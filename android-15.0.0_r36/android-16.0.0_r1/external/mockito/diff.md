```diff
diff --git a/Android.bp b/Android.bp
index f26703d..96fc7eb 100644
--- a/Android.bp
+++ b/Android.bp
@@ -64,6 +64,8 @@ java_library_static {
             // dexmaker instead and including it causes conflicts.
             exclude_srcs: [
                 "src/main/java/org/mockito/internal/creation/bytebuddy/**/*.java",
+                "src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java",
+                "src/main/java/org/mockito/internal/util/reflection/InstrumentationMemberAccessor.java",
             ],
         },
         host: {
@@ -77,10 +79,11 @@ java_library_static {
 
     errorprone: {
         javacflags: [
-            "-Xep:CollectionIncompatibleType:WARN",  // b/74213384
+            "-Xep:CollectionIncompatibleType:WARN", // b/74213384
             "-Xep:BoxedPrimitiveEquality:WARN",
+            "-Xep:ReturnValueIgnored:WARN",
         ],
-    }
+    },
 }
 
 // Compatibility library for Maven artifact naming scheme
diff --git a/METADATA b/METADATA
index d97975c..a0d0f05 100644
--- a/METADATA
+++ b/METADATA
@@ -1,3 +1,20 @@
+# This project was upgraded with external_updater.
+# Usage: tools/external_updater/updater.sh update external/mockito
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
+
+name: "mockito"
+description: "Most popular mocking framework for Java"
 third_party {
   license_type: NOTICE
+  last_upgrade_date {
+    year: 2025
+    month: 3
+    day: 17
+  }
+  identifier {
+    type: "Archive"
+    value: "https://github.com/mockito/mockito/archive/v4.3.0.tar.gz"
+    version: "v4.3.0"
+    primary_source: true
+  }
 }
diff --git a/OWNERS b/OWNERS
index 5119321..13872f3 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,2 +1,3 @@
 paulduffin@google.com
 xutan@google.com
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/README.version b/README.version
deleted file mode 100644
index 3cce812..0000000
--- a/README.version
+++ /dev/null
@@ -1,13 +0,0 @@
-URL: https://github.com/mockito/mockito
-Version: v2.23.0
-License: Apache 2.0
-Description: Mockito is a mocking framework with a clean and simple API.
-
-For Android, we need to combine Mockito with a MockMaker provided by the
-Dexmaker module.
-
-The source can be updated using the update_source.sh script.
-
-Local Modifications:
-        Fixed DefaultMockitoSession constructor. (I14ed7c032a974c3a65caaf091d36d9667ea331b6)
-        New API to clean up all inline mocks after test (8bdfbf053ab6e4fc14a3eaecb613f5838fdf0f09)
diff --git a/build.gradle b/build.gradle
index 4ecc4f3..4c37b6e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,63 +1,145 @@
-apply plugin: 'java'
+buildscript {
+    repositories {
+        mavenLocal() //for local testing of mockito-release-tools
+        google()
+        maven { url 'https://plugins.gradle.org/m2/' }
+    }
 
-configurations {
-    // similar to 'default', export compile-time dependencies
-    host.extendsFrom(hostCompile)
-    target.extendsFrom(targetCompile)
+    dependencies {
+        classpath 'gradle.plugin.com.hierynomus.gradle.plugins:license-gradle-plugin:0.16.1'
+        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:2.0.2'
+
+        classpath "io.github.gradle-nexus:publish-plugin:1.1.0"
+        classpath 'org.shipkit:shipkit-changelog:1.1.15'
+        classpath 'org.shipkit:shipkit-auto-version:1.1.19'
+
+        classpath 'com.google.googlejavaformat:google-java-format:1.13.0'
+        classpath 'com.android.tools.build:gradle:4.2.0'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10"
+    }
 }
 
-sourceSets {
-    host {
-        java {
-            srcDirs = ['src', 'cglib-and-asm/src']
-        }
+plugins {
+    id 'com.diffplug.spotless' version '6.2.0'
+    id 'eclipse'
+    id 'com.github.ben-manes.versions' version '0.41.0'
+    id 'biz.aQute.bnd.builder' version '6.1.0'
+    id 'ru.vyarus.animalsniffer' version '1.5.2'
+}
+
+description = 'Mockito mock objects library core API and implementation'
+
+apply plugin: 'base'
+archivesBaseName = 'mockito-core'
+
+apply from: 'gradle/shipkit.gradle'
+
+apply from: 'gradle/root/ide.gradle'
+apply from: 'gradle/root/gradle-fix.gradle'
+apply from: 'gradle/java-library.gradle'
+apply from: 'gradle/license.gradle'
+apply from: 'gradle/root/coverage.gradle'
+
+apply from: 'gradle/mockito-core/inline-mock.gradle'
+apply from: 'gradle/mockito-core/osgi.gradle'
+apply from: 'gradle/mockito-core/javadoc.gradle'
+apply from: 'gradle/mockito-core/testing.gradle'
+
+apply from: 'gradle/dependencies.gradle'
+
+allprojects { proj ->
+    repositories {
+        mavenCentral()
+        google()
+    }
+    plugins.withId('java') {
+        proj.apply from: "$rootDir/gradle/errorprone.gradle"
+    }
+    tasks.withType(JavaCompile) {
+        //I don't believe those warnings add value given modern IDEs
+        options.warnings = false
+        options.encoding = 'UTF-8'
+    }
+    tasks.withType(Javadoc) {
+        options.addStringOption('Xdoclint:none', '-quiet')
+        options.addStringOption('encoding', 'UTF-8')
+        options.addStringOption('charSet', 'UTF-8')
+        options.setSource('8')
     }
 
-    target {
-        java {
-            srcDirs = ['src']
-            exclude 'org/mockito/internal/creation/cglib/**',
-                    'org/mockito/internal/creation/jmock/**',
-                    'org/mockito/internal/creation/AbstractMockitoMethodProxy.java',
-                    'org/mockito/internal/creation/AcrossJVMSerializationFeature.java',
-                    'org/mockito/internal/creation/CglibMockMaker.java',
-                    'org/mockito/internal/creation/DelegatingMockitoMethodProxy.java',
-                    'org/mockito/internal/creation/MethodInterceptorFilter.java',
-                    'org/mockito/internal/creation/MockitoMethodProxy.java',
-                    'org/mockito/internal/creation/SerializableMockitoMethodProxy.java',
-                    'org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java',
-                    'org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java',
-                    'org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java'
-        }
+    tasks.withType(AbstractArchiveTask) {
+        preserveFileTimestamps = false
+        reproducibleFileOrder = true
     }
+
+    apply plugin: 'checkstyle'
+    checkstyle {
+       configFile = rootProject.file('config/checkstyle/checkstyle.xml')
+    }
+}
+
+configurations {
+    testUtil //TODO move to separate project
 }
 
 dependencies {
-    targetCompile project(':hamcrest')
-    targetCompile project(':objenesis')
-    targetCompile project(path: ':junit', configuration: 'target')
+    api libraries.bytebuddy, libraries.bytebuddyagent
+
+    compileOnly libraries.junit4, libraries.hamcrest, libraries.opentest4j
+    implementation libraries.objenesis
+
+    testImplementation libraries.assertj
+
+    //putting 'provided' dependencies on test compile and runtime classpath
+    testCompileOnly configurations.compileOnly
+    testRuntimeOnly configurations.compileOnly
+
+    testUtil sourceSets.test.output
 
-    hostCompile project(':hamcrest')
-    hostCompile project(':objenesis')
-    hostCompile project(path: ':junit', configuration: 'host')
-    hostCompile 'org.apache.ant:ant:1.8.0'
+    signature 'org.codehaus.mojo.signature:java18:1.0@signature'
+    signature 'net.sf.androidscents.signature:android-api-level-24:7.0_r2@signature'
 }
 
-task targetJar(type: Jar) {
-    from sourceSets.target.output
-    dependsOn targetClasses
-    baseName "mockito"
-    classifier "target"
+animalsniffer {
+    sourceSets = [sourceSets.main]
+    annotation = 'org.mockito.internal.SuppressSignatureCheck'
 }
 
-task hostJar(type: Jar) {
-    from sourceSets.host.output
-    dependsOn hostClasses
-    baseName "mockito"
-    classifier "host"
+spotless {
+    // We run the check separately on CI, so don't run this by default
+    enforceCheck = false
+
+    java {
+        licenseHeaderFile rootProject.file('config/spotless/spotless.header')
+
+        custom 'google-java-format', { source ->
+            com.google.googlejavaformat.java.JavaFormatterOptions options = new com.google.googlejavaformat.java.JavaFormatterOptions.Builder()
+                    .style(com.google.googlejavaformat.java.JavaFormatterOptions.Style.AOSP)
+                    .formatJavadoc(false)
+                    .build()
+            com.google.googlejavaformat.java.Formatter formatter = new com.google.googlejavaformat.java.Formatter(options)
+            return formatter.formatSource(source)
+        }
+
+        // This test contains emulation of same-line stubbings. The formatter would put them on a separate line.
+        targetExclude 'src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java'
+    }
 }
 
-artifacts {
-    host hostJar
-    target targetJar
+
+//workaround for #1444, delete when Shipkit bug is fixed
+subprojects {
+	eclipse {
+		project {
+			name = rootProject.name + '-' + project.name
+		}
+	}
+
+    afterEvaluate {
+        def lib = publishing.publications.javaLibrary
+        if(lib && !lib.artifactId.startsWith("mockito-")) {
+            lib.artifactId = "mockito-" + lib.artifactId
+        }
+    }
 }
+//end workaround
diff --git a/patches/FieldSetter.patch b/patches/FieldSetter.patch
new file mode 100644
index 0000000..759c26e
--- /dev/null
+++ b/patches/FieldSetter.patch
@@ -0,0 +1,74 @@
+diff --git a/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java b/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java
+new file mode 100644
+index 0000000..9d1b756
+--- /dev/null
++++ b/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java
+@@ -0,0 +1,32 @@
++/*
++ * Copyright (c) 2007 Mockito contributors
++ * This program is made available under the terms of the MIT License.
++ */
++package org.mockito.internal.util.reflection;
++
++import java.lang.reflect.AccessibleObject;
++
++class AccessibilityChanger {
++
++    private Boolean wasAccessible = null;
++
++    /**
++     * safely disables access
++     */
++    public void safelyDisableAccess(AccessibleObject accessibleObject) {
++        assert wasAccessible != null : "accessibility info shall not be null";
++        try {
++            accessibleObject.setAccessible(wasAccessible);
++        } catch (Throwable t) {
++            //ignore
++        }
++    }
++
++    /**
++     * changes the accessibleObject accessibility and returns true if accessibility was changed
++     */
++    public void enableAccess(AccessibleObject accessibleObject) {
++        wasAccessible = accessibleObject.isAccessible();
++        accessibleObject.setAccessible(true);
++    }
++}
+diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java b/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java
+new file mode 100644
+index 0000000..35b1210
+--- /dev/null
++++ b/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java
+@@ -0,0 +1,30 @@
++/*
++ * Copyright (c) 2007 Mockito contributors
++ * This program is made available under the terms of the MIT License.
++ */
++package org.mockito.internal.util.reflection;
++
++import java.lang.reflect.Field;
++
++/** Do not use. To be removed after last usage is gone. */
++@Deprecated
++public class FieldSetter {
++
++    private FieldSetter(){}
++
++    /** Do not use. To be removed after last usage is gone. */
++    @Deprecated
++    public static void setField(Object target, Field field,Object value) {
++        AccessibilityChanger changer = new AccessibilityChanger();
++        changer.enableAccess(field);
++        try {
++            field.set(target, value);
++        } catch (IllegalAccessException e) {
++            throw new RuntimeException("Access not authorized on field '" + field + "' of object '" + target + "' with value: '" + value + "'", e);
++        } catch (IllegalArgumentException e) {
++            throw new RuntimeException("Wrong argument on field '" + field + "' of object '" + target + "' with value: '" + value + "', \n" +
++                    "reason : " + e.getMessage(), e);
++        }
++        changer.safelyDisableAccess(field);
++    }
++}
diff --git a/patches/GenericMetadataSupport.patch b/patches/GenericMetadataSupport.patch
new file mode 100644
index 0000000..6bcc64a
--- /dev/null
+++ b/patches/GenericMetadataSupport.patch
@@ -0,0 +1,13 @@
+diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+index ef64c5bb6..c7edd9cea 100644
+--- a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
++++ b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+@@ -91,7 +91,7 @@ public abstract class GenericMetadataSupport {
+ 
+             Class<?> rawType = extractRawTypeOf(typeToRegister);
+             typesToRegister.add(rawType.getGenericSuperclass());
+-            typesToRegister.addAll(Arrays.asList(rawType.getGenericInterfaces()));
++            Collections.addAll(typesToRegister, rawType.getGenericInterfaces());
+         }
+     }
+ 
diff --git a/patches/remove_opentest4j.patch b/patches/remove_opentest4j.patch
new file mode 100644
index 0000000..c8fd3f2
--- /dev/null
+++ b/patches/remove_opentest4j.patch
@@ -0,0 +1,38 @@
+diff --git a/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java b/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java
+index 2810520..6589c5a 100644
+--- a/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java
++++ b/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java
+@@ -7,30 +7,13 @@ package org.mockito.exceptions.verification.opentest4j;
+ import static org.mockito.internal.util.StringUtil.removeFirstLine;
+ 
+ import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+-import org.opentest4j.AssertionFailedError;
++import org.mockito.exceptions.base.MockitoAssertionError;
+ 
+-public class ArgumentsAreDifferent extends AssertionFailedError {
+ 
+-    private static final long serialVersionUID = 1L;
+-    private final String message;
+-    private final StackTraceElement[] unfilteredStackTrace;
++public class ArgumentsAreDifferent extends MockitoAssertionError {
+ 
+     public ArgumentsAreDifferent(String message, String wanted, String actual) {
+-        super(message, wanted, actual);
+-        this.message = message;
+-
+-        unfilteredStackTrace = getStackTrace();
+-        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
+-        filter.filter(this);
+-    }
+-
+-    @Override
+-    public String getMessage() {
+-        return message;
+-    }
+-
+-    public StackTraceElement[] getUnfilteredStackTrace() {
+-        return unfilteredStackTrace;
++        super(message);
+     }
+ 
+     @Override
diff --git a/post_update.sh b/post_update.sh
new file mode 100644
index 0000000..9a6dc2f
--- /dev/null
+++ b/post_update.sh
@@ -0,0 +1,45 @@
+#!/bin/bash
+
+# $1 Path to the new version.
+# $2 Path to the old version.
+
+excludes=(
+.checkstyle
+.editorconfig
+.gitattributes
+.github/
+.gitignore
+README.md
+SECURITY.md
+check_reproducibility.sh
+config/
+doc/
+gradle.properties
+gradle/
+gradlew
+gradlew.bat
+src/conf/
+src/javadoc/
+subprojects/androidTest/
+subprojects/deprecatedPluginsTest/
+subprojects/errorprone/
+subprojects/extTest/
+subprojects/groovyTest/
+subprojects/junit-jupiter/
+subprojects/junitJupiterExtensionTest/
+subprojects/junitJupiterInlineMockMakerExtensionTest/
+subprojects/junitJupiterParallelTest/
+subprojects/kotlinReleaseCoroutinesTest/
+subprojects/kotlinTest/
+subprojects/memory-test/
+subprojects/module-test/
+subprojects/osgi-test/
+subprojects/bom
+subprojects/groovyInlineTest/
+subprojects/proxy
+subprojects/subclass
+)
+
+for remove in ${excludes[@]}; do
+  rm -rf "$1/$remove"
+done
diff --git a/settings.gradle.kts b/settings.gradle.kts
new file mode 100644
index 0000000..f5a786d
--- /dev/null
+++ b/settings.gradle.kts
@@ -0,0 +1,62 @@
+plugins {
+  id("com.gradle.enterprise").version("3.3.4")
+}
+
+include("inline",
+    "proxy",
+    "extTest",
+    "groovyTest",
+    "kotlinTest",
+    "kotlinReleaseCoroutinesTest",
+    "android",
+    "junit-jupiter",
+    "junitJupiterExtensionTest",
+    "junitJupiterInlineMockMakerExtensionTest",
+    "module-test",
+    "memory-test",
+    "errorprone",
+    "junitJupiterParallelTest",
+    "osgi-test",
+    "bom")
+
+if (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17) && (System.getenv("ANDROID_SDK_ROOT") != null || File(".local.properties").exists())) {
+    include("androidTest")
+} else {
+    logger.info("Not including android test project due to missing SDK configuration")
+}
+
+rootProject.name = "mockito"
+
+val koltinBuildScriptProject = hashSetOf("junitJupiterExtensionTest", "junitJupiterInlineMockMakerExtensionTest")
+
+fun buildFileExtensionFor(projectName: String) =
+    if (projectName in koltinBuildScriptProject) ".gradle.kts" else ".gradle"
+
+fun buildFileFor(projectName: String) =
+    "$projectName${buildFileExtensionFor(projectName)}"
+
+rootProject.children.forEach { project ->
+    val projectDirName = "subprojects/${project.name}"
+    project.projectDir = File(settingsDir, projectDirName)
+    project.buildFileName = buildFileFor(project.name)
+    require(project.projectDir.isDirectory) {
+        "Project directory ${project.projectDir} for project ${project.name} does not exist."
+    }
+    require(project.buildFile.isFile) {
+        "Build file ${project.buildFile} for project ${project.name} does not exist."
+    }
+}
+
+//Posting Build scans to https://scans.gradle.com
+gradleEnterprise {
+    buildScan {
+        termsOfServiceUrl = "https://gradle.com/terms-of-service"
+        termsOfServiceAgree = "yes"
+    }
+}
+
+buildCache {
+    local {
+        isEnabled = !System.getenv().containsKey("CI")
+    }
+}
diff --git a/src/main/java/org/mockito/AdditionalAnswers.java b/src/main/java/org/mockito/AdditionalAnswers.java
index 214eaa5..1ba790f 100644
--- a/src/main/java/org/mockito/AdditionalAnswers.java
+++ b/src/main/java/org/mockito/AdditionalAnswers.java
@@ -4,6 +4,8 @@
  */
 package org.mockito;
 
+import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
+
 import java.util.Collection;
 
 import org.mockito.internal.stubbing.answers.AnswersWithDelay;
@@ -16,20 +18,20 @@ import org.mockito.stubbing.Answer2;
 import org.mockito.stubbing.Answer3;
 import org.mockito.stubbing.Answer4;
 import org.mockito.stubbing.Answer5;
+import org.mockito.stubbing.Answer6;
 import org.mockito.stubbing.VoidAnswer1;
 import org.mockito.stubbing.VoidAnswer2;
 import org.mockito.stubbing.VoidAnswer3;
 import org.mockito.stubbing.VoidAnswer4;
 import org.mockito.stubbing.VoidAnswer5;
-
-import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
+import org.mockito.stubbing.VoidAnswer6;
 
 /**
  * Additional answers provides factory methods for answers.
  *
  * <p>Currently offer answers that can return the parameter of an invocation at a certain position,
  * along with answers that draw on a strongly typed interface to provide a neater way to write custom answers
- * that either return a value or are void (see answer interfaces in {@link org.mockito.stubbing}).
+ * that either return a value or are void (see answer interfaces in org.mockito.stubbing).
  *
  * <p>See factory methods for more information : {@link #returnsFirstArg}, {@link #returnsSecondArg},
  * {@link #returnsLastArg}, {@link #returnsArgAt}, {@link #answer} and {@link #answerVoid}
@@ -37,7 +39,7 @@ import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.t
  * @since 1.9.5
  */
 @SuppressWarnings("unchecked")
-public class AdditionalAnswers {
+public final class AdditionalAnswers {
     /**
      * Returns the first parameter of an invocation.
      *
@@ -274,7 +276,7 @@ public class AdditionalAnswers {
      * This feature suffers from the same drawback as the spy.
      * The mock will call the delegate if you use regular when().then() stubbing style.
      * Since the real implementation is called this might have some side effects.
-     * Therefore you should to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:
+     * Therefore you should use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:
      *
      * <pre class="code"><code class="java">
      *   List listWithDelegate = mock(List.class, AdditionalAnswers.delegatesTo(awesomeList));
@@ -306,7 +308,7 @@ public class AdditionalAnswers {
      *   when(mock.foo()).thenReturn(1, 2, 3);
      *
      *   //is equivalent to:
-     *   when(mock.foo()).thenAnswer(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));
+     *   when(mock.foo()).thenAnswer(AdditionalAnswers.returnsElementsOf(Arrays.asList(1, 2, 3)));
      * </code></pre>
      *
      * @param elements The collection of elements to return.
@@ -328,7 +330,6 @@ public class AdditionalAnswers {
      *
      * @since 2.8.44
      */
-    @Incubating
     public static <T> Answer<T> answersWithDelay(long sleepyTime, Answer<T> answer) {
         return (Answer<T>) new AnswersWithDelay(sleepyTime, (Answer<Object>) answer);
     }
@@ -342,7 +343,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <T, A> Answer<T> answer(Answer1<T, A> answer) {
         return toAnswer(answer);
     }
@@ -355,7 +355,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <A> Answer<Void> answerVoid(VoidAnswer1<A> answer) {
         return toAnswer(answer);
     }
@@ -370,7 +369,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <T, A, B> Answer<T> answer(Answer2<T, A, B> answer) {
         return toAnswer(answer);
     }
@@ -384,7 +382,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <A, B> Answer<Void> answerVoid(VoidAnswer2<A, B> answer) {
         return toAnswer(answer);
     }
@@ -400,7 +397,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <T, A, B, C> Answer<T> answer(Answer3<T, A, B, C> answer) {
         return toAnswer(answer);
     }
@@ -415,7 +411,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <A, B, C> Answer<Void> answerVoid(VoidAnswer3<A, B, C> answer) {
         return toAnswer(answer);
     }
@@ -432,7 +427,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <T, A, B, C, D> Answer<T> answer(Answer4<T, A, B, C, D> answer) {
         return toAnswer(answer);
     }
@@ -448,7 +442,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <A, B, C, D> Answer<Void> answerVoid(VoidAnswer4<A, B, C, D> answer) {
         return toAnswer(answer);
     }
@@ -466,7 +459,6 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <T, A, B, C, D, E> Answer<T> answer(Answer5<T, A, B, C, D, E> answer) {
         return toAnswer(answer);
     }
@@ -484,8 +476,46 @@ public class AdditionalAnswers {
      * @return the answer object to use
      * @since 2.1.0
      */
-    @Incubating
     public static <A, B, C, D, E> Answer<Void> answerVoid(VoidAnswer5<A, B, C, D, E> answer) {
         return toAnswer(answer);
     }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * idiomatically in Java 8
+     *
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @param <E> input parameter type 5
+     * @param <F> input parameter type 6
+     * @return the answer object to use
+     * @since 2.26.0
+     */
+    public static <T, A, B, C, D, E, F> Answer<T> answer(Answer6<T, A, B, C, D, E, F> answer) {
+        return toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * idiomatically in Java 8
+     *
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @param <E> input parameter type 5
+     * @param <F> input parameter type 6
+     * @return the answer object to use
+     * @since 2.26.0
+     */
+    public static <A, B, C, D, E, F> Answer<Void> answerVoid(VoidAnswer6<A, B, C, D, E, F> answer) {
+        return toAnswer(answer);
+    }
+
+    private AdditionalAnswers() {}
 }
diff --git a/src/main/java/org/mockito/AdditionalMatchers.java b/src/main/java/org/mockito/AdditionalMatchers.java
index 8f6d11c..2cb71c6 100644
--- a/src/main/java/org/mockito/AdditionalMatchers.java
+++ b/src/main/java/org/mockito/AdditionalMatchers.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
@@ -17,11 +16,11 @@ import org.mockito.internal.matchers.LessOrEqual;
 import org.mockito.internal.matchers.LessThan;
 
 /**
- * See {@link Matchers} for general info about matchers.
+ * See {@link ArgumentMatchers} for general info about matchers.
  * <p>
  * AdditionalMatchers provides rarely used matchers, kept only for somewhat compatibility with EasyMock.
  * Use additional matchers very judiciously because they may impact readability of a test.
- * It is recommended to use matchers from {@link Matchers} and keep stubbing and verification simple.
+ * It is recommended to use matchers from {@link ArgumentMatchers} and keep stubbing and verification simple.
  * <p>
  * Example of using logical and(), not(), or() matchers:
  *
@@ -39,7 +38,7 @@ import org.mockito.internal.matchers.LessThan;
  * Scroll down to see all methods - full list of matchers.
  */
 @SuppressWarnings("ALL")
-public class AdditionalMatchers {
+public final class AdditionalMatchers {
 
     /**
      * argument greater than or equal the given value.
@@ -1055,4 +1054,6 @@ public class AdditionalMatchers {
     private static void reportMatcher(ArgumentMatcher<?> matcher) {
         mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);
     }
+
+    private AdditionalMatchers() {}
 }
diff --git a/src/main/java/org/mockito/Answers.java b/src/main/java/org/mockito/Answers.java
index 1ba50d9..30dc307 100644
--- a/src/main/java/org/mockito/Answers.java
+++ b/src/main/java/org/mockito/Answers.java
@@ -5,11 +5,11 @@
 package org.mockito;
 
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
-import org.mockito.internal.stubbing.defaultanswers.TriesToReturnSelf;
 import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsMocks;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls;
+import org.mockito.internal.stubbing.defaultanswers.TriesToReturnSelf;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -24,7 +24,7 @@ import org.mockito.stubbing.Answer;
  * </code></pre>
  * <b>This is not the full list</b> of Answers available in Mockito. Some interesting answers can be found in org.mockito.stubbing.answers package.
  */
-public enum Answers implements Answer<Object>{
+public enum Answers implements Answer<Object> {
     /**
      * The default configured answer of every mock.
      *
@@ -52,7 +52,6 @@ public enum Answers implements Answer<Object>{
      */
     RETURNS_MOCKS(new ReturnsMocks()),
 
-
     /**
      * An answer that returns <strong>deep stubs</strong> (not mocks).
      *
@@ -78,8 +77,7 @@ public enum Answers implements Answer<Object>{
      *
      * @see org.mockito.Mockito#RETURNS_SELF
      */
-    RETURNS_SELF(new TriesToReturnSelf())
-    ;
+    RETURNS_SELF(new TriesToReturnSelf());
 
     private final Answer<Object> implementation;
 
@@ -87,15 +85,7 @@ public enum Answers implements Answer<Object>{
         this.implementation = implementation;
     }
 
-    /**
-     * @deprecated as of 2.1.0 Use the enum-constant directly, instead of this getter. This method will be removed in a future release<br>
-     * E.g. instead of <code>Answers.CALLS_REAL_METHODS.get()</code> use <code>Answers.CALLS_REAL_METHODS</code> .
-     */
-    @Deprecated
-    public Answer<Object> get() {
-        return this;
-    }
-
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         return implementation.answer(invocation);
     }
diff --git a/src/main/java/org/mockito/ArgumentCaptor.java b/src/main/java/org/mockito/ArgumentCaptor.java
index 7011c92..afb3add 100644
--- a/src/main/java/org/mockito/ArgumentCaptor.java
+++ b/src/main/java/org/mockito/ArgumentCaptor.java
@@ -15,7 +15,7 @@ import org.mockito.internal.matchers.CapturingMatcher;
  *
  * <p>
  * Mockito verifies argument values in natural java style: by using an equals() method.
- * This is also the recommended way of matching arguments because it makes tests clean & simple.
+ * This is also the recommended way of matching arguments because it makes tests clean and simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre class="code"><code class="java">
@@ -40,7 +40,7 @@ import org.mockito.internal.matchers.CapturingMatcher;
  *
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
- * Both techniques can be used for making sure certain arguments where passed to mocks.
+ * Both techniques can be used for making sure certain arguments were passed to mocks.
  * However, ArgumentCaptor may be a better fit if:
  * <ul>
  * <li>custom argument matcher is not likely to be reused</li>
@@ -59,9 +59,9 @@ import org.mockito.internal.matchers.CapturingMatcher;
  * @see Captor
  * @since 1.8.0
  */
+@CheckReturnValue
 public class ArgumentCaptor<T> {
 
-
     private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
     private final Class<? extends T> clazz;
 
@@ -80,7 +80,7 @@ public class ArgumentCaptor<T> {
      * @return null or default values
      */
     public T capture() {
-        Mockito.argThat(capturingMatcher);
+        T ignored = Mockito.argThat(capturingMatcher);
         return defaultValue(clazz);
     }
 
@@ -145,7 +145,7 @@ public class ArgumentCaptor<T> {
      * @param <U> Type of object captured by the newly built ArgumentCaptor
      * @return A new ArgumentCaptor
      */
-    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
+    public static <U, S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
         return new ArgumentCaptor<U>(clazz);
     }
 }
diff --git a/src/main/java/org/mockito/ArgumentMatcher.java b/src/main/java/org/mockito/ArgumentMatcher.java
index a1e27c9..d0324b6 100644
--- a/src/main/java/org/mockito/ArgumentMatcher.java
+++ b/src/main/java/org/mockito/ArgumentMatcher.java
@@ -44,7 +44,7 @@ package org.mockito;
  * </ul>
  *
  * <p>
- * Implementations of this interface can be used with {@link Matchers#argThat} method.
+ * Implementations of this interface can be used with {@link ArgumentMatchers#argThat} method.
  * Use <code>toString()</code> method for description of the matcher
  * - it is printed in verification errors.
  *
@@ -61,7 +61,7 @@ package org.mockito;
  *
  * List mock = mock(List.class);
  *
- * when(mock.addAll(argThat(new ListOfTwoElements))).thenReturn(true);
+ * when(mock.addAll(argThat(new ListOfTwoElements()))).thenReturn(true);
  *
  * mock.addAll(Arrays.asList(&quot;one&quot;, &quot;two&quot;));
  *
@@ -80,11 +80,11 @@ package org.mockito;
  * and use a lambda, e.g.:
  *
  * <pre class="code"><code class="java">
- *   verify(mock).addAll(<b>argThat(list -> list.size() == 2)</b>);
+ *   verify(mock).addAll(<b>argThat(list -&gt; list.size() == 2)</b>);
  * </code></pre>
  *
  * <p>
- * Read more about other matchers in javadoc for {@link Matchers} class.
+ * Read more about other matchers in javadoc for {@link ArgumentMatchers} class.
  * <h2>2.1.0 migration guide</h2>
  *
  * All existing custom implementations of <code>ArgumentMatcher</code> will no longer compile.
diff --git a/src/main/java/org/mockito/ArgumentMatchers.java b/src/main/java/org/mockito/ArgumentMatchers.java
index 4a6c84d..d969bc7 100644
--- a/src/main/java/org/mockito/ArgumentMatchers.java
+++ b/src/main/java/org/mockito/ArgumentMatchers.java
@@ -4,6 +4,9 @@
  */
 package org.mockito;
 
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+import static org.mockito.internal.util.Primitives.defaultValue;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -12,6 +15,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Pattern;
+
 import org.mockito.internal.matchers.Any;
 import org.mockito.internal.matchers.Contains;
 import org.mockito.internal.matchers.EndsWith;
@@ -25,15 +29,9 @@ import org.mockito.internal.matchers.StartsWith;
 import org.mockito.internal.matchers.apachecommons.ReflectionEquals;
 import org.mockito.internal.util.Primitives;
 
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-import static org.mockito.internal.util.Primitives.defaultValue;
-
 /**
  * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.
  *
- * <p>
- * {@link Mockito} extends ArgumentMatchers so to get access to all matchers just import Mockito class statically.
- *
  * <pre class="code"><code class="java">
  * //stubbing using anyInt() argument matcher
  * when(mockedList.get(anyInt())).thenReturn("element");
@@ -89,10 +87,10 @@ import static org.mockito.internal.util.Primitives.defaultValue;
  * </code></pre>
  *
  * <p>
- * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.
+ * Matcher methods like <code>any()</code>, <code>eq()</code> <b>do not</b> return matchers.
  * Internally, they record a matcher on a stack and return a dummy value (usually null).
  * This implementation is due to static type safety imposed by java compiler.
- * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.
+ * The consequence is that you cannot use <code>any()</code>, <code>eq()</code> methods outside of verified/stubbed method.
  * </p>
  *
  * <h1>Additional matchers</h1>
@@ -111,6 +109,7 @@ import static org.mockito.internal.util.Primitives.defaultValue;
  *
  * @see AdditionalMatchers
  */
+@CheckReturnValue
 @SuppressWarnings("unchecked")
 public class ArgumentMatchers {
 
@@ -119,8 +118,6 @@ public class ArgumentMatchers {
      *
      * <p>
      * See examples in javadoc for {@link ArgumentMatchers} class
-     *
-     * This is an alias of: {@link #anyObject()} and {@link #any(java.lang.Class)}
      * </p>
      *
      * <p>
@@ -134,34 +131,11 @@ public class ArgumentMatchers {
      * @return <code>null</code>.
      *
      * @see #any(Class)
-     * @see #anyObject()
-     * @see #anyVararg()
      * @see #anyChar()
      * @see #anyInt()
      * @see #anyBoolean()
-     * @see #anyCollectionOf(Class)
      */
     public static <T> T any() {
-        return anyObject();
-    }
-
-    /**
-     * Matches anything, including <code>null</code>.
-     *
-     * <p>
-     * This is an alias of: {@link #any()} and {@link #any(java.lang.Class)}.
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @return <code>null</code>.
-     * @see #any()
-     * @see #any(Class)
-     * @see #notNull()
-     * @see #notNull(Class)
-     * @deprecated This will be removed in Mockito 3.0 (which will be java 8 only)
-     */
-    @Deprecated
-    public static <T> T anyObject() {
         reportMatcher(Any.ANY);
         return null;
     }
@@ -179,7 +153,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow non-null instance of <code></code>, thus <code>null</code> is not anymore a valid value.
      * As reference are nullable, the suggested API to <strong>match</strong> <code>null</code>
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -187,7 +161,7 @@ public class ArgumentMatchers {
      * <ul>
      *     <li>For primitive types use {@link #anyChar()} family.</li>
      *     <li>Since Mockito 2.1.0 this method will perform a type check thus <code>null</code> values are not authorized.</li>
-     *     <li>Since mockito 2.1.0 {@link #any()} and {@link #anyObject()} are not anymore aliases of this method.</li>
+     *     <li>Since mockito 2.1.0 {@link #any()} is no longer an alias of this method.</li>
      * </ul>
      * </p>
      *
@@ -195,13 +169,9 @@ public class ArgumentMatchers {
      * @param type the class of the accepted type.
      * @return <code>null</code>.
      * @see #any()
-     * @see #anyObject()
-     * @see #anyVararg()
      * @see #isA(Class)
      * @see #notNull()
-     * @see #notNull(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <T> T any(Class<T> type) {
         reportMatcher(new InstanceOf.VarArgAware(type, "<any " + type.getCanonicalName() + ">"));
@@ -223,50 +193,13 @@ public class ArgumentMatchers {
         return defaultValue(type);
     }
 
-    /**
-     * Any vararg, meaning any number and values of arguments.
-     *
-     * <p>
-     * Example:
-     * <pre class="code"><code class="java">
-     * //verification:
-     * mock.foo(1, 2);
-     * mock.foo(1, 2, 3, 4);
-     *
-     * verify(mock, times(2)).foo(anyVararg());
-     *
-     * //stubbing:
-     * when(mock.foo(anyVararg()).thenReturn(100);
-     *
-     * //prints 100
-     * System.out.println(mock.foo(1, 2));
-     * //also prints 100
-     * System.out.println(mock.foo(1, 2, 3, 4));
-     * </code></pre>
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @return <code>null</code>.
-     * @see #any()
-     * @see #any(Class)
-     * @deprecated as of 2.1.0 use {@link #any()}
-     */
-    @Deprecated
-    public static <T> T anyVararg() {
-        any();
-        return null;
-    }
-
     /**
      * Any <code>boolean</code> or <strong>non-null</strong> <code>Boolean</code>
      *
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Boolean</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -276,7 +209,6 @@ public class ArgumentMatchers {
      *
      * @return <code>false</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static boolean anyBoolean() {
         reportMatcher(new InstanceOf(Boolean.class, "<any boolean>"));
@@ -289,7 +221,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Byte</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -299,7 +231,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static byte anyByte() {
         reportMatcher(new InstanceOf(Byte.class, "<any byte>"));
@@ -312,7 +243,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Character</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -322,7 +253,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static char anyChar() {
         reportMatcher(new InstanceOf(Character.class, "<any char>"));
@@ -335,7 +265,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Integer</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -345,7 +275,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static int anyInt() {
         reportMatcher(new InstanceOf(Integer.class, "<any integer>"));
@@ -358,7 +287,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Long</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -368,7 +297,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static long anyLong() {
         reportMatcher(new InstanceOf(Long.class, "<any long>"));
@@ -381,7 +309,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Float</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -391,7 +319,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static float anyFloat() {
         reportMatcher(new InstanceOf(Float.class, "<any float>"));
@@ -404,7 +331,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Double</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -414,7 +341,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static double anyDouble() {
         reportMatcher(new InstanceOf(Double.class, "<any double>"));
@@ -427,7 +353,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow valued <code>Short</code>, thus <code>null</code> is not anymore a valid value.
      * As primitive wrappers are nullable, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -437,7 +363,6 @@ public class ArgumentMatchers {
      *
      * @return <code>0</code>.
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static short anyShort() {
         reportMatcher(new InstanceOf(Short.class, "<any short>"));
@@ -450,7 +375,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>String</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -460,7 +385,6 @@ public class ArgumentMatchers {
      *
      * @return empty String ("")
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static String anyString() {
         reportMatcher(new InstanceOf(String.class, "<any string>"));
@@ -473,7 +397,7 @@ public class ArgumentMatchers {
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>List</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -482,56 +406,20 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return empty List.
-     * @see #anyListOf(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <T> List<T> anyList() {
         reportMatcher(new InstanceOf(List.class, "<any List>"));
         return new ArrayList<T>(0);
     }
 
-    /**
-     * Any <strong>non-null</strong> <code>List</code>.
-     *
-     * Generic friendly alias to {@link ArgumentMatchers#anyList()}. It's an alternative to
-     * <code>&#064;SuppressWarnings("unchecked")</code> to keep code clean of compiler warnings.
-     *
-     * <p>
-     * This method doesn't do type checks of the list content with the given type parameter, it is only there
-     * to avoid casting in the code.
-     * </p>
-     *
-     * <p>
-     * Since Mockito 2.1.0, only allow non-null <code>List</code>.
-     * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
-     * 1.x.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @param clazz Type owned by the list to avoid casting
-     * @return empty List.
-     * @see #anyList()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> List<T> anyListOf(Class<T> clazz) {
-        return anyList();
-    }
-
     /**
      * Any <strong>non-null</strong> <code>Set</code>.
      *
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>Set</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -540,58 +428,20 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return empty Set
-     * @see #anySetOf(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <T> Set<T> anySet() {
         reportMatcher(new InstanceOf(Set.class, "<any set>"));
         return new HashSet<T>(0);
     }
 
-    /**
-     * Any <strong>non-null</strong> <code>Set</code>.
-     *
-     * <p>
-     * Generic friendly alias to {@link ArgumentMatchers#anySet()}.
-     * It's an alternative to <code>&#064;SuppressWarnings("unchecked")</code> to keep code clean of compiler warnings.
-     * </p>
-     *
-     * <p>
-     * This method doesn't do type checks of the set content with the given type parameter, it is only there
-     * to avoid casting in the code.
-     * </p>
-     *
-     * <p>
-     * Since Mockito 2.1.0, only allow non-null <code>Set</code>.
-     * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
-     * 1.x.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @param clazz Type owned by the Set to avoid casting
-     * @return empty Set
-     * @see #anySet()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> Set<T> anySetOf(Class<T> clazz) {
-        return anySet();
-    }
-
     /**
      * Any <strong>non-null</strong> <code>Map</code>.
      *
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>Map</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -600,59 +450,20 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return empty Map.
-     * @see #anyMapOf(Class, Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <K, V> Map<K, V> anyMap() {
         reportMatcher(new InstanceOf(Map.class, "<any map>"));
         return new HashMap<K, V>(0);
     }
 
-    /**
-     * Any <strong>non-null</strong> <code>Map</code>.
-     *
-     * <p>
-     * Generic friendly alias to {@link ArgumentMatchers#anyMap()}.
-     * It's an alternative to <code>&#064;SuppressWarnings("unchecked")</code> to keep code clean of compiler warnings.
-     * </p>
-     *
-     * <p>
-     * This method doesn't do type checks of the map content with the given type parameter, it is only there
-     * to avoid casting in the code.
-     * </p>
-     *
-     * <p>
-     * Since Mockito 2.1.0, only allow non-null <code>Map</code>.
-     * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
-     * 1.x.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @param keyClazz   Type of the map key to avoid casting
-     * @param valueClazz Type of the value to avoid casting
-     * @return empty Map.
-     * @see #anyMap()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <K, V> Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
-        return anyMap();
-    }
-
     /**
      * Any <strong>non-null</strong> <code>Collection</code>.
      *
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>Collection</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code>
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -661,58 +472,20 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return empty Collection.
-     * @see #anyCollectionOf(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <T> Collection<T> anyCollection() {
         reportMatcher(new InstanceOf(Collection.class, "<any collection>"));
         return new ArrayList<T>(0);
     }
 
-    /**
-     * Any <strong>non-null</strong> <code>Collection</code>.
-     *
-     * <p>
-     * Generic friendly alias to {@link ArgumentMatchers#anyCollection()}.
-     * It's an alternative to <code>&#064;SuppressWarnings("unchecked")</code> to keep code clean of compiler warnings.
-     * </p>
-     *
-     * <p>
-     * This method doesn't do type checks of the collection content with the given type parameter, it is only there
-     * to avoid casting in the code.
-     * </p>
-     *
-     * <p>
-     * Since Mockito 2.1.0, only allow non-null <code>Collection</code>.
-     * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code>
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
-     * 1.x.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @param clazz Type owned by the collection to avoid casting
-     * @return empty Collection.
-     * @see #anyCollection()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
-        return anyCollection();
-    }
-
     /**
      * Any <strong>non-null</strong> <code>Iterable</code>.
      *
      * <p>
      * Since Mockito 2.1.0, only allow non-null <code>Iterable</code>.
      * As this is a nullable reference, the suggested API to <strong>match</strong> <code>null</code>
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
+     * would be {@link #isNull()}. We felt this change would make test harnesses much safer than they were with Mockito
      * 1.x.
      * </p>
      *
@@ -721,9 +494,7 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return empty Iterable.
-     * @see #anyIterableOf(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      * @since 2.1.0
      */
     public static <T> Iterable<T> anyIterable() {
@@ -731,45 +502,6 @@ public class ArgumentMatchers {
         return new ArrayList<T>(0);
     }
 
-    /**
-     * Any <strong>non-null</strong> <code>Iterable</code>.
-     *
-     * <p>
-     * Generic friendly alias to {@link ArgumentMatchers#anyIterable()}.
-     * It's an alternative to <code>&#064;SuppressWarnings("unchecked")</code> to keep code clean of compiler warnings.
-     * </p>
-     *
-     * <p>
-     * This method doesn't do type checks of the iterable content with the given type parameter, it is only there
-     * to avoid casting in the code.
-     * </p>
-     *
-     * <p>
-     * Since Mockito 2.1.0, only allow non-null <code>String</code>.
-     * As strings are nullable reference, the suggested API to <strong>match</strong> <code>null</code> wrapper
-     * would be {@link #isNull()}. We felt this change would make tests harness much safer that it was with Mockito
-     * 1.x.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class.
-     * </p>
-     *
-     * @param clazz Type owned by the collection to avoid casting
-     * @return empty Iterable.
-     * @see #anyIterable()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @since 2.1.0
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> Iterable<T> anyIterableOf(Class<T> clazz) {
-        return anyIterable();
-    }
-
-
-
     /**
      * <code>boolean</code> argument that is equal to the given value.
      *
@@ -900,8 +632,7 @@ public class ArgumentMatchers {
      */
     public static <T> T eq(T value) {
         reportMatcher(new Equals(value));
-        if (value == null)
-            return null;
+        if (value == null) return null;
         return (T) Primitives.defaultValue(value.getClass());
     }
 
@@ -947,8 +678,9 @@ public class ArgumentMatchers {
      */
     public static <T> T same(T value) {
         reportMatcher(new Same(value));
-        if (value == null)
+        if (value == null) {
             return null;
+        }
         return (T) Primitives.defaultValue(value.getClass());
     }
 
@@ -960,38 +692,13 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return <code>null</code>.
-     * @see #isNull(Class)
      * @see #isNotNull()
-     * @see #isNotNull(Class)
      */
     public static <T> T isNull() {
         reportMatcher(Null.NULL);
         return null;
     }
 
-    /**
-     * <code>null</code> argument.
-     *
-     * <p>
-     * The class argument is provided to avoid casting.
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class
-     * </p>
-     *
-     * @param clazz Type to avoid casting
-     * @return <code>null</code>.
-     * @see #isNull()
-     * @see #isNotNull()
-     * @see #isNotNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> T isNull(Class<T> clazz) {
-        return isNull();
-    }
-
     /**
      * Not <code>null</code> argument.
      *
@@ -1010,31 +717,6 @@ public class ArgumentMatchers {
         return null;
     }
 
-    /**
-     * Not <code>null</code> argument, not necessary of the given class.
-     *
-     * <p>
-     * The class argument is provided to avoid casting.
-     *
-     * Alias to {@link ArgumentMatchers#isNotNull(Class)}
-     * <p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class
-     * </p>
-     *
-     * @param clazz Type to avoid casting
-     * @return <code>null</code>.
-     * @see #isNotNull()
-     * @see #isNull()
-     * @see #isNull(Class)
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> T notNull(Class<T> clazz) {
-        return notNull();
-    }
-
     /**
      * Not <code>null</code> argument.
      *
@@ -1047,36 +729,12 @@ public class ArgumentMatchers {
      * </p>
      *
      * @return <code>null</code>.
-     * @see #isNotNull(Class)
      * @see #isNull()
-     * @see #isNull(Class)
      */
     public static <T> T isNotNull() {
         return notNull();
     }
 
-    /**
-     * Not <code>null</code> argument, not necessary of the given class.
-     *
-     * <p>
-     * The class argument is provided to avoid casting.
-     * Alias to {@link ArgumentMatchers#notNull(Class)}
-     * </p>
-     *
-     * <p>
-     * See examples in javadoc for {@link ArgumentMatchers} class
-     * </p>
-     *
-     * @param clazz Type to avoid casting
-     * @return <code>null</code>.
-     * @deprecated With Java 8 this method will be removed in Mockito 3.0. This method is only used for generic
-     * friendliness to avoid casting, this is not anymore needed in Java 8.
-     */
-    public static <T> T isNotNull(Class<T> clazz) {
-        return notNull(clazz);
-    }
-
-
     /**
      * Argument that is either <code>null</code> or of the given type.
      *
@@ -1089,7 +747,7 @@ public class ArgumentMatchers {
      */
     public static <T> T nullable(Class<T> clazz) {
         AdditionalMatchers.or(isNull(), isA(clazz));
-        return  (T) Primitives.defaultValue(clazz);
+        return Primitives.defaultValue(clazz);
     }
 
     /**
diff --git a/src/main/java/org/mockito/BDDMockito.java b/src/main/java/org/mockito/BDDMockito.java
index 9090fa8..d37a07a 100644
--- a/src/main/java/org/mockito/BDDMockito.java
+++ b/src/main/java/org/mockito/BDDMockito.java
@@ -13,7 +13,7 @@ import org.mockito.verification.VerificationMode;
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
- * Start learning about BDD here: <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
+ * Start learning about BDD here: <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test.
@@ -127,9 +127,12 @@ public class BDDMockito extends Mockito {
          * See original {@link OngoingStubbing#thenThrow(Class, Class[])}
          * @since 2.1.0
          */
-        // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
-        @SuppressWarnings ({"unchecked", "varargs"})
-        BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable> throwableType, Class<? extends Throwable>... throwableTypes);
+        // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
+        // creation
+        @SuppressWarnings({"unchecked", "varargs"})
+        BDDMyOngoingStubbing<T> willThrow(
+                Class<? extends Throwable> throwableType,
+                Class<? extends Throwable>... throwableTypes);
 
         /**
          * See original {@link OngoingStubbing#thenCallRealMethod()}
@@ -176,8 +179,11 @@ public class BDDMockito extends Mockito {
             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableType));
         }
 
-        public BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable> throwableType, Class<? extends Throwable>... throwableTypes) {
-            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableType, throwableTypes));
+        public BDDMyOngoingStubbing<T> willThrow(
+                Class<? extends Throwable> throwableType,
+                Class<? extends Throwable>... throwableTypes) {
+            return new BDDOngoingStubbingImpl<T>(
+                    mockitoOngoingStubbing.thenThrow(throwableType, throwableTypes));
         }
 
         public BDDMyOngoingStubbing<T> willCallRealMethod() {
@@ -249,16 +255,16 @@ public class BDDMockito extends Mockito {
         T should(InOrder inOrder, VerificationMode mode);
 
         /**
-         * @see #verifyZeroInteractions(Object...)
+         * @see #verifyNoMoreInteractions(Object...)
          * @since 2.1.0
          */
-        void shouldHaveZeroInteractions();
+        void shouldHaveNoMoreInteractions();
 
         /**
-         * @see #verifyNoMoreInteractions(Object...)
-         * @since 2.1.0
+         * @see #verifyNoInteractions(Object...)
+         * @since 3.0.1
          */
-        void shouldHaveNoMoreInteractions();
+        void shouldHaveNoInteractions();
     }
 
     private static class ThenImpl<T> implements Then<T> {
@@ -302,19 +308,19 @@ public class BDDMockito extends Mockito {
         }
 
         /**
-         * @see #verifyZeroInteractions(Object...)
+         * @see #verifyNoMoreInteractions(Object...)
          * @since 2.1.0
          */
-        public void shouldHaveZeroInteractions() {
-            verifyZeroInteractions(mock);
+        public void shouldHaveNoMoreInteractions() {
+            verifyNoMoreInteractions(mock);
         }
 
         /**
-         * @see #verifyNoMoreInteractions(Object...)
-         * @since 2.1.0
+         * @see #verifyNoInteractions(Object...)
+         * @since 3.0.1
          */
-        public void shouldHaveNoMoreInteractions() {
-            verifyNoMoreInteractions(mock);
+        public void shouldHaveNoInteractions() {
+            verifyNoInteractions(mock);
         }
     }
 
@@ -335,17 +341,6 @@ public class BDDMockito extends Mockito {
          */
         BDDStubber will(Answer<?> answer);
 
-        /**
-         * See original {@link Stubber#doNothing()}.
-         *
-         * This method will be removed in version 3.0.0
-         *
-         * @since 1.8.0
-         * @deprecated as of 2.1.0 please use {@link #willDoNothing()} instead
-         */
-        @Deprecated
-        BDDStubber willNothing();
-
         /**
          * See original {@link Stubber#doNothing()}
          * @since 1.10.20
@@ -381,8 +376,10 @@ public class BDDMockito extends Mockito {
          * See original {@link Stubber#doThrow(Class, Class[])}
          * @since 2.1.0
          */
-        @SuppressWarnings ({"unchecked", "varargs"})
-        BDDStubber willThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown);
+        @SuppressWarnings({"unchecked", "varargs"})
+        BDDStubber willThrow(
+                Class<? extends Throwable> toBeThrown,
+                Class<? extends Throwable>... nextToBeThrown);
 
         /**
          * See original {@link Stubber#doCallRealMethod()}
@@ -417,14 +414,6 @@ public class BDDMockito extends Mockito {
             return new BDDStubberImpl(mockitoStubber.doAnswer(answer));
         }
 
-        /**
-         * @deprecated please use {@link #willDoNothing()} instead
-         */
-        @Deprecated
-        public BDDStubber willNothing() {
-            return willDoNothing();
-        }
-
         public BDDStubber willDoNothing() {
             return new BDDStubberImpl(mockitoStubber.doNothing());
         }
@@ -434,7 +423,8 @@ public class BDDMockito extends Mockito {
         }
 
         public BDDStubber willReturn(Object toBeReturned, Object... nextToBeReturned) {
-            return new BDDStubberImpl(mockitoStubber.doReturn(toBeReturned).doReturn(nextToBeReturned));
+            return new BDDStubberImpl(
+                    mockitoStubber.doReturn(toBeReturned).doReturn(nextToBeReturned));
         }
 
         public BDDStubber willThrow(Throwable... toBeThrown) {
@@ -445,7 +435,9 @@ public class BDDMockito extends Mockito {
             return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));
         }
 
-        public BDDStubber willThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
+        public BDDStubber willThrow(
+                Class<? extends Throwable> toBeThrown,
+                Class<? extends Throwable>... nextToBeThrown) {
             return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown, nextToBeThrown));
         }
 
@@ -474,7 +466,8 @@ public class BDDMockito extends Mockito {
      * see original {@link Mockito#doThrow(Class)}
      * @since 1.9.0
      */
-    public static BDDStubber willThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... throwableTypes) {
+    public static BDDStubber willThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... throwableTypes) {
         return new BDDStubberImpl(Mockito.doThrow(toBeThrown, throwableTypes));
     }
 
diff --git a/src/main/java/org/mockito/Captor.java b/src/main/java/org/mockito/Captor.java
index 225bf70..0de9f72 100644
--- a/src/main/java/org/mockito/Captor.java
+++ b/src/main/java/org/mockito/Captor.java
@@ -4,7 +4,11 @@
  */
 package org.mockito;
 
-import java.lang.annotation.*;
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 /**
  * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.
@@ -15,9 +19,16 @@ import java.lang.annotation.*;
  *
  *    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;
  *
+ *    private AutoCloseable closeable;
+ *
  *    &#64;Before
- *    public void init(){
- *       MockitoAnnotations.initMocks(this);
+ *    public void open() {
+ *       closeable = MockitoAnnotations.openMocks(this);
+ *    }
+ *
+ *    &#64;After
+ *    public void release() throws Exception {
+ *       closeable.close();
  *    }
  *
  *    &#64;Test public void shouldDoSomethingUseful() {
diff --git a/src/main/java/org/mockito/CheckReturnValue.java b/src/main/java/org/mockito/CheckReturnValue.java
index 0498c14..935b320 100644
--- a/src/main/java/org/mockito/CheckReturnValue.java
+++ b/src/main/java/org/mockito/CheckReturnValue.java
@@ -9,7 +9,6 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-
 /**
  * This annotation is not supposed to be used by Mockito end-users. Instead, we
  * use it to annotate methods for Static Analysis tools, including FindBugs and ErrorProne.
@@ -18,15 +17,9 @@ import java.lang.annotation.Target;
  * This annotation is public, because we have to use it in multiple packages.
  *
  * @see <a href="https://github.com/findbugsproject/findbugs/blob/264ae7baf890d2b347d91805c90057062b5dcb1e/findbugs/src/java/edu/umd/cs/findbugs/detect/BuildCheckReturnAnnotationDatabase.java#L120">Findbugs source code</a>
- * @see <a href="http://errorprone.info/bugpattern/CheckReturnValue">ErrorProne check</a>
+ * @see <a href="https://errorprone.info/bugpattern/CheckReturnValue">ErrorProne check</a>
  * @since 2.11.4
  */
-@Target({
-    ElementType.CONSTRUCTOR,
-    ElementType.METHOD,
-    ElementType.PACKAGE,
-    ElementType.TYPE
-})
+@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PACKAGE, ElementType.TYPE})
 @Retention(RetentionPolicy.CLASS)
-public @interface CheckReturnValue {
-}
+public @interface CheckReturnValue {}
diff --git a/src/main/java/org/mockito/DoNotMock.java b/src/main/java/org/mockito/DoNotMock.java
new file mode 100644
index 0000000..fb2de8e
--- /dev/null
+++ b/src/main/java/org/mockito/DoNotMock.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation representing a type that should not be mocked.
+ * <p>When marking a type {@code @DoNotMock}, you should always point to alternative testing
+ * solutions such as standard fakes or other testing utilities.
+ *
+ * Mockito enforces {@code @DoNotMock} with the {@link org.mockito.plugins.DoNotMockEnforcer}.
+ *
+ * If you want to use a custom {@code @DoNotMock} annotation, the {@link org.mockito.plugins.DoNotMockEnforcer}
+ * will match on annotations with a type ending in "org.mockito.DoNotMock". You can thus place
+ * your custom annotation in {@code com.my.package.org.mockito.DoNotMock} and Mockito will enforce
+ * that types annotated by {@code @com.my.package.org.mockito.DoNotMock} can not be mocked.
+ *
+ * <pre class="code"><code class="java">
+ * &#064;DoNotMock(reason = "Use a real instance instead")
+ * class DoNotMockMe {}
+ * </code></pre>
+ */
+@Target({TYPE})
+@Retention(RUNTIME)
+@Documented
+public @interface DoNotMock {
+    /**
+     * The reason why the annotated type should not be mocked.
+     *
+     * <p>This should suggest alternative APIs to use for testing objects of this type.
+     */
+    String reason() default "Create a real instance instead.";
+}
diff --git a/src/main/java/org/mockito/InOrder.java b/src/main/java/org/mockito/InOrder.java
index 56beafe..02ea019 100644
--- a/src/main/java/org/mockito/InOrder.java
+++ b/src/main/java/org/mockito/InOrder.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
 import org.mockito.verification.VerificationMode;
@@ -63,7 +62,6 @@ public interface InOrder {
      */
     <T> T verify(T mock, VerificationMode mode);
 
-
     /**
      * Verifies that no more interactions happened <b>in order</b>.
      * Different from {@link Mockito#verifyNoMoreInteractions(Object...)} because the order of verification matters.
diff --git a/src/main/java/org/mockito/Incubating.java b/src/main/java/org/mockito/Incubating.java
index 294cfc5..adf011a 100644
--- a/src/main/java/org/mockito/Incubating.java
+++ b/src/main/java/org/mockito/Incubating.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
 import java.lang.annotation.Documented;
@@ -26,5 +25,4 @@ import java.lang.annotation.RetentionPolicy;
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-public @interface Incubating {
-}
+public @interface Incubating {}
diff --git a/src/main/java/org/mockito/InjectMocks.java b/src/main/java/org/mockito/InjectMocks.java
index 0430524..6ed02ab 100644
--- a/src/main/java/org/mockito/InjectMocks.java
+++ b/src/main/java/org/mockito/InjectMocks.java
@@ -4,15 +4,15 @@
  */
 package org.mockito;
 
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import org.mockito.junit.MockitoJUnitRunner;
 
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Mark a field on which injection should be performed.
  *
@@ -22,7 +22,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * </ul>
  * <p>
  * Mockito will try to inject mocks only either by constructor injection,
- * setter injection, or property injection in order and as described below.
+ * property injection or setter injection in order and as described below.
  * If any of the following strategy fail, then Mockito <strong>won't report failure</strong>;
  * i.e. you will have to provide dependencies yourself.
  * <ol>
@@ -39,7 +39,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *     then, if there is several property of the same type, by the match of the property name and the mock name.
  *     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock
  *     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>
- *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,
+ *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and has a no-arg constructor,
  *     then it will be initialized with this constructor.</p></li>
  *
  *     <li><strong>Field injection</strong>; mocks will first be resolved by type (if a single type match
@@ -71,8 +71,14 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *
  *   public class SampleBaseTestCase {
  *
- *       &#064;Before public void initMocks() {
- *           MockitoAnnotations.initMocks(this);
+ *       private AutoCloseable closeable;
+ *
+ *       &#064;Before public void openMocks() {
+ *           closeable = MockitoAnnotations.openMocks(this);
+ *       }
+ *
+ *       &#064;After public void releaseMocks() throws Exception {
+ *           closeable.close();
  *       }
  *   }
  * </code></pre>
@@ -83,13 +89,13 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * a parameterized constructor only or a no-arg constructor only, or both.
  * All these constructors can be package protected, protected or private, however
  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>
- * <u>Beware of private nest static classes too.</u>
+ * <u>Beware of private nested static classes too.</u>
  *
  * <p>The same stands for setters or fields, they can be declared with private
  * visibility, Mockito will see them through reflection.
  * However fields that are static or final will be ignored.</p>
  *
- * <p>So on the field that needs injection, for example constructor injection will happen here :</p>
+ * <p>So on the field that needs injection, for example constructor injection will happen here:</p>
  * <pre class="code"><code class="java">
  *   public class ArticleManager {
  *       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {
@@ -98,7 +104,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *   }
  * </code></pre>
  *
- * <p>Property setter injection will happen here :</p>
+ * <p>Property setter injection will happen here:</p>
  * <pre class="code"><code class="java">
  *   public class ArticleManager {
  *       // no-arg constructor
@@ -112,7 +118,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *   }
  * </code></pre>
  *
- * <p>Field injection will be used here :</p>
+ * <p>Field injection will be used here:</p>
  * <pre class="code"><code class="java">
  *   public class ArticleManager {
  *       private ArticleDatabase database;
@@ -141,11 +147,11 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * </p>
  *
  * <p>
- * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.
- * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.
- * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in
- * {@link MockitoJUnitRunner}.
+ * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
+ * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
+ * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
+ * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
  *
  * <p>
@@ -155,7 +161,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *
  * @see Mock
  * @see Spy
- * @see MockitoAnnotations#initMocks(Object)
+ * @see MockitoAnnotations#openMocks(Object)
  * @see MockitoJUnitRunner
  * @since 1.8.3
  */
diff --git a/src/main/java/org/mockito/Matchers.java b/src/main/java/org/mockito/Matchers.java
deleted file mode 100644
index f6d07bc..0000000
--- a/src/main/java/org/mockito/Matchers.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito;
-
-/**
- * @deprecated Use {@link ArgumentMatchers}. This class is now deprecated in order to avoid a name clash with Hamcrest
- * <code>org.hamcrest.Matchers</code> class. This class will likely be removed in version 3.0.
- */
-@Deprecated
-public class Matchers extends ArgumentMatchers {
-}
diff --git a/src/main/java/org/mockito/Mock.java b/src/main/java/org/mockito/Mock.java
index 909432f..8b81320 100644
--- a/src/main/java/org/mockito/Mock.java
+++ b/src/main/java/org/mockito/Mock.java
@@ -4,15 +4,16 @@
  */
 package org.mockito;
 
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import org.mockito.junit.MockitoJUnitRunner;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import org.mockito.stubbing.Answer;
 
 /**
  * Mark a field as a mock.
@@ -22,6 +23,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * <li>Minimizes repetitive mock creation code.</li>
  * <li>Makes the test class more readable.</li>
  * <li>Makes the verification error easier to read because the <b>field name</b> is used to identify the mock.</li>
+ * <li>Automatically detects static mocks of type {@link MockedStatic} and infers the static mock type of the type parameter.</li>
  * </ul>
  *
  * <pre class="code"><code class="java">
@@ -30,7 +32,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *       &#064;Mock private ArticleCalculator calculator;
  *       &#064;Mock(name = "database") private ArticleDatabase dbMock;
  *       &#064;Mock(answer = RETURNS_MOCKS) private UserProvider userProvider;
- *       &#064;Mock(extraInterfaces = {Queue.class, Observer.class}) private  articleMonitor;
+ *       &#064;Mock(extraInterfaces = {Queue.class, Observer.class}) private ArticleMonitor articleMonitor;
  *       &#064;Mock(stubOnly = true) private Logger logger;
  *
  *       private ArticleManager manager;
@@ -42,24 +44,30 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *
  *   public class SampleBaseTestCase {
  *
- *       &#064;Before public void initMocks() {
- *           MockitoAnnotations.initMocks(this);
+ *       private AutoCloseable closeable;
+ *
+ *       &#064;Before public void openMocks() {
+ *           closeable = MockitoAnnotations.openMocks(this);
+ *       }
+ *
+ *       &#064;After public void releaseMocks() throws Exception {
+ *           closeable.close();
  *       }
  *   }
  * </code></pre>
  *
  * <p>
- * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.
- * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.
- * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in
- * {@link MockitoJUnitRunner}.
+ * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
+ * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
+ * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
+ * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
  *
  * @see Mockito#mock(Class)
  * @see Spy
  * @see InjectMocks
- * @see MockitoAnnotations#initMocks(Object)
+ * @see MockitoAnnotations#openMocks(Object)
  * @see MockitoJUnitRunner
  */
 @Target({FIELD, PARAMETER})
@@ -67,13 +75,41 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
 @Documented
 public @interface Mock {
 
+    /**
+     * Mock will have custom answer, see {@link MockSettings#defaultAnswer(Answer)}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     */
     Answers answer() default Answers.RETURNS_DEFAULTS;
 
+    /**
+     * Mock will be 'stubOnly', see {@link MockSettings#stubOnly()}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     */
     boolean stubOnly() default false;
 
+    /**
+     * Mock will have custom name (shown in verification errors), see {@link MockSettings#name(String)}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     */
     String name() default "";
 
+    /**
+     * Mock will have extra interfaces, see {@link MockSettings#extraInterfaces(Class[])}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     */
     Class<?>[] extraInterfaces() default {};
 
+    /**
+     * Mock will be serializable, see {@link MockSettings#serializable()}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     */
     boolean serializable() default false;
+
+    /**
+     * Mock will be lenient, see {@link MockSettings#lenient()}.
+     * For examples how to use 'Mock' annotation and parameters see {@link Mock}.
+     *
+     * @since 2.23.3
+     */
+    boolean lenient() default false;
 }
diff --git a/src/main/java/org/mockito/MockSettings.java b/src/main/java/org/mockito/MockSettings.java
index c79c243..fb65540 100644
--- a/src/main/java/org/mockito/MockSettings.java
+++ b/src/main/java/org/mockito/MockSettings.java
@@ -4,30 +4,31 @@
  */
 package org.mockito;
 
+import java.io.Serializable;
+
 import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.invocation.InvocationFactory;
 import org.mockito.invocation.MockHandler;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockito.listeners.VerificationStartedListener;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.SerializableMode;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 
-import java.io.Serializable;
-
 /**
  * Allows mock creation with additional mock settings.
  * <p/>
  * Don't use it too often.
  * Consider writing simple tests that use simple mocks.
- * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.
+ * Repeat after me: simple tests push simple, KISSy, readable and maintainable code.
  * If you cannot write a test in a simple way - refactor the code under test.
  * <p/>
  * Examples of mock settings:
  * <pre class="code"><code class="java">
- *   //Creates mock with different default answer & name
+ *   //Creates mock with different default answer and name
  *   Foo mock = mock(Foo.class, withSettings()
  *                                .defaultAnswer(RETURNS_SMART_NULLS)
  *                                .name("cool mockie")
@@ -43,14 +44,15 @@ import java.io.Serializable;
  * Firstly, to make it easy to add another mock setting when the demand comes.
  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.
  */
+@NotExtensible
 public interface MockSettings extends Serializable {
 
     /**
      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.
      * <p>
      * This mysterious feature should be used very occasionally.
-     * The object under test should know exactly its collaborators & dependencies.
-     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.
+     * The object under test should know exactly its collaborators and dependencies.
+     * If you happen to use it often than please make sure you are really producing simple, clean and readable code.
      * <p>
      * Examples:
      * <pre class="code"><code class="java">
@@ -99,7 +101,7 @@ public interface MockSettings extends Serializable {
      * <p>
      * However, there are rare cases when partial mocks come handy:
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
      * <p>
      * Enough warnings about partial mocks, see an example how spiedInstance() works:
      * <pre class="code"><code class="java">
@@ -203,6 +205,24 @@ public interface MockSettings extends Serializable {
      */
     MockSettings verboseLogging();
 
+    /**
+     * Add stubbing lookup listener to the mock object.
+     *
+     * Multiple listeners may be added and they will be notified orderly.
+     *
+     * For use cases and more info see {@link StubbingLookupListener}.
+     *
+     * Example:
+     * <pre class="code"><code class="java">
+     *  List mockWithListener = mock(List.class, withSettings().stubbingLookupListeners(new YourStubbingLookupListener()));
+     * </code></pre>
+     *
+     * @param listeners The stubbing lookup listeners to add. May not be null.
+     * @return settings instance so that you can fluently specify other settings
+     * @since 2.24.6
+     */
+    MockSettings stubbingLookupListeners(StubbingLookupListener... listeners);
+
     /**
      * Registers a listener for method invocations on this mock. The listener is
      * notified every time a method on this mock is called.
@@ -235,7 +255,6 @@ public interface MockSettings extends Serializable {
      * @return settings instance so that you can fluently specify other settings
      * @since 2.11.0
      */
-    @Incubating
     MockSettings verificationStartedListeners(VerificationStartedListener... listeners);
 
     /**
@@ -276,7 +295,6 @@ public interface MockSettings extends Serializable {
      * @return settings instance so that you can fluently specify other settings
      * @since 2.7.14 (useConstructor with no arguments was supported since 1.10.12)
      */
-    @Incubating
     MockSettings useConstructor(Object... args);
 
     /**
@@ -291,7 +309,6 @@ public interface MockSettings extends Serializable {
      * @return settings instance so that you can fluently specify other settings
      * @since 1.10.12
      */
-    @Incubating
     MockSettings outerInstance(Object outerClassInstance);
 
     /**
@@ -302,7 +319,6 @@ public interface MockSettings extends Serializable {
      * @return settings instance so that you can fluently specify other settings
      * @since 1.10.13
      */
-    @Incubating
     MockSettings withoutAnnotations();
 
     /**
@@ -317,9 +333,22 @@ public interface MockSettings extends Serializable {
      * @return immutable view of mock settings
      * @since 2.10.0
      */
-    @Incubating
     <T> MockCreationSettings<T> build(Class<T> typeToMock);
 
+    /**
+     * Creates immutable view of mock settings used later by Mockito, for use within a static mocking.
+     * Framework integrators can use this method to create instances of creation settings
+     * and use them in advanced use cases, for example to create invocations with {@link InvocationFactory},
+     * or to implement custom {@link MockHandler}.
+     * Since {@link MockCreationSettings} is {@link NotExtensible}, Mockito public API needs a creation method for this type.
+     *
+     * @param classToMock class to mock
+     * @param <T> type to mock
+     * @return immutable view of mock settings
+     * @since 2.10.0
+     */
+    <T> MockCreationSettings<T> buildStatic(Class<T> classToMock);
+
     /**
      * Lenient mocks bypass "strict stubbing" validation (see {@link Strictness#STRICT_STUBS}).
      * When mock is declared as lenient none of its stubbings will be checked for potential stubbing problems such as
@@ -331,6 +360,5 @@ public interface MockSettings extends Serializable {
      *
      * For more information and an elaborate example, see {@link Mockito#lenient()}.
      */
-    @Incubating
     MockSettings lenient();
 }
diff --git a/src/main/java/org/mockito/MockedConstruction.java b/src/main/java/org/mockito/MockedConstruction.java
new file mode 100644
index 0000000..5c2ec21
--- /dev/null
+++ b/src/main/java/org/mockito/MockedConstruction.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import java.lang.reflect.Constructor;
+import java.util.List;
+
+/**
+ * Represents a mock of any object construction of the represented type. Within the scope of the
+ * mocked construction, the invocation of any interceptor will generate a mock which will be
+ * prepared as specified when generating this scope. The mock can also be received via this
+ * instance.
+ * <p>
+ * If the {@link Mock} annotation is used on fields or method parameters of this type, a mocked
+ * construction is created instead of a regular mock. The mocked construction is activated and
+ * released upon completing any relevant test.
+ *
+ * @param <T> The type for which the construction is being mocked.
+ */
+public interface MockedConstruction<T> extends ScopedMock {
+
+    List<T> constructed();
+
+    interface Context {
+
+        int getCount();
+
+        Constructor<?> constructor();
+
+        List<?> arguments();
+    }
+
+    interface MockInitializer<T> {
+
+        void prepare(T mock, Context context) throws Throwable;
+    }
+}
diff --git a/src/main/java/org/mockito/MockedStatic.java b/src/main/java/org/mockito/MockedStatic.java
new file mode 100644
index 0000000..9095556
--- /dev/null
+++ b/src/main/java/org/mockito/MockedStatic.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import static org.mockito.Mockito.times;
+
+import org.mockito.stubbing.OngoingStubbing;
+import org.mockito.verification.VerificationMode;
+
+/**
+ * Represents an active mock of a type's static methods. The mocking only affects the thread
+ * on which this static mock was created and it is not safe to use this object from another
+ * thread. The static mock is released when this object's {@link MockedStatic#close()} method
+ * is invoked. If this object is never closed, the static mock will remain active on the
+ * initiating thread. It is therefore recommended to create this object within a try-with-resources
+ * statement unless when managed explicitly, for example by using a JUnit rule or extension.
+ * <p>
+ * If the {@link Mock} annotation is used on fields or method parameters of this type, a static mock
+ * is created instead of a regular mock. The static mock is activated and released upon completing any
+ * relevant test.
+ *
+ * @param <T> The type being mocked.
+ */
+public interface MockedStatic<T> extends ScopedMock {
+
+    /**
+     * See {@link Mockito#when(Object)}.
+     */
+    <S> OngoingStubbing<S> when(Verification verification);
+
+    /**
+     * See {@link Mockito#verify(Object)}.
+     */
+    default void verify(Verification verification) {
+        verify(verification, times(1));
+    }
+
+    /**
+     * See {@link Mockito#verify(Object, VerificationMode)}.
+     */
+    void verify(Verification verification, VerificationMode mode);
+
+    /**
+     * See {@link Mockito#reset(Object[])}.
+     */
+    void reset();
+
+    /**
+     * See {@link Mockito#clearInvocations(Object[])}.
+     */
+    void clearInvocations();
+
+    /**
+     * {@link Mockito#verifyNoMoreInteractions(Object...)}.
+     */
+    void verifyNoMoreInteractions();
+
+    /**
+     * See {@link Mockito#verifyNoInteractions(Object...)}.
+     */
+    void verifyNoInteractions();
+
+    interface Verification {
+
+        void apply() throws Throwable;
+    }
+}
diff --git a/src/main/java/org/mockito/MockingDetails.java b/src/main/java/org/mockito/MockingDetails.java
index 126b48e..c32e04e 100644
--- a/src/main/java/org/mockito/MockingDetails.java
+++ b/src/main/java/org/mockito/MockingDetails.java
@@ -4,14 +4,14 @@
  */
 package org.mockito;
 
+import java.util.Collection;
+
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.quality.MockitoHint;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Collection;
-
 /**
  * Provides mocking information.
  * For example, you can identify whether a particular object is either a mock or a spy.
@@ -102,8 +102,6 @@ public interface MockingDetails {
      * Don't write code that depends on the output of this method.
      * If you need to know about interactions and stubbings, use {@link #getStubbings()} and {@link #getInvocations()}.
      * <p>
-     * This method was moved from the deprecated and semi-hidden type {@link MockitoDebugger}.
-     * <p>
      * This method throws meaningful exception when object wrapped by MockingDetails is not a mock.
      *
      * @since 2.2.6
@@ -119,7 +117,6 @@ public interface MockingDetails {
      * @return mock handler instance of this mock
      * @since 2.10.0
      */
-    @Incubating
     MockHandler getMockHandler();
 
     /**
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 4058340..8c1a0cf 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -6,10 +6,8 @@ package org.mockito;
 
 import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
-import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
-import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.framework.DefaultMockitoFramework;
 import org.mockito.internal.session.DefaultMockitoSessionBuilder;
 import org.mockito.internal.verification.VerificationModeFactory;
@@ -18,6 +16,7 @@ import org.mockito.invocation.InvocationFactory;
 import org.mockito.invocation.MockHandler;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoJUnitRunner;
+import org.mockito.junit.MockitoJUnitRunner.Strict;
 import org.mockito.junit.MockitoRule;
 import org.mockito.listeners.VerificationStartedEvent;
 import org.mockito.listeners.VerificationStartedListener;
@@ -33,20 +32,17 @@ import org.mockito.stubbing.Answer1;
 import org.mockito.stubbing.LenientStubber;
 import org.mockito.stubbing.OngoingStubbing;
 import org.mockito.stubbing.Stubber;
-import org.mockito.stubbing.Stubbing;
 import org.mockito.stubbing.VoidAnswer1;
-import org.mockito.verification.After;
-import org.mockito.verification.Timeout;
-import org.mockito.verification.VerificationAfterDelay;
-import org.mockito.verification.VerificationMode;
-import org.mockito.verification.VerificationWithTimeout;
+import org.mockito.verification.*;
+
+import java.util.function.Function;
 
 /**
  * <p align="left"><img src="logo.png" srcset="logo@2x.png 2x" alt="Mockito logo"/></p>
  * The Mockito library enables mock creation, verification and stubbing.
  *
  * <p>
- * This javadoc content is also available on the <a href="http://mockito.org">http://mockito.org</a> web page.
+ * This javadoc content is also available on the <a href="https://site.mockito.org/">https://site.mockito.org/</a> web page.
  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
  * It allows access to documentation straight from the IDE even if you work offline.
  * It motivates Mockito developers to keep documentation up-to-date with the code that they write,
@@ -56,8 +52,8 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <b>
  *      <a href="#0">0. Migrating to Mockito 2</a><br/>
- *      <a href="#0.1">0.1 Mockito Android support</a></br/>
- *      <a href="#0.2">0.2 Configuration-free inline mock making</a></br/>
+ *      <a href="#0.1">0.1 Mockito Android support</a><br/>
+ *      <a href="#0.2">0.2 Configuration-free inline mock making</a><br/>
  *      <a href="#1">1. Let's verify some behaviour! </a><br/>
  *      <a href="#2">2. How about some stubbing? </a><br/>
  *      <a href="#3">3. Argument matchers </a><br/>
@@ -75,7 +71,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *      <a href="#15">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
  *      <a href="#16">16. Real partial mocks (Since 1.8.0) </a><br/>
  *      <a href="#17">17. Resetting mocks (Since 1.8.0) </a><br/>
- *      <a href="#18">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
+ *      <a href="#18">18. Troubleshooting and validating framework usage (Since 1.8.0) </a><br/>
  *      <a href="#19">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
  *      <a href="#20">20. Serializable mocks (Since 1.8.1) </a><br/>
  *      <a href="#21">21. New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </a><br/>
@@ -105,12 +101,16 @@ import org.mockito.verification.VerificationWithTimeout;
  *      <a href="#45">45. New JUnit Jupiter (JUnit5+) extension</a><br/>
  *      <a href="#46">46. New <code>Mockito.lenient()</code> and <code>MockSettings.lenient()</code> methods (Since 2.20.0)</a><br/>
  *      <a href="#47">47. New API for clearing mock state in inline mocking (Since 2.25.0)</a><br/>
+ *      <a href="#48">48. New API for mocking static methods (Since 3.4.0)</a><br/>
+ *      <a href="#49">49. New API for mocking object construction (Since 3.5.0)</a><br/>
+ *      <a href="#50">50. Avoiding code generation when restricting mocks to interfaces (Since 3.12.2)</a><br/>
+ *      <a href="#51">51. New API for marking classes as unmockable (Since 4.1.0)</a><br/>
  * </b>
  *
  * <h3 id="0">0. <a class="meaningful_link" href="#mockito2" name="mockito2">Migrating to Mockito 2</a></h3>
  *
  * In order to continue improving Mockito and further improve the unit testing experience, we want you to upgrade to 2.1.0!
- * Mockito follows <a href="http://semver.org/">semantic versioning</a> and contains breaking changes only on major version upgrades.
+ * Mockito follows <a href="https://semver.org/">semantic versioning</a> and contains breaking changes only on major version upgrades.
  * In the lifecycle of a library, breaking changes are necessary
  * to roll out a set of brand new features that alter the existing behavior or even change the API.
  * For a comprehensive guide on the new release including incompatible changes,
@@ -124,7 +124,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <pre class="code"><code>
  * repositories {
- *   jcenter()
+ *   mavenCentral()
  * }
  * dependencies {
  *   testCompile "org.mockito:mockito-core:+"
@@ -146,7 +146,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <pre class="code"><code>
  * repositories {
- *   jcenter()
+ *   mavenCentral()
  * }
  * dependencies {
  *   testCompile "org.mockito:mockito-inline:+"
@@ -208,7 +208,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
  * //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
- * //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
+ * //If your code doesn't care what get(0) returns, then it should not be stubbed.
  * verify(mockedList).get(0);
  * </code></pre>
  *
@@ -243,7 +243,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * when(mockedList.get(anyInt())).thenReturn("element");
  *
  * //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
- * when(mockedList.contains(argThat(isValid()))).thenReturn("element");
+ * when(mockedList.contains(argThat(isValid()))).thenReturn(true);
  *
  * //following prints "element"
  * System.out.println(mockedList.get(999));
@@ -252,7 +252,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * verify(mockedList).get(anyInt());
  *
  * //<b>argument matchers can also be written as Java 8 Lambdas</b>
- * verify(mockedList).add(argThat(someString -> someString.length() > 5));
+ * verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5));
  *
  * </code></pre>
  *
@@ -264,7 +264,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.
  * <p>
  * Be reasonable with using complicated argument matching.
- * The natural matching style using <code>equals()</code> with occasional <code>anyX()</code> matchers tend to give clean & simple tests.
+ * The natural matching style using <code>equals()</code> with occasional <code>anyX()</code> matchers tend to give clean and simple tests.
  * Sometimes it's just better to refactor the code to allow <code>equals()</code> matching or even implement <code>equals()</code> method to help out with testing.
  * <p>
  * Also, read <a href="#15">section 15</a> or javadoc for {@link ArgumentCaptor} class.
@@ -275,7 +275,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * If you are using argument matchers, <b>all arguments</b> have to be provided
  * by matchers.
  * <p>
- The following example shows verification but the same applies to stubbing:
+ * The following example shows verification but the same applies to stubbing:
  *
  * <pre class="code"><code class="java">
  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq("third argument")</b>);
@@ -286,10 +286,10 @@ import org.mockito.verification.VerificationWithTimeout;
  * </code></pre>
  *
  * <p>
- * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.
+ * Matcher methods like <code>any()</code>, <code>eq()</code> <b>do not</b> return matchers.
  * Internally, they record a matcher on a stack and return a dummy value (usually null).
  * This implementation is due to static type safety imposed by the java compiler.
- * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.
+ * The consequence is that you cannot use <code>any()</code>, <code>eq()</code> methods outside of verified/stubbed method.
  *
  *
  *
@@ -320,6 +320,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * verify(mockedList, never()).add("never happened");
  *
  * //verification using atLeast()/atMost()
+ * verify(mockedList, atMostOnce()).add("once");
  * verify(mockedList, atLeastOnce()).add("three times");
  * verify(mockedList, atLeast(2)).add("three times");
  * verify(mockedList, atMost(5)).add("three times");
@@ -358,7 +359,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * //create an inOrder verifier for a single mock
  * InOrder inOrder = inOrder(singleMock);
  *
- * //following will make sure that add is first called with "was added first, then with "was added second"
+ * //following will make sure that add is first called with "was added first", then with "was added second"
  * inOrder.verify(singleMock).add("was added first");
  * inOrder.verify(singleMock).add("was added second");
  *
@@ -402,9 +403,6 @@ import org.mockito.verification.VerificationWithTimeout;
  * //verify that method was never called on a mock
  * verify(mockOne, never()).add("two");
  *
- * //verify that other mocks were not interacted
- * verifyZeroInteractions(mockTwo, mockThree);
- *
  * </code></pre>
  *
  *
@@ -427,8 +425,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.
  * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.
  * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
- * Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading
- * <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.
+ * Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests.
  *
  * <p>
  * See also {@link Mockito#never()} - it is more explicit and
@@ -455,16 +452,20 @@ import org.mockito.verification.VerificationWithTimeout;
  *       &#064;Mock private UserProvider userProvider;
  *
  *       private ArticleManager manager;
+ *
+ *       &#064;org.junit.jupiter.api.Test
+ *       void testSomethingInJunit5(&#064;Mock ArticleDatabase database) {
  * </code></pre>
  *
  * <b>Important!</b> This needs to be somewhere in the base class or a test
  * runner:
  *
  * <pre class="code"><code class="java">
- * MockitoAnnotations.initMocks(testClass);
+ * MockitoAnnotations.openMocks(testClass);
  * </code></pre>
  *
  * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoRule}.
+ * For JUnit5 tests, refer to the JUnit5 extension described in <a href="#45">section 45</a>.
  * <p>
  * Read more here: {@link MockitoAnnotations}
  *
@@ -524,7 +525,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Yet another controversial feature which was not included in Mockito
  * originally. We recommend simply stubbing with <code>thenReturn()</code> or
  * <code>thenThrow()</code>, which should be enough to test/test-drive
- * any clean & simple code. However, if you do have a need to stub with the generic Answer interface, here is an example:
+ * any clean and simple code. However, if you do have a need to stub with the generic Answer interface, here is an example:
  *
  * <pre class="code"><code class="java">
  * when(mock.someMethod(anyString())).thenAnswer(
@@ -598,8 +599,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks.
  * The reason was we thought partial mock is a code smell.
  * At some point we found legitimate use cases for partial mocks
- * (3rd party interfaces, interim refactoring of legacy code, the full article is
- * <a href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring">here</a>)
+ * (3rd party interfaces, interim refactoring of legacy code).
  * <p>
  *
  * <pre class="code"><code class="java">
@@ -680,7 +680,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * <h3 id="15">15. <a class="meaningful_link" href="#captors" name="captors">Capturing arguments</a> for further assertions (Since 1.8.0)</h3>
  *
  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.
- * This is also the recommended way of matching arguments because it makes tests clean & simple.
+ * This is also the recommended way of matching arguments because it makes tests clean and simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre class="code"><code class="java">
@@ -694,7 +694,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
- * Both techniques can be used for making sure certain arguments where passed to mocks.
+ * Both techniques can be used for making sure certain arguments were passed to mocks.
  * However, ArgumentCaptor may be a better fit if:
  * <ul>
  * <li>custom argument matcher is not likely to be reused</li>
@@ -707,9 +707,8 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <h3 id="16">16. <a class="meaningful_link" href="#partial_mocks" name="partial_mocks">Real partial mocks</a> (Since 1.8.0)</h3>
  *
- *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
- *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
- *  <a href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring">here</a>
+ *  Finally, after many internal debates and discussions on the mailing list, partial mock support was added to Mockito.
+ *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks.
  *  <p>
  *  <b>Before release 1.8</b> <code>spy()</code> was not producing real partial mocks and it was confusing for some users.
  *  Read more about spying: <a href="#13">here</a> or in javadoc for {@link Mockito#spy(Object)} method.
@@ -733,7 +732,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * <p>
  * However, there are rare cases when partial mocks come handy:
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
- * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+ * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
  *
  *
  *
@@ -745,7 +744,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * <p>
  * Instead of <code>reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.
  * <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.
- * Follow the whisper of your test methods: "Please keep us small & focused on single behavior".
+ * Follow the whisper of your test methods: "Please keep us small and focused on single behavior".
  * There are several threads about it on mockito mailing list.
  * <p>
  * The only reason we added <code>reset()</code> method is to
@@ -759,19 +758,19 @@ import org.mockito.verification.VerificationWithTimeout;
  *   mock.add(1);
  *
  *   reset(mock);
- *   //at this point the mock forgot any interactions & stubbing
+ *   //at this point the mock forgot any interactions and stubbing
  * </code></pre>
  *
  *
  *
  *
- * <h3 id="18">18. <a class="meaningful_link" href="#framework_validation" name="framework_validation">Troubleshooting & validating framework usage</a> (Since 1.8.0)</h3>
+ * <h3 id="18">18. <a class="meaningful_link" href="#framework_validation" name="framework_validation">Troubleshooting and validating framework usage</a> (Since 1.8.0)</h3>
  *
  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ:
  * <a href="https://github.com/mockito/mockito/wiki/FAQ">https://github.com/mockito/mockito/wiki/FAQ</a>
  * <p>
  * In case of questions you may also post to mockito mailing list:
- * <a href="http://groups.google.com/group/mockito">http://groups.google.com/group/mockito</a>
+ * <a href="https://groups.google.com/group/mockito">https://groups.google.com/group/mockito</a>
  * <p>
  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>.
  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
@@ -784,7 +783,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
- * Start learning about BDD here: <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
+ * Start learning about BDD here: <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">https://en.wikipedia.org/wiki/Behavior-driven_development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test.
@@ -827,7 +826,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *   List serializableMock = mock(List.class, withSettings().serializable());
  * </code></pre>
  * <p>
- * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
+ * The mock can be serialized assuming all the normal <a href='https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html'>
  * serialization requirements</a> are met by the class.
  * <p>
  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version
@@ -864,7 +863,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * should only use partial mocks as a last resort. See point 16 about partial mocks.
  *
  * <p>
- * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.
+ * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#openMocks(Object)}.
  * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:
  * {@link MockitoRule}.
  * <p>
@@ -908,7 +907,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields
  * using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.
  * <p>
- * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}
+ * To take advantage of this feature you need to use {@link MockitoAnnotations#openMocks(Object)}, {@link MockitoJUnitRunner}
  * or {@link MockitoRule}.
  * <p>
  * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}
@@ -930,7 +929,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * Mockito will now allow you to create mocks when stubbing.
  * Basically, it allows to create a stub in one line of code.
  * This can be helpful to keep test code clean.
- * For example, some boring stub can be created & stubbed at field initialization in a test:
+ * For example, some boring stub can be created and stubbed at field initialization in a test:
  * <pre class="code"><code class="java">
  * public class CarTest {
  *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();
@@ -1077,7 +1076,7 @@ import org.mockito.verification.VerificationWithTimeout;
  * SomeAbstract spy = spy(SomeAbstract.class);
  *
  * //Mocking abstract methods, spying default methods of an interface (only available since 2.7.13)
- * Function<Foo, Bar> function = spy(Function.class);
+ * Function&lt;Foo, Bar&gt; function = spy(Function.class);
  *
  * //Robust API, via settings builder:
  * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
@@ -1101,7 +1100,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * Mockito introduces serialization across classloader.
  *
- * Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers.
+ * Like with any other form of serialization, all types in the mock hierarchy have to serializable, including answers.
  * As this serialization mode require considerably more work, this is an opt-in setting.
  *
  * <pre class="code"><code class="java">
@@ -1145,7 +1144,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <ul>
  *     <li>Annotating the JUnit test class with a <code>&#064;{@link org.junit.runner.RunWith}({@link MockitoJUnitRunner}.class)</code></li>
- *     <li>Invoking <code>{@link MockitoAnnotations#initMocks(Object)}</code> in the <code>&#064;{@link org.junit.Before}</code> method</li>
+ *     <li>Invoking <code>{@link MockitoAnnotations#openMocks(Object)}</code> in the <code>&#064;{@link org.junit.Before}</code> method</li>
  * </ul>
  *
  * Now you can choose to use a rule :
@@ -1201,21 +1200,21 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * // verify a list only had strings of a certain length added to it
  * // note - this will only compile under Java 8
- * verify(list, times(2)).add(argThat(string -> string.length() < 5));
+ * verify(list, times(2)).add(argThat(string -&gt; string.length() &lt; 5));
  *
  * // Java 7 equivalent - not as neat
- * verify(list, times(2)).add(argThat(new ArgumentMatcher<String>(){
+ * verify(list, times(2)).add(argThat(new ArgumentMatcher&lt;String&gt;(){
  *     public boolean matches(String arg) {
- *         return arg.length() < 5;
+ *         return arg.length() &lt; 5;
  *     }
  * }));
  *
  * // more complex Java 8 example - where you can specify complex verification behaviour functionally
- * verify(target, times(1)).receiveComplexObject(argThat(obj -> obj.getSubObject().get(0).equals("expected")));
+ * verify(target, times(1)).receiveComplexObject(argThat(obj -&gt; obj.getSubObject().get(0).equals("expected")));
  *
  * // this can also be used when defining the behaviour of a mock under different inputs
  * // in this case if the input list was fewer than 3 items the mock returns null
- * when(mock.someMethod(argThat(list -> list.size()<3))).thenReturn(null);
+ * when(mock.someMethod(argThat(list -&gt; list.size()&lt;3))).thenReturn(null);
  * </code></pre>
  *
  * <h3 id="37">37. <a class="meaningful_link" href="#Java_8_Custom_Answers" name="Java_8_Custom_Answers">Java 8 Custom Answer Support</a> (Since 2.1.0)</h3>
@@ -1229,12 +1228,12 @@ import org.mockito.verification.VerificationWithTimeout;
  * <p>
  * <pre class="code"><code class="java">
  * // answer by returning 12 every time
- * doAnswer(invocation -> 12).when(mock).doSomething();
+ * doAnswer(invocation -&gt; 12).when(mock).doSomething();
  *
  * // answer by using one of the parameters - converting into the right
  * // type as your go - in this case, returning the length of the second string parameter
  * // as the answer. This gets long-winded quickly, with casting of parameters.
- * doAnswer(invocation -> ((String)invocation.getArgument(1)).length())
+ * doAnswer(invocation -&gt; ((String)invocation.getArgument(1)).length())
  *     .when(mock).doSomething(anyString(), anyString(), anyString());
  * </code></pre>
  *
@@ -1242,8 +1241,8 @@ import org.mockito.verification.VerificationWithTimeout;
  * as Java 8 lambdas. Even in Java 7 and lower these custom answers based on a typed interface can reduce boilerplate.
  * In particular, this approach will make it easier to test functions which use callbacks.
  *
- * The methods {@link AdditionalAnswers#answer(Answer1) answer} and {@link AdditionalAnswers#answerVoid(VoidAnswer1) answerVoid}
- * can be used to create the answer. They rely on the related answer interfaces in {@link org.mockito.stubbing} that
+ * The methods {@link AdditionalAnswers#answer(Answer1)}} and {@link AdditionalAnswers#answerVoid(VoidAnswer1)}
+ * can be used to create the answer. They rely on the related answer interfaces in org.mockito.stubbing that
  * support answers up to 5 parameters.
  *
  * <p>
@@ -1259,11 +1258,11 @@ import org.mockito.verification.VerificationWithTimeout;
  * void receive(String item);
  *
  * // Java 8 - style 1
- * doAnswer(AdditionalAnswers.<String,Callback>answerVoid((operand, callback) -> callback.receive("dummy"))
+ * doAnswer(AdditionalAnswers.&lt;String,Callback&gt;answerVoid((operand, callback) -&gt; callback.receive("dummy"))
  *     .when(mock).execute(anyString(), any(Callback.class));
  *
  * // Java 8 - style 2 - assuming static import of AdditionalAnswers
- * doAnswer(answerVoid((String operand, Callback callback) -> callback.receive("dummy"))
+ * doAnswer(answerVoid((String operand, Callback callback) -&gt; callback.receive("dummy"))
  *     .when(mock).execute(anyString(), any(Callback.class));
  *
  * // Java 8 - style 3 - where mocking function to is a static member of test class
@@ -1275,7 +1274,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *     .when(mock).execute(anyString(), any(Callback.class));
  *
  * // Java 7
- * doAnswer(answerVoid(new VoidAnswer2<String, Callback>() {
+ * doAnswer(answerVoid(new VoidAnswer2&lt;String, Callback&gt;() {
  *     public void answer(String operation, Callback callback) {
  *         callback.receive("dummy");
  *     }})).when(mock).execute(anyString(), any(Callback.class));
@@ -1287,11 +1286,11 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * // this could be mocked
  * // Java 8
- * doAnswer(AdditionalAnswers.<Boolean,String,String>answer((input1, input2) -> input1.equals(input2))))
+ * doAnswer(AdditionalAnswers.&lt;Boolean,String,String&gt;answer((input1, input2) -&gt; input1.equals(input2))))
  *     .when(mock).execute(anyString(), anyString());
  *
  * // Java 7
- * doAnswer(answer(new Answer2<String, String, String>() {
+ * doAnswer(answer(new Answer2&lt;String, String, String&gt;() {
  *     public String answer(String input1, String input2) {
  *         return input1 + input2;
  *     }})).when(mock).execute(anyString(), anyString());
@@ -1361,7 +1360,7 @@ import org.mockito.verification.VerificationWithTimeout;
  *     </li>
  *     <li>This mock maker has been designed around Java Agent runtime attachment ; this require a compatible JVM,
  *     that is part of the JDK (or Java 9 VM). When running on a non-JDK VM prior to Java 9, it is however possible to
- *     manually add the <a href="http://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
+ *     manually add the <a href="https://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
  *     parameter upon starting the JVM.
  *     </li>
  * </ul>
@@ -1375,9 +1374,11 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * To quickly find out how "stricter" Mockito can make you more productive and get your tests cleaner, see:
  * <ul>
- *     <li>Strict stubbing with JUnit Rules - {@link MockitoRule#strictness(Strictness)} with {@link Strictness#STRICT_STUBS}</li>
- *     <li>Strict stubbing with JUnit Runner - {@link MockitoJUnitRunner.StrictStubs}</li>
- *     <li>Strict stubbing if you cannot use runner/rule (like TestNG) - {@link MockitoSession}</li>
+ *     <li>Strict stubbing with JUnit4 Rules - {@link MockitoRule#strictness(Strictness)} with {@link Strictness#STRICT_STUBS}</li>
+ *     <li>Strict stubbing with JUnit4 Runner - {@link Strict MockitoJUnitRunner.Strict}</li>
+ *     <li>Strict stubbing with JUnit5 Extension - <code>org.mockito.junit.jupiter.MockitoExtension</code></li>
+ *     <li>Strict stubbing with TestNG Listener <a href="https://github.com/mockito/mockito-testng">MockitoTestNGListener</a></li>
+ *     <li>Strict stubbing if you cannot use runner/rule - {@link MockitoSession}</li>
  *     <li>Unnecessary stubbing detection with {@link MockitoJUnitRunner}</li>
  *     <li>Stubbing argument mismatch warnings, documented in {@link MockitoHint}</li>
  * </ul>
@@ -1434,16 +1435,11 @@ import org.mockito.verification.VerificationWithTimeout;
  *      Provides access to invocation container object which has no methods (marker interface).
  *      Container is needed to hide the internal implementation and avoid leaking it to the public API.
  *     </li>
- *     <li>Changed {@link Stubbing} -
+ *     <li>Changed {@link org.mockito.stubbing.Stubbing} -
  *      it now extends {@link Answer} interface.
  *      It is backwards compatible because Stubbing interface is not extensible (see {@link NotExtensible}).
  *      The change should be seamless to our users.
  *     </li>
- *     <li>Deprecated {@link InternalMockHandler} -
- *       In order to accommodate API changes we needed to deprecate this interface.
- *       The interface was always documented as internal, we don't have evidence it was used by the community.
- *       The deprecation should be completely seamless for our users.
- *     </li>
  *     <li>{@link NotExtensible} -
  *       Public annotation that indicates to the user that she should not provide custom implementations of given type.
  *       Helps framework integrators and our users understand how to use Mockito API safely.
@@ -1501,16 +1497,16 @@ import org.mockito.verification.VerificationWithTimeout;
  *
  * <h3 id="44">44. <a class="meaningful_link" href="#mockito_instantiator_provider_deprecation" name="mockito_instantiator_provider_deprecation">
  *       Deprecated <code>org.mockito.plugins.InstantiatorProvider</code> as it was leaking internal API. it was
- *       replaced by <code>org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)</a></h3>
+ *       replaced by <code>org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)</code></a></h3>
  *
- * <p>{@link org.mockito.plugins.InstantiatorProvider} returned an internal API. Hence it was deprecated and replaced
- * by {@link org.mockito.plugins.InstantiatorProvider2}. Old {@link org.mockito.plugins.InstantiatorProvider
- * instantiator providers} will continue to work, but it is recommended to switch to the new API.</p>
+ * <p>org.mockito.plugins.InstantiatorProvider returned an internal API. Hence it was deprecated and replaced
+ * by {@link org.mockito.plugins.InstantiatorProvider2}. org.mockito.plugins.InstantiatorProvider
+ * has now been removed.</p>
  *
  * <h3 id="45">45. <a class="meaningful_link" href="#junit5_mockito" name="junit5_mockito">New JUnit Jupiter (JUnit5+) extension</a></h3>
  *
  * For integration with JUnit Jupiter (JUnit5+), use the `org.mockito:mockito-junit-jupiter` artifact.
- * For more information about the usage of the integration, see <a href="http://javadoc.io/page/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html">the JavaDoc of <code>MockitoExtension</code></a>.
+ * For more information about the usage of the integration, see <a href="https://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html">the JavaDoc of <code>MockitoExtension</code></a>.
  *
  * <h3 id="46">46. <a class="meaningful_link" href="#mockito_lenient" name="mockito_lenient">
  *       New <code>Mockito.lenient()</code> and <code>MockSettings.lenient()</code> methods (Since 2.20.0)</a></h3>
@@ -1542,7 +1538,76 @@ import org.mockito.verification.VerificationWithTimeout;
  * Hence, we introduced a new API to explicitly clear mock state (only make sense in inline mocking!).
  * See example usage in {@link MockitoFramework#clearInlineMocks()}.
  * If you have feedback or a better idea how to solve the problem please reach out.
+ *
+ *
+ * <h3 id="48">48. <a class="meaningful_link" href="#static_mocks" name="static_mocks">Mocking static methods</a> (since 3.4.0)</h3>
+ *
+ * When using the <a href="#0.2">inline mock maker</a>, it is possible to mock static method invocations within the current
+ * thread and a user-defined scope. This way, Mockito assures that concurrently and sequentially running tests do not interfere.
+ *
+ * To make sure a static mock remains temporary, it is recommended to define the scope within a try-with-resources construct.
+ * In the following example, the <code>Foo</code> type's static method would return <code>foo</code> unless mocked:
+ *
+ * <pre class="code"><code class="java">
+ * assertEquals("foo", Foo.method());
+ * try (MockedStatic<Foo> mocked = mockStatic(Foo.class)) {
+ * mocked.when(Foo::method).thenReturn("bar");
+ * assertEquals("bar", Foo.method());
+ * mocked.verify(Foo::method);
+ * }
+ * assertEquals("foo", Foo.method());
+ * </code></pre>
+ *
+ * Due to the defined scope of the static mock, it returns to its original behavior once the scope is released. To define mock
+ * behavior and to verify static method invocations, use the <code>MockedStatic</code> that is returned.
+ * <p>
+ *
+ * <h3 id="49">49. <a class="meaningful_link" href="#mocked_construction" name="mocked_construction">Mocking object construction</a> (since 3.5.0)</h3>
+ *
+ * When using the <a href="#0.2">inline mock maker</a>, it is possible to generate mocks on constructor invocations within the current
+ * thread and a user-defined scope. This way, Mockito assures that concurrently and sequentially running tests do not interfere.
+ *
+ * To make sure a constructor mocks remain temporary, it is recommended to define the scope within a try-with-resources construct.
+ * In the following example, the <code>Foo</code> type's construction would generate a mock:
+ *
+ * <pre class="code"><code class="java">
+ * assertEquals("foo", new Foo().method());
+ * try (MockedConstruction<Foo> mocked = mockConstruction(Foo.class)) {
+ * Foo foo = new Foo();
+ * when(foo.method()).thenReturn("bar");
+ * assertEquals("bar", foo.method());
+ * verify(foo).method();
+ * }
+ * assertEquals("foo", new Foo().method());
+ * </code></pre>
+ *
+ * Due to the defined scope of the mocked construction, object construction returns to its original behavior once the scope is
+ * released. To define mock behavior and to verify method invocations, use the <code>MockedConstruction</code> that is returned.
+ * <p>
+ *
+ * <h3 id="50">50. <a class="meaningful_link" href="#proxy_mock_maker" name="mocked_construction">Avoiding code generation when only interfaces are mocked</a> (since 3.12.2)</h3>
+ *
+ * The JVM offers the {@link java.lang.reflect.Proxy} facility for creating dynamic proxies of interface types. For most applications, Mockito
+ * must be capable of mocking classes as supported by the default mock maker, or even final classes, as supported by the inline mock maker. To
+ * create such mocks, Mockito requires to setup diverse JVM facilities and must apply code generation. If only interfaces are supposed to be
+ * mocked, one can however choose to use a org.mockito.internal.creation.proxy.ProxyMockMaker that is based on the {@link java.lang.reflect.Proxy}
+ * API which avoids diverse overhead of the other mock makers but also limits mocking to interfaces.
+ *
+ * This mock maker can be activated explicitly by the mockito extension mechanism, just create in the classpath a file
+ * <code>/mockito-extensions/org.mockito.plugins.MockMaker</code> containing the value <code>mock-maker-proxy</code>.
+ *
+ * <h3 id="51">51. <a class="meaningful_link" href="#do_not_mock" name="do_not_mock">Mark classes as unmockable</a> (since 4.1.0)</h3>
+ *
+ * In some cases, mocking a class/interface can lead to unexpected runtime behavior. For example, mocking a <code>java.util.List</code>
+ * is difficult, given the requirements imposed by the interface. This means that on runtime, depending on what methods the application
+ * calls on the list, your mock might behave in such a way that it violates the interface.
+ *
+ * <p>
+ * For any class/interface you own that is problematic to mock, you can now mark the class with {@link org.mockito.DoNotMock @DoNotMock}. For usage
+ * of the annotation and how to ship your own (to avoid a compile time dependency on a test artifact), please see its JavaDoc.
+ * <p>
  */
+@CheckReturnValue
 @SuppressWarnings("unchecked")
 public class Mockito extends ArgumentMatchers {
 
@@ -1573,8 +1638,6 @@ public class Mockito extends ArgumentMatchers {
      * <code>ReturnsSmartNulls</code> first tries to return ordinary values (zeros, empty collections, empty string, etc.)
      * then it tries to return SmartNull. If the return type is final then plain <code>null</code> is returned.
      * <p>
-     * <code>ReturnsSmartNulls</code> will be probably the default return values strategy in Mockito 3.0.0
-     * <p>
      * Example:
      * <pre class="code"><code class="java">
      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
@@ -1694,6 +1757,7 @@ public class Mockito extends ArgumentMatchers {
 
     /**
      * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}
+     *
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
@@ -1709,7 +1773,7 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * However, there are rare cases when partial mocks come handy:
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
      * <p>
      * Example:
      * <pre class="code"><code class="java">
@@ -1725,8 +1789,11 @@ public class Mockito extends ArgumentMatchers {
      * </code></pre>
      *
      * <p>
-     * <u>Note:</u> Stubbing partial mocks using <code>when(mock.getSomething()).thenReturn(fakeValue)</code>
+     * <u>Note 1:</u> Stubbing partial mocks using <code>when(mock.getSomething()).thenReturn(fakeValue)</code>
      * syntax will call the real method. For partial mock it's recommended to use <code>doReturn</code> syntax.
+     * <p>
+     * <u>Note 2:</u> If the mock is serialized then deserialized, then this answer will not be able to understand
+     * generics metadata.
      */
     public static final Answer<Object> CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;
 
@@ -1809,7 +1876,6 @@ public class Mockito extends ArgumentMatchers {
      * @param classToMock class or interface to mock
      * @return mock object
      */
-    @CheckReturnValue
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings());
     }
@@ -1829,11 +1895,8 @@ public class Mockito extends ArgumentMatchers {
      * @param name of the mock
      * @return mock object
      */
-    @CheckReturnValue
     public static <T> T mock(Class<T> classToMock, String name) {
-        return mock(classToMock, withSettings()
-                .name(name)
-                .defaultAnswer(RETURNS_DEFAULTS));
+        return mock(classToMock, withSettings().name(name).defaultAnswer(RETURNS_DEFAULTS));
     }
 
     /**
@@ -1848,7 +1911,6 @@ public class Mockito extends ArgumentMatchers {
      * @return A {@link org.mockito.MockingDetails} instance.
      * @since 1.9.5
      */
-    @CheckReturnValue
     public static MockingDetails mockingDetails(Object toInspect) {
         return MOCKITO_CORE.mockingDetails(toInspect);
     }
@@ -1872,7 +1934,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return mock object
      */
-    @CheckReturnValue
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
@@ -1900,7 +1961,6 @@ public class Mockito extends ArgumentMatchers {
      * @param mockSettings additional mock settings
      * @return mock object
      */
-    @CheckReturnValue
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
         return MOCKITO_CORE.mock(classToMock, mockSettings);
     }
@@ -1918,7 +1978,7 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * However, there are rare cases when partial mocks come handy:
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
      * <p>
      * Example:
      *
@@ -1984,11 +2044,10 @@ public class Mockito extends ArgumentMatchers {
      *            to spy on
      * @return a spy of the real object
      */
-    @CheckReturnValue
     public static <T> T spy(T object) {
-        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
-                .spiedInstance(object)
-                .defaultAnswer(CALLS_REAL_METHODS));
+        return MOCKITO_CORE.mock(
+                (Class<T>) object.getClass(),
+                withSettings().spiedInstance(object).defaultAnswer(CALLS_REAL_METHODS));
     }
 
     /**
@@ -2018,12 +2077,224 @@ public class Mockito extends ArgumentMatchers {
      * @return a spy of the provided class
      * @since 1.10.12
      */
-    @Incubating
-    @CheckReturnValue
     public static <T> T spy(Class<T> classToSpy) {
-        return MOCKITO_CORE.mock(classToSpy, withSettings()
-                .useConstructor()
-                .defaultAnswer(CALLS_REAL_METHODS));
+        return MOCKITO_CORE.mock(
+                classToSpy, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
+    }
+
+    /**
+     * Creates a thread-local mock controller for all static methods of the given class or interface.
+     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
+     * classes used by custom class loaders used to executed the block with the mocked class. A mock
+     * maker might forbid mocking static methods of know classes that are known to cause problems.
+     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
+     * explicitly forbidden.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock class or interface of which static mocks should be mocked.
+     * @return mock controller
+     */
+    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock) {
+        return mockStatic(classToMock, withSettings());
+    }
+
+    /**
+     * Creates a thread-local mock controller for all static methods of the given class or interface.
+     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
+     * classes used by custom class loaders used to executed the block with the mocked class. A mock
+     * maker might forbid mocking static methods of know classes that are known to cause problems.
+     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
+     * explicitly forbidden.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock class or interface of which static mocks should be mocked.
+     * @param defaultAnswer the default answer when invoking static methods.
+     * @return mock controller
+     */
+    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, Answer defaultAnswer) {
+        return mockStatic(classToMock, withSettings().defaultAnswer(defaultAnswer));
+    }
+
+    /**
+     * Creates a thread-local mock controller for all static methods of the given class or interface.
+     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
+     * classes used by custom class loaders used to executed the block with the mocked class. A mock
+     * maker might forbid mocking static methods of know classes that are known to cause problems.
+     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
+     * explicitly forbidden.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock class or interface of which static mocks should be mocked.
+     * @param name the name of the mock to use in error messages.
+     * @return mock controller
+     */
+    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, String name) {
+        return mockStatic(classToMock, withSettings().name(name));
+    }
+
+    /**
+     * Creates a thread-local mock controller for all static methods of the given class or interface.
+     * The returned object's {@link MockedStatic#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * <b>Note</b>: We recommend against mocking static methods of classes in the standard library or
+     * classes used by custom class loaders used to executed the block with the mocked class. A mock
+     * maker might forbid mocking static methods of know classes that are known to cause problems.
+     * Also, if a static method is a JVM-intrinsic, it cannot typically be mocked even if not
+     * explicitly forbidden.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock class or interface of which static mocks should be mocked.
+     * @param mockSettings the settings to use where only name and default answer are considered.
+     * @return mock controller
+     */
+    public static <T> MockedStatic<T> mockStatic(Class<T> classToMock, MockSettings mockSettings) {
+        return MOCKITO_CORE.mockStatic(classToMock, mockSettings);
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param defaultAnswer the default answer for the first created mock.
+     * @param additionalAnswers the default answer for all additional mocks. For any access mocks, the
+     *                         last answer is used. If this array is empty, the {@code defaultAnswer} is used.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstructionWithAnswer(
+            Class<T> classToMock, Answer defaultAnswer, Answer... additionalAnswers) {
+        return mockConstruction(
+                classToMock,
+                context -> {
+                    if (context.getCount() == 1 || additionalAnswers.length == 0) {
+                        return withSettings().defaultAnswer(defaultAnswer);
+                    } else if (context.getCount() > additionalAnswers.length) {
+                        return withSettings()
+                                .defaultAnswer(additionalAnswers[additionalAnswers.length - 1]);
+                    } else {
+                        return withSettings()
+                                .defaultAnswer(additionalAnswers[context.getCount() - 2]);
+                    }
+                },
+                (mock, context) -> {});
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(Class<T> classToMock) {
+        return mockConstruction(classToMock, index -> withSettings(), (mock, context) -> {});
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(
+            Class<T> classToMock, MockedConstruction.MockInitializer<T> mockInitializer) {
+        return mockConstruction(classToMock, withSettings(), mockInitializer);
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param mockSettings the mock settings to use.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(
+            Class<T> classToMock, MockSettings mockSettings) {
+        return mockConstruction(classToMock, context -> mockSettings);
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param mockSettingsFactory the mock settings to use.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(
+            Class<T> classToMock,
+            Function<MockedConstruction.Context, MockSettings> mockSettingsFactory) {
+        return mockConstruction(classToMock, mockSettingsFactory, (mock, context) -> {});
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param mockSettings the settings to use.
+     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(
+            Class<T> classToMock,
+            MockSettings mockSettings,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        return mockConstruction(classToMock, index -> mockSettings, mockInitializer);
+    }
+
+    /**
+     * Creates a thread-local mock controller for all constructions of the given class.
+     * The returned object's {@link MockedConstruction#close()} method must be called upon completing the
+     * test or the mock will remain active on the current thread.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @param classToMock non-abstract class of which constructions should be mocked.
+     * @param mockSettingsFactory a function to create settings to use.
+     * @param mockInitializer a callback to prepare a mock's methods after its instantiation.
+     * @return mock controller
+     */
+    public static <T> MockedConstruction<T> mockConstruction(
+            Class<T> classToMock,
+            Function<MockedConstruction.Context, MockSettings> mockSettingsFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        return MOCKITO_CORE.mockConstruction(classToMock, mockSettingsFactory, mockInitializer);
     }
 
     /**
@@ -2079,7 +2350,6 @@ public class Mockito extends ArgumentMatchers {
      * Let's say you've stubbed <code>foo.bar()</code>.
      * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
      * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.
-     * Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
      *
      * <p>
      * See examples in javadoc for {@link Mockito} class
@@ -2087,7 +2357,6 @@ public class Mockito extends ArgumentMatchers {
      * @return OngoingStubbing object used to stub fluently.
      *         <strong>Do not</strong> create a reference to this returned object.
      */
-    @CheckReturnValue
     public static <T> OngoingStubbing<T> when(T methodCall) {
         return MOCKITO_CORE.when(methodCall);
     }
@@ -2110,8 +2379,7 @@ public class Mockito extends ArgumentMatchers {
      * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
      * Let's say you've stubbed <code>foo.bar()</code>.
      * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
-     * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.
-     * Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
+     * If your code doesn't care what <code>foo.bar()</code> returns then it should not be stubbed.
      *
      * <p>
      * See examples in javadoc for {@link Mockito} class
@@ -2119,7 +2387,6 @@ public class Mockito extends ArgumentMatchers {
      * @param mock to be verified
      * @return mock object itself
      */
-    @CheckReturnValue
     public static <T> T verify(T mock) {
         return MOCKITO_CORE.verify(mock, times(1));
     }
@@ -2146,7 +2413,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return mock object itself
      */
-    @CheckReturnValue
     public static <T> T verify(T mock, VerificationMode mode) {
         return MOCKITO_CORE.verify(mock, mode);
     }
@@ -2157,7 +2423,7 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * Instead of <code>#reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.
      * <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.
-     * Follow the whisper of your test methods: "Please keep us small & focused on single behavior".
+     * Follow the whisper of your test methods: "Please keep us small and focused on single behavior".
      * There are several threads about it on mockito mailing list.
      * <p>
      * The only reason we added <code>reset()</code> method is to
@@ -2171,16 +2437,27 @@ public class Mockito extends ArgumentMatchers {
      *   mock.add(1);
      *
      *   reset(mock);
-     *   //at this point the mock forgot any interactions & stubbing
+     *   //at this point the mock forgot any interactions and stubbing
      * </code></pre>
      *
      * @param <T> The Type of the mocks
      * @param mocks to be reset
      */
-    public static <T> void reset(T ... mocks) {
+    public static <T> void reset(T... mocks) {
         MOCKITO_CORE.reset(mocks);
     }
 
+    /**
+     * Clears all mocks, type caches and instrumentations.
+     * <p>
+     * By clearing Mockito's state, previously created mocks might begin to malfunction. This option can be used if
+     * Mockito's caches take up too much space or if the inline mock maker's instrumentation is causing performance
+     * issues in code where mocks are no longer used. Normally, you would not need to use this option.
+     */
+    public static void clearAllCaches() {
+        MOCKITO_CORE.clearAllCaches();
+    }
+
     /**
      * Use this method in order to only clear invocations, when stubbing is non-trivial. Use-cases can be:
      * <ul>
@@ -2192,7 +2469,7 @@ public class Mockito extends ArgumentMatchers {
      * @param <T> The type of the mocks
      * @param mocks The mocks to clear the invocations for
      */
-    public static <T> void clearInvocations(T ... mocks) {
+    public static <T> void clearInvocations(T... mocks) {
         MOCKITO_CORE.clearInvocations(mocks);
     }
 
@@ -2213,8 +2490,7 @@ public class Mockito extends ArgumentMatchers {
      * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.
      * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.
      * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
-     * Abusing it leads to overspecified, less maintainable tests. You can find further reading
-     * <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.
+     * Abusing it leads to overspecified, less maintainable tests.
      * <p>
      * This method will also detect unverified invocations that occurred before the test method,
      * for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
@@ -2245,13 +2521,23 @@ public class Mockito extends ArgumentMatchers {
     }
 
     /**
-     * Verifies that no interactions happened on given mocks beyond the previously verified interactions.<br/>
-     * This method has the same behavior as {@link #verifyNoMoreInteractions(Object...)}.
+     * Verifies that no interactions happened on given mocks.
+     * <pre class="code"><code class="java">
+     *   verifyNoInteractions(mockOne, mockTwo);
+     * </code></pre>
+     * This method will also detect invocations
+     * that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
+     * Consider writing nice code that makes interactions only in test methods.
+     * <p>
+     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
      *
      * @param mocks to be verified
+     * @since 3.0.1
      */
-    public static void verifyZeroInteractions(Object... mocks) {
-        MOCKITO_CORE.verifyNoMoreInteractions(mocks);
+    public static void verifyNoInteractions(Object... mocks) {
+        MOCKITO_CORE.verifyNoInteractions(mocks);
     }
 
     /**
@@ -2269,7 +2555,6 @@ public class Mockito extends ArgumentMatchers {
      * @param toBeThrown to be thrown when the stubbed method is called
      * @return stubber - to select a method for stubbing
      */
-    @CheckReturnValue
     public static Stubber doThrow(Throwable... toBeThrown) {
         return MOCKITO_CORE.stubber().doThrow(toBeThrown);
     }
@@ -2292,7 +2577,6 @@ public class Mockito extends ArgumentMatchers {
      * @return stubber - to select a method for stubbing
      * @since 2.1.0
      */
-    @CheckReturnValue
     public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {
         return MOCKITO_CORE.stubber().doThrow(toBeThrown);
     }
@@ -2317,14 +2601,14 @@ public class Mockito extends ArgumentMatchers {
      * @return stubber - to select a method for stubbing
      * @since 2.1.0
      */
-    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
-    @SuppressWarnings ({"unchecked", "varargs"})
-    @CheckReturnValue
-    public static Stubber doThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... toBeThrownNext) {
+    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
+    // creation
+    @SuppressWarnings({"unchecked", "varargs"})
+    public static Stubber doThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... toBeThrownNext) {
         return MOCKITO_CORE.stubber().doThrow(toBeThrown, toBeThrownNext);
     }
 
-
     /**
      * Use <code>doCallRealMethod()</code> when you want to call the real implementation of a method.
      * <p>
@@ -2336,7 +2620,7 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * However, there are rare cases when partial mocks come handy:
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
      * <p>
      * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
      * <b>Mockito.spy() is a recommended way of creating partial mocks.</b>
@@ -2356,7 +2640,6 @@ public class Mockito extends ArgumentMatchers {
      * @return stubber - to select a method for stubbing
      * @since 1.9.5
      */
-    @CheckReturnValue
     public static Stubber doCallRealMethod() {
         return MOCKITO_CORE.stubber().doCallRealMethod();
     }
@@ -2383,7 +2666,6 @@ public class Mockito extends ArgumentMatchers {
      * @param answer to answer when the stubbed method is called
      * @return stubber - to select a method for stubbing
      */
-    @CheckReturnValue
     public static Stubber doAnswer(Answer answer) {
         return MOCKITO_CORE.stubber().doAnswer(answer);
     }
@@ -2426,7 +2708,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return stubber - to select a method for stubbing
      */
-    @CheckReturnValue
     public static Stubber doNothing() {
         return MOCKITO_CORE.stubber().doNothing();
     }
@@ -2477,7 +2758,6 @@ public class Mockito extends ArgumentMatchers {
      * @param toBeReturned to be returned when the stubbed method is called
      * @return stubber - to select a method for stubbing
      */
-    @CheckReturnValue
     public static Stubber doReturn(Object toBeReturned) {
         return MOCKITO_CORE.stubber().doReturn(toBeReturned);
     }
@@ -2532,7 +2812,6 @@ public class Mockito extends ArgumentMatchers {
      * @since 2.1.0
      */
     @SuppressWarnings({"unchecked", "varargs"})
-    @CheckReturnValue
     public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {
         return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);
     }
@@ -2554,9 +2833,9 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * <code>InOrder</code> verification is 'greedy', but you will hardly ever notice it.
      * If you want to find out more, read
-     * <a href="https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder">this wiki page</a>.
+     * <a href="https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verification-InOrder">this wiki page</a>.
      * <p>
-     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
+     * As of Mockito 1.8.4 you can verifyNoMoreInteractions() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      *
@@ -2564,7 +2843,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return InOrder object to be used to verify in order
      */
-    @CheckReturnValue
     public static InOrder inOrder(Object... mocks) {
         return MOCKITO_CORE.inOrder(mocks);
     }
@@ -2665,7 +2943,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode times(int wantedNumberOfInvocations) {
         return VerificationModeFactory.times(wantedNumberOfInvocations);
     }
@@ -2680,14 +2957,12 @@ public class Mockito extends ArgumentMatchers {
      *
      * <p>
      * If you want to verify there were NO interactions with the mock
-     * check out {@link Mockito#verifyZeroInteractions(Object...)}
-     * or {@link Mockito#verifyNoMoreInteractions(Object...)}
+     * check out {@link Mockito#verifyNoMoreInteractions(Object...)}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode never() {
         return times(0);
     }
@@ -2703,7 +2978,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode atLeastOnce() {
         return VerificationModeFactory.atLeastOnce();
     }
@@ -2720,11 +2994,25 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode atLeast(int minNumberOfInvocations) {
         return VerificationModeFactory.atLeast(minNumberOfInvocations);
     }
 
+    /**
+     * Allows at-most-once verification. E.g:
+     * <pre class="code"><code class="java">
+     *   verify(mock, atMostOnce()).someMethod("some arg");
+     * </code></pre>
+     * Alias to <code>atMost(1)</code>.
+     * <p>
+     * See examples in javadoc for {@link Mockito} class
+     *
+     * @return verification mode
+     */
+    public static VerificationMode atMostOnce() {
+        return VerificationModeFactory.atMostOnce();
+    }
+
     /**
      * Allows at-most-x verification. E.g:
      * <pre class="code"><code class="java">
@@ -2737,7 +3025,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode atMost(int maxNumberOfInvocations) {
         return VerificationModeFactory.atMost(maxNumberOfInvocations);
     }
@@ -2755,9 +3042,8 @@ public class Mockito extends ArgumentMatchers {
      * @param wantedNumberOfInvocations number of invocations to verify
      * @return  verification mode
      */
-    @CheckReturnValue
-    public static VerificationMode calls( int wantedNumberOfInvocations ){
-        return VerificationModeFactory.calls( wantedNumberOfInvocations );
+    public static VerificationMode calls(int wantedNumberOfInvocations) {
+        return VerificationModeFactory.calls(wantedNumberOfInvocations);
     }
 
     /**
@@ -2766,7 +3052,7 @@ public class Mockito extends ArgumentMatchers {
      *   verify(mock, only()).someMethod();
      *   //above is a shorthand for following 2 lines of code:
      *   verify(mock).someMethod();
-     *   verifyNoMoreInvocations(mock);
+     *   verifyNoMoreInteractions(mock);
      * </code></pre>
      *
      * <p>
@@ -2776,20 +3062,18 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return verification mode
      */
-    @CheckReturnValue
     public static VerificationMode only() {
         return VerificationModeFactory.only();
     }
 
     /**
-     * Verification will be triggered after given amount of millis, allowing testing of async code.
+     * Verification will be triggered over and over until the given amount of millis, allowing testing of async code.
      * Useful when interactions with the mock object did not happened yet.
-     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
+     * Extensive use of {@code timeout()} method can be a code smell - there are better ways of testing concurrent code.
      * <p>
      * See also {@link #after(long)} method for testing async code.
      * Differences between {@code timeout()} and {@code after} are explained in Javadoc for {@link #after(long)}.
-     * <p>
-     * Extensive use of {@code timeout()} method can be a code smell - there are better ways of testing concurrent code.
+     *
      * <pre class="code"><code class="java">
      *   //passes when someMethod() is called no later than within 100 ms
      *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
@@ -2810,7 +3094,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return object that allows fluent specification of the verification (times(x), atLeast(y), etc.)
      */
-    @CheckReturnValue
     public static VerificationWithTimeout timeout(long millis) {
         return new Timeout(millis, VerificationModeFactory.times(1));
     }
@@ -2818,7 +3101,7 @@ public class Mockito extends ArgumentMatchers {
     /**
      * Verification will be triggered after given amount of millis, allowing testing of async code.
      * Useful when interactions with the mock object did not happened yet.
-     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
+     * Extensive use of {@code after()} method can be a code smell - there are better ways of testing concurrent code.
      * <p>
      * Not yet implemented to work with InOrder verification.
      * <p>
@@ -2866,7 +3149,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return object that allows fluent specification of the verification
      */
-    @CheckReturnValue
     public static VerificationAfterDelay after(long millis) {
         return new After(millis, VerificationModeFactory.times(1));
     }
@@ -2874,7 +3156,7 @@ public class Mockito extends ArgumentMatchers {
     /**
      * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href="https://github.com/mockito/mockito/wiki/FAQ">https://github.com/mockito/mockito/wiki/FAQ</a>
      * <p>
-     * In case of questions you may also post to mockito mailing list: <a href="http://groups.google.com/group/mockito">http://groups.google.com/group/mockito</a>
+     * In case of questions you may also post to mockito mailing list: <a href="https://groups.google.com/group/mockito">https://groups.google.com/group/mockito</a>
      * <p>
      * <code>validateMockitoUsage()</code> <b>explicitly validates</b> the framework state to detect invalid use of Mockito.
      * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.
@@ -2925,12 +3207,12 @@ public class Mockito extends ArgumentMatchers {
      * <p>
      * Don't use it too often.
      * Consider writing simple tests that use simple mocks.
-     * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.
+     * Repeat after me: simple tests push simple, KISSy, readable and maintainable code.
      * If you cannot write a test in a simple way - refactor the code under test.
      * <p>
      * Examples of mock settings:
      * <pre class="code"><code class="java">
-     *   //Creates mock with different default answer & name
+     *   //Creates mock with different default answer and name
      *   Foo mock = mock(Foo.class, withSettings()
      *       .defaultAnswer(RETURNS_SMART_NULLS)
      *       .name("cool mockie"));
@@ -2950,7 +3232,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @return mock settings instance with defaults.
      */
-    @CheckReturnValue
     public static MockSettings withSettings() {
         return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);
     }
@@ -2964,28 +3245,15 @@ public class Mockito extends ArgumentMatchers {
      * @return verification mode
      * @since 2.1.0
      */
-    @CheckReturnValue
     public static VerificationMode description(String description) {
         return times(1).description(description);
     }
 
-    /**
-     * @deprecated - please use {@link MockingDetails#printInvocations()} instead.
-     * An instance of {@code MockingDetails} can be retrieved via {@link #mockingDetails(Object)}.
-     */
-    @Deprecated
-    @CheckReturnValue
-    static MockitoDebugger debug() {
-        return new MockitoDebuggerImpl();
-    }
-
     /**
      * For advanced users or framework integrators. See {@link MockitoFramework} class.
      *
      * @since 2.1.0
      */
-    @Incubating
-    @CheckReturnValue
     public static MockitoFramework framework() {
         return new DefaultMockitoFramework();
     }
@@ -2998,8 +3266,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @since 2.7.0
      */
-    @Incubating
-    @CheckReturnValue
     public static MockitoSessionBuilder mockitoSession() {
         return new DefaultMockitoSessionBuilder();
     }
@@ -3067,7 +3333,6 @@ public class Mockito extends ArgumentMatchers {
      *
      * @since 2.20.0
      */
-    @Incubating
     public static LenientStubber lenient() {
         return MOCKITO_CORE.lenient();
     }
diff --git a/src/main/java/org/mockito/MockitoAnnotations.java b/src/main/java/org/mockito/MockitoAnnotations.java
index 518a36f..1672422 100644
--- a/src/main/java/org/mockito/MockitoAnnotations.java
+++ b/src/main/java/org/mockito/MockitoAnnotations.java
@@ -2,16 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
+import static org.mockito.internal.util.StringUtil.join;
+
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.configuration.GlobalConfiguration;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockito.plugins.AnnotationEngine;
 
 /**
- * MockitoAnnotations.initMocks(this); initializes fields annotated with Mockito annotations.
+ * MockitoAnnotations.openMocks(this); initializes fields annotated with Mockito annotations.
  * See also {@link MockitoSession} which not only initializes mocks
  * but also adds extra validation for cleaner tests!
  * <p>
@@ -38,34 +39,74 @@ import org.mockito.plugins.AnnotationEngine;
  *
  *   public class SampleBaseTestCase {
  *
- *       &#064;Before public void initMocks() {
- *           MockitoAnnotations.initMocks(this);
+ *       private AutoCloseable closeable;
+ *
+ *       &#064;Before public void openMocks() {
+ *           closeable = MockitoAnnotations.openMocks(this);
+ *       }
+ *
+ *       &#064;After public void releaseMocks() throws Exception {
+ *           closeable.close();
  *       }
  *   }
  * </code></pre>
  * <p>
  * Read also about other annotations &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}
  * <p>
- * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated fields.
+ * <b><code>MockitoAnnotations.openMocks(this)</code></b> method has to be called to initialize annotated fields.
  * <p>
- * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.
- * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runner: {@link MockitoJUnitRunner}
+ * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
+ * You can also put openMocks() in your JUnit runner (&#064;RunWith) or use built-in runner: {@link MockitoJUnitRunner}.
+ * If static method mocks are used, it is required to close the initialization. Additionally, if using third-party
+ * mock-makers, other life-cycles might be handled by the open-release routine.
  */
-public class MockitoAnnotations {
+public final class MockitoAnnotations {
 
     /**
      * Initializes objects annotated with Mockito annotations for given testClass:
      *  &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}
      * <p>
      * See examples in javadoc for {@link MockitoAnnotations} class.
+     *
+     * @return A closable to close when completing any tests in {@code testClass}.
      */
-    public static void initMocks(Object testClass) {
+    public static AutoCloseable openMocks(Object testClass) {
         if (testClass == null) {
-            throw new MockitoException("testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class");
+            throw new MockitoException(
+                    "testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class");
         }
 
-        AnnotationEngine annotationEngine = new GlobalConfiguration().tryGetPluginAnnotationEngine();
-        annotationEngine.process(testClass.getClass(), testClass);
+        AnnotationEngine annotationEngine =
+                new GlobalConfiguration().tryGetPluginAnnotationEngine();
+        return annotationEngine.process(testClass.getClass(), testClass);
     }
+
+    /**
+     * Initializes objects annotated with Mockito annotations for given testClass:
+     *  &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}
+     * <p>
+     * See examples in javadoc for {@link MockitoAnnotations} class.
+     *
+     * @deprecated Use {@link MockitoAnnotations#openMocks(Object)} instead.
+     * This method is equivalent to {@code openMocks(testClass).close()}.
+     * The close method should however only be called after completed usage of {@code testClass}.
+     * If using static-mocks or custom {@link org.mockito.plugins.MockMaker}s, using this method might
+     * cause misbehavior of mocks injected into the test class.
+     */
+    @Deprecated
+    public static void initMocks(Object testClass) {
+        try {
+            openMocks(testClass).close();
+        } catch (Exception e) {
+            throw new MockitoException(
+                    join(
+                            "Failed to release mocks",
+                            "",
+                            "This should not happen unless you are using a third-party mock maker"),
+                    e);
+        }
+    }
+
+    private MockitoAnnotations() {}
 }
diff --git a/src/main/java/org/mockito/MockitoDebugger.java b/src/main/java/org/mockito/MockitoDebugger.java
deleted file mode 100644
index 90c7e9a..0000000
--- a/src/main/java/org/mockito/MockitoDebugger.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito;
-
-/**
- * @deprecated - please use {@link MockingDetails#printInvocations()} instead.
- * An instance of {@code MockingDetails} can be retrieved via {@link Mockito#mockingDetails(Object)}.
- */
-@Deprecated
-public interface MockitoDebugger {
-
-    /**
-     * @deprecated - please use {@link MockingDetails#printInvocations()} instead.
-     * An instance of {@code MockingDetails} can be retrieved via {@link Mockito#mockingDetails(Object)}.
-     */
-    @Deprecated
-    String printInvocations(Object ... mocks);
-}
diff --git a/src/main/java/org/mockito/MockitoFramework.java b/src/main/java/org/mockito/MockitoFramework.java
index 58cd4b6..ba814e6 100644
--- a/src/main/java/org/mockito/MockitoFramework.java
+++ b/src/main/java/org/mockito/MockitoFramework.java
@@ -19,7 +19,7 @@ import org.mockito.plugins.MockitoPlugins;
  *
  * @since 2.1.0
  */
-@Incubating
+@NotExtensible
 public interface MockitoFramework {
 
     /**
@@ -32,7 +32,7 @@ public interface MockitoFramework {
      * Make sure you remove the listener when the job is complete, see {@link #removeListener(MockitoListener)}.
      * Currently the listeners list is thread local so you need to remove listener from the same thread otherwise
      * remove is ineffectual.
-     * In typical scenarios, it is not a problem, because adding & removing listeners typically happens in the same thread.
+     * In typical scenarios, it is not a problem, because adding and removing listeners typically happens in the same thread.
      * <p>
      * If you are trying to add the listener but a listener of the same type was already added (and not removed)
      * this method will throw {@link RedundantListenerException}.
@@ -52,14 +52,13 @@ public interface MockitoFramework {
      * @return this instance of mockito framework (fluent builder pattern)
      * @since 2.1.0
      */
-    @Incubating
     MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
 
     /**
      * When you add listener using {@link #addListener(MockitoListener)} make sure to remove it.
      * Currently the listeners list is thread local so you need to remove listener from the same thread otherwise
      * remove is ineffectual.
-     * In typical scenarios, it is not a problem, because adding & removing listeners typically happens in the same thread.
+     * In typical scenarios, it is not a problem, because adding and removing listeners typically happens in the same thread.
      * <p>
      * For usage examples, see Mockito codebase.
      * If you have ideas and feature requests about Mockito listeners API
@@ -69,7 +68,6 @@ public interface MockitoFramework {
      * @return this instance of mockito framework (fluent builder pattern)
      * @since 2.1.0
      */
-    @Incubating
     MockitoFramework removeListener(MockitoListener listener);
 
     /**
@@ -80,7 +78,6 @@ public interface MockitoFramework {
      * @return object that gives access to mockito plugins
      * @since 2.10.0
      */
-    @Incubating
     MockitoPlugins getPlugins();
 
     /**
@@ -90,7 +87,6 @@ public interface MockitoFramework {
      * @return object that can construct invocations
      * @since 2.10.0
      */
-    @Incubating
     InvocationFactory getInvocationFactory();
 
     /**
@@ -129,7 +125,6 @@ public interface MockitoFramework {
      * @since 2.25.0
      * @see #clearInlineMock(Object)
      */
-    @Incubating
     void clearInlineMocks();
 
     /**
@@ -141,6 +136,5 @@ public interface MockitoFramework {
      * @since 2.25.0
      * @see #clearInlineMocks()
      */
-    @Incubating
     void clearInlineMock(Object mock);
 }
diff --git a/src/main/java/org/mockito/MockitoSession.java b/src/main/java/org/mockito/MockitoSession.java
index 9e820f2..d3ad832 100644
--- a/src/main/java/org/mockito/MockitoSession.java
+++ b/src/main/java/org/mockito/MockitoSession.java
@@ -8,6 +8,7 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.junit.MockitoJUnitRunner;
+import org.mockito.junit.MockitoJUnitRunner.StrictStubs;
 import org.mockito.junit.MockitoRule;
 import org.mockito.listeners.MockitoListener;
 import org.mockito.quality.MockitoHint;
@@ -27,7 +28,6 @@ import org.mockito.session.MockitoSessionBuilder;
  * otherwise {@link UnfinishedMockingSessionException} is triggered when the next session is created.
  * <p>
  * {@code MockitoSession} is useful when you cannot use {@link MockitoJUnitRunner} or {@link MockitoRule}.
- * For example, you work with TestNG instead of JUnit.
  * Another example is when different JUnit runner is in use (Jukito, Springockito)
  * and it cannot be combined with Mockito's own runner.
  * <p>
@@ -67,18 +67,18 @@ import org.mockito.session.MockitoSessionBuilder;
  * <p>
  * Why to use {@code MockitoSession}?
  * What's the difference between {@code MockitoSession}, {@link MockitoJUnitRunner}, {@link MockitoRule}
- * and traditional {@link MockitoAnnotations#initMocks(Object)}?
+ * and traditional {@link MockitoAnnotations#openMocks(Object)}?
  * <p>
  * Great questions!
  * There is no need to use {@code MockitoSession} if you already use {@link MockitoJUnitRunner} or {@link MockitoRule}.
  * If you are JUnit user who does not leverage Mockito rule or runner we strongly recommend to do so.
  * Both the runner and the rule support strict stubbing which can really help driving cleaner tests.
- * See {@link MockitoJUnitRunner.StrictStubs} and {@link MockitoRule#strictness(Strictness)}.
- * If you cannot use Mockito's JUnit support (for example, you are on TestNG) {@code MockitoSession} exactly is for you!
+ * See {@link StrictStubs MockitoJUnitRunner.StrictStubs} and {@link MockitoRule#strictness(Strictness)}.
+ * If you cannot use Mockito's JUnit support {@code MockitoSession} exactly is for you!
  * You can automatically take advantage of strict stubbing ({@link Strictness}),
  * automatic initialization of annotated mocks ({@link MockitoAnnotations}),
  * and extra validation ({@link Mockito#validateMockitoUsage()}).
- * If you use Mockito annotations with {@link MockitoAnnotations#initMocks(Object)}
+ * If you use Mockito annotations with {@link MockitoAnnotations#openMocks(Object)}
  * but not Mockito runner/rule please try out Mockito's JUnit support (runner or rule) or
  * start using {@code MockitoSession}. You'll get cleaner tests and better productivity.
  * <p>
@@ -87,7 +87,7 @@ import org.mockito.session.MockitoSessionBuilder;
  *
  * @since 2.7.0
  */
-@Incubating
+@NotExtensible
 public interface MockitoSession {
 
     /**
@@ -101,7 +101,6 @@ public interface MockitoSession {
      * @param strictness new strictness for this session.
      * @since 2.15.0
      */
-    @Incubating
     void setStrictness(Strictness strictness);
 
     /**
@@ -123,7 +122,6 @@ public interface MockitoSession {
      * @see #finishMocking(Throwable)
      * @since 2.7.0
      */
-    @Incubating
     void finishMocking();
 
     /**
@@ -140,6 +138,5 @@ public interface MockitoSession {
      * @see #finishMocking()
      * @since 2.15.0
      */
-    @Incubating
     void finishMocking(Throwable failure);
 }
diff --git a/src/main/java/org/mockito/NotExtensible.java b/src/main/java/org/mockito/NotExtensible.java
index de67a0a..39191ac 100644
--- a/src/main/java/org/mockito/NotExtensible.java
+++ b/src/main/java/org/mockito/NotExtensible.java
@@ -26,5 +26,4 @@ import java.lang.annotation.RetentionPolicy;
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-public @interface NotExtensible {
-}
+public @interface NotExtensible {}
diff --git a/src/main/java/org/mockito/ScopedMock.java b/src/main/java/org/mockito/ScopedMock.java
new file mode 100644
index 0000000..ab2b94c
--- /dev/null
+++ b/src/main/java/org/mockito/ScopedMock.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+/**
+ * Represents a mock with a thread-local explicit scope. Scoped mocks must be closed by the entity
+ * that activates the scoped mock.
+ */
+public interface ScopedMock extends AutoCloseable {
+
+    /**
+     * Checks if this mock is closed.
+     *
+     * @return {@code true} if this mock is closed.
+     */
+    boolean isClosed();
+
+    /**
+     * Closes this scoped mock and throws an exception if already closed.
+     */
+    @Override
+    void close();
+
+    /**
+     * Releases this scoped mock and is non-operational if already released.
+     */
+    void closeOnDemand();
+}
diff --git a/src/main/java/org/mockito/Spy.java b/src/main/java/org/mockito/Spy.java
index 6bb4609..aa485a3 100644
--- a/src/main/java/org/mockito/Spy.java
+++ b/src/main/java/org/mockito/Spy.java
@@ -6,9 +6,11 @@ package org.mockito;
 
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import org.mockito.junit.MockitoJUnitRunner;
 
 /**
@@ -23,9 +25,14 @@ import org.mockito.junit.MockitoJUnitRunner;
  *    &#64;Spy Foo spyOnFoo = new Foo("argument");
  *    //Instance for spying is created by mockito via reflection (only default constructors supported):
  *    &#64;Spy Bar spyOnBar;
+ *    private AutoCloseable closeable;
  *    &#64;Before
- *    public void init(){
- *       MockitoAnnotations.initMocks(this);
+ *    public void init() {
+ *       closeable = MockitoAnnotations.openMocks(this);
+ *    }
+ *    &#64;After
+ *    public void release() throws Exception {
+ *       closeable.close();
  *    }
  *    ...
  * }
@@ -82,12 +89,13 @@ import org.mockito.junit.MockitoJUnitRunner;
  * </ol>
  *
  * <p>
- * <strong>One last warning :</strong> if you call <code>MockitoAnnotations.initMocks(this)</code> in a
+ * <strong>One last warning :</strong> if you call <code>MockitoAnnotations.openMocks(this)</code> in a
  * super class <strong>constructor</strong> then this will not work. It is because fields
  * in subclass are only instantiated after super class constructor has returned.
  * It's better to use &#64;Before.
- * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in
- * {@link MockitoJUnitRunner}.
+ * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
+ * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a
+ * corresponding hook.
  * </p>
  *
  * <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.
@@ -96,11 +104,11 @@ import org.mockito.junit.MockitoJUnitRunner;
  * @see Mockito#spy(Object)
  * @see Mock
  * @see InjectMocks
- * @see MockitoAnnotations#initMocks(Object)
+ * @see MockitoAnnotations#openMocks(Object)
  * @see MockitoJUnitRunner
  * @since 1.8.3
  */
 @Retention(RUNTIME)
 @Target(FIELD)
 @Documented
-public @interface Spy { }
+public @interface Spy {}
diff --git a/src/main/java/org/mockito/configuration/AnnotationEngine.java b/src/main/java/org/mockito/configuration/AnnotationEngine.java
deleted file mode 100644
index 40ff352..0000000
--- a/src/main/java/org/mockito/configuration/AnnotationEngine.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.configuration;
-
-import org.mockito.MockitoAnnotations;
-
-/**
- * Configures mock creation logic behind &#064;Mock, &#064;Captor and &#064;Spy annotations
- * <p>
- * If you are interested then see implementations or source code of {@link MockitoAnnotations#initMocks(Object)}
- *
- * <p>This interface can be used to configure a different annotation engine through
- * {@link org.mockito.configuration.IMockitoConfiguration}, however this mechanism is being superseded by the new
- * {@link org.mockito.plugins plugin} system.
- *
- * <p>
- * Note that if it exists on the classpath both a class <code>org.mockito.configuration.MockitoConfiguration</code>
- * and a file <code>mockito-extensions/org.mockito.plugins.AnnotationEngine</code> then the implementation of
- * <code>org.mockito.configuration.MockitoConfiguration</code> will be chosen instead of the one in the file.
-
- * @deprecated Please use {@link org.mockito.plugins.AnnotationEngine} instead,
- *             this interface will probably be removed in mockito 3.
- */
-@Deprecated
-public interface AnnotationEngine extends org.mockito.plugins.AnnotationEngine {
-}
diff --git a/src/main/java/org/mockito/configuration/DefaultMockitoConfiguration.java b/src/main/java/org/mockito/configuration/DefaultMockitoConfiguration.java
index cad13e7..43882d4 100644
--- a/src/main/java/org/mockito/configuration/DefaultMockitoConfiguration.java
+++ b/src/main/java/org/mockito/configuration/DefaultMockitoConfiguration.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.configuration;
 
-import org.mockito.internal.configuration.InjectingAnnotationEngine;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
 import org.mockito.stubbing.Answer;
 
@@ -17,20 +16,15 @@ import org.mockito.stubbing.Answer;
  */
 public class DefaultMockitoConfiguration implements IMockitoConfiguration {
 
+    @Override
     public Answer<Object> getDefaultAnswer() {
         return new ReturnsEmptyValues();
     }
 
-    /* (non-Javadoc)
-     * @see org.mockito.IMockitoConfiguration#getAnnotationEngine()
-     */
-    public AnnotationEngine getAnnotationEngine() {
-        return new InjectingAnnotationEngine();
-    }
-
     /* (non-Javadoc)
      * @see org.mockito.configuration.IMockitoConfiguration#cleansStackTrace()
      */
+    @Override
     public boolean cleansStackTrace() {
         return true;
     }
@@ -38,9 +32,8 @@ public class DefaultMockitoConfiguration implements IMockitoConfiguration {
     /* (non-Javadoc)
      * @see org.mockito.configuration.IMockitoConfiguration#enableClassCache()
      */
+    @Override
     public boolean enableClassCache() {
         return true;
     }
-
-
 }
diff --git a/src/main/java/org/mockito/configuration/IMockitoConfiguration.java b/src/main/java/org/mockito/configuration/IMockitoConfiguration.java
index 2c2da56..5366494 100644
--- a/src/main/java/org/mockito/configuration/IMockitoConfiguration.java
+++ b/src/main/java/org/mockito/configuration/IMockitoConfiguration.java
@@ -44,24 +44,6 @@ public interface IMockitoConfiguration {
      */
     Answer<Object> getDefaultAnswer();
 
-    /**
-     * Configures annotations for mocks.
-     *
-     * <p>
-     * This method will have lower priority that the new extension mechanism.
-     * That is if it exists on the classpath both a class <code>org.mockito.configuration.MockitoConfiguration</code>
-     * and a file <code>mockito-extensions/org.mockito.plugins.AnnotationEngine</code> then the implementation of
-     * <code>org.mockito.configuration.MockitoConfiguration</code> will be chosen instead of the one in the file.
-     *
-     * <p>
-     * See javadoc for {@link IMockitoConfiguration}
-     *
-     * @deprecated Please use the extension mechanism {@link org.mockito.plugins.AnnotationEngine} instead,
-     *             this method will probably be removed in mockito 3.
-     */
-    @Deprecated
-    AnnotationEngine getAnnotationEngine();
-
     /**
      * This should be turned on unless you're a Mockito developer and you wish
      * to have verbose (read: messy) stack traces that only few understand (eg:
diff --git a/src/main/java/org/mockito/creation/instance/InstantiationException.java b/src/main/java/org/mockito/creation/instance/InstantiationException.java
index 1cfbaba..34548d5 100644
--- a/src/main/java/org/mockito/creation/instance/InstantiationException.java
+++ b/src/main/java/org/mockito/creation/instance/InstantiationException.java
@@ -13,6 +13,13 @@ import org.mockito.exceptions.base.MockitoException;
  */
 public class InstantiationException extends MockitoException {
 
+    /**
+     * @since 3.5.0
+     */
+    public InstantiationException(String message) {
+        super(message);
+    }
+
     /**
      * @since 2.15.4
      */
diff --git a/src/main/java/org/mockito/creation/instance/Instantiator.java b/src/main/java/org/mockito/creation/instance/Instantiator.java
index 9ce37b5..a60ec75 100644
--- a/src/main/java/org/mockito/creation/instance/Instantiator.java
+++ b/src/main/java/org/mockito/creation/instance/Instantiator.java
@@ -17,6 +17,5 @@ public interface Instantiator {
      *
      * @since 2.15.4
      */
-    <T> T newInstance(Class<T> cls) throws InstantiationException;
-
+    <T> T newInstance(Class<T> cls);
 }
diff --git a/src/main/java/org/mockito/exceptions/base/MockitoAssertionError.java b/src/main/java/org/mockito/exceptions/base/MockitoAssertionError.java
index 491ff40..5e463c7 100644
--- a/src/main/java/org/mockito/exceptions/base/MockitoAssertionError.java
+++ b/src/main/java/org/mockito/exceptions/base/MockitoAssertionError.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
@@ -47,6 +46,18 @@ public class MockitoAssertionError extends AssertionError {
         unfilteredStackTrace = error.getUnfilteredStackTrace();
     }
 
+    /**
+     * Creates a copy of the given assertion error with the custom failure message prepended.
+     * @param error The assertion error to copy
+     * @param message The custom message to prepend
+     * @since 3.3.13
+     */
+    public MockitoAssertionError(AssertionError error, String message) {
+        super(message + "\n" + error.getMessage());
+        unfilteredStackTrace = error.getStackTrace();
+        super.setStackTrace(unfilteredStackTrace);
+    }
+
     public StackTraceElement[] getUnfilteredStackTrace() {
         return unfilteredStackTrace;
     }
diff --git a/src/main/java/org/mockito/exceptions/base/MockitoException.java b/src/main/java/org/mockito/exceptions/base/MockitoException.java
index d774702..9293870 100644
--- a/src/main/java/org/mockito/exceptions/base/MockitoException.java
+++ b/src/main/java/org/mockito/exceptions/base/MockitoException.java
@@ -2,12 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
 
-
 /**
  * Raised by mockito to emit an error either due to Mockito, or due to the User.
  * All exception classes that inherit from this class will have the stack trace filtered.
diff --git a/src/main/java/org/mockito/exceptions/base/MockitoInitializationException.java b/src/main/java/org/mockito/exceptions/base/MockitoInitializationException.java
index 019fe0b..e4d986d 100644
--- a/src/main/java/org/mockito/exceptions/base/MockitoInitializationException.java
+++ b/src/main/java/org/mockito/exceptions/base/MockitoInitializationException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
 public class MockitoInitializationException extends RuntimeException {
diff --git a/src/main/java/org/mockito/exceptions/base/MockitoSerializationIssue.java b/src/main/java/org/mockito/exceptions/base/MockitoSerializationIssue.java
index 458b56d..eae6851 100644
--- a/src/main/java/org/mockito/exceptions/base/MockitoSerializationIssue.java
+++ b/src/main/java/org/mockito/exceptions/base/MockitoSerializationIssue.java
@@ -2,13 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
-import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
-
 import java.io.ObjectStreamException;
 
+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+
 /**
  * Raised by mockito to emit an error either due to Mockito, or due to the User.
  *
diff --git a/src/main/java/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java b/src/main/java/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java
index 2c8a656..6fa9a55 100644
--- a/src/main/java/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java
+++ b/src/main/java/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/DoNotMockException.java b/src/main/java/org/mockito/exceptions/misusing/DoNotMockException.java
new file mode 100644
index 0000000..4b4281b
--- /dev/null
+++ b/src/main/java/org/mockito/exceptions/misusing/DoNotMockException.java
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.exceptions.misusing;
+
+import org.mockito.exceptions.base.MockitoException;
+
+/**
+ * Thrown when attempting to mock a class that is annotated with {@link org.mockito.DoNotMock}.
+ */
+public class DoNotMockException extends MockitoException {
+    public DoNotMockException(String message) {
+        super(message);
+    }
+}
diff --git a/src/main/java/org/mockito/exceptions/misusing/FriendlyReminderException.java b/src/main/java/org/mockito/exceptions/misusing/FriendlyReminderException.java
index 57d8015..a161e8f 100644
--- a/src/main/java/org/mockito/exceptions/misusing/FriendlyReminderException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/FriendlyReminderException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java b/src/main/java/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java
index a6a17ee..c6e574d 100644
--- a/src/main/java/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/MissingMethodInvocationException.java b/src/main/java/org/mockito/exceptions/misusing/MissingMethodInvocationException.java
index ae77fb0..45db3f4 100644
--- a/src/main/java/org/mockito/exceptions/misusing/MissingMethodInvocationException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/MissingMethodInvocationException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/NotAMockException.java b/src/main/java/org/mockito/exceptions/misusing/NotAMockException.java
index d4fb917..541f197 100644
--- a/src/main/java/org/mockito/exceptions/misusing/NotAMockException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/NotAMockException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/NullInsteadOfMockException.java b/src/main/java/org/mockito/exceptions/misusing/NullInsteadOfMockException.java
index 5225f7c..1d1f91d 100644
--- a/src/main/java/org/mockito/exceptions/misusing/NullInsteadOfMockException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/NullInsteadOfMockException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/PotentialStubbingProblem.java b/src/main/java/org/mockito/exceptions/misusing/PotentialStubbingProblem.java
index 5eb6a77..f50c642 100644
--- a/src/main/java/org/mockito/exceptions/misusing/PotentialStubbingProblem.java
+++ b/src/main/java/org/mockito/exceptions/misusing/PotentialStubbingProblem.java
@@ -26,7 +26,7 @@ import org.mockito.quality.Strictness;
  * given(mock.getSomething(100)).willReturn(something);
  *
  * //code under test:
- * Something something = mock.getSomething(50); // <-- stubbing argument mismatch
+ * Something something = mock.getSomething(50); // &lt;-- stubbing argument mismatch
  * </code></pre>
  * The stubbing argument mismatch typically indicates:
  * <ol>
diff --git a/src/main/java/org/mockito/exceptions/misusing/UnfinishedStubbingException.java b/src/main/java/org/mockito/exceptions/misusing/UnfinishedStubbingException.java
index 3085161..c24ae43 100644
--- a/src/main/java/org/mockito/exceptions/misusing/UnfinishedStubbingException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/UnfinishedStubbingException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/UnfinishedVerificationException.java b/src/main/java/org/mockito/exceptions/misusing/UnfinishedVerificationException.java
index 323c1f6..078cc23 100644
--- a/src/main/java/org/mockito/exceptions/misusing/UnfinishedVerificationException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/UnfinishedVerificationException.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.misusing;
 
 import org.mockito.exceptions.base.MockitoException;
diff --git a/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java b/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
index 2d4605b..1a5895f 100644
--- a/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
@@ -30,15 +30,16 @@ import org.mockito.exceptions.base.MockitoException;
  *
  * //test:
  * ...
- * when(translator.translate("one")).thenReturn("jeden"); // <- stubbing realized during code execution
- * when(translator.translate("two")).thenReturn("dwa"); // <- stubbing never realized
+ * when(translator.translate("one")).thenReturn("jeden"); // &lt;- stubbing realized during code execution
+ * when(translator.translate("two")).thenReturn("dwa"); // &lt;- stubbing never realized
  * ...
+ * </code>
  * </pre>
  * Notice that one of the stubbed methods were never realized in the code under test, during test execution.
  * The stray stubbing might be an oversight of the developer, the artifact of copy-paste
- * or the effect not understanding the test/code.
+ * or the effect of not understanding the test/code.
  * Either way, the developer ends up with unnecessary test code.
- * In order to keep the codebase clean & maintainable it is necessary to remove unnecessary code.
+ * In order to keep the codebase clean and maintainable it is necessary to remove unnecessary code.
  * Otherwise tests are harder to read and reason about.
  * <p>
  * Mockito JUnit Runner triggers <code>UnnecessaryStubbingException</code> only when none of the test methods use the stubbings.
diff --git a/src/main/java/org/mockito/exceptions/verification/ArgumentsAreDifferent.java b/src/main/java/org/mockito/exceptions/verification/ArgumentsAreDifferent.java
index a44cc6f..ac572f4 100644
--- a/src/main/java/org/mockito/exceptions/verification/ArgumentsAreDifferent.java
+++ b/src/main/java/org/mockito/exceptions/verification/ArgumentsAreDifferent.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import static org.mockito.internal.util.StringUtil.removeFirstLine;
@@ -17,8 +16,21 @@ public class ArgumentsAreDifferent extends MockitoAssertionError {
         super(message);
     }
 
+    /**
+     * Three-arg constructor for compatibility with ExceptionFactory's three-arg
+     * create method. This implementation simply ignores the second and third
+     * arguments.
+     *
+     * @param message
+     * @param wanted ignored
+     * @param actual ignored
+     */
+    public ArgumentsAreDifferent(String message, String wanted, String actual) {
+        this(message);
+    }
+
     @Override
-    public String toString() {
-        return removeFirstLine(super.toString());
+    public String getMessage() {
+        return removeFirstLine(super.getMessage());
     }
 }
diff --git a/src/main/java/org/mockito/exceptions/verification/MoreThanAllowedActualInvocations.java b/src/main/java/org/mockito/exceptions/verification/MoreThanAllowedActualInvocations.java
index c3c0ed4..7d3ac5a 100644
--- a/src/main/java/org/mockito/exceptions/verification/MoreThanAllowedActualInvocations.java
+++ b/src/main/java/org/mockito/exceptions/verification/MoreThanAllowedActualInvocations.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
diff --git a/src/main/java/org/mockito/exceptions/verification/NeverWantedButInvoked.java b/src/main/java/org/mockito/exceptions/verification/NeverWantedButInvoked.java
index e8e3ba9..d126102 100644
--- a/src/main/java/org/mockito/exceptions/verification/NeverWantedButInvoked.java
+++ b/src/main/java/org/mockito/exceptions/verification/NeverWantedButInvoked.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
diff --git a/src/main/java/org/mockito/exceptions/verification/NoInteractionsWanted.java b/src/main/java/org/mockito/exceptions/verification/NoInteractionsWanted.java
index 9dccf3b..0b45a86 100644
--- a/src/main/java/org/mockito/exceptions/verification/NoInteractionsWanted.java
+++ b/src/main/java/org/mockito/exceptions/verification/NoInteractionsWanted.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
diff --git a/src/main/java/org/mockito/exceptions/verification/TooLittleActualInvocations.java b/src/main/java/org/mockito/exceptions/verification/TooFewActualInvocations.java
similarity index 58%
rename from src/main/java/org/mockito/exceptions/verification/TooLittleActualInvocations.java
rename to src/main/java/org/mockito/exceptions/verification/TooFewActualInvocations.java
index d47a440..bf7c018 100644
--- a/src/main/java/org/mockito/exceptions/verification/TooLittleActualInvocations.java
+++ b/src/main/java/org/mockito/exceptions/verification/TooFewActualInvocations.java
@@ -1,17 +1,19 @@
 /*
- * Copyright (c) 2007 Mockito contributors
+ * Copyright (c) 2019 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
 
-public class TooLittleActualInvocations extends MockitoAssertionError {
+/**
+ * @since 2.27.5
+ */
+public class TooFewActualInvocations extends MockitoAssertionError {
 
     private static final long serialVersionUID = 1L;
 
-    public TooLittleActualInvocations(String message) {
+    public TooFewActualInvocations(String message) {
         super(message);
     }
 }
diff --git a/src/main/java/org/mockito/exceptions/verification/TooManyActualInvocations.java b/src/main/java/org/mockito/exceptions/verification/TooManyActualInvocations.java
index e29ec7a..b121508 100644
--- a/src/main/java/org/mockito/exceptions/verification/TooManyActualInvocations.java
+++ b/src/main/java/org/mockito/exceptions/verification/TooManyActualInvocations.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
diff --git a/src/main/java/org/mockito/exceptions/verification/VerificationInOrderFailure.java b/src/main/java/org/mockito/exceptions/verification/VerificationInOrderFailure.java
index d27c30c..c2b9632 100644
--- a/src/main/java/org/mockito/exceptions/verification/VerificationInOrderFailure.java
+++ b/src/main/java/org/mockito/exceptions/verification/VerificationInOrderFailure.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
diff --git a/src/main/java/org/mockito/exceptions/verification/WantedButNotInvoked.java b/src/main/java/org/mockito/exceptions/verification/WantedButNotInvoked.java
index e791d56..ddf5998 100644
--- a/src/main/java/org/mockito/exceptions/verification/WantedButNotInvoked.java
+++ b/src/main/java/org/mockito/exceptions/verification/WantedButNotInvoked.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification;
 
 import static org.mockito.internal.util.StringUtil.removeFirstLine;
diff --git a/src/main/java/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java b/src/main/java/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java
index 32bf882..94da89d 100644
--- a/src/main/java/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java
+++ b/src/main/java/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.verification.junit;
 
 import static org.mockito.internal.util.StringUtil.removeFirstLine;
@@ -10,7 +9,6 @@ import static org.mockito.internal.util.StringUtil.removeFirstLine;
 import junit.framework.ComparisonFailure;
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
 
-
 public class ArgumentsAreDifferent extends ComparisonFailure {
 
     private static final long serialVersionUID = 1L;
diff --git a/src/main/java/org/mockito/exceptions/verification/junit/package-info.java b/src/main/java/org/mockito/exceptions/verification/junit/package-info.java
index 4542d34..23d1848 100644
--- a/src/main/java/org/mockito/exceptions/verification/junit/package-info.java
+++ b/src/main/java/org/mockito/exceptions/verification/junit/package-info.java
@@ -4,6 +4,9 @@
  */
 
 /**
- * JUnit integration to provide better support for junit runners in IDEs.
+ * JUnit integration to provide better support for JUnit 4 and
+ * earlier in IDEs.
+ *
+ * See also org.mockito.exceptions.verification.opentest4j
  */
 package org.mockito.exceptions.verification.junit;
diff --git a/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java b/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java
new file mode 100644
index 0000000..6589c5a
--- /dev/null
+++ b/src/main/java/org/mockito/exceptions/verification/opentest4j/ArgumentsAreDifferent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.exceptions.verification.opentest4j;
+
+import static org.mockito.internal.util.StringUtil.removeFirstLine;
+
+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+import org.mockito.exceptions.base.MockitoAssertionError;
+
+
+public class ArgumentsAreDifferent extends MockitoAssertionError {
+
+    public ArgumentsAreDifferent(String message, String wanted, String actual) {
+        super(message);
+    }
+
+    @Override
+    public String toString() {
+        return removeFirstLine(super.toString());
+    }
+}
diff --git a/src/main/java/org/mockito/exceptions/verification/opentest4j/package-info.java b/src/main/java/org/mockito/exceptions/verification/opentest4j/package-info.java
new file mode 100644
index 0000000..311253f
--- /dev/null
+++ b/src/main/java/org/mockito/exceptions/verification/opentest4j/package-info.java
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+/**
+ * Integration to provide better support for IDEs that support OpenTest4J.
+ *
+ * See also org.mockito.exceptions.verification.junit
+ */
+package org.mockito.exceptions.verification.opentest4j;
diff --git a/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java b/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
index 5f55d22..b8ebf8f 100644
--- a/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
+++ b/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.hamcrest;
 
-import org.hamcrest.Matcher;
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.hamcrest.HamcrestArgumentMatcher;
-
 import static org.mockito.internal.hamcrest.MatcherGenericTypeExtractor.genericTypeOfMatcher;
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 import static org.mockito.internal.util.Primitives.defaultValue;
 
+import org.hamcrest.Matcher;
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.hamcrest.HamcrestArgumentMatcher;
+
 /**
  * Allows matching arguments with hamcrest matchers.
  * <b>Requires</b> <a href="http://hamcrest.org/JavaHamcrest/">hamcrest</a> on classpath,
@@ -45,7 +45,7 @@ import static org.mockito.internal.util.Primitives.defaultValue;
  *
  * @since 2.1.0
  */
-public class MockitoHamcrest {
+public final class MockitoHamcrest {
 
     /**
      * Allows matching arguments with hamcrest matchers.
@@ -59,7 +59,7 @@ public class MockitoHamcrest {
     @SuppressWarnings("unchecked")
     public static <T> T argThat(Matcher<T> matcher) {
         reportMatcher(matcher);
-        return  (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));
+        return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));
     }
 
     /**
@@ -175,6 +175,10 @@ public class MockitoHamcrest {
     }
 
     private static <T> void reportMatcher(Matcher<T> matcher) {
-        mockingProgress().getArgumentMatcherStorage().reportMatcher(new HamcrestArgumentMatcher<T>(matcher));
+        mockingProgress()
+                .getArgumentMatcherStorage()
+                .reportMatcher(new HamcrestArgumentMatcher<T>(matcher));
     }
+
+    private MockitoHamcrest() {}
 }
diff --git a/src/main/java/org/mockito/internal/InOrderImpl.java b/src/main/java/org/mockito/internal/InOrderImpl.java
index 5b0af9c..af852e4 100644
--- a/src/main/java/org/mockito/internal/InOrderImpl.java
+++ b/src/main/java/org/mockito/internal/InOrderImpl.java
@@ -2,25 +2,28 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal;
 
+import static org.mockito.internal.exceptions.Reporter.inOrderRequiresFamiliarMock;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.mockito.InOrder;
+import org.mockito.MockingDetails;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.InOrderContextImpl;
 import org.mockito.internal.verification.InOrderWrapper;
 import org.mockito.internal.verification.VerificationModeFactory;
+import org.mockito.internal.verification.VerificationWrapper;
+import org.mockito.internal.verification.VerificationWrapperInOrderWrapper;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.internal.verification.api.VerificationInOrderMode;
 import org.mockito.invocation.Invocation;
 import org.mockito.verification.VerificationMode;
-import org.mockito.internal.verification.VerificationWrapper;
-import org.mockito.internal.verification.VerificationWrapperInOrderWrapper;
 
-import static org.mockito.internal.exceptions.Reporter.inOrderRequiresFamiliarMock;
-
-import java.util.LinkedList;
-import java.util.List;
+import static org.mockito.Mockito.mockingDetails;
+import static org.mockito.internal.exceptions.Reporter.*;
 
 /**
  * Allows verifying in order. This class should not be exposed, hence default access.
@@ -28,7 +31,7 @@ import java.util.List;
 public class InOrderImpl implements InOrder, InOrderContext {
 
     private final MockitoCore mockitoCore = new MockitoCore();
-    private final List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();
+    private final List<Object> mocksToBeVerifiedInOrder = new ArrayList<>();
     private final InOrderContext inOrderContext = new InOrderContextImpl();
 
     public List<Object> getMocksToBeVerifiedInOrder() {
@@ -39,30 +42,58 @@ public class InOrderImpl implements InOrder, InOrderContext {
         this.mocksToBeVerifiedInOrder.addAll(mocksToBeVerifiedInOrder);
     }
 
+    @Override
     public <T> T verify(T mock) {
         return this.verify(mock, VerificationModeFactory.times(1));
     }
 
+    @Override
     public <T> T verify(T mock, VerificationMode mode) {
-        if (!mocksToBeVerifiedInOrder.contains(mock)) {
+        if (mock == null) {
+            throw nullPassedToVerify();
+        }
+        MockingDetails mockingDetails = mockingDetails(mock);
+        if (!mockingDetails.isMock()) {
+            throw notAMockPassedToVerify(mock.getClass());
+        }
+        if (!this.objectIsMockToBeVerified(mock)) {
             throw inOrderRequiresFamiliarMock();
         }
         if (mode instanceof VerificationWrapper) {
-            return mockitoCore.verify(mock, new VerificationWrapperInOrderWrapper((VerificationWrapper) mode, this));
-        }  else if (!(mode instanceof VerificationInOrderMode)) {
-            throw new MockitoException(mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
+            return mockitoCore.verify(
+                    mock, new VerificationWrapperInOrderWrapper((VerificationWrapper) mode, this));
+        } else if (!(mode instanceof VerificationInOrderMode)) {
+            throw new MockitoException(
+                    mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
         }
         return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));
     }
 
+    // We can't use `this.mocksToBeVerifiedInOrder.contains`, since that in turn calls `.equals` on
+    // the mock. Since mocks can be spies and spies get their real equals method calls called, the
+    // result is that Mockito incorrectly would register an invocation on a mock. This normally
+    // wouldn't be a problem, unless the user explicitly verifies that no interactions are performed
+    // on the mock, which would start to fail for the equals invocation.
+    private boolean objectIsMockToBeVerified(Object mock) {
+        for (Object inOrderMock : this.mocksToBeVerifiedInOrder) {
+            if (inOrderMock == mock) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
     public boolean isVerified(Invocation i) {
         return inOrderContext.isVerified(i);
     }
 
+    @Override
     public void markVerified(Invocation i) {
         inOrderContext.markVerified(i);
     }
 
+    @Override
     public void verifyNoMoreInteractions() {
         mockitoCore.verifyNoMoreInteractionsInOrder(mocksToBeVerifiedInOrder, this);
     }
diff --git a/src/main/java/org/mockito/internal/InternalMockHandler.java b/src/main/java/org/mockito/internal/InternalMockHandler.java
deleted file mode 100644
index 40ebd24..0000000
--- a/src/main/java/org/mockito/internal/InternalMockHandler.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal;
-
-import org.mockito.invocation.MockHandler;
-
-/**
- * Deprecated, please use {@link MockHandler}.
- * <p>
- * This class was changed in Mockito in order to tidy up Mockito API
- * and make it easier for other frameworks to integrate with Mockito.
- * Since this class is internal, e.g. it resides in "org.mockito.internal" package,
- * Mockito team can change it without the need for major version release of Mockito.
- * <p>
- * This interface was deprecated in Mockito 2.10.0 and will be deleted in Mockito 3.0.
- */
-@Deprecated
-public interface InternalMockHandler<T> extends MockHandler {}
diff --git a/src/main/java/org/mockito/internal/MockedConstructionImpl.java b/src/main/java/org/mockito/internal/MockedConstructionImpl.java
new file mode 100644
index 0000000..47bd808
--- /dev/null
+++ b/src/main/java/org/mockito/internal/MockedConstructionImpl.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal;
+
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.util.Collections;
+import java.util.List;
+
+import org.mockito.MockedConstruction;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.invocation.Location;
+import org.mockito.plugins.MockMaker;
+
+public final class MockedConstructionImpl<T> implements MockedConstruction<T> {
+
+    private final MockMaker.ConstructionMockControl<T> control;
+
+    private boolean closed;
+
+    private final Location location = new LocationImpl();
+
+    protected MockedConstructionImpl(MockMaker.ConstructionMockControl<T> control) {
+        this.control = control;
+    }
+
+    @Override
+    public List<T> constructed() {
+        return Collections.unmodifiableList(control.getMocks());
+    }
+
+    @Override
+    public boolean isClosed() {
+        return closed;
+    }
+
+    @Override
+    public void close() {
+        assertNotClosed();
+
+        closed = true;
+        control.disable();
+    }
+
+    @Override
+    public void closeOnDemand() {
+        if (!closed) {
+            close();
+        }
+    }
+
+    private void assertNotClosed() {
+        if (closed) {
+            throw new MockitoException(
+                    join(
+                            "The static mock created at",
+                            location.toString(),
+                            "is already resolved and cannot longer be used"));
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/MockedStaticImpl.java b/src/main/java/org/mockito/internal/MockedStaticImpl.java
new file mode 100644
index 0000000..fbfb54b
--- /dev/null
+++ b/src/main/java/org/mockito/internal/MockedStaticImpl.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal;
+
+import static org.mockito.internal.exceptions.Reporter.missingMethodInvocation;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+import static org.mockito.internal.util.MockUtil.getInvocationContainer;
+import static org.mockito.internal.util.MockUtil.resetMock;
+import static org.mockito.internal.util.StringUtil.join;
+import static org.mockito.internal.verification.VerificationModeFactory.noInteractions;
+import static org.mockito.internal.verification.VerificationModeFactory.noMoreInteractions;
+
+import org.mockito.MockedStatic;
+import org.mockito.MockingDetails;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoAssertionError;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.listeners.VerificationStartedNotifier;
+import org.mockito.internal.progress.MockingProgress;
+import org.mockito.internal.stubbing.InvocationContainerImpl;
+import org.mockito.internal.verification.MockAwareVerificationMode;
+import org.mockito.internal.verification.VerificationDataImpl;
+import org.mockito.invocation.Location;
+import org.mockito.invocation.MockHandler;
+import org.mockito.plugins.MockMaker;
+import org.mockito.stubbing.OngoingStubbing;
+import org.mockito.verification.VerificationMode;
+
+public final class MockedStaticImpl<T> implements MockedStatic<T> {
+
+    private final MockMaker.StaticMockControl<T> control;
+
+    private boolean closed;
+
+    private final Location location = new LocationImpl();
+
+    protected MockedStaticImpl(MockMaker.StaticMockControl<T> control) {
+        this.control = control;
+    }
+
+    @Override
+    public <S> OngoingStubbing<S> when(Verification verification) {
+        assertNotClosed();
+
+        try {
+            verification.apply();
+        } catch (MockitoException exception) {
+            throw exception;
+        } catch (Throwable ignored) {
+        }
+
+        MockingProgress mockingProgress = mockingProgress();
+        mockingProgress.stubbingStarted();
+        @SuppressWarnings("unchecked")
+        OngoingStubbing<S> stubbing = (OngoingStubbing<S>) mockingProgress.pullOngoingStubbing();
+        if (stubbing == null) {
+            mockingProgress.reset();
+            throw missingMethodInvocation();
+        }
+        return stubbing;
+    }
+
+    @Override
+    public void verify(Verification verification, VerificationMode mode) {
+        assertNotClosed();
+
+        MockingDetails mockingDetails = Mockito.mockingDetails(control.getType());
+        MockHandler handler = mockingDetails.getMockHandler();
+
+        VerificationStartedNotifier.notifyVerificationStarted(
+                handler.getMockSettings().getVerificationStartedListeners(), mockingDetails);
+
+        MockingProgress mockingProgress = mockingProgress();
+        VerificationMode actualMode = mockingProgress.maybeVerifyLazily(mode);
+        mockingProgress.verificationStarted(
+                new MockAwareVerificationMode(
+                        control.getType(), actualMode, mockingProgress.verificationListeners()));
+
+        try {
+            verification.apply();
+        } catch (MockitoException | MockitoAssertionError e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new MockitoException(
+                    join(
+                            "An unexpected error occurred while verifying a static stub",
+                            "",
+                            "To correctly verify a stub, invoke a single static method of "
+                                    + control.getType().getName()
+                                    + " in the provided lambda.",
+                            "For example, if a method 'sample' was defined, provide a lambda or anonymous class containing the code",
+                            "",
+                            "() -> " + control.getType().getSimpleName() + ".sample()",
+                            "or",
+                            control.getType().getSimpleName() + "::sample"),
+                    t);
+        }
+    }
+
+    @Override
+    public void reset() {
+        assertNotClosed();
+
+        MockingProgress mockingProgress = mockingProgress();
+        mockingProgress.validateState();
+        mockingProgress.reset();
+        mockingProgress.resetOngoingStubbing();
+
+        resetMock(control.getType());
+    }
+
+    @Override
+    public void clearInvocations() {
+        assertNotClosed();
+
+        MockingProgress mockingProgress = mockingProgress();
+        mockingProgress.validateState();
+        mockingProgress.reset();
+        mockingProgress.resetOngoingStubbing();
+
+        getInvocationContainer(control.getType()).clearInvocations();
+    }
+
+    @Override
+    public void verifyNoMoreInteractions() {
+        assertNotClosed();
+
+        mockingProgress().validateState();
+        InvocationContainerImpl invocations = getInvocationContainer(control.getType());
+        VerificationDataImpl data = new VerificationDataImpl(invocations, null);
+        noMoreInteractions().verify(data);
+    }
+
+    @Override
+    public void verifyNoInteractions() {
+        assertNotClosed();
+
+        mockingProgress().validateState();
+        InvocationContainerImpl invocations = getInvocationContainer(control.getType());
+        VerificationDataImpl data = new VerificationDataImpl(invocations, null);
+        noInteractions().verify(data);
+    }
+
+    @Override
+    public boolean isClosed() {
+        return closed;
+    }
+
+    @Override
+    public void close() {
+        assertNotClosed();
+
+        closed = true;
+        control.disable();
+    }
+
+    @Override
+    public void closeOnDemand() {
+        if (!closed) {
+            close();
+        }
+    }
+
+    private void assertNotClosed() {
+        if (closed) {
+            throw new MockitoException(
+                    join(
+                            "The static mock created at",
+                            location.toString(),
+                            "is already resolved and cannot longer be used"));
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "static mock for " + control.getType().getName();
+    }
+}
diff --git a/src/main/java/org/mockito/internal/MockitoCore.java b/src/main/java/org/mockito/internal/MockitoCore.java
index 68b580a..fff3b76 100644
--- a/src/main/java/org/mockito/internal/MockitoCore.java
+++ b/src/main/java/org/mockito/internal/MockitoCore.java
@@ -4,10 +4,42 @@
  */
 package org.mockito.internal;
 
+import static org.mockito.internal.exceptions.Reporter.missingMethodInvocation;
+import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions;
+import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder;
+import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerify;
+import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions;
+import static org.mockito.internal.exceptions.Reporter.notAMockPassedWhenCreatingInOrder;
+import static org.mockito.internal.exceptions.Reporter.nullPassedToVerify;
+import static org.mockito.internal.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions;
+import static org.mockito.internal.exceptions.Reporter.nullPassedWhenCreatingInOrder;
+import static org.mockito.internal.exceptions.Reporter.stubPassedToVerify;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+import static org.mockito.internal.util.MockUtil.createConstructionMock;
+import static org.mockito.internal.util.MockUtil.createMock;
+import static org.mockito.internal.util.MockUtil.createStaticMock;
+import static org.mockito.internal.util.MockUtil.getInvocationContainer;
+import static org.mockito.internal.util.MockUtil.getMockHandler;
+import static org.mockito.internal.util.MockUtil.isMock;
+import static org.mockito.internal.util.MockUtil.resetMock;
+import static org.mockito.internal.util.MockUtil.typeMockabilityOf;
+import static org.mockito.internal.verification.VerificationModeFactory.noInteractions;
+import static org.mockito.internal.verification.VerificationModeFactory.noMoreInteractions;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
+import org.mockito.MockedConstruction;
+import org.mockito.MockedStatic;
 import org.mockito.MockingDetails;
+import org.mockito.exceptions.misusing.DoNotMockException;
 import org.mockito.exceptions.misusing.NotAMockException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;
 import org.mockito.internal.listeners.VerificationStartedNotifier;
@@ -17,6 +49,7 @@ import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.DefaultMockingDetails;
+import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
@@ -26,6 +59,8 @@ import org.mockito.internal.verification.api.VerificationDataInOrderImpl;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.DoNotMockEnforcer;
+import org.mockito.plugins.MockMaker;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.LenientStubber;
 import org.mockito.stubbing.OngoingStubbing;
@@ -34,43 +69,105 @@ import org.mockito.verification.VerificationMode;
 
 import java.util.Arrays;
 import java.util.List;
-
-import static org.mockito.internal.exceptions.Reporter.missingMethodInvocation;
-import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions;
-import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder;
-import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerify;
-import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions;
-import static org.mockito.internal.exceptions.Reporter.notAMockPassedWhenCreatingInOrder;
-import static org.mockito.internal.exceptions.Reporter.nullPassedToVerify;
-import static org.mockito.internal.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions;
-import static org.mockito.internal.exceptions.Reporter.nullPassedWhenCreatingInOrder;
-import static org.mockito.internal.exceptions.Reporter.stubPassedToVerify;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-import static org.mockito.internal.util.MockUtil.createMock;
-import static org.mockito.internal.util.MockUtil.getInvocationContainer;
-import static org.mockito.internal.util.MockUtil.isMock;
-import static org.mockito.internal.util.MockUtil.resetMock;
-import static org.mockito.internal.util.MockUtil.typeMockabilityOf;
-import static org.mockito.internal.verification.VerificationModeFactory.noMoreInteractions;
+import java.util.function.Function;
 
 @SuppressWarnings("unchecked")
 public class MockitoCore {
 
+    private static final DoNotMockEnforcer DO_NOT_MOCK_ENFORCER = Plugins.getDoNotMockEnforcer();
+    private static final Set<Class<?>> MOCKABLE_CLASSES =
+            Collections.synchronizedSet(new HashSet<>());
+
     public boolean isTypeMockable(Class<?> typeToMock) {
         return typeMockabilityOf(typeToMock).mockable();
     }
 
     public <T> T mock(Class<T> typeToMock, MockSettings settings) {
-        if (!MockSettingsImpl.class.isInstance(settings)) {
-            throw new IllegalArgumentException("Unexpected implementation of '" + settings.getClass().getCanonicalName() + "'\n" + "At the moment, you cannot provide your own implementations of that class.");
+        if (!(settings instanceof MockSettingsImpl)) {
+            throw new IllegalArgumentException(
+                    "Unexpected implementation of '"
+                            + settings.getClass().getCanonicalName()
+                            + "'\n"
+                            + "At the moment, you cannot provide your own implementations of that class.");
         }
-        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);
+        MockSettingsImpl impl = (MockSettingsImpl) settings;
         MockCreationSettings<T> creationSettings = impl.build(typeToMock);
+        checkDoNotMockAnnotation(creationSettings.getTypeToMock(), creationSettings);
         T mock = createMock(creationSettings);
         mockingProgress().mockingStarted(mock, creationSettings);
         return mock;
     }
 
+    private void checkDoNotMockAnnotation(
+            Class<?> typeToMock, MockCreationSettings<?> creationSettings) {
+        checkDoNotMockAnnotationForType(typeToMock);
+        for (Class<?> aClass : creationSettings.getExtraInterfaces()) {
+            checkDoNotMockAnnotationForType(aClass);
+        }
+    }
+
+    private static void checkDoNotMockAnnotationForType(Class<?> type) {
+        // Object and interfaces do not have a super class
+        if (type == null) {
+            return;
+        }
+
+        if (MOCKABLE_CLASSES.contains(type)) {
+            return;
+        }
+
+        String warning = DO_NOT_MOCK_ENFORCER.checkTypeForDoNotMockViolation(type);
+        if (warning != null) {
+            throw new DoNotMockException(warning);
+        }
+
+        checkDoNotMockAnnotationForType(type.getSuperclass());
+        for (Class<?> aClass : type.getInterfaces()) {
+            checkDoNotMockAnnotationForType(aClass);
+        }
+
+        MOCKABLE_CLASSES.add(type);
+    }
+
+    public <T> MockedStatic<T> mockStatic(Class<T> classToMock, MockSettings settings) {
+        if (!MockSettingsImpl.class.isInstance(settings)) {
+            throw new IllegalArgumentException(
+                    "Unexpected implementation of '"
+                            + settings.getClass().getCanonicalName()
+                            + "'\n"
+                            + "At the moment, you cannot provide your own implementations of that class.");
+        }
+        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);
+        MockCreationSettings<T> creationSettings = impl.buildStatic(classToMock);
+        MockMaker.StaticMockControl<T> control = createStaticMock(classToMock, creationSettings);
+        control.enable();
+        mockingProgress().mockingStarted(classToMock, creationSettings);
+        return new MockedStaticImpl<>(control);
+    }
+
+    public <T> MockedConstruction<T> mockConstruction(
+            Class<T> typeToMock,
+            Function<MockedConstruction.Context, ? extends MockSettings> settingsFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        Function<MockedConstruction.Context, MockCreationSettings<T>> creationSettings =
+                context -> {
+                    MockSettings value = settingsFactory.apply(context);
+                    if (!MockSettingsImpl.class.isInstance(value)) {
+                        throw new IllegalArgumentException(
+                                "Unexpected implementation of '"
+                                        + value.getClass().getCanonicalName()
+                                        + "'\n"
+                                        + "At the moment, you cannot provide your own implementations of that class.");
+                    }
+                    MockSettingsImpl impl = MockSettingsImpl.class.cast(value);
+                    return impl.build(typeToMock);
+                };
+        MockMaker.ConstructionMockControl<T> control =
+                createConstructionMock(typeToMock, creationSettings, mockInitializer);
+        control.enable();
+        return new MockedConstructionImpl<>(control);
+    }
+
     public <T> OngoingStubbing<T> when(T methodCall) {
         MockingProgress mockingProgress = mockingProgress();
         mockingProgress.stubbingStarted();
@@ -91,16 +188,19 @@ public class MockitoCore {
         if (!mockingDetails.isMock()) {
             throw notAMockPassedToVerify(mock.getClass());
         }
+        assertNotStubOnlyMock(mock);
         MockHandler handler = mockingDetails.getMockHandler();
-        if (handler.getMockSettings().isStubOnly()) {
-            throw stubPassedToVerify();
-        }
-        mock = (T) VerificationStartedNotifier.notifyVerificationStarted(
-            handler.getMockSettings().getVerificationStartedListeners(), mockingDetails);
+        mock =
+                (T)
+                        VerificationStartedNotifier.notifyVerificationStarted(
+                                handler.getMockSettings().getVerificationStartedListeners(),
+                                mockingDetails);
 
         MockingProgress mockingProgress = mockingProgress();
         VerificationMode actualMode = mockingProgress.maybeVerifyLazily(mode);
-        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, actualMode, mockingProgress.verificationListeners()));
+        mockingProgress.verificationStarted(
+                new MockAwareVerificationMode(
+                        mock, actualMode, mockingProgress.verificationListeners()));
         return mock;
     }
 
@@ -135,6 +235,7 @@ public class MockitoCore {
                     throw nullPassedToVerifyNoMoreInteractions();
                 }
                 InvocationContainerImpl invocations = getInvocationContainer(mock);
+                assertNotStubOnlyMock(mock);
                 VerificationDataImpl data = new VerificationDataImpl(invocations, null);
                 noMoreInteractions().verify(data);
             } catch (NotAMockException e) {
@@ -143,9 +244,29 @@ public class MockitoCore {
         }
     }
 
+    public void verifyNoInteractions(Object... mocks) {
+        assertMocksNotEmpty(mocks);
+        mockingProgress().validateState();
+        for (Object mock : mocks) {
+            try {
+                if (mock == null) {
+                    throw nullPassedToVerifyNoMoreInteractions();
+                }
+                InvocationContainerImpl invocations = getInvocationContainer(mock);
+                assertNotStubOnlyMock(mock);
+                VerificationDataImpl data = new VerificationDataImpl(invocations, null);
+                noInteractions().verify(data);
+            } catch (NotAMockException e) {
+                throw notAMockPassedToVerifyNoMoreInteractions();
+            }
+        }
+    }
+
     public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {
         mockingProgress().validateState();
-        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, VerifiableInvocationsFinder.find(mocks), null);
+        VerificationDataInOrder data =
+                new VerificationDataInOrderImpl(
+                        inOrderContext, VerifiableInvocationsFinder.find(mocks), null);
         VerificationModeFactory.noMoreInteractions().verifyInOrder(data);
     }
 
@@ -155,6 +276,12 @@ public class MockitoCore {
         }
     }
 
+    private void assertNotStubOnlyMock(Object mock) {
+        if (getMockHandler(mock).getMockSettings().isStubOnly()) {
+            throw stubPassedToVerify(mock);
+        }
+    }
+
     public InOrder inOrder(Object... mocks) {
         if (mocks == null || mocks.length == 0) {
             throw mocksHaveToBePassedWhenCreatingInOrder();
@@ -166,6 +293,7 @@ public class MockitoCore {
             if (!isMock(mock)) {
                 throw notAMockPassedWhenCreatingInOrder();
             }
+            assertNotStubOnlyMock(mock);
         }
         return new InOrderImpl(Arrays.asList(mocks));
     }
@@ -191,7 +319,8 @@ public class MockitoCore {
      * @return last invocation
      */
     public Invocation getLastInvocation() {
-        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress().pullOngoingStubbing());
+        OngoingStubbingImpl ongoingStubbing =
+                ((OngoingStubbingImpl) mockingProgress().pullOngoingStubbing());
         List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();
         return allInvocations.get(allInvocations.size() - 1);
     }
@@ -216,4 +345,8 @@ public class MockitoCore {
     public LenientStubber lenient() {
         return new DefaultLenientStubber();
     }
+
+    public void clearAllCaches() {
+        MockUtil.clearAllCaches();
+    }
 }
diff --git a/src/main/java/org/mockito/internal/SuppressSignatureCheck.java b/src/main/java/org/mockito/internal/SuppressSignatureCheck.java
new file mode 100644
index 0000000..2a47d00
--- /dev/null
+++ b/src/main/java/org/mockito/internal/SuppressSignatureCheck.java
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.CLASS)
+@Documented
+public @interface SuppressSignatureCheck {}
diff --git a/src/main/java/org/mockito/internal/configuration/CaptorAnnotationProcessor.java b/src/main/java/org/mockito/internal/configuration/CaptorAnnotationProcessor.java
index 0ccbfbc..600583b 100644
--- a/src/main/java/org/mockito/internal/configuration/CaptorAnnotationProcessor.java
+++ b/src/main/java/org/mockito/internal/configuration/CaptorAnnotationProcessor.java
@@ -4,23 +4,27 @@
  */
 package org.mockito.internal.configuration;
 
+import java.lang.reflect.Field;
+
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.GenericMaster;
 
-import java.lang.reflect.Field;
-
 /**
  * Instantiate {@link ArgumentCaptor} a field annotated by &#64;Captor.
  */
 public class CaptorAnnotationProcessor implements FieldAnnotationProcessor<Captor> {
+    @Override
     public Object process(Captor annotation, Field field) {
         Class<?> type = field.getType();
         if (!ArgumentCaptor.class.isAssignableFrom(type)) {
-            throw new MockitoException("@Captor field must be of the type ArgumentCaptor.\n" + "Field: '"
-               + field.getName() + "' has wrong type\n"
-               + "For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.");
+            throw new MockitoException(
+                    "@Captor field must be of the type ArgumentCaptor.\n"
+                            + "Field: '"
+                            + field.getName()
+                            + "' has wrong type\n"
+                            + "For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.");
         }
         Class<?> cls = new GenericMaster().getGenericType(field);
         return ArgumentCaptor.forClass(cls);
diff --git a/src/main/java/org/mockito/internal/configuration/ClassPathLoader.java b/src/main/java/org/mockito/internal/configuration/ClassPathLoader.java
index 67b2040..0f031ee 100644
--- a/src/main/java/org/mockito/internal/configuration/ClassPathLoader.java
+++ b/src/main/java/org/mockito/internal/configuration/ClassPathLoader.java
@@ -8,7 +8,6 @@ import org.mockito.configuration.IMockitoConfiguration;
 import org.mockito.exceptions.misusing.MockitoConfigurationException;
 import org.mockito.plugins.MockMaker;
 
-
 /**
  * Loads configuration or extension points available in the classpath.
  *
@@ -47,7 +46,8 @@ import org.mockito.plugins.MockMaker;
  */
 public class ClassPathLoader {
 
-    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = "org.mockito.configuration.MockitoConfiguration";
+    public static final String MOCKITO_CONFIGURATION_CLASS_NAME =
+            "org.mockito.configuration.MockitoConfiguration";
 
     /**
      * @return configuration loaded from classpath or null
@@ -59,16 +59,24 @@ public class ClassPathLoader {
         try {
             configClass = Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);
         } catch (ClassNotFoundException e) {
-            //that's ok, it means there is no global config, using default one.
+            // that's ok, it means there is no global config, using default one.
             return null;
         }
 
         try {
-            return (IMockitoConfiguration) configClass.newInstance();
+            return (IMockitoConfiguration) configClass.getDeclaredConstructor().newInstance();
         } catch (ClassCastException e) {
-            throw new MockitoConfigurationException("MockitoConfiguration class must implement " + IMockitoConfiguration.class.getName() + " interface.", e);
+            throw new MockitoConfigurationException(
+                    "MockitoConfiguration class must implement "
+                            + IMockitoConfiguration.class.getName()
+                            + " interface.",
+                    e);
         } catch (Exception e) {
-            throw new MockitoConfigurationException("Unable to instantiate " + MOCKITO_CONFIGURATION_CLASS_NAME +" class. Does it have a safe, no-arg constructor?", e);
+            throw new MockitoConfigurationException(
+                    "Unable to instantiate "
+                            + MOCKITO_CONFIGURATION_CLASS_NAME
+                            + " class. Does it have a safe, no-arg constructor?",
+                    e);
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/DefaultDoNotMockEnforcer.java b/src/main/java/org/mockito/internal/configuration/DefaultDoNotMockEnforcer.java
new file mode 100644
index 0000000..ada97d6
--- /dev/null
+++ b/src/main/java/org/mockito/internal/configuration/DefaultDoNotMockEnforcer.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.configuration;
+
+import java.lang.annotation.Annotation;
+
+import org.mockito.DoNotMock;
+import org.mockito.plugins.DoNotMockEnforcer;
+
+public class DefaultDoNotMockEnforcer implements DoNotMockEnforcer {
+
+    @Override
+    public String checkTypeForDoNotMockViolation(Class<?> type) {
+        for (Annotation annotation : type.getAnnotations()) {
+            if (annotation.annotationType().getName().endsWith("org.mockito.DoNotMock")) {
+                String exceptionMessage =
+                        type + " is annotated with @org.mockito.DoNotMock and can't be mocked.";
+                if (DoNotMock.class.equals(annotation.annotationType())) {
+                    exceptionMessage += " " + type.getAnnotation(DoNotMock.class).reason();
+                }
+
+                return exceptionMessage;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/main/java/org/mockito/internal/configuration/DefaultInjectionEngine.java
index e5e98a1..f6b3595 100644
--- a/src/main/java/org/mockito/internal/configuration/DefaultInjectionEngine.java
+++ b/src/main/java/org/mockito/internal/configuration/DefaultInjectionEngine.java
@@ -16,7 +16,8 @@ import org.mockito.internal.configuration.injection.MockInjection;
  */
 public class DefaultInjectionEngine {
 
-    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {
+    public void injectMocksOnFields(
+            Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {
         MockInjection.onFields(needingInjection, testClassInstance)
                 .withMocks(mocks)
                 .tryConstructorInjection()
@@ -24,5 +25,4 @@ public class DefaultInjectionEngine {
                 .handleSpyAnnotation()
                 .apply();
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/configuration/GlobalConfiguration.java b/src/main/java/org/mockito/internal/configuration/GlobalConfiguration.java
index 4ac027a..92f5a54 100644
--- a/src/main/java/org/mockito/internal/configuration/GlobalConfiguration.java
+++ b/src/main/java/org/mockito/internal/configuration/GlobalConfiguration.java
@@ -5,7 +5,7 @@
 package org.mockito.internal.configuration;
 
 import java.io.Serializable;
-import org.mockito.configuration.AnnotationEngine;
+
 import org.mockito.configuration.DefaultMockitoConfiguration;
 import org.mockito.configuration.IMockitoConfiguration;
 import org.mockito.internal.configuration.plugins.Plugins;
@@ -17,15 +17,16 @@ import org.mockito.stubbing.Answer;
 public class GlobalConfiguration implements IMockitoConfiguration, Serializable {
     private static final long serialVersionUID = -2860353062105505938L;
 
-    private static final ThreadLocal<IMockitoConfiguration> GLOBAL_CONFIGURATION = new ThreadLocal<IMockitoConfiguration>();
+    private static final ThreadLocal<IMockitoConfiguration> GLOBAL_CONFIGURATION =
+            new ThreadLocal<>();
 
-    //back door for testing
+    // back door for testing
     IMockitoConfiguration getIt() {
         return GLOBAL_CONFIGURATION.get();
     }
 
     public GlobalConfiguration() {
-        //Configuration should be loaded only once but I cannot really test it
+        // Configuration should be loaded only once but I cannot really test it
         if (GLOBAL_CONFIGURATION.get() == null) {
             GLOBAL_CONFIGURATION.set(createConfig());
         }
@@ -45,28 +46,21 @@ public class GlobalConfiguration implements IMockitoConfiguration, Serializable
         new GlobalConfiguration();
     }
 
-    public AnnotationEngine getAnnotationEngine() {
-        return GLOBAL_CONFIGURATION.get().getAnnotationEngine();
-    }
-
     public org.mockito.plugins.AnnotationEngine tryGetPluginAnnotationEngine() {
-        IMockitoConfiguration configuration = GLOBAL_CONFIGURATION.get();
-        if (configuration.getClass() == DefaultMockitoConfiguration.class) {
-            return Plugins.getAnnotationEngine();
-        }
-        return configuration.getAnnotationEngine();
+        return Plugins.getAnnotationEngine();
     }
 
-
-
+    @Override
     public boolean cleansStackTrace() {
         return GLOBAL_CONFIGURATION.get().cleansStackTrace();
     }
 
+    @Override
     public boolean enableClassCache() {
         return GLOBAL_CONFIGURATION.get().enableClassCache();
     }
 
+    @Override
     public Answer<Object> getDefaultAnswer() {
         return GLOBAL_CONFIGURATION.get().getDefaultAnswer();
     }
diff --git a/src/main/java/org/mockito/internal/configuration/IndependentAnnotationEngine.java b/src/main/java/org/mockito/internal/configuration/IndependentAnnotationEngine.java
index d78476a..a7950da 100644
--- a/src/main/java/org/mockito/internal/configuration/IndependentAnnotationEngine.java
+++ b/src/main/java/org/mockito/internal/configuration/IndependentAnnotationEngine.java
@@ -4,18 +4,23 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.mockito.internal.exceptions.Reporter.moreThanOneAnnotationNotAllowed;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+
 import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.ScopedMock;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.plugins.AnnotationEngine;
-
-import static org.mockito.internal.exceptions.Reporter.moreThanOneAnnotationNotAllowed;
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
+import org.mockito.plugins.MemberAccessor;
 
 /**
  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.
@@ -26,8 +31,9 @@ import static org.mockito.internal.util.reflection.FieldSetter.setField;
  * @see MockitoAnnotations
  */
 @SuppressWarnings("unchecked")
-public class IndependentAnnotationEngine implements AnnotationEngine, org.mockito.configuration.AnnotationEngine {
-    private final Map<Class<? extends Annotation>, FieldAnnotationProcessor<?>> annotationProcessorMap = new HashMap<Class<? extends Annotation>, FieldAnnotationProcessor<?>>();
+public class IndependentAnnotationEngine implements AnnotationEngine {
+    private final Map<Class<? extends Annotation>, FieldAnnotationProcessor<?>>
+            annotationProcessorMap = new HashMap<>();
 
     public IndependentAnnotationEngine() {
         registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());
@@ -40,38 +46,58 @@ public class IndependentAnnotationEngine implements AnnotationEngine, org.mockit
 
     private <A extends Annotation> FieldAnnotationProcessor<A> forAnnotation(A annotation) {
         if (annotationProcessorMap.containsKey(annotation.annotationType())) {
-            return (FieldAnnotationProcessor<A>) annotationProcessorMap.get(annotation.annotationType());
+            return (FieldAnnotationProcessor<A>)
+                    annotationProcessorMap.get(annotation.annotationType());
         }
         return new FieldAnnotationProcessor<A>() {
+            @Override
             public Object process(A annotation, Field field) {
                 return null;
             }
         };
     }
 
-    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {
+    private <A extends Annotation> void registerAnnotationProcessor(
+            Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {
         annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);
     }
 
     @Override
-    public void process(Class<?> clazz, Object testInstance) {
+    public AutoCloseable process(Class<?> clazz, Object testInstance) {
+        List<ScopedMock> scopedMocks = new ArrayList<>();
         Field[] fields = clazz.getDeclaredFields();
         for (Field field : fields) {
             boolean alreadyAssigned = false;
-            for(Annotation annotation : field.getAnnotations()) {
+            for (Annotation annotation : field.getAnnotations()) {
                 Object mock = createMockFor(annotation, field);
+                if (mock instanceof ScopedMock) {
+                    scopedMocks.add((ScopedMock) mock);
+                }
                 if (mock != null) {
                     throwIfAlreadyAssigned(field, alreadyAssigned);
                     alreadyAssigned = true;
+                    final MemberAccessor accessor = Plugins.getMemberAccessor();
                     try {
-                        setField(testInstance, field,mock);
+                        accessor.set(field, testInstance, mock);
                     } catch (Exception e) {
-                        throw new MockitoException("Problems setting field " + field.getName() + " annotated with "
-                                + annotation, e);
+                        for (ScopedMock scopedMock : scopedMocks) {
+                            scopedMock.close();
+                        }
+                        throw new MockitoException(
+                                "Problems setting field "
+                                        + field.getName()
+                                        + " annotated with "
+                                        + annotation,
+                                e);
                     }
                 }
             }
         }
+        return () -> {
+            for (ScopedMock scopedMock : scopedMocks) {
+                scopedMock.closeOnDemand();
+            }
+        };
     }
 
     void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {
@@ -79,5 +105,4 @@ public class IndependentAnnotationEngine implements AnnotationEngine, org.mockit
             throw moreThanOneAnnotationNotAllowed(field.getName());
         }
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java b/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java
index 6cb5fb1..ef9933d 100644
--- a/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java
+++ b/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java
@@ -4,20 +4,24 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
+
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
+
 import org.mockito.MockitoAnnotations;
+import org.mockito.ScopedMock;
 import org.mockito.internal.configuration.injection.scanner.InjectMocksScanner;
 import org.mockito.internal.configuration.injection.scanner.MockScanner;
 import org.mockito.plugins.AnnotationEngine;
 
-import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
-
 /**
  * See {@link MockitoAnnotations}
  */
-public class InjectingAnnotationEngine implements AnnotationEngine, org.mockito.configuration.AnnotationEngine {
+public class InjectingAnnotationEngine implements AnnotationEngine {
     private final AnnotationEngine delegate = new IndependentAnnotationEngine();
     private final AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();
 
@@ -37,31 +41,57 @@ public class InjectingAnnotationEngine implements AnnotationEngine, org.mockito.
      *
      * @see org.mockito.plugins.AnnotationEngine#process(Class, Object)
      */
-    public void process(Class<?> clazz, Object testInstance) {
-        processIndependentAnnotations(testInstance.getClass(), testInstance);
-        processInjectMocks(testInstance.getClass(), testInstance);
+    @Override
+    public AutoCloseable process(Class<?> clazz, Object testInstance) {
+        List<AutoCloseable> closeables = new ArrayList<>();
+        closeables.addAll(processIndependentAnnotations(testInstance.getClass(), testInstance));
+        closeables.addAll(processInjectMocks(testInstance.getClass(), testInstance));
+        return () -> {
+            for (AutoCloseable closeable : closeables) {
+                closeable.close();
+            }
+        };
     }
 
-    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
+    private List<AutoCloseable> processInjectMocks(
+            final Class<?> clazz, final Object testInstance) {
+        List<AutoCloseable> closeables = new ArrayList<>();
         Class<?> classContext = clazz;
         while (classContext != Object.class) {
-            injectMocks(testInstance);
+            closeables.add(injectCloseableMocks(testInstance));
             classContext = classContext.getSuperclass();
         }
+        return closeables;
     }
 
-    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {
+    private List<AutoCloseable> processIndependentAnnotations(
+            final Class<?> clazz, final Object testInstance) {
+        List<AutoCloseable> closeables = new ArrayList<>();
         Class<?> classContext = clazz;
         while (classContext != Object.class) {
-            //this will create @Mocks, @Captors, etc:
-            delegate.process(classContext, testInstance);
-            //this will create @Spies:
-            spyAnnotationEngine.process(classContext, testInstance);
+            // this will create @Mocks, @Captors, etc:
+            closeables.add(delegate.process(classContext, testInstance));
+            // this will create @Spies:
+            closeables.add(spyAnnotationEngine.process(classContext, testInstance));
 
             classContext = classContext.getSuperclass();
         }
+        return closeables;
     }
 
+    /**
+     * Required by PowerMockito and retained to avoid API breakage despite being internal API.
+     *
+     * @deprecated Use {@link InjectingAnnotationEngine#injectCloseableMocks(Object)}.
+     */
+    @Deprecated
+    public void injectMocks(Object testClassInstance) {
+        try {
+            injectCloseableMocks(testClassInstance).close();
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
+        }
+    }
 
     /**
      * Initializes mock/spies dependencies for objects annotated with
@@ -72,9 +102,9 @@ public class InjectingAnnotationEngine implements AnnotationEngine, org.mockito.
      * @param testClassInstance
      *            Test class, usually <code>this</code>
      */
-    public void injectMocks(final Object testClassInstance) {
+    private AutoCloseable injectCloseableMocks(final Object testClassInstance) {
         Class<?> clazz = testClassInstance.getClass();
-        Set<Field> mockDependentFields = new HashSet<Field>();
+        Set<Field> mockDependentFields = new HashSet<>();
         Set<Object> mocks = newMockSafeHashSet();
 
         while (clazz != Object.class) {
@@ -84,11 +114,21 @@ public class InjectingAnnotationEngine implements AnnotationEngine, org.mockito.
             clazz = clazz.getSuperclass();
         }
 
-        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
-    }
-
-    protected void onInjection(Object testClassInstance, Class<?> clazz, Set<Field> mockDependentFields, Set<Object> mocks) {
+        new DefaultInjectionEngine()
+                .injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
 
+        return () -> {
+            for (Object mock : mocks) {
+                if (mock instanceof ScopedMock) {
+                    ((ScopedMock) mock).closeOnDemand();
+                }
+            }
+        };
     }
 
+    protected void onInjection(
+            Object testClassInstance,
+            Class<?> clazz,
+            Set<Field> mockDependentFields,
+            Set<Object> mocks) {}
 }
diff --git a/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java b/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
index 91086d2..e48291e 100644
--- a/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
+++ b/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
@@ -4,11 +4,19 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
 import org.mockito.Mock;
 import org.mockito.MockSettings;
+import org.mockito.MockedConstruction;
+import org.mockito.MockedStatic;
 import org.mockito.Mockito;
-
-import java.lang.reflect.Field;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.Supplier;
 
 /**
  * Instantiates a mock on a field annotated by {@link Mock}
@@ -16,10 +24,12 @@ import java.lang.reflect.Field;
 public class MockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {
     @Override
     public Object process(Mock annotation, Field field) {
-        return processAnnotationForMock(annotation, field.getType(), field.getName());
+        return processAnnotationForMock(
+                annotation, field.getType(), field::getGenericType, field.getName());
     }
 
-    public static Object processAnnotationForMock(Mock annotation, Class<?> type, String name) {
+    public static Object processAnnotationForMock(
+            Mock annotation, Class<?> type, Supplier<Type> genericType, String name) {
         MockSettings mockSettings = Mockito.withSettings();
         if (annotation.extraInterfaces().length > 0) { // never null
             mockSettings.extraInterfaces(annotation.extraInterfaces());
@@ -29,15 +39,53 @@ public class MockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {
         } else {
             mockSettings.name(annotation.name());
         }
-        if(annotation.serializable()){
+        if (annotation.serializable()) {
             mockSettings.serializable();
         }
-        if(annotation.stubOnly()){
+        if (annotation.stubOnly()) {
             mockSettings.stubOnly();
         }
+        if (annotation.lenient()) {
+            mockSettings.lenient();
+        }
 
         // see @Mock answer default value
         mockSettings.defaultAnswer(annotation.answer());
-        return Mockito.mock(type, mockSettings);
+
+        if (type == MockedStatic.class) {
+            return Mockito.mockStatic(
+                    inferParameterizedType(
+                            genericType.get(), name, MockedStatic.class.getSimpleName()),
+                    mockSettings);
+        } else if (type == MockedConstruction.class) {
+            return Mockito.mockConstruction(
+                    inferParameterizedType(
+                            genericType.get(), name, MockedConstruction.class.getSimpleName()),
+                    mockSettings);
+        } else {
+            return Mockito.mock(type, mockSettings);
+        }
+    }
+
+    static Class<?> inferParameterizedType(Type type, String name, String sort) {
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type[] arguments = parameterizedType.getActualTypeArguments();
+            if (arguments.length == 1) {
+                if (arguments[0] instanceof Class<?>) {
+                    return (Class<?>) arguments[0];
+                }
+            }
+        }
+        throw new MockitoException(
+                join(
+                        "Mockito cannot infer a static mock from a raw type for " + name,
+                        "",
+                        "Instead of @Mock " + sort + " you need to specify a parameterized type",
+                        "For example, if you would like to mock Sample.class, specify",
+                        "",
+                        "@Mock " + sort + "<Sample>",
+                        "",
+                        "as the type parameter. If the type is itself parameterized, it should be specified as raw type."));
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java b/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
index 92d045d..a88ad63 100644
--- a/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
+++ b/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
@@ -4,11 +4,17 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.mockito.Mockito.CALLS_REAL_METHODS;
+import static org.mockito.Mockito.withSettings;
+import static org.mockito.internal.exceptions.Reporter.unsupportedCombinationOfAnnotations;
+import static org.mockito.internal.util.StringUtil.join;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Modifier;
+
 import org.mockito.Captor;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
@@ -16,13 +22,10 @@ import org.mockito.MockSettings;
 import org.mockito.Mockito;
 import org.mockito.Spy;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.plugins.AnnotationEngine;
-
-import static org.mockito.Mockito.CALLS_REAL_METHODS;
-import static org.mockito.Mockito.withSettings;
-import static org.mockito.internal.exceptions.Reporter.unsupportedCombinationOfAnnotations;
-import static org.mockito.internal.util.StringUtil.join;
+import org.mockito.plugins.MemberAccessor;
 
 /**
  * Process fields annotated with &#64;Spy.
@@ -43,73 +46,86 @@ import static org.mockito.internal.util.StringUtil.join;
  * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.
  */
 @SuppressWarnings({"unchecked"})
-public class SpyAnnotationEngine implements AnnotationEngine, org.mockito.configuration.AnnotationEngine {
+public class SpyAnnotationEngine implements AnnotationEngine {
 
     @Override
-    public void process(Class<?> context, Object testInstance) {
+    public AutoCloseable process(Class<?> context, Object testInstance) {
         Field[] fields = context.getDeclaredFields();
+        MemberAccessor accessor = Plugins.getMemberAccessor();
         for (Field field : fields) {
-            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {
+            if (field.isAnnotationPresent(Spy.class)
+                    && !field.isAnnotationPresent(InjectMocks.class)) {
                 assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, Captor.class);
-                field.setAccessible(true);
                 Object instance;
                 try {
-                    instance = field.get(testInstance);
+                    instance = accessor.get(field, testInstance);
                     if (MockUtil.isMock(instance)) {
                         // instance has been spied earlier
-                        // for example happens when MockitoAnnotations.initMocks is called two times.
+                        // for example happens when MockitoAnnotations.openMocks is called two
+                        // times.
                         Mockito.reset(instance);
                     } else if (instance != null) {
-                        field.set(testInstance, spyInstance(field, instance));
+                        accessor.set(field, testInstance, spyInstance(field, instance));
                     } else {
-                        field.set(testInstance, spyNewInstance(testInstance, field));
+                        accessor.set(field, testInstance, spyNewInstance(testInstance, field));
                     }
                 } catch (Exception e) {
-                    throw new MockitoException("Unable to initialize @Spy annotated field '" + field.getName() + "'.\n" + e.getMessage(), e);
+                    throw new MockitoException(
+                            "Unable to initialize @Spy annotated field '"
+                                    + field.getName()
+                                    + "'.\n"
+                                    + e.getMessage(),
+                            e);
                 }
             }
         }
+        return new NoAction();
     }
 
     private static Object spyInstance(Field field, Object instance) {
-        return Mockito.mock(instance.getClass(),
-                            withSettings().spiedInstance(instance)
-                                                           .defaultAnswer(CALLS_REAL_METHODS)
-                                                           .name(field.getName()));
+        return Mockito.mock(
+                instance.getClass(),
+                withSettings()
+                        .spiedInstance(instance)
+                        .defaultAnswer(CALLS_REAL_METHODS)
+                        .name(field.getName()));
     }
 
     private static Object spyNewInstance(Object testInstance, Field field)
             throws InstantiationException, IllegalAccessException, InvocationTargetException {
-        MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
-                                              .name(field.getName());
+        MockSettings settings =
+                withSettings().defaultAnswer(CALLS_REAL_METHODS).name(field.getName());
         Class<?> type = field.getType();
         if (type.isInterface()) {
             return Mockito.mock(type, settings.useConstructor());
         }
         int modifiers = type.getModifiers();
         if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
-            throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
-                                            "  inner class: '" + type.getSimpleName() + "'",
-                                            "  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
-                                            "",
-                                            "You should augment the visibility of this inner class"));
+            throw new MockitoException(
+                    join(
+                            "@Spy annotation can't initialize private abstract inner classes.",
+                            "  inner class: '" + type.getSimpleName() + "'",
+                            "  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
+                            "",
+                            "You should augment the visibility of this inner class"));
         }
         if (typeIsNonStaticInnerClass(type, modifiers)) {
             Class<?> enclosing = type.getEnclosingClass();
             if (!enclosing.isInstance(testInstance)) {
-                throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
-                                                "  inner class: '" + type.getSimpleName() + "'",
-                                                "  outer class: '" + enclosing.getSimpleName() + "'",
-                                                ""));
+                throw new MockitoException(
+                        join(
+                                "@Spy annotation can only initialize inner classes declared in the test.",
+                                "  inner class: '" + type.getSimpleName() + "'",
+                                "  outer class: '" + enclosing.getSimpleName() + "'",
+                                ""));
             }
-            return Mockito.mock(type, settings.useConstructor()
-                                              .outerInstance(testInstance));
+            return Mockito.mock(type, settings.useConstructor().outerInstance(testInstance));
         }
 
         Constructor<?> constructor = noArgConstructorOf(type);
         if (Modifier.isPrivate(constructor.getModifiers())) {
-            constructor.setAccessible(true);
-            return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
+            MemberAccessor accessor = Plugins.getMemberAccessor();
+            return Mockito.mock(type, settings.spiedInstance(accessor.newInstance(constructor)));
         } else {
             return Mockito.mock(type, settings.useConstructor());
         }
@@ -120,7 +136,11 @@ public class SpyAnnotationEngine implements AnnotationEngine, org.mockito.config
         try {
             constructor = type.getDeclaredConstructor();
         } catch (NoSuchMethodException e) {
-            throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
+            throw new MockitoException(
+                    "Please ensure that the type '"
+                            + type.getSimpleName()
+                            + "' has a no-arg constructor.",
+                    e);
         }
         return constructor;
     }
@@ -130,17 +150,20 @@ public class SpyAnnotationEngine implements AnnotationEngine, org.mockito.config
     }
 
     private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
-        return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
+        return Modifier.isPrivate(modifiers)
+                && Modifier.isAbstract(modifiers)
+                && type.getEnclosingClass() != null;
     }
 
-    //TODO duplicated elsewhere
-    private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
-                                                        Field field,
-                                                        Class<? extends Annotation>... undesiredAnnotations) {
+    // TODO duplicated elsewhere
+    private static void assertNoIncompatibleAnnotations(
+            Class<? extends Annotation> annotation,
+            Field field,
+            Class<? extends Annotation>... undesiredAnnotations) {
         for (Class<? extends Annotation> u : undesiredAnnotations) {
             if (field.isAnnotationPresent(u)) {
-                throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
-                                                          u.getSimpleName());
+                throw unsupportedCombinationOfAnnotations(
+                        annotation.getSimpleName(), u.getSimpleName());
             }
         }
     }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/ConstructorInjection.java b/src/main/java/org/mockito/internal/configuration/injection/ConstructorInjection.java
index ffece34..f1577d7 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/ConstructorInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/ConstructorInjection.java
@@ -2,14 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.util.reflection.FieldInitializationReport;
-import org.mockito.internal.util.reflection.FieldInitializer;
-import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
-
 import static org.mockito.internal.exceptions.Reporter.fieldInitialisationThrewException;
 
 import java.lang.reflect.Field;
@@ -18,6 +12,11 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.reflection.FieldInitializationReport;
+import org.mockito.internal.util.reflection.FieldInitializer;
+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
+
 /**
  * Injection strategy based on constructor.
  *
@@ -38,23 +37,25 @@ import java.util.Set;
  */
 public class ConstructorInjection extends MockInjectionStrategy {
 
-    public ConstructorInjection() { }
+    public ConstructorInjection() {}
 
+    @Override
     public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {
         try {
-            SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);
-            FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();
+            SimpleArgumentResolver simpleArgumentResolver =
+                    new SimpleArgumentResolver(mockCandidates);
+            FieldInitializationReport report =
+                    new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();
 
             return report.fieldWasInitializedUsingContructorArgs();
         } catch (MockitoException e) {
-            if(e.getCause() instanceof InvocationTargetException) {
+            if (e.getCause() instanceof InvocationTargetException) {
                 Throwable realCause = e.getCause().getCause();
                 throw fieldInitialisationThrewException(field, realCause);
             }
             // other causes should be fine
             return false;
         }
-
     }
 
     /**
@@ -67,8 +68,9 @@ public class ConstructorInjection extends MockInjectionStrategy {
             this.objects = objects;
         }
 
+        @Override
         public Object[] resolveTypeInstances(Class<?>... argTypes) {
-            List<Object> argumentInstances = new ArrayList<Object>(argTypes.length);
+            List<Object> argumentInstances = new ArrayList<>(argTypes.length);
             for (Class<?> argType : argTypes) {
                 argumentInstances.add(objectThatIsAssignableFrom(argType));
             }
@@ -77,10 +79,11 @@ public class ConstructorInjection extends MockInjectionStrategy {
 
         private Object objectThatIsAssignableFrom(Class<?> argType) {
             for (Object object : objects) {
-                if(argType.isAssignableFrom(object.getClass())) return object;
+                if (argType.isAssignableFrom(object.getClass())) {
+                    return object;
+                }
             }
             return null;
         }
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/MockInjection.java b/src/main/java/org/mockito/internal/configuration/injection/MockInjection.java
index ef5312c..342391e 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/MockInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/MockInjection.java
@@ -2,27 +2,23 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
+import static org.mockito.internal.util.Checks.checkItemsNotNull;
+import static org.mockito.internal.util.Checks.checkNotNull;
+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
+
 import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
-import static org.mockito.internal.util.Checks.checkItemsNotNull;
-import static org.mockito.internal.util.Checks.checkNotNull;
-import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
-
 /**
  * Internal injection configuration utility.
  *
- * <p>
- * Allow the user of this class to configure the way the injection of mocks will happen.
- * </p>
- *
+ * <p>Allow the user of this class to configure the way the injection of mocks will happen.
  */
-public class MockInjection {
+public final class MockInjection {
 
     /**
      * Create a new configuration setup for a field
@@ -52,7 +48,7 @@ public class MockInjection {
      * Ongoing configuration of the mock injector.
      */
     public static class OngoingMockInjection {
-        private final Set<Field> fields = new HashSet<Field>();
+        private final Set<Field> fields = new HashSet<>();
         private final Set<Object> mocks = newMockSafeHashSet();
         private final Object fieldOwner;
         private final MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();
@@ -94,4 +90,6 @@ public class MockInjection {
             }
         }
     }
+
+    private MockInjection() {}
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/MockInjectionStrategy.java b/src/main/java/org/mockito/internal/configuration/injection/MockInjectionStrategy.java
index 5b56eb0..1ce4c05 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/MockInjectionStrategy.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/MockInjectionStrategy.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
 import java.lang.reflect.Field;
@@ -18,13 +17,14 @@ public abstract class MockInjectionStrategy {
      */
     public static MockInjectionStrategy nop() {
         return new MockInjectionStrategy() {
-            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {
+            @Override
+            protected boolean processInjection(
+                    Field field, Object fieldOwner, Set<Object> mockCandidates) {
                 return false;
             }
         };
     }
 
-
     private MockInjectionStrategy nextStrategy;
 
     /**
@@ -38,7 +38,7 @@ public abstract class MockInjectionStrategy {
      * @return The passed strategy instance to allow chaining.
      */
     public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {
-        if(nextStrategy != null) {
+        if (nextStrategy != null) {
             nextStrategy.thenTry(strategy);
         } else {
             nextStrategy = strategy;
@@ -65,7 +65,7 @@ public abstract class MockInjectionStrategy {
      * @return <code>true</code> if successful, <code>false</code> otherwise.
      */
     public boolean process(Field onField, Object fieldOwnedBy, Set<Object> mockCandidates) {
-        if(processInjection(onField, fieldOwnedBy, mockCandidates)) {
+        if (processInjection(onField, fieldOwnedBy, mockCandidates)) {
             return true;
         }
         return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);
@@ -83,9 +83,11 @@ public abstract class MockInjectionStrategy {
      * @param mockCandidates Pool of mocks to inject.
      * @return <code>true</code> if injection occurred, <code>false</code> otherwise
      */
-    protected abstract boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates);
+    protected abstract boolean processInjection(
+            Field field, Object fieldOwner, Set<Object> mockCandidates);
 
-    private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {
+    private boolean relayProcessToNextStrategy(
+            Field field, Object fieldOwner, Set<Object> mockCandidates) {
         return nextStrategy != null && nextStrategy.process(field, fieldOwner, mockCandidates);
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 2d74197..06e340e 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
 import static org.mockito.internal.exceptions.Reporter.cannotInitializeForInjectMocksAnnotation;
@@ -65,25 +64,33 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
 
     private final MockCandidateFilter mockCandidateFilter =
             new TypeBasedCandidateFilter(
-                    new NameBasedCandidateFilter(
-                            new TerminalMockCandidateFilter()));
-
-    private final ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {
-        public boolean isOut(Field object) {
-            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());
-        }
-    };
-
-
-    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
-        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);
+                    new NameBasedCandidateFilter(new TerminalMockCandidateFilter()));
+
+    private final ListUtil.Filter<Field> notFinalOrStatic =
+            new ListUtil.Filter<Field>() {
+                @Override
+                public boolean isOut(Field object) {
+                    return Modifier.isFinal(object.getModifiers())
+                            || Modifier.isStatic(object.getModifiers());
+                }
+            };
+
+    @Override
+    public boolean processInjection(
+            Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
+        FieldInitializationReport report =
+                initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);
 
         // for each field in the class hierarchy
         boolean injectionOccurred = false;
         Class<?> fieldClass = report.fieldClass();
         Object fieldInstanceNeedingInjection = report.fieldInstance();
         while (fieldClass != Object.class) {
-            injectionOccurred |= injectMockCandidates(fieldClass, fieldInstanceNeedingInjection, newMockSafeHashSet(mockCandidates));
+            injectionOccurred |=
+                    injectMockCandidates(
+                            fieldClass,
+                            fieldInstanceNeedingInjection,
+                            newMockSafeHashSet(mockCandidates));
             fieldClass = fieldClass.getSuperclass();
         }
         return injectionOccurred;
@@ -93,33 +100,42 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
         try {
             return new FieldInitializer(fieldOwner, field).initialize();
         } catch (MockitoException e) {
-            if(e.getCause() instanceof InvocationTargetException) {
+            if (e.getCause() instanceof InvocationTargetException) {
                 Throwable realCause = e.getCause().getCause();
                 throw fieldInitialisationThrewException(field, realCause);
             }
-            throw cannotInitializeForInjectMocksAnnotation(field.getName(),e.getMessage());
+            throw cannotInitializeForInjectMocksAnnotation(field.getName(), e.getMessage());
         }
     }
 
-
-    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Object injectee, Set<Object> mocks) {
+    private boolean injectMockCandidates(
+            Class<?> awaitingInjectionClazz, Object injectee, Set<Object> mocks) {
         boolean injectionOccurred;
-        List<Field> orderedCandidateInjecteeFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);
+        List<Field> orderedCandidateInjecteeFields =
+                orderedInstanceFieldsFrom(awaitingInjectionClazz);
         // pass 1
-        injectionOccurred = injectMockCandidatesOnFields(mocks, injectee, false, orderedCandidateInjecteeFields);
+        injectionOccurred =
+                injectMockCandidatesOnFields(
+                        mocks, injectee, false, orderedCandidateInjecteeFields);
         // pass 2
-        injectionOccurred |= injectMockCandidatesOnFields(mocks, injectee, injectionOccurred, orderedCandidateInjecteeFields);
+        injectionOccurred |=
+                injectMockCandidatesOnFields(
+                        mocks, injectee, injectionOccurred, orderedCandidateInjecteeFields);
         return injectionOccurred;
     }
 
-    private boolean injectMockCandidatesOnFields(Set<Object> mocks,
-                                                 Object injectee,
-                                                 boolean injectionOccurred,
-                                                 List<Field> orderedCandidateInjecteeFields) {
+    private boolean injectMockCandidatesOnFields(
+            Set<Object> mocks,
+            Object injectee,
+            boolean injectionOccurred,
+            List<Field> orderedCandidateInjecteeFields) {
         for (Iterator<Field> it = orderedCandidateInjecteeFields.iterator(); it.hasNext(); ) {
             Field candidateField = it.next();
-            Object injected = mockCandidateFilter.filterCandidate(mocks, candidateField, orderedCandidateInjecteeFields, injectee)
-                                                 .thenInject();
+            Object injected =
+                    mockCandidateFilter
+                            .filterCandidate(
+                                    mocks, candidateField, orderedCandidateInjecteeFields, injectee)
+                            .thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);
diff --git a/src/main/java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java b/src/main/java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java
index 3dc0351..73f3004 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java
@@ -2,20 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
+import static org.mockito.Mockito.withSettings;
+
+import java.lang.reflect.Field;
+import java.util.Set;
+
 import org.mockito.Mockito;
 import org.mockito.Spy;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.FieldReader;
-
-import java.lang.reflect.Field;
-import java.util.Set;
-
-import static org.mockito.Mockito.withSettings;
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
+import org.mockito.plugins.MemberAccessor;
 
 /**
  * Handler for field annotated with &#64;InjectMocks and &#64;Spy.
@@ -27,24 +27,29 @@ import static org.mockito.internal.util.reflection.FieldSetter.setField;
  */
 public class SpyOnInjectedFieldsHandler extends MockInjectionStrategy {
 
+    private final MemberAccessor accessor = Plugins.getMemberAccessor();
+
     @Override
     protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {
         FieldReader fieldReader = new FieldReader(fieldOwner, field);
 
-        // TODO refoctor : code duplicated in SpyAnnotationEngine
-        if(!fieldReader.isNull() && field.isAnnotationPresent(Spy.class)) {
+        // TODO refactor : code duplicated in SpyAnnotationEngine
+        if (!fieldReader.isNull() && field.isAnnotationPresent(Spy.class)) {
             try {
                 Object instance = fieldReader.read();
                 if (MockUtil.isMock(instance)) {
                     // A. instance has been spied earlier
-                    // B. protect against multiple use of MockitoAnnotations.initMocks()
+                    // B. protect against multiple use of MockitoAnnotations.openMocks()
                     Mockito.reset(instance);
                 } else {
-                    Object mock = Mockito.mock(instance.getClass(), withSettings()
-					    .spiedInstance(instance)
-					    .defaultAnswer(Mockito.CALLS_REAL_METHODS)
-					    .name(field.getName()));
-					setField(fieldOwner, field, mock);
+                    Object mock =
+                            Mockito.mock(
+                                    instance.getClass(),
+                                    withSettings()
+                                            .spiedInstance(instance)
+                                            .defaultAnswer(Mockito.CALLS_REAL_METHODS)
+                                            .name(field.getName()));
+                    accessor.set(field, fieldOwner, mock);
                 }
             } catch (Exception e) {
                 throw new MockitoException("Problems initiating spied field " + field.getName(), e);
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
index 454d3be..470a42f 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
@@ -13,6 +13,5 @@ public interface MockCandidateFilter {
             Collection<Object> mocks,
             Field candidateFieldToBeInjected,
             List<Field> allRemainingCandidateFields,
-            Object injectee
-    );
+            Object injectee);
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
index dc50e9d..125b959 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
@@ -18,27 +18,32 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {
         this.next = next;
     }
 
-    public OngoingInjector filterCandidate(final Collection<Object> mocks,
-                                           final Field candidateFieldToBeInjected,
-                                           final List<Field> allRemainingCandidateFields,
-                                           final Object injectee) {
+    @Override
+    public OngoingInjector filterCandidate(
+            final Collection<Object> mocks,
+            final Field candidateFieldToBeInjected,
+            final List<Field> allRemainingCandidateFields,
+            final Object injectee) {
         if (mocks.size() == 1
-                && anotherCandidateMatchesMockName(mocks, candidateFieldToBeInjected, allRemainingCandidateFields)) {
+                && anotherCandidateMatchesMockName(
+                        mocks, candidateFieldToBeInjected, allRemainingCandidateFields)) {
             return OngoingInjector.nop;
         }
 
-        return next.filterCandidate(tooMany(mocks) ? selectMatchingName(mocks, candidateFieldToBeInjected) : mocks,
-                                    candidateFieldToBeInjected,
-                                    allRemainingCandidateFields,
-                                    injectee);
+        return next.filterCandidate(
+                tooMany(mocks) ? selectMatchingName(mocks, candidateFieldToBeInjected) : mocks,
+                candidateFieldToBeInjected,
+                allRemainingCandidateFields,
+                injectee);
     }
 
     private boolean tooMany(Collection<Object> mocks) {
         return mocks.size() > 1;
     }
 
-    private List<Object> selectMatchingName(Collection<Object> mocks, Field candidateFieldToBeInjected) {
-        List<Object> mockNameMatches = new ArrayList<Object>();
+    private List<Object> selectMatchingName(
+            Collection<Object> mocks, Field candidateFieldToBeInjected) {
+        List<Object> mockNameMatches = new ArrayList<>();
         for (Object mock : mocks) {
             if (candidateFieldToBeInjected.getName().equals(getMockName(mock).toString())) {
                 mockNameMatches.add(mock);
@@ -56,9 +61,10 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {
      * whenever we find a field that does match its name with the mock
      * name, we should take that field instead.
      */
-    private boolean anotherCandidateMatchesMockName(final Collection<Object> mocks,
-                                                    final Field candidateFieldToBeInjected,
-                                                    final List<Field> allRemainingCandidateFields) {
+    private boolean anotherCandidateMatchesMockName(
+            final Collection<Object> mocks,
+            final Field candidateFieldToBeInjected,
+            final List<Field> allRemainingCandidateFields) {
         String mockName = getMockName(mocks.iterator().next()).toString();
 
         for (Field otherCandidateField : allRemainingCandidateFields) {
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/OngoingInjector.java b/src/main/java/org/mockito/internal/configuration/injection/filter/OngoingInjector.java
index 4550e1f..a10d041 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/OngoingInjector.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/OngoingInjector.java
@@ -23,9 +23,11 @@ public interface OngoingInjector {
     /**
      * Injector that will do nothing, and will return <code>null</code> as no mocks will be injected
      */
-    OngoingInjector nop = new OngoingInjector() {
-        public Object thenInject() {
-            return null;
-        }
-    };
+    OngoingInjector nop =
+            new OngoingInjector() {
+                @Override
+                public Object thenInject() {
+                    return null;
+                }
+            };
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
index 3a66c7e..ec9dadc 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
@@ -4,14 +4,15 @@
  */
 package org.mockito.internal.configuration.injection.filter;
 
-import org.mockito.internal.util.reflection.BeanPropertySetter;
+import static org.mockito.internal.exceptions.Reporter.cannotInjectDependency;
 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
-import static org.mockito.internal.exceptions.Reporter.cannotInjectDependency;
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.util.reflection.BeanPropertySetter;
+import org.mockito.plugins.MemberAccessor;
 
 /**
  * This node returns an actual injecter which will be either :
@@ -22,28 +23,29 @@ import static org.mockito.internal.util.reflection.FieldSetter.setField;
  * </ul>
  */
 public class TerminalMockCandidateFilter implements MockCandidateFilter {
-    public OngoingInjector filterCandidate(final Collection<Object> mocks,
-                                           final Field candidateFieldToBeInjected,
-                                           final List<Field> allRemainingCandidateFields,
-                                           final Object injectee) {
-        if(mocks.size() == 1) {
+    @Override
+    public OngoingInjector filterCandidate(
+            final Collection<Object> mocks,
+            final Field candidateFieldToBeInjected,
+            final List<Field> allRemainingCandidateFields,
+            final Object injectee) {
+        if (mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
-            return new OngoingInjector() {
-                public Object thenInject() {
-                    try {
-                        if (!new BeanPropertySetter(injectee, candidateFieldToBeInjected).set(matchingMock)) {
-                            setField(injectee, candidateFieldToBeInjected,matchingMock);
-                        }
-                    } catch (RuntimeException e) {
-                        throw cannotInjectDependency(candidateFieldToBeInjected, matchingMock, e);
+            MemberAccessor accessor = Plugins.getMemberAccessor();
+            return () -> {
+                try {
+                    if (!new BeanPropertySetter(injectee, candidateFieldToBeInjected)
+                            .set(matchingMock)) {
+                        accessor.set(candidateFieldToBeInjected, injectee, matchingMock);
                     }
-                    return matchingMock;
+                } catch (RuntimeException | IllegalAccessException e) {
+                    throw cannotInjectDependency(candidateFieldToBeInjected, matchingMock, e);
                 }
+                return matchingMock;
             };
         }
 
         return OngoingInjector.nop;
-
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
index 7284399..9ba0fba 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
@@ -17,17 +17,20 @@ public class TypeBasedCandidateFilter implements MockCandidateFilter {
         this.next = next;
     }
 
-    public OngoingInjector filterCandidate(final Collection<Object> mocks,
-                                           final Field candidateFieldToBeInjected,
-                                           final List<Field> allRemainingCandidateFields,
-                                           final Object injectee) {
-        List<Object> mockTypeMatches = new ArrayList<Object>();
+    @Override
+    public OngoingInjector filterCandidate(
+            final Collection<Object> mocks,
+            final Field candidateFieldToBeInjected,
+            final List<Field> allRemainingCandidateFields,
+            final Object injectee) {
+        List<Object> mockTypeMatches = new ArrayList<>();
         for (Object mock : mocks) {
             if (candidateFieldToBeInjected.getType().isAssignableFrom(mock.getClass())) {
                 mockTypeMatches.add(mock);
             }
         }
 
-        return next.filterCandidate(mockTypeMatches, candidateFieldToBeInjected, allRemainingCandidateFields, injectee);
+        return next.filterCandidate(
+                mockTypeMatches, candidateFieldToBeInjected, allRemainingCandidateFields, injectee);
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java b/src/main/java/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java
index 57d5113..b206f18 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java
@@ -4,10 +4,6 @@
  */
 package org.mockito.internal.configuration.injection.scanner;
 
-import org.mockito.Captor;
-import org.mockito.InjectMocks;
-import org.mockito.Mock;
-
 import static org.mockito.internal.exceptions.Reporter.unsupportedCombinationOfAnnotations;
 
 import java.lang.annotation.Annotation;
@@ -15,6 +11,10 @@ import java.lang.reflect.Field;
 import java.util.HashSet;
 import java.util.Set;
 
+import org.mockito.Captor;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+
 /**
  * Scan field for injection.
  */
@@ -30,7 +30,6 @@ public class InjectMocksScanner {
         this.clazz = clazz;
     }
 
-
     /**
      * Add the fields annotated by @{@link InjectMocks}
      *
@@ -47,7 +46,7 @@ public class InjectMocksScanner {
      */
     @SuppressWarnings("unchecked")
     private Set<Field> scan() {
-        Set<Field> mockDependentFields = new HashSet<Field>();
+        Set<Field> mockDependentFields = new HashSet<>();
         Field[] fields = clazz.getDeclaredFields();
         for (Field field : fields) {
             if (null != field.getAnnotation(InjectMocks.class)) {
@@ -59,10 +58,12 @@ public class InjectMocksScanner {
         return mockDependentFields;
     }
 
-    private static void assertNoAnnotations(Field field, Class<? extends Annotation>... annotations) {
+    private static void assertNoAnnotations(
+            Field field, Class<? extends Annotation>... annotations) {
         for (Class<? extends Annotation> annotation : annotations) {
             if (field.isAnnotationPresent(annotation)) {
-                throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());
+                throw unsupportedCombinationOfAnnotations(
+                        annotation.getSimpleName(), InjectMocks.class.getSimpleName());
             }
         }
     }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/scanner/MockScanner.java b/src/main/java/org/mockito/internal/configuration/injection/scanner/MockScanner.java
index 1d567fe..9798444 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/scanner/MockScanner.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/scanner/MockScanner.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.configuration.injection.scanner;
 
-import org.mockito.Mock;
-import org.mockito.Spy;
-import org.mockito.internal.util.MockUtil;
-import org.mockito.internal.util.reflection.FieldReader;
+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
 
 import java.lang.reflect.Field;
 import java.util.Set;
 
-import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.internal.util.MockUtil;
+import org.mockito.internal.util.reflection.FieldReader;
 
 /**
  * Scan mocks, and prepare them if needed.
@@ -80,7 +80,6 @@ public class MockScanner {
     }
 
     private boolean isMockOrSpy(Object instance) {
-        return MockUtil.isMock(instance)
-                || MockUtil.isSpy(instance);
+        return MockUtil.isMock(instance) || MockUtil.isSpy(instance);
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/DefaultMockitoPlugins.java b/src/main/java/org/mockito/internal/configuration/plugins/DefaultMockitoPlugins.java
index f80e7c4..592f79a 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/DefaultMockitoPlugins.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/DefaultMockitoPlugins.java
@@ -4,44 +4,59 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.mockito.internal.creation.instance.InstantiatorProvider2Adapter;
+import java.util.HashMap;
+import java.util.Map;
 import org.mockito.plugins.AnnotationEngine;
-import org.mockito.plugins.InstantiatorProvider;
+import org.mockito.plugins.DoNotMockEnforcer;
 import org.mockito.plugins.InstantiatorProvider2;
+import org.mockito.plugins.MemberAccessor;
 import org.mockito.plugins.MockMaker;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.plugins.MockitoPlugins;
 import org.mockito.plugins.PluginSwitch;
 import org.mockito.plugins.StackTraceCleanerProvider;
 
-import java.util.HashMap;
-import java.util.Map;
-
 class DefaultMockitoPlugins implements MockitoPlugins {
 
-    private final static Map<String, String> DEFAULT_PLUGINS = new HashMap<String, String>();
+    private static final Map<String, String> DEFAULT_PLUGINS = new HashMap<>();
     static final String INLINE_ALIAS = "mock-maker-inline";
+    static final String PROXY_ALIAS = "mock-maker-proxy";
+    static final String MODULE_ALIAS = "member-accessor-module";
 
     static {
-        //Keep the mapping: plugin interface name -> plugin implementation class name
+        // Keep the mapping: plugin interface name -> plugin implementation class name
         DEFAULT_PLUGINS.put(PluginSwitch.class.getName(), DefaultPluginSwitch.class.getName());
-        DEFAULT_PLUGINS.put(MockMaker.class.getName(), "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
-        DEFAULT_PLUGINS.put(StackTraceCleanerProvider.class.getName(), "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
-        DEFAULT_PLUGINS.put(InstantiatorProvider2.class.getName(), "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
-        DEFAULT_PLUGINS.put(AnnotationEngine.class.getName(), "org.mockito.internal.configuration.InjectingAnnotationEngine");
-        DEFAULT_PLUGINS.put(INLINE_ALIAS, "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
+        DEFAULT_PLUGINS.put(
+                MockMaker.class.getName(),
+                "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
+        DEFAULT_PLUGINS.put(
+                StackTraceCleanerProvider.class.getName(),
+                "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
+        DEFAULT_PLUGINS.put(
+                InstantiatorProvider2.class.getName(),
+                "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
+        DEFAULT_PLUGINS.put(
+                AnnotationEngine.class.getName(),
+                "org.mockito.internal.configuration.InjectingAnnotationEngine");
+        DEFAULT_PLUGINS.put(
+                INLINE_ALIAS, "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
+        DEFAULT_PLUGINS.put(PROXY_ALIAS, "org.mockito.internal.creation.proxy.ProxyMockMaker");
+        DEFAULT_PLUGINS.put(
+                MockitoLogger.class.getName(), "org.mockito.internal.util.ConsoleMockitoLogger");
+        DEFAULT_PLUGINS.put(
+                MemberAccessor.class.getName(),
+                "org.mockito.internal.util.reflection.ReflectionMemberAccessor");
+        DEFAULT_PLUGINS.put(
+                MODULE_ALIAS, "org.mockito.internal.util.reflection.ModuleMemberAccessor");
+        DEFAULT_PLUGINS.put(
+                DoNotMockEnforcer.class.getName(),
+                "org.mockito.internal.configuration.DefaultDoNotMockEnforcer");
     }
 
     @Override
     public <T> T getDefaultPlugin(Class<T> pluginType) {
-        if (pluginType == InstantiatorProvider.class) {
-            //the implementation class is not configured via map so that we can reduce duplication
-            //(ensure that we are adapting the currently configured default implementation for InstantiatorProvider2)
-            String className = DEFAULT_PLUGINS.get(InstantiatorProvider2.class.getName());
-            return pluginType.cast(new InstantiatorProvider2Adapter(create(InstantiatorProvider2.class, className)));
-        } else {
-            String className = DEFAULT_PLUGINS.get(pluginType.getName());
-            return create(pluginType, className);
-        }
+        String className = DEFAULT_PLUGINS.get(pluginType.getName());
+        return create(pluginType, className);
     }
 
     String getDefaultPluginClass(String classOrAlias) {
@@ -54,20 +69,25 @@ class DefaultMockitoPlugins implements MockitoPlugins {
     private <T> T create(Class<T> pluginType, String className) {
         if (className == null) {
             throw new IllegalStateException(
-                "No default implementation for requested Mockito plugin type: " + pluginType.getName() + "\n"
-                    + "Is this a valid Mockito plugin type? If yes, please report this problem to Mockito team.\n"
-                    + "Otherwise, please check if you are passing valid plugin type.\n"
-                    + "Examples of valid plugin types: MockMaker, StackTraceCleanerProvider.");
+                    "No default implementation for requested Mockito plugin type: "
+                            + pluginType.getName()
+                            + "\n"
+                            + "Is this a valid Mockito plugin type? If yes, please report this problem to Mockito team.\n"
+                            + "Otherwise, please check if you are passing valid plugin type.\n"
+                            + "Examples of valid plugin types: MockMaker, StackTraceCleanerProvider.");
         }
         try {
             // Default implementation. Use our own ClassLoader instead of the context
             // ClassLoader, as the default implementation is assumed to be part of
             // Mockito and may not be available via the context ClassLoader.
-            return pluginType.cast(Class.forName(className).newInstance());
+            return pluginType.cast(Class.forName(className).getDeclaredConstructor().newInstance());
         } catch (Exception e) {
-            throw new IllegalStateException("Internal problem occurred, please report it. " +
-                "Mockito is unable to load the default implementation of class that is a part of Mockito distribution. " +
-                "Failed to load " + pluginType, e);
+            throw new IllegalStateException(
+                    "Internal problem occurred, please report it. "
+                            + "Mockito is unable to load the default implementation of class that is a part of Mockito distribution. "
+                            + "Failed to load "
+                            + pluginType,
+                    e);
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java b/src/main/java/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java
index e332cd9..61fded6 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java
@@ -7,6 +7,7 @@ package org.mockito.internal.configuration.plugins;
 import org.mockito.plugins.PluginSwitch;
 
 class DefaultPluginSwitch implements PluginSwitch {
+    @Override
     public boolean isEnabled(String pluginClassName) {
         return true;
     }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginFileReader.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginFileReader.java
index a71a144..c1e2cbb 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginFileReader.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginFileReader.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.mockito.internal.util.io.IOUtil;
-
 import java.io.InputStream;
 
+import org.mockito.internal.util.io.IOUtil;
+
 class PluginFileReader {
 
     String readPluginClass(InputStream input) {
-        for(String line: IOUtil.readLines(input)) {
+        for (String line : IOUtil.readLines(input)) {
             String stripped = stripCommentAndWhitespace(line);
             if (stripped.length() > 0) {
                 return stripped;
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
index 258da72..3ca2ac5 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
@@ -4,13 +4,15 @@
  */
 package org.mockito.internal.configuration.plugins;
 
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.io.IOUtil;
 import org.mockito.plugins.PluginSwitch;
 
-import java.io.InputStream;
-import java.net.URL;
-
 class PluginFinder {
 
     private final PluginSwitch pluginSwitch;
@@ -26,20 +28,47 @@ class PluginFinder {
                 s = resource.openStream();
                 String pluginClassName = new PluginFileReader().readPluginClass(s);
                 if (pluginClassName == null) {
-                    //For backwards compatibility
-                    //If the resource does not have plugin class name we're ignoring it
+                    // For backwards compatibility
+                    // If the resource does not have plugin class name we're ignoring it
                     continue;
                 }
                 if (!pluginSwitch.isEnabled(pluginClassName)) {
                     continue;
                 }
                 return pluginClassName;
-            } catch(Exception e) {
-                throw new MockitoException("Problems reading plugin implementation from: " + resource, e);
+            } catch (Exception e) {
+                throw new MockitoException(
+                        "Problems reading plugin implementation from: " + resource, e);
             } finally {
                 IOUtil.closeQuietly(s);
             }
         }
         return null;
     }
+
+    List<String> findPluginClasses(Iterable<URL> resources) {
+        List<String> pluginClassNames = new ArrayList<>();
+        for (URL resource : resources) {
+            InputStream s = null;
+            try {
+                s = resource.openStream();
+                String pluginClassName = new PluginFileReader().readPluginClass(s);
+                if (pluginClassName == null) {
+                    // For backwards compatibility
+                    // If the resource does not have plugin class name we're ignoring it
+                    continue;
+                }
+                if (!pluginSwitch.isEnabled(pluginClassName)) {
+                    continue;
+                }
+                pluginClassNames.add(pluginClassName);
+            } catch (Exception e) {
+                throw new MockitoException(
+                        "Problems reading plugin implementation from: " + resource, e);
+            } finally {
+                IOUtil.closeQuietly(s);
+            }
+        }
+        return pluginClassNames;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
index 0e28d91..a88f0cc 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
@@ -4,20 +4,23 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.mockito.internal.util.collections.Iterables;
-import org.mockito.plugins.PluginSwitch;
-
 import java.io.IOException;
 import java.net.URL;
+import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.List;
+import java.util.Set;
+
+import org.mockito.internal.util.collections.Iterables;
+import org.mockito.plugins.PluginSwitch;
 
 class PluginInitializer {
 
     private final PluginSwitch pluginSwitch;
-    private final String alias;
+    private final Set<String> alias;
     private final DefaultMockitoPlugins plugins;
 
-    PluginInitializer(PluginSwitch pluginSwitch, String alias, DefaultMockitoPlugins plugins) {
+    PluginInitializer(PluginSwitch pluginSwitch, Set<String> alias, DefaultMockitoPlugins plugins) {
         this.pluginSwitch = pluginSwitch;
         this.alias = alias;
         this.plugins = plugins;
@@ -40,19 +43,52 @@ class PluginInitializer {
         }
 
         try {
-            String classOrAlias = new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));
+            String classOrAlias =
+                    new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));
             if (classOrAlias != null) {
-                if (classOrAlias.equals(alias)) {
-                    classOrAlias = plugins.getDefaultPluginClass(alias);
+                if (alias.contains(classOrAlias)) {
+                    classOrAlias = plugins.getDefaultPluginClass(classOrAlias);
                 }
                 Class<?> pluginClass = loader.loadClass(classOrAlias);
-                Object plugin = pluginClass.newInstance();
+                Object plugin = pluginClass.getDeclaredConstructor().newInstance();
                 return service.cast(plugin);
             }
             return null;
         } catch (Exception e) {
             throw new IllegalStateException(
-                "Failed to load " + service + " implementation declared in " + resources, e);
+                    "Failed to load " + service + " implementation declared in " + resources, e);
+        }
+    }
+
+    public <T> List<T> loadImpls(Class<T> service) {
+        ClassLoader loader = Thread.currentThread().getContextClassLoader();
+        if (loader == null) {
+            loader = ClassLoader.getSystemClassLoader();
+        }
+        Enumeration<URL> resources;
+        try {
+            resources = loader.getResources("mockito-extensions/" + service.getName());
+        } catch (IOException e) {
+            throw new IllegalStateException("Failed to load " + service, e);
+        }
+
+        try {
+            List<String> classesOrAliases =
+                    new PluginFinder(pluginSwitch)
+                            .findPluginClasses(Iterables.toIterable(resources));
+            List<T> impls = new ArrayList<>();
+            for (String classOrAlias : classesOrAliases) {
+                if (alias.contains(classOrAlias)) {
+                    classOrAlias = plugins.getDefaultPluginClass(classOrAlias);
+                }
+                Class<?> pluginClass = loader.loadClass(classOrAlias);
+                Object plugin = pluginClass.getDeclaredConstructor().newInstance();
+                impls.add(service.cast(plugin));
+            }
+            return impls;
+        } catch (Exception e) {
+            throw new IllegalStateException(
+                    "Failed to load " + service + " implementation declared in " + resources, e);
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
index a230d0c..3f33dff 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
@@ -4,11 +4,15 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.mockito.plugins.PluginSwitch;
-
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import org.mockito.plugins.PluginSwitch;
 
 class PluginLoader {
 
@@ -21,19 +25,25 @@ class PluginLoader {
     }
 
     PluginLoader(PluginSwitch pluginSwitch) {
-        this(new DefaultMockitoPlugins(), new PluginInitializer(pluginSwitch, null, new DefaultMockitoPlugins()));
+        this(
+                new DefaultMockitoPlugins(),
+                new PluginInitializer(
+                        pluginSwitch, Collections.emptySet(), new DefaultMockitoPlugins()));
     }
 
     /**
-     * @deprecated Let's avoid adding more aliases. It complicates the API.
-     * Instead of an alias, we can use fully qualified class name of the alternative implementation.
-     * <p>
      * Adds an alias for a class name to this plugin loader. Instead of the fully qualified type name,
-     * the alias can be used as a convenience name for a known plugin.
+     * the alias can be used as a convenience name for a known plugin. This avoids exposing API that is
+     * explicitly marked as <i>internal</i> through the package name. Without such aliases, we would need
+     * to make internal packages part of the API, not by code but by configuration file.
      */
-    @Deprecated
-    PluginLoader(PluginSwitch pluginSwitch, String alias) {
-        this(new DefaultMockitoPlugins(), new PluginInitializer(pluginSwitch, alias, new DefaultMockitoPlugins()));
+    PluginLoader(PluginSwitch pluginSwitch, String... alias) {
+        this(
+                new DefaultMockitoPlugins(),
+                new PluginInitializer(
+                        pluginSwitch,
+                        new HashSet<>(Arrays.asList(alias)),
+                        new DefaultMockitoPlugins()));
     }
 
     /**
@@ -52,9 +62,11 @@ class PluginLoader {
      * @return An object of either {@code preferredPluginType} or {@code alternatePluginType}
      */
     @SuppressWarnings("unchecked")
-    <PreferredType, AlternateType> Object loadPlugin(final Class<PreferredType> preferredPluginType, final Class<AlternateType> alternatePluginType) {
+    <PreferredT, AlternateType> Object loadPlugin(
+            final Class<PreferredT> preferredPluginType,
+            final Class<AlternateType> alternatePluginType) {
         try {
-            PreferredType preferredPlugin = initializer.loadImpl(preferredPluginType);
+            PreferredT preferredPlugin = initializer.loadImpl(preferredPluginType);
             if (preferredPlugin != null) {
                 return preferredPlugin;
             } else if (alternatePluginType != null) {
@@ -66,14 +78,50 @@ class PluginLoader {
 
             return plugins.getDefaultPlugin(preferredPluginType);
         } catch (final Throwable t) {
-            return Proxy.newProxyInstance(preferredPluginType.getClassLoader(),
-                new Class<?>[]{preferredPluginType},
-                new InvocationHandler() {
-                    @Override
-                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                        throw new IllegalStateException("Could not initialize plugin: " + preferredPluginType + " (alternate: " + alternatePluginType + ")", t);
-                    }
-                });
+            return Proxy.newProxyInstance(
+                    preferredPluginType.getClassLoader(),
+                    new Class<?>[] {preferredPluginType},
+                    new InvocationHandler() {
+                        @Override
+                        public Object invoke(Object proxy, Method method, Object[] args)
+                                throws Throwable {
+                            throw new IllegalStateException(
+                                    "Could not initialize plugin: "
+                                            + preferredPluginType
+                                            + " (alternate: "
+                                            + alternatePluginType
+                                            + ")",
+                                    t);
+                        }
+                    });
+        }
+    }
+
+    /**
+     * Scans the classpath for given {@code pluginType} and returns a list of its instances.
+     *
+     * @return An list of {@code pluginType} or an empty list if none was found.
+     */
+    @SuppressWarnings("unchecked")
+    <T> List<T> loadPlugins(final Class<T> pluginType) {
+        try {
+            return initializer.loadImpls(pluginType);
+        } catch (final Throwable t) {
+            return Collections.singletonList(
+                    (T)
+                            Proxy.newProxyInstance(
+                                    pluginType.getClassLoader(),
+                                    new Class<?>[] {pluginType},
+                                    new InvocationHandler() {
+                                        @Override
+                                        public Object invoke(
+                                                Object proxy, Method method, Object[] args)
+                                                throws Throwable {
+                                            throw new IllegalStateException(
+                                                    "Could not initialize plugin: " + pluginType,
+                                                    t);
+                                        }
+                                    }));
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
index 02e5d66..01e89d2 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
@@ -4,44 +4,60 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.mockito.internal.creation.instance.InstantiatorProviderAdapter;
+import java.util.List;
 import org.mockito.plugins.AnnotationEngine;
-import org.mockito.plugins.InstantiatorProvider;
+import org.mockito.plugins.DoNotMockEnforcer;
 import org.mockito.plugins.InstantiatorProvider2;
+import org.mockito.plugins.MemberAccessor;
 import org.mockito.plugins.MockMaker;
+import org.mockito.plugins.MockResolver;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.plugins.PluginSwitch;
 import org.mockito.plugins.StackTraceCleanerProvider;
 
 class PluginRegistry {
 
-    private final PluginSwitch pluginSwitch = new PluginLoader(new DefaultPluginSwitch())
-            .loadPlugin(PluginSwitch.class);
+    private final PluginSwitch pluginSwitch =
+            new PluginLoader(new DefaultPluginSwitch()).loadPlugin(PluginSwitch.class);
 
-    private final MockMaker mockMaker = new PluginLoader(pluginSwitch, DefaultMockitoPlugins.INLINE_ALIAS)
-            .loadPlugin(MockMaker.class);
+    private final MockMaker mockMaker =
+            new PluginLoader(
+                            pluginSwitch,
+                            DefaultMockitoPlugins.INLINE_ALIAS,
+                            DefaultMockitoPlugins.PROXY_ALIAS)
+                    .loadPlugin(MockMaker.class);
 
-    private final StackTraceCleanerProvider stackTraceCleanerProvider = new PluginLoader(pluginSwitch)
-            .loadPlugin(StackTraceCleanerProvider.class);
+    private final MemberAccessor memberAccessor =
+            new PluginLoader(pluginSwitch, DefaultMockitoPlugins.MODULE_ALIAS)
+                    .loadPlugin(MemberAccessor.class);
+
+    private final StackTraceCleanerProvider stackTraceCleanerProvider =
+            new PluginLoader(pluginSwitch).loadPlugin(StackTraceCleanerProvider.class);
 
     private final InstantiatorProvider2 instantiatorProvider;
 
-    private AnnotationEngine annotationEngine = new PluginLoader(pluginSwitch)
-            .loadPlugin(AnnotationEngine.class);
+    private final AnnotationEngine annotationEngine =
+            new PluginLoader(pluginSwitch).loadPlugin(AnnotationEngine.class);
+
+    private final MockitoLogger mockitoLogger =
+            new PluginLoader(pluginSwitch).loadPlugin(MockitoLogger.class);
+
+    private final List<MockResolver> mockResolvers =
+            new PluginLoader(pluginSwitch).loadPlugins(MockResolver.class);
+
+    private final DoNotMockEnforcer doNotMockEnforcer =
+            new PluginLoader(pluginSwitch).loadPlugin(DoNotMockEnforcer.class);
 
     PluginRegistry() {
-        Object impl = new PluginLoader(pluginSwitch).loadPlugin(InstantiatorProvider2.class, InstantiatorProvider.class);
-        if (impl instanceof InstantiatorProvider) {
-            instantiatorProvider = new InstantiatorProviderAdapter((InstantiatorProvider) impl);
-        } else {
-            instantiatorProvider = (InstantiatorProvider2) impl;
-        }
+        instantiatorProvider =
+                new PluginLoader(pluginSwitch).loadPlugin(InstantiatorProvider2.class);
     }
 
     /**
      * The implementation of the stack trace cleaner
      */
     StackTraceCleanerProvider getStackTraceCleanerProvider() {
-        //TODO we should throw some sensible exception if this is null.
+        // TODO we should throw some sensible exception if this is null.
         return stackTraceCleanerProvider;
     }
 
@@ -55,6 +71,16 @@ class PluginRegistry {
         return mockMaker;
     }
 
+    /**
+     * Returns the implementation of the member accessor available for the current runtime.
+     *
+     * <p>Returns {@link org.mockito.internal.util.reflection.ReflectionMemberAccessor} if no
+     * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>
+     */
+    MemberAccessor getMemberAccessor() {
+        return memberAccessor;
+    }
+
     /**
      * Returns the instantiator provider available for the current runtime.
      *
@@ -75,4 +101,33 @@ class PluginRegistry {
     AnnotationEngine getAnnotationEngine() {
         return annotationEngine;
     }
+
+    /**
+     * Returns the logger available for the current runtime.
+     *
+     * <p>Returns {@link org.mockito.internal.util.ConsoleMockitoLogger} if no
+     * {@link org.mockito.plugins.MockitoLogger} extension exists or is visible in the current classpath.</p>
+     */
+    MockitoLogger getMockitoLogger() {
+        return mockitoLogger;
+    }
+
+    /**
+     * Returns the DoNotMock enforce for the current runtime.
+     *
+     * <p> Returns {@link org.mockito.internal.configuration.DefaultDoNotMockEnforcer} if no
+     * {@link DoNotMockEnforcer} extension exists or is visible in the current classpath.</p>
+     */
+    DoNotMockEnforcer getDoNotMockEnforcer() {
+        return doNotMockEnforcer;
+    }
+
+    /**
+     * Returns a list of available mock resolvers if any.
+     *
+     * @return A list of available mock resolvers or an empty list if none are registered.
+     */
+    List<MockResolver> getMockResolvers() {
+        return mockResolvers;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java b/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
index f65fe89..20f6dc7 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
@@ -4,16 +4,20 @@
  */
 package org.mockito.internal.configuration.plugins;
 
+import org.mockito.DoNotMock;
+import java.util.List;
 import org.mockito.plugins.AnnotationEngine;
+import org.mockito.plugins.DoNotMockEnforcer;
 import org.mockito.plugins.InstantiatorProvider2;
+import org.mockito.plugins.MemberAccessor;
 import org.mockito.plugins.MockMaker;
+import org.mockito.plugins.MockResolver;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.plugins.MockitoPlugins;
 import org.mockito.plugins.StackTraceCleanerProvider;
 
-/**
- * Access to Mockito behavior that can be reconfigured by plugins
- */
-public class Plugins {
+/** Access to Mockito behavior that can be reconfigured by plugins */
+public final class Plugins {
 
     private static final PluginRegistry registry = new PluginRegistry();
 
@@ -34,6 +38,16 @@ public class Plugins {
         return registry.getMockMaker();
     }
 
+    /**
+     * Returns the implementation of the member accessor available for the current runtime.
+     *
+     * <p>Returns default member accessor if no
+     * {@link org.mockito.plugins.MemberAccessor} extension exists or is visible in the current classpath.</p>
+     */
+    public static MemberAccessor getMemberAccessor() {
+        return registry.getMemberAccessor();
+    }
+
     /**
      * Returns the instantiator provider available for the current runtime.
      *
@@ -42,7 +56,7 @@ public class Plugins {
      * current classpath.</p>
      */
     public static InstantiatorProvider2 getInstantiatorProvider() {
-      return registry.getInstantiatorProvider();
+        return registry.getInstantiatorProvider();
     }
 
     /**
@@ -55,10 +69,41 @@ public class Plugins {
         return registry.getAnnotationEngine();
     }
 
+    /**
+     * Returns the logger available for the current runtime.
+     *
+     * <p>Returns {@link org.mockito.internal.util.ConsoleMockitoLogger} if no
+     * {@link org.mockito.plugins.MockitoLogger} extension exists or is visible in the current classpath.</p>
+     */
+    public static MockitoLogger getMockitoLogger() {
+        return registry.getMockitoLogger();
+    }
+
+    /**
+     * Returns a list of available mock resolvers if any.
+     *
+     * @return A list of available mock resolvers or an empty list if none are registered.
+     */
+    public static List<MockResolver> getMockResolvers() {
+        return registry.getMockResolvers();
+    }
+
     /**
      * @return instance of mockito plugins type
      */
     public static MockitoPlugins getPlugins() {
         return new DefaultMockitoPlugins();
     }
+
+    /**
+     * Returns the {@link DoNotMock} enforcer available for the current runtime.
+     *
+     * <p> Returns {@link org.mockito.internal.configuration.DefaultDoNotMockEnforcer} if no
+     * {@link DoNotMockEnforcer} extension exists or is visible in the current classpath.</p>
+     */
+    public static DoNotMockEnforcer getDoNotMockEnforcer() {
+        return registry.getDoNotMockEnforcer();
+    }
+
+    private Plugins() {}
 }
diff --git a/src/main/java/org/mockito/internal/creation/DelegatingMethod.java b/src/main/java/org/mockito/internal/creation/DelegatingMethod.java
index 0844471..bb947ba 100644
--- a/src/main/java/org/mockito/internal/creation/DelegatingMethod.java
+++ b/src/main/java/org/mockito/internal/creation/DelegatingMethod.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.creation;
 
-import org.mockito.internal.invocation.MockitoMethod;
-
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
+import org.mockito.internal.invocation.MockitoMethod;
+
 public class DelegatingMethod implements MockitoMethod {
 
     private final Method method;
@@ -20,30 +20,37 @@ public class DelegatingMethod implements MockitoMethod {
         this.parameterTypes = SuspendMethod.trimSuspendParameterTypes(method.getParameterTypes());
     }
 
+    @Override
     public Class<?>[] getExceptionTypes() {
         return method.getExceptionTypes();
     }
 
+    @Override
     public Method getJavaMethod() {
         return method;
     }
 
+    @Override
     public String getName() {
         return method.getName();
     }
 
+    @Override
     public Class<?>[] getParameterTypes() {
         return parameterTypes;
     }
 
+    @Override
     public Class<?> getReturnType() {
         return method.getReturnType();
     }
 
+    @Override
     public boolean isVarArgs() {
         return method.isVarArgs();
     }
 
+    @Override
     public boolean isAbstract() {
         return (method.getModifiers() & Modifier.ABSTRACT) != 0;
     }
diff --git a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
index ca67730..3aa746c 100644
--- a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
+++ b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
@@ -4,36 +4,40 @@
  */
 package org.mockito.internal.creation;
 
+import static java.util.Arrays.asList;
+
+import static org.mockito.internal.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter;
+import static org.mockito.internal.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces;
+import static org.mockito.internal.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters;
+import static org.mockito.internal.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface;
+import static org.mockito.internal.exceptions.Reporter.methodDoesNotAcceptParameter;
+import static org.mockito.internal.exceptions.Reporter.requiresAtLeastOneListener;
+import static org.mockito.internal.util.collections.Sets.newSet;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.MockSettings;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.debugging.VerboseMockInvocationLogger;
 import org.mockito.internal.util.Checks;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockNameImpl;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockito.listeners.VerificationStartedListener;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
 import org.mockito.stubbing.Answer;
 
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import static org.mockito.internal.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter;
-import static org.mockito.internal.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces;
-import static org.mockito.internal.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters;
-import static org.mockito.internal.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface;
-import static org.mockito.internal.exceptions.Reporter.invocationListenersRequiresAtLeastOneListener;
-import static org.mockito.internal.exceptions.Reporter.methodDoesNotAcceptParameter;
-import static org.mockito.internal.util.collections.Sets.newSet;
-
 @SuppressWarnings("unchecked")
-public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {
+public class MockSettingsImpl<T> extends CreationSettings<T>
+        implements MockSettings, MockCreationSettings<T> {
 
     private static final long serialVersionUID = 4475297236197939569L;
     private boolean useConstructor;
@@ -117,9 +121,10 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
 
     @Override
     public MockSettings useConstructor(Object... constructorArgs) {
-        Checks.checkNotNull(constructorArgs,
-            "constructorArgs",
-            "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
+        Checks.checkNotNull(
+                constructorArgs,
+                "constructorArgs",
+                "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
         this.useConstructor = true;
         this.constructorArgs = constructorArgs;
         return this;
@@ -152,9 +157,9 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         if (outerClassInstance == null) {
             return constructorArgs;
         }
-        List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
+        List<Object> resultArgs = new ArrayList<>(constructorArgs.length + 1);
         resultArgs.add(outerClassInstance);
-        resultArgs.addAll(Arrays.asList(constructorArgs));
+        resultArgs.addAll(asList(constructorArgs));
         return resultArgs.toArray(new Object[constructorArgs.length + 1]);
     }
 
@@ -173,17 +178,23 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
 
     @Override
     public MockSettings invocationListeners(InvocationListener... listeners) {
-        if (listeners == null || listeners.length == 0) {
-            throw invocationListenersRequiresAtLeastOneListener();
-        }
         addListeners(listeners, invocationListeners, "invocationListeners");
         return this;
     }
 
-    private static <T> void addListeners(T[] listeners, List<T> container, String method) {
+    @Override
+    public MockSettings stubbingLookupListeners(StubbingLookupListener... listeners) {
+        addListeners(listeners, stubbingLookupListeners, "stubbingLookupListeners");
+        return this;
+    }
+
+    static <T> void addListeners(T[] listeners, List<T> container, String method) {
         if (listeners == null) {
             throw methodDoesNotAcceptParameter(method, "null vararg array.");
         }
+        if (listeners.length == 0) {
+            throw requiresAtLeastOneListener(method);
+        }
         for (T listener : listeners) {
             if (listener == null) {
                 throw methodDoesNotAcceptParameter(method, "null listeners.");
@@ -207,13 +218,8 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return false;
     }
 
-    @Override
-    public List<InvocationListener> getInvocationListeners() {
-        return this.invocationListeners;
-    }
-
     public boolean hasInvocationListeners() {
-        return !invocationListeners.isEmpty();
+        return !getInvocationListeners().isEmpty();
     }
 
     @Override
@@ -222,8 +228,13 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
     }
 
     @Override
-    public <T> MockCreationSettings<T> build(Class<T> typeToMock) {
-        return validatedSettings(typeToMock, (CreationSettings<T>) this);
+    public <T2> MockCreationSettings<T2> build(Class<T2> typeToMock) {
+        return validatedSettings(typeToMock, (CreationSettings<T2>) this);
+    }
+
+    @Override
+    public <T2> MockCreationSettings<T2> buildStatic(Class<T2> classToMock) {
+        return validatedStaticSettings(classToMock, (CreationSettings<T2>) this);
     }
 
     @Override
@@ -232,34 +243,56 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return this;
     }
 
-    private static <T> CreationSettings<T> validatedSettings(Class<T> typeToMock, CreationSettings<T> source) {
+    private static <T> CreationSettings<T> validatedSettings(
+            Class<T> typeToMock, CreationSettings<T> source) {
         MockCreationValidator validator = new MockCreationValidator();
 
         validator.validateType(typeToMock);
         validator.validateExtraInterfaces(typeToMock, source.getExtraInterfaces());
         validator.validateMockedType(typeToMock, source.getSpiedInstance());
 
-        //TODO SF - add this validation and also add missing coverage
-//        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());
+        // TODO SF - add this validation and also add missing coverage
+        //        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());
 
         validator.validateConstructorUse(source.isUsingConstructor(), source.getSerializableMode());
 
-        //TODO SF - I don't think we really need CreationSettings type
-        //TODO do we really need to copy the entire settings every time we create mock object? it does not seem necessary.
+        // TODO SF - I don't think we really need CreationSettings type
+        // TODO do we really need to copy the entire settings every time we create mock object? it
+        // does not seem necessary.
         CreationSettings<T> settings = new CreationSettings<T>(source);
-        settings.setMockName(new MockNameImpl(source.getName(), typeToMock));
+        settings.setMockName(new MockNameImpl(source.getName(), typeToMock, false));
         settings.setTypeToMock(typeToMock);
         settings.setExtraInterfaces(prepareExtraInterfaces(source));
         return settings;
     }
 
+    private static <T> CreationSettings<T> validatedStaticSettings(
+            Class<T> classToMock, CreationSettings<T> source) {
+
+        if (classToMock.isPrimitive()) {
+            throw new MockitoException(
+                    "Cannot create static mock of primitive type " + classToMock);
+        }
+        if (!source.getExtraInterfaces().isEmpty()) {
+            throw new MockitoException(
+                    "Cannot specify additional interfaces for static mock of " + classToMock);
+        }
+        if (source.getSpiedInstance() != null) {
+            throw new MockitoException(
+                    "Cannot specify spied instance for static mock of " + classToMock);
+        }
+
+        CreationSettings<T> settings = new CreationSettings<T>(source);
+        settings.setMockName(new MockNameImpl(source.getName(), classToMock, true));
+        settings.setTypeToMock(classToMock);
+        return settings;
+    }
+
     private static Set<Class<?>> prepareExtraInterfaces(CreationSettings settings) {
-        Set<Class<?>> interfaces = new HashSet<Class<?>>(settings.getExtraInterfaces());
-        if(settings.isSerializable()) {
+        Set<Class<?>> interfaces = new HashSet<>(settings.getExtraInterfaces());
+        if (settings.isSerializable()) {
             interfaces.add(Serializable.class);
         }
         return interfaces;
     }
-
 }
-
diff --git a/src/main/java/org/mockito/internal/creation/SuspendMethod.java b/src/main/java/org/mockito/internal/creation/SuspendMethod.java
index 42ceac6..1bb6e0a 100644
--- a/src/main/java/org/mockito/internal/creation/SuspendMethod.java
+++ b/src/main/java/org/mockito/internal/creation/SuspendMethod.java
@@ -10,14 +10,16 @@ import java.util.Arrays;
  * Utilities for Kotlin Continuation-Passing-Style suspending function, detecting and trimming last hidden parameter.
  * See <a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#continuation-passing-style">Design docs for details</a>.
  */
-public class SuspendMethod {
-    private static final String KOTLIN_EXPERIMENTAL_CONTINUATION = "kotlin.coroutines.experimental.Continuation";
+public final class SuspendMethod {
+    private static final String KOTLIN_EXPERIMENTAL_CONTINUATION =
+            "kotlin.coroutines.experimental.Continuation";
     private static final String KOTLIN_CONTINUATION = "kotlin.coroutines.Continuation";
 
     public static Class<?>[] trimSuspendParameterTypes(Class<?>[] parameterTypes) {
         int n = parameterTypes.length;
-        if (n > 0 && isContinuationType(parameterTypes[n - 1]))
+        if (n > 0 && isContinuationType(parameterTypes[n - 1])) {
             return Arrays.copyOf(parameterTypes, n - 1);
+        }
         return parameterTypes;
     }
 
@@ -25,4 +27,6 @@ public class SuspendMethod {
         String name = parameterType.getName();
         return name.equals(KOTLIN_CONTINUATION) || name.equals(KOTLIN_EXPERIMENTAL_CONTINUATION);
     }
+
+    private SuspendMethod() {}
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java
index f63731c..02e8961 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java
@@ -2,10 +2,25 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.creation.bytebuddy;
 
-import org.mockito.Incubating;
+import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamClass;
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
 import org.mockito.exceptions.base.MockitoSerializationIssue;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.settings.CreationSettings;
@@ -13,16 +28,7 @@ import org.mockito.internal.util.MockUtil;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
-
-import java.io.*;
-import java.lang.reflect.Field;
-import java.util.Set;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
-import static org.mockito.internal.util.StringUtil.join;
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
+import org.mockito.plugins.MemberAccessor;
 
 /**
  * This is responsible for serializing a mock, it is enabled if the mock is implementing {@link Serializable}.
@@ -51,7 +57,6 @@ import static org.mockito.internal.util.reflection.FieldSetter.setField;
  * @author Brice Dutheil
  * @since 1.10.0
  */
-@Incubating
 class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
     private static final long serialVersionUID = 7411152578314420778L;
     private static final String MOCKITO_PROXY_MARKER = "ByteBuddyMockitoProxyMarker";
@@ -115,12 +120,16 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
             return new CrossClassLoaderSerializationProxy(mockitoMock);
         } catch (IOException ioe) {
             MockName mockName = MockUtil.getMockName(mockitoMock);
-            String mockedType = MockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();
-            throw new MockitoSerializationIssue(join(
-                    "The mock '" + mockName + "' of type '" + mockedType + "'",
-                    "The Java Standard Serialization reported an '" + ioe.getClass().getSimpleName() + "' saying :",
-                    "  " + ioe.getMessage()
-            ), ioe);
+            String mockedType =
+                    MockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();
+            throw new MockitoSerializationIssue(
+                    join(
+                            "The mock '" + mockName + "' of type '" + mockedType + "'",
+                            "The Java Standard Serialization reported an '"
+                                    + ioe.getClass().getSimpleName()
+                                    + "' saying :",
+                            "  " + ioe.getMessage()),
+                    ioe);
         } finally {
             // unmark
             mockReplacementCompleted();
@@ -128,17 +137,14 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
         }
     }
 
-
     private void mockReplacementCompleted() {
         instanceLocalCurrentlySerializingFlag = false;
     }
 
-
     private void mockReplacementStarted() {
         instanceLocalCurrentlySerializingFlag = true;
     }
 
-
     private boolean mockIsCurrentlyBeingReplaced() {
         return instanceLocalCurrentlySerializingFlag;
     }
@@ -193,10 +199,12 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
          * @return A deserialized instance of the Mockito mock.
          * @throws java.io.ObjectStreamException
          */
+        @SuppressWarnings("BanSerializableRead")
         private Object readResolve() throws ObjectStreamException {
             try {
                 ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);
-                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);
+                ObjectInputStream objectInputStream =
+                        new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);
 
                 Object deserializedMock = objectInputStream.readObject();
 
@@ -205,22 +213,25 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
 
                 return deserializedMock;
             } catch (IOException ioe) {
-                throw new MockitoSerializationIssue(join(
-                        "Mockito mock cannot be deserialized to a mock of '" + typeToMock.getCanonicalName() + "'. The error was :",
-                        "  " + ioe.getMessage(),
-                        "If you are unsure what is the reason of this exception, feel free to contact us on the mailing list."
-                ), ioe);
+                throw new MockitoSerializationIssue(
+                        join(
+                                "Mockito mock cannot be deserialized to a mock of '"
+                                        + typeToMock.getCanonicalName()
+                                        + "'. The error was :",
+                                "  " + ioe.getMessage(),
+                                "If you are unsure what is the reason of this exception, feel free to contact us on the mailing list."),
+                        ioe);
             } catch (ClassNotFoundException cce) {
-                throw new MockitoSerializationIssue(join(
-                        "A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :",
-                        "  " + cce.getMessage(),
-                        "If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list."
-                ), cce);
+                throw new MockitoSerializationIssue(
+                        join(
+                                "A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :",
+                                "  " + cce.getMessage(),
+                                "If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list."),
+                        cce);
             }
         }
     }
 
-
     /**
      * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.
      * <p/>
@@ -241,7 +252,9 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
         private final Class<?> typeToMock;
         private final Set<Class<?>> extraInterfaces;
 
-        public MockitoMockObjectInputStream(InputStream in, Class<?> typeToMock, Set<Class<?>> extraInterfaces) throws IOException {
+        public MockitoMockObjectInputStream(
+                InputStream in, Class<?> typeToMock, Set<Class<?>> extraInterfaces)
+                throws IOException {
             super(in);
             this.typeToMock = typeToMock;
             this.extraInterfaces = extraInterfaces;
@@ -261,7 +274,9 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
          * @throws ClassNotFoundException
          */
         @Override
-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
+        @SuppressWarnings("BanSerializableRead")
+        protected Class<?> resolveClass(ObjectStreamClass desc)
+                throws IOException, ClassNotFoundException {
             if (notMarkedAsAMockitoMock(readObject())) {
                 return super.resolveClass(desc);
             }
@@ -269,20 +284,24 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
             // create the Mockito mock class before it can even be deserialized
             try {
                 @SuppressWarnings("unchecked")
-                Class<?> proxyClass = ((ClassCreatingMockMaker) Plugins.getMockMaker()).createMockType(
-                        new CreationSettings()
-                                .setTypeToMock(typeToMock)
-                                .setExtraInterfaces(extraInterfaces)
-                                .setSerializableMode(SerializableMode.ACROSS_CLASSLOADERS));
+                Class<?> proxyClass =
+                        ((ClassCreatingMockMaker) Plugins.getMockMaker())
+                                .createMockType(
+                                        new CreationSettings()
+                                                .setTypeToMock(typeToMock)
+                                                .setExtraInterfaces(extraInterfaces)
+                                                .setSerializableMode(
+                                                        SerializableMode.ACROSS_CLASSLOADERS));
 
                 hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
                 return proxyClass;
             } catch (ClassCastException cce) {
-                throw new MockitoSerializationIssue(join(
-                        "A Byte Buddy-generated mock cannot be deserialized into a non-Byte Buddy generated mock class",
-                        "",
-                        "The mock maker in use was: " + Plugins.getMockMaker().getClass()
-                ), cce);
+                throw new MockitoSerializationIssue(
+                        join(
+                                "A Byte Buddy-generated mock cannot be deserialized into a non-Byte Buddy generated mock class",
+                                "",
+                                "The mock maker in use was: " + Plugins.getMockMaker().getClass()),
+                        cce);
             }
         }
 
@@ -304,17 +323,25 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
          * @param proxyClass   The proxy class whose name will be applied.
          * @throws java.io.InvalidObjectException
          */
-        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {
+        private void hackClassNameToMatchNewlyCreatedClass(
+                ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {
             try {
+                MemberAccessor accessor = Plugins.getMemberAccessor();
                 Field classNameField = descInstance.getClass().getDeclaredField("name");
-                setField(descInstance, classNameField,proxyClass.getCanonicalName());
+                try {
+                    accessor.set(classNameField, descInstance, proxyClass.getCanonicalName());
+                } catch (IllegalAccessException e) {
+                    throw new MockitoSerializationIssue(
+                            "Access to " + classNameField + " was denied", e);
+                }
             } catch (NoSuchFieldException nsfe) {
-                throw new MockitoSerializationIssue(join(
-                        "Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
-                        "this is definitely a bug in our code as it means the JDK team changed a few internal things.",
-                        "",
-                        "Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."
-                ), nsfe);
+                throw new MockitoSerializationIssue(
+                        join(
+                                "Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
+                                "this is definitely a bug in our code as it means the JDK team changed a few internal things.",
+                                "",
+                                "Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."),
+                        nsfe);
             }
         }
 
@@ -329,7 +356,6 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
         }
     }
 
-
     /**
      * Special Mockito aware <code>ObjectOutputStream</code>.
      * <p/>
@@ -375,7 +401,6 @@ class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
         }
     }
 
-
     /**
      * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an
      * <code>ObjectOutputStream</code>.
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
index 3b124dc..f6cba29 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
@@ -4,10 +4,14 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import org.mockito.Incubating;
+import org.mockito.MockedConstruction;
+import org.mockito.internal.exceptions.Reporter;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
+import java.util.Optional;
+import java.util.function.Function;
+
 /**
  * ByteBuddy MockMaker.
  *
@@ -18,31 +22,70 @@ import org.mockito.mock.MockCreationSettings;
  * The programmatic API could look like {@code mock(Final.class, withSettings().finalClasses())}.
  */
 public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
-    private ClassCreatingMockMaker defaultByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
+    private final SubclassByteBuddyMockMaker subclassByteBuddyMockMaker;
+
+    public ByteBuddyMockMaker() {
+        try {
+            subclassByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
+        } catch (NoClassDefFoundError e) {
+            Reporter.missingByteBuddyDependency(e);
+            throw e;
+        }
+    }
+
+    ByteBuddyMockMaker(SubclassByteBuddyMockMaker subclassByteBuddyMockMaker) {
+        this.subclassByteBuddyMockMaker = subclassByteBuddyMockMaker;
+    }
 
     @Override
     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        return defaultByteBuddyMockMaker.createMock(settings, handler);
+        return subclassByteBuddyMockMaker.createMock(settings, handler);
+    }
+
+    @Override
+    public <T> Optional<T> createSpy(
+            MockCreationSettings<T> settings, MockHandler handler, T object) {
+        return subclassByteBuddyMockMaker.createSpy(settings, handler, object);
     }
 
     @Override
     public <T> Class<? extends T> createMockType(MockCreationSettings<T> creationSettings) {
-        return defaultByteBuddyMockMaker.createMockType(creationSettings);
+        return subclassByteBuddyMockMaker.createMockType(creationSettings);
     }
 
     @Override
     public MockHandler getHandler(Object mock) {
-        return defaultByteBuddyMockMaker.getHandler(mock);
+        return subclassByteBuddyMockMaker.getHandler(mock);
     }
 
     @Override
     public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        defaultByteBuddyMockMaker.resetMock(mock, newHandler, settings);
+        subclassByteBuddyMockMaker.resetMock(mock, newHandler, settings);
     }
 
     @Override
-    @Incubating
     public TypeMockability isTypeMockable(Class<?> type) {
-        return defaultByteBuddyMockMaker.isTypeMockable(type);
+        return subclassByteBuddyMockMaker.isTypeMockable(type);
+    }
+
+    @Override
+    public <T> StaticMockControl<T> createStaticMock(
+            Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
+        return subclassByteBuddyMockMaker.createStaticMock(type, settings, handler);
+    }
+
+    @Override
+    public <T> ConstructionMockControl<T> createConstructionMock(
+            Class<T> type,
+            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+            Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        return subclassByteBuddyMockMaker.createConstructionMock(
+                type, settingsFactory, handlerFactory, mockInitializer);
+    }
+
+    @Override
+    public void clearAllCaches() {
+        subclassByteBuddyMockMaker.clearAllCaches();
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
index a131c04..392392d 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
@@ -7,4 +7,10 @@ package org.mockito.internal.creation.bytebuddy;
 public interface BytecodeGenerator {
 
     <T> Class<? extends T> mockClass(MockFeatures<T> features);
+
+    void mockClassConstruction(Class<?> type);
+
+    void mockClassStatic(Class<?> type);
+
+    default void clearAllCaches() {}
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/ConstructionCallback.java b/src/main/java/org/mockito/internal/creation/bytebuddy/ConstructionCallback.java
new file mode 100644
index 0000000..ac8ecc4
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/ConstructionCallback.java
@@ -0,0 +1,10 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy;
+
+public interface ConstructionCallback {
+
+    Object apply(Class<?> type, Object object, Object[] arguments, String[] parameterTypeNames);
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
index dfe2061..acfddfe 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
@@ -4,310 +4,97 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import net.bytebuddy.agent.ByteBuddyAgent;
-import org.mockito.Incubating;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.base.MockitoInitializationException;
-import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.MockedConstruction;
 import org.mockito.creation.instance.Instantiator;
-import org.mockito.internal.util.Platform;
-import org.mockito.internal.util.concurrent.WeakConcurrentMap;
+import org.mockito.internal.exceptions.Reporter;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.plugins.InlineMockMaker;
 
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.instrument.Instrumentation;
-import java.lang.reflect.Modifier;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.jar.JarOutputStream;
+import java.util.Optional;
+import java.util.function.Function;
 
-import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
-import static org.mockito.internal.util.StringUtil.join;
+public class InlineByteBuddyMockMaker
+        implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
+    private final InlineDelegateByteBuddyMockMaker inlineDelegateByteBuddyMockMaker;
 
-/**
- * Agent and subclass based mock maker.
- * <p>
- * This mock maker which uses a combination of the Java instrumentation API and sub-classing rather than creating
- * a new sub-class to create a mock. This way, it becomes possible to mock final types and methods. This mock
- * maker <strong>must to be activated explicitly</strong> for supporting mocking final types and methods:
- * <p>
- * <p>
- * This mock maker can be activated by creating the file <code>/mockito-extensions/org.mockito.plugins.MockMaker</code>
- * containing the text <code>mock-maker-inline</code> or <code>org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker</code>.
- * <p>
- * <p>
- * This mock maker will make a best effort to avoid subclass creation when creating a mock. Otherwise it will use the
- * <code>org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker</code> to create the mock class. That means
- * that the following condition is true
- * <p>
- * <pre class="code"><code class="java">
- * class Foo { }
- * assert mock(Foo.class).getClass() == Foo.class;
- * </pre></code>
- * <p>
- * unless any of the following conditions is met, in such case the mock maker <em>fall backs</em> to the
- * the creation of a subclass.
- * <p>
- * <ul>
- * <li>the type to mock is an abstract class.</li>
- * <li>the mock is set to require additional interfaces.</li>
- * <li>the mock is <a href="#20">explicitly set to support serialization</a>.</li>
- * </ul>
- * <p>
- * <p>
- * Some type of the JDK cannot be mocked, this includes <code>Class</code>, <code>String</code>, and wrapper types.
- * <p>
- * <p>
- * Nevertheless, final methods of such types are mocked when using the inlining mock maker. Mocking final types and enums
- * does however remain impossible when explicitly requiring serialization support or when adding ancillary interfaces.
- * <p>
- * <p>
- * Important behavioral changes when using inline-mocks:
- * <ul>
- * <li>Mockito is capable of mocking package-private methods even if they are defined in different packages than
- * the mocked type. Mockito voluntarily never mocks package-visible methods within <code>java.*</code> packages.</li>
- * <li>Additionally to final types, Mockito can now mock types that are not visible for extension; such types
- * include private types in a protected package.</li>
- * <li>Mockito can no longer mock <code>native</code> methods. Inline mocks require byte code manipulation of a
- * method where native methods do not offer any byte code to manipulate.</li>
- * <li>Mockito cannot longer strip <code>synchronized</code> modifiers from mocked instances.</li>
- * </ul>
- * <p>
- * <p>
- * Note that inline mocks require a Java agent to be attached. Mockito will attempt an attachment of a Java agent upon
- * loading the mock maker for creating inline mocks. Such runtime attachment is only possible when using a JVM that
- * is part of a JDK or when using a Java 9 VM. When running on a non-JDK VM prior to Java 9, it is however possible to
- * manually add the <a href="http://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
- * parameter upon starting the JVM. Furthermore, the inlining mock maker requires the VM to support class retransformation
- * (also known as HotSwap). All major VM distributions such as HotSpot (OpenJDK), J9 (IBM/Websphere) or Zing (Azul)
- * support this feature.
- */
-@Incubating
-public class InlineByteBuddyMockMaker implements ClassCreatingMockMaker, InlineMockMaker {
-
-    private static final Instrumentation INSTRUMENTATION;
-
-    private static final Throwable INITIALIZATION_ERROR;
-
-    static {
-        Instrumentation instrumentation;
-        Throwable initializationError = null;
+    public InlineByteBuddyMockMaker() {
         try {
-            try {
-                instrumentation = ByteBuddyAgent.install();
-                if (!instrumentation.isRetransformClassesSupported()) {
-                    throw new IllegalStateException(join(
-                            "Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.",
-                            "",
-                            "You cannot use this mock maker on this VM"));
-                }
-                File boot = File.createTempFile("mockitoboot", ".jar");
-                boot.deleteOnExit();
-                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
-                try {
-                    String source = "org/mockito/internal/creation/bytebuddy/MockMethodDispatcher";
-                    InputStream inputStream = InlineByteBuddyMockMaker.class.getClassLoader().getResourceAsStream(source + ".raw");
-                    if (inputStream == null) {
-                        throw new IllegalStateException(join(
-                                "The MockMethodDispatcher class file is not locatable: " + source + ".raw",
-                                "",
-                                "The class loader responsible for looking up the resource: " + InlineByteBuddyMockMaker.class.getClassLoader()
-                        ));
-                    }
-                    outputStream.putNextEntry(new JarEntry(source + ".class"));
-                    try {
-                        int length;
-                        byte[] buffer = new byte[1024];
-                        while ((length = inputStream.read(buffer)) != -1) {
-                            outputStream.write(buffer, 0, length);
-                        }
-                    } finally {
-                        inputStream.close();
-                    }
-                    outputStream.closeEntry();
-                } finally {
-                    outputStream.close();
-                }
-                instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(boot));
-                try {
-                    Class<?> dispatcher = Class.forName("org.mockito.internal.creation.bytebuddy.MockMethodDispatcher");
-                    if (dispatcher.getClassLoader() != null) {
-                        throw new IllegalStateException(join(
-                                "The MockMethodDispatcher must not be loaded manually but must be injected into the bootstrap class loader.",
-                                "",
-                                "The dispatcher class was already loaded by: " + dispatcher.getClassLoader()));
-                    }
-                } catch (ClassNotFoundException cnfe) {
-                    throw new IllegalStateException(join(
-                            "Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader",
-                            "",
-                            "It seems like your current VM does not support the instrumentation API correctly."), cnfe);
-                }
-            } catch (IOException ioe) {
-                throw new IllegalStateException(join(
-                        "Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.",
-                        "This error occured due to an I/O error during the creation of this agent: " + ioe,
-                        "",
-                        "Potentially, the current VM does not support the instrumentation API correctly"), ioe);
-            }
-        } catch (Throwable throwable) {
-            instrumentation = null;
-            initializationError = throwable;
+            inlineDelegateByteBuddyMockMaker = new InlineDelegateByteBuddyMockMaker();
+        } catch (NoClassDefFoundError e) {
+            Reporter.missingByteBuddyDependency(e);
+            throw e;
         }
-        INSTRUMENTATION = instrumentation;
-        INITIALIZATION_ERROR = initializationError;
     }
 
-    private final BytecodeGenerator bytecodeGenerator;
+    InlineByteBuddyMockMaker(InlineDelegateByteBuddyMockMaker inlineDelegateByteBuddyMockMaker) {
+        this.inlineDelegateByteBuddyMockMaker = inlineDelegateByteBuddyMockMaker;
+    }
 
-    private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks = new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
+    @Override
+    public <T> T newInstance(Class<T> cls) {
+        return inlineDelegateByteBuddyMockMaker.newInstance(cls);
+    }
 
-    public InlineByteBuddyMockMaker() {
-        if (INITIALIZATION_ERROR != null) {
-            throw new MockitoInitializationException(join(
-                    "Could not initialize inline Byte Buddy mock maker. (This mock maker is not supported on Android.)",
-                    "",
-                    Platform.describe()), INITIALIZATION_ERROR);
-        }
-        bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(INSTRUMENTATION, mocks), true);
+    @Override
+    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
+        return inlineDelegateByteBuddyMockMaker.createMockType(settings);
     }
 
     @Override
-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        Class<? extends T> type = createMockType(settings);
+    public void clearMock(Object mock) {
+        inlineDelegateByteBuddyMockMaker.clearMock(mock);
+    }
 
-        Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
-        try {
-            T instance = instantiator.newInstance(type);
-            MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(handler, settings);
-            mocks.put(instance, mockMethodInterceptor);
-            if (instance instanceof MockAccess) {
-                ((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
-            }
-            return instance;
-        } catch (org.mockito.creation.instance.InstantiationException e) {
-            throw new MockitoException("Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
-        }
+    @Override
+    public void clearAllMocks() {
+        inlineDelegateByteBuddyMockMaker.clearAllMocks();
     }
 
     @Override
-    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
-        try {
-            return bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
-                    settings.getTypeToMock(),
-                    settings.getExtraInterfaces(),
-                    settings.getSerializableMode(),
-                    settings.isStripAnnotations()
-            ));
-        } catch (Exception bytecodeGenerationFailed) {
-            throw prettifyFailure(settings, bytecodeGenerationFailed);
-        }
+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+        return inlineDelegateByteBuddyMockMaker.createMock(settings, handler);
     }
 
-    private <T> RuntimeException prettifyFailure(MockCreationSettings<T> mockFeatures, Exception generationFailed) {
-        if (mockFeatures.getTypeToMock().isArray()) {
-            throw new MockitoException(join(
-                    "Arrays cannot be mocked: " + mockFeatures.getTypeToMock() + ".",
-                    ""
-            ), generationFailed);
-        }
-        if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
-            throw new MockitoException(join(
-                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                    "Can not mock final classes with the following settings :",
-                    " - explicit serialization (e.g. withSettings().serializable())",
-                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
-                    "",
-                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                    "",
-                    "Underlying exception : " + generationFailed
-            ), generationFailed);
-        }
-        if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
-            throw new MockitoException(join(
-                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                    "Most likely it is a private class that is not visible by Mockito",
-                    "",
-                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                    ""
-            ), generationFailed);
-        }
-        throw new MockitoException(join(
-                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                "",
-                "If you're not sure why you're getting this error, please report to the mailing list.",
-                "",
-                Platform.warnForVM(
-                        "IBM J9 VM", "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
-                        "Hotspot", Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : ""
-                ),
-                Platform.describe(),
-                "",
-                "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                "",
-                "Underlying exception : " + generationFailed
-        ), generationFailed);
+    @Override
+    public <T> Optional<T> createSpy(
+            MockCreationSettings<T> settings, MockHandler handler, T instance) {
+        return inlineDelegateByteBuddyMockMaker.createSpy(settings, handler, instance);
     }
 
     @Override
     public MockHandler getHandler(Object mock) {
-        MockMethodInterceptor interceptor = mocks.get(mock);
-        if (interceptor == null) {
-            return null;
-        } else {
-            return interceptor.handler;
-        }
+        return inlineDelegateByteBuddyMockMaker.getHandler(mock);
     }
 
     @Override
     public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(newHandler, settings);
-        mocks.put(mock, mockMethodInterceptor);
-        if (mock instanceof MockAccess) {
-            ((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
-        }
+        inlineDelegateByteBuddyMockMaker.resetMock(mock, newHandler, settings);
     }
 
     @Override
-    public void clearMock(Object mock) {
-        mocks.remove(mock);
+    public TypeMockability isTypeMockable(Class<?> type) {
+        return inlineDelegateByteBuddyMockMaker.isTypeMockable(type);
     }
 
     @Override
-    public void clearAllMocks() {
-        mocks.clear();
+    public <T> StaticMockControl<T> createStaticMock(
+            Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
+        return inlineDelegateByteBuddyMockMaker.createStaticMock(type, settings, handler);
     }
 
     @Override
-    public TypeMockability isTypeMockable(final Class<?> type) {
-        return new TypeMockability() {
-            @Override
-            public boolean mockable() {
-                return INSTRUMENTATION.isModifiableClass(type) && !EXCLUDES.contains(type);
-            }
-
-            @Override
-            public String nonMockableReason() {
-                if (mockable()) {
-                    return "";
-                }
-                if (type.isPrimitive()) {
-                    return "primitive type";
-                }
-                if (EXCLUDES.contains(type)) {
-                    return "Cannot mock wrapper types, String.class or Class.class";
-                }
-                return "VM does not not support modification of given type";
-            }
-        };
+    public <T> ConstructionMockControl<T> createConstructionMock(
+            Class<T> type,
+            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+            Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        return inlineDelegateByteBuddyMockMaker.createConstructionMock(
+                type, settingsFactory, handlerFactory, mockInitializer);
     }
 
+    @Override
+    public void clearAllCaches() {
+        inlineDelegateByteBuddyMockMaker.clearAllCaches();
+    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index 64139c2..10b73c8 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -20,85 +20,151 @@ import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.jar.asm.ClassVisitor;
 import net.bytebuddy.jar.asm.MethodVisitor;
-import net.bytebuddy.jar.asm.Opcodes;
 import net.bytebuddy.matcher.ElementMatchers;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.utility.OpenedClassReader;
 import net.bytebuddy.utility.RandomString;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.SuppressSignatureCheck;
+import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
+import org.mockito.internal.util.concurrent.DetachedThreadLocal;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
 import org.mockito.internal.util.concurrent.WeakConcurrentSet;
 import org.mockito.mock.SerializableMode;
 
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
+import java.lang.instrument.UnmodifiableClassException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.security.ProtectionDomain;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.*;
+import java.util.function.Predicate;
 
 import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
 import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
 import static net.bytebuddy.matcher.ElementMatchers.*;
 import static org.mockito.internal.util.StringUtil.join;
 
+@SuppressSignatureCheck
 public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTransformer {
 
     private static final String PRELOAD = "org.mockito.inline.preload";
 
     @SuppressWarnings("unchecked")
-    static final Set<Class<?>> EXCLUDES = new HashSet<Class<?>>(Arrays.asList(Class.class,
-            Boolean.class,
-            Byte.class,
-            Short.class,
-            Character.class,
-            Integer.class,
-            Long.class,
-            Float.class,
-            Double.class,
-            String.class));
+    static final Set<Class<?>> EXCLUDES =
+            new HashSet<Class<?>>(
+                    Arrays.asList(
+                            Class.class,
+                            Boolean.class,
+                            Byte.class,
+                            Short.class,
+                            Character.class,
+                            Integer.class,
+                            Long.class,
+                            Float.class,
+                            Double.class,
+                            String.class));
 
     private final Instrumentation instrumentation;
 
     private final ByteBuddy byteBuddy;
 
-    private final WeakConcurrentSet<Class<?>> mocked;
+    private final WeakConcurrentSet<Class<?>> mocked, flatMocked;
 
     private final BytecodeGenerator subclassEngine;
 
     private final AsmVisitorWrapper mockTransformer;
 
+    private final Method getModule, canRead, redefineModule;
+
     private volatile Throwable lastException;
 
-    public InlineBytecodeGenerator(Instrumentation instrumentation, WeakConcurrentMap<Object, MockMethodInterceptor> mocks) {
+    public InlineBytecodeGenerator(
+            Instrumentation instrumentation,
+            WeakConcurrentMap<Object, MockMethodInterceptor> mocks,
+            DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics,
+            Predicate<Class<?>> isMockConstruction,
+            ConstructionCallback onConstruction) {
         preload();
         this.instrumentation = instrumentation;
-        byteBuddy = new ByteBuddy()
-            .with(TypeValidation.DISABLED)
-            .with(Implementation.Context.Disabled.Factory.INSTANCE)
-            .with(MethodGraph.Compiler.ForDeclaredMethods.INSTANCE);
-        mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
+        byteBuddy =
+                new ByteBuddy()
+                        .with(TypeValidation.DISABLED)
+                        .with(Implementation.Context.Disabled.Factory.INSTANCE)
+                        .with(MethodGraph.Compiler.ForDeclaredMethods.INSTANCE)
+                        .ignore(isSynthetic().and(not(isConstructor())).or(isDefaultFinalizer()));
+        mocked = new WeakConcurrentSet<>(WeakConcurrentSet.Cleaner.INLINE);
+        flatMocked = new WeakConcurrentSet<>(WeakConcurrentSet.Cleaner.INLINE);
         String identifier = RandomString.make();
-        subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
-            .withBinders(of(MockMethodAdvice.Identifier.class, identifier))
-            .to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative()).or(isToString())), false);
-        mockTransformer = new AsmVisitorWrapper.ForDeclaredMethods()
-            .method(isVirtual()
-                    .and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
-                    .and(not(isDeclaredBy(nameStartsWith("java.")).<MethodDescription>and(isPackagePrivate()))),
-                Advice.withCustomMapping()
-                    .bind(MockMethodAdvice.Identifier.class, identifier)
-                    .to(MockMethodAdvice.class))
-            .method(isHashCode(),
-                Advice.withCustomMapping()
-                    .bind(MockMethodAdvice.Identifier.class, identifier)
-                    .to(MockMethodAdvice.ForHashCode.class))
-            .method(isEquals(),
-                Advice.withCustomMapping()
-                    .bind(MockMethodAdvice.Identifier.class, identifier)
-                    .to(MockMethodAdvice.ForEquals.class));
-        MockMethodDispatcher.set(identifier, new MockMethodAdvice(mocks, identifier));
+        subclassEngine =
+                new TypeCachingBytecodeGenerator(
+                        new SubclassBytecodeGenerator(
+                                withDefaultConfiguration()
+                                        .withBinders(
+                                                of(MockMethodAdvice.Identifier.class, identifier))
+                                        .to(MockMethodAdvice.ForReadObject.class),
+                                isAbstract().or(isNative()).or(isToString())),
+                        false);
+        mockTransformer =
+                new AsmVisitorWrapper.ForDeclaredMethods()
+                        .method(
+                                isVirtual()
+                                        .and(
+                                                not(
+                                                        isBridge()
+                                                                .or(isHashCode())
+                                                                .or(isEquals())
+                                                                .or(isDefaultFinalizer())))
+                                        .and(
+                                                not(
+                                                        isDeclaredBy(nameStartsWith("java."))
+                                                                .<MethodDescription>and(
+                                                                        isPackagePrivate()))),
+                                Advice.withCustomMapping()
+                                        .bind(MockMethodAdvice.Identifier.class, identifier)
+                                        .to(MockMethodAdvice.class))
+                        .method(
+                                isStatic(),
+                                Advice.withCustomMapping()
+                                        .bind(MockMethodAdvice.Identifier.class, identifier)
+                                        .to(MockMethodAdvice.ForStatic.class))
+                        .constructor(any(), new MockMethodAdvice.ConstructorShortcut(identifier))
+                        .method(
+                                isHashCode(),
+                                Advice.withCustomMapping()
+                                        .bind(MockMethodAdvice.Identifier.class, identifier)
+                                        .to(MockMethodAdvice.ForHashCode.class))
+                        .method(
+                                isEquals(),
+                                Advice.withCustomMapping()
+                                        .bind(MockMethodAdvice.Identifier.class, identifier)
+                                        .to(MockMethodAdvice.ForEquals.class));
+        Method getModule, canRead, redefineModule;
+        try {
+            getModule = Class.class.getMethod("getModule");
+            canRead = getModule.getReturnType().getMethod("canRead", getModule.getReturnType());
+            redefineModule =
+                    Instrumentation.class.getMethod(
+                            "redefineModule",
+                            getModule.getReturnType(),
+                            Set.class,
+                            Map.class,
+                            Map.class,
+                            Set.class,
+                            Map.class);
+        } catch (Exception ignored) {
+            getModule = null;
+            canRead = null;
+            redefineModule = null;
+        }
+        this.getModule = getModule;
+        this.canRead = canRead;
+        this.redefineModule = redefineModule;
+        MockMethodDispatcher.set(
+                identifier,
+                new MockMethodAdvice(
+                        mocks, mockedStatics, identifier, isMockConstruction, onConstruction));
         instrumentation.addTransformer(this, true);
     }
 
@@ -119,7 +185,8 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
     private static void preload() {
         String preloads = System.getProperty(PRELOAD);
         if (preloads == null) {
-            preloads = "java.lang.WeakPairMap,java.lang.WeakPairMap$Pair,java.lang.WeakPairMap$Pair$Weak";
+            preloads =
+                    "java.lang.WeakPairMap,java.lang.WeakPairMap$Pair,java.lang.WeakPairMap$Pair$Weak";
         }
         for (String preload : preloads.split(",")) {
             try {
@@ -131,89 +198,201 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
 
     @Override
     public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
-        boolean subclassingRequired = !features.interfaces.isEmpty()
-            || features.serializableMode != SerializableMode.NONE
-            || Modifier.isAbstract(features.mockedType.getModifiers());
+        boolean subclassingRequired =
+                !features.interfaces.isEmpty()
+                        || features.serializableMode != SerializableMode.NONE
+                        || Modifier.isAbstract(features.mockedType.getModifiers());
 
         checkSupportedCombination(subclassingRequired, features);
 
+        Set<Class<?>> types = new HashSet<>();
+        types.add(features.mockedType);
+        types.addAll(features.interfaces);
+
         synchronized (this) {
-            triggerRetransformation(features);
+            triggerRetransformation(types, false);
         }
 
-        return subclassingRequired ?
-                subclassEngine.mockClass(features) :
-                features.mockedType;
+        return subclassingRequired ? subclassEngine.mockClass(features) : features.mockedType;
     }
 
-    private <T> void triggerRetransformation(MockFeatures<T> features) {
-        Set<Class<?>> types = new HashSet<Class<?>>();
-        Class<?> type = features.mockedType;
-        do {
-            if (mocked.add(type)) {
-                types.add(type);
-                addInterfaces(types, type.getInterfaces());
+    @Override
+    public synchronized void mockClassStatic(Class<?> type) {
+        triggerRetransformation(Collections.singleton(type), true);
+    }
+
+    @Override
+    public synchronized void mockClassConstruction(Class<?> type) {
+        triggerRetransformation(Collections.singleton(type), false);
+    }
+
+    private static void assureInitialization(Class<?> type) {
+        try {
+            Class.forName(type.getName(), true, type.getClassLoader());
+        } catch (ExceptionInInitializerError e) {
+            throw new MockitoException(
+                    "Cannot instrument "
+                            + type
+                            + " because it or one of its supertypes could not be initialized",
+                    e.getException());
+        } catch (Throwable ignored) {
+        }
+    }
+
+    private <T> void triggerRetransformation(Set<Class<?>> types, boolean flat) {
+        Set<Class<?>> targets = new HashSet<Class<?>>();
+
+        try {
+            for (Class<?> type : types) {
+                if (flat) {
+                    if (!mocked.contains(type) && flatMocked.add(type)) {
+                        assureInitialization(type);
+                        targets.add(type);
+                    }
+                } else {
+                    do {
+                        if (mocked.add(type)) {
+                            if (!flatMocked.remove(type)) {
+                                assureInitialization(type);
+                                targets.add(type);
+                            }
+                            addInterfaces(targets, type.getInterfaces());
+                        }
+                        type = type.getSuperclass();
+                    } while (type != null);
+                }
+            }
+        } catch (Throwable t) {
+            for (Class<?> target : targets) {
+                mocked.remove(target);
+                flatMocked.remove(target);
             }
-            type = type.getSuperclass();
-        } while (type != null);
-        if (!types.isEmpty()) {
+            throw t;
+        }
+
+        if (!targets.isEmpty()) {
             try {
-                instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
+                assureCanReadMockito(targets);
+                instrumentation.retransformClasses(targets.toArray(new Class<?>[targets.size()]));
                 Throwable throwable = lastException;
                 if (throwable != null) {
-                    throw new IllegalStateException(join("Byte Buddy could not instrument all classes within the mock's type hierarchy",
-                        "",
-                        "This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:",
-                        " - Compiled by older versions of scalac",
-                        " - Classes that are part of the Android distribution"), throwable);
+                    throw new IllegalStateException(
+                            join(
+                                    "Byte Buddy could not instrument all classes within the mock's type hierarchy",
+                                    "",
+                                    "This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:",
+                                    " - Compiled by older versions of scalac",
+                                    " - Classes that are part of the Android distribution"),
+                            throwable);
                 }
             } catch (Exception exception) {
-                for (Class<?> failed : types) {
+                for (Class<?> failed : targets) {
                     mocked.remove(failed);
+                    flatMocked.remove(failed);
                 }
-                throw new MockitoException("Could not modify all classes " + types, exception);
+                throw new MockitoException("Could not modify all classes " + targets, exception);
             } finally {
                 lastException = null;
             }
         }
     }
 
-    private <T> void checkSupportedCombination(boolean subclassingRequired, MockFeatures<T> features) {
+    private void assureCanReadMockito(Set<Class<?>> types) {
+        if (redefineModule == null) {
+            return;
+        }
+        Set<Object> modules = new HashSet<Object>();
+        try {
+            Object target =
+                    getModule.invoke(
+                            Class.forName(
+                                    "org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher",
+                                    false,
+                                    null));
+            for (Class<?> type : types) {
+                Object module = getModule.invoke(type);
+                if (!modules.contains(module) && !(Boolean) canRead.invoke(module, target)) {
+                    modules.add(module);
+                }
+            }
+            for (Object module : modules) {
+                redefineModule.invoke(
+                        instrumentation,
+                        module,
+                        Collections.singleton(target),
+                        Collections.emptyMap(),
+                        Collections.emptyMap(),
+                        Collections.emptySet(),
+                        Collections.emptyMap());
+            }
+        } catch (Exception e) {
+            throw new IllegalStateException(
+                    join(
+                            "Could not adjust module graph to make the mock instance dispatcher visible to some classes",
+                            "",
+                            "At least one of those modules: "
+                                    + modules
+                                    + " is not reading the unnamed module of the bootstrap loader",
+                            "Without such a read edge, the classes that are redefined to become mocks cannot access the mock dispatcher.",
+                            "To circumvent this, Mockito attempted to add a read edge to this module what failed for an unexpected reason"),
+                    e);
+        }
+    }
+
+    private <T> void checkSupportedCombination(
+            boolean subclassingRequired, MockFeatures<T> features) {
         if (subclassingRequired
                 && !features.mockedType.isArray()
                 && !features.mockedType.isPrimitive()
-                && Modifier.isFinal(features.mockedType.getModifiers())) {
-            throw new MockitoException("Unsupported settings with this type '" + features.mockedType.getName() + "'");
+                && (Modifier.isFinal(features.mockedType.getModifiers())
+                        || TypeSupport.INSTANCE.isSealed(features.mockedType)
+                        || features.interfaces.stream().anyMatch(TypeSupport.INSTANCE::isSealed))) {
+            throw new MockitoException(
+                    "Unsupported settings with this type '" + features.mockedType.getName() + "'");
         }
     }
 
     private void addInterfaces(Set<Class<?>> types, Class<?>[] interfaces) {
         for (Class<?> type : interfaces) {
             if (mocked.add(type)) {
-                types.add(type);
+                if (!flatMocked.remove(type)) {
+                    assureInitialization(type);
+                    types.add(type);
+                }
                 addInterfaces(types, type.getInterfaces());
             }
         }
     }
 
     @Override
-    public byte[] transform(ClassLoader loader,
-                            String className,
-                            Class<?> classBeingRedefined,
-                            ProtectionDomain protectionDomain,
-                            byte[] classfileBuffer) {
+    public byte[] transform(
+            ClassLoader loader,
+            String className,
+            Class<?> classBeingRedefined,
+            ProtectionDomain protectionDomain,
+            byte[] classfileBuffer) {
         if (classBeingRedefined == null
-            || !mocked.contains(classBeingRedefined)
-            || EXCLUDES.contains(classBeingRedefined)) {
+                || !mocked.contains(classBeingRedefined)
+                        && !flatMocked.contains(classBeingRedefined)
+                || EXCLUDES.contains(classBeingRedefined)) {
             return null;
         } else {
             try {
-                return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
-                    // Note: The VM erases parameter meta data from the provided class file (bug). We just add this information manually.
-                    .visit(new ParameterWritingVisitorWrapper(classBeingRedefined))
-                    .visit(mockTransformer)
-                    .make()
-                    .getBytes();
+                return byteBuddy
+                        .redefine(
+                                classBeingRedefined,
+                                //        new ClassFileLocator.Compound(
+                                ClassFileLocator.Simple.of(
+                                        classBeingRedefined.getName(), classfileBuffer)
+                                //            ,ClassFileLocator.ForClassLoader.ofSystemLoader()
+                                //        )
+                                )
+                        // Note: The VM erases parameter meta data from the provided class file
+                        // (bug). We just add this information manually.
+                        .visit(new ParameterWritingVisitorWrapper(classBeingRedefined))
+                        .visit(mockTransformer)
+                        .make()
+                        .getBytes();
             } catch (Throwable throwable) {
                 lastException = throwable;
                 return null;
@@ -221,6 +400,28 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
         }
     }
 
+    @Override
+    public synchronized void clearAllCaches() {
+        Set<Class<?>> types = new HashSet<>();
+        mocked.forEach(types::add);
+        if (types.isEmpty()) {
+            return;
+        }
+        mocked.clear();
+        flatMocked.clear();
+        try {
+            instrumentation.retransformClasses(types.toArray(new Class<?>[0]));
+        } catch (UnmodifiableClassException e) {
+            throw new MockitoException(
+                    join(
+                            "Failed to reset mocks.",
+                            "",
+                            "This should not influence the working of Mockito.",
+                            "But if the reset intends to remove mocking code to improve performance, it is still impacted."),
+                    e);
+        }
+    }
+
     private static class ParameterWritingVisitorWrapper extends AsmVisitorWrapper.AbstractBase {
 
         private final Class<?> type;
@@ -230,16 +431,18 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
         }
 
         @Override
-        public ClassVisitor wrap(TypeDescription instrumentedType,
-                                 ClassVisitor classVisitor,
-                                 Implementation.Context implementationContext,
-                                 TypePool typePool,
-                                 FieldList<FieldDescription.InDefinedShape> fields,
-                                 MethodList<?> methods,
-                                 int writerFlags,
-                                 int readerFlags) {
+        public ClassVisitor wrap(
+                TypeDescription instrumentedType,
+                ClassVisitor classVisitor,
+                Implementation.Context implementationContext,
+                TypePool typePool,
+                FieldList<FieldDescription.InDefinedShape> fields,
+                MethodList<?> methods,
+                int writerFlags,
+                int readerFlags) {
             return implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V8)
-                    ? new ParameterAddingClassVisitor(classVisitor, new TypeDescription.ForLoadedType(type))
+                    ? new ParameterAddingClassVisitor(
+                            classVisitor, new TypeDescription.ForLoadedType(type))
                     : classVisitor;
         }
 
@@ -253,14 +456,26 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
             }
 
             @Override
-            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
-                MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);
-                MethodList<?> methodList = typeDescription.getDeclaredMethods().filter((name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)
-                        ? isConstructor()
-                        : ElementMatchers.<MethodDescription>named(name)).and(hasDescriptor(desc)));
-                if (methodList.size() == 1 && methodList.getOnly().getParameters().hasExplicitMetaData()) {
-                    for (ParameterDescription parameterDescription : methodList.getOnly().getParameters()) {
-                        methodVisitor.visitParameter(parameterDescription.getName(), parameterDescription.getModifiers());
+            public MethodVisitor visitMethod(
+                    int access, String name, String desc, String signature, String[] exceptions) {
+                MethodVisitor methodVisitor =
+                        super.visitMethod(access, name, desc, signature, exceptions);
+                MethodList<?> methodList =
+                        typeDescription
+                                .getDeclaredMethods()
+                                .filter(
+                                        (name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)
+                                                        ? isConstructor()
+                                                        : ElementMatchers.<MethodDescription>named(
+                                                                name))
+                                                .and(hasDescriptor(desc)));
+                if (methodList.size() == 1
+                        && methodList.getOnly().getParameters().hasExplicitMetaData()) {
+                    for (ParameterDescription parameterDescription :
+                            methodList.getOnly().getParameters()) {
+                        methodVisitor.visitParameter(
+                                parameterDescription.getName(),
+                                parameterDescription.getModifiers());
                     }
                     return new MethodParameterStrippingMethodVisitor(methodVisitor);
                 } else {
@@ -272,7 +487,7 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
         private static class MethodParameterStrippingMethodVisitor extends MethodVisitor {
 
             public MethodParameterStrippingMethodVisitor(MethodVisitor mv) {
-                super(Opcodes.ASM5, mv);
+                super(OpenedClassReader.ASM_API, mv);
             }
 
             @Override
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
new file mode 100644
index 0000000..9da6560
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
@@ -0,0 +1,879 @@
+/*
+ * Copyright (c) 2016 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy;
+
+import net.bytebuddy.agent.ByteBuddyAgent;
+import org.mockito.MockedConstruction;
+import org.mockito.creation.instance.InstantiationException;
+import org.mockito.creation.instance.Instantiator;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.base.MockitoInitializationException;
+import org.mockito.exceptions.misusing.MockitoConfigurationException;
+import org.mockito.internal.SuppressSignatureCheck;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.creation.instance.ConstructorInstantiator;
+import org.mockito.internal.util.Platform;
+import org.mockito.internal.util.concurrent.DetachedThreadLocal;
+import org.mockito.internal.util.concurrent.WeakConcurrentMap;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.InlineMockMaker;
+import org.mockito.plugins.MemberAccessor;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.instrument.Instrumentation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarOutputStream;
+
+import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
+import static org.mockito.internal.util.StringUtil.join;
+
+/**
+ * Agent and subclass based mock maker.
+ * <p>
+ * This mock maker which uses a combination of the Java instrumentation API and sub-classing rather than creating
+ * a new sub-class to create a mock. This way, it becomes possible to mock final types and methods. This mock
+ * maker <strong>must to be activated explicitly</strong> for supporting mocking final types and methods:
+ * <p>
+ * <p>
+ * This mock maker can be activated by creating the file <code>/mockito-extensions/org.mockito.plugins.MockMaker</code>
+ * containing the text <code>mock-maker-inline</code> or <code>org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker</code>.
+ * <p>
+ * <p>
+ * This mock maker will make a best effort to avoid subclass creation when creating a mock. Otherwise it will use the
+ * <code>org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker</code> to create the mock class. That means
+ * that the following condition is true
+ * <p>
+ * <pre class="code"><code class="java">
+ * class Foo { }
+ * assert mock(Foo.class).getClass() == Foo.class;
+ * </pre></code>
+ * <p>
+ * unless any of the following conditions is met, in such case the mock maker <em>fall backs</em> to the
+ * the creation of a subclass.
+ * <p>
+ * <ul>
+ * <li>the type to mock is an abstract class.</li>
+ * <li>the mock is set to require additional interfaces.</li>
+ * <li>the mock is <a href="#20">explicitly set to support serialization</a>.</li>
+ * </ul>
+ * <p>
+ * <p>
+ * Some type of the JDK cannot be mocked, this includes <code>Class</code>, <code>String</code>, and wrapper types.
+ * <p>
+ * <p>
+ * Nevertheless, final methods of such types are mocked when using the inlining mock maker. Mocking final types and enums
+ * does however remain impossible when explicitly requiring serialization support or when adding ancillary interfaces.
+ * <p>
+ * <p>
+ * Important behavioral changes when using inline-mocks:
+ * <ul>
+ * <li>Mockito is capable of mocking package-private methods even if they are defined in different packages than
+ * the mocked type. Mockito voluntarily never mocks package-visible methods within <code>java.*</code> packages.</li>
+ * <li>Additionally to final types, Mockito can now mock types that are not visible for extension; such types
+ * include private types in a protected package.</li>
+ * <li>Mockito can no longer mock <code>native</code> methods. Inline mocks require byte code manipulation of a
+ * method where native methods do not offer any byte code to manipulate.</li>
+ * <li>Mockito cannot longer strip <code>synchronized</code> modifiers from mocked instances.</li>
+ * </ul>
+ * <p>
+ * <p>
+ * Note that inline mocks require a Java agent to be attached. Mockito will attempt an attachment of a Java agent upon
+ * loading the mock maker for creating inline mocks. Such runtime attachment is only possible when using a JVM that
+ * is part of a JDK or when using a Java 9 VM. When running on a non-JDK VM prior to Java 9, it is however possible to
+ * manually add the <a href="https://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
+ * parameter upon starting the JVM. Furthermore, the inlining mock maker requires the VM to support class retransformation
+ * (also known as HotSwap). All major VM distributions such as HotSpot (OpenJDK), J9 (IBM/Websphere) or Zing (Azul)
+ * support this feature.
+ */
+@SuppressSignatureCheck
+class InlineDelegateByteBuddyMockMaker
+        implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
+
+    private static final Instrumentation INSTRUMENTATION;
+
+    private static final Throwable INITIALIZATION_ERROR;
+
+    static {
+        Instrumentation instrumentation;
+        Throwable initializationError = null;
+        try {
+            try {
+                instrumentation = ByteBuddyAgent.install();
+                if (!instrumentation.isRetransformClassesSupported()) {
+                    throw new IllegalStateException(
+                            join(
+                                    "Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.",
+                                    "",
+                                    "You cannot use this mock maker on this VM"));
+                }
+                File boot = File.createTempFile("mockitoboot", ".jar");
+                boot.deleteOnExit();
+                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
+                try {
+                    String source =
+                            "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher";
+                    InputStream inputStream =
+                            InlineDelegateByteBuddyMockMaker.class
+                                    .getClassLoader()
+                                    .getResourceAsStream(source + ".raw");
+                    if (inputStream == null) {
+                        throw new IllegalStateException(
+                                join(
+                                        "The MockMethodDispatcher class file is not locatable: "
+                                                + source
+                                                + ".raw",
+                                        "",
+                                        "The class loader responsible for looking up the resource: "
+                                                + InlineDelegateByteBuddyMockMaker.class
+                                                        .getClassLoader()));
+                    }
+                    outputStream.putNextEntry(new JarEntry(source + ".class"));
+                    try {
+                        int length;
+                        byte[] buffer = new byte[1024];
+                        while ((length = inputStream.read(buffer)) != -1) {
+                            outputStream.write(buffer, 0, length);
+                        }
+                    } finally {
+                        inputStream.close();
+                    }
+                    outputStream.closeEntry();
+                } finally {
+                    outputStream.close();
+                }
+                try (JarFile jarfile = new JarFile(boot)) {
+                    instrumentation.appendToBootstrapClassLoaderSearch(jarfile);
+                }
+                try {
+                    Class.forName(
+                            "org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher",
+                            false,
+                            null);
+                } catch (ClassNotFoundException cnfe) {
+                    throw new IllegalStateException(
+                            join(
+                                    "Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader",
+                                    "",
+                                    "It seems like your current VM does not support the instrumentation API correctly."),
+                            cnfe);
+                }
+            } catch (IOException ioe) {
+                throw new IllegalStateException(
+                        join(
+                                "Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.",
+                                "This error occured due to an I/O error during the creation of this agent: "
+                                        + ioe,
+                                "",
+                                "Potentially, the current VM does not support the instrumentation API correctly"),
+                        ioe);
+            }
+        } catch (Throwable throwable) {
+            instrumentation = null;
+            initializationError = throwable;
+        }
+        INSTRUMENTATION = instrumentation;
+        INITIALIZATION_ERROR = initializationError;
+    }
+
+    private final BytecodeGenerator bytecodeGenerator;
+
+    private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks =
+            new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
+
+    private final DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics =
+            new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
+
+    private final DetachedThreadLocal<Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>>>
+            mockedConstruction = new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
+
+    private final ThreadLocal<Boolean> mockitoConstruction = ThreadLocal.withInitial(() -> false);
+
+    private final ThreadLocal<Object> currentSpied = new ThreadLocal<>();
+
+    InlineDelegateByteBuddyMockMaker() {
+        if (INITIALIZATION_ERROR != null) {
+            String detail;
+            if (System.getProperty("java.specification.vendor", "")
+                    .toLowerCase()
+                    .contains("android")) {
+                detail =
+                        "It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.";
+            } else {
+                try {
+                    if (INITIALIZATION_ERROR instanceof NoClassDefFoundError
+                            && INITIALIZATION_ERROR.getMessage() != null
+                            && INITIALIZATION_ERROR
+                                    .getMessage()
+                                    .startsWith("net/bytebuddy/agent/")) {
+                        detail =
+                                join(
+                                        "It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy Agent could not be loaded.",
+                                        "",
+                                        "Byte Buddy Agent is available on Maven Central as 'net.bytebuddy:byte-buddy-agent' with the module name 'net.bytebuddy.agent'.",
+                                        "Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but ");
+                    } else if (Class.forName("javax.tools.ToolProvider")
+                                    .getMethod("getSystemJavaCompiler")
+                                    .invoke(null)
+                            == null) {
+                        detail =
+                                "It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.";
+                    } else {
+                        detail =
+                                "It appears as if your JDK does not supply a working agent attachment mechanism.";
+                    }
+                } catch (Throwable ignored) {
+                    detail =
+                            "It appears as if you are running an incomplete JVM installation that might not support all tooling APIs";
+                }
+            }
+            throw new MockitoInitializationException(
+                    join(
+                            "Could not initialize inline Byte Buddy mock maker.",
+                            "",
+                            detail,
+                            Platform.describe()),
+                    INITIALIZATION_ERROR);
+        }
+
+        ThreadLocal<Class<?>> currentConstruction = new ThreadLocal<>();
+        ThreadLocal<Boolean> isSuspended = ThreadLocal.withInitial(() -> false);
+        Predicate<Class<?>> isMockConstruction =
+                type -> {
+                    if (isSuspended.get()) {
+                        return false;
+                    } else if (mockitoConstruction.get() || currentConstruction.get() != null) {
+                        return true;
+                    }
+                    Map<Class<?>, ?> interceptors = mockedConstruction.get();
+                    if (interceptors != null && interceptors.containsKey(type)) {
+                        currentConstruction.set(type);
+                        return true;
+                    } else {
+                        return false;
+                    }
+                };
+        ConstructionCallback onConstruction =
+                (type, object, arguments, parameterTypeNames) -> {
+                    if (mockitoConstruction.get()) {
+                        Object spy = currentSpied.get();
+                        if (spy == null) {
+                            return null;
+                        } else if (type.isInstance(spy)) {
+                            return spy;
+                        } else {
+                            isSuspended.set(true);
+                            try {
+                                // Unexpected construction of non-spied object
+                                throw new MockitoException(
+                                        "Unexpected spy for "
+                                                + type.getName()
+                                                + " on instance of "
+                                                + object.getClass().getName(),
+                                        object instanceof Throwable ? (Throwable) object : null);
+                            } finally {
+                                isSuspended.set(false);
+                            }
+                        }
+                    } else if (currentConstruction.get() != type) {
+                        return null;
+                    }
+                    currentConstruction.remove();
+                    isSuspended.set(true);
+                    try {
+                        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
+                                mockedConstruction.get();
+                        if (interceptors != null) {
+                            BiConsumer<Object, MockedConstruction.Context> interceptor =
+                                    interceptors.get(type);
+                            if (interceptor != null) {
+                                interceptor.accept(
+                                        object,
+                                        new InlineConstructionMockContext(
+                                                arguments, object.getClass(), parameterTypeNames));
+                            }
+                        }
+                    } finally {
+                        isSuspended.set(false);
+                    }
+                    return null;
+                };
+
+        bytecodeGenerator =
+                new TypeCachingBytecodeGenerator(
+                        new InlineBytecodeGenerator(
+                                INSTRUMENTATION,
+                                mocks,
+                                mockedStatics,
+                                isMockConstruction,
+                                onConstruction),
+                        true);
+    }
+
+    @Override
+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+        return doCreateMock(settings, handler, false);
+    }
+
+    @Override
+    public <T> Optional<T> createSpy(
+            MockCreationSettings<T> settings, MockHandler handler, T object) {
+        if (object == null) {
+            throw new MockitoConfigurationException("Spy instance must not be null");
+        }
+        currentSpied.set(object);
+        try {
+            return Optional.ofNullable(doCreateMock(settings, handler, true));
+        } finally {
+            currentSpied.remove();
+        }
+    }
+
+    private <T> T doCreateMock(
+            MockCreationSettings<T> settings,
+            MockHandler handler,
+            boolean nullOnNonInlineConstruction) {
+        Class<? extends T> type = createMockType(settings);
+
+        try {
+            T instance;
+            if (settings.isUsingConstructor()) {
+                instance =
+                        new ConstructorInstantiator(
+                                        settings.getOuterClassInstance() != null,
+                                        settings.getConstructorArgs())
+                                .newInstance(type);
+            } else {
+                try {
+                    // We attempt to use the "native" mock maker first that avoids
+                    // Objenesis and Unsafe
+                    instance = newInstance(type);
+                } catch (InstantiationException ignored) {
+                    if (nullOnNonInlineConstruction) {
+                        return null;
+                    }
+                    Instantiator instantiator =
+                            Plugins.getInstantiatorProvider().getInstantiator(settings);
+                    instance = instantiator.newInstance(type);
+                }
+            }
+            MockMethodInterceptor mockMethodInterceptor =
+                    new MockMethodInterceptor(handler, settings);
+            mocks.put(instance, mockMethodInterceptor);
+            if (instance instanceof MockAccess) {
+                ((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
+            }
+            return instance;
+        } catch (InstantiationException e) {
+            throw new MockitoException(
+                    "Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
+        }
+    }
+
+    @Override
+    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
+        try {
+            return bytecodeGenerator.mockClass(
+                    MockFeatures.withMockFeatures(
+                            settings.getTypeToMock(),
+                            settings.getExtraInterfaces(),
+                            settings.getSerializableMode(),
+                            settings.isStripAnnotations(),
+                            settings.getDefaultAnswer()));
+        } catch (Exception bytecodeGenerationFailed) {
+            throw prettifyFailure(settings, bytecodeGenerationFailed);
+        }
+    }
+
+    private <T> RuntimeException prettifyFailure(
+            MockCreationSettings<T> mockFeatures, Exception generationFailed) {
+        if (mockFeatures.getTypeToMock().isArray()) {
+            throw new MockitoException(
+                    join("Arrays cannot be mocked: " + mockFeatures.getTypeToMock() + ".", ""),
+                    generationFailed);
+        }
+        if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
+            throw new MockitoException(
+                    join(
+                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                            "Can not mock final classes with the following settings :",
+                            " - explicit serialization (e.g. withSettings().serializable())",
+                            " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
+                            "",
+                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                            "",
+                            "Underlying exception : " + generationFailed),
+                    generationFailed);
+        }
+        if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
+            throw new MockitoException(
+                    join(
+                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                            "Most likely it is a private class that is not visible by Mockito",
+                            "",
+                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                            ""),
+                    generationFailed);
+        }
+        throw new MockitoException(
+                join(
+                        "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                        "",
+                        "If you're not sure why you're getting this error, please report to the mailing list.",
+                        "",
+                        Platform.warnForVM(
+                                "IBM J9 VM",
+                                "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
+                                "Hotspot",
+                                Platform.isJava8BelowUpdate45()
+                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
+                                        : ""),
+                        Platform.describe(),
+                        "",
+                        "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                        "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                        "",
+                        "Underlying exception : " + generationFailed),
+                generationFailed);
+    }
+
+    @Override
+    public MockHandler getHandler(Object mock) {
+        MockMethodInterceptor interceptor;
+        if (mock instanceof Class<?>) {
+            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+            interceptor = interceptors != null ? interceptors.get(mock) : null;
+        } else {
+            interceptor = mocks.get(mock);
+        }
+        if (interceptor == null) {
+            return null;
+        } else {
+            return interceptor.handler;
+        }
+    }
+
+    @Override
+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
+        MockMethodInterceptor mockMethodInterceptor =
+                new MockMethodInterceptor(newHandler, settings);
+        if (mock instanceof Class<?>) {
+            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+            if (interceptors == null || !interceptors.containsKey(mock)) {
+                throw new MockitoException(
+                        "Cannot reset "
+                                + mock
+                                + " which is not currently registered as a static mock");
+            }
+            interceptors.put((Class<?>) mock, mockMethodInterceptor);
+        } else {
+            if (!mocks.containsKey(mock)) {
+                throw new MockitoException(
+                        "Cannot reset " + mock + " which is not currently registered as a mock");
+            }
+            mocks.put(mock, mockMethodInterceptor);
+            if (mock instanceof MockAccess) {
+                ((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
+            }
+        }
+    }
+
+    @Override
+    public void clearAllCaches() {
+        clearAllMocks();
+        bytecodeGenerator.clearAllCaches();
+    }
+
+    @Override
+    public void clearMock(Object mock) {
+        if (mock instanceof Class<?>) {
+            for (Map<Class<?>, ?> entry : mockedStatics.getBackingMap().target.values()) {
+                entry.remove(mock);
+            }
+        } else {
+            mocks.remove(mock);
+        }
+    }
+
+    @Override
+    public void clearAllMocks() {
+        mockedStatics.getBackingMap().clear();
+        mocks.clear();
+    }
+
+    @Override
+    public TypeMockability isTypeMockable(final Class<?> type) {
+        return new TypeMockability() {
+            @Override
+            public boolean mockable() {
+                return INSTRUMENTATION.isModifiableClass(type) && !EXCLUDES.contains(type);
+            }
+
+            @Override
+            public String nonMockableReason() {
+                if (mockable()) {
+                    return "";
+                }
+                if (type.isPrimitive()) {
+                    return "primitive type";
+                }
+                if (EXCLUDES.contains(type)) {
+                    return "Cannot mock wrapper types, String.class or Class.class";
+                }
+                return "VM does not support modification of given type";
+            }
+        };
+    }
+
+    @Override
+    public <T> StaticMockControl<T> createStaticMock(
+            Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
+        if (type == ConcurrentHashMap.class) {
+            throw new MockitoException(
+                    "It is not possible to mock static methods of ConcurrentHashMap "
+                            + "to avoid infinitive loops within Mockito's implementation of static mock handling");
+        } else if (type == Thread.class
+                || type == System.class
+                || type == Arrays.class
+                || ClassLoader.class.isAssignableFrom(type)) {
+            throw new MockitoException(
+                    "It is not possible to mock static methods of "
+                            + type.getName()
+                            + " to avoid interfering with class loading what leads to infinite loops");
+        }
+
+        bytecodeGenerator.mockClassStatic(type);
+
+        Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+        if (interceptors == null) {
+            interceptors = new WeakHashMap<>();
+            mockedStatics.set(interceptors);
+        }
+
+        return new InlineStaticMockControl<>(type, interceptors, settings, handler);
+    }
+
+    @Override
+    public <T> ConstructionMockControl<T> createConstructionMock(
+            Class<T> type,
+            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+            Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        if (type == Object.class) {
+            throw new MockitoException(
+                    "It is not possible to mock construction of the Object class "
+                            + "to avoid inference with default object constructor chains");
+        } else if (type.isPrimitive() || Modifier.isAbstract(type.getModifiers())) {
+            throw new MockitoException(
+                    "It is not possible to construct primitive types or abstract types: "
+                            + type.getName());
+        }
+
+        bytecodeGenerator.mockClassConstruction(type);
+
+        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
+                mockedConstruction.get();
+        if (interceptors == null) {
+            interceptors = new WeakHashMap<>();
+            mockedConstruction.set(interceptors);
+        }
+
+        return new InlineConstructionMockControl<>(
+                type, settingsFactory, handlerFactory, mockInitializer, interceptors);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T newInstance(Class<T> cls) throws InstantiationException {
+        Constructor<?>[] constructors = cls.getDeclaredConstructors();
+        if (constructors.length == 0) {
+            throw new InstantiationException(cls.getName() + " does not define a constructor");
+        }
+        Constructor<?> selected = constructors[0];
+        for (Constructor<?> constructor : constructors) {
+            if (Modifier.isPublic(constructor.getModifiers())) {
+                selected = constructor;
+                break;
+            }
+        }
+        Class<?>[] types = selected.getParameterTypes();
+        Object[] arguments = new Object[types.length];
+        int index = 0;
+        for (Class<?> type : types) {
+            arguments[index++] = makeStandardArgument(type);
+        }
+        MemberAccessor accessor = Plugins.getMemberAccessor();
+        try {
+            return (T)
+                    accessor.newInstance(
+                            selected,
+                            callback -> {
+                                mockitoConstruction.set(true);
+                                try {
+                                    return callback.newInstance();
+                                } finally {
+                                    mockitoConstruction.set(false);
+                                }
+                            },
+                            arguments);
+        } catch (Exception e) {
+            throw new InstantiationException("Could not instantiate " + cls.getName(), e);
+        }
+    }
+
+    private Object makeStandardArgument(Class<?> type) {
+        if (type == boolean.class) {
+            return false;
+        } else if (type == byte.class) {
+            return (byte) 0;
+        } else if (type == short.class) {
+            return (short) 0;
+        } else if (type == char.class) {
+            return (char) 0;
+        } else if (type == int.class) {
+            return 0;
+        } else if (type == long.class) {
+            return 0L;
+        } else if (type == float.class) {
+            return 0f;
+        } else if (type == double.class) {
+            return 0d;
+        } else {
+            return null;
+        }
+    }
+
+    private static class InlineStaticMockControl<T> implements StaticMockControl<T> {
+
+        private final Class<T> type;
+
+        private final Map<Class<?>, MockMethodInterceptor> interceptors;
+
+        private final MockCreationSettings<T> settings;
+
+        private final MockHandler handler;
+
+        private InlineStaticMockControl(
+                Class<T> type,
+                Map<Class<?>, MockMethodInterceptor> interceptors,
+                MockCreationSettings<T> settings,
+                MockHandler handler) {
+            this.type = type;
+            this.interceptors = interceptors;
+            this.settings = settings;
+            this.handler = handler;
+        }
+
+        @Override
+        public Class<T> getType() {
+            return type;
+        }
+
+        @Override
+        public void enable() {
+            if (interceptors.putIfAbsent(type, new MockMethodInterceptor(handler, settings))
+                    != null) {
+                throw new MockitoException(
+                        join(
+                                "For "
+                                        + type.getName()
+                                        + ", static mocking is already registered in the current thread",
+                                "",
+                                "To create a new mock, the existing static mock registration must be deregistered"));
+            }
+        }
+
+        @Override
+        public void disable() {
+            if (interceptors.remove(type) == null) {
+                throw new MockitoException(
+                        join(
+                                "Could not deregister "
+                                        + type.getName()
+                                        + " as a static mock since it is not currently registered",
+                                "",
+                                "To register a static mock, use Mockito.mockStatic("
+                                        + type.getSimpleName()
+                                        + ".class)"));
+            }
+        }
+    }
+
+    private class InlineConstructionMockControl<T> implements ConstructionMockControl<T> {
+
+        private final Class<T> type;
+
+        private final Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory;
+        private final Function<MockedConstruction.Context, MockHandler<T>> handlerFactory;
+
+        private final MockedConstruction.MockInitializer<T> mockInitializer;
+
+        private final Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors;
+
+        private final List<Object> all = new ArrayList<>();
+        private int count;
+
+        private InlineConstructionMockControl(
+                Class<T> type,
+                Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+                Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+                MockedConstruction.MockInitializer<T> mockInitializer,
+                Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors) {
+            this.type = type;
+            this.settingsFactory = settingsFactory;
+            this.handlerFactory = handlerFactory;
+            this.mockInitializer = mockInitializer;
+            this.interceptors = interceptors;
+        }
+
+        @Override
+        public Class<T> getType() {
+            return type;
+        }
+
+        @Override
+        public void enable() {
+            if (interceptors.putIfAbsent(
+                            type,
+                            (object, context) -> {
+                                ((InlineConstructionMockContext) context).count = ++count;
+                                MockMethodInterceptor interceptor =
+                                        new MockMethodInterceptor(
+                                                handlerFactory.apply(context),
+                                                settingsFactory.apply(context));
+                                mocks.put(object, interceptor);
+                                try {
+                                    @SuppressWarnings("unchecked")
+                                    T cast = (T) object;
+                                    mockInitializer.prepare(cast, context);
+                                } catch (Throwable t) {
+                                    mocks.remove(object); // TODO: filter stack trace?
+                                    throw new MockitoException(
+                                            "Could not initialize mocked construction", t);
+                                }
+                                all.add(object);
+                            })
+                    != null) {
+                throw new MockitoException(
+                        join(
+                                "For "
+                                        + type.getName()
+                                        + ", static mocking is already registered in the current thread",
+                                "",
+                                "To create a new mock, the existing static mock registration must be deregistered"));
+            }
+        }
+
+        @Override
+        public void disable() {
+            if (interceptors.remove(type) == null) {
+                throw new MockitoException(
+                        join(
+                                "Could not deregister "
+                                        + type.getName()
+                                        + " as a static mock since it is not currently registered",
+                                "",
+                                "To register a static mock, use Mockito.mockStatic("
+                                        + type.getSimpleName()
+                                        + ".class)"));
+            }
+            all.clear();
+        }
+
+        @Override
+        @SuppressWarnings("unchecked")
+        public List<T> getMocks() {
+            return (List<T>) all;
+        }
+    }
+
+    private static class InlineConstructionMockContext implements MockedConstruction.Context {
+
+        private static final Map<String, Class<?>> PRIMITIVES = new HashMap<>();
+
+        static {
+            PRIMITIVES.put(boolean.class.getName(), boolean.class);
+            PRIMITIVES.put(byte.class.getName(), byte.class);
+            PRIMITIVES.put(short.class.getName(), short.class);
+            PRIMITIVES.put(char.class.getName(), char.class);
+            PRIMITIVES.put(int.class.getName(), int.class);
+            PRIMITIVES.put(long.class.getName(), long.class);
+            PRIMITIVES.put(float.class.getName(), float.class);
+            PRIMITIVES.put(double.class.getName(), double.class);
+        }
+
+        private int count;
+
+        private final Object[] arguments;
+        private final Class<?> type;
+        private final String[] parameterTypeNames;
+
+        private InlineConstructionMockContext(
+                Object[] arguments, Class<?> type, String[] parameterTypeNames) {
+            this.arguments = arguments;
+            this.type = type;
+            this.parameterTypeNames = parameterTypeNames;
+        }
+
+        @Override
+        public int getCount() {
+            if (count == 0) {
+                throw new MockitoConfigurationException(
+                        "mocked construction context is not initialized");
+            }
+            return count;
+        }
+
+        @Override
+        public Constructor<?> constructor() {
+            Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];
+            int index = 0;
+            for (String parameterTypeName : parameterTypeNames) {
+                if (PRIMITIVES.containsKey(parameterTypeName)) {
+                    parameterTypes[index++] = PRIMITIVES.get(parameterTypeName);
+                } else {
+                    try {
+                        parameterTypes[index++] =
+                                Class.forName(parameterTypeName, false, type.getClassLoader());
+                    } catch (ClassNotFoundException e) {
+                        throw new MockitoException(
+                                "Could not find parameter of type " + parameterTypeName, e);
+                    }
+                }
+            }
+            try {
+                return type.getDeclaredConstructor(parameterTypes);
+            } catch (NoSuchMethodException e) {
+                throw new MockitoException(
+                        join(
+                                "Could not resolve constructor of type",
+                                "",
+                                type.getName(),
+                                "",
+                                "with arguments of types",
+                                Arrays.toString(parameterTypes)),
+                        e);
+            }
+        }
+
+        @Override
+        public List<?> arguments() {
+            return Collections.unmodifiableList(Arrays.asList(arguments));
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockFeatures.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockFeatures.java
index e92495f..ca27be0 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockFeatures.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockFeatures.java
@@ -4,29 +4,40 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import org.mockito.mock.SerializableMode;
-
 import java.util.Collections;
 import java.util.Set;
 
+import org.mockito.mock.SerializableMode;
+import org.mockito.stubbing.Answer;
+
 class MockFeatures<T> {
 
     final Class<T> mockedType;
     final Set<Class<?>> interfaces;
     final SerializableMode serializableMode;
     final boolean stripAnnotations;
+    final Answer defaultAnswer;
 
-    private MockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode, boolean stripAnnotations) {
+    private MockFeatures(
+            Class<T> mockedType,
+            Set<Class<?>> interfaces,
+            SerializableMode serializableMode,
+            boolean stripAnnotations,
+            Answer defaultAnswer) {
         this.mockedType = mockedType;
         this.interfaces = Collections.unmodifiableSet(interfaces);
         this.serializableMode = serializableMode;
         this.stripAnnotations = stripAnnotations;
+        this.defaultAnswer = defaultAnswer;
     }
 
-    public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType,
-                                                       Set<Class<?>> interfaces,
-                                                       SerializableMode serializableMode,
-                                                       boolean stripAnnotations) {
-        return new MockFeatures<T>(mockedType, interfaces, serializableMode, stripAnnotations);
+    public static <T> MockFeatures<T> withMockFeatures(
+            Class<T> mockedType,
+            Set<Class<?>> interfaces,
+            SerializableMode serializableMode,
+            boolean stripAnnotations,
+            Answer defaultAnswer) {
+        return new MockFeatures<T>(
+                mockedType, interfaces, serializableMode, stripAnnotations, defaultAnswer);
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index f39a1a2..580f22b 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -4,59 +4,102 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
+import static net.bytebuddy.matcher.ElementMatchers.isPrivate;
+import static net.bytebuddy.matcher.ElementMatchers.isStatic;
+import static net.bytebuddy.matcher.ElementMatchers.not;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.ref.SoftReference;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.concurrent.Callable;
+import java.util.function.Predicate;
+
+import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.Advice;
+import net.bytebuddy.asm.AsmVisitorWrapper;
+import net.bytebuddy.description.field.FieldDescription;
+import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.description.method.MethodList;
+import net.bytebuddy.description.method.ParameterDescription;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.dynamic.scaffold.MethodGraph;
+import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.bind.annotation.Argument;
 import net.bytebuddy.implementation.bind.annotation.This;
+import net.bytebuddy.implementation.bytecode.StackSize;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
+import net.bytebuddy.jar.asm.Label;
+import net.bytebuddy.jar.asm.MethodVisitor;
+import net.bytebuddy.jar.asm.Opcodes;
+import net.bytebuddy.jar.asm.Type;
+import net.bytebuddy.pool.TypePool;
+import net.bytebuddy.utility.OpenedClassReader;
+
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
 import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
 import org.mockito.internal.invocation.RealMethod;
 import org.mockito.internal.invocation.SerializableMethod;
 import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.internal.invocation.mockref.MockWeakReference;
+import org.mockito.internal.util.concurrent.DetachedThreadLocal;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.Serializable;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.ref.SoftReference;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
+import org.mockito.plugins.MemberAccessor;
 
 public class MockMethodAdvice extends MockMethodDispatcher {
 
-    final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
+    private final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
+    private final DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics;
 
     private final String identifier;
 
     private final SelfCallInfo selfCallInfo = new SelfCallInfo();
     private final MethodGraph.Compiler compiler = MethodGraph.Compiler.Default.forJavaHierarchy();
-    private final WeakConcurrentMap<Class<?>, SoftReference<MethodGraph>> graphs
-        = new WeakConcurrentMap.WithInlinedExpunction<Class<?>, SoftReference<MethodGraph>>();
-
-    public MockMethodAdvice(WeakConcurrentMap<Object, MockMethodInterceptor> interceptors, String identifier) {
+    private final WeakConcurrentMap<Class<?>, SoftReference<MethodGraph>> graphs =
+            new WeakConcurrentMap.WithInlinedExpunction<>();
+
+    private final Predicate<Class<?>> isMockConstruction;
+    private final ConstructionCallback onConstruction;
+
+    public MockMethodAdvice(
+            WeakConcurrentMap<Object, MockMethodInterceptor> interceptors,
+            DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics,
+            String identifier,
+            Predicate<Class<?>> isMockConstruction,
+            ConstructionCallback onConstruction) {
         this.interceptors = interceptors;
+        this.mockedStatics = mockedStatics;
+        this.onConstruction = onConstruction;
         this.identifier = identifier;
+        this.isMockConstruction = isMockConstruction;
     }
 
     @SuppressWarnings("unused")
     @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
-    private static Callable<?> enter(@Identifier String identifier,
-                                     @Advice.This Object mock,
-                                     @Advice.Origin Method origin,
-                                     @Advice.AllArguments Object[] arguments) throws Throwable {
+    private static Callable<?> enter(
+            @Identifier String identifier,
+            @Advice.This Object mock,
+            @Advice.Origin Method origin,
+            @Advice.AllArguments Object[] arguments)
+            throws Throwable {
         MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
-        if (dispatcher == null || !dispatcher.isMocked(mock) || dispatcher.isOverridden(mock, origin)) {
+        if (dispatcher == null
+                || !dispatcher.isMocked(mock)
+                || dispatcher.isOverridden(mock, origin)) {
             return null;
         } else {
             return dispatcher.handle(mock, origin, arguments);
@@ -65,33 +108,15 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
     @SuppressWarnings({"unused", "UnusedAssignment"})
     @Advice.OnMethodExit
-    private static void exit(@Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object returned,
-                             @Advice.Enter Callable<?> mocked) throws Throwable {
+    private static void exit(
+            @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object returned,
+            @Advice.Enter Callable<?> mocked)
+            throws Throwable {
         if (mocked != null) {
             returned = mocked.call();
         }
     }
 
-    static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
-        try {
-            StackTraceElement[] stack = throwable.getStackTrace();
-            int skip = 0;
-            StackTraceElement next;
-            do {
-                next = stack[stack.length - current - ++skip];
-            } while (!next.getClassName().equals(targetType.getName()));
-            int top = stack.length - current - skip;
-            StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
-            System.arraycopy(stack, 0, cleared, 0, top);
-            System.arraycopy(stack, top + skip, cleared, top, current);
-            throwable.setStackTrace(cleared);
-            return throwable;
-        } catch (RuntimeException ignored) {
-            // This should not happen unless someone instrumented or manipulated exception stack traces.
-            return throwable;
-        }
-    }
-
     @Override
     public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
         MockMethodInterceptor interceptor = interceptors.get(instance);
@@ -104,13 +129,37 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         } else {
             realMethod = new RealMethodCall(selfCallInfo, origin, instance, arguments);
         }
-        Throwable t = new Throwable();
-        t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
-        return new ReturnValueWrapper(interceptor.doIntercept(instance,
-                origin,
-                arguments,
-                realMethod,
-                new LocationImpl(t)));
+        return new ReturnValueWrapper(
+                interceptor.doIntercept(
+                        instance,
+                        origin,
+                        arguments,
+                        realMethod,
+                        new LocationImpl(new Throwable(), true)));
+    }
+
+    @Override
+    public Callable<?> handleStatic(Class<?> type, Method origin, Object[] arguments)
+            throws Throwable {
+        Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+        if (interceptors == null || !interceptors.containsKey(type)) {
+            return null;
+        }
+        return new ReturnValueWrapper(
+                interceptors
+                        .get(type)
+                        .doIntercept(
+                                type,
+                                origin,
+                                arguments,
+                                new StaticMethodCall(selfCallInfo, type, origin, arguments),
+                                new LocationImpl(new Throwable(), true)));
+    }
+
+    @Override
+    public Object handleConstruction(
+            Class<?> type, Object object, Object[] arguments, String[] parameterTypeNames) {
+        return onConstruction.apply(type, object, arguments, parameterTypeNames);
     }
 
     @Override
@@ -122,7 +171,16 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
     @Override
     public boolean isMocked(Object instance) {
-        return selfCallInfo.checkSuperCall(instance) && isMock(instance);
+        return selfCallInfo.checkSelfCall(instance) && isMock(instance);
+    }
+
+    @Override
+    public boolean isMockedStatic(Class<?> type) {
+        if (!selfCallInfo.checkSelfCall(type)) {
+            return false;
+        }
+        Map<Class<?>, ?> interceptors = mockedStatics.get();
+        return interceptors != null && interceptors.containsKey(type);
     }
 
     @Override
@@ -131,10 +189,21 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         MethodGraph methodGraph = reference == null ? null : reference.get();
         if (methodGraph == null) {
             methodGraph = compiler.compile(new TypeDescription.ForLoadedType(instance.getClass()));
-            graphs.put(instance.getClass(), new SoftReference<MethodGraph>(methodGraph));
+            graphs.put(instance.getClass(), new SoftReference<>(methodGraph));
         }
-        MethodGraph.Node node = methodGraph.locate(new MethodDescription.ForLoadedMethod(origin).asSignatureToken());
-        return !node.getSort().isResolved() || !node.getRepresentative().asDefined().getDeclaringType().represents(origin.getDeclaringClass());
+        MethodGraph.Node node =
+                methodGraph.locate(
+                        new MethodDescription.ForLoadedMethod(origin).asSignatureToken());
+        return !node.getSort().isResolved()
+                || !node.getRepresentative()
+                        .asDefined()
+                        .getDeclaringType()
+                        .represents(origin.getDeclaringClass());
+    }
+
+    @Override
+    public boolean isConstructorMock(Class<?> type) {
+        return isMockConstruction.test(type);
     }
 
     private static class RealMethodCall implements RealMethod {
@@ -147,10 +216,11 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         private final Object[] arguments;
 
-        private RealMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
+        private RealMethodCall(
+                SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
             this.selfCallInfo = selfCallInfo;
             this.origin = origin;
-            this.instanceRef = new MockWeakReference<Object>(instance);
+            this.instanceRef = new MockWeakReference<>(instance);
             this.arguments = arguments;
         }
 
@@ -161,13 +231,9 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         @Override
         public Object invoke() throws Throwable {
-            if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
-                origin.setAccessible(true);
-            }
             selfCallInfo.set(instanceRef.get());
             return tryInvoke(origin, instanceRef.get(), arguments);
         }
-
     }
 
     private static class SerializableRealMethodCall implements RealMethod {
@@ -180,10 +246,11 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         private final Object[] arguments;
 
-        private SerializableRealMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
+        private SerializableRealMethodCall(
+                String identifier, Method origin, Object instance, Object[] arguments) {
             this.origin = new SerializableMethod(origin);
             this.identifier = identifier;
-            this.instanceRef = new MockWeakReference<Object>(instance);
+            this.instanceRef = new MockWeakReference<>(instance);
             this.arguments = arguments;
         }
 
@@ -195,14 +262,14 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         @Override
         public Object invoke() throws Throwable {
             Method method = origin.getJavaMethod();
-            if (!Modifier.isPublic(method.getDeclaringClass().getModifiers() & method.getModifiers())) {
-                method.setAccessible(true);
-            }
-            MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instanceRef.get());
+            MockMethodDispatcher mockMethodDispatcher =
+                    MockMethodDispatcher.get(identifier, instanceRef.get());
             if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
                 throw new MockitoException("Unexpected dispatcher for advice-based super call");
             }
-            Object previous = ((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.replace(instanceRef.get());
+            Object previous =
+                    ((MockMethodAdvice) mockMethodDispatcher)
+                            .selfCallInfo.replace(instanceRef.get());
             try {
                 return tryInvoke(method, instanceRef.get(), arguments);
             } finally {
@@ -211,29 +278,69 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
-    private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
+    private static class StaticMethodCall implements RealMethod {
+
+        private final SelfCallInfo selfCallInfo;
+
+        private final Class<?> type;
+
+        private final Method origin;
+
+        private final Object[] arguments;
+
+        private StaticMethodCall(
+                SelfCallInfo selfCallInfo, Class<?> type, Method origin, Object[] arguments) {
+            this.selfCallInfo = selfCallInfo;
+            this.type = type;
+            this.origin = origin;
+            this.arguments = arguments;
+        }
+
+        @Override
+        public boolean isInvokable() {
+            return true;
+        }
+
+        @Override
+        public Object invoke() throws Throwable {
+            selfCallInfo.set(type);
+            return tryInvoke(origin, null, arguments);
+        }
+    }
+
+    private static Object tryInvoke(Method origin, Object instance, Object[] arguments)
+            throws Throwable {
+        MemberAccessor accessor = Plugins.getMemberAccessor();
         try {
-            return origin.invoke(instance, arguments);
+            return accessor.invoke(origin, instance, arguments);
         } catch (InvocationTargetException exception) {
             Throwable cause = exception.getCause();
-            new ConditionalStackTraceFilter().filter(hideRecursiveCall(cause, new Throwable().getStackTrace().length, origin.getDeclaringClass()));
+            new ConditionalStackTraceFilter()
+                    .filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
             throw cause;
         }
     }
 
-    // With inline mocking, mocks for concrete classes are not subclassed, so elements of the stubbing methods are not filtered out.
-    // Therefore, if the method is inlined, skip the element.
-    private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
-        List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
-        for (int i = 0; i < elements.length; i++) {
-            StackTraceElement element = elements[i];
-            list.add(element);
-            if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
-                // If the current element is MockMethodAdvice#handle(), the next is assumed to be an inlined method.
-                i++;
+    static Throwable removeRecursiveCalls(final Throwable cause, final Class<?> declaringClass) {
+        final List<String> uniqueStackTraceItems = new ArrayList<>();
+        final List<Integer> indexesToBeRemoved = new ArrayList<>();
+        for (StackTraceElement element : cause.getStackTrace()) {
+            final String key = element.getClassName() + element.getLineNumber();
+            final int elementIndex = uniqueStackTraceItems.lastIndexOf(key);
+            uniqueStackTraceItems.add(key);
+
+            if (elementIndex > -1 && declaringClass.getName().equals(element.getClassName())) {
+                indexesToBeRemoved.add(elementIndex);
             }
         }
-        return list.toArray(new StackTraceElement[list.size()]);
+        final List<StackTraceElement> adjustedList =
+                new ArrayList<>(Arrays.asList(cause.getStackTrace()));
+        indexesToBeRemoved.stream()
+                .sorted(Comparator.reverseOrder())
+                .mapToInt(Integer::intValue)
+                .forEach(adjustedList::remove);
+        cause.setStackTrace(adjustedList.toArray(new StackTraceElement[] {}));
+        return cause;
     }
 
     private static class ReturnValueWrapper implements Callable<Object> {
@@ -258,7 +365,7 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             return current;
         }
 
-        boolean checkSuperCall(Object value) {
+        boolean checkSelfCall(Object value) {
             if (value == get()) {
                 set(null);
                 return false;
@@ -268,26 +375,319 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
-    @Retention(RetentionPolicy.RUNTIME)
-    @interface Identifier {
+    static class ConstructorShortcut
+            implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {
+
+        private final String identifier;
 
+        ConstructorShortcut(String identifier) {
+            this.identifier = identifier;
+        }
+
+        @Override
+        public MethodVisitor wrap(
+                TypeDescription instrumentedType,
+                MethodDescription instrumentedMethod,
+                MethodVisitor methodVisitor,
+                Implementation.Context implementationContext,
+                TypePool typePool,
+                int writerFlags,
+                int readerFlags) {
+            if (instrumentedMethod.isConstructor() && !instrumentedType.represents(Object.class)) {
+                MethodList<MethodDescription.InDefinedShape> constructors =
+                        instrumentedType
+                                .getSuperClass()
+                                .asErasure()
+                                .getDeclaredMethods()
+                                .filter(isConstructor().and(not(isPrivate())));
+                int arguments = Integer.MAX_VALUE;
+                boolean packagePrivate = true;
+                MethodDescription.InDefinedShape current = null;
+                for (MethodDescription.InDefinedShape constructor : constructors) {
+                    // We are choosing the shortest constructor with regards to arguments.
+                    // Yet, we prefer a non-package-private constructor since they require
+                    // the super class to be on the same class loader.
+                    if (constructor.getParameters().size() < arguments
+                            && (packagePrivate || !constructor.isPackagePrivate())) {
+                        arguments = constructor.getParameters().size();
+                        packagePrivate = constructor.isPackagePrivate();
+                        current = constructor;
+                    }
+                }
+                if (current != null) {
+                    final MethodDescription.InDefinedShape selected = current;
+                    return new MethodVisitor(OpenedClassReader.ASM_API, methodVisitor) {
+                        @Override
+                        public void visitCode() {
+                            super.visitCode();
+                            /*
+                             * The byte code that is added to the start of the method is roughly equivalent to
+                             * the following byte code for a hypothetical constructor of class Current:
+                             *
+                             * if (MockMethodDispatcher.isConstructorMock(<identifier>, Current.class) {
+                             *   super(<default arguments>);
+                             *   Current o = (Current) MockMethodDispatcher.handleConstruction(Current.class,
+                             *       this,
+                             *       new Object[] {argument1, argument2, ...},
+                             *       new String[] {argumentType1, argumentType2, ...});
+                             *   if (o != null) {
+                             *     this.field = o.field; // for each declared field
+                             *   }
+                             *   return;
+                             * }
+                             *
+                             * This avoids the invocation of the original constructor chain but fullfils the
+                             * verifier requirement to invoke a super constructor.
+                             */
+                            Label label = new Label();
+                            super.visitLdcInsn(identifier);
+                            if (implementationContext
+                                    .getClassFileVersion()
+                                    .isAtLeast(ClassFileVersion.JAVA_V5)) {
+                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));
+                            } else {
+                                super.visitLdcInsn(instrumentedType.getName());
+                                super.visitMethodInsn(
+                                        Opcodes.INVOKESTATIC,
+                                        Type.getInternalName(Class.class),
+                                        "forName",
+                                        Type.getMethodDescriptor(
+                                                Type.getType(Class.class),
+                                                Type.getType(String.class)),
+                                        false);
+                            }
+                            super.visitMethodInsn(
+                                    Opcodes.INVOKESTATIC,
+                                    Type.getInternalName(MockMethodDispatcher.class),
+                                    "isConstructorMock",
+                                    Type.getMethodDescriptor(
+                                            Type.BOOLEAN_TYPE,
+                                            Type.getType(String.class),
+                                            Type.getType(Class.class)),
+                                    false);
+                            super.visitInsn(Opcodes.ICONST_0);
+                            super.visitJumpInsn(Opcodes.IF_ICMPEQ, label);
+                            super.visitVarInsn(Opcodes.ALOAD, 0);
+                            for (TypeDescription type :
+                                    selected.getParameters().asTypeList().asErasures()) {
+                                if (type.represents(boolean.class)
+                                        || type.represents(byte.class)
+                                        || type.represents(short.class)
+                                        || type.represents(char.class)
+                                        || type.represents(int.class)) {
+                                    super.visitInsn(Opcodes.ICONST_0);
+                                } else if (type.represents(long.class)) {
+                                    super.visitInsn(Opcodes.LCONST_0);
+                                } else if (type.represents(float.class)) {
+                                    super.visitInsn(Opcodes.FCONST_0);
+                                } else if (type.represents(double.class)) {
+                                    super.visitInsn(Opcodes.DCONST_0);
+                                } else {
+                                    super.visitInsn(Opcodes.ACONST_NULL);
+                                }
+                            }
+                            super.visitMethodInsn(
+                                    Opcodes.INVOKESPECIAL,
+                                    selected.getDeclaringType().getInternalName(),
+                                    selected.getInternalName(),
+                                    selected.getDescriptor(),
+                                    false);
+                            super.visitLdcInsn(identifier);
+                            if (implementationContext
+                                    .getClassFileVersion()
+                                    .isAtLeast(ClassFileVersion.JAVA_V5)) {
+                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));
+                            } else {
+                                super.visitLdcInsn(instrumentedType.getName());
+                                super.visitMethodInsn(
+                                        Opcodes.INVOKESTATIC,
+                                        Type.getInternalName(Class.class),
+                                        "forName",
+                                        Type.getMethodDescriptor(
+                                                Type.getType(Class.class),
+                                                Type.getType(String.class)),
+                                        false);
+                            }
+                            super.visitVarInsn(Opcodes.ALOAD, 0);
+                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
+                            super.visitTypeInsn(
+                                    Opcodes.ANEWARRAY, Type.getInternalName(Object.class));
+                            int index = 0;
+                            for (ParameterDescription parameter :
+                                    instrumentedMethod.getParameters()) {
+                                super.visitInsn(Opcodes.DUP);
+                                super.visitLdcInsn(index++);
+                                Type type =
+                                        Type.getType(
+                                                parameter.getType().asErasure().getDescriptor());
+                                super.visitVarInsn(
+                                        type.getOpcode(Opcodes.ILOAD), parameter.getOffset());
+                                if (parameter.getType().isPrimitive()) {
+                                    Type wrapper =
+                                            Type.getType(
+                                                    parameter
+                                                            .getType()
+                                                            .asErasure()
+                                                            .asBoxed()
+                                                            .getDescriptor());
+                                    super.visitMethodInsn(
+                                            Opcodes.INVOKESTATIC,
+                                            wrapper.getInternalName(),
+                                            "valueOf",
+                                            Type.getMethodDescriptor(wrapper, type),
+                                            false);
+                                }
+                                super.visitInsn(Opcodes.AASTORE);
+                            }
+                            index = 0;
+                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
+                            super.visitTypeInsn(
+                                    Opcodes.ANEWARRAY, Type.getInternalName(String.class));
+                            for (TypeDescription typeDescription :
+                                    instrumentedMethod.getParameters().asTypeList().asErasures()) {
+                                super.visitInsn(Opcodes.DUP);
+                                super.visitLdcInsn(index++);
+                                super.visitLdcInsn(typeDescription.getName());
+                                super.visitInsn(Opcodes.AASTORE);
+                            }
+                            super.visitMethodInsn(
+                                    Opcodes.INVOKESTATIC,
+                                    Type.getInternalName(MockMethodDispatcher.class),
+                                    "handleConstruction",
+                                    Type.getMethodDescriptor(
+                                            Type.getType(Object.class),
+                                            Type.getType(String.class),
+                                            Type.getType(Class.class),
+                                            Type.getType(Object.class),
+                                            Type.getType(Object[].class),
+                                            Type.getType(String[].class)),
+                                    false);
+                            FieldList<FieldDescription.InDefinedShape> fields =
+                                    instrumentedType.getDeclaredFields().filter(not(isStatic()));
+                            super.visitTypeInsn(
+                                    Opcodes.CHECKCAST, instrumentedType.getInternalName());
+                            super.visitInsn(Opcodes.DUP);
+                            Label noSpy = new Label();
+                            super.visitJumpInsn(Opcodes.IFNULL, noSpy);
+                            for (FieldDescription field : fields) {
+                                super.visitInsn(Opcodes.DUP);
+                                super.visitFieldInsn(
+                                        Opcodes.GETFIELD,
+                                        instrumentedType.getInternalName(),
+                                        field.getInternalName(),
+                                        field.getDescriptor());
+                                super.visitVarInsn(Opcodes.ALOAD, 0);
+                                super.visitInsn(
+                                        field.getType().getStackSize() == StackSize.DOUBLE
+                                                ? Opcodes.DUP_X2
+                                                : Opcodes.DUP_X1);
+                                super.visitInsn(Opcodes.POP);
+                                super.visitFieldInsn(
+                                        Opcodes.PUTFIELD,
+                                        instrumentedType.getInternalName(),
+                                        field.getInternalName(),
+                                        field.getDescriptor());
+                            }
+                            super.visitLabel(noSpy);
+                            if (implementationContext
+                                    .getClassFileVersion()
+                                    .isAtLeast(ClassFileVersion.JAVA_V6)) {
+                                Object[] locals =
+                                        toFrames(
+                                                instrumentedType.getInternalName(),
+                                                instrumentedMethod
+                                                        .getParameters()
+                                                        .asTypeList()
+                                                        .asErasures());
+                                super.visitFrame(
+                                        Opcodes.F_FULL,
+                                        locals.length,
+                                        locals,
+                                        1,
+                                        new Object[] {instrumentedType.getInternalName()});
+                            }
+                            super.visitInsn(Opcodes.POP);
+                            super.visitInsn(Opcodes.RETURN);
+                            super.visitLabel(label);
+                            if (implementationContext
+                                    .getClassFileVersion()
+                                    .isAtLeast(ClassFileVersion.JAVA_V6)) {
+                                Object[] locals =
+                                        toFrames(
+                                                Opcodes.UNINITIALIZED_THIS,
+                                                instrumentedMethod
+                                                        .getParameters()
+                                                        .asTypeList()
+                                                        .asErasures());
+                                super.visitFrame(
+                                        Opcodes.F_FULL, locals.length, locals, 0, new Object[0]);
+                            }
+                        }
+
+                        @Override
+                        public void visitMaxs(int maxStack, int maxLocals) {
+                            int prequel = Math.max(5, selected.getStackSize());
+                            for (ParameterDescription parameter :
+                                    instrumentedMethod.getParameters()) {
+                                prequel =
+                                        Math.max(
+                                                prequel,
+                                                6 + parameter.getType().getStackSize().getSize());
+                                prequel = Math.max(prequel, 8);
+                            }
+                            super.visitMaxs(Math.max(maxStack, prequel), maxLocals);
+                        }
+                    };
+                }
+            }
+            return methodVisitor;
+        }
+
+        private static Object[] toFrames(Object self, List<TypeDescription> types) {
+            Object[] frames = new Object[1 + types.size()];
+            frames[0] = self;
+            int index = 0;
+            for (TypeDescription type : types) {
+                Object frame;
+                if (type.represents(boolean.class)
+                        || type.represents(byte.class)
+                        || type.represents(short.class)
+                        || type.represents(char.class)
+                        || type.represents(int.class)) {
+                    frame = Opcodes.INTEGER;
+                } else if (type.represents(long.class)) {
+                    frame = Opcodes.LONG;
+                } else if (type.represents(float.class)) {
+                    frame = Opcodes.FLOAT;
+                } else if (type.represents(double.class)) {
+                    frame = Opcodes.DOUBLE;
+                } else {
+                    frame = type.getInternalName();
+                }
+                frames[++index] = frame;
+            }
+            return frames;
+        }
     }
 
+    @Retention(RetentionPolicy.RUNTIME)
+    @interface Identifier {}
+
     static class ForHashCode {
 
         @SuppressWarnings("unused")
         @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
-        private static boolean enter(@Identifier String id,
-                                     @Advice.This Object self) {
+        private static boolean enter(@Identifier String id, @Advice.This Object self) {
             MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
             return dispatcher != null && dispatcher.isMock(self);
         }
 
         @SuppressWarnings({"unused", "UnusedAssignment"})
         @Advice.OnMethodExit
-        private static void enter(@Advice.This Object self,
-                                  @Advice.Return(readOnly = false) int hashCode,
-                                  @Advice.Enter boolean skipped) {
+        private static void enter(
+                @Advice.This Object self,
+                @Advice.Return(readOnly = false) int hashCode,
+                @Advice.Enter boolean skipped) {
             if (skipped) {
                 hashCode = System.identityHashCode(self);
             }
@@ -298,32 +698,65 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         @SuppressWarnings("unused")
         @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
-        private static boolean enter(@Identifier String identifier,
-                                     @Advice.This Object self) {
+        private static boolean enter(@Identifier String identifier, @Advice.This Object self) {
             MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
             return dispatcher != null && dispatcher.isMock(self);
         }
 
         @SuppressWarnings({"unused", "UnusedAssignment"})
         @Advice.OnMethodExit
-        private static void enter(@Advice.This Object self,
-                                  @Advice.Argument(0) Object other,
-                                  @Advice.Return(readOnly = false) boolean equals,
-                                  @Advice.Enter boolean skipped) {
+        private static void enter(
+                @Advice.This Object self,
+                @Advice.Argument(0) Object other,
+                @Advice.Return(readOnly = false) boolean equals,
+                @Advice.Enter boolean skipped) {
             if (skipped) {
                 equals = self == other;
             }
         }
     }
 
-    public static class ForReadObject {
+    static class ForStatic {
 
         @SuppressWarnings("unused")
-        public static void doReadObject(@Identifier String identifier,
-                                        @This MockAccess thiz,
-                                        @Argument(0) ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
+        @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
+        private static Callable<?> enter(
+                @Identifier String identifier,
+                @Advice.Origin Class<?> type,
+                @Advice.Origin Method origin,
+                @Advice.AllArguments Object[] arguments)
+                throws Throwable {
+            MockMethodDispatcher dispatcher = MockMethodDispatcher.getStatic(identifier, type);
+            if (dispatcher == null || !dispatcher.isMockedStatic(type)) {
+                return null;
+            } else {
+                return dispatcher.handleStatic(type, origin, arguments);
+            }
+        }
+
+        @SuppressWarnings({"unused", "UnusedAssignment"})
+        @Advice.OnMethodExit
+        private static void exit(
+                @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object returned,
+                @Advice.Enter Callable<?> mocked)
+                throws Throwable {
+            if (mocked != null) {
+                returned = mocked.call();
+            }
+        }
+    }
+
+    public static class ForReadObject {
+
+        @SuppressWarnings({"unused", "BanSerializableRead"})
+        public static void doReadObject(
+                @Identifier String identifier,
+                @This MockAccess thiz,
+                @Argument(0) ObjectInputStream objectInputStream)
+                throws IOException, ClassNotFoundException {
             objectInputStream.defaultReadObject();
-            MockMethodAdvice mockMethodAdvice = (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
+            MockMethodAdvice mockMethodAdvice =
+                    (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
             if (mockMethodAdvice != null) {
                 mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
             }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.java
deleted file mode 100644
index 1bf4cce..0000000
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2016 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.bytebuddy;
-
-import java.lang.reflect.Method;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-
-public abstract class MockMethodDispatcher {
-
-    private static final ConcurrentMap<String, MockMethodDispatcher> INSTANCE = new ConcurrentHashMap<String, MockMethodDispatcher>();
-
-    public static MockMethodDispatcher get(String identifier, Object mock) {
-        if (mock == INSTANCE) { // Avoid endless loop if ConcurrentHashMap was redefined to check for being a mock.
-            return null;
-        } else {
-            return INSTANCE.get(identifier);
-        }
-    }
-
-    public static void set(String identifier, MockMethodDispatcher dispatcher) {
-        INSTANCE.putIfAbsent(identifier, dispatcher);
-    }
-
-    public abstract Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable;
-
-    public abstract boolean isMock(Object instance);
-
-    public abstract boolean isMocked(Object instance);
-
-    public abstract boolean isOverridden(Object instance, Method origin);
-}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
index 9066927..83908ca 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
@@ -4,6 +4,15 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static org.mockito.internal.invocation.DefaultInvocationFactory.createInvocation;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.util.concurrent.Callable;
+
 import net.bytebuddy.implementation.bind.annotation.AllArguments;
 import net.bytebuddy.implementation.bind.annotation.Argument;
 import net.bytebuddy.implementation.bind.annotation.BindingPriority;
@@ -19,13 +28,6 @@ import org.mockito.invocation.Location;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.util.concurrent.Callable;
-
-import static org.mockito.internal.invocation.DefaultInvocationFactory.createInvocation;
-
 public class MockMethodInterceptor implements Serializable {
 
     private static final long serialVersionUID = 7152947254057253027L;
@@ -36,31 +38,58 @@ public class MockMethodInterceptor implements Serializable {
 
     private final ByteBuddyCrossClassLoaderSerializationSupport serializationSupport;
 
+    private transient ThreadLocal<Object> weakReferenceHatch = new ThreadLocal<>();
+
     public MockMethodInterceptor(MockHandler handler, MockCreationSettings mockCreationSettings) {
         this.handler = handler;
         this.mockCreationSettings = mockCreationSettings;
         serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport();
     }
 
-    Object doIntercept(Object mock,
-                       Method invokedMethod,
-                       Object[] arguments,
-                       RealMethod realMethod) throws Throwable {
-        return doIntercept(
-                mock,
-                invokedMethod,
-                arguments,
-            realMethod,
-                new LocationImpl()
-        );
+    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
+        stream.defaultReadObject();
+        weakReferenceHatch = new ThreadLocal<>();
     }
 
-    Object doIntercept(Object mock,
-                       Method invokedMethod,
-                       Object[] arguments,
-                       RealMethod realMethod,
-                       Location location) throws Throwable {
-        return handler.handle(createInvocation(mock, invokedMethod, arguments, realMethod, mockCreationSettings, location));
+    Object doIntercept(Object mock, Method invokedMethod, Object[] arguments, RealMethod realMethod)
+            throws Throwable {
+        return doIntercept(mock, invokedMethod, arguments, realMethod, new LocationImpl());
+    }
+
+    Object doIntercept(
+            Object mock,
+            Method invokedMethod,
+            Object[] arguments,
+            RealMethod realMethod,
+            Location location)
+            throws Throwable {
+        // If the currently dispatched method is used in a hot path, typically a tight loop and if
+        // the mock is not used after the currently dispatched method, the JVM might attempt a
+        // garbage collection of the mock instance even before the execution of the current
+        // method is completed. Since we only reference the mock weakly from hereon after to avoid
+        // leaking the instance, it might therefore be garbage collected before the
+        // handler.handle(...) method completes. Since the handler method expects the mock to be
+        // present while a method call onto the mock is dispatched, this can lead to the problem
+        // described in GitHub #1802.
+        //
+        // To avoid this problem, we distract the JVM JIT by escaping the mock instance to a thread
+        // local field for the duration of the handler's dispatch.
+        //
+        // When dropping support for Java 8, instead of this hatch we should use an explicit fence
+        // https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Reference.html#reachabilityFence-java.lang.Object-
+        weakReferenceHatch.set(mock);
+        try {
+            return handler.handle(
+                    createInvocation(
+                            mock,
+                            invokedMethod,
+                            arguments,
+                            realMethod,
+                            mockCreationSettings,
+                            location));
+        } finally {
+            weakReferenceHatch.remove();
+        }
     }
 
     public MockHandler getMockHandler() {
@@ -71,12 +100,14 @@ public class MockMethodInterceptor implements Serializable {
         return serializationSupport;
     }
 
-    public static class ForHashCode {
+    public static final class ForHashCode {
 
         @SuppressWarnings("unused")
         public static int doIdentityHashCode(@This Object thiz) {
             return System.identityHashCode(thiz);
         }
+
+        private ForHashCode() {}
     }
 
     public static class ForEquals {
@@ -87,11 +118,13 @@ public class MockMethodInterceptor implements Serializable {
         }
     }
 
-    public static class ForWriteReplace {
+    public static final class ForWriteReplace {
 
         public static Object doWriteReplace(@This MockAccess thiz) throws ObjectStreamException {
             return thiz.getMockitoInterceptor().getSerializationSupport().writeReplace(thiz);
         }
+
+        private ForWriteReplace() {}
     }
 
     public static class DispatcherDefaultingToRealMethod {
@@ -99,38 +132,34 @@ public class MockMethodInterceptor implements Serializable {
         @SuppressWarnings("unused")
         @RuntimeType
         @BindingPriority(BindingPriority.DEFAULT * 2)
-        public static Object interceptSuperCallable(@This Object mock,
-                                                    @FieldValue("mockitoInterceptor") MockMethodInterceptor interceptor,
-                                                    @Origin Method invokedMethod,
-                                                    @AllArguments Object[] arguments,
-                                                    @SuperCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
+        public static Object interceptSuperCallable(
+                @This Object mock,
+                @FieldValue("mockitoInterceptor") MockMethodInterceptor interceptor,
+                @Origin Method invokedMethod,
+                @AllArguments Object[] arguments,
+                @SuperCall(serializableProxy = true) Callable<?> superCall)
+                throws Throwable {
             if (interceptor == null) {
                 return superCall.call();
             }
             return interceptor.doIntercept(
-                    mock,
-                    invokedMethod,
-                    arguments,
-                    new RealMethod.FromCallable(superCall)
-            );
+                    mock, invokedMethod, arguments, new RealMethod.FromCallable(superCall));
         }
 
         @SuppressWarnings("unused")
         @RuntimeType
-        public static Object interceptAbstract(@This Object mock,
-                                               @FieldValue("mockitoInterceptor") MockMethodInterceptor interceptor,
-                                               @StubValue Object stubValue,
-                                               @Origin Method invokedMethod,
-                                               @AllArguments Object[] arguments) throws Throwable {
+        public static Object interceptAbstract(
+                @This Object mock,
+                @FieldValue("mockitoInterceptor") MockMethodInterceptor interceptor,
+                @StubValue Object stubValue,
+                @Origin Method invokedMethod,
+                @AllArguments Object[] arguments)
+                throws Throwable {
             if (interceptor == null) {
                 return stubValue;
             }
             return interceptor.doIntercept(
-                    mock,
-                    invokedMethod,
-                    arguments,
-                    RealMethod.IsIllegal.INSTANCE
-            );
+                    mock, invokedMethod, arguments, RealMethod.IsIllegal.INSTANCE);
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/ModuleHandler.java b/src/main/java/org/mockito/internal/creation/bytebuddy/ModuleHandler.java
new file mode 100644
index 0000000..38716d0
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/ModuleHandler.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (c) 2016 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy;
+
+import static net.bytebuddy.matcher.ElementMatchers.isTypeInitializer;
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Random;
+
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.description.modifier.Ownership;
+import net.bytebuddy.description.modifier.Visibility;
+import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
+import net.bytebuddy.implementation.Implementation;
+import net.bytebuddy.implementation.MethodCall;
+import net.bytebuddy.implementation.StubMethod;
+import org.mockito.codegen.InjectionBase;
+import org.mockito.exceptions.base.MockitoException;
+
+abstract class ModuleHandler {
+
+    abstract boolean isOpened(Class<?> source, Class<?> target);
+
+    abstract boolean canRead(Class<?> source, Class<?> target);
+
+    abstract boolean isExported(Class<?> source);
+
+    abstract boolean isExported(Class<?> source, Class<?> target);
+
+    abstract Class<?> injectionBase(ClassLoader classLoader, String tyoeName);
+
+    abstract void adjustModuleGraph(Class<?> source, Class<?> target, boolean export, boolean read);
+
+    static ModuleHandler make(ByteBuddy byteBuddy, SubclassLoader loader, Random random) {
+        try {
+            return new ModuleSystemFound(byteBuddy, loader, random);
+        } catch (Exception ignored) {
+            return new NoModuleSystemFound();
+        }
+    }
+
+    private static class ModuleSystemFound extends ModuleHandler {
+
+        private final ByteBuddy byteBuddy;
+        private final SubclassLoader loader;
+        private final Random random;
+
+        private final int injectonBaseSuffix;
+
+        private final Method getModule,
+                isOpen,
+                isExported,
+                isExportedUnqualified,
+                canRead,
+                addExports,
+                addReads,
+                addOpens,
+                forName;
+
+        private ModuleSystemFound(ByteBuddy byteBuddy, SubclassLoader loader, Random random)
+                throws Exception {
+            this.byteBuddy = byteBuddy;
+            this.loader = loader;
+            this.random = random;
+            injectonBaseSuffix = Math.abs(random.nextInt());
+            Class<?> moduleType = Class.forName("java.lang.Module");
+            getModule = Class.class.getMethod("getModule");
+            isOpen = moduleType.getMethod("isOpen", String.class, moduleType);
+            isExported = moduleType.getMethod("isExported", String.class, moduleType);
+            isExportedUnqualified = moduleType.getMethod("isExported", String.class);
+            canRead = moduleType.getMethod("canRead", moduleType);
+            addExports = moduleType.getMethod("addExports", String.class, moduleType);
+            addReads = moduleType.getMethod("addReads", moduleType);
+            addOpens = moduleType.getMethod("addOpens", String.class, moduleType);
+            forName = Class.class.getMethod("forName", String.class);
+        }
+
+        @Override
+        boolean isOpened(Class<?> source, Class<?> target) {
+            if (source.getPackage() == null) {
+                return true;
+            }
+            return (Boolean)
+                    invoke(
+                            isOpen,
+                            invoke(getModule, source),
+                            source.getPackage().getName(),
+                            invoke(getModule, target));
+        }
+
+        @Override
+        boolean canRead(Class<?> source, Class<?> target) {
+            return (Boolean) invoke(canRead, invoke(getModule, source), invoke(getModule, target));
+        }
+
+        @Override
+        boolean isExported(Class<?> source) {
+            if (source.getPackage() == null) {
+                return true;
+            }
+            return (Boolean)
+                    invoke(
+                            isExportedUnqualified,
+                            invoke(getModule, source),
+                            source.getPackage().getName());
+        }
+
+        @Override
+        boolean isExported(Class<?> source, Class<?> target) {
+            if (source.getPackage() == null) {
+                return true;
+            }
+            return (Boolean)
+                    invoke(
+                            isExported,
+                            invoke(getModule, source),
+                            source.getPackage().getName(),
+                            invoke(getModule, target));
+        }
+
+        @Override
+        Class<?> injectionBase(ClassLoader classLoader, String typeName) {
+            String packageName = typeName.substring(0, typeName.lastIndexOf('.'));
+            if (classLoader == InjectionBase.class.getClassLoader()
+                    && InjectionBase.class.getPackage().getName().equals(packageName)) {
+                return InjectionBase.class;
+            } else {
+                synchronized (this) {
+                    String name;
+                    int suffix = injectonBaseSuffix;
+                    do {
+                        name =
+                                packageName
+                                        + "."
+                                        + InjectionBase.class.getSimpleName()
+                                        + "$"
+                                        + suffix++;
+                        try {
+                            Class<?> type = Class.forName(name, false, classLoader);
+                            // The injected type must be defined in the class loader that is target
+                            // of the injection. Otherwise,
+                            // the class's unnamed module would differ from the intended module. To
+                            // avoid conflicts, we increment
+                            // the suffix until we hit a class with a known name and generate one if
+                            // it does not exist.
+                            if (type.getClassLoader() == classLoader) {
+                                return type;
+                            }
+                        } catch (ClassNotFoundException ignored) {
+                            break;
+                        }
+                    } while (true);
+                    return byteBuddy
+                            .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)
+                            .name(name)
+                            .make()
+                            .load(
+                                    classLoader,
+                                    loader.resolveStrategy(InjectionBase.class, classLoader, false))
+                            .getLoaded();
+                }
+            }
+        }
+
+        @Override
+        void adjustModuleGraph(Class<?> source, Class<?> target, boolean export, boolean read) {
+            boolean needsExport = export && !isExported(source, target);
+            boolean needsRead = read && !canRead(source, target);
+            if (!needsExport && !needsRead) {
+                return;
+            }
+            ClassLoader classLoader = source.getClassLoader();
+            if (classLoader == null) {
+                throw new MockitoException(
+                        join(
+                                "Cannot adjust module graph for modules in the bootstrap loader",
+                                "",
+                                source
+                                        + " is declared by the bootstrap loader and cannot be adjusted",
+                                "Requires package export to " + target + ": " + needsExport,
+                                "Requires adjusted reading of " + target + ": " + needsRead));
+            }
+            boolean targetVisible = classLoader == target.getClassLoader();
+            while (!targetVisible && classLoader != null) {
+                classLoader = classLoader.getParent();
+                targetVisible = classLoader == target.getClassLoader();
+            }
+            MethodCall targetLookup;
+            Implementation.Composable implementation;
+            if (targetVisible) {
+                targetLookup =
+                        MethodCall.invoke(getModule)
+                                .onMethodCall(MethodCall.invoke(forName).with(target.getName()));
+                implementation = StubMethod.INSTANCE;
+            } else {
+                Class<?> intermediate;
+                Field field;
+                try {
+                    intermediate =
+                            byteBuddy
+                                    .subclass(
+                                            Object.class,
+                                            ConstructorStrategy.Default.NO_CONSTRUCTORS)
+                                    .name(
+                                            String.format(
+                                                    "%s$%d",
+                                                    "org.mockito.codegen.MockitoTypeCarrier",
+                                                    Math.abs(random.nextInt())))
+                                    .defineField(
+                                            "mockitoType",
+                                            Class.class,
+                                            Visibility.PUBLIC,
+                                            Ownership.STATIC)
+                                    .make()
+                                    .load(
+                                            source.getClassLoader(),
+                                            loader.resolveStrategy(
+                                                    source, source.getClassLoader(), false))
+                                    .getLoaded();
+                    field = intermediate.getField("mockitoType");
+                    field.set(null, target);
+                } catch (Exception e) {
+                    throw new MockitoException(
+                            join(
+                                    "Could not create a carrier for making the Mockito type visible to "
+                                            + source,
+                                    "",
+                                    "This is required to adjust the module graph to enable mock creation"),
+                            e);
+                }
+                targetLookup = MethodCall.invoke(getModule).onField(field);
+                implementation =
+                        MethodCall.invoke(getModule)
+                                .onMethodCall(
+                                        MethodCall.invoke(forName).with(intermediate.getName()));
+            }
+            MethodCall sourceLookup =
+                    MethodCall.invoke(getModule)
+                            .onMethodCall(MethodCall.invoke(forName).with(source.getName()));
+            if (needsExport) {
+                implementation =
+                        implementation.andThen(
+                                MethodCall.invoke(addExports)
+                                        .onMethodCall(sourceLookup)
+                                        .with(target.getPackage().getName())
+                                        .withMethodCall(targetLookup));
+            }
+            if (needsRead) {
+                implementation =
+                        implementation.andThen(
+                                MethodCall.invoke(addReads)
+                                        .onMethodCall(sourceLookup)
+                                        .withMethodCall(targetLookup));
+            }
+            try {
+                Class.forName(
+                        byteBuddy
+                                .subclass(Object.class)
+                                .name(
+                                        String.format(
+                                                "%s$%s$%d",
+                                                source.getName(),
+                                                "MockitoModuleProbe",
+                                                Math.abs(random.nextInt())))
+                                .invokable(isTypeInitializer())
+                                .intercept(implementation)
+                                .make()
+                                .load(
+                                        source.getClassLoader(),
+                                        loader.resolveStrategy(
+                                                source, source.getClassLoader(), false))
+                                .getLoaded()
+                                .getName(),
+                        true,
+                        source.getClassLoader());
+            } catch (Exception e) {
+                throw new MockitoException(
+                        join(
+                                "Could not force module adjustment of the module of " + source,
+                                "",
+                                "This is required to adjust the module graph to enable mock creation"),
+                        e);
+            }
+        }
+
+        private static Object invoke(Method method, Object target, Object... args) {
+            try {
+                return method.invoke(target, args);
+            } catch (Exception e) {
+                throw new MockitoException(
+                        join(
+                                "Could not invoke " + method + " using reflection",
+                                "",
+                                "Mockito attempted to interact with the Java module system but an unexpected method behavior was encountered"),
+                        e);
+            }
+        }
+    }
+
+    private static class NoModuleSystemFound extends ModuleHandler {
+
+        @Override
+        boolean isOpened(Class<?> source, Class<?> target) {
+            return true;
+        }
+
+        @Override
+        boolean canRead(Class<?> source, Class<?> target) {
+            return true;
+        }
+
+        @Override
+        boolean isExported(Class<?> source) {
+            return true;
+        }
+
+        @Override
+        boolean isExported(Class<?> source, Class<?> target) {
+            return true;
+        }
+
+        @Override
+        Class<?> injectionBase(ClassLoader classLoader, String tyoeName) {
+            return InjectionBase.class;
+        }
+
+        @Override
+        void adjustModuleGraph(Class<?> source, Class<?> target, boolean export, boolean read) {
+            // empty
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
index 79e89f2..533e287 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
@@ -4,17 +4,17 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.lang.reflect.Modifier;
+
+import org.mockito.creation.instance.Instantiator;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.configuration.plugins.Plugins;
-import org.mockito.creation.instance.Instantiator;
 import org.mockito.internal.util.Platform;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
-import java.lang.reflect.Modifier;
-
-import static org.mockito.internal.util.StringUtil.join;
-
 /**
  * Subclass based mock maker.
  *
@@ -34,7 +34,8 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
     }
 
     public SubclassByteBuddyMockMaker(SubclassLoader loader) {
-        cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(loader), false);
+        cachingMockBytecodeGenerator =
+                new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(loader), false);
     }
 
     @Override
@@ -50,36 +51,43 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
 
             return ensureMockIsAssignableToMockedType(settings, mockInstance);
         } catch (ClassCastException cce) {
-            throw new MockitoException(join(
-                    "ClassCastException occurred while creating the mockito mock :",
-                    "  class to mock : " + describeClass(settings.getTypeToMock()),
-                    "  created class : " + describeClass(mockedProxyType),
-                    "  proxy instance class : " + describeClass(mockInstance),
-                    "  instance creation by : " + instantiator.getClass().getSimpleName(),
-                    "",
-                    "You might experience classloading issues, please ask the mockito mailing-list.",
-                    ""
-            ), cce);
+            throw new MockitoException(
+                    join(
+                            "ClassCastException occurred while creating the mockito mock :",
+                            "  class to mock : " + describeClass(settings.getTypeToMock()),
+                            "  created class : " + describeClass(mockedProxyType),
+                            "  proxy instance class : " + describeClass(mockInstance),
+                            "  instance creation by : " + instantiator.getClass().getSimpleName(),
+                            "",
+                            "You might experience classloading issues, please ask the mockito mailing-list.",
+                            ""),
+                    cce);
         } catch (org.mockito.creation.instance.InstantiationException e) {
-            throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
+            throw new MockitoException(
+                    "Unable to create mock instance of type '"
+                            + mockedProxyType.getSuperclass().getSimpleName()
+                            + "'",
+                    e);
         }
     }
 
     @Override
     public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
         try {
-            return cachingMockBytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
-                    settings.getTypeToMock(),
-                    settings.getExtraInterfaces(),
-                    settings.getSerializableMode(),
-                    settings.isStripAnnotations()
-            ));
+            return cachingMockBytecodeGenerator.mockClass(
+                    MockFeatures.withMockFeatures(
+                            settings.getTypeToMock(),
+                            settings.getExtraInterfaces(),
+                            settings.getSerializableMode(),
+                            settings.isStripAnnotations(),
+                            settings.getDefaultAnswer()));
         } catch (Exception bytecodeGenerationFailed) {
             throw prettifyFailure(settings, bytecodeGenerationFailed);
         }
     }
 
-    private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {
+    private static <T> T ensureMockIsAssignableToMockedType(
+            MockCreationSettings<T> settings, T mock) {
         // Force explicit cast to mocked type here, instead of
         // relying on the JVM to implicitly cast on the client call site.
         // This allows us to catch earlier the ClassCastException earlier
@@ -87,38 +95,49 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
         return typeToMock.cast(mock);
     }
 
-    private <T> RuntimeException prettifyFailure(MockCreationSettings<T> mockFeatures, Exception generationFailed) {
+    private <T> RuntimeException prettifyFailure(
+            MockCreationSettings<T> mockFeatures, Exception generationFailed) {
         if (mockFeatures.getTypeToMock().isArray()) {
-            throw new MockitoException(join(
-                    "Mockito cannot mock arrays: " + mockFeatures.getTypeToMock() + ".",
-                    ""
-                    ), generationFailed);
+            throw new MockitoException(
+                    join("Mockito cannot mock arrays: " + mockFeatures.getTypeToMock() + ".", ""),
+                    generationFailed);
         }
         if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
-            throw new MockitoException(join(
-                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                    "Most likely it is due to mocking a private class that is not visible to Mockito",
-                    ""
-            ), generationFailed);
+            throw new MockitoException(
+                    join(
+                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                            "Most likely it is due to mocking a private class that is not visible to Mockito",
+                            ""),
+                    generationFailed);
         }
-        throw new MockitoException(join(
-                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                "",
-                "Mockito can only mock non-private & non-final classes.",
-                "If you're not sure why you're getting this error, please report to the mailing list.",
-                "",
-                Platform.warnForVM(
-                        "IBM J9 VM", "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
-                        "Hotspot", Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : ""
-                ),
-                Platform.describe(),
-                "",
-                "Underlying exception : " + generationFailed
-        ), generationFailed);
+        throw new MockitoException(
+                join(
+                        "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                        "",
+                        "Mockito can only mock non-private & non-final classes.",
+                        "If you're not sure why you're getting this error, please report to the mailing list.",
+                        "",
+                        Platform.warnForVM(
+                                "IBM J9 VM",
+                                "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
+                                "Hotspot",
+                                Platform.isJava8BelowUpdate45()
+                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
+                                        : ""),
+                        Platform.describe(),
+                        "",
+                        "Underlying exception : " + generationFailed),
+                generationFailed);
     }
 
     private static String describeClass(Class<?> type) {
-        return type == null ? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
+        return type == null
+                ? "null"
+                : "'"
+                        + type.getCanonicalName()
+                        + "', loaded by classloader : '"
+                        + type.getClassLoader()
+                        + "'";
     }
 
     private static String describeClass(Object instance) {
@@ -135,9 +154,7 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
 
     @Override
     public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        ((MockAccess) mock).setMockitoInterceptor(
-                new MockMethodInterceptor(newHandler, settings)
-        );
+        ((MockAccess) mock).setMockitoInterceptor(new MockMethodInterceptor(newHandler, settings));
     }
 
     @Override
@@ -145,12 +162,14 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
         return new TypeMockability() {
             @Override
             public boolean mockable() {
-                return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
+                return !type.isPrimitive()
+                        && !Modifier.isFinal(type.getModifiers())
+                        && !TypeSupport.INSTANCE.isSealed(type);
             }
 
             @Override
             public String nonMockableReason() {
-                if(mockable()) {
+                if (mockable()) {
                     return "";
                 }
                 if (type.isPrimitive()) {
@@ -159,8 +178,16 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
                 if (Modifier.isFinal(type.getModifiers())) {
                     return "final class";
                 }
+                if (TypeSupport.INSTANCE.isSealed(type)) {
+                    return "sealed class";
+                }
                 return join("not handled type");
             }
         };
     }
+
+    @Override
+    public void clearAllCaches() {
+        cachingMockBytecodeGenerator.clearAllCaches();
+    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index b659c73..f67fdfc 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -4,6 +4,35 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static java.lang.Thread.currentThread;
+import static net.bytebuddy.description.modifier.Visibility.PRIVATE;
+import static net.bytebuddy.dynamic.Transformer.ForMethod.withModifiers;
+import static net.bytebuddy.implementation.MethodDelegation.to;
+import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER;
+import static net.bytebuddy.matcher.ElementMatchers.any;
+import static net.bytebuddy.matcher.ElementMatchers.hasParameters;
+import static net.bytebuddy.matcher.ElementMatchers.hasType;
+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;
+import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;
+import static net.bytebuddy.matcher.ElementMatchers.isEquals;
+import static net.bytebuddy.matcher.ElementMatchers.isHashCode;
+import static net.bytebuddy.matcher.ElementMatchers.isPackagePrivate;
+import static net.bytebuddy.matcher.ElementMatchers.named;
+import static net.bytebuddy.matcher.ElementMatchers.returns;
+import static net.bytebuddy.matcher.ElementMatchers.whereAny;
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Random;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.modifier.SynchronizationState;
@@ -15,36 +44,20 @@ import net.bytebuddy.implementation.FieldAccessor;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
 import net.bytebuddy.matcher.ElementMatcher;
+import org.mockito.codegen.InjectionBase;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
 import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.DispatcherDefaultingToRealMethod;
 import org.mockito.mock.SerializableMode;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Random;
-
-import static java.lang.Thread.currentThread;
-import static net.bytebuddy.description.modifier.Visibility.PRIVATE;
-import static net.bytebuddy.dynamic.Transformer.ForMethod.withModifiers;
-import static net.bytebuddy.implementation.MethodDelegation.to;
-import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER;
-import static net.bytebuddy.matcher.ElementMatchers.*;
-import static org.mockito.internal.util.StringUtil.join;
-
 class SubclassBytecodeGenerator implements BytecodeGenerator {
 
     private static final String CODEGEN_PACKAGE = "org.mockito.codegen.";
 
     private final SubclassLoader loader;
-
+    private final ModuleHandler handler;
     private final ByteBuddy byteBuddy;
     private final Random random;
-
     private final Implementation readReplace;
     private final ElementMatcher<? super MethodDescription> matcher;
 
@@ -61,116 +74,252 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
         this(loader, null, any());
     }
 
-    public SubclassBytecodeGenerator(Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
+    public SubclassBytecodeGenerator(
+            Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
         this(new SubclassInjectionLoader(), readReplace, matcher);
     }
 
-    protected SubclassBytecodeGenerator(SubclassLoader loader, Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
+    protected SubclassBytecodeGenerator(
+            SubclassLoader loader,
+            Implementation readReplace,
+            ElementMatcher<? super MethodDescription> matcher) {
         this.loader = loader;
         this.readReplace = readReplace;
         this.matcher = matcher;
         byteBuddy = new ByteBuddy().with(TypeValidation.DISABLED);
         random = new Random();
+        handler = ModuleHandler.make(byteBuddy, loader, random);
+    }
+
+    private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
+        if (!Modifier.isPublic(features.mockedType.getModifiers())
+                || !features.mockedType.isInterface()) {
+            // The mocked type is package private or is not an interface and thus may contain
+            // package private methods.
+            return true;
+        }
+        if (hasNonPublicTypeReference(features.mockedType)) {
+            return true;
+        }
+
+        for (Class<?> iface : features.interfaces) {
+            if (!Modifier.isPublic(iface.getModifiers())) {
+                return true;
+            }
+            if (hasNonPublicTypeReference(iface)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean hasNonPublicTypeReference(Class<?> iface) {
+        for (Method method : iface.getMethods()) {
+            if (!Modifier.isPublic(method.getReturnType().getModifiers())) {
+                return true;
+            }
+            for (Class<?> param : method.getParameterTypes()) {
+                if (!Modifier.isPublic(param.getModifiers())) {
+                    return true;
+                }
+            }
+        }
+        return false;
     }
 
     @Override
     public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
-        String name = nameFor(features.mockedType);
+        MultipleParentClassLoader.Builder loaderBuilder =
+                new MultipleParentClassLoader.Builder()
+                        .appendMostSpecific(features.mockedType)
+                        .appendMostSpecific(features.interfaces)
+                        .appendMostSpecific(
+                                MockAccess.class, DispatcherDefaultingToRealMethod.class)
+                        .appendMostSpecific(
+                                MockMethodInterceptor.class,
+                                MockMethodInterceptor.ForHashCode.class,
+                                MockMethodInterceptor.ForEquals.class);
+        ClassLoader contextLoader = currentThread().getContextClassLoader();
+        boolean shouldIncludeContextLoader = true;
+        if (needsSamePackageClassLoader(features)) {
+            // For the generated class to access package-private methods, it must be defined by the
+            // same classloader as its type. All the other added classloaders are required to load
+            // the type; if the context classloader is a child of the mocked type's defining
+            // classloader, it will break a mock that would have worked. Check if the context class
+            // loader is a child of the classloader we'd otherwise use, and possibly skip it.
+            ClassLoader candidateLoader = loaderBuilder.build();
+            for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
+                if (parent == candidateLoader) {
+                    shouldIncludeContextLoader = false;
+                    break;
+                }
+            }
+        }
+        if (shouldIncludeContextLoader) {
+            loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
+        }
+        ClassLoader classLoader = loaderBuilder.build();
+
+        // If Mockito does not need to create a new class loader and if a mock is not based on a JDK
+        // type, we attempt
+        // to define the mock class in the user runtime package to allow for mocking package private
+        // types and methods.
+        // This also requires that we are able to access the package of the mocked class either by
+        // override or explicit
+        // privilege given by the target package being opened to Mockito.
+        boolean localMock =
+                classLoader == features.mockedType.getClassLoader()
+                        && features.serializableMode != SerializableMode.ACROSS_CLASSLOADERS
+                        && !isComingFromJDK(features.mockedType)
+                        && (loader.isDisrespectingOpenness()
+                                || handler.isOpened(features.mockedType, MockAccess.class));
+        String typeName;
+        if (localMock
+                || (loader instanceof MultipleParentClassLoader
+                        && !isComingFromJDK(features.mockedType))) {
+            typeName = features.mockedType.getName();
+        } else {
+            typeName =
+                    InjectionBase.class.getPackage().getName()
+                            + "."
+                            + features.mockedType.getSimpleName();
+        }
+        String name =
+                String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
+
+        if (localMock) {
+            handler.adjustModuleGraph(features.mockedType, MockAccess.class, false, true);
+            for (Class<?> iFace : features.interfaces) {
+                handler.adjustModuleGraph(iFace, features.mockedType, true, false);
+                handler.adjustModuleGraph(features.mockedType, iFace, false, true);
+            }
+        } else {
+            boolean exported = handler.isExported(features.mockedType);
+            Iterator<Class<?>> it = features.interfaces.iterator();
+            while (exported && it.hasNext()) {
+                exported = handler.isExported(it.next());
+            }
+            // We check if all mocked types are exported without qualification to avoid generating a
+            // hook type.
+            // unless this is necessary. We expect this to be the case for most mocked types what
+            // makes this a
+            // worthy performance optimization.
+            if (exported) {
+                assertVisibility(features.mockedType);
+                for (Class<?> iFace : features.interfaces) {
+                    assertVisibility(iFace);
+                }
+            } else {
+                Class<?> hook = handler.injectionBase(classLoader, typeName);
+                assertVisibility(features.mockedType);
+                handler.adjustModuleGraph(features.mockedType, hook, true, false);
+                for (Class<?> iFace : features.interfaces) {
+                    assertVisibility(iFace);
+                    handler.adjustModuleGraph(iFace, hook, true, false);
+                }
+            }
+        }
+
         DynamicType.Builder<T> builder =
-                byteBuddy.subclass(features.mockedType)
-                         .name(name)
-                         .ignoreAlso(isGroovyMethod())
-                         .annotateType(features.stripAnnotations
-                             ? new Annotation[0]
-                             : features.mockedType.getAnnotations())
-                         .implement(new ArrayList<Type>(features.interfaces))
-                         .method(matcher)
-                           .intercept(dispatcher)
-                           .transform(withModifiers(SynchronizationState.PLAIN))
-                           .attribute(features.stripAnnotations
-                               ? MethodAttributeAppender.NoOp.INSTANCE
-                               : INCLUDING_RECEIVER)
-                         .method(isHashCode())
-                           .intercept(hashCode)
-                         .method(isEquals())
-                           .intercept(equals)
-                         .serialVersionUid(42L)
-                         .defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
-                         .implement(MockAccess.class)
-                           .intercept(FieldAccessor.ofBeanProperty());
+                byteBuddy
+                        .subclass(features.mockedType)
+                        .name(name)
+                        .ignoreAlso(isGroovyMethod())
+                        .annotateType(
+                                features.stripAnnotations
+                                        ? new Annotation[0]
+                                        : features.mockedType.getAnnotations())
+                        .implement(new ArrayList<Type>(features.interfaces))
+                        .method(matcher)
+                        .intercept(dispatcher)
+                        .transform(withModifiers(SynchronizationState.PLAIN))
+                        .attribute(
+                                features.stripAnnotations
+                                        ? MethodAttributeAppender.NoOp.INSTANCE
+                                        : INCLUDING_RECEIVER)
+                        .serialVersionUid(42L)
+                        .defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
+                        .implement(MockAccess.class)
+                        .intercept(FieldAccessor.ofBeanProperty())
+                        .method(isHashCode())
+                        .intercept(hashCode)
+                        .method(isEquals())
+                        .intercept(equals);
         if (features.serializableMode == SerializableMode.ACROSS_CLASSLOADERS) {
-            builder = builder.implement(CrossClassLoaderSerializableMock.class)
-                             .intercept(writeReplace);
+            builder =
+                    builder.implement(CrossClassLoaderSerializableMock.class)
+                            .intercept(writeReplace);
         }
         if (readReplace != null) {
-            builder = builder.defineMethod("readObject", void.class, Visibility.PRIVATE)
-                    .withParameters(ObjectInputStream.class)
-                    .throwing(ClassNotFoundException.class, IOException.class)
-                    .intercept(readReplace);
+            builder =
+                    builder.defineMethod("readObject", void.class, Visibility.PRIVATE)
+                            .withParameters(ObjectInputStream.class)
+                            .throwing(ClassNotFoundException.class, IOException.class)
+                            .intercept(readReplace);
         }
-        ClassLoader classLoader = new MultipleParentClassLoader.Builder()
-            .append(features.mockedType)
-            .append(features.interfaces)
-            .append(currentThread().getContextClassLoader())
-            .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
-            .append(MockMethodInterceptor.class,
-                MockMethodInterceptor.ForHashCode.class,
-                MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader());
-        if (classLoader != features.mockedType.getClassLoader()) {
-            assertVisibility(features.mockedType);
-            for (Class<?> iFace : features.interfaces) {
-                assertVisibility(iFace);
-            }
-            builder = builder.ignoreAlso(isPackagePrivate()
-                .or(returns(isPackagePrivate()))
-                .or(hasParameters(whereAny(hasType(isPackagePrivate())))));
+        if (name.startsWith(CODEGEN_PACKAGE) || classLoader instanceof MultipleParentClassLoader) {
+            builder =
+                    builder.ignoreAlso(
+                            isPackagePrivate()
+                                    .or(returns(isPackagePrivate()))
+                                    .or(hasParameters(whereAny(hasType(isPackagePrivate())))));
         }
         return builder.make()
-                      .load(classLoader, loader.resolveStrategy(features.mockedType, classLoader, name.startsWith(CODEGEN_PACKAGE)))
-                      .getLoaded();
+                .load(
+                        classLoader,
+                        loader.resolveStrategy(features.mockedType, classLoader, localMock))
+                .getLoaded();
     }
 
-    private static ElementMatcher<MethodDescription> isGroovyMethod() {
-        return isDeclaredBy(named("groovy.lang.GroovyObjectSupport"));
+    @Override
+    public void mockClassStatic(Class<?> type) {
+        throw new MockitoException("The subclass byte code generator cannot create static mocks");
     }
 
-    // TODO inspect naming strategy (for OSGI, signed package, java.* (and bootstrap classes), etc...)
-    private String nameFor(Class<?> type) {
-        String typeName = type.getName();
-        if (isComingFromJDK(type)
-                || isComingFromSignedJar(type)
-                || isComingFromSealedPackage(type)) {
-            typeName = CODEGEN_PACKAGE + type.getSimpleName();
+    @Override
+    public void mockClassConstruction(Class<?> type) {
+        throw new MockitoException(
+                "The subclass byte code generator cannot create construction mocks");
+    }
+
+    private <T> Collection<Class<? super T>> getAllTypes(Class<T> type) {
+        Collection<Class<? super T>> supertypes = new LinkedList<>();
+        supertypes.add(type);
+        Class<? super T> superType = type;
+        while (superType != null) {
+            supertypes.add(superType);
+            superType = superType.getSuperclass();
         }
-        return String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
+        return supertypes;
+    }
+
+    private static ElementMatcher<MethodDescription> isGroovyMethod() {
+        return isDeclaredBy(named("groovy.lang.GroovyObjectSupport"))
+                .or(isAnnotatedWith(named("groovy.transform.Internal")));
     }
 
     private boolean isComingFromJDK(Class<?> type) {
         // Comes from the manifest entry :
         // Implementation-Title: Java Runtime Environment
         // This entry is not necessarily present in every jar of the JDK
-        return type.getPackage() != null && "Java Runtime Environment".equalsIgnoreCase(type.getPackage().getImplementationTitle())
+        return (type.getPackage() != null
+                        && "Java Runtime Environment"
+                                .equalsIgnoreCase(type.getPackage().getImplementationTitle()))
                 || type.getName().startsWith("java.")
                 || type.getName().startsWith("javax.");
     }
 
-    private boolean isComingFromSealedPackage(Class<?> type) {
-        return type.getPackage() != null && type.getPackage().isSealed();
-    }
-
-    private boolean isComingFromSignedJar(Class<?> type) {
-        return type.getSigners() != null;
-    }
-
     private static void assertVisibility(Class<?> type) {
         if (!Modifier.isPublic(type.getModifiers())) {
-            throw new MockitoException(join("Cannot create mock for " + type,
-                "",
-                "The type is not public and its mock class is loaded by a different class loader.",
-                "This can have multiple reasons:",
-                " - You are mocking a class with additional interfaces of another class loader",
-                " - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)",
-                " - The thread's context class loader is different than the mock's class loader"));
+            throw new MockitoException(
+                    join(
+                            "Cannot create mock for " + type,
+                            "",
+                            "The type is not public and its mock class is loaded by a different class loader.",
+                            "This can have multiple reasons:",
+                            " - You are mocking a class with additional interfaces of another class loader",
+                            " - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)",
+                            " - The thread's context class loader is different than the mock's class loader"));
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
index 454dd8e..c70de01 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
@@ -4,28 +4,31 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
 import net.bytebuddy.dynamic.loading.ClassInjector;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import org.mockito.codegen.InjectionBase;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.Platform;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import static org.mockito.internal.util.StringUtil.join;
-
 class SubclassInjectionLoader implements SubclassLoader {
 
-    private static final String ERROR_MESSAGE = join("The current JVM does not support any class injection mechanism.",
-        "",
-        "Currently, Mockito supports injection via neither by method handle lookups or using sun.misc.Unsafe",
-        "Neither seems to be available on your current JVM.");
+    private static final String ERROR_MESSAGE =
+            join(
+                    "The current JVM does not support any class injection mechanism.",
+                    "",
+                    "Currently, Mockito supports injection via either by method handle lookups or using sun.misc.Unsafe",
+                    "Neither seems to be available on your current JVM.");
 
     private final SubclassLoader loader;
 
     SubclassInjectionLoader() {
-        if (!Boolean.getBoolean("org.mockito.internal.simulateJava11") && ClassInjector.UsingReflection.isAvailable()) {
+        if (!Boolean.getBoolean("org.mockito.internal.noUnsafeInjection")
+                && ClassInjector.UsingReflection.isAvailable()) {
             this.loader = new WithReflection();
         } else if (ClassInjector.UsingLookup.isAvailable()) {
             this.loader = tryLookup();
@@ -38,7 +41,11 @@ class SubclassInjectionLoader implements SubclassLoader {
         try {
             Class<?> methodHandles = Class.forName("java.lang.invoke.MethodHandles");
             Object lookup = methodHandles.getMethod("lookup").invoke(null);
-            Method privateLookupIn = methodHandles.getMethod("privateLookupIn", Class.class, Class.forName("java.lang.invoke.MethodHandles$Lookup"));
+            Method privateLookupIn =
+                    methodHandles.getMethod(
+                            "privateLookupIn",
+                            Class.class,
+                            Class.forName("java.lang.invoke.MethodHandles$Lookup"));
             Object codegenLookup = privateLookupIn.invoke(null, InjectionBase.class, lookup);
             return new WithLookup(lookup, codegenLookup, privateLookupIn);
         } catch (Exception exception) {
@@ -49,8 +56,17 @@ class SubclassInjectionLoader implements SubclassLoader {
     private static class WithReflection implements SubclassLoader {
 
         @Override
-        public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
-            return ClassLoadingStrategy.Default.INJECTION.with(codegen ? InjectionBase.class.getProtectionDomain() : mockedType.getProtectionDomain());
+        public boolean isDisrespectingOpenness() {
+            return true;
+        }
+
+        @Override
+        public ClassLoadingStrategy<ClassLoader> resolveStrategy(
+                Class<?> mockedType, ClassLoader classLoader, boolean localMock) {
+            return ClassLoadingStrategy.Default.INJECTION.with(
+                    localMock
+                            ? mockedType.getProtectionDomain()
+                            : InjectionBase.class.getProtectionDomain());
         }
     }
 
@@ -69,39 +85,53 @@ class SubclassInjectionLoader implements SubclassLoader {
         }
 
         @Override
-        public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
-            if (codegen) {
-                return ClassLoadingStrategy.UsingLookup.of(codegenLookup);
-            } else if (classLoader != mockedType.getClassLoader()) {
-                return ClassLoadingStrategy.Default.WRAPPER.with(mockedType.getProtectionDomain());
-            } else {
+        public boolean isDisrespectingOpenness() {
+            return false;
+        }
+
+        @Override
+        public ClassLoadingStrategy<ClassLoader> resolveStrategy(
+                Class<?> mockedType, ClassLoader classLoader, boolean localMock) {
+            if (localMock) {
                 try {
                     Object privateLookup;
                     try {
                         privateLookup = privateLookupIn.invoke(null, mockedType, lookup);
                     } catch (InvocationTargetException exception) {
                         if (exception.getCause() instanceof IllegalAccessException) {
-                            return ClassLoadingStrategy.Default.WRAPPER.with(mockedType.getProtectionDomain());
+                            return ClassLoadingStrategy.Default.WRAPPER.with(
+                                    mockedType.getProtectionDomain());
                         } else {
                             throw exception.getCause();
                         }
                     }
                     return ClassLoadingStrategy.UsingLookup.of(privateLookup);
                 } catch (Throwable exception) {
-                    throw new MockitoException(join(
-                        "The Java module system prevents Mockito from defining a mock class in the same package as " + mockedType,
-                        "",
-                        "To overcome this, you must open and export the mocked type to Mockito.",
-                        "Remember that you can also do so programmatically if the mocked class is defined by the same module as your test code",
-                        exception
-                    ));
+                    throw new MockitoException(
+                            join(
+                                    "The Java module system prevents Mockito from defining a mock class in the same package as "
+                                            + mockedType,
+                                    "",
+                                    "To overcome this, you must open and export the mocked type to Mockito.",
+                                    "Remember that you can also do so programmatically if the mocked class is defined by the same module as your test code",
+                                    exception));
                 }
+            } else if (classLoader == InjectionBase.class.getClassLoader()) {
+                return ClassLoadingStrategy.UsingLookup.of(codegenLookup);
+            } else {
+                return ClassLoadingStrategy.Default.WRAPPER.with(mockedType.getProtectionDomain());
             }
         }
     }
 
     @Override
-    public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
-        return loader.resolveStrategy(mockedType, classLoader, codegen);
+    public boolean isDisrespectingOpenness() {
+        return loader.isDisrespectingOpenness();
+    }
+
+    @Override
+    public ClassLoadingStrategy<ClassLoader> resolveStrategy(
+            Class<?> mockedType, ClassLoader classLoader, boolean localMock) {
+        return loader.resolveStrategy(mockedType, classLoader, localMock);
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
index 194c282..289497d 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
@@ -11,13 +11,21 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
  */
 public interface SubclassLoader {
 
+    /**
+     * Checks if this loader does not require a module to be open.
+     *
+     * @return {@code true} if this loader is not constraint to a target module being opened for loading a class.
+     */
+    boolean isDisrespectingOpenness();
+
     /**
      * Resolves a class loading strategy.
      *
      * @param mockedType  The type being mocked.
      * @param classLoader The class loader being used.
-     * @param codegen     {@code true} if the mock is loaded in the {@code org.mockito.codegen} package.
+     * @param localMock   {@code true} if the mock is loaded within the runtime package of the mocked type.
      * @return An appropriate class loading strategy.
      */
-    ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen);
+    ClassLoadingStrategy<ClassLoader> resolveStrategy(
+            Class<?> mockedType, ClassLoader classLoader, boolean localMock);
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
index ea51edf..30ed949 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
@@ -4,39 +4,48 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import net.bytebuddy.TypeCache;
-import org.mockito.mock.SerializableMode;
-
 import java.lang.ref.ReferenceQueue;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import net.bytebuddy.TypeCache;
+import org.mockito.mock.SerializableMode;
 
-class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
+class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader>
+        implements BytecodeGenerator {
 
-    private final Object BOOTSTRAP_LOCK = new Object();
+    private static final Object BOOTSTRAP_LOCK = new Object();
 
     private final BytecodeGenerator bytecodeGenerator;
 
     private final TypeCache<MockitoMockKey> typeCache;
 
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
     public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
         this.bytecodeGenerator = bytecodeGenerator;
-        typeCache = new TypeCache.WithInlineExpunction<MockitoMockKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
+        typeCache =
+                new TypeCache.WithInlineExpunction<>(
+                        weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
     }
 
     @SuppressWarnings("unchecked")
     @Override
     public <T> Class<T> mockClass(final MockFeatures<T> params) {
+        lock.readLock().lock();
         try {
             ClassLoader classLoader = params.mockedType.getClassLoader();
-            return (Class<T>) typeCache.findOrInsert(classLoader,
-                    new MockitoMockKey(params.mockedType, params.interfaces, params.serializableMode, params.stripAnnotations),
-                    new Callable<Class<?>>() {
-                        @Override
-                        public Class<?> call() throws Exception {
-                            return bytecodeGenerator.mockClass(params);
-                        }
-                    }, BOOTSTRAP_LOCK);
+            return (Class<T>)
+                    typeCache.findOrInsert(
+                            classLoader,
+                            new MockitoMockKey(
+                                    params.mockedType,
+                                    params.interfaces,
+                                    params.serializableMode,
+                                    params.stripAnnotations),
+                            () -> bytecodeGenerator.mockClass(params),
+                            BOOTSTRAP_LOCK);
         } catch (IllegalArgumentException exception) {
             Throwable cause = exception.getCause();
             if (cause instanceof RuntimeException) {
@@ -44,6 +53,29 @@ class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implement
             } else {
                 throw exception;
             }
+        } finally {
+            lock.readLock().unlock();
+        }
+    }
+
+    @Override
+    public void mockClassStatic(Class<?> type) {
+        bytecodeGenerator.mockClassStatic(type);
+    }
+
+    @Override
+    public void mockClassConstruction(Class<?> type) {
+        bytecodeGenerator.mockClassConstruction(type);
+    }
+
+    @Override
+    public void clearAllCaches() {
+        lock.writeLock().lock();
+        try {
+            typeCache.clear();
+            bytecodeGenerator.clearAllCaches();
+        } finally {
+            lock.writeLock().unlock();
         }
     }
 
@@ -52,10 +84,11 @@ class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implement
         private final SerializableMode serializableMode;
         private final boolean stripAnnotations;
 
-        private MockitoMockKey(Class<?> type,
-                               Set<Class<?>> additionalType,
-                               SerializableMode serializableMode,
-                               boolean stripAnnotations) {
+        private MockitoMockKey(
+                Class<?> type,
+                Set<Class<?>> additionalType,
+                SerializableMode serializableMode,
+                boolean stripAnnotations) {
             super(type, additionalType);
             this.serializableMode = serializableMode;
             this.stripAnnotations = stripAnnotations;
@@ -63,12 +96,18 @@ class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implement
 
         @Override
         public boolean equals(Object object) {
-            if (this == object) return true;
-            if (object == null || getClass() != object.getClass()) return false;
-            if (!super.equals(object)) return false;
+            if (this == object) {
+                return true;
+            }
+            if (object == null || getClass() != object.getClass()) {
+                return false;
+            }
+            if (!super.equals(object)) {
+                return false;
+            }
             MockitoMockKey that = (MockitoMockKey) object;
             return stripAnnotations == that.stripAnnotations
-                && serializableMode.equals(that.serializableMode);
+                    && serializableMode.equals(that.serializableMode);
         }
 
         @Override
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeSupport.java b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeSupport.java
new file mode 100644
index 0000000..17df601
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeSupport.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy;
+
+import org.mockito.exceptions.base.MockitoException;
+
+import java.lang.reflect.Method;
+
+class TypeSupport {
+
+    static final TypeSupport INSTANCE;
+
+    static {
+        Method isSealed;
+        try {
+            isSealed = Class.class.getMethod("isSealed");
+        } catch (NoSuchMethodException ignored) {
+            isSealed = null;
+        }
+        INSTANCE = new TypeSupport(isSealed);
+    }
+
+    private final Method isSealed;
+
+    private TypeSupport(Method isSealed) {
+        this.isSealed = isSealed;
+    }
+
+    boolean isSealed(Class<?> type) {
+        if (isSealed == null) {
+            return false;
+        }
+        try {
+            return (boolean) isSealed.invoke(type);
+        } catch (Throwable t) {
+            throw new MockitoException(
+                    "Failed to check if type is sealed using handle " + isSealed, t);
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.java b/src/main/java/org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.java
new file mode 100644
index 0000000..82db0ba
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy.inject;
+
+import java.lang.reflect.Method;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public abstract class MockMethodDispatcher {
+
+    static {
+        ClassLoader classLoader = MockMethodDispatcher.class.getClassLoader();
+        if (classLoader != null) {
+            // Do not use Mockito classes in here as this is executed on the boot loader.
+            throw new IllegalStateException(
+                    MockMethodDispatcher.class.getName()
+                            + " is not loaded by the bootstrap class loader but by an instance of "
+                            + classLoader.getClass().getName()
+                            + ".\n\nThis causes the inline mock maker to not work as expected. "
+                            + "Please contact the maintainer of this class loader implementation "
+                            + "to assure that this class is never loaded by another class loader. "
+                            + "The bootstrap class loader must always be queried first for this "
+                            + "class for Mockito's inline mock maker to function correctly.");
+        }
+    }
+
+    private static final ConcurrentMap<String, MockMethodDispatcher> DISPATCHERS =
+            new ConcurrentHashMap<>();
+
+    public static MockMethodDispatcher get(String identifier, Object mock) {
+        if (mock == DISPATCHERS) {
+            // Avoid endless loop if ConcurrentHashMap was redefined to check for being a mock.
+            return null;
+        } else {
+            return DISPATCHERS.get(identifier);
+        }
+    }
+
+    public static MockMethodDispatcher getStatic(String identifier, Class<?> type) {
+        if (MockMethodDispatcher.class.isAssignableFrom(type) || type == ConcurrentHashMap.class) {
+            // Avoid endless loop for lookups of self.
+            return null;
+        } else {
+            return DISPATCHERS.get(identifier);
+        }
+    }
+
+    public static void set(String identifier, MockMethodDispatcher dispatcher) {
+        DISPATCHERS.putIfAbsent(identifier, dispatcher);
+    }
+
+    @SuppressWarnings("unused")
+    public static boolean isConstructorMock(String identifier, Class<?> type) {
+        return DISPATCHERS.get(identifier).isConstructorMock(type);
+    }
+
+    public abstract boolean isConstructorMock(Class<?> type);
+
+    @SuppressWarnings("unused")
+    public static Object handleConstruction(
+            String identifier,
+            Class<?> type,
+            Object object,
+            Object[] arguments,
+            String[] parameterTypeNames) {
+        return DISPATCHERS
+                .get(identifier)
+                .handleConstruction(type, object, arguments, parameterTypeNames);
+    }
+
+    public abstract Callable<?> handle(Object instance, Method origin, Object[] arguments)
+            throws Throwable;
+
+    public abstract Callable<?> handleStatic(Class<?> type, Method origin, Object[] arguments)
+            throws Throwable;
+
+    public abstract Object handleConstruction(
+            Class<?> type, Object object, Object[] arguments, String[] parameterTypeNames);
+
+    public abstract boolean isMock(Object instance);
+
+    public abstract boolean isMocked(Object instance);
+
+    public abstract boolean isMockedStatic(Class<?> type);
+
+    public abstract boolean isOverridden(Object instance, Method origin);
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/inject/package-info.java b/src/main/java/org/mockito/internal/creation/bytebuddy/inject/package-info.java
new file mode 100644
index 0000000..5abed05
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/inject/package-info.java
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+/**
+ * Internal classes, not to be used by clients. Intended for injection into the bootstrap class loader.
+ *
+ * Subject to change at any time without notice.
+ */
+package org.mockito.internal.creation.bytebuddy.inject;
diff --git a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
index 688526b..c882704 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
@@ -4,18 +4,19 @@
  */
 package org.mockito.internal.creation.instance;
 
+import static org.mockito.internal.util.StringUtil.join;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 
-import org.mockito.creation.instance.Instantiator;
 import org.mockito.creation.instance.InstantiationException;
+import org.mockito.creation.instance.Instantiator;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.util.Primitives;
-import org.mockito.internal.util.reflection.AccessibilityChanger;
-
-import static org.mockito.internal.util.StringUtil.join;
+import org.mockito.plugins.MemberAccessor;
 
 public class ConstructorInstantiator implements Instantiator {
 
@@ -25,6 +26,7 @@ public class ConstructorInstantiator implements Instantiator {
      * If an outer inject exists, it would be the first ([0]) element of the {@link #constructorArgs} array.
      */
     private final boolean hasOuterClassInstance;
+
     private final Object[] constructorArgs;
 
     public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
@@ -32,12 +34,13 @@ public class ConstructorInstantiator implements Instantiator {
         this.constructorArgs = constructorArgs;
     }
 
+    @Override
     public <T> T newInstance(Class<T> cls) {
         return withParams(cls, constructorArgs);
     }
 
     private <T> T withParams(Class<T> cls, Object... params) {
-        List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
+        List<Constructor<?>> matchingConstructors = new LinkedList<>();
         try {
             for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                 Class<?>[] types = constructor.getParameterTypes();
@@ -52,7 +55,7 @@ public class ConstructorInstantiator implements Instantiator {
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
-        if (matchingConstructors.size() == 0) {
+        if (matchingConstructors.isEmpty()) {
             throw noMatchingConstructor(cls);
         } else {
             throw multipleMatchingConstructors(cls, matchingConstructors);
@@ -60,17 +63,21 @@ public class ConstructorInstantiator implements Instantiator {
     }
 
     @SuppressWarnings("unchecked")
-    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
-        AccessibilityChanger accessibility = new AccessibilityChanger();
-        accessibility.enableAccess(constructor);
-        return (T) constructor.newInstance(params);
+    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params)
+            throws java.lang.InstantiationException, IllegalAccessException,
+                    InvocationTargetException {
+        MemberAccessor accessor = Plugins.getMemberAccessor();
+        return (T) accessor.newInstance(constructor, params);
     }
 
     private InstantiationException paramsException(Class<?> cls, Exception e) {
-        return new InstantiationException(join(
-                "Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
-                , e);
+        return new InstantiationException(
+                join(
+                        "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                        "Please ensure the target class has "
+                                + constructorArgsString()
+                                + " and executes cleanly."),
+                e);
     }
 
     private String constructorArgTypes() {
@@ -80,7 +87,8 @@ public class ConstructorInstantiator implements Instantiator {
         }
         String[] constructorArgTypes = new String[constructorArgs.length - argPos];
         for (int i = argPos; i < constructorArgs.length; ++i) {
-            constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
+            constructorArgTypes[i - argPos] =
+                    constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
         }
         return Arrays.toString(constructorArgTypes);
     }
@@ -91,9 +99,14 @@ public class ConstructorInstantiator implements Instantiator {
         if (hasOuterClassInstance) {
             outerInstanceHint = " and provided outer instance is correct";
         }
-        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Please ensure that the target class has " + constructorString + outerInstanceHint + ".")
-                , null);
+        return new InstantiationException(
+                join(
+                        "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                        "Please ensure that the target class has "
+                                + constructorString
+                                + outerInstanceHint
+                                + "."),
+                null);
     }
 
     private String constructorArgsString() {
@@ -101,19 +114,25 @@ public class ConstructorInstantiator implements Instantiator {
         if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
             constructorString = "a 0-arg constructor";
         } else {
-            constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
+            constructorString =
+                    "a constructor that matches these argument types: " + constructorArgTypes();
         }
         return constructorString;
     }
 
-    private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
-        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
-                join("", " - ", constructors),
-                "If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
-                "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
-                "See https://github.com/mockito/mockito/issues/685"
-            ), null);
+    private InstantiationException multipleMatchingConstructors(
+            Class<?> cls, List<Constructor<?>> constructors) {
+        return new InstantiationException(
+                join(
+                        "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                        "Multiple constructors could be matched to arguments of types "
+                                + constructorArgTypes()
+                                + ":",
+                        join("", " - ", constructors),
+                        "If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
+                        "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
+                        "See https://github.com/mockito/mockito/issues/685"),
+                null);
     }
 
     private static boolean paramsMatch(Class<?>[] types, Object[] params) {
@@ -125,8 +144,10 @@ public class ConstructorInstantiator implements Instantiator {
                 if (types[i].isPrimitive()) {
                     return false;
                 }
-            } else if ((!types[i].isPrimitive() && !types[i].isInstance(params[i])) ||
-                    (types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
+            } else if ((!types[i].isPrimitive() && !types[i].isInstance(params[i]))
+                    || (types[i].isPrimitive()
+                            && !types[i].equals(
+                                    Primitives.primitiveTypeOf(params[i].getClass())))) {
                 return false;
             }
         }
@@ -156,7 +177,8 @@ public class ConstructorInstantiator implements Instantiator {
      * @param matchingConstructors A list of equivalently best matching constructors found so far
      * @param constructor The constructor to be evaluated against this list
      */
-    private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
+    private void evaluateConstructor(
+            List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
         boolean newHasBetterParam = false;
         boolean existingHasBetterParam = false;
 
diff --git a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
index 9c414f3..af071bf 100644
--- a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
+++ b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
@@ -10,11 +10,13 @@ import org.mockito.plugins.InstantiatorProvider2;
 
 public class DefaultInstantiatorProvider implements InstantiatorProvider2 {
 
-    private final static Instantiator INSTANCE = new ObjenesisInstantiator();
+    private static final Instantiator INSTANCE = new ObjenesisInstantiator();
 
+    @Override
     public Instantiator getInstantiator(MockCreationSettings<?> settings) {
         if (settings != null && settings.getConstructorArgs() != null) {
-            return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
+            return new ConstructorInstantiator(
+                    settings.getOuterClassInstance() != null, settings.getConstructorArgs());
         } else {
             return INSTANCE;
         }
diff --git a/src/main/java/org/mockito/internal/creation/instance/InstantiationException.java b/src/main/java/org/mockito/internal/creation/instance/InstantiationException.java
deleted file mode 100644
index 86b5463..0000000
--- a/src/main/java/org/mockito/internal/creation/instance/InstantiationException.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2016 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.instance;
-
-import org.mockito.exceptions.base.MockitoException;
-
-/**
- * @deprecated since 2.15.4 because this internal class was leaking from the public API.
- * For information why deprecated, see {@link org.mockito.plugins.InstantiatorProvider2}.
- * Use {@link org.mockito.creation.instance.Instantiator} and {@link org.mockito.creation.instance.InstantiationException} types instead.
- * <p>
- * Exception generated when {@link Instantiator#newInstance(Class)} failed.
- */
-@Deprecated
-public class InstantiationException extends MockitoException {
-
-    public InstantiationException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
diff --git a/src/main/java/org/mockito/internal/creation/instance/Instantiator.java b/src/main/java/org/mockito/internal/creation/instance/Instantiator.java
deleted file mode 100644
index 85b6b3d..0000000
--- a/src/main/java/org/mockito/internal/creation/instance/Instantiator.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2016 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.instance;
-
-/**
- * @deprecated since 2.15.4 because this internal class was leaking from the public API.
- * For more information why deprecated, see {@link org.mockito.plugins.InstantiatorProvider2}.
- * Use {@link org.mockito.creation.instance.Instantiator} instead.
- * <p>
- * Provides instances of classes.
- */
-@Deprecated
-public interface Instantiator {
-
-    /**
-     * Creates instance of given class
-     */
-    <T> T newInstance(Class<T> cls) throws InstantiationException;
-
-}
diff --git a/src/main/java/org/mockito/internal/creation/instance/InstantiatorProvider2Adapter.java b/src/main/java/org/mockito/internal/creation/instance/InstantiatorProvider2Adapter.java
deleted file mode 100644
index a1ab5d5..0000000
--- a/src/main/java/org/mockito/internal/creation/instance/InstantiatorProvider2Adapter.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2018 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.instance;
-
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.plugins.InstantiatorProvider;
-import org.mockito.plugins.InstantiatorProvider2;
-
-/**
- * Adapts new public API {@link InstantiatorProvider2} onto old, deprecated API {@link InstantiatorProvider}
- */
-public class InstantiatorProvider2Adapter implements InstantiatorProvider {
-    private final InstantiatorProvider2 provider;
-
-    public InstantiatorProvider2Adapter(InstantiatorProvider2 provider) {
-        this.provider = provider;
-    }
-
-    @Override
-    public Instantiator getInstantiator(final MockCreationSettings<?> settings) {
-        return new Instantiator() {
-            @Override
-            public <T> T newInstance(Class<T> cls) throws InstantiationException {
-                try {
-                    return provider.getInstantiator(settings).newInstance(cls);
-                } catch (org.mockito.creation.instance.InstantiationException e) {
-                    throw new InstantiationException(e.getMessage(), e.getCause());
-                }
-            }
-        };
-    }
-}
diff --git a/src/main/java/org/mockito/internal/creation/instance/InstantiatorProviderAdapter.java b/src/main/java/org/mockito/internal/creation/instance/InstantiatorProviderAdapter.java
deleted file mode 100644
index c807925..0000000
--- a/src/main/java/org/mockito/internal/creation/instance/InstantiatorProviderAdapter.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2018 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.instance;
-
-import org.mockito.creation.instance.InstantiationException;
-import org.mockito.creation.instance.Instantiator;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.plugins.InstantiatorProvider;
-import org.mockito.plugins.InstantiatorProvider2;
-
-/**
- * Adapts old, deprecated {@link InstantiatorProvider} onto a new public {@link InstantiatorProvider2} API.
- */
-public class InstantiatorProviderAdapter implements InstantiatorProvider2 {
-    private final InstantiatorProvider provider;
-
-    public InstantiatorProviderAdapter(InstantiatorProvider provider) {
-        this.provider = provider;
-    }
-
-    @Override
-    public Instantiator getInstantiator(final MockCreationSettings<?> settings) {
-        return new Instantiator() {
-            @Override
-            public <T> T newInstance(Class<T> cls) throws InstantiationException {
-                try {
-                    return provider.getInstantiator(settings).newInstance(cls);
-                } catch (org.mockito.internal.creation.instance.InstantiationException e) {
-                    throw new InstantiationException(e.getMessage(), e.getCause());
-                }
-            }
-        };
-    }
-}
diff --git a/src/main/java/org/mockito/internal/creation/instance/ObjenesisInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ObjenesisInstantiator.java
index 7e41f68..deffbe9 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ObjenesisInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ObjenesisInstantiator.java
@@ -10,11 +10,14 @@ import org.objenesis.ObjenesisStd;
 
 class ObjenesisInstantiator implements Instantiator {
 
-    //TODO: in order to provide decent exception message when objenesis is not found,
-    //have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then show decent exception that dependency is missing
-    //TODO: for the same reason catch and give better feedback when hamcrest core is not found.
-    private final ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());
+    // TODO: in order to provide decent exception message when objenesis is not found,
+    // have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then
+    // show decent exception that dependency is missing
+    // TODO: for the same reason catch and give better feedback when hamcrest core is not found.
+    private final ObjenesisStd objenesis =
+            new ObjenesisStd(new GlobalConfiguration().enableClassCache());
 
+    @Override
     public <T> T newInstance(Class<T> cls) {
         return objenesis.newInstance(cls);
     }
diff --git a/src/main/java/org/mockito/internal/creation/proxy/InvokeDefaultProxy.java b/src/main/java/org/mockito/internal/creation/proxy/InvokeDefaultProxy.java
new file mode 100644
index 0000000..41f808a
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/proxy/InvokeDefaultProxy.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.proxy;
+
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.invocation.RealMethod;
+import org.mockito.internal.invocation.SerializableMethod;
+import org.mockito.internal.util.Platform;
+
+import java.io.Serializable;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import static org.mockito.internal.util.StringUtil.join;
+
+class InvokeDefaultProxy implements ProxyRealMethod {
+
+    private final Method invokeDefault;
+
+    InvokeDefaultProxy() throws Throwable {
+        invokeDefault =
+                InvocationHandler.class.getMethod(
+                        "invokeDefault", Object.class, Method.class, Object[].class);
+    }
+
+    @Override
+    public RealMethod resolve(Object proxy, Method method, Object[] args) {
+        return new InvokeDefaultRealMethod(proxy, method, args);
+    }
+
+    private class InvokeDefaultRealMethod implements RealMethod, Serializable {
+
+        private static final long serialVersionUID = -1;
+
+        private final Object proxy;
+        private final SerializableMethod serializableMethod;
+        private final Object[] args;
+
+        private InvokeDefaultRealMethod(Object proxy, Method method, Object[] args) {
+            this.proxy = proxy;
+            this.serializableMethod = new SerializableMethod(method);
+            this.args = args;
+        }
+
+        @Override
+        public boolean isInvokable() {
+            return true;
+        }
+
+        @Override
+        public Object invoke() throws Throwable {
+            try {
+                return invokeDefault.invoke(null, proxy, serializableMethod.getJavaMethod(), args);
+            } catch (InvocationTargetException e) {
+                throw e.getTargetException();
+            } catch (IllegalAccessException | IllegalArgumentException e) {
+                throw new MockitoException(
+                        join(
+                                "Failed to access default method or invoked method with illegal arguments",
+                                "",
+                                "Method "
+                                        + serializableMethod.getJavaMethod()
+                                        + " could not be delegated, this is not supposed to happen",
+                                Platform.describe()),
+                        e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/proxy/MethodHandleProxy.java b/src/main/java/org/mockito/internal/creation/proxy/MethodHandleProxy.java
new file mode 100644
index 0000000..068f723
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/proxy/MethodHandleProxy.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.proxy;
+
+import org.mockito.internal.SuppressSignatureCheck;
+import org.mockito.internal.invocation.RealMethod;
+
+import java.io.Serializable;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+@SuppressSignatureCheck
+class MethodHandleProxy implements ProxyRealMethod {
+
+    private final MethodHandles.Lookup lookup;
+
+    MethodHandleProxy() throws Throwable {
+        lookup = MethodHandles.lookup();
+    }
+
+    @Override
+    public RealMethod resolve(Object proxy, Method method, Object[] args) {
+        try {
+            return new MethodHandleRealMethod(
+                    lookup.findSpecial(
+                                    method.getDeclaringClass(),
+                                    method.getName(),
+                                    MethodType.methodType(
+                                            method.getReturnType(), method.getParameterTypes()),
+                                    method.getDeclaringClass())
+                            .bindTo(proxy),
+                    args);
+        } catch (Throwable ignored) {
+            return RealMethod.IsIllegal.INSTANCE;
+        }
+    }
+
+    @SuppressSignatureCheck
+    static class LegacyVersion implements ProxyRealMethod {
+
+        private final Constructor<MethodHandles.Lookup> constructor;
+
+        LegacyVersion() throws Throwable {
+            try {
+                Class.forName("java.lang.Module");
+                throw new RuntimeException("Must not be used when modules are available");
+            } catch (ClassNotFoundException ignored) {
+            }
+            constructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);
+            constructor.setAccessible(true);
+        }
+
+        @Override
+        public RealMethod resolve(Object proxy, Method method, Object[] args) {
+            try {
+                return new MethodHandleRealMethod(
+                        constructor
+                                .newInstance(method.getDeclaringClass())
+                                .in(method.getDeclaringClass())
+                                .unreflectSpecial(method, method.getDeclaringClass())
+                                .bindTo(proxy),
+                        args);
+            } catch (Throwable ignored) {
+                return RealMethod.IsIllegal.INSTANCE;
+            }
+        }
+    }
+
+    @SuppressSignatureCheck
+    private static class MethodHandleRealMethod implements RealMethod, Serializable {
+
+        private static final long serialVersionUID = -1;
+
+        private final MethodHandle handle;
+        private final Object[] args;
+
+        private MethodHandleRealMethod(MethodHandle handle, Object[] args) {
+            this.handle = handle;
+            this.args = args;
+        }
+
+        @Override
+        public boolean isInvokable() {
+            return true;
+        }
+
+        @Override
+        public Object invoke() throws Throwable {
+            return handle.invokeWithArguments(args);
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/proxy/ProxyMockMaker.java b/src/main/java/org/mockito/internal/creation/proxy/ProxyMockMaker.java
new file mode 100644
index 0000000..faa97e8
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/proxy/ProxyMockMaker.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.proxy;
+
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.RealMethod;
+import org.mockito.internal.util.Platform;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.MockMaker;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.mockito.internal.invocation.DefaultInvocationFactory.createInvocation;
+import static org.mockito.internal.util.StringUtil.join;
+
+/**
+ * A mock maker that is using the {@link Proxy} utility and is therefore only capable of mocking interfaces but
+ * does not rely on manual byte code generation but only uses official and public Java API.
+ */
+public class ProxyMockMaker implements MockMaker {
+
+    private static final Object[] EMPTY = new Object[0];
+
+    private final ProxyRealMethod proxyRealMethod = ProxyRealMethod.make();
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+        boolean object = settings.getTypeToMock() == Object.class;
+        Class<?>[] ifaces = new Class<?>[settings.getExtraInterfaces().size() + (object ? 0 : 1)];
+        int index = 0;
+        if (!object) {
+            ifaces[index++] = settings.getTypeToMock();
+        }
+        ClassLoader classLoader = settings.getTypeToMock().getClassLoader();
+        for (Class<?> iface : settings.getExtraInterfaces()) {
+            ifaces[index++] = iface;
+            classLoader = resolveCommonClassLoader(classLoader, iface);
+        }
+        return (T)
+                Proxy.newProxyInstance(
+                        resolveCommonClassLoader(classLoader, ProxyMockMaker.class),
+                        ifaces,
+                        new MockInvocationHandler(handler, settings));
+    }
+
+    private static ClassLoader resolveCommonClassLoader(ClassLoader mostSpecific, Class<?> type) {
+        if (mostSpecific == null) {
+            return type.getClassLoader();
+        }
+        ClassLoader candidate = type.getClassLoader();
+        if (candidate == null || mostSpecific == candidate) {
+            return mostSpecific;
+        }
+        while (candidate != null) {
+            if (candidate == mostSpecific) {
+                return type.getClassLoader();
+            }
+            candidate = candidate.getParent();
+        }
+        candidate = mostSpecific;
+        while (candidate != null) {
+            if (candidate == type.getClassLoader()) {
+                return mostSpecific;
+            }
+            candidate = candidate.getParent();
+        }
+        return new CommonClassLoader(mostSpecific, type.getClassLoader());
+    }
+
+    @Override
+    public MockHandler getHandler(Object mock) {
+        if (!Proxy.isProxyClass(mock.getClass())) {
+            return null;
+        }
+        InvocationHandler handler = Proxy.getInvocationHandler(mock);
+        if (!(handler instanceof MockInvocationHandler)) {
+            return null;
+        }
+        return ((MockInvocationHandler) handler).handler.get();
+    }
+
+    @Override
+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
+        ((MockInvocationHandler) Proxy.getInvocationHandler(mock)).handler.set(newHandler);
+    }
+
+    @Override
+    public TypeMockability isTypeMockable(Class<?> type) {
+        return new TypeMockability() {
+            @Override
+            public boolean mockable() {
+                return type.isInterface() || type == Object.class;
+            }
+
+            @Override
+            public String nonMockableReason() {
+                return mockable() ? "" : "non-interface";
+            }
+        };
+    }
+
+    private class MockInvocationHandler implements InvocationHandler {
+
+        private final AtomicReference<MockHandler<?>> handler;
+
+        private final MockCreationSettings<?> settings;
+
+        private MockInvocationHandler(MockHandler<?> handler, MockCreationSettings<?> settings) {
+            this.handler = new AtomicReference<>(handler);
+            this.settings = settings;
+        }
+
+        @Override
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            if (args == null) {
+                args = EMPTY;
+            }
+            if (method.getDeclaringClass() == Object.class) {
+                switch (method.getName()) {
+                    case "hashCode":
+                        return System.identityHashCode(proxy);
+                    case "equals":
+                        return proxy == args[0];
+                    case "toString":
+                        break;
+                    default:
+                        throw new MockitoException(
+                                join(
+                                        "Unexpected overridable method of Object class found",
+                                        "",
+                                        "The method "
+                                                + method
+                                                + " was not expected to be declared. Either your JVM build offers "
+                                                + "non-official API or the current functionality is not supported",
+                                        Platform.describe()));
+                }
+            }
+            RealMethod realMethod;
+            if (Modifier.isAbstract(method.getModifiers())) {
+                realMethod = RealMethod.IsIllegal.INSTANCE;
+            } else {
+                realMethod = proxyRealMethod.resolve(proxy, method, args);
+            }
+            return handler.get()
+                    .handle(
+                            createInvocation(
+                                    proxy, method, args, realMethod, settings, new LocationImpl()));
+        }
+    }
+
+    private static class CommonClassLoader extends ClassLoader {
+
+        private final ClassLoader left, right;
+
+        private CommonClassLoader(ClassLoader left, ClassLoader right) {
+            super(null);
+            this.left = left;
+            this.right = right;
+        }
+
+        @Override
+        public Class<?> loadClass(String name) throws ClassNotFoundException {
+            try {
+                return left.loadClass(name);
+            } catch (ClassNotFoundException ignored) {
+                return right.loadClass(name);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/proxy/ProxyRealMethod.java b/src/main/java/org/mockito/internal/creation/proxy/ProxyRealMethod.java
new file mode 100644
index 0000000..a6f140d
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/proxy/ProxyRealMethod.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.proxy;
+
+import org.mockito.internal.invocation.RealMethod;
+
+import java.lang.reflect.Method;
+
+interface ProxyRealMethod {
+
+    RealMethod resolve(Object proxy, Method method, Object[] args);
+
+    static ProxyRealMethod make() {
+        // From Java 16 on, there is a standard API for invoking a default method from an invocation
+        // handler.
+        try {
+            return new InvokeDefaultProxy();
+        } catch (Throwable ignored) {
+        }
+        // Java 8 does not yet allow special method invocation via proxies. Therefore, we need to
+        // deep reflect what is no longer allowed after Java 8.
+        try {
+            return new MethodHandleProxy.LegacyVersion();
+        } catch (Throwable ignored) {
+        }
+        // Between Java 9 and 15, a default method can be invoked via regular method handle
+        // invocation.
+        try {
+            return new MethodHandleProxy();
+        } catch (Throwable ignored) {
+        }
+        // Nothing works, this might happen on Android where method handles are not supported on old
+        // versions. Default methods cannot be invoked.
+        return (proxy, method, args) -> RealMethod.IsIllegal.INSTANCE;
+    }
+}
diff --git a/src/main/java/org/mockito/runners/package-info.java b/src/main/java/org/mockito/internal/creation/proxy/package-info.java
similarity index 53%
rename from src/main/java/org/mockito/runners/package-info.java
rename to src/main/java/org/mockito/internal/creation/proxy/package-info.java
index ab2fb8c..0649d3b 100644
--- a/src/main/java/org/mockito/runners/package-info.java
+++ b/src/main/java/org/mockito/internal/creation/proxy/package-info.java
@@ -4,7 +4,6 @@
  */
 
 /**
- * JUnit runners.
+ * Mock makers based on the {@link java.lang.reflect.Proxy} utility.
  */
-@Deprecated
-package org.mockito.runners;
+package org.mockito.internal.creation.proxy;
diff --git a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
index 81f52f9..9da7311 100644
--- a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
+++ b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
@@ -4,34 +4,41 @@
  */
 package org.mockito.internal.creation.settings;
 
-import org.mockito.internal.listeners.StubbingLookupListener;
-import org.mockito.listeners.InvocationListener;
-import org.mockito.listeners.VerificationStartedListener;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.mock.MockName;
-import org.mockito.mock.SerializableMode;
-import org.mockito.stubbing.Answer;
-
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.StubbingLookupListener;
+import org.mockito.listeners.VerificationStartedListener;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.mock.MockName;
+import org.mockito.mock.SerializableMode;
+import org.mockito.stubbing.Answer;
 
 public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {
     private static final long serialVersionUID = -6789800638070123629L;
 
     protected Class<T> typeToMock;
-    protected Set<Class<?>> extraInterfaces = new LinkedHashSet<Class<?>>();
+    protected Set<Class<?>> extraInterfaces = new LinkedHashSet<>();
     protected String name;
     protected Object spiedInstance;
     protected Answer<Object> defaultAnswer;
     protected MockName mockName;
     protected SerializableMode serializableMode = SerializableMode.NONE;
-    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();
-    protected final List<StubbingLookupListener> stubbingLookupListeners = new ArrayList<StubbingLookupListener>();
-    protected List<VerificationStartedListener> verificationStartedListeners = new LinkedList<VerificationStartedListener>();
+    protected List<InvocationListener> invocationListeners = new ArrayList<>();
+
+    // Other listeners in this class may also need concurrency-safe implementation. However, no
+    // issue was reported about it.
+    // If we do it, we need to understand usage patterns and choose the right concurrent
+    // implementation.
+    protected List<StubbingLookupListener> stubbingLookupListeners = new CopyOnWriteArrayList<>();
+
+    protected List<VerificationStartedListener> verificationStartedListeners = new LinkedList<>();
     protected boolean stubOnly;
     protected boolean stripAnnotations;
     private boolean useConstructor;
@@ -43,6 +50,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
 
     @SuppressWarnings("unchecked")
     public CreationSettings(CreationSettings copy) {
+        // TODO can we have a reflection test here? We had a couple of bugs here in the past.
         this.typeToMock = copy.typeToMock;
         this.extraInterfaces = copy.extraInterfaces;
         this.name = copy.name;
@@ -51,6 +59,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         this.mockName = copy.mockName;
         this.serializableMode = copy.serializableMode;
         this.invocationListeners = copy.invocationListeners;
+        this.stubbingLookupListeners = copy.stubbingLookupListeners;
         this.verificationStartedListeners = copy.verificationStartedListeners;
         this.stubOnly = copy.stubOnly;
         this.useConstructor = copy.isUsingConstructor();
@@ -104,6 +113,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return this;
     }
 
+    @Override
     public boolean isSerializable() {
         return serializableMode != SerializableMode.NONE;
     }
@@ -128,6 +138,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return verificationStartedListeners;
     }
 
+    @Override
     public List<StubbingLookupListener> getStubbingLookupListeners() {
         return stubbingLookupListeners;
     }
diff --git a/src/main/java/org/mockito/internal/creation/util/MockitoMethodProxy.java b/src/main/java/org/mockito/internal/creation/util/MockitoMethodProxy.java
index 585a0c1..21642e4 100644
--- a/src/main/java/org/mockito/internal/creation/util/MockitoMethodProxy.java
+++ b/src/main/java/org/mockito/internal/creation/util/MockitoMethodProxy.java
@@ -4,7 +4,7 @@
  */
 package org.mockito.internal.creation.util;
 
-//TODO SF Replace with RealMethod and get rid of (possibly).
+// TODO SF Replace with RealMethod and get rid of (possibly).
 public interface MockitoMethodProxy {
     Object invokeSuper(Object target, Object[] arguments);
 }
diff --git a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
index 04a4f1d..7e26169 100644
--- a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
+++ b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.debugging;
 
+import java.util.Collection;
+import java.util.LinkedList;
+
 import org.mockito.Mockito;
 import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.invocation.Invocation;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Collection;
-import java.util.LinkedList;
-
 /**
  * Prints invocations in human-readable, printable way
  */
@@ -26,22 +26,26 @@ public class InvocationsPrinter {
 
         StringBuilder sb = new StringBuilder();
         int x = 1;
-        for(Invocation i:invocations) {
+        for (Invocation i : invocations) {
             if (x == 1) {
                 sb.append("[Mockito] Interactions of: ").append(mock).append("\n");
             }
-            sb.append(" ").append(x++).append(". ").append(i.toString()).append("\n");
+            sb.append(" ").append(x++).append(". ").append(i).append("\n");
             sb.append("  ").append(i.getLocation()).append("\n");
             if (i.stubInfo() != null) {
                 sb.append("   - stubbed ").append(i.stubInfo().stubbedAt()).append("\n");
             }
         }
 
-        LinkedList<Stubbing> unused = ListUtil.filter(stubbings, new ListUtil.Filter<Stubbing>() {
-            public boolean isOut(Stubbing s) {
-                return s.wasUsed();
-            }
-        });
+        LinkedList<Stubbing> unused =
+                ListUtil.filter(
+                        stubbings,
+                        new ListUtil.Filter<Stubbing>() {
+                            @Override
+                            public boolean isOut(Stubbing s) {
+                                return s.wasUsed();
+                            }
+                        });
 
         if (unused.isEmpty()) {
             return sb.toString();
@@ -49,7 +53,7 @@ public class InvocationsPrinter {
         sb.append("[Mockito] Unused stubbings of: ").append(mock).append("\n");
 
         x = 1;
-        for(Stubbing s:stubbings) {
+        for (Stubbing s : stubbings) {
             sb.append(" ").append(x++).append(". ").append(s.getInvocation()).append("\n");
             sb.append("  - stubbed ").append(s.getInvocation().getLocation()).append("\n");
         }
diff --git a/src/main/java/org/mockito/internal/debugging/Localized.java b/src/main/java/org/mockito/internal/debugging/Localized.java
index 0588042..d1d7912 100644
--- a/src/main/java/org/mockito/internal/debugging/Localized.java
+++ b/src/main/java/org/mockito/internal/debugging/Localized.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.internal.debugging;
 
-
 import org.mockito.invocation.Location;
 
 public class Localized<T> {
diff --git a/src/main/java/org/mockito/internal/debugging/LocationImpl.java b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
index 8561b62..cf25501 100644
--- a/src/main/java/org/mockito/internal/debugging/LocationImpl.java
+++ b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
@@ -5,42 +5,63 @@
 package org.mockito.internal.debugging;
 
 import java.io.Serializable;
+
 import org.mockito.internal.exceptions.stacktrace.StackTraceFilter;
 import org.mockito.invocation.Location;
 
 public class LocationImpl implements Location, Serializable {
 
     private static final long serialVersionUID = -9054861157390980624L;
-    //Limit the amount of objects being created, as this class is heavily instantiated:
-    private static final StackTraceFilter defaultStackTraceFilter = new StackTraceFilter();
+    // Limit the amount of objects being created, as this class is heavily instantiated:
+    private static final StackTraceFilter stackTraceFilter = new StackTraceFilter();
 
-    private final Throwable stackTraceHolder;
-    private final StackTraceFilter stackTraceFilter;
+    private String stackTraceLine;
+    private String sourceFile;
 
     public LocationImpl() {
-        this(defaultStackTraceFilter);
+        this(new Throwable(), false);
     }
 
-    public LocationImpl(StackTraceFilter stackTraceFilter) {
-        this(stackTraceFilter, new Throwable());
+    public LocationImpl(Throwable stackTraceHolder, boolean isInline) {
+        this(stackTraceFilter, stackTraceHolder, isInline);
     }
 
-    public LocationImpl(Throwable stackTraceHolder) {
-        this(defaultStackTraceFilter, stackTraceHolder);
+    public LocationImpl(StackTraceFilter stackTraceFilter) {
+        this(stackTraceFilter, new Throwable(), false);
     }
 
-    private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
-        this.stackTraceFilter = stackTraceFilter;
-        this.stackTraceHolder = stackTraceHolder;
+    private LocationImpl(
+            StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
+        computeStackTraceInformation(stackTraceFilter, stackTraceHolder, isInline);
     }
 
     @Override
     public String toString() {
-        //TODO SF perhaps store the results after invocation?
-        StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
-        if (filtered.length == 0) {
-            return "-> at <<unknown line>>";
+        return stackTraceLine;
+    }
+
+    /**
+     * Eagerly compute the stacktrace line from the stackTraceHolder. Storing the Throwable is
+     * memory-intensive for tests that have large stacktraces and have a lot of invocations on
+     * mocks.
+     */
+    private void computeStackTraceInformation(
+            StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
+        StackTraceElement filtered = stackTraceFilter.filterFirst(stackTraceHolder, isInline);
+
+        // there are corner cases where exception can have a null or empty stack trace
+        // for example, a custom exception can override getStackTrace() method
+        if (filtered == null) {
+            this.stackTraceLine = "-> at <<unknown line>>";
+            this.sourceFile = "<unknown source file>";
+        } else {
+            this.stackTraceLine = "-> at " + filtered;
+            this.sourceFile = filtered.getFileName();
         }
-        return "-> at " + filtered[0].toString();
+    }
+
+    @Override
+    public String getSourceFile() {
+        return sourceFile;
     }
 }
diff --git a/src/main/java/org/mockito/internal/debugging/LoggingListener.java b/src/main/java/org/mockito/internal/debugging/LoggingListener.java
index d014e87..6e0a645 100644
--- a/src/main/java/org/mockito/internal/debugging/LoggingListener.java
+++ b/src/main/java/org/mockito/internal/debugging/LoggingListener.java
@@ -4,35 +4,37 @@
  */
 package org.mockito.internal.debugging;
 
-import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.invocation.Invocation;
+import static org.mockito.internal.util.StringUtil.join;
 
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.mockito.internal.util.StringUtil.join;
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.invocation.Invocation;
 
 public class LoggingListener implements FindingsListener {
     private final boolean warnAboutUnstubbed;
 
-    private final List<String> argMismatchStubs = new LinkedList<String>();
-    private final List<String> unusedStubs = new LinkedList<String>();
-    private final List<String> unstubbedCalls = new LinkedList<String>();
+    private final List<String> argMismatchStubs = new LinkedList<>();
+    private final List<String> unusedStubs = new LinkedList<>();
+    private final List<String> unstubbedCalls = new LinkedList<>();
 
     public LoggingListener(boolean warnAboutUnstubbed) {
         this.warnAboutUnstubbed = warnAboutUnstubbed;
     }
 
+    @Override
     public void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed) {
-        //TODO there is not good reason we should get Invocation and InvocationMatcher here
+        // TODO there is not good reason we should get Invocation and InvocationMatcher here
         // we should pass 2 InvocationMatchers and testing is easier
-        // it's also confusing that unstubbed invocation is passed as InvocationMatcher (should be rather Invocation)
+        // it's also confusing that unstubbed invocation is passed as InvocationMatcher (should be
+        // rather Invocation)
 
-        //this information comes in pairs
+        // this information comes in pairs
         String index = Integer.toString(indexOfNextPair(argMismatchStubs.size()));
-        //making sure indentation is correct
+        // making sure indentation is correct
         String padding = index.replaceAll("\\d", " ");
-        argMismatchStubs.add(index +   ". Stubbed " + unused.getLocation());
+        argMismatchStubs.add(index + ". Stubbed " + unused.getLocation());
         argMismatchStubs.add(padding + "  Invoked " + unstubbed.getInvocation().getLocation());
     }
 
@@ -40,13 +42,16 @@ public class LoggingListener implements FindingsListener {
         return (collectionSize / 2) + 1;
     }
 
+    @Override
     public void foundUnusedStub(Invocation unused) {
         unusedStubs.add((unusedStubs.size() + 1) + ". " + unused.getLocation());
     }
 
+    @Override
     public void foundUnstubbed(InvocationMatcher unstubbed) {
         if (warnAboutUnstubbed) {
-            unstubbedCalls.add((unstubbedCalls.size() + 1) + ". " + unstubbed.getInvocation().getLocation());
+            unstubbedCalls.add(
+                    (unstubbedCalls.size() + 1) + ". " + unstubbed.getInvocation().getLocation());
         }
     }
 
@@ -55,12 +60,14 @@ public class LoggingListener implements FindingsListener {
             return "";
         }
 
-        List<String> lines = new LinkedList<String>();
-        lines.add("[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):");
+        List<String> lines = new LinkedList<>();
+        lines.add(
+                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):");
 
         if (!argMismatchStubs.isEmpty()) {
             lines.add("[Mockito]");
-            lines.add("[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):");
+            lines.add(
+                    "[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):");
             lines.add("[Mockito]");
             addOrderedList(lines, argMismatchStubs);
         }
@@ -74,7 +81,8 @@ public class LoggingListener implements FindingsListener {
 
         if (!unstubbedCalls.isEmpty()) {
             lines.add("[Mockito]");
-            lines.add("[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):");
+            lines.add(
+                    "[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):");
             lines.add("[Mockito]");
             addOrderedList(lines, unstubbedCalls);
         }
diff --git a/src/main/java/org/mockito/internal/debugging/MockitoDebuggerImpl.java b/src/main/java/org/mockito/internal/debugging/MockitoDebuggerImpl.java
deleted file mode 100644
index c14f0ab..0000000
--- a/src/main/java/org/mockito/internal/debugging/MockitoDebuggerImpl.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.debugging;
-
-import org.mockito.MockitoDebugger;
-import org.mockito.internal.invocation.UnusedStubsFinder;
-import org.mockito.internal.invocation.finder.AllInvocationsFinder;
-import org.mockito.invocation.Invocation;
-
-import java.util.List;
-
-import static java.util.Arrays.asList;
-
-public class MockitoDebuggerImpl implements MockitoDebugger {
-
-    private final UnusedStubsFinder unusedStubsFinder = new UnusedStubsFinder();
-
-    /**
-     * TODO: when MockitoDebugger is deleted, delete this implementation, too
-     */
-    @Deprecated
-    public String printInvocations(Object ... mocks) {
-        String out = "";
-        List<Invocation> invocations = AllInvocationsFinder.find(asList(mocks));
-        out += line("********************************");
-        out += line("*** Mockito interactions log ***");
-        out += line("********************************");
-        for(Invocation i:invocations) {
-            out += line(i.toString());
-            out += line(" invoked: " + i.getLocation());
-            if (i.stubInfo() != null) {
-                out += line(" stubbed: " + i.stubInfo().stubbedAt().toString());
-            }
-        }
-
-        invocations = unusedStubsFinder.find(asList(mocks));
-        if (invocations.isEmpty()) {
-            return print(out);
-        }
-        out += line("********************************");
-        out += line("***       Unused stubs       ***");
-        out += line("********************************");
-
-        for(Invocation i:invocations) {
-            out += line(i.toString());
-            out += line(" stubbed: " + i.getLocation());
-        }
-        return print(out);
-    }
-
-    private String line(String text) {
-        return text + "\n";
-    }
-
-    private String print(String out) {
-        System.out.println(out);
-        return out;
-    }
-}
diff --git a/src/main/java/org/mockito/internal/debugging/VerboseMockInvocationLogger.java b/src/main/java/org/mockito/internal/debugging/VerboseMockInvocationLogger.java
index c7b6ff6..a78be31 100644
--- a/src/main/java/org/mockito/internal/debugging/VerboseMockInvocationLogger.java
+++ b/src/main/java/org/mockito/internal/debugging/VerboseMockInvocationLogger.java
@@ -2,10 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.debugging;
 
 import java.io.PrintStream;
+
 import org.mockito.invocation.DescribedInvocation;
 import org.mockito.listeners.InvocationListener;
 import org.mockito.listeners.MethodInvocationReport;
@@ -30,6 +30,7 @@ public class VerboseMockInvocationLogger implements InvocationListener {
         this.printStream = printStream;
     }
 
+    @Override
     public void reportInvocation(MethodInvocationReport methodInvocationReport) {
         printHeader();
         printStubInfo(methodInvocationReport);
@@ -40,11 +41,21 @@ public class VerboseMockInvocationLogger implements InvocationListener {
 
     private void printReturnedValueOrThrowable(MethodInvocationReport methodInvocationReport) {
         if (methodInvocationReport.threwException()) {
-            String message = methodInvocationReport.getThrowable().getMessage() == null ? "" : " with message " + methodInvocationReport.getThrowable().getMessage();
-            printlnIndented("has thrown: " + methodInvocationReport.getThrowable().getClass() + message);
+            String message =
+                    methodInvocationReport.getThrowable().getMessage() == null
+                            ? ""
+                            : " with message " + methodInvocationReport.getThrowable().getMessage();
+            printlnIndented(
+                    "has thrown: " + methodInvocationReport.getThrowable().getClass() + message);
         } else {
-            String type = (methodInvocationReport.getReturnedValue() == null) ? "" : " (" + methodInvocationReport.getReturnedValue().getClass().getName() + ")";
-            printlnIndented("has returned: \"" + methodInvocationReport.getReturnedValue() + "\"" + type);
+            String type =
+                    (methodInvocationReport.getReturnedValue() == null)
+                            ? ""
+                            : " ("
+                                    + methodInvocationReport.getReturnedValue().getClass().getName()
+                                    + ")";
+            printlnIndented(
+                    "has returned: \"" + methodInvocationReport.getReturnedValue() + "\"" + type);
         }
     }
 
@@ -56,21 +67,23 @@ public class VerboseMockInvocationLogger implements InvocationListener {
 
     private void printHeader() {
         mockInvocationsCounter++;
-        printStream.println("############ Logging method invocation #" + mockInvocationsCounter + " on mock/spy ########");
+        printStream.println(
+                "############ Logging method invocation #"
+                        + mockInvocationsCounter
+                        + " on mock/spy ########");
     }
 
     private void printInvocation(DescribedInvocation invocation) {
-        printStream.println(invocation.toString());
-//        printStream.println("Handling method call on a mock/spy.");
-        printlnIndented("invoked: " + invocation.getLocation().toString());
+        printStream.println(invocation);
+        //        printStream.println("Handling method call on a mock/spy.");
+        printlnIndented("invoked: " + invocation.getLocation());
     }
 
     private void printFooter() {
-        printStream.println("");
+        printStream.println();
     }
 
     private void printlnIndented(String message) {
         printStream.println("   " + message);
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/debugging/WarningsCollector.java b/src/main/java/org/mockito/internal/debugging/WarningsCollector.java
deleted file mode 100644
index 3fb3e0e..0000000
--- a/src/main/java/org/mockito/internal/debugging/WarningsCollector.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.debugging;
-
-import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.internal.invocation.UnusedStubsFinder;
-import org.mockito.internal.invocation.finder.AllInvocationsFinder;
-import org.mockito.invocation.Invocation;
-
-import java.util.LinkedList;
-import java.util.List;
-
-@Deprecated
-public class WarningsCollector {
-
-    private final List<Object> createdMocks;
-
-    public WarningsCollector() {
-        createdMocks = new LinkedList<Object>();
-    }
-
-    public String getWarnings() {
-        List<Invocation> unused = new UnusedStubsFinder().find(createdMocks);
-        List<Invocation> all = AllInvocationsFinder.find(createdMocks);
-        List<InvocationMatcher> allInvocationMatchers = InvocationMatcher.createFrom(all);
-
-        return new WarningsPrinterImpl(unused, allInvocationMatchers, false).print();
-    }
-}
diff --git a/src/main/java/org/mockito/internal/debugging/WarningsFinder.java b/src/main/java/org/mockito/internal/debugging/WarningsFinder.java
index 8b7c457..c766366 100644
--- a/src/main/java/org/mockito/internal/debugging/WarningsFinder.java
+++ b/src/main/java/org/mockito/internal/debugging/WarningsFinder.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.debugging;
 
-import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.invocation.Invocation;
-
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.invocation.Invocation;
+
 public class WarningsFinder {
     private final List<Invocation> baseUnusedStubs;
     private final List<InvocationMatcher> baseAllInvocations;
@@ -21,16 +21,16 @@ public class WarningsFinder {
     }
 
     public void find(FindingsListener findingsListener) {
-        List<Invocation> unusedStubs = new LinkedList<Invocation>(this.baseUnusedStubs);
-        List<InvocationMatcher> allInvocations = new LinkedList<InvocationMatcher>(this.baseAllInvocations);
+        List<Invocation> unusedStubs = new LinkedList<>(this.baseUnusedStubs);
+        List<InvocationMatcher> allInvocations = new LinkedList<>(this.baseAllInvocations);
 
         Iterator<Invocation> unusedIterator = unusedStubs.iterator();
-        while(unusedIterator.hasNext()) {
+        while (unusedIterator.hasNext()) {
             Invocation unused = unusedIterator.next();
             Iterator<InvocationMatcher> unstubbedIterator = allInvocations.iterator();
-            while(unstubbedIterator.hasNext()) {
+            while (unstubbedIterator.hasNext()) {
                 InvocationMatcher unstubbed = unstubbedIterator.next();
-                if(unstubbed.hasSimilarMethod(unused)) {
+                if (unstubbed.hasSimilarMethod(unused)) {
                     findingsListener.foundStubCalledWithDifferentArgs(unused, unstubbed);
                     unusedIterator.remove();
                     unstubbedIterator.remove();
diff --git a/src/main/java/org/mockito/internal/debugging/WarningsPrinterImpl.java b/src/main/java/org/mockito/internal/debugging/WarningsPrinterImpl.java
index ca18e85..e02e139 100644
--- a/src/main/java/org/mockito/internal/debugging/WarningsPrinterImpl.java
+++ b/src/main/java/org/mockito/internal/debugging/WarningsPrinterImpl.java
@@ -4,17 +4,20 @@
  */
 package org.mockito.internal.debugging;
 
+import java.util.List;
+
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.invocation.Invocation;
 
-import java.util.List;
-
 public class WarningsPrinterImpl {
 
     private final boolean warnAboutUnstubbed;
     private final WarningsFinder finder;
 
-    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {
+    public WarningsPrinterImpl(
+            List<Invocation> unusedStubs,
+            List<InvocationMatcher> allInvocations,
+            boolean warnAboutUnstubbed) {
         this(warnAboutUnstubbed, new WarningsFinder(unusedStubs, allInvocations));
     }
 
diff --git a/src/main/java/org/mockito/internal/exceptions/Reporter.java b/src/main/java/org/mockito/internal/exceptions/Reporter.java
index 38135a0..f91c6e1 100644
--- a/src/main/java/org/mockito/internal/exceptions/Reporter.java
+++ b/src/main/java/org/mockito/internal/exceptions/Reporter.java
@@ -2,17 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions;
 
+import static org.mockito.internal.reporting.Pluralizer.pluralize;
+import static org.mockito.internal.reporting.Pluralizer.were_exactly_x_interactions;
+import static org.mockito.internal.util.StringUtil.join;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.*;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.base.MockitoInitializationException;
 import org.mockito.exceptions.misusing.*;
 import org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;
 import org.mockito.exceptions.verification.NeverWantedButInvoked;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.SmartNullPointerException;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.TooManyActualInvocations;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
@@ -26,19 +33,8 @@ import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.invocation.Location;
 import org.mockito.listeners.InvocationListener;
-import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import static org.mockito.internal.reporting.Pluralizer.pluralize;
-import static org.mockito.internal.reporting.Pluralizer.were_exactly_x_interactions;
-import static org.mockito.internal.util.StringUtil.join;
-
 /**
  * Reports verification and misusing errors.
  * <p>
@@ -52,283 +48,314 @@ import static org.mockito.internal.util.StringUtil.join;
  */
 public class Reporter {
 
-    private final static String NON_PUBLIC_PARENT = "Mocking methods declared on non-public parent classes is not supported.";
+    private static final String NON_PUBLIC_PARENT =
+            "Mocking methods declared on non-public parent classes is not supported.";
 
-    private Reporter() {
-    }
+    private Reporter() {}
 
     public static MockitoException checkedExceptionInvalid(Throwable t) {
-        return new MockitoException(join(
-                "Checked exception is invalid for this method!",
-                "Invalid: " + t
-        ));
+        return new MockitoException(
+                join("Checked exception is invalid for this method!", "Invalid: " + t));
     }
 
     public static MockitoException cannotStubWithNullThrowable() {
-        return new MockitoException(join(
-                "Cannot stub with null throwable!"
-        ));
-
+        return new MockitoException(join("Cannot stub with null throwable!"));
     }
 
     public static MockitoException unfinishedStubbing(Location location) {
-        return new UnfinishedStubbingException(join(
-                "Unfinished stubbing detected here:",
-                location,
-                "",
-                "E.g. thenReturn() may be missing.",
-                "Examples of correct stubbing:",
-                "    when(mock.isOk()).thenReturn(true);",
-                "    when(mock.isOk()).thenThrow(exception);",
-                "    doThrow(exception).when(mock).someVoidMethod();",
-                "Hints:",
-                " 1. missing thenReturn()",
-                " 2. you are trying to stub a final method, which is not supported",
-                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
-                ""
-        ));
+        return new UnfinishedStubbingException(
+                join(
+                        "Unfinished stubbing detected here:",
+                        location,
+                        "",
+                        "E.g. thenReturn() may be missing.",
+                        "Examples of correct stubbing:",
+                        "    when(mock.isOk()).thenReturn(true);",
+                        "    when(mock.isOk()).thenThrow(exception);",
+                        "    doThrow(exception).when(mock).someVoidMethod();",
+                        "Hints:",
+                        " 1. missing thenReturn()",
+                        " 2. you are trying to stub a final method, which is not supported",
+                        " 3. you are stubbing the behaviour of another mock inside before 'thenReturn' instruction is completed",
+                        ""));
     }
 
     public static MockitoException incorrectUseOfApi() {
-        return new MockitoException(join(
-                "Incorrect use of API detected here:",
-                new LocationImpl(),
-                "",
-                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
-                "Examples of correct usage:",
-                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
-                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
-                ""
-        ));
+        return new MockitoException(
+                join(
+                        "Incorrect use of API detected here:",
+                        new LocationImpl(),
+                        "",
+                        "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
+                        "Examples of correct usage:",
+                        "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
+                        "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
+                        ""));
     }
 
     public static MockitoException missingMethodInvocation() {
-        return new MissingMethodInvocationException(join(
-                "when() requires an argument which has to be 'a method call on a mock'.",
-                "For example:",
-                "    when(mock.getArticles()).thenReturn(articles);",
-                "",
-                "Also, this error might show up because:",
-                "1. you stub either of: final/private/equals()/hashCode() methods.",
-                "   Those methods *cannot* be stubbed/verified.",
-                "   " + NON_PUBLIC_PARENT,
-                "2. inside when() you don't call method on mock but on some other object.",
-                ""
-        ));
+        return new MissingMethodInvocationException(
+                join(
+                        "when() requires an argument which has to be 'a method call on a mock'.",
+                        "For example:",
+                        "    when(mock.getArticles()).thenReturn(articles);",
+                        "",
+                        "Also, this error might show up because:",
+                        "1. you stub either of: final/private/equals()/hashCode() methods.",
+                        "   Those methods *cannot* be stubbed/verified.",
+                        "   " + NON_PUBLIC_PARENT,
+                        "2. inside when() you don't call method on mock but on some other object.",
+                        ""));
     }
 
     public static MockitoException unfinishedVerificationException(Location location) {
-        return new UnfinishedVerificationException(join(
-                "Missing method call for verify(mock) here:",
-                location,
-                "",
-                "Example of correct verification:",
-                "    verify(mock).doSomething()",
-                "",
-                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
-                "Those methods *cannot* be stubbed/verified.",
-                NON_PUBLIC_PARENT,
-                ""
-        ));
+        return new UnfinishedVerificationException(
+                join(
+                        "Missing method call for verify(mock) here:",
+                        location,
+                        "",
+                        "Example of correct verification:",
+                        "    verify(mock).doSomething()",
+                        "",
+                        "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
+                        "Those methods *cannot* be stubbed/verified.",
+                        NON_PUBLIC_PARENT,
+                        ""));
     }
 
     public static MockitoException notAMockPassedToVerify(Class<?> type) {
-        return new NotAMockException(join(
-                "Argument passed to verify() is of type " + type.getSimpleName() + " and is not a mock!",
-                "Make sure you place the parenthesis correctly!",
-                "See the examples of correct verifications:",
-                "    verify(mock).someMethod();",
-                "    verify(mock, times(10)).someMethod();",
-                "    verify(mock, atLeastOnce()).someMethod();"
-        ));
+        return new NotAMockException(
+                join(
+                        "Argument passed to verify() is of type "
+                                + type.getSimpleName()
+                                + " and is not a mock!",
+                        "Make sure you place the parenthesis correctly!",
+                        "See the examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();"));
     }
 
     public static MockitoException nullPassedToVerify() {
-        return new NullInsteadOfMockException(join(
-                "Argument passed to verify() should be a mock but is null!",
-                "Examples of correct verifications:",
-                "    verify(mock).someMethod();",
-                "    verify(mock, times(10)).someMethod();",
-                "    verify(mock, atLeastOnce()).someMethod();",
-                "    not: verify(mock.someMethod());",
-                "Also, if you use @Mock annotation don't miss initMocks()"
-        ));
+        return new NullInsteadOfMockException(
+                join(
+                        "Argument passed to verify() should be a mock but is null!",
+                        "Examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();",
+                        "    not: verify(mock.someMethod());",
+                        "Also, if you use @Mock annotation don't miss openMocks()"));
     }
 
     public static MockitoException notAMockPassedToWhenMethod() {
-        return new NotAMockException(join(
-                "Argument passed to when() is not a mock!",
-                "Example of correct stubbing:",
-                "    doThrow(new RuntimeException()).when(mock).someMethod();"
-        ));
+        return new NotAMockException(
+                join(
+                        "Argument passed to when() is not a mock!",
+                        "Example of correct stubbing:",
+                        "    doThrow(new RuntimeException()).when(mock).someMethod();"));
     }
 
     public static MockitoException nullPassedToWhenMethod() {
-        return new NullInsteadOfMockException(join(
-                "Argument passed to when() is null!",
-                "Example of correct stubbing:",
-                "    doThrow(new RuntimeException()).when(mock).someMethod();",
-                "Also, if you use @Mock annotation don't miss initMocks()"
-        ));
+        return new NullInsteadOfMockException(
+                join(
+                        "Argument passed to when() is null!",
+                        "Example of correct stubbing:",
+                        "    doThrow(new RuntimeException()).when(mock).someMethod();",
+                        "Also, if you use @Mock annotation don't miss openMocks()"));
     }
 
     public static MockitoException mocksHaveToBePassedToVerifyNoMoreInteractions() {
-        return new MockitoException(join(
-                "Method requires argument(s)!",
-                "Pass mocks that should be verified, e.g:",
-                "    verifyNoMoreInteractions(mockOne, mockTwo);",
-                "    verifyZeroInteractions(mockOne, mockTwo);",
-                ""
-        ));
+        return new MockitoException(
+                join(
+                        "Method requires argument(s)!",
+                        "Pass mocks that should be verified, e.g:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);",
+                        ""));
     }
 
     public static MockitoException notAMockPassedToVerifyNoMoreInteractions() {
-        return new NotAMockException(join(
-                "Argument(s) passed is not a mock!",
-                "Examples of correct verifications:",
-                "    verifyNoMoreInteractions(mockOne, mockTwo);",
-                "    verifyZeroInteractions(mockOne, mockTwo);",
-                ""
-        ));
+        return new NotAMockException(
+                join(
+                        "Argument(s) passed is not a mock!",
+                        "Examples of correct verifications:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);",
+                        ""));
     }
 
     public static MockitoException nullPassedToVerifyNoMoreInteractions() {
-        return new NullInsteadOfMockException(join(
-                "Argument(s) passed is null!",
-                "Examples of correct verifications:",
-                "    verifyNoMoreInteractions(mockOne, mockTwo);",
-                "    verifyZeroInteractions(mockOne, mockTwo);"
-        ));
+        return new NullInsteadOfMockException(
+                join(
+                        "Argument(s) passed is null!",
+                        "Examples of correct verifications:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);"));
     }
 
     public static MockitoException notAMockPassedWhenCreatingInOrder() {
-        return new NotAMockException(join(
-                "Argument(s) passed is not a mock!",
-                "Pass mocks that require verification in order.",
-                "For example:",
-                "    InOrder inOrder = inOrder(mockOne, mockTwo);"
-        ));
+        return new NotAMockException(
+                join(
+                        "Argument(s) passed is not a mock!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);"));
     }
 
     public static MockitoException nullPassedWhenCreatingInOrder() {
-        return new NullInsteadOfMockException(join(
-                "Argument(s) passed is null!",
-                "Pass mocks that require verification in order.",
-                "For example:",
-                "    InOrder inOrder = inOrder(mockOne, mockTwo);"
-        ));
+        return new NullInsteadOfMockException(
+                join(
+                        "Argument(s) passed is null!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);"));
     }
 
     public static MockitoException mocksHaveToBePassedWhenCreatingInOrder() {
-        return new MockitoException(join(
-                "Method requires argument(s)!",
-                "Pass mocks that require verification in order.",
-                "For example:",
-                "    InOrder inOrder = inOrder(mockOne, mockTwo);"
-        ));
+        return new MockitoException(
+                join(
+                        "Method requires argument(s)!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);"));
     }
 
     public static MockitoException inOrderRequiresFamiliarMock() {
-        return new MockitoException(join(
-                "InOrder can only verify mocks that were passed in during creation of InOrder.",
-                "For example:",
-                "    InOrder inOrder = inOrder(mockOne);",
-                "    inOrder.verify(mockOne).doStuff();"
-        ));
-    }
-
-    public static MockitoException invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {
-        return new InvalidUseOfMatchersException(join(
-                "Invalid use of argument matchers!",
-                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
-                        locationsOf(recordedMatchers),
-                "",
-                "This exception may occur if matchers are combined with raw values:",
-                "    //incorrect:",
-                "    someMethod(anyObject(), \"raw String\");",
-                "When using matchers, all arguments have to be provided by matchers.",
-                "For example:",
-                "    //correct:",
-                "    someMethod(anyObject(), eq(\"String by matcher\"));",
-                "",
-                "For more info see javadoc for Matchers class.",
-                ""
-        ));
-    }
-
-    public static MockitoException incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {
-        return new InvalidUseOfMatchersException(join(
-                "Invalid use of argument matchers inside additional matcher " + additionalMatcherName + " !",
-                new LocationImpl(),
-                "",
-                expectedSubMatchersCount + " sub matchers expected, " + matcherStack.size() + " recorded:",
-                locationsOf(matcherStack),
-                "",
-                "This exception may occur if matchers are combined with raw values:",
-                "    //incorrect:",
-                "    someMethod(AdditionalMatchers.and(isNotNull(), \"raw String\");",
-                "When using matchers, all arguments have to be provided by matchers.",
-                "For example:",
-                "    //correct:",
-                "    someMethod(AdditionalMatchers.and(isNotNull(), eq(\"raw String\"));",
-                "",
-                "For more info see javadoc for Matchers and AdditionalMatchers classes.",
-                ""
-        ));
-    }
-
-    public static MockitoException stubPassedToVerify() {
-        return new CannotVerifyStubOnlyMock(join(
-                "Argument passed to verify() is a stubOnly() mock, not a full blown mock!",
-                "If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings."
-        ));
+        return new MockitoException(
+                join(
+                        "InOrder can only verify mocks that were passed in during creation of InOrder.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne);",
+                        "    inOrder.verify(mockOne).doStuff();"));
+    }
+
+    public static MockitoException invalidUseOfMatchers(
+            int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {
+        return new InvalidUseOfMatchersException(
+                join(
+                        "Invalid use of argument matchers!",
+                        expectedMatchersCount
+                                + " matchers expected, "
+                                + recordedMatchers.size()
+                                + " recorded:"
+                                + locationsOf(recordedMatchers),
+                        "",
+                        "This exception may occur if matchers are combined with raw values:",
+                        "    //incorrect:",
+                        "    someMethod(any(), \"raw String\");",
+                        "When using matchers, all arguments have to be provided by matchers.",
+                        "For example:",
+                        "    //correct:",
+                        "    someMethod(any(), eq(\"String by matcher\"));",
+                        "",
+                        "For more info see javadoc for Matchers class.",
+                        ""));
+    }
+
+    public static MockitoException incorrectUseOfAdditionalMatchers(
+            String additionalMatcherName,
+            int expectedSubMatchersCount,
+            Collection<LocalizedMatcher> matcherStack) {
+        return new InvalidUseOfMatchersException(
+                join(
+                        "Invalid use of argument matchers inside additional matcher "
+                                + additionalMatcherName
+                                + " !",
+                        new LocationImpl(),
+                        "",
+                        expectedSubMatchersCount
+                                + " sub matchers expected, "
+                                + matcherStack.size()
+                                + " recorded:",
+                        locationsOf(matcherStack),
+                        "",
+                        "This exception may occur if matchers are combined with raw values:",
+                        "    //incorrect:",
+                        "    someMethod(AdditionalMatchers.and(isNotNull(), \"raw String\");",
+                        "When using matchers, all arguments have to be provided by matchers.",
+                        "For example:",
+                        "    //correct:",
+                        "    someMethod(AdditionalMatchers.and(isNotNull(), eq(\"raw String\"));",
+                        "",
+                        "For more info see javadoc for Matchers and AdditionalMatchers classes.",
+                        ""));
+    }
+
+    public static MockitoException stubPassedToVerify(Object mock) {
+        return new CannotVerifyStubOnlyMock(
+                join(
+                        "Argument \""
+                                + MockUtil.getMockName(mock)
+                                + "\" passed to verify is a stubOnly() mock which cannot be verified.",
+                        "If you intend to verify invocations on this mock, don't use stubOnly() in its MockSettings."));
     }
 
     public static MockitoException reportNoSubMatchersFound(String additionalMatcherName) {
-        return new InvalidUseOfMatchersException(join(
-                "No matchers found for additional matcher " + additionalMatcherName,
-                new LocationImpl(),
-                ""
-        ));
+        return new InvalidUseOfMatchersException(
+                join(
+                        "No matchers found for additional matcher " + additionalMatcherName,
+                        new LocationImpl(),
+                        ""));
     }
 
-
     private static Object locationsOf(Collection<LocalizedMatcher> matchers) {
-        List<String> description = new ArrayList<String>();
-        for (LocalizedMatcher matcher : matchers)
+        List<String> description = new ArrayList<>();
+        for (LocalizedMatcher matcher : matchers) {
             description.add(matcher.getLocation().toString());
+        }
         return join(description.toArray());
     }
 
-    public static AssertionError argumentsAreDifferent(String wanted, String actual, Location actualLocation) {
-        String message = join("Argument(s) are different! Wanted:",
-                              wanted,
-                              new LocationImpl(),
-                              "Actual invocation has different arguments:",
-                              actual,
-                              actualLocation,
-                              ""
-        );
+    public static AssertionError argumentsAreDifferent(
+            String wanted, List<String> actualCalls, List<Location> actualLocations) {
+        if (actualCalls == null
+                || actualLocations == null
+                || actualCalls.size() != actualLocations.size()) {
+            throw new IllegalArgumentException("actualCalls and actualLocations list must match");
+        }
+
+        StringBuilder actualBuilder = new StringBuilder();
+        StringBuilder messageBuilder = new StringBuilder();
+        messageBuilder
+                .append("\n")
+                .append("Argument(s) are different! Wanted:\n")
+                .append(wanted)
+                .append("\n")
+                .append(new LocationImpl())
+                .append("\n")
+                .append("Actual invocations have different arguments:\n");
+
+        for (int i = 0; i < actualCalls.size(); i++) {
+            actualBuilder.append(actualCalls.get(i)).append("\n");
+
+            messageBuilder
+                    .append(actualCalls.get(i))
+                    .append("\n")
+                    .append(actualLocations.get(i))
+                    .append("\n");
+        }
 
-        return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
+        return ExceptionFactory.createArgumentsAreDifferentException(
+                messageBuilder.toString(), wanted, actualBuilder.toString());
     }
 
     public static MockitoAssertionError wantedButNotInvoked(DescribedInvocation wanted) {
         return new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));
     }
 
-    public static MockitoAssertionError wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {
+    public static MockitoAssertionError wantedButNotInvoked(
+            DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {
         String allInvocations;
         if (invocations.isEmpty()) {
             allInvocations = "Actually, there were zero interactions with this mock.\n";
         } else {
-            StringBuilder sb = new StringBuilder(
-                    "\nHowever, there " + were_exactly_x_interactions(invocations.size()) + " with this mock:\n");
+            StringBuilder sb =
+                    new StringBuilder("\nHowever, there ")
+                            .append(were_exactly_x_interactions(invocations.size()))
+                            .append(" with this mock:\n");
             for (DescribedInvocation i : invocations) {
-                sb.append(i.toString())
-                  .append("\n")
-                  .append(i.getLocation())
-                  .append("\n\n");
+                sb.append(i).append("\n").append(i.getLocation()).append("\n\n");
             }
             allInvocations = sb.toString();
         }
@@ -338,59 +365,67 @@ public class Reporter {
     }
 
     private static String createWantedButNotInvokedMessage(DescribedInvocation wanted) {
-        return join(
-                "Wanted but not invoked:",
-                wanted.toString(),
-                new LocationImpl(),
-                ""
-        );
-    }
-
-    public static MockitoAssertionError wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {
-        return new VerificationInOrderFailure(join(
-                "Verification in order failure",
-                "Wanted but not invoked:",
-                wanted.toString(),
-                new LocationImpl(),
-                "Wanted anywhere AFTER following interaction:",
-                previous.toString(),
-                previous.getLocation(),
-                ""
-        ));
-    }
-
-    public static MockitoAssertionError tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, List<Location> locations) {
-        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, locations);
+        return join("Wanted but not invoked:", wanted.toString(), new LocationImpl(), "");
+    }
+
+    public static MockitoAssertionError wantedButNotInvokedInOrder(
+            DescribedInvocation wanted, DescribedInvocation previous) {
+        return new VerificationInOrderFailure(
+                join(
+                        "Verification in order failure",
+                        "Wanted but not invoked:",
+                        wanted.toString(),
+                        new LocationImpl(),
+                        "Wanted anywhere AFTER following interaction:",
+                        previous.toString(),
+                        previous.getLocation(),
+                        ""));
+    }
+
+    public static MockitoAssertionError tooManyActualInvocations(
+            int wantedCount,
+            int actualCount,
+            DescribedInvocation wanted,
+            List<Location> locations) {
+        String message =
+                createTooManyInvocationsMessage(wantedCount, actualCount, wanted, locations);
         return new TooManyActualInvocations(message);
     }
 
-    private static String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,
-                                                          List<Location> invocations) {
+    private static String createTooManyInvocationsMessage(
+            int wantedCount,
+            int actualCount,
+            DescribedInvocation wanted,
+            List<Location> invocations) {
         return join(
                 wanted.toString(),
                 "Wanted " + pluralize(wantedCount) + ":",
                 new LocationImpl(),
                 "But was " + pluralize(actualCount) + ":",
                 createAllLocationsMessage(invocations),
-                ""
-        );
+                "");
     }
 
-    public static MockitoAssertionError neverWantedButInvoked(DescribedInvocation wanted, List<Location> invocations) {
-        return new NeverWantedButInvoked(join(
-                wanted.toString(),
-                "Never wanted here:",
-                new LocationImpl(),
-                "But invoked here:",
-                createAllLocationsMessage(invocations)
-        ));
+    public static MockitoAssertionError neverWantedButInvoked(
+            DescribedInvocation wanted, List<Invocation> invocations) {
+
+        return new NeverWantedButInvoked(
+                join(
+                        wanted.toString(),
+                        "Never wanted here:",
+                        new LocationImpl(),
+                        "But invoked here:",
+                        createAllLocationsArgsMessage(invocations)));
     }
 
-    public static MockitoAssertionError tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, List<Location> invocations) {
-        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, invocations);
-        return new VerificationInOrderFailure(join(
-                "Verification in order failure:" + message
-        ));
+    public static MockitoAssertionError tooManyActualInvocationsInOrder(
+            int wantedCount,
+            int actualCount,
+            DescribedInvocation wanted,
+            List<Location> invocations) {
+        String message =
+                createTooManyInvocationsMessage(wantedCount, actualCount, wanted, invocations);
+        return new VerificationInOrderFailure(join("Verification in order failure:" + message));
     }
 
     private static String createAllLocationsMessage(List<Location> locations) {
@@ -404,305 +439,406 @@ public class Reporter {
         return sb.toString();
     }
 
-    private static String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy,
-                                                            DescribedInvocation wanted,
-                                                            List<Location> locations) {
+    private static String createAllLocationsArgsMessage(List<Invocation> invocations) {
+        StringBuilder sb = new StringBuilder();
+        for (Invocation invocation : invocations) {
+            Location location = invocation.getLocation();
+            if (location == null) {
+                continue;
+            }
+            sb.append(location)
+                    .append(" with arguments: ")
+                    .append(Arrays.toString(invocation.getArguments()))
+                    .append("\n");
+        }
+        return sb.toString();
+    }
+
+    private static String createTooFewInvocationsMessage(
+            org.mockito.internal.reporting.Discrepancy discrepancy,
+            DescribedInvocation wanted,
+            List<Location> locations) {
         return join(
                 wanted.toString(),
-                "Wanted " + discrepancy.getPluralizedWantedCount() + (discrepancy.getWantedCount() == 0 ? "." : ":"),
+                "Wanted "
+                        + discrepancy.getPluralizedWantedCount()
+                        + (discrepancy.getWantedCount() == 0 ? "." : ":"),
                 new LocationImpl(),
-                "But was " + discrepancy.getPluralizedActualCount() + (discrepancy.getActualCount() == 0 ? "." : ":"),
-                createAllLocationsMessage(locations)
-        );
+                "But was "
+                        + discrepancy.getPluralizedActualCount()
+                        + (discrepancy.getActualCount() == 0 ? "." : ":"),
+                createAllLocationsMessage(locations));
     }
 
-    public static MockitoAssertionError tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, List<Location> allLocations) {
-        String message = createTooLittleInvocationsMessage(discrepancy, wanted, allLocations);
+    public static MockitoAssertionError tooFewActualInvocations(
+            org.mockito.internal.reporting.Discrepancy discrepancy,
+            DescribedInvocation wanted,
+            List<Location> allLocations) {
+        String message = createTooFewInvocationsMessage(discrepancy, wanted, allLocations);
 
-        return new TooLittleActualInvocations(message);
+        return new TooFewActualInvocations(message);
     }
 
-    public static MockitoAssertionError tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, List<Location> locations) {
-        String message = createTooLittleInvocationsMessage(discrepancy, wanted, locations);
+    public static MockitoAssertionError tooFewActualInvocationsInOrder(
+            org.mockito.internal.reporting.Discrepancy discrepancy,
+            DescribedInvocation wanted,
+            List<Location> locations) {
+        String message = createTooFewInvocationsMessage(discrepancy, wanted, locations);
 
-        return new VerificationInOrderFailure(join(
-                "Verification in order failure:" + message
-        ));
+        return new VerificationInOrderFailure(join("Verification in order failure:" + message));
     }
 
-    public static MockitoAssertionError noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {
+    public static MockitoAssertionError noMoreInteractionsWanted(
+            Invocation undesired, List<VerificationAwareInvocation> invocations) {
         ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
         String scenario = scenarioPrinter.print(invocations);
 
-        return new NoInteractionsWanted(join(
-                "No interactions wanted here:",
-                new LocationImpl(),
-                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
-                undesired.getLocation(),
-                scenario
-        ));
+        return new NoInteractionsWanted(
+                join(
+                        "No interactions wanted here:",
+                        new LocationImpl(),
+                        "But found this interaction on mock '"
+                                + MockUtil.getMockName(undesired.getMock())
+                                + "':",
+                        undesired.getLocation(),
+                        scenario));
     }
 
     public static MockitoAssertionError noMoreInteractionsWantedInOrder(Invocation undesired) {
-        return new VerificationInOrderFailure(join(
-                "No interactions wanted here:",
-                new LocationImpl(),
-                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
-                undesired.getLocation()
-        ));
+        return new VerificationInOrderFailure(
+                join(
+                        "No interactions wanted here:",
+                        new LocationImpl(),
+                        "But found this interaction on mock '"
+                                + MockUtil.getMockName(undesired.getMock())
+                                + "':",
+                        undesired.getLocation()));
+    }
+
+    public static MockitoAssertionError noInteractionsWanted(
+            Object mock, List<VerificationAwareInvocation> invocations) {
+        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
+        String scenario = scenarioPrinter.print(invocations);
+
+        List<Location> locations = new ArrayList<>();
+        for (VerificationAwareInvocation invocation : invocations) {
+            locations.add(invocation.getLocation());
+        }
+        return new NoInteractionsWanted(
+                join(
+                        "No interactions wanted here:",
+                        new LocationImpl(),
+                        "But found these interactions on mock '"
+                                + MockUtil.getMockName(mock)
+                                + "':",
+                        join("", locations),
+                        scenario));
     }
 
     public static MockitoException cannotMockClass(Class<?> clazz, String reason) {
-        return new MockitoException(join(
-                "Cannot mock/spy " + clazz.toString(),
-                "Mockito cannot mock/spy because :",
-                " - " + reason
-        ));
+        return new MockitoException(
+                join(
+                        "Cannot mock/spy " + clazz,
+                        "Mockito cannot mock/spy because :",
+                        " - " + reason));
     }
 
     public static MockitoException cannotStubVoidMethodWithAReturnValue(String methodName) {
-        return new CannotStubVoidMethodWithReturnValue(join(
-                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
-                "Voids are usually stubbed with Throwables:",
-                "    doThrow(exception).when(mock).someVoidMethod();",
-                "If you need to set the void method to do nothing you can use:",
-                "    doNothing().when(mock).someVoidMethod();",
-                "For more information, check out the javadocs for Mockito.doNothing().",
-                "***",
-                "If you're unsure why you're getting above error read on.",
-                "Due to the nature of the syntax above problem might occur because:",
-                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
-                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
-                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
-                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
-                "4. " + NON_PUBLIC_PARENT,
-                ""
-        ));
+        return new CannotStubVoidMethodWithReturnValue(
+                join(
+                        "'"
+                                + methodName
+                                + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
+                        "Voids are usually stubbed with Throwables:",
+                        "    doThrow(exception).when(mock).someVoidMethod();",
+                        "If you need to set the void method to do nothing you can use:",
+                        "    doNothing().when(mock).someVoidMethod();",
+                        "For more information, check out the javadocs for Mockito.doNothing().",
+                        "***",
+                        "If you're unsure why you're getting above error read on.",
+                        "Due to the nature of the syntax above problem might occur because:",
+                        "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
+                        "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
+                        "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
+                        "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
+                        "4. " + NON_PUBLIC_PARENT,
+                        ""));
     }
 
     public static MockitoException onlyVoidMethodsCanBeSetToDoNothing() {
-        return new MockitoException(join(
-                "Only void methods can doNothing()!",
-                "Example of correct use of doNothing():",
-                "    doNothing().",
-                "    doThrow(new RuntimeException())",
-                "    .when(mock).someVoidMethod();",
-                "Above means:",
-                "someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called"
-        ));
-    }
-
-    public static MockitoException wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {
-        return new WrongTypeOfReturnValue(join(
-                actualType + " cannot be returned by " + methodName + "()",
-                methodName + "() should return " + expectedType,
-                "***",
-                "If you're unsure why you're getting above error read on.",
-                "Due to the nature of the syntax above problem might occur because:",
-                "1. This exception *might* occur in wrongly written multi-threaded tests.",
-                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
-                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
-                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
-                ""
-        ));
-    }
-
-    public static MockitoException wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {
-        return new WrongTypeOfReturnValue(join(
-                "Default answer returned a result with the wrong type:",
-                actualType + " cannot be returned by " + methodName + "()",
-                methodName + "() should return " + expectedType,
-                "",
-                "The default answer of " + safelyGetMockName(mock) + " that was configured on the mock is probably incorrectly implemented.",
-                ""
-        ));
-    }
-
-    public static MoreThanAllowedActualInvocations wantedAtMostX(int maxNumberOfInvocations, int foundSize) {
-        return new MoreThanAllowedActualInvocations(join("Wanted at most " + pluralize(maxNumberOfInvocations) + " but was " + foundSize));
+        return new MockitoException(
+                join(
+                        "Only void methods can doNothing()!",
+                        "Example of correct use of doNothing():",
+                        "    doNothing().",
+                        "    doThrow(new RuntimeException())",
+                        "    .when(mock).someVoidMethod();",
+                        "Above means:",
+                        "someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called"));
+    }
+
+    public static MockitoException wrongTypeOfReturnValue(
+            String expectedType, String actualType, String methodName) {
+        return new WrongTypeOfReturnValue(
+                join(
+                        actualType + " cannot be returned by " + methodName + "()",
+                        methodName + "() should return " + expectedType,
+                        "***",
+                        "If you're unsure why you're getting above error read on.",
+                        "Due to the nature of the syntax above problem might occur because:",
+                        "1. This exception *might* occur in wrongly written multi-threaded tests.",
+                        "   Please refer to Mockito FAQ on limitations of concurrency testing.",
+                        "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
+                        "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
+                        ""));
+    }
+
+    public static MockitoException wrongTypeReturnedByDefaultAnswer(
+            Object mock, String expectedType, String actualType, String methodName) {
+        return new WrongTypeOfReturnValue(
+                join(
+                        "Default answer returned a result with the wrong type:",
+                        actualType + " cannot be returned by " + methodName + "()",
+                        methodName + "() should return " + expectedType,
+                        "",
+                        "The default answer of "
+                                + MockUtil.getMockName(mock)
+                                + " that was configured on the mock is probably incorrectly implemented.",
+                        ""));
+    }
+
+    public static MoreThanAllowedActualInvocations wantedAtMostX(
+            int maxNumberOfInvocations, int foundSize) {
+        return new MoreThanAllowedActualInvocations(
+                join(
+                        "Wanted at most "
+                                + pluralize(maxNumberOfInvocations)
+                                + " but was "
+                                + foundSize));
     }
 
     public static MockitoException misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {
-        return new InvalidUseOfMatchersException(join(
-                "Misplaced or misused argument matcher detected here:",
-                locationsOf(lastMatchers),
-                "",
-                "You cannot use argument matchers outside of verification or stubbing.",
-                "Examples of correct usage of argument matchers:",
-                "    when(mock.get(anyInt())).thenReturn(null);",
-                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
-                "    verify(mock).someMethod(contains(\"foo\"))",
-                "",
-                "This message may appear after an NullPointerException if the last matcher is returning an object ",
-                "like any() but the stubbed method signature expect a primitive argument, in this case,",
-                "use primitive alternatives.",
-                "    when(mock.get(any())); // bad use, will raise NPE",
-                "    when(mock.get(anyInt())); // correct usage use",
-                "",
-                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
-                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
-                NON_PUBLIC_PARENT,
-                ""
-        ));
+        return new InvalidUseOfMatchersException(
+                join(
+                        "Misplaced or misused argument matcher detected here:",
+                        locationsOf(lastMatchers),
+                        "",
+                        "You cannot use argument matchers outside of verification or stubbing.",
+                        "Examples of correct usage of argument matchers:",
+                        "    when(mock.get(anyInt())).thenReturn(null);",
+                        "    doThrow(new RuntimeException()).when(mock).someVoidMethod(any());",
+                        "    verify(mock).someMethod(contains(\"foo\"))",
+                        "",
+                        "This message may appear after an NullPointerException if the last matcher is returning an object ",
+                        "like any() but the stubbed method signature expect a primitive argument, in this case,",
+                        "use primitive alternatives.",
+                        "    when(mock.get(any())); // bad use, will raise NPE",
+                        "    when(mock.get(anyInt())); // correct usage use",
+                        "",
+                        "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
+                        "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
+                        NON_PUBLIC_PARENT,
+                        ""));
     }
 
     public static MockitoException smartNullPointerException(String invocation, Location location) {
-        return new SmartNullPointerException(join(
-                "You have a NullPointerException here:",
-                new LocationImpl(),
-                "because this method call was *not* stubbed correctly:",
-                location,
-                invocation,
-                ""
-        ));
+        return new SmartNullPointerException(
+                join(
+                        "You have a NullPointerException here:",
+                        new LocationImpl(),
+                        "because this method call was *not* stubbed correctly:",
+                        location,
+                        invocation,
+                        ""));
     }
 
     public static MockitoException noArgumentValueWasCaptured() {
-        return new MockitoException(join(
-                "No argument value was captured!",
-                "You might have forgotten to use argument.capture() in verify()...",
-                "...or you used capture() in stubbing but stubbed method was not called.",
-                "Be aware that it is recommended to use capture() only with verify()",
-                "",
-                "Examples of correct argument capturing:",
-                "    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);",
-                "    verify(mock).doSomething(argument.capture());",
-                "    assertEquals(\"John\", argument.getValue().getName());",
-                ""
-        ));
+        return new MockitoException(
+                join(
+                        "No argument value was captured!",
+                        "You might have forgotten to use argument.capture() in verify()...",
+                        "...or you used capture() in stubbing but stubbed method was not called.",
+                        "Be aware that it is recommended to use capture() only with verify()",
+                        "",
+                        "Examples of correct argument capturing:",
+                        "    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);",
+                        "    verify(mock).doSomething(argument.capture());",
+                        "    assertEquals(\"John\", argument.getValue().getName());",
+                        ""));
     }
 
     public static MockitoException extraInterfacesDoesNotAcceptNullParameters() {
-        return new MockitoException(join(
-                "extraInterfaces() does not accept null parameters."
-        ));
+        return new MockitoException(join("extraInterfaces() does not accept null parameters."));
     }
 
     public static MockitoException extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {
-        return new MockitoException(join(
-                "extraInterfaces() accepts only interfaces.",
-                "You passed following type: " + wrongType.getSimpleName() + " which is not an interface."
-        ));
+        return new MockitoException(
+                join(
+                        "extraInterfaces() accepts only interfaces.",
+                        "You passed following type: "
+                                + wrongType.getSimpleName()
+                                + " which is not an interface."));
     }
 
     public static MockitoException extraInterfacesCannotContainMockedType(Class<?> wrongType) {
-        return new MockitoException(join(
-                "extraInterfaces() does not accept the same type as the mocked type.",
-                "You mocked following type: " + wrongType.getSimpleName(),
-                "and you passed the same very interface to the extraInterfaces()"
-        ));
+        return new MockitoException(
+                join(
+                        "extraInterfaces() does not accept the same type as the mocked type.",
+                        "You mocked following type: " + wrongType.getSimpleName(),
+                        "and you passed the same very interface to the extraInterfaces()"));
     }
 
     public static MockitoException extraInterfacesRequiresAtLeastOneInterface() {
-        return new MockitoException(join(
-                "extraInterfaces() requires at least one interface."
-        ));
+        return new MockitoException(join("extraInterfaces() requires at least one interface."));
     }
 
-    public static MockitoException mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {
-        return new MockitoException(join(
-                "Mocked type must be the same as the type of your spied instance.",
-                "Mocked type must be: " + spiedInstance.getClass().getSimpleName() + ", but is: " + mockedType.getSimpleName(),
-                "  //correct spying:",
-                "  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );",
-                "  //incorrect - types don't match:",
-                "  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );"
-        ));
+    public static MockitoException mockedTypeIsInconsistentWithSpiedInstanceType(
+            Class<?> mockedType, Object spiedInstance) {
+        return new MockitoException(
+                join(
+                        "Mocked type must be the same as the type of your spied instance.",
+                        "Mocked type must be: "
+                                + spiedInstance.getClass().getSimpleName()
+                                + ", but is: "
+                                + mockedType.getSimpleName(),
+                        "  //correct spying:",
+                        "  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );",
+                        "  //incorrect - types don't match:",
+                        "  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );"));
     }
 
     public static MockitoException cannotCallAbstractRealMethod() {
-        return new MockitoException(join(
-                "Cannot call abstract real method on java object!",
-                "Calling real methods is only possible when mocking non abstract method.",
-                "  //correct example:",
-                "  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();"
-        ));
+        return new MockitoException(
+                join(
+                        "Cannot call abstract real method on java object!",
+                        "Calling real methods is only possible when mocking non abstract method.",
+                        "  //correct example:",
+                        "  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();"));
     }
 
     public static MockitoException cannotVerifyToString() {
-        return new MockitoException(join(
-                "Mockito cannot verify toString()",
-                "toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). " +
-                        "Verifying it may give inconsistent or hard to understand results. " +
-                        "Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)",
-                "However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases."
-        ));
+        return new MockitoException(
+                join(
+                        "Mockito cannot verify toString()",
+                        "toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). "
+                                + "Verifying it may give inconsistent or hard to understand results. "
+                                + "Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)",
+                        "However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases."));
     }
 
     public static MockitoException moreThanOneAnnotationNotAllowed(String fieldName) {
-        return new MockitoException("You cannot have more than one Mockito annotation on a field!\n" +
-                                            "The field '" + fieldName + "' has multiple Mockito annotations.\n" +
-                                            "For info how to use annotations see examples in javadoc for MockitoAnnotations class.");
-    }
-
-    public static MockitoException unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {
-        return new MockitoException("This combination of annotations is not permitted on a single field:\n" +
-                                            "@" + undesiredAnnotationOne + " and @" + undesiredAnnotationTwo);
-    }
-
-    public static MockitoException cannotInitializeForSpyAnnotation(String fieldName, Exception details) {
-        return new MockitoException(join("Cannot instantiate a @Spy for '" + fieldName + "' field.",
-                                         "You haven't provided the instance for spying at field declaration so I tried to construct the instance.",
-                                         "However, I failed because: " + details.getMessage(),
-                                         "Examples of correct usage of @Spy:",
-                                         "   @Spy List mock = new LinkedList();",
-                                         "   @Spy Foo foo; //only if Foo has parameterless constructor",
-                                         "   //also, don't forget about MockitoAnnotations.initMocks();",
-                                         ""), details);
-    }
-
-    public static MockitoException cannotInitializeForInjectMocksAnnotation(String fieldName, String causeMessage) {
-        return new MockitoException(join("Cannot instantiate @InjectMocks field named '" + fieldName + "'! Cause: "+causeMessage,
-                                         "You haven't provided the instance at field declaration so I tried to construct the instance.",
-                                         "Examples of correct usage of @InjectMocks:",
-                                         "   @InjectMocks Service service = new Service();",
-                                         "   @InjectMocks Service service;",
-                                         "   //and... don't forget about some @Mocks for injection :)",
-                                         ""));
+        return new MockitoException(
+                "You cannot have more than one Mockito annotation on a field!\n"
+                        + "The field '"
+                        + fieldName
+                        + "' has multiple Mockito annotations.\n"
+                        + "For info how to use annotations see examples in javadoc for MockitoAnnotations class.");
+    }
+
+    public static MockitoException unsupportedCombinationOfAnnotations(
+            String undesiredAnnotationOne, String undesiredAnnotationTwo) {
+        return new MockitoException(
+                "This combination of annotations is not permitted on a single field:\n"
+                        + "@"
+                        + undesiredAnnotationOne
+                        + " and @"
+                        + undesiredAnnotationTwo);
+    }
+
+    public static MockitoException cannotInitializeForSpyAnnotation(
+            String fieldName, Exception details) {
+        return new MockitoException(
+                join(
+                        "Cannot instantiate a @Spy for '" + fieldName + "' field.",
+                        "You haven't provided the instance for spying at field declaration so I tried to construct the instance.",
+                        "However, I failed because: " + details.getMessage(),
+                        "Examples of correct usage of @Spy:",
+                        "   @Spy List mock = new LinkedList();",
+                        "   @Spy Foo foo; //only if Foo has parameterless constructor",
+                        "   //also, don't forget about MockitoAnnotations.openMocks();",
+                        ""),
+                details);
+    }
+
+    public static MockitoException cannotInitializeForInjectMocksAnnotation(
+            String fieldName, String causeMessage) {
+        return new MockitoException(
+                join(
+                        "Cannot instantiate @InjectMocks field named '"
+                                + fieldName
+                                + "'! Cause: "
+                                + causeMessage,
+                        "You haven't provided the instance at field declaration so I tried to construct the instance.",
+                        "Examples of correct usage of @InjectMocks:",
+                        "   @InjectMocks Service service = new Service();",
+                        "   @InjectMocks Service service;",
+                        "   //and... don't forget about some @Mocks for injection :)",
+                        ""));
     }
 
     public static MockitoException atMostAndNeverShouldNotBeUsedWithTimeout() {
-        return new FriendlyReminderException(join("",
-                                                  "Don't panic! I'm just a friendly reminder!",
-                                                  "timeout() should not be used with atMost() or never() because...",
-                                                  "...it does not make much sense - the test would have passed immediately in concurrency",
-                                                  "We kept this method only to avoid compilation errors when upgrading Mockito.",
-                                                  "In future release we will remove timeout(x).atMost(y) from the API.",
-                                                  "If you want to find out more please refer to issue 235",
-                                                  ""));
-    }
-
-    public static MockitoException fieldInitialisationThrewException(Field field, Throwable details) {
-        return new InjectMocksException(join(
-                "Cannot instantiate @InjectMocks field named '" + field.getName() + "' of type '" + field.getType() + "'.",
-                "You haven't provided the instance at field declaration so I tried to construct the instance.",
-                "However the constructor or the initialization block threw an exception : " + details.getMessage(),
-                ""), details);
-
+        return new FriendlyReminderException(
+                join(
+                        "",
+                        "Don't panic! I'm just a friendly reminder!",
+                        "timeout() should not be used with atMost() or never() because...",
+                        "...it does not make much sense - the test would have passed immediately in concurrency",
+                        "We kept this method only to avoid compilation errors when upgrading Mockito.",
+                        "In future release we will remove timeout(x).atMost(y) from the API.",
+                        "If you want to find out more please refer to issue 235",
+                        ""));
+    }
+
+    public static MockitoException fieldInitialisationThrewException(
+            Field field, Throwable details) {
+        return new InjectMocksException(
+                join(
+                        "Cannot instantiate @InjectMocks field named '"
+                                + field.getName()
+                                + "' of type '"
+                                + field.getType()
+                                + "'.",
+                        "You haven't provided the instance at field declaration so I tried to construct the instance.",
+                        "However the constructor or the initialization block threw an exception : "
+                                + details.getMessage(),
+                        ""),
+                details);
     }
 
     public static MockitoException methodDoesNotAcceptParameter(String method, String parameter) {
-        return new MockitoException(method + "() does not accept " + parameter + " See the Javadoc.");
+        return new MockitoException(
+                method + "() does not accept " + parameter + " See the Javadoc.");
     }
 
-    public static MockitoException invocationListenersRequiresAtLeastOneListener() {
-        return new MockitoException("invocationListeners() requires at least one listener");
+    public static MockitoException requiresAtLeastOneListener(String method) {
+        return new MockitoException(method + "() requires at least one listener");
     }
 
-    public static MockitoException invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {
-        return new MockitoException(join(
-                "The invocation listener with type " + listener.getClass().getName(),
-                "threw an exception : " + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);
+    public static MockitoException invocationListenerThrewException(
+            InvocationListener listener, Throwable listenerThrowable) {
+        return new MockitoException(
+                join(
+                        "The invocation listener with type " + listener.getClass().getName(),
+                        "threw an exception : "
+                                + listenerThrowable.getClass().getName()
+                                + listenerThrowable.getMessage()),
+                listenerThrowable);
     }
 
-    public static MockitoException cannotInjectDependency(Field field, Object matchingMock, Exception details) {
-        return new MockitoException(join(
-                "Mockito couldn't inject mock dependency '" + safelyGetMockName(matchingMock) + "' on field ",
-                "'" + field + "'",
-                "whose type '" + field.getDeclaringClass().getCanonicalName() + "' was annotated by @InjectMocks in your test.",
-                "Also I failed because: " + exceptionCauseMessageIfAvailable(details),
-                ""
-        ), details);
+    public static MockitoException cannotInjectDependency(
+            Field field, Object matchingMock, Exception details) {
+        return new MockitoException(
+                join(
+                        "Mockito couldn't inject mock dependency '"
+                                + MockUtil.getMockName(matchingMock)
+                                + "' on field ",
+                        "'" + field + "'",
+                        "whose type '"
+                                + field.getDeclaringClass().getCanonicalName()
+                                + "' was annotated by @InjectMocks in your test.",
+                        "Also I failed because: " + exceptionCauseMessageIfAvailable(details),
+                        ""),
+                details);
     }
 
     private static String exceptionCauseMessageIfAvailable(Exception details) {
@@ -712,43 +848,55 @@ public class Reporter {
         return details.getCause().getMessage();
     }
 
-    public static MockitoException mockedTypeIsInconsistentWithDelegatedInstanceType(Class<?> mockedType, Object delegatedInstance) {
-        return new MockitoException(join(
-                "Mocked type must be the same as the type of your delegated instance.",
-                "Mocked type must be: " + delegatedInstance.getClass().getSimpleName() + ", but is: " + mockedType.getSimpleName(),
-                "  //correct delegate:",
-                "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );",
-                "  //incorrect - types don't match:",
-                "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );"
-        ));
+    public static MockitoException mockedTypeIsInconsistentWithDelegatedInstanceType(
+            Class<?> mockedType, Object delegatedInstance) {
+        return new MockitoException(
+                join(
+                        "Mocked type must be the same as the type of your delegated instance.",
+                        "Mocked type must be: "
+                                + delegatedInstance.getClass().getSimpleName()
+                                + ", but is: "
+                                + mockedType.getSimpleName(),
+                        "  //correct delegate:",
+                        "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );",
+                        "  //incorrect - types don't match:",
+                        "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );"));
     }
 
     public static MockitoException spyAndDelegateAreMutuallyExclusive() {
-        return new MockitoException(join(
-                "Settings should not define a spy instance and a delegated instance at the same time."
-        ));
+        return new MockitoException(
+                join(
+                        "Settings should not define a spy instance and a delegated instance at the same time."));
     }
 
     public static MockitoException invalidArgumentRangeAtIdentityAnswerCreationTime() {
-        return new MockitoException(join(
-                "Invalid argument index.",
-                "The index need to be a positive number that indicates the position of the argument to return.",
-                "However it is possible to use the -1 value to indicates that the last argument should be",
-                "returned."));
-    }
-
-    public static MockitoException invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
-        return new MockitoException(join(
-                "Invalid argument index for the current invocation of method : ",
-                " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
-                "",
-                (willReturnLastParameter ?
-                        "Last parameter wanted" :
-                        "Wanted parameter at position " + argumentIndex) + " but " + possibleArgumentTypesOf(invocation),
-                "The index need to be a positive number that indicates a valid position of the argument in the invocation.",
-                "However it is possible to use the -1 value to indicates that the last argument should be returned.",
-                ""
-        ));
+        return new MockitoException(
+                join(
+                        "Invalid argument index.",
+                        "The index need to be a positive number that indicates the position of the argument to return.",
+                        "However it is possible to use the -1 value to indicates that the last argument should be",
+                        "returned."));
+    }
+
+    public static MockitoException invalidArgumentPositionRangeAtInvocationTime(
+            InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
+        return new MockitoException(
+                join(
+                        "Invalid argument index for the current invocation of method : ",
+                        " -> "
+                                + MockUtil.getMockName(invocation.getMock())
+                                + "."
+                                + invocation.getMethod().getName()
+                                + "()",
+                        "",
+                        (willReturnLastParameter
+                                        ? "Last parameter wanted"
+                                        : "Wanted parameter at position " + argumentIndex)
+                                + " but "
+                                + possibleArgumentTypesOf(invocation),
+                        "The index need to be a positive number that indicates a valid position of the argument in the invocation.",
+                        "However it is possible to use the -1 value to indicates that the last argument should be returned.",
+                        ""));
     }
 
     private static StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {
@@ -757,12 +905,19 @@ public class Reporter {
             return new StringBuilder("the method has no arguments.\n");
         }
 
-        StringBuilder stringBuilder = new StringBuilder("the possible argument indexes for this method are :\n");
-        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {
+        StringBuilder stringBuilder =
+                new StringBuilder("the possible argument indexes for this method are :\n");
+        for (int i = 0, parameterTypesLength = parameterTypes.length;
+                i < parameterTypesLength;
+                i++) {
             stringBuilder.append("    [").append(i);
 
             if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {
-                stringBuilder.append("+] ").append(parameterTypes[i].getComponentType().getSimpleName()).append("  <- Vararg").append("\n");
+                stringBuilder
+                        .append("+] ")
+                        .append(parameterTypes[i].getComponentType().getSimpleName())
+                        .append("  <- Vararg")
+                        .append("\n");
             } else {
                 stringBuilder.append("] ").append(parameterTypes[i].getSimpleName()).append("\n");
             }
@@ -770,105 +925,143 @@ public class Reporter {
         return stringBuilder;
     }
 
-    public static MockitoException wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class<?> actualType, int argumentIndex) {
-        return new WrongTypeOfReturnValue(join(
-                "The argument of type '" + actualType.getSimpleName() + "' cannot be returned because the following ",
-                "method should return the type '" + expectedType + "'",
-                " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
-                "",
-                "The reason for this error can be :",
-                "1. The wanted argument position is incorrect.",
-                "2. The answer is used on the wrong interaction.",
-                "",
-                "Position of the wanted argument is " + argumentIndex + " and " + possibleArgumentTypesOf(invocation),
-                "***",
-                "However if you're still unsure why you're getting above error read on.",
-                "Due to the nature of the syntax above problem might occur because:",
-                "1. This exception *might* occur in wrongly written multi-threaded tests.",
-                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
-                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
-                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
-                ""
-        ));
+    public static MockitoException wrongTypeOfArgumentToReturn(
+            InvocationOnMock invocation,
+            String expectedType,
+            Class<?> actualType,
+            int argumentIndex) {
+        return new WrongTypeOfReturnValue(
+                join(
+                        "The argument of type '"
+                                + actualType.getSimpleName()
+                                + "' cannot be returned because the following ",
+                        "method should return the type '" + expectedType + "'",
+                        " -> "
+                                + MockUtil.getMockName(invocation.getMock())
+                                + "."
+                                + invocation.getMethod().getName()
+                                + "()",
+                        "",
+                        "The reason for this error can be :",
+                        "1. The wanted argument position is incorrect.",
+                        "2. The answer is used on the wrong interaction.",
+                        "",
+                        "Position of the wanted argument is "
+                                + argumentIndex
+                                + " and "
+                                + possibleArgumentTypesOf(invocation),
+                        "***",
+                        "However if you're still unsure why you're getting above error read on.",
+                        "Due to the nature of the syntax above problem might occur because:",
+                        "1. This exception *might* occur in wrongly written multi-threaded tests.",
+                        "   Please refer to Mockito FAQ on limitations of concurrency testing.",
+                        "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
+                        "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
+                        ""));
     }
 
     public static MockitoException defaultAnswerDoesNotAcceptNullParameter() {
         return new MockitoException("defaultAnswer() does not accept null parameter");
     }
 
-    public static MockitoException serializableWontWorkForObjectsThatDontImplementSerializable(Class<?> classToMock) {
-        return new MockitoException(join(
-                "You are using the setting 'withSettings().serializable()' however the type you are trying to mock '" + classToMock.getSimpleName() + "'",
-                "do not implement Serializable AND do not have a no-arg constructor.",
-                "This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized",
-                "",
-                "Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,",
-                "i.e. the top-most superclass has to implements Serializable.",
-                ""
-        ));
-    }
-
-    public static MockitoException delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
-        return new MockitoException(join(
-                "Methods called on delegated instance must have compatible return types with the mock.",
-                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
-                "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
-                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-        ));
-    }
-
-    public static MockitoException delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
-        return new MockitoException(join(
-                "Methods called on mock must exist in delegated instance.",
-                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
-                "no such method was found.",
-                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-        ));
+    public static MockitoException serializableWontWorkForObjectsThatDontImplementSerializable(
+            Class<?> classToMock) {
+        return new MockitoException(
+                join(
+                        "You are using the setting 'withSettings().serializable()' however the type you are trying to mock '"
+                                + classToMock.getSimpleName()
+                                + "'",
+                        "do not implement Serializable AND do not have a no-arg constructor.",
+                        "This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized",
+                        "",
+                        "Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,",
+                        "i.e. the top-most superclass has to implements Serializable.",
+                        ""));
+    }
+
+    public static MockitoException delegatedMethodHasWrongReturnType(
+            Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
+        return new MockitoException(
+                join(
+                        "Methods called on delegated instance must have compatible return types with the mock.",
+                        "When calling: " + mockMethod + " on mock: " + MockUtil.getMockName(mock),
+                        "return type should be: "
+                                + mockMethod.getReturnType().getSimpleName()
+                                + ", but was: "
+                                + delegateMethod.getReturnType().getSimpleName(),
+                        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                        "(delegate instance had type: "
+                                + delegate.getClass().getSimpleName()
+                                + ")"));
+    }
+
+    public static MockitoException delegatedMethodDoesNotExistOnDelegate(
+            Method mockMethod, Object mock, Object delegate) {
+        return new MockitoException(
+                join(
+                        "Methods called on mock must exist in delegated instance.",
+                        "When calling: " + mockMethod + " on mock: " + MockUtil.getMockName(mock),
+                        "no such method was found.",
+                        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                        "(delegate instance had type: "
+                                + delegate.getClass().getSimpleName()
+                                + ")"));
     }
 
     public static MockitoException usingConstructorWithFancySerializable(SerializableMode mode) {
-        return new MockitoException("Mocks instantiated with constructor cannot be combined with " + mode + " serialization mode.");
+        return new MockitoException(
+                "Mocks instantiated with constructor cannot be combined with "
+                        + mode
+                        + " serialization mode.");
     }
 
     public static MockitoException cannotCreateTimerWithNegativeDurationTime(long durationMillis) {
-        return new FriendlyReminderException(join(
-                "",
-                "Don't panic! I'm just a friendly reminder!",
-                "It is impossible for time to go backward, therefore...",
-                "You cannot put negative value of duration: (" + durationMillis + ")",
-                "as argument of timer methods (after(), timeout())",
-                ""
-        ));
+        return new FriendlyReminderException(
+                join(
+                        "",
+                        "Don't panic! I'm just a friendly reminder!",
+                        "It is impossible for time to go backward, therefore...",
+                        "You cannot put negative value of duration: (" + durationMillis + ")",
+                        "as argument of timer methods (after(), timeout())",
+                        ""));
     }
 
     public static MockitoException notAnException() {
-        return new MockitoException(join(
-                "Exception type cannot be null.",
-                "This may happen with doThrow(Class)|thenThrow(Class) family of methods if passing null parameter."));
+        return new MockitoException(
+                join(
+                        "Exception type cannot be null.",
+                        "This may happen with doThrow(Class)|thenThrow(Class) family of methods if passing null parameter."));
     }
 
-    private static MockName safelyGetMockName(Object mock) {
-        return MockUtil.getMockName(mock);
+    public static MockitoException inlineClassWithoutUnboxImpl(
+            Class<?> inlineClass, Exception details) {
+        return new MockitoException(
+                join(
+                        "Kotlin inline class should have unbox-impl() method,",
+                        "but " + inlineClass + " does not."),
+                details);
     }
 
-    public static UnnecessaryStubbingException formatUnncessaryStubbingException(Class<?> testClass, Collection<Invocation> unnecessaryStubbings) {
+    public static UnnecessaryStubbingException formatUnncessaryStubbingException(
+            Class<?> testClass, Collection<Invocation> unnecessaryStubbings) {
         StringBuilder stubbings = new StringBuilder();
         int count = 1;
         for (Invocation u : unnecessaryStubbings) {
             stubbings.append("\n  ").append(count++).append(". ").append(u.getLocation());
         }
-        String heading = (testClass != null)?
-                "Unnecessary stubbings detected in test class: " + testClass.getSimpleName() :
-                "Unnecessary stubbings detected.";
+        String heading =
+                (testClass != null)
+                        ? "Unnecessary stubbings detected in test class: "
+                                + testClass.getSimpleName()
+                        : "Unnecessary stubbings detected.";
 
-        return new UnnecessaryStubbingException(join(
-                heading,
-                "Clean & maintainable test code requires zero unnecessary code.",
-                "Following stubbings are unnecessary (click to navigate to relevant line of code):" + stubbings,
-                "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class."
-        ));
+        return new UnnecessaryStubbingException(
+                join(
+                        heading,
+                        "Clean & maintainable test code requires zero unnecessary code.",
+                        "Following stubbings are unnecessary (click to navigate to relevant line of code):"
+                                + stubbings,
+                        "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class."));
     }
 
     public static void unncessaryStubbingException(List<Invocation> unused) {
@@ -883,39 +1076,61 @@ public class Reporter {
             stubbings.append("    ").append(count++).append(". ").append(s);
             stubbings.append("\n      ").append(s.getLocation()).append("\n");
         }
-        stubbings.deleteCharAt(stubbings.length()-1); //remove trailing end of line
-
-        throw new PotentialStubbingProblem(join(
-                "Strict stubbing argument mismatch. Please check:",
-                " - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
-                "    " + actualInvocation,
-                "    " + actualInvocation.getLocation(),
-                " - has following stubbing(s) with different arguments:",
-                stubbings,
-                "Typically, stubbing argument mismatch indicates user mistake when writing tests.",
-                "Mockito fails early so that you can debug potential problem easily.",
-                "However, there are legit scenarios when this exception generates false negative signal:",
-                "  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API",
-                "    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
-                "  - stubbed method is intentionally invoked with different arguments by code under test",
-                "    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).",
-                "For more information see javadoc for PotentialStubbingProblem class."));
+        stubbings.deleteCharAt(stubbings.length() - 1); // remove trailing end of line
+
+        throw new PotentialStubbingProblem(
+                join(
+                        "Strict stubbing argument mismatch. Please check:",
+                        " - this invocation of '"
+                                + actualInvocation.getMethod().getName()
+                                + "' method:",
+                        "    " + actualInvocation,
+                        "    " + actualInvocation.getLocation(),
+                        " - has following stubbing(s) with different arguments:",
+                        stubbings,
+                        "Typically, stubbing argument mismatch indicates user mistake when writing tests.",
+                        "Mockito fails early so that you can debug potential problem easily.",
+                        "However, there are legit scenarios when this exception generates false negative signal:",
+                        "  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API",
+                        "    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
+                        "  - stubbed method is intentionally invoked with different arguments by code under test",
+                        "    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).",
+                        "For more information see javadoc for PotentialStubbingProblem class."));
     }
 
     public static void redundantMockitoListener(String listenerType) {
-        throw new RedundantListenerException(join(
-            "Problems adding Mockito listener.",
-            "Listener of type '" + listenerType + "' has already been added and not removed.",
-            "It indicates that previous listener was not removed according to the API.",
-            "When you add a listener, don't forget to remove the listener afterwards:",
-            "  Mockito.framework().removeListener(myListener);",
-            "For more information, see the javadoc for RedundantListenerException class."));
+        throw new RedundantListenerException(
+                join(
+                        "Problems adding Mockito listener.",
+                        "Listener of type '"
+                                + listenerType
+                                + "' has already been added and not removed.",
+                        "It indicates that previous listener was not removed according to the API.",
+                        "When you add a listener, don't forget to remove the listener afterwards:",
+                        "  Mockito.framework().removeListener(myListener);",
+                        "For more information, see the javadoc for RedundantListenerException class."));
     }
 
     public static void unfinishedMockingSession() {
-        throw new UnfinishedMockingSessionException(join(
-                "Unfinished mocking session detected.",
-                "Previous MockitoSession was not concluded with 'finishMocking()'.",
-                "For examples of correct usage see javadoc for MockitoSession class."));
+        throw new UnfinishedMockingSessionException(
+                join(
+                        "Unfinished mocking session detected.",
+                        "Previous MockitoSession was not concluded with 'finishMocking()'.",
+                        "For examples of correct usage see javadoc for MockitoSession class."));
+    }
+
+    public static void missingByteBuddyDependency(Throwable t) {
+        if (t instanceof NoClassDefFoundError
+                && t.getMessage() != null
+                && t.getMessage().startsWith("net/bytebuddy/")) {
+            throw new MockitoInitializationException(
+                    join(
+                            "It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy could not be loaded.",
+                            "",
+                            "Byte Buddy is available on Maven Central as 'net.bytebuddy:byte-buddy' with the module name 'net.bytebuddy'.",
+                            "For the inline mock maker, 'net.bytebuddy:byte-buddy-agent' with the module name 'net.bytebuddy.agent' is also required.",
+                            "Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but "),
+                    t);
+        }
     }
 }
diff --git a/src/main/java/org/mockito/internal/exceptions/VerificationAwareInvocation.java b/src/main/java/org/mockito/internal/exceptions/VerificationAwareInvocation.java
index 9920aa6..865ee58 100644
--- a/src/main/java/org/mockito/internal/exceptions/VerificationAwareInvocation.java
+++ b/src/main/java/org/mockito/internal/exceptions/VerificationAwareInvocation.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions;
 
 import org.mockito.invocation.DescribedInvocation;
@@ -10,5 +9,4 @@ import org.mockito.invocation.DescribedInvocation;
 public interface VerificationAwareInvocation extends DescribedInvocation {
 
     boolean isVerified();
-
 }
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java
index c0d1150..61d9664 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions.stacktrace;
 
+import java.io.Serializable;
+
 import org.mockito.configuration.IMockitoConfiguration;
 import org.mockito.internal.configuration.GlobalConfiguration;
 
-import java.io.Serializable;
-
 public class ConditionalStackTraceFilter implements Serializable {
     private static final long serialVersionUID = -8085849703510292641L;
 
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
index 6f7b956..6b05752 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
@@ -23,7 +23,8 @@ public class DefaultStackTraceCleaner implements StackTraceCleaner {
     }
 
     private static boolean isMockDispatcher(String className) {
-        return (className.contains("$$EnhancerByMockitoWithCGLIB$$") || className.contains("$MockitoMock$"));
+        return (className.contains("$$EnhancerByMockitoWithCGLIB$$")
+                || className.contains("$MockitoMock$"));
     }
 
     private static boolean isFromMockito(String className) {
@@ -36,7 +37,7 @@ public class DefaultStackTraceCleaner implements StackTraceCleaner {
 
     private static boolean isFromMockitoRunner(String className) {
         return className.startsWith("org.mockito.internal.runners.")
-               || className.startsWith("org.mockito.runners.")
-               || className.startsWith("org.mockito.junit.");
+                || className.startsWith("org.mockito.runners.")
+                || className.startsWith("org.mockito.junit.");
     }
 }
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java
index ef500ce..4a23639 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java
@@ -12,6 +12,7 @@ import org.mockito.plugins.StackTraceCleanerProvider;
  */
 public class DefaultStackTraceCleanerProvider implements StackTraceCleanerProvider {
 
+    @Override
     public StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner) {
         return defaultCleaner;
     }
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
index e8b0cb0..ad0ede2 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
@@ -2,22 +2,41 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions.stacktrace;
 
-import org.mockito.exceptions.stacktrace.StackTraceCleaner;
-import org.mockito.internal.configuration.plugins.Plugins;
-
 import java.io.Serializable;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.mockito.exceptions.stacktrace.StackTraceCleaner;
+import org.mockito.internal.configuration.plugins.Plugins;
+
 public class StackTraceFilter implements Serializable {
 
     static final long serialVersionUID = -5499819791513105700L;
 
     private static final StackTraceCleaner CLEANER =
-            Plugins.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());
+            Plugins.getStackTraceCleanerProvider()
+                    .getStackTraceCleaner(new DefaultStackTraceCleaner());
+
+    private static Object JAVA_LANG_ACCESS;
+    private static Method GET_STACK_TRACE_ELEMENT;
+
+    static {
+        try {
+            JAVA_LANG_ACCESS =
+                    Class.forName("sun.misc.SharedSecrets")
+                            .getMethod("getJavaLangAccess")
+                            .invoke(null);
+            GET_STACK_TRACE_ELEMENT =
+                    Class.forName("sun.misc.JavaLangAccess")
+                            .getMethod("getStackTraceElement", Throwable.class, int.class);
+        } catch (Exception ignored) {
+            // Use the slow computational path for filtering stacktraces if fast path does not exist
+            // in JVM
+        }
+    }
 
     /**
      * Example how the filter works (+/- means good/bad):
@@ -26,9 +45,9 @@ public class StackTraceFilter implements Serializable {
      * <strike>If any good are in the middle of bad those are also removed.</strike>
      */
     public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {
-        //TODO: profile
-        //TODO: investigate "keepTop" commit history - no effect!
-        final List<StackTraceElement> filtered = new ArrayList<StackTraceElement>();
+        // TODO: profile
+        // TODO: investigate "keepTop" commit history - no effect!
+        final List<StackTraceElement> filtered = new ArrayList<>();
         for (StackTraceElement element : target) {
             if (CLEANER.isIn(element)) {
                 filtered.add(element);
@@ -37,4 +56,78 @@ public class StackTraceFilter implements Serializable {
         StackTraceElement[] result = new StackTraceElement[filtered.size()];
         return filtered.toArray(result);
     }
+
+    /**
+     * This filtering strategy makes use of a fast-path computation to retrieve stackTraceElements
+     * from a Stacktrace of a Throwable. It does so, by taking advantage of {@link
+     * sun.misc.SharedSecrets} and {@link sun.misc.JavaLangAccess}.
+     *
+     * <p>The {@link sun.misc.SharedSecrets} provides a method to obtain an instance of an {@link
+     * sun.misc.JavaLangAccess}. The latter class has a method to fast-path into {@link
+     * Throwable#getStackTrace()} and retrieve a single {@link StackTraceElement}. This prevents the
+     * JVM from having to generate a full stacktrace, which could potentially be expensive if
+     * stacktraces become very large.
+     *
+     * @param target The throwable target to find the first {@link StackTraceElement} that should
+     *     not be filtered out per {@link StackTraceFilter#CLEANER}.
+     * @return The first {@link StackTraceElement} outside of the {@link StackTraceFilter#CLEANER}
+     */
+    public StackTraceElement filterFirst(Throwable target, boolean isInline) {
+        boolean shouldSkip = isInline;
+
+        if (GET_STACK_TRACE_ELEMENT != null) {
+            int i = 0;
+
+            // The assumption here is that the CLEANER filter will not filter out every single
+            // element. However, since we don't want to compute the full length of the stacktrace,
+            // we don't know the upper boundary. Therefore, simply increment the counter and go as
+            // far as we have to go, assuming that we get there. If, in the rare occasion, we
+            // don't, we fall back to the old slow path.
+            while (true) {
+                try {
+                    StackTraceElement stackTraceElement =
+                            (StackTraceElement)
+                                    GET_STACK_TRACE_ELEMENT.invoke(JAVA_LANG_ACCESS, target, i);
+
+                    if (CLEANER.isIn(stackTraceElement)) {
+                        if (shouldSkip) {
+                            shouldSkip = false;
+                        } else {
+                            return stackTraceElement;
+                        }
+                    }
+                } catch (Exception e) {
+                    // Fall back to slow path
+                    break;
+                }
+                i++;
+            }
+        }
+
+        // If we can't use the fast path of retrieving stackTraceElements, use the slow path by
+        // iterating over the actual stacktrace
+        for (StackTraceElement stackTraceElement : target.getStackTrace()) {
+            if (CLEANER.isIn(stackTraceElement)) {
+                if (shouldSkip) {
+                    shouldSkip = false;
+                } else {
+                    return stackTraceElement;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Finds the source file of the target stack trace.
+     * Returns the default value if source file cannot be found.
+     */
+    public String findSourceFile(StackTraceElement[] target, String defaultValue) {
+        for (StackTraceElement e : target) {
+            if (CLEANER.isIn(e)) {
+                return e.getFileName();
+            }
+        }
+        return defaultValue;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/exceptions/util/ScenarioPrinter.java b/src/main/java/org/mockito/internal/exceptions/util/ScenarioPrinter.java
index a3e60fe..7b4375d 100644
--- a/src/main/java/org/mockito/internal/exceptions/util/ScenarioPrinter.java
+++ b/src/main/java/org/mockito/internal/exceptions/util/ScenarioPrinter.java
@@ -14,9 +14,10 @@ public class ScenarioPrinter {
         if (invocations.size() == 1) {
             return "Actually, above is the only interaction with this mock.";
         }
-        StringBuilder sb = new StringBuilder(
-                "***\n" +
-                "For your reference, here is the list of all invocations ([?] - means unverified).\n");
+        StringBuilder sb =
+                new StringBuilder(
+                        "***\n"
+                                + "For your reference, here is the list of all invocations ([?] - means unverified).\n");
 
         int counter = 0;
         for (VerificationAwareInvocation i : invocations) {
@@ -28,5 +29,4 @@ public class ScenarioPrinter {
         }
         return sb.toString();
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java b/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
index d92fc28..f4a9882 100644
--- a/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
+++ b/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.internal.framework;
 
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+
 import org.mockito.MockitoFramework;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.invocation.DefaultInvocationFactory;
@@ -14,16 +16,16 @@ import org.mockito.plugins.InlineMockMaker;
 import org.mockito.plugins.MockMaker;
 import org.mockito.plugins.MockitoPlugins;
 
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-
 public class DefaultMockitoFramework implements MockitoFramework {
 
+    @Override
     public MockitoFramework addListener(MockitoListener listener) {
         Checks.checkNotNull(listener, "listener");
         mockingProgress().addListener(listener);
         return this;
     }
 
+    @Override
     public MockitoFramework removeListener(MockitoListener listener) {
         Checks.checkNotNull(listener, "listener");
         mockingProgress().removeListener(listener);
diff --git a/src/main/java/org/mockito/internal/framework/DefaultMockitoSession.java b/src/main/java/org/mockito/internal/framework/DefaultMockitoSession.java
index c3f15f3..549019d 100644
--- a/src/main/java/org/mockito/internal/framework/DefaultMockitoSession.java
+++ b/src/main/java/org/mockito/internal/framework/DefaultMockitoSession.java
@@ -7,13 +7,15 @@ package org.mockito.internal.framework;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.RedundantListenerException;
 import org.mockito.internal.exceptions.Reporter;
 import org.mockito.internal.junit.TestFinishedEvent;
 import org.mockito.internal.junit.UniversalTestListener;
-import org.mockito.internal.util.MockitoLogger;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.quality.Strictness;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class DefaultMockitoSession implements MockitoSession {
@@ -21,33 +23,34 @@ public class DefaultMockitoSession implements MockitoSession {
     private final String name;
     private final UniversalTestListener listener;
 
-    public DefaultMockitoSession(List<Object> testClassInstances, String name, Strictness strictness, MockitoLogger logger) {
+    private final List<AutoCloseable> closeables = new ArrayList<>();
+
+    public DefaultMockitoSession(
+            List<Object> testClassInstances,
+            String name,
+            Strictness strictness,
+            MockitoLogger logger) {
         this.name = name;
         listener = new UniversalTestListener(strictness, logger);
         try {
-            //So that the listener can capture mock creation events
+            // So that the listener can capture mock creation events
             Mockito.framework().addListener(listener);
         } catch (RedundantListenerException e) {
             Reporter.unfinishedMockingSession();
         }
         try {
             for (Object testClassInstance : testClassInstances) {
-                MockitoAnnotations.initMocks(testClassInstance);
+                closeables.add(MockitoAnnotations.openMocks(testClassInstance));
             }
-        } catch (RuntimeException | Error e) {
+        } catch (RuntimeException e) {
             try {
-                // TODO: ideally this scenario should be tested on DefaultMockitoSessionBuilderTest,
-                // but we don't have any Android.bp project to run it.
-                // Besides, the latest Mockito code (https://github.com/mockito/mockito/blob/main/src/main/java/org/mockito/internal/framework/DefaultMockitoSession.java
-                // at the time this patch was merged) has a different workflow, where the listener
-                // is marked as dirty when an exception is thrown, so we're forking the solution.
-                Mockito.framework().removeListener(listener);
-            } catch (RuntimeException | Error e2) {
-                // Ignore it, as the real failure is e, thrown at the end
-                System.err.println("DefaultMockitoSession: ignoring exception thrown when removing "
-                        + "listener " + listener);
-                e2.printStackTrace(System.err);
+                release();
+            } catch (Throwable t) {
+                e.addSuppressed(t);
             }
+
+            // clean up in case 'openMocks' fails
+            listener.setListenerDirty();
             throw e;
         }
     }
@@ -64,27 +67,43 @@ public class DefaultMockitoSession implements MockitoSession {
 
     @Override
     public void finishMocking(final Throwable failure) {
-        //Cleaning up the state, we no longer need the listener hooked up
-        //The listener implements MockCreationListener and at this point
-        //we no longer need to listen on mock creation events. We are wrapping up the session
-        Mockito.framework().removeListener(listener);
+        try {
+            // Cleaning up the state, we no longer need the listener hooked up
+            // The listener implements MockCreationListener and at this point
+            // we no longer need to listen on mock creation events. We are wrapping up the session
+            Mockito.framework().removeListener(listener);
 
-        //Emit test finished event so that validation such as strict stubbing can take place
-        listener.testFinished(new TestFinishedEvent() {
-            @Override
-            public Throwable getFailure() {
-                return failure;
-            }
-            @Override
-            public String getTestName() {
-                return name;
+            // Emit test finished event so that validation such as strict stubbing can take place
+            listener.testFinished(
+                    new TestFinishedEvent() {
+                        @Override
+                        public Throwable getFailure() {
+                            return failure;
+                        }
+
+                        @Override
+                        public String getTestName() {
+                            return name;
+                        }
+                    });
+
+            // Validate only when there is no test failure to avoid reporting multiple problems
+            if (failure == null) {
+                // Finally, validate user's misuse of Mockito framework.
+                Mockito.validateMockitoUsage();
             }
-        });
+        } finally {
+            release();
+        }
+    }
 
-        //Validate only when there is no test failure to avoid reporting multiple problems
-        if (failure == null) {
-            //Finally, validate user's misuse of Mockito framework.
-            Mockito.validateMockitoUsage();
+    private void release() {
+        for (AutoCloseable closeable : closeables) {
+            try {
+                closeable.close();
+            } catch (Exception e) {
+                throw new MockitoException("Failed to release " + closeable, e);
+            }
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java b/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
index 9892422..99869fa 100644
--- a/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
+++ b/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
@@ -17,6 +17,7 @@ public class HamcrestArgumentMatcher<T> implements ArgumentMatcher<T> {
         this.matcher = matcher;
     }
 
+    @Override
     public boolean matches(Object argument) {
         return this.matcher.matches(argument);
     }
@@ -25,8 +26,9 @@ public class HamcrestArgumentMatcher<T> implements ArgumentMatcher<T> {
         return matcher instanceof VarargMatcher;
     }
 
+    @Override
     public String toString() {
-        //TODO SF add unit tests and integ test coverage for describeTo()
+        // TODO SF add unit tests and integ test coverage for toString()
         return StringDescription.toString(matcher);
     }
 }
diff --git a/src/main/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractor.java b/src/main/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractor.java
index f9c8806..5d46ad7 100644
--- a/src/main/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractor.java
+++ b/src/main/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractor.java
@@ -4,22 +4,22 @@
  */
 package org.mockito.internal.hamcrest;
 
+import static org.mockito.internal.util.reflection.GenericTypeExtractor.genericTypeOf;
+
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Matcher;
 
-import static org.mockito.internal.util.reflection.GenericTypeExtractor.genericTypeOf;
-
-/**
- * Extracts generic type of matcher
- */
-public class MatcherGenericTypeExtractor {
+/** Extracts generic type of matcher */
+public final class MatcherGenericTypeExtractor {
 
     /**
      * Gets the generic type of given matcher. For example,
      * for matcher class that extends BaseMatcher[Integer] this method returns Integer
      */
     public static Class<?> genericTypeOfMatcher(Class<?> matcherClass) {
-        //TODO SF check if we can reuse it for Mockito ArgumentMatcher
+        // TODO SF check if we can reuse it for Mockito ArgumentMatcher
         return genericTypeOf(matcherClass, BaseMatcher.class, Matcher.class);
     }
+
+    private MatcherGenericTypeExtractor() {}
 }
diff --git a/src/main/java/org/mockito/internal/handler/InvocationNotifierHandler.java b/src/main/java/org/mockito/internal/handler/InvocationNotifierHandler.java
index da2500a..b1c84df 100644
--- a/src/main/java/org/mockito/internal/handler/InvocationNotifierHandler.java
+++ b/src/main/java/org/mockito/internal/handler/InvocationNotifierHandler.java
@@ -4,21 +4,19 @@
  */
 package org.mockito.internal.handler;
 
-import org.mockito.invocation.InvocationContainer;
+import static org.mockito.internal.exceptions.Reporter.invocationListenerThrewException;
+
+import java.util.List;
+
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationContainer;
 import org.mockito.invocation.MockHandler;
 import org.mockito.listeners.InvocationListener;
 import org.mockito.mock.MockCreationSettings;
 
-import java.util.List;
-
-import static org.mockito.internal.exceptions.Reporter.invocationListenerThrewException;
-
 /**
  * Handler, that call all listeners wanted for this mock, before delegating it
  * to the parameterized handler.
- *
- * Also imposterize MockHandlerImpl, delegate all call of InternalMockHandler to the real mockHandler
  */
 class InvocationNotifierHandler<T> implements MockHandler<T> {
 
@@ -30,23 +28,24 @@ class InvocationNotifierHandler<T> implements MockHandler<T> {
         this.invocationListeners = settings.getInvocationListeners();
     }
 
+    @Override
     public Object handle(Invocation invocation) throws Throwable {
         try {
             Object returnedValue = mockHandler.handle(invocation);
             notifyMethodCall(invocation, returnedValue);
             return returnedValue;
-        } catch (Throwable t){
+        } catch (Throwable t) {
             notifyMethodCallException(invocation, t);
             throw t;
         }
     }
 
-
     private void notifyMethodCall(Invocation invocation, Object returnValue) {
         for (InvocationListener listener : invocationListeners) {
             try {
-                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));
-            } catch(Throwable listenerThrowable) {
+                listener.reportInvocation(
+                        new NotifiedMethodInvocationReport(invocation, returnValue));
+            } catch (Throwable listenerThrowable) {
                 throw invocationListenerThrewException(listener, listenerThrowable);
             }
         }
@@ -55,19 +54,21 @@ class InvocationNotifierHandler<T> implements MockHandler<T> {
     private void notifyMethodCallException(Invocation invocation, Throwable exception) {
         for (InvocationListener listener : invocationListeners) {
             try {
-                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));
-            } catch(Throwable listenerThrowable) {
+                listener.reportInvocation(
+                        new NotifiedMethodInvocationReport(invocation, exception));
+            } catch (Throwable listenerThrowable) {
                 throw invocationListenerThrewException(listener, listenerThrowable);
             }
         }
     }
 
+    @Override
     public MockCreationSettings<T> getMockSettings() {
         return mockHandler.getMockSettings();
     }
 
+    @Override
     public InvocationContainer getInvocationContainer() {
         return mockHandler.getInvocationContainer();
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/handler/MockHandlerFactory.java b/src/main/java/org/mockito/internal/handler/MockHandlerFactory.java
index e8b44cb..c735cd4 100644
--- a/src/main/java/org/mockito/internal/handler/MockHandlerFactory.java
+++ b/src/main/java/org/mockito/internal/handler/MockHandlerFactory.java
@@ -7,14 +7,14 @@ package org.mockito.internal.handler;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
-/**
- * by Szczepan Faber, created at: 5/21/12
- */
-public class MockHandlerFactory {
+/** by Szczepan Faber, created at: 5/21/12 */
+public final class MockHandlerFactory {
 
     public static <T> MockHandler<T> createMockHandler(MockCreationSettings<T> settings) {
         MockHandler<T> handler = new MockHandlerImpl<T>(settings);
         MockHandler<T> nullResultGuardian = new NullResultGuardian<T>(handler);
         return new InvocationNotifierHandler<T>(nullResultGuardian, settings);
     }
+
+    private MockHandlerFactory() {}
 }
diff --git a/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java b/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java
index a5c6458..17b967e 100644
--- a/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java
+++ b/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.internal.handler;
 
+import static org.mockito.internal.listeners.StubbingLookupNotifier.notifyStubbedAnswerLookup;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.invocation.MatchersBinder;
@@ -11,6 +14,7 @@ import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.answers.DefaultAnswerValidator;
+import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.invocation.Invocation;
@@ -19,9 +23,6 @@ import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.verification.VerificationMode;
 
-import static org.mockito.internal.listeners.StubbingLookupNotifier.notifyStubbedAnswerLookup;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-
 /**
  * Invocation handler set on mock objects.
  *
@@ -44,22 +45,21 @@ public class MockHandlerImpl<T> implements MockHandler<T> {
         this.invocationContainer = new InvocationContainerImpl(mockSettings);
     }
 
+    @Override
     public Object handle(Invocation invocation) throws Throwable {
         if (invocationContainer.hasAnswersForStubbing()) {
             // stubbing voids with doThrow() or doAnswer() style
-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
-                    mockingProgress().getArgumentMatcherStorage(),
-                    invocation
-            );
+            InvocationMatcher invocationMatcher =
+                    matchersBinder.bindMatchers(
+                            mockingProgress().getArgumentMatcherStorage(), invocation);
             invocationContainer.setMethodForStubbing(invocationMatcher);
             return null;
         }
         VerificationMode verificationMode = mockingProgress().pullVerificationMode();
 
-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
-                mockingProgress().getArgumentMatcherStorage(),
-                invocation
-        );
+        InvocationMatcher invocationMatcher =
+                matchersBinder.bindMatchers(
+                        mockingProgress().getArgumentMatcherStorage(), invocation);
 
         mockingProgress().validateState();
 
@@ -67,12 +67,16 @@ public class MockHandlerImpl<T> implements MockHandler<T> {
         if (verificationMode != null) {
             // We need to check if verification was started on the correct mock
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
-                VerificationDataImpl data = new VerificationDataImpl(invocationContainer, invocationMatcher);
+            if (MockUtil.areSameMocks(
+                    ((MockAwareVerificationMode) verificationMode).getMock(),
+                    invocation.getMock())) {
+                VerificationDataImpl data =
+                        new VerificationDataImpl(invocationContainer, invocationMatcher);
                 verificationMode.verify(data);
                 return null;
             } else {
-                // this means there is an invocation on a different mock. Re-adding verification mode
+                // this means there is an invocation on a different mock. Re-adding verification
+                // mode
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
                 mockingProgress().verificationStarted(verificationMode);
             }
@@ -86,8 +90,11 @@ public class MockHandlerImpl<T> implements MockHandler<T> {
         // look for existing answer for this invocation
         StubbedInvocationMatcher stubbing = invocationContainer.findAnswerFor(invocation);
         // TODO #793 - when completed, we should be able to get rid of the casting below
-        notifyStubbedAnswerLookup(invocation, stubbing, invocationContainer.getStubbingsAscending(),
-                                  (CreationSettings) mockSettings);
+        notifyStubbedAnswerLookup(
+                invocation,
+                stubbing,
+                invocationContainer.getStubbingsAscending(),
+                (CreationSettings) mockSettings);
 
         if (stubbing != null) {
             stubbing.captureArgumentsFrom(invocation);
@@ -95,28 +102,32 @@ public class MockHandlerImpl<T> implements MockHandler<T> {
             try {
                 return stubbing.answer(invocation);
             } finally {
-                //Needed so that we correctly isolate stubbings in some scenarios
-                //see MockitoStubbedCallInAnswerTest or issue #1279
+                // Needed so that we correctly isolate stubbings in some scenarios
+                // see MockitoStubbedCallInAnswerTest or issue #1279
                 mockingProgress().reportOngoingStubbing(ongoingStubbing);
             }
         } else {
             Object ret = mockSettings.getDefaultAnswer().answer(invocation);
             DefaultAnswerValidator.validateReturnValueFor(invocation, ret);
 
-            //Mockito uses it to redo setting invocation for potential stubbing in case of partial mocks / spies.
-            //Without it, the real method inside 'when' might have delegated to other self method
-            //and overwrite the intended stubbed method with a different one.
-            //This means we would be stubbing a wrong method.
-            //Typically this would led to runtime exception that validates return type with stubbed method signature.
+            // Mockito uses it to redo setting invocation for potential stubbing in case of partial
+            // mocks / spies.
+            // Without it, the real method inside 'when' might have delegated to other self method
+            // and overwrite the intended stubbed method with a different one.
+            // This means we would be stubbing a wrong method.
+            // Typically this would led to runtime exception that validates return type with stubbed
+            // method signature.
             invocationContainer.resetInvocationForPotentialStubbing(invocationMatcher);
             return ret;
         }
     }
 
+    @Override
     public MockCreationSettings<T> getMockSettings() {
         return mockSettings;
     }
 
+    @Override
     public InvocationContainer getInvocationContainer() {
         return invocationContainer;
     }
diff --git a/src/main/java/org/mockito/internal/handler/NotifiedMethodInvocationReport.java b/src/main/java/org/mockito/internal/handler/NotifiedMethodInvocationReport.java
index 1684f9b..39871c8 100644
--- a/src/main/java/org/mockito/internal/handler/NotifiedMethodInvocationReport.java
+++ b/src/main/java/org/mockito/internal/handler/NotifiedMethodInvocationReport.java
@@ -4,12 +4,12 @@
  */
 package org.mockito.internal.handler;
 
+import static org.mockito.internal.matchers.Equality.areEqual;
+
 import org.mockito.invocation.DescribedInvocation;
 import org.mockito.invocation.Invocation;
 import org.mockito.listeners.MethodInvocationReport;
 
-import static org.mockito.internal.matchers.Equality.areEqual;
-
 /**
  * Report on a method call
  */
@@ -18,7 +18,6 @@ public class NotifiedMethodInvocationReport implements MethodInvocationReport {
     private final Object returnedValue;
     private final Throwable throwable;
 
-
     /**
      * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.
      *
@@ -45,38 +44,50 @@ public class NotifiedMethodInvocationReport implements MethodInvocationReport {
         this.throwable = throwable;
     }
 
+    @Override
     public DescribedInvocation getInvocation() {
         return invocation;
     }
 
+    @Override
     public Object getReturnedValue() {
         return returnedValue;
     }
 
+    @Override
     public Throwable getThrowable() {
         return throwable;
     }
 
+    @Override
     public boolean threwException() {
         return throwable != null;
     }
 
+    @Override
     public String getLocationOfStubbing() {
-        return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt().toString();
+        return (invocation.stubInfo() == null)
+                ? null
+                : invocation.stubInfo().stubbedAt().toString();
     }
 
-
+    @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
 
         NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;
 
-        return areEqual(invocation, that.invocation) &&
-               areEqual(returnedValue, that.returnedValue) &&
-               areEqual(throwable, that.throwable);
+        return areEqual(invocation, that.invocation)
+                && areEqual(returnedValue, that.returnedValue)
+                && areEqual(throwable, that.throwable);
     }
 
+    @Override
     public int hashCode() {
         int result = invocation != null ? invocation.hashCode() : 0;
         result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);
diff --git a/src/main/java/org/mockito/internal/handler/NullResultGuardian.java b/src/main/java/org/mockito/internal/handler/NullResultGuardian.java
index 7f4a3a7..65de62e 100644
--- a/src/main/java/org/mockito/internal/handler/NullResultGuardian.java
+++ b/src/main/java/org/mockito/internal/handler/NullResultGuardian.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.handler;
 
-import org.mockito.invocation.InvocationContainer;
+import static org.mockito.internal.util.Primitives.defaultValue;
+
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationContainer;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
-import static org.mockito.internal.util.Primitives.defaultValue;
-
 /**
  * Protects the results from delegate MockHandler. Makes sure the results are valid.
  *
@@ -28,12 +28,12 @@ class NullResultGuardian<T> implements MockHandler<T> {
     public Object handle(Invocation invocation) throws Throwable {
         Object result = delegate.handle(invocation);
         Class<?> returnType = invocation.getMethod().getReturnType();
-        if(result == null && returnType.isPrimitive()) {
-            //primitive values cannot be null
+        if (result == null && returnType.isPrimitive()) {
+            // primitive values cannot be null
             return defaultValue(returnType);
         }
         return result;
-     }
+    }
 
     @Override
     public MockCreationSettings<T> getMockSettings() {
diff --git a/src/main/java/org/mockito/internal/invocation/AbstractAwareMethod.java b/src/main/java/org/mockito/internal/invocation/AbstractAwareMethod.java
index 2b36073..5e49215 100644
--- a/src/main/java/org/mockito/internal/invocation/AbstractAwareMethod.java
+++ b/src/main/java/org/mockito/internal/invocation/AbstractAwareMethod.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
 public interface AbstractAwareMethod {
diff --git a/src/main/java/org/mockito/internal/invocation/ArgumentsProcessor.java b/src/main/java/org/mockito/internal/invocation/ArgumentsProcessor.java
index 2621193..aa3edf0 100644
--- a/src/main/java/org/mockito/internal/invocation/ArgumentsProcessor.java
+++ b/src/main/java/org/mockito/internal/invocation/ArgumentsProcessor.java
@@ -4,31 +4,34 @@
  */
 package org.mockito.internal.invocation;
 
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.matchers.ArrayEquals;
-import org.mockito.internal.matchers.Equals;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-/**
- * by Szczepan Faber, created at: 3/31/12
- */
-public class ArgumentsProcessor {
-    // drops hidden synthetic parameters (last continuation parameter from Kotlin suspending functions)
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.matchers.ArrayEquals;
+import org.mockito.internal.matchers.Equals;
+
+/** by Szczepan Faber, created at: 3/31/12 */
+public final class ArgumentsProcessor {
+    // drops hidden synthetic parameters (last continuation parameter from Kotlin suspending
+    // functions)
     // and expands varargs
     public static Object[] expandArgs(MockitoMethod method, Object[] args) {
         int nParams = method.getParameterTypes().length;
-        if (args != null && args.length > nParams)
-            args = Arrays.copyOf(args, nParams); // drop extra args (currently -- Kotlin continuation synthetic arg)
+        if (args != null && args.length > nParams) {
+            args = Arrays.copyOf(args, nParams);
+        } // drop extra args (currently -- Kotlin continuation synthetic
+        // arg)
         return expandVarArgs(method.isVarArgs(), args);
     }
 
     // expands array varArgs that are given by runtime (1, [a, b]) into true
     // varArgs (1, a, b);
     private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
-        if (!isVarArgs || isNullOrEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {
+        if (!isVarArgs
+                || isNullOrEmpty(args)
+                || (args[args.length - 1] != null && !args[args.length - 1].getClass().isArray())) {
             return args == null ? new Object[0] : args;
         }
 
@@ -36,7 +39,7 @@ public class ArgumentsProcessor {
         Object[] varArgs;
         if (args[nonVarArgsCount] == null) {
             // in case someone deliberately passed null varArg array
-            varArgs = new Object[] { null };
+            varArgs = new Object[] {null};
         } else {
             varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);
         }
@@ -52,7 +55,7 @@ public class ArgumentsProcessor {
     }
 
     public static List<ArgumentMatcher> argumentsToMatchers(Object[] arguments) {
-        List<ArgumentMatcher> matchers = new ArrayList<ArgumentMatcher>(arguments.length);
+        List<ArgumentMatcher> matchers = new ArrayList<>(arguments.length);
         for (Object arg : arguments) {
             if (arg != null && arg.getClass().isArray()) {
                 matchers.add(new ArrayEquals(arg));
@@ -63,5 +66,5 @@ public class ArgumentsProcessor {
         return matchers;
     }
 
-
+    private ArgumentsProcessor() {}
 }
diff --git a/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java b/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
index d08f6b1..81f8015 100644
--- a/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
+++ b/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
@@ -4,48 +4,74 @@
  */
 package org.mockito.internal.invocation;
 
+import java.lang.reflect.Method;
+import java.util.concurrent.Callable;
+
 import org.mockito.internal.creation.DelegatingMethod;
-import org.mockito.internal.invocation.mockref.MockWeakReference;
 import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.mockref.MockWeakReference;
 import org.mockito.internal.progress.SequenceNumber;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationFactory;
 import org.mockito.invocation.Location;
 import org.mockito.mock.MockCreationSettings;
 
-import java.lang.reflect.Method;
-import java.util.concurrent.Callable;
-
 public class DefaultInvocationFactory implements InvocationFactory {
 
-    public Invocation createInvocation(Object target, MockCreationSettings settings, Method method, final Callable realMethod, Object... args) {
+    public Invocation createInvocation(
+            Object target,
+            MockCreationSettings settings,
+            Method method,
+            final Callable realMethod,
+            Object... args) {
         RealMethod superMethod = new RealMethod.FromCallable(realMethod);
         return createInvocation(target, settings, method, superMethod, args);
     }
 
-    public Invocation createInvocation(Object target, MockCreationSettings settings, Method method, RealMethodBehavior realMethod, Object... args) {
+    @Override
+    public Invocation createInvocation(
+            Object target,
+            MockCreationSettings settings,
+            Method method,
+            RealMethodBehavior realMethod,
+            Object... args) {
         RealMethod superMethod = new RealMethod.FromBehavior(realMethod);
         return createInvocation(target, settings, method, superMethod, args);
     }
 
-    private Invocation createInvocation(Object target, MockCreationSettings settings, Method method, RealMethod superMethod, Object[] args) {
+    private Invocation createInvocation(
+            Object target,
+            MockCreationSettings settings,
+            Method method,
+            RealMethod superMethod,
+            Object[] args) {
         return createInvocation(target, method, args, superMethod, settings);
     }
 
-    public static InterceptedInvocation createInvocation(Object mock, Method invokedMethod, Object[] arguments, RealMethod realMethod, MockCreationSettings settings, Location location) {
+    public static InterceptedInvocation createInvocation(
+            Object mock,
+            Method invokedMethod,
+            Object[] arguments,
+            RealMethod realMethod,
+            MockCreationSettings settings,
+            Location location) {
         return new InterceptedInvocation(
-            new MockWeakReference<Object>(mock),
-            createMockitoMethod(invokedMethod, settings),
-            arguments,
-            realMethod,
-            location,
-            SequenceNumber.next()
-        );
+                new MockWeakReference<Object>(mock),
+                createMockitoMethod(invokedMethod, settings),
+                arguments,
+                realMethod,
+                location,
+                SequenceNumber.next());
     }
 
-    private static InterceptedInvocation createInvocation(Object mock, Method invokedMethod, Object[]
-        arguments, RealMethod realMethod, MockCreationSettings settings) {
-        return createInvocation(mock, invokedMethod, arguments, realMethod, settings, new LocationImpl());
+    private static InterceptedInvocation createInvocation(
+            Object mock,
+            Method invokedMethod,
+            Object[] arguments,
+            RealMethod realMethod,
+            MockCreationSettings settings) {
+        return createInvocation(
+                mock, invokedMethod, arguments, realMethod, settings, new LocationImpl());
     }
 
     private static MockitoMethod createMockitoMethod(Method method, MockCreationSettings settings) {
diff --git a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
index b9cf072..20316ec 100644
--- a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
+++ b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
@@ -4,25 +4,29 @@
  */
 package org.mockito.internal.invocation;
 
-import org.mockito.internal.invocation.mockref.MockReference;
+import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
+import static org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.List;
+
+import org.mockito.ArgumentMatcher;
 import org.mockito.internal.exceptions.VerificationAwareInvocation;
+import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.internal.reporting.PrintSettings;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
 import org.mockito.invocation.StubInfo;
 
-import java.lang.reflect.Method;
-import java.util.Arrays;
-
-import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
-
 public class InterceptedInvocation implements Invocation, VerificationAwareInvocation {
 
     private static final long serialVersionUID = 475027563923510472L;
 
     private final MockReference<Object> mockRef;
     private final MockitoMethod mockitoMethod;
-    private final Object[] arguments, rawArguments;
+    private final Object[] arguments;
+    private final Object[] rawArguments;
     private final RealMethod realMethod;
 
     private final int sequenceNumber;
@@ -33,12 +37,13 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
     private boolean isIgnoredForVerification;
     private StubInfo stubInfo;
 
-    public InterceptedInvocation(MockReference<Object> mockRef,
-                                 MockitoMethod mockitoMethod,
-                                 Object[] arguments,
-                                 RealMethod realMethod,
-                                 Location location,
-                                 int sequenceNumber) {
+    public InterceptedInvocation(
+            MockReference<Object> mockRef,
+            MockitoMethod mockitoMethod,
+            Object[] arguments,
+            RealMethod realMethod,
+            Location location,
+            int sequenceNumber) {
         this.mockRef = mockRef;
         this.mockitoMethod = mockitoMethod;
         this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, arguments);
@@ -119,6 +124,16 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
         return (T) arguments[index];
     }
 
+    @Override
+    public <T> T getArgument(int index, Class<T> clazz) {
+        return clazz.cast(arguments[index]);
+    }
+
+    @Override
+    public List<ArgumentMatcher> getArgumentsAsMatchers() {
+        return argumentsToMatchers(getArguments());
+    }
+
     @Override
     public Object callRealMethod() throws Throwable {
         if (!realMethod.isInvokable()) {
@@ -127,15 +142,40 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
         return realMethod.invoke();
     }
 
+    /**
+     * @deprecated Not used by Mockito but by mockito-scala
+     */
+    @Deprecated
+    public MockReference<Object> getMockRef() {
+        return mockRef;
+    }
+
+    /**
+     * @deprecated Not used by Mockito but by mockito-scala
+     */
+    @Deprecated
+    public MockitoMethod getMockitoMethod() {
+        return mockitoMethod;
+    }
+
+    /**
+     * @deprecated Not used by Mockito but by mockito-scala
+     */
+    @Deprecated
+    public RealMethod getRealMethod() {
+        return realMethod;
+    }
+
     @Override
     public int hashCode() {
-        //TODO SF we need to provide hash code implementation so that there are no unexpected, slight perf issues
+        // TODO SF we need to provide hash code implementation so that there are no unexpected,
+        // slight perf issues
         return 1;
     }
 
     @Override
     public boolean equals(Object o) {
-        if (o == null || !o.getClass().equals(this.getClass())) {
+        if (!(o instanceof InterceptedInvocation)) {
             return false;
         }
         InterceptedInvocation other = (InterceptedInvocation) o;
@@ -148,17 +188,20 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
         return Arrays.equals(arguments, this.arguments);
     }
 
+    @Override
     public String toString() {
-        return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);
+        return new PrintSettings().print(getArgumentsAsMatchers(), this);
     }
 
-    public final static RealMethod NO_OP = new RealMethod() {
-        public boolean isInvokable() {
-            return false;
-        }
-        public Object invoke() throws Throwable {
-            return null;
-        }
-    };
+    public static final RealMethod NO_OP =
+            new RealMethod() {
+                @Override
+                public boolean isInvokable() {
+                    return false;
+                }
 
+                public Object invoke() throws Throwable {
+                    return null;
+                }
+            };
 }
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationComparator.java b/src/main/java/org/mockito/internal/invocation/InvocationComparator.java
index 46dc08e..2af9358 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationComparator.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationComparator.java
@@ -4,15 +4,16 @@
  */
 package org.mockito.internal.invocation;
 
-import org.mockito.invocation.Invocation;
-
 import java.util.Comparator;
 
+import org.mockito.invocation.Invocation;
+
 /**
  * Compares invocations based on the sequence number
  */
 public class InvocationComparator implements Comparator<Invocation> {
+    @Override
     public int compare(Invocation o1, Invocation o2) {
-        return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());
+        return Integer.compare(o1.getSequenceNumber(), o2.getSequenceNumber());
     }
 }
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationMarker.java b/src/main/java/org/mockito/internal/invocation/InvocationMarker.java
index fc48b4d..5f32dea 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationMarker.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationMarker.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.invocation;
 
+import java.util.List;
+
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 
-import java.util.List;
-
 public class InvocationMarker {
 
-    private InvocationMarker(){}
+    private InvocationMarker() {}
 
     public static void markVerified(List<Invocation> invocations, MatchableInvocation wanted) {
         for (Invocation invocation : invocations) {
@@ -25,7 +25,8 @@ public class InvocationMarker {
         wanted.captureArgumentsFrom(invocation);
     }
 
-    public static void markVerifiedInOrder(List<Invocation> chunk, MatchableInvocation wanted, InOrderContext context) {
+    public static void markVerifiedInOrder(
+            List<Invocation> chunk, MatchableInvocation wanted, InOrderContext context) {
         markVerified(chunk, wanted);
 
         for (Invocation i : chunk) {
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
index 83a28ff..6cc7a8c 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
@@ -2,10 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
-import static org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers;
 import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
 import static org.mockito.internal.invocation.TypeSafeMatching.matchesTypeSafe;
 
@@ -15,6 +13,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.CapturesArguments;
 import org.mockito.internal.reporting.PrintSettings;
@@ -32,11 +31,11 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
     private final Invocation invocation;
     private final List<ArgumentMatcher<?>> matchers;
 
-    @SuppressWarnings({ "rawtypes", "unchecked" })
+    @SuppressWarnings({"rawtypes", "unchecked"})
     public InvocationMatcher(Invocation invocation, List<ArgumentMatcher> matchers) {
         this.invocation = invocation;
         if (matchers.isEmpty()) {
-            this.matchers = (List) argumentsToMatchers(invocation.getArguments());
+            this.matchers = (List) invocation.getArgumentsAsMatchers();
         } else {
             this.matchers = (List) matchers;
         }
@@ -44,11 +43,11 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
 
     @SuppressWarnings("rawtypes")
     public InvocationMatcher(Invocation invocation) {
-        this(invocation, Collections.<ArgumentMatcher> emptyList());
+        this(invocation, Collections.<ArgumentMatcher>emptyList());
     }
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
-        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
+        LinkedList<InvocationMatcher> out = new LinkedList<>();
         for (Invocation i : invocations) {
             out.add(new InvocationMatcher(i));
         }
@@ -65,20 +64,22 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
     }
 
     @Override
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public List<ArgumentMatcher> getMatchers() {
         return (List) matchers;
     }
 
     @Override
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public String toString() {
         return new PrintSettings().print((List) matchers, invocation);
     }
 
     @Override
     public boolean matches(Invocation candidate) {
-        return invocation.getMock().equals(candidate.getMock()) && hasSameMethod(candidate) && argumentsMatch(candidate);
+        return invocation.getMock() == candidate.getMock()
+                && hasSameMethod(candidate)
+                && argumentsMatch(candidate);
     }
 
     /**
@@ -108,7 +109,8 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
     @Override
     public boolean hasSameMethod(Invocation candidate) {
         // not using method.equals() for 1 good reason:
-        // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
+        // sometimes java generates forwarding methods when generics are in play see
+        // JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
 
@@ -128,7 +130,8 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
 
     @Override
     public void captureArgumentsFrom(Invocation invocation) {
-        MatcherApplicationStrategy strategy = getMatcherApplicationStrategyFor(invocation, matchers);
+        MatcherApplicationStrategy strategy =
+                getMatcherApplicationStrategyFor(invocation, matchers);
         strategy.forEachMatcherAndArgument(captureArgument());
     }
 
@@ -146,9 +149,10 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
         };
     }
 
-    @SuppressWarnings({ "rawtypes", "unchecked" })
+    @SuppressWarnings({"rawtypes", "unchecked"})
     private boolean argumentsMatch(Invocation actual) {
         List matchers = getMatchers();
-        return getMatcherApplicationStrategyFor(actual, matchers).forEachMatcherAndArgument( matchesTypeSafe());
+        return getMatcherApplicationStrategyFor(actual, matchers)
+                .forEachMatcherAndArgument(matchesTypeSafe());
     }
 }
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
index 260321b..fc0cb22 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
 import java.util.LinkedList;
@@ -17,14 +16,17 @@ import org.mockito.invocation.MatchableInvocation;
 
 public class InvocationsFinder {
 
-    private InvocationsFinder() {
-    }
+    private InvocationsFinder() {}
 
-    public static List<Invocation> findInvocations(List<Invocation> invocations, MatchableInvocation wanted) {
+    public static List<Invocation> findInvocations(
+            List<Invocation> invocations, MatchableInvocation wanted) {
         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));
     }
 
-    public static List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, MatchableInvocation wanted, InOrderContext orderingContext) {
+    public static List<Invocation> findAllMatchingUnverifiedChunks(
+            List<Invocation> invocations,
+            MatchableInvocation wanted,
+            InOrderContext orderingContext) {
         List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);
         return ListUtil.filter(unverified, new RemoveNotMatching(wanted));
     }
@@ -44,7 +46,11 @@ public class InvocationsFinder {
      * if wanted is 1 and mode is times(x), where x != 2 then returns
      * 1,1,1
      */
-    public static List<Invocation> findMatchingChunk(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
+    public static List<Invocation> findMatchingChunk(
+            List<Invocation> invocations,
+            MatchableInvocation wanted,
+            int wantedCount,
+            InOrderContext context) {
         List<Invocation> unverified = removeVerifiedInOrder(invocations, context);
         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);
 
@@ -55,8 +61,9 @@ public class InvocationsFinder {
         }
     }
 
-    private static List<Invocation> getFirstMatchingChunk(MatchableInvocation wanted, List<Invocation> unverified) {
-        List<Invocation> firstChunk = new LinkedList<Invocation>();
+    private static List<Invocation> getFirstMatchingChunk(
+            MatchableInvocation wanted, List<Invocation> unverified) {
+        List<Invocation> firstChunk = new LinkedList<>();
         for (Invocation invocation : unverified) {
             if (wanted.matches(invocation)) {
                 firstChunk.add(invocation);
@@ -67,16 +74,18 @@ public class InvocationsFinder {
         return firstChunk;
     }
 
-    public static Invocation findFirstMatchingUnverifiedInvocation(List<Invocation> invocations, MatchableInvocation wanted, InOrderContext context ){
-        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){
-            if( wanted.matches( invocation )){
+    public static Invocation findFirstMatchingUnverifiedInvocation(
+            List<Invocation> invocations, MatchableInvocation wanted, InOrderContext context) {
+        for (Invocation invocation : removeVerifiedInOrder(invocations, context)) {
+            if (wanted.matches(invocation)) {
                 return invocation;
             }
         }
         return null;
     }
 
-    public static Invocation findSimilarInvocation(List<Invocation> invocations, MatchableInvocation wanted) {
+    public static Invocation findSimilarInvocation(
+            List<Invocation> invocations, MatchableInvocation wanted) {
         Invocation firstSimilar = null;
         for (Invocation invocation : invocations) {
             if (!wanted.hasSimilarMethod(invocation)) {
@@ -116,8 +125,10 @@ public class InvocationsFinder {
         }
     }
 
-    public static Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {
-        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));
+    public static Invocation findPreviousVerifiedInOrder(
+            List<Invocation> invocations, InOrderContext context) {
+        LinkedList<Invocation> verifiedOnly =
+                ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));
 
         if (verifiedOnly.isEmpty()) {
             return null;
@@ -126,8 +137,9 @@ public class InvocationsFinder {
         }
     }
 
-    private static List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {
-        List<Invocation> unverified = new LinkedList<Invocation>();
+    private static List<Invocation> removeVerifiedInOrder(
+            List<Invocation> invocations, InOrderContext orderingContext) {
+        List<Invocation> unverified = new LinkedList<>();
         for (Invocation i : invocations) {
             if (orderingContext.isVerified(i)) {
                 unverified.clear();
@@ -139,7 +151,7 @@ public class InvocationsFinder {
     }
 
     public static List<Location> getAllLocations(List<Invocation> invocations) {
-        List<Location> locations = new LinkedList<Location>();
+        List<Location> locations = new LinkedList<>();
         for (Invocation invocation : invocations) {
             locations.add(invocation.getLocation());
         }
@@ -153,6 +165,7 @@ public class InvocationsFinder {
             this.wanted = wanted;
         }
 
+        @Override
         public boolean isOut(Invocation invocation) {
             return !wanted.matches(invocation);
         }
@@ -165,6 +178,7 @@ public class InvocationsFinder {
             this.orderingContext = orderingContext;
         }
 
+        @Override
         public boolean isOut(Invocation invocation) {
             return !orderingContext.isVerified(invocation);
         }
@@ -184,9 +198,10 @@ public class InvocationsFinder {
      * @param context
      * @param orderedInvocations
      */
-    public static Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {
+    public static Invocation findFirstUnverifiedInOrder(
+            InOrderContext context, List<Invocation> orderedInvocations) {
         Invocation candidate = null;
-        for(Invocation i : orderedInvocations) {
+        for (Invocation i : orderedInvocations) {
             if (!context.isVerified(i)) {
                 candidate = candidate != null ? candidate : i;
             } else {
diff --git a/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
index e47156f..acc7382 100644
--- a/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
+++ b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
@@ -23,9 +23,10 @@ public class MatcherApplicationStrategy {
     private final List<ArgumentMatcher<?>> matchers;
     private final MatcherApplicationType matchingType;
 
-
-
-    private MatcherApplicationStrategy(Invocation invocation, List<ArgumentMatcher<?>> matchers, MatcherApplicationType matchingType) {
+    private MatcherApplicationStrategy(
+            Invocation invocation,
+            List<ArgumentMatcher<?>> matchers,
+            MatcherApplicationType matchingType) {
         this.invocation = invocation;
         if (matchingType == MATCH_EACH_VARARGS_WITH_LAST_MATCHER) {
             int times = varargLength(invocation);
@@ -49,7 +50,8 @@ public class MatcherApplicationStrategy {
      *            {@link CapturingMatcher}
      * @return never <code>null</code>
      */
-    public static MatcherApplicationStrategy getMatcherApplicationStrategyFor(Invocation invocation, List<ArgumentMatcher<?>> matchers) {
+    public static MatcherApplicationStrategy getMatcherApplicationStrategyFor(
+            Invocation invocation, List<ArgumentMatcher<?>> matchers) {
 
         MatcherApplicationType type = getMatcherApplicationType(invocation, matchers);
         return new MatcherApplicationStrategy(invocation, matchers, type);
@@ -72,8 +74,9 @@ public class MatcherApplicationStrategy {
      *         </ul>
      */
     public boolean forEachMatcherAndArgument(ArgumentMatcherAction action) {
-        if (matchingType == ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS)
+        if (matchingType == ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS) {
             return false;
+        }
 
         Object[] arguments = invocation.getArguments();
         for (int i = 0; i < arguments.length; i++) {
@@ -87,7 +90,8 @@ public class MatcherApplicationStrategy {
         return true;
     }
 
-    private static MatcherApplicationType getMatcherApplicationType(Invocation invocation, List<ArgumentMatcher<?>> matchers) {
+    private static MatcherApplicationType getMatcherApplicationType(
+            Invocation invocation, List<ArgumentMatcher<?>> matchers) {
         final int rawArguments = invocation.getRawArguments().length;
         final int expandedArguments = invocation.getArguments().length;
         final int matcherCount = matchers.size();
@@ -106,12 +110,13 @@ public class MatcherApplicationStrategy {
     private static boolean isLastMatcherVarargMatcher(final List<ArgumentMatcher<?>> matchers) {
         ArgumentMatcher<?> argumentMatcher = lastMatcher(matchers);
         if (argumentMatcher instanceof HamcrestArgumentMatcher<?>) {
-           return  ((HamcrestArgumentMatcher<?>) argumentMatcher).isVarargMatcher();
+            return ((HamcrestArgumentMatcher<?>) argumentMatcher).isVarargMatcher();
         }
         return argumentMatcher instanceof VarargMatcher;
     }
 
-    private static List<ArgumentMatcher<?>> appendLastMatcherNTimes(List<ArgumentMatcher<?>> matchers, int timesToAppendLastMatcher) {
+    private static List<ArgumentMatcher<?>> appendLastMatcherNTimes(
+            List<ArgumentMatcher<?>> matchers, int timesToAppendLastMatcher) {
         ArgumentMatcher<?> lastMatcher = lastMatcher(matchers);
 
         List<ArgumentMatcher<?>> expandedMatchers = new ArrayList<ArgumentMatcher<?>>(matchers);
@@ -132,6 +137,8 @@ public class MatcherApplicationStrategy {
     }
 
     enum MatcherApplicationType {
-        ONE_MATCHER_PER_ARGUMENT, MATCH_EACH_VARARGS_WITH_LAST_MATCHER, ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS;
+        ONE_MATCHER_PER_ARGUMENT,
+        MATCH_EACH_VARARGS_WITH_LAST_MATCHER,
+        ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS;
     }
 }
diff --git a/src/main/java/org/mockito/internal/invocation/MatchersBinder.java b/src/main/java/org/mockito/internal/invocation/MatchersBinder.java
index 8a01d2c..dd3f239 100644
--- a/src/main/java/org/mockito/internal/invocation/MatchersBinder.java
+++ b/src/main/java/org/mockito/internal/invocation/MatchersBinder.java
@@ -2,10 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
-
 import static org.mockito.internal.exceptions.Reporter.invalidUseOfMatchers;
 
 import java.io.Serializable;
@@ -20,11 +18,12 @@ import org.mockito.invocation.Invocation;
 @SuppressWarnings("unchecked")
 public class MatchersBinder implements Serializable {
 
-    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
+    public InvocationMatcher bindMatchers(
+            ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
         List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();
         validateMatchers(invocation, lastMatchers);
 
-        List<ArgumentMatcher> matchers = new LinkedList<ArgumentMatcher>();
+        List<ArgumentMatcher> matchers = new LinkedList<>();
         for (LocalizedMatcher m : lastMatchers) {
             matchers.add(m.getMatcher());
         }
diff --git a/src/main/java/org/mockito/internal/invocation/RealMethod.java b/src/main/java/org/mockito/internal/invocation/RealMethod.java
index b7c8c17..8cb8b72 100644
--- a/src/main/java/org/mockito/internal/invocation/RealMethod.java
+++ b/src/main/java/org/mockito/internal/invocation/RealMethod.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.invocation;
 
+import java.io.Serializable;
+import java.util.concurrent.Callable;
+
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
 import org.mockito.invocation.InvocationFactory;
 import org.mockito.invocation.InvocationOnMock;
 
-import java.io.Serializable;
-import java.util.concurrent.Callable;
-
 /**
  * Interface that wraps a 'real' method of the mock object.
  * Needed for test spies or {@link InvocationOnMock#callRealMethod()}.
@@ -18,7 +18,6 @@ import java.util.concurrent.Callable;
 public interface RealMethod extends Serializable {
 
     enum IsIllegal implements RealMethod {
-
         INSTANCE;
 
         @Override
@@ -34,12 +33,13 @@ public interface RealMethod extends Serializable {
 
     class FromCallable extends FromBehavior implements RealMethod {
         public FromCallable(final Callable<?> callable) {
-            super(new InvocationFactory.RealMethodBehavior() {
-                @Override
-                public Object call() throws Throwable {
-                    return callable.call();
-                }
-            });
+            super(
+                    new InvocationFactory.RealMethodBehavior() {
+                        @Override
+                        public Object call() throws Throwable {
+                            return callable.call();
+                        }
+                    });
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/invocation/SerializableMethod.java b/src/main/java/org/mockito/internal/invocation/SerializableMethod.java
index 0ebbe97..f007371 100644
--- a/src/main/java/org/mockito/internal/invocation/SerializableMethod.java
+++ b/src/main/java/org/mockito/internal/invocation/SerializableMethod.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.invocation;
 
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.creation.SuspendMethod;
-
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.Arrays;
 
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.creation.SuspendMethod;
+
 public class SerializableMethod implements Serializable, MockitoMethod {
 
     private static final long serialVersionUID = 6005610965006048445L;
@@ -24,7 +24,7 @@ public class SerializableMethod implements Serializable, MockitoMethod {
     private final boolean isVarArgs;
     private final boolean isAbstract;
 
-    private volatile transient Method method;
+    private transient volatile Method method;
 
     public SerializableMethod(Method method) {
         this.method = method;
@@ -37,30 +37,37 @@ public class SerializableMethod implements Serializable, MockitoMethod {
         isAbstract = (method.getModifiers() & Modifier.ABSTRACT) != 0;
     }
 
+    @Override
     public String getName() {
         return methodName;
     }
 
+    @Override
     public Class<?> getReturnType() {
         return returnType;
     }
 
+    @Override
     public Class<?>[] getParameterTypes() {
         return parameterTypes;
     }
 
+    @Override
     public Class<?>[] getExceptionTypes() {
         return exceptionTypes;
     }
 
+    @Override
     public boolean isVarArgs() {
         return isVarArgs;
     }
 
+    @Override
     public boolean isAbstract() {
         return isAbstract;
     }
 
+    @Override
     public Method getJavaMethod() {
         if (method != null) {
             return method;
@@ -69,14 +76,18 @@ public class SerializableMethod implements Serializable, MockitoMethod {
             method = declaringClass.getDeclaredMethod(methodName, parameterTypes);
             return method;
         } catch (SecurityException e) {
-            String message = String.format(
-                    "The method %1$s.%2$s is probably private or protected and cannot be mocked.\n" +
-                            "Please report this as a defect with an example of how to reproduce it.", declaringClass, methodName);
+            String message =
+                    String.format(
+                            "The method %1$s.%2$s is probably private or protected and cannot be mocked.\n"
+                                    + "Please report this as a defect with an example of how to reproduce it.",
+                            declaringClass, methodName);
             throw new MockitoException(message, e);
         } catch (NoSuchMethodException e) {
-            String message = String.format(
-                    "The method %1$s.%2$s does not exists and you should not get to this point.\n" +
-                            "Please report this as a defect with an example of how to reproduce it.", declaringClass, methodName);
+            String message =
+                    String.format(
+                            "The method %1$s.%2$s does not exists and you should not get to this point.\n"
+                                    + "Please report this as a defect with an example of how to reproduce it.",
+                            declaringClass, methodName);
             throw new MockitoException(message, e);
         }
     }
@@ -88,30 +99,40 @@ public class SerializableMethod implements Serializable, MockitoMethod {
 
     @Override
     public boolean equals(Object obj) {
-        if (this == obj)
+        if (this == obj) {
             return true;
-        if (obj == null)
+        }
+        if (obj == null) {
             return false;
-        if (getClass() != obj.getClass())
+        }
+        if (getClass() != obj.getClass()) {
             return false;
+        }
         SerializableMethod other = (SerializableMethod) obj;
         if (declaringClass == null) {
-            if (other.declaringClass != null)
+            if (other.declaringClass != null) {
                 return false;
-        } else if (!declaringClass.equals(other.declaringClass))
+            }
+        } else if (!declaringClass.equals(other.declaringClass)) {
             return false;
+        }
         if (methodName == null) {
-            if (other.methodName != null)
+            if (other.methodName != null) {
                 return false;
-        } else if (!methodName.equals(other.methodName))
+            }
+        } else if (!methodName.equals(other.methodName)) {
             return false;
-        if (!Arrays.equals(parameterTypes, other.parameterTypes))
+        }
+        if (!Arrays.equals(parameterTypes, other.parameterTypes)) {
             return false;
+        }
         if (returnType == null) {
-            if (other.returnType != null)
+            if (other.returnType != null) {
                 return false;
-        } else if (!returnType.equals(other.returnType))
+            }
+        } else if (!returnType.equals(other.returnType)) {
             return false;
+        }
         return true;
     }
 }
diff --git a/src/main/java/org/mockito/internal/invocation/StubInfoImpl.java b/src/main/java/org/mockito/internal/invocation/StubInfoImpl.java
index 794d25a..c2720d3 100644
--- a/src/main/java/org/mockito/internal/invocation/StubInfoImpl.java
+++ b/src/main/java/org/mockito/internal/invocation/StubInfoImpl.java
@@ -4,12 +4,12 @@
  */
 package org.mockito.internal.invocation;
 
+import java.io.Serializable;
+
 import org.mockito.invocation.DescribedInvocation;
 import org.mockito.invocation.Location;
 import org.mockito.invocation.StubInfo;
 
-import java.io.Serializable;
-
 public class StubInfoImpl implements StubInfo, Serializable {
     private static final long serialVersionUID = 2125827349332068867L;
     private final DescribedInvocation stubbedAt;
@@ -18,6 +18,7 @@ public class StubInfoImpl implements StubInfo, Serializable {
         this.stubbedAt = stubbedAt;
     }
 
+    @Override
     public Location stubbedAt() {
         return stubbedAt.getLocation();
     }
diff --git a/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java b/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java
index 1452137..b4ca07a 100644
--- a/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java
+++ b/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java
@@ -8,31 +8,31 @@ import java.lang.reflect.Method;
 
 import org.mockito.ArgumentMatcher;
 
-@SuppressWarnings({"unchecked","rawtypes"})
+@SuppressWarnings({"unchecked", "rawtypes"})
 public class TypeSafeMatching implements ArgumentMatcherAction {
 
-    private final static ArgumentMatcherAction TYPE_SAFE_MATCHING_ACTION = new TypeSafeMatching();
+    private static final ArgumentMatcherAction TYPE_SAFE_MATCHING_ACTION = new TypeSafeMatching();
 
     private TypeSafeMatching() {}
 
-
-    public static ArgumentMatcherAction matchesTypeSafe(){
+    public static ArgumentMatcherAction matchesTypeSafe() {
         return TYPE_SAFE_MATCHING_ACTION;
     }
+
     @Override
     public boolean apply(ArgumentMatcher matcher, Object argument) {
         return isCompatible(matcher, argument) && matcher.matches(argument);
     }
 
-
     /**
      * Returns <code>true</code> if the given <b>argument</b> can be passed to
      * the given <code>argumentMatcher</code> without causing a
      * {@link ClassCastException}.
      */
     private static boolean isCompatible(ArgumentMatcher<?> argumentMatcher, Object argument) {
-        if (argument == null)
+        if (argument == null) {
             return true;
+        }
 
         Class<?> expectedArgumentType = getArgumentType(argumentMatcher);
 
@@ -51,7 +51,10 @@ public class TypeSafeMatching implements ArgumentMatcherAction {
                 return method.getParameterTypes()[0];
             }
         }
-        throw new NoSuchMethodError("Method 'matches(T)' not found in ArgumentMatcher: " + argumentMatcher + " !\r\n Please file a bug with this stack trace at: https://github.com/mockito/mockito/issues/new ");
+        throw new NoSuchMethodError(
+                "Method 'matches(T)' not found in ArgumentMatcher: "
+                        + argumentMatcher
+                        + " !\r\n Please file a bug with this stack trace at: https://github.com/mockito/mockito/issues/new ");
     }
 
     /**
diff --git a/src/main/java/org/mockito/internal/invocation/UnusedStubsFinder.java b/src/main/java/org/mockito/internal/invocation/UnusedStubsFinder.java
deleted file mode 100644
index 5aec36d..0000000
--- a/src/main/java/org/mockito/internal/invocation/UnusedStubsFinder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.internal.invocation;
-
-import org.mockito.internal.util.MockUtil;
-import org.mockito.invocation.Invocation;
-import org.mockito.stubbing.Stubbing;
-
-import java.util.LinkedList;
-import java.util.List;
-
-@Deprecated
-public class UnusedStubsFinder {
-
-    /**
-     * Finds all unused stubs for given mocks
-     *
-     * @param mocks full list of mocks
-     */
-    public List<Invocation> find(List<?> mocks) {
-        List<Invocation> unused = new LinkedList<Invocation>();
-        for (Object mock : mocks) {
-            List<Stubbing> fromSingleMock = MockUtil.getInvocationContainer(mock).getStubbingsDescending();
-            for(Stubbing s : fromSingleMock) {
-                if (!s.wasUsed()) {
-                     unused.add(s.getInvocation());
-                }
-            }
-        }
-        return unused;
-    }
-}
diff --git a/src/main/java/org/mockito/internal/invocation/finder/AllInvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/finder/AllInvocationsFinder.java
index 15dafdf..4d1e767 100644
--- a/src/main/java/org/mockito/internal/invocation/finder/AllInvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/finder/AllInvocationsFinder.java
@@ -2,16 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation.finder;
 
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
 import org.mockito.internal.invocation.InvocationComparator;
-import org.mockito.stubbing.Stubbing;
 import org.mockito.internal.stubbing.StubbingComparator;
 import org.mockito.internal.util.DefaultMockingDetails;
 import org.mockito.invocation.Invocation;
-
-import java.util.*;
+import org.mockito.stubbing.Stubbing;
 
 public class AllInvocationsFinder {
 
@@ -24,13 +26,14 @@ public class AllInvocationsFinder {
      * @return invocations
      */
     public static List<Invocation> find(Iterable<?> mocks) {
-        Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new InvocationComparator());
+        Set<Invocation> invocationsInOrder = new TreeSet<>(new InvocationComparator());
         for (Object mock : mocks) {
-            Collection<Invocation> fromSingleMock = new DefaultMockingDetails(mock).getInvocations();
+            Collection<Invocation> fromSingleMock =
+                    new DefaultMockingDetails(mock).getInvocations();
             invocationsInOrder.addAll(fromSingleMock);
         }
 
-        return new LinkedList<Invocation>(invocationsInOrder);
+        return new LinkedList<>(invocationsInOrder);
     }
 
     /**
@@ -40,9 +43,16 @@ public class AllInvocationsFinder {
      * @return stubbings
      */
     public static Set<Stubbing> findStubbings(Iterable<?> mocks) {
-        Set<Stubbing> stubbings = new TreeSet<Stubbing>(new StubbingComparator());
+        Set<Stubbing> stubbings = new TreeSet<>(new StubbingComparator());
         for (Object mock : mocks) {
-            Collection<? extends Stubbing> fromSingleMock = new DefaultMockingDetails(mock).getStubbings();
+            // TODO due to the limited scope of static mocks they cannot be processed
+            //  it would rather be required to trigger this stubbing control upon releasing
+            //  the static mock.
+            if (mock instanceof Class<?>) {
+                continue;
+            }
+            Collection<? extends Stubbing> fromSingleMock =
+                    new DefaultMockingDetails(mock).getStubbings();
             stubbings.addAll(fromSingleMock);
         }
 
diff --git a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
index 819c7e0..19b0ac0 100644
--- a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation.finder;
 
+import java.util.List;
+
 import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 
-import java.util.List;
-
 /**
  * Author: Szczepan Faber, created at: 4/3/11
  */
@@ -23,7 +22,8 @@ public class VerifiableInvocationsFinder {
         return ListUtil.filter(invocations, new RemoveIgnoredForVerification());
     }
 
-    private static class RemoveIgnoredForVerification implements Filter<Invocation>{
+    private static class RemoveIgnoredForVerification implements Filter<Invocation> {
+        @Override
         public boolean isOut(Invocation invocation) {
             return invocation.isIgnoredForVerification();
         }
diff --git a/src/main/java/org/mockito/internal/invocation/mockref/MockReference.java b/src/main/java/org/mockito/internal/invocation/mockref/MockReference.java
index 0dac2ea..3a42c57 100644
--- a/src/main/java/org/mockito/internal/invocation/mockref/MockReference.java
+++ b/src/main/java/org/mockito/internal/invocation/mockref/MockReference.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2018 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation.mockref;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/invocation/mockref/MockStrongReference.java b/src/main/java/org/mockito/internal/invocation/mockref/MockStrongReference.java
index 3b20ee5..b80883b 100644
--- a/src/main/java/org/mockito/internal/invocation/mockref/MockStrongReference.java
+++ b/src/main/java/org/mockito/internal/invocation/mockref/MockStrongReference.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2018 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation.mockref;
 
 import java.io.ObjectStreamException;
diff --git a/src/main/java/org/mockito/internal/invocation/mockref/MockWeakReference.java b/src/main/java/org/mockito/internal/invocation/mockref/MockWeakReference.java
index 256745b..ddf7f68 100644
--- a/src/main/java/org/mockito/internal/invocation/mockref/MockWeakReference.java
+++ b/src/main/java/org/mockito/internal/invocation/mockref/MockWeakReference.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2018 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation.mockref;
 
 import java.io.ObjectStreamException;
@@ -29,14 +28,15 @@ public class MockWeakReference<T> implements MockReference<T> {
         T ref = this.ref.get();
 
         if (ref == null) {
-            throw new IllegalStateException("The mock object was garbage collected. " +
-                "This should not happen in normal circumstances when using public API. " +
-                "Typically, the test class keeps strong reference to the mock object " +
-                "and it prevents getting the mock collected. Mockito internally needs " +
-                "to keep weak references to mock objects to avoid memory leaks for " +
-                "certain types of MockMaker implementations. If you see this exception " +
-                "using Mockito public API, please file a bug. For more information see " +
-                "issue #1313.");
+            throw new IllegalStateException(
+                    "The mock object was garbage collected. "
+                            + "This should not happen in normal circumstances when using public API. "
+                            + "Typically, the test class keeps strong reference to the mock object "
+                            + "and it prevents getting the mock collected. Mockito internally needs "
+                            + "to keep weak references to mock objects to avoid memory leaks for "
+                            + "certain types of MockMaker implementations. If you see this exception "
+                            + "using Mockito public API, please file a bug. For more information see "
+                            + "issue #1313.");
         }
 
         return ref;
diff --git a/src/main/java/org/mockito/internal/junit/ArgMismatchFinder.java b/src/main/java/org/mockito/internal/junit/ArgMismatchFinder.java
index e1de445..9c4ec44 100644
--- a/src/main/java/org/mockito/internal/junit/ArgMismatchFinder.java
+++ b/src/main/java/org/mockito/internal/junit/ArgMismatchFinder.java
@@ -20,9 +20,13 @@ class ArgMismatchFinder {
                 continue;
             }
             for (Stubbing stubbing : AllInvocationsFinder.findStubbings(mocks)) {
-                //method name & mock matches
-                if (!stubbing.wasUsed() && stubbing.getInvocation().getMock() == i.getMock()
-                        && stubbing.getInvocation().getMethod().getName().equals(i.getMethod().getName())) {
+                // method name & mock matches
+                if (!stubbing.wasUsed()
+                        && stubbing.getInvocation().getMock() == i.getMock()
+                        && stubbing.getInvocation()
+                                .getMethod()
+                                .getName()
+                                .equals(i.getMethod().getName())) {
                     mismatches.add(i, stubbing.getInvocation());
                 }
             }
diff --git a/src/main/java/org/mockito/internal/junit/DefaultStubbingLookupListener.java b/src/main/java/org/mockito/internal/junit/DefaultStubbingLookupListener.java
index 4885d63..c713863 100644
--- a/src/main/java/org/mockito/internal/junit/DefaultStubbingLookupListener.java
+++ b/src/main/java/org/mockito/internal/junit/DefaultStubbingLookupListener.java
@@ -4,25 +4,28 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.exceptions.Reporter;
-import org.mockito.internal.listeners.StubbingLookupEvent;
-import org.mockito.internal.listeners.StubbingLookupListener;
-import org.mockito.internal.stubbing.UnusedStubbingReporting;
-import org.mockito.invocation.Invocation;
-import org.mockito.quality.Strictness;
-import org.mockito.stubbing.Stubbing;
+import static org.mockito.internal.stubbing.StrictnessSelector.determineStrictness;
 
+import java.io.Serializable;
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.mockito.internal.stubbing.StrictnessSelector.determineStrictness;
+import org.mockito.internal.exceptions.Reporter;
+import org.mockito.internal.stubbing.UnusedStubbingReporting;
+import org.mockito.invocation.Invocation;
+import org.mockito.listeners.StubbingLookupEvent;
+import org.mockito.listeners.StubbingLookupListener;
+import org.mockito.quality.Strictness;
+import org.mockito.stubbing.Stubbing;
 
 /**
  * Default implementation of stubbing lookup listener.
  * Fails early if stub called with unexpected arguments, but only if current strictness is set to STRICT_STUBS.
  */
-class DefaultStubbingLookupListener implements StubbingLookupListener {
+class DefaultStubbingLookupListener implements StubbingLookupListener, Serializable {
+
+    private static final long serialVersionUID = -6789800638070123629L;
 
     private Strictness currentStrictness;
     private boolean mismatchesReported;
@@ -31,33 +34,51 @@ class DefaultStubbingLookupListener implements StubbingLookupListener {
         this.currentStrictness = strictness;
     }
 
+    @Override
     public void onStubbingLookup(StubbingLookupEvent event) {
-        Strictness actualStrictness = determineStrictness(event.getStubbingFound(), event.getMockSettings(), currentStrictness);
+        Strictness actualStrictness =
+                determineStrictness(
+                        event.getStubbingFound(), event.getMockSettings(), currentStrictness);
 
         if (actualStrictness != Strictness.STRICT_STUBS) {
             return;
         }
 
         if (event.getStubbingFound() == null) {
-            //If stubbing was not found for invocation it means that either the mock invocation was not stubbed or
-            //we have a stubbing arg mismatch.
-            List<Invocation> argMismatchStubbings = potentialArgMismatches(event.getInvocation(), event.getAllStubbings());
+            // If stubbing was not found for invocation it means that either the mock invocation was
+            // not stubbed or
+            // we have a stubbing arg mismatch.
+            List<Invocation> argMismatchStubbings =
+                    potentialArgMismatches(event.getInvocation(), event.getAllStubbings());
             if (!argMismatchStubbings.isEmpty()) {
                 mismatchesReported = true;
                 Reporter.potentialStubbingProblem(event.getInvocation(), argMismatchStubbings);
             }
         } else {
-            //when strict stubs are in use, every time a stub is realized in the code it is implicitly marked as verified
-            //this way, the users don't have to repeat themselves to verify stubbed invocations (DRY)
+            // when strict stubs are in use, every time a stub is realized in the code it is
+            // implicitly marked as verified
+            // this way, the users don't have to repeat themselves to verify stubbed invocations
+            // (DRY)
             event.getInvocation().markVerified();
         }
     }
 
-    private static List<Invocation> potentialArgMismatches(Invocation invocation, Collection<Stubbing> stubbings) {
-        List<Invocation> matchingStubbings = new LinkedList<Invocation>();
+    private static List<Invocation> potentialArgMismatches(
+            Invocation invocation, Collection<Stubbing> stubbings) {
+        List<Invocation> matchingStubbings = new LinkedList<>();
         for (Stubbing s : stubbings) {
             if (UnusedStubbingReporting.shouldBeReported(s)
-                && s.getInvocation().getMethod().getName().equals(invocation.getMethod().getName())) {
+                    && s.getInvocation()
+                            .getMethod()
+                            .getName()
+                            .equals(invocation.getMethod().getName())
+                    // If stubbing and invocation are in the same source file we assume they are in
+                    // the test code,
+                    // and we don't flag it as mismatch:
+                    && !s.getInvocation()
+                            .getLocation()
+                            .getSourceFile()
+                            .equals(invocation.getLocation().getSourceFile())) {
                 matchingStubbings.add(s.getInvocation());
             }
         }
diff --git a/src/main/java/org/mockito/internal/junit/DefaultTestFinishedEvent.java b/src/main/java/org/mockito/internal/junit/DefaultTestFinishedEvent.java
index c3b348b..269ab9c 100644
--- a/src/main/java/org/mockito/internal/junit/DefaultTestFinishedEvent.java
+++ b/src/main/java/org/mockito/internal/junit/DefaultTestFinishedEvent.java
@@ -9,7 +9,8 @@ public class DefaultTestFinishedEvent implements TestFinishedEvent {
     private final String testMethodName;
     private final Throwable testFailure;
 
-    public DefaultTestFinishedEvent(Object testClassInstance, String testMethodName, Throwable testFailure) {
+    public DefaultTestFinishedEvent(
+            Object testClassInstance, String testMethodName, Throwable testFailure) {
         this.testClassInstance = testClassInstance;
         this.testMethodName = testMethodName;
         this.testFailure = testFailure;
diff --git a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
index 3664aea..7c5a841 100644
--- a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
+++ b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
@@ -4,49 +4,45 @@
  */
 package org.mockito.internal.junit;
 
-import junit.framework.ComparisonFailure;
 import org.mockito.exceptions.verification.ArgumentsAreDifferent;
 
 public class ExceptionFactory {
 
-    private final static boolean hasJUnit = canLoadJunitClass();
+    private ExceptionFactory() {}
 
-    private ExceptionFactory() {
+    private static interface ExceptionFactoryImpl {
+        AssertionError create(String message, String wanted, String actual);
     }
 
-    /**
-     * If JUnit is used, an AssertionError is returned that extends from JUnit {@link ComparisonFailure} and hence provide a better IDE support as the comparison result is comparable
-     */
-    public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual) {
-        if (hasJUnit) {
-            return createJUnitArgumentsAreDifferent(message, wanted, actual);
-        }
-        return new ArgumentsAreDifferent(message);
-    }
+    private static final ExceptionFactoryImpl factory;
 
-    private static AssertionError createJUnitArgumentsAreDifferent(String message, String wanted, String actual) {
-        return JUnitArgsAreDifferent.create(message, wanted, actual);
-    }
+    static {
+        ExceptionFactoryImpl theFactory = null;
 
-    private static boolean canLoadJunitClass() {
         try {
-            JUnitArgsAreDifferent.create("message", "wanted", "actual");
-        } catch (NoClassDefFoundError onlyIfJUnitIsNotAvailable) {
-            return false;
+            Class.forName("org.opentest4j.AssertionFailedError");
+            theFactory = org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent::new;
+        } catch (ClassNotFoundException onlyIfOpenTestIsNotAvailable) {
+            try {
+                Class.forName("junit.framework.ComparisonFailure");
+                theFactory = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent::new;
+            } catch (ClassNotFoundException onlyIfJUnitIsNotAvailable) {
+            }
         }
-        return true;
+        factory = (theFactory == null) ? ArgumentsAreDifferent::new : theFactory;
     }
 
     /**
-     * Don't inline this class! It allows create the JUnit-ArgumentsAreDifferent exception without the need to use reflection.
-     * <p>
-     * If JUnit is not available a call to {@link #create(String, String, String)} will throw a {@link NoClassDefFoundError}.
-     * The {@link NoClassDefFoundError} will be thrown by the class loader cause the JUnit class {@link ComparisonFailure}
-     * can't be loaded which is a upper class of ArgumentsAreDifferent.
+     * Returns an AssertionError that describes the fact that the arguments of an invocation are different.
+     * If {@link org.opentest4j.AssertionFailedError} is on the class path (used by JUnit 5 and others),
+     * it returns a class that extends it. Otherwise, if {@link junit.framework.ComparisonFailure} is on the
+     * class path (shipped with JUnit 3 and 4), it will return a class that extends that. This provides
+     * better IDE support as the comparison result can be opened in a visual diff. If neither are available,
+     * it returns an instance of
+     * {@link org.mockito.exceptions.verification.ArgumentsAreDifferent}.
      */
-    private static class JUnitArgsAreDifferent {
-        static AssertionError create(String message, String wanted, String actual) {
-            return new org.mockito.exceptions.verification.junit.ArgumentsAreDifferent(message, wanted, actual);
-        }
+    public static AssertionError createArgumentsAreDifferentException(
+            String message, String wanted, String actual) {
+        return factory.create(message, wanted, actual);
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/JUnitRule.java b/src/main/java/org/mockito/internal/junit/JUnitRule.java
index b825416..0439f98 100644
--- a/src/main/java/org/mockito/internal/junit/JUnitRule.java
+++ b/src/main/java/org/mockito/internal/junit/JUnitRule.java
@@ -6,69 +6,35 @@ package org.mockito.internal.junit;
 
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.Statement;
-import org.mockito.Mockito;
-import org.mockito.MockitoSession;
-import org.mockito.internal.session.MockitoSessionLoggerAdapter;
-import org.mockito.internal.util.MockitoLogger;
-import org.mockito.quality.Strictness;
 import org.mockito.junit.MockitoRule;
+import org.mockito.plugins.MockitoLogger;
+import org.mockito.quality.Strictness;
 
-/**
- * Internal implementation.
- */
-public class JUnitRule implements MockitoRule {
+/** Internal implementation. */
+public final class JUnitRule implements MockitoRule {
 
-    private final MockitoLogger logger;
-    private Strictness strictness;
-    private MockitoSession session;
+    private final JUnitSessionStore sessionStore;
 
-    /**
-     * @param strictness how strict mocking / stubbing is concerned
-     */
+    /** @param strictness how strict mocking / stubbing is concerned */
     public JUnitRule(MockitoLogger logger, Strictness strictness) {
-        this.logger = logger;
-        this.strictness = strictness;
+        this.sessionStore = new JUnitSessionStore(logger, strictness);
     }
 
-	@Override
-	public Statement apply(final Statement base, final FrameworkMethod method, final Object target) {
-        return new Statement() {
-            public void evaluate() throws Throwable {
-                session = Mockito.mockitoSession()
-                    .name(target.getClass().getSimpleName() + "." + method.getName())
-                    .strictness(strictness)
-                    .logger(new MockitoSessionLoggerAdapter(logger))
-                    .initMocks(target)
-                    .startMocking();
-                Throwable testFailure = evaluateSafely(base);
-                session.finishMocking(testFailure);
-                if (testFailure != null) {
-                    throw testFailure;
-                }
-            }
-
-            private Throwable evaluateSafely(Statement base) {
-                try {
-                    base.evaluate();
-                    return null;
-                } catch (Throwable throwable) {
-                    return throwable;
-                }
-            }
-        };
+    @Override
+    public Statement apply(
+            final Statement base, final FrameworkMethod method, final Object target) {
+        return sessionStore.createStatement(
+                base, target.getClass().getSimpleName() + "." + method.getName(), target);
     }
 
+    @Override
     public MockitoRule silent() {
         return strictness(Strictness.LENIENT);
     }
 
+    @Override
     public MockitoRule strictness(Strictness strictness) {
-        this.strictness = strictness;
-        // session is null when this method is called during initialization of
-        // the @Rule field of the test class
-        if (session != null) {
-            session.setStrictness(strictness);
-        }
+        sessionStore.setStrictness(strictness);
         return this;
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/JUnitSessionStore.java b/src/main/java/org/mockito/internal/junit/JUnitSessionStore.java
new file mode 100644
index 0000000..5aa1557
--- /dev/null
+++ b/src/main/java/org/mockito/internal/junit/JUnitSessionStore.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.junit;
+
+import org.junit.runners.model.Statement;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.internal.session.MockitoSessionLoggerAdapter;
+import org.mockito.plugins.MockitoLogger;
+import org.mockito.quality.Strictness;
+
+class JUnitSessionStore {
+
+    private final MockitoLogger logger;
+    private MockitoSession session;
+    protected Strictness strictness;
+
+    JUnitSessionStore(MockitoLogger logger, Strictness strictness) {
+        this.logger = logger;
+        this.strictness = strictness;
+    }
+
+    Statement createStatement(final Statement base, final String methodName, final Object target) {
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                AutoCloseable closeable;
+                if (session == null) {
+                    session =
+                            Mockito.mockitoSession()
+                                    .name(methodName)
+                                    .strictness(strictness)
+                                    .logger(new MockitoSessionLoggerAdapter(logger))
+                                    .initMocks(target)
+                                    .startMocking();
+                    closeable = null;
+                } else {
+                    closeable = MockitoAnnotations.openMocks(target);
+                }
+                Throwable testFailure = evaluateSafely(base);
+                session.finishMocking(testFailure);
+                if (closeable != null) {
+                    closeable.close();
+                }
+                if (testFailure != null) {
+                    throw testFailure;
+                }
+            }
+
+            private Throwable evaluateSafely(Statement base) {
+                try {
+                    base.evaluate();
+                    return null;
+                } catch (Throwable throwable) {
+                    return throwable;
+                }
+            }
+        };
+    }
+
+    void setStrictness(Strictness strictness) {
+        this.strictness = strictness;
+        // session is null when this method is called during initialization of
+        // the @Rule field of the test class
+        if (session != null) {
+            session.setStrictness(strictness);
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/junit/JUnitTestRule.java b/src/main/java/org/mockito/internal/junit/JUnitTestRule.java
new file mode 100644
index 0000000..3cbf2c6
--- /dev/null
+++ b/src/main/java/org/mockito/internal/junit/JUnitTestRule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.junit;
+
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.mockito.junit.MockitoTestRule;
+import org.mockito.plugins.MockitoLogger;
+import org.mockito.quality.Strictness;
+
+public final class JUnitTestRule implements MockitoTestRule {
+
+    private final Object testInstance;
+    private final JUnitSessionStore sessionStore;
+
+    public JUnitTestRule(MockitoLogger logger, Strictness strictness, Object testInstance) {
+        this.sessionStore = new JUnitSessionStore(logger, strictness);
+        this.testInstance = testInstance;
+    }
+
+    @Override
+    public Statement apply(Statement base, Description description) {
+        return sessionStore.createStatement(base, description.getDisplayName(), this.testInstance);
+    }
+
+    @Override
+    public MockitoTestRule silent() {
+        return strictness(Strictness.LENIENT);
+    }
+
+    @Override
+    public MockitoTestRule strictness(Strictness strictness) {
+        sessionStore.setStrictness(strictness);
+        return this;
+    }
+}
diff --git a/src/main/java/org/mockito/internal/junit/MismatchReportingTestListener.java b/src/main/java/org/mockito/internal/junit/MismatchReportingTestListener.java
index 26d4e4e..ec877b5 100644
--- a/src/main/java/org/mockito/internal/junit/MismatchReportingTestListener.java
+++ b/src/main/java/org/mockito/internal/junit/MismatchReportingTestListener.java
@@ -4,37 +4,44 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.util.MockitoLogger;
-import org.mockito.mock.MockCreationSettings;
-
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.MockitoLogger;
+
 /**
  * Reports stubbing argument mismatches to the supplied logger
  */
 public class MismatchReportingTestListener implements MockitoTestListener {
 
     private final MockitoLogger logger;
-    private List<Object> mocks = new LinkedList<Object>();
+    private List<Object> mocks = new LinkedList<>();
 
     public MismatchReportingTestListener(MockitoLogger logger) {
         this.logger = logger;
     }
 
+    @Override
     public void testFinished(TestFinishedEvent event) {
         Collection<Object> createdMocks = mocks;
-        //At this point, we don't need the mocks any more and we can mark all collected mocks for gc
-        //TODO make it better, it's easy to forget to clean up mocks and we still create new instance of list that nobody will read, it's also duplicated
-        mocks = new LinkedList<Object>();
+        // At this point, we don't need the mocks any more and we can mark all collected mocks for
+        // gc
+        // TODO make it better, it's easy to forget to clean up mocks and we still create new
+        // instance of list that nobody will read, it's also duplicated
+        mocks = new LinkedList<>();
 
         if (event.getFailure() != null) {
-            //print unused stubbings only when test succeeds to avoid reporting multiple problems and confusing users
-            new ArgMismatchFinder().getStubbingArgMismatches(createdMocks).format(event.getTestName(), logger);
+            // print unused stubbings only when test succeeds to avoid reporting multiple problems
+            // and confusing users
+            new ArgMismatchFinder()
+                    .getStubbingArgMismatches(createdMocks)
+                    .format(event.getTestName(), logger);
         }
     }
 
+    @Override
     public void onMockCreated(Object mock, MockCreationSettings settings) {
         this.mocks.add(mock);
     }
diff --git a/src/main/java/org/mockito/internal/junit/NoOpTestListener.java b/src/main/java/org/mockito/internal/junit/NoOpTestListener.java
index f6eea7e..77c7d4e 100644
--- a/src/main/java/org/mockito/internal/junit/NoOpTestListener.java
+++ b/src/main/java/org/mockito/internal/junit/NoOpTestListener.java
@@ -8,7 +8,9 @@ import org.mockito.mock.MockCreationSettings;
 
 public class NoOpTestListener implements MockitoTestListener {
 
+    @Override
     public void testFinished(TestFinishedEvent event) {}
 
+    @Override
     public void onMockCreated(Object mock, MockCreationSettings settings) {}
 }
diff --git a/src/main/java/org/mockito/internal/junit/StrictStubsRunnerTestListener.java b/src/main/java/org/mockito/internal/junit/StrictStubsRunnerTestListener.java
index 9e60c31..8d6cc6c 100644
--- a/src/main/java/org/mockito/internal/junit/StrictStubsRunnerTestListener.java
+++ b/src/main/java/org/mockito/internal/junit/StrictStubsRunnerTestListener.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.quality.Strictness;
 
@@ -13,17 +12,18 @@ import org.mockito.quality.Strictness;
  */
 public class StrictStubsRunnerTestListener implements MockitoTestListener {
 
-    private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
+    private final DefaultStubbingLookupListener stubbingLookupListener =
+            new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
 
     @Override
     public void testFinished(TestFinishedEvent event) {}
 
     @Override
     public void onMockCreated(Object mock, MockCreationSettings settings) {
-        //It is not ideal that we modify the state of MockCreationSettings object
-        //MockCreationSettings is intended to be an immutable view of the creation settings
-        //In future, we should start passing MockSettings object to the creation listener
-        //TODO #793 - when completed, we should be able to get rid of the CreationSettings casting below
-        ((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
+        // It is not ideal that we modify the state of MockCreationSettings object
+        // MockCreationSettings is intended to be an immutable view of the creation settings
+        // However, we our previous listeners work this way and it hasn't backfired.
+        // Since it is simple and pragmatic, we'll keep it for now.
+        settings.getStubbingLookupListeners().add(stubbingLookupListener);
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/StubbingArgMismatches.java b/src/main/java/org/mockito/internal/junit/StubbingArgMismatches.java
index 3d6342c..3fb3bad 100644
--- a/src/main/java/org/mockito/internal/junit/StubbingArgMismatches.java
+++ b/src/main/java/org/mockito/internal/junit/StubbingArgMismatches.java
@@ -4,27 +4,25 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.util.MockitoLogger;
-import org.mockito.invocation.Invocation;
-
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
+import org.mockito.invocation.Invocation;
+import org.mockito.plugins.MockitoLogger;
+
 /**
  * Contains stubbing arg mismatches, knows how to format them
  */
 class StubbingArgMismatches {
 
-    final Map<Invocation, Set<Invocation>> mismatches = new LinkedHashMap<Invocation, Set<Invocation>>();
+    final Map<Invocation, Set<Invocation>> mismatches = new LinkedHashMap<>();
 
     public void add(Invocation invocation, Invocation stubbing) {
-        Set<Invocation> matchingInvocations = mismatches.get(stubbing);
-        if (matchingInvocations == null) {
-            matchingInvocations = new LinkedHashSet<Invocation>();
-            mismatches.put(stubbing, matchingInvocations);
-        }
+        Set<Invocation> matchingInvocations =
+                mismatches.computeIfAbsent(
+                        stubbing, (Invocation k) -> new LinkedHashSet<Invocation>());
         matchingInvocations.add(invocation);
     }
 
@@ -49,6 +47,7 @@ class StubbingArgMismatches {
         return mismatches.size();
     }
 
+    @Override
     public String toString() {
         return "" + mismatches;
     }
diff --git a/src/main/java/org/mockito/internal/junit/StubbingHint.java b/src/main/java/org/mockito/internal/junit/StubbingHint.java
index 3675a4d..2710425 100644
--- a/src/main/java/org/mockito/internal/junit/StubbingHint.java
+++ b/src/main/java/org/mockito/internal/junit/StubbingHint.java
@@ -12,18 +12,21 @@ class StubbingHint {
     private final StringBuilder hint;
 
     StubbingHint(String testName) {
-        hint = new StringBuilder("[MockitoHint] ")
-            .append(testName).append(" (see javadoc for MockitoHint):");
+        hint =
+                new StringBuilder("[MockitoHint] ")
+                        .append(testName)
+                        .append(" (see javadoc for MockitoHint):");
     }
 
-    void appendLine(Object ... elements) {
+    void appendLine(Object... elements) {
         hint.append("\n[MockitoHint] ");
         for (Object e : elements) {
             hint.append(e);
         }
     }
 
+    @Override
     public String toString() {
-        return hint.toString() + "\n";
+        return hint + "\n";
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java b/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java
index 43b373a..a2c10cf 100644
--- a/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java
+++ b/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java
@@ -9,5 +9,4 @@ public interface TestFinishedEvent {
     Throwable getFailure();
 
     String getTestName();
-
 }
diff --git a/src/main/java/org/mockito/internal/junit/UniversalTestListener.java b/src/main/java/org/mockito/internal/junit/UniversalTestListener.java
index f670c64..72e3c09 100644
--- a/src/main/java/org/mockito/internal/junit/UniversalTestListener.java
+++ b/src/main/java/org/mockito/internal/junit/UniversalTestListener.java
@@ -4,16 +4,14 @@
  */
 package org.mockito.internal.junit;
 
+import java.util.Collection;
+import java.util.IdentityHashMap;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.listeners.AutoCleanableListener;
-import org.mockito.internal.util.MockitoLogger;
 import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.quality.Strictness;
 
-import java.util.Collection;
-import java.util.IdentityHashMap;
-import java.util.Map;
-
 /**
  * Universal test listener that behaves accordingly to current setting of strictness.
  * Will come handy when we offer tweaking strictness at the method level with annotation.
@@ -24,51 +22,67 @@ public class UniversalTestListener implements MockitoTestListener, AutoCleanable
     private Strictness currentStrictness;
     private final MockitoLogger logger;
 
-    private Map<Object, MockCreationSettings> mocks = new IdentityHashMap<Object, MockCreationSettings>();
-    private DefaultStubbingLookupListener stubbingLookupListener;
+    private IdentityHashMap mocks = new IdentityHashMap<Object, MockCreationSettings>();
+    private final DefaultStubbingLookupListener stubbingLookupListener;
     private boolean listenerDirty;
 
     public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
         this.currentStrictness = initialStrictness;
         this.logger = logger;
 
-        //creating single stubbing lookup listener per junit rule instance / test method
-        //this way, when strictness is updated in the middle of the test it will affect the behavior of the stubbing listener
+        // creating single stubbing lookup listener per junit rule instance / test method
+        // this way, when strictness is updated in the middle of the test it will affect the
+        // behavior of the stubbing listener
         this.stubbingLookupListener = new DefaultStubbingLookupListener(currentStrictness);
     }
 
     @Override
     public void testFinished(TestFinishedEvent event) {
         Collection<Object> createdMocks = mocks.keySet();
-        //At this point, we don't need the mocks any more and we can mark all collected mocks for gc
-        //TODO make it better, it's easy to forget to clean up mocks and we still create new instance of list that nobody will read, it's also duplicated
-        //TODO clean up all other state, null out stubbingLookupListener
-        mocks = new IdentityHashMap<Object, MockCreationSettings>();
+        // At this point, we don't need the mocks any more and we can mark all collected mocks for
+        // gc
+        // TODO make it better, it's easy to forget to clean up mocks and we still create new
+        // instance of list that nobody will read, it's also duplicated
+        // TODO clean up all other state, null out stubbingLookupListener
+        mocks = new IdentityHashMap<>();
 
         switch (currentStrictness) {
-            case WARN: emitWarnings(logger, event, createdMocks); break;
-            case STRICT_STUBS: reportUnusedStubs(event, createdMocks); break;
-            case LENIENT: break;
-            default: throw new IllegalStateException("Unknown strictness: " + currentStrictness);
+            case WARN:
+                emitWarnings(logger, event, createdMocks);
+                break;
+            case STRICT_STUBS:
+                reportUnusedStubs(event, createdMocks);
+                break;
+            case LENIENT:
+                break;
+            default:
+                throw new IllegalStateException("Unknown strictness: " + currentStrictness);
         }
     }
 
     private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
-        //If there is some other failure (or mismatches were detected) don't report another exception to avoid confusion
+        // If there is some other failure (or mismatches were detected) don't report another
+        // exception to avoid confusion
         if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
             UnusedStubbings unused = new UnusedStubbingsFinder().getUnusedStubbings(mocks);
             unused.reportUnused();
         }
     }
 
-    private static void emitWarnings(MockitoLogger logger, TestFinishedEvent event, Collection<Object> mocks) {
+    private static void emitWarnings(
+            MockitoLogger logger, TestFinishedEvent event, Collection<Object> mocks) {
         if (event.getFailure() != null) {
-            //print stubbing mismatches only when there is a test failure
-            //to avoid false negatives. Give hint only when test fails.
-            new ArgMismatchFinder().getStubbingArgMismatches(mocks).format(event.getTestName(), logger);
+            // print stubbing mismatches only when there is a test failure
+            // to avoid false negatives. Give hint only when test fails.
+            new ArgMismatchFinder()
+                    .getStubbingArgMismatches(mocks)
+                    .format(event.getTestName(), logger);
         } else {
-            //print unused stubbings only when test succeeds to avoid reporting multiple problems and confusing users
-            new UnusedStubbingsFinder().getUnusedStubbings(mocks).format(event.getTestName(), logger);
+            // print unused stubbings only when test succeeds to avoid reporting multiple problems
+            // and confusing users
+            new UnusedStubbingsFinder()
+                    .getUnusedStubbings(mocks)
+                    .format(event.getTestName(), logger);
         }
     }
 
@@ -76,10 +90,11 @@ public class UniversalTestListener implements MockitoTestListener, AutoCleanable
     public void onMockCreated(Object mock, MockCreationSettings settings) {
         this.mocks.put(mock, settings);
 
-        //It is not ideal that we modify the state of MockCreationSettings object
-        //MockCreationSettings is intended to be an immutable view of the creation settings
-        //In future, we should start passing MockSettings object to the creation listener
-        //TODO #793 - when completed, we should be able to get rid of the CreationSettings casting below
+        // It is not ideal that we modify the state of MockCreationSettings object
+        // MockCreationSettings is intended to be an immutable view of the creation settings
+        // In future, we should start passing MockSettings object to the creation listener
+        // TODO #793 - when completed, we should be able to get rid of the CreationSettings casting
+        // below
         ((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
     }
 
diff --git a/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java b/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java
index c5a8afe..2ba1fb9 100644
--- a/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java
+++ b/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.junit;
 
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.runner.Description;
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
@@ -12,27 +16,27 @@ import org.mockito.invocation.Invocation;
 import org.mockito.listeners.MockCreationListener;
 import org.mockito.mock.MockCreationSettings;
 
-import java.util.Collection;
-import java.util.LinkedList;
-import java.util.List;
-
 /**
  * Reports unnecessary stubbings
  */
 public class UnnecessaryStubbingsReporter implements MockCreationListener {
 
-    private List<Object> mocks = new LinkedList<Object>();
+    private final List<Object> mocks = new LinkedList<Object>();
 
     public void validateUnusedStubs(Class<?> testClass, RunNotifier notifier) {
-        Collection<Invocation> unused = new UnusedStubbingsFinder().getUnusedStubbingsByLocation(mocks);
+        Collection<Invocation> unused =
+                new UnusedStubbingsFinder().getUnusedStubbingsByLocation(mocks);
         if (unused.isEmpty()) {
-            return; //whoa!!! All stubbings were used!
+            return; // whoa!!! All stubbings were used!
         }
 
-        //Oups, there are unused stubbings
-        Description unnecessaryStubbings = Description.createTestDescription(testClass, "unnecessary Mockito stubbings");
-        notifier.fireTestFailure(new Failure(unnecessaryStubbings,
-                Reporter.formatUnncessaryStubbingException(testClass, unused)));
+        // Oups, there are unused stubbings
+        Description unnecessaryStubbings =
+                Description.createTestDescription(testClass, "unnecessary Mockito stubbings");
+        notifier.fireTestFailure(
+                new Failure(
+                        unnecessaryStubbings,
+                        Reporter.formatUnncessaryStubbingException(testClass, unused)));
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbings.java b/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
index 3505d2c..4c4fbf9 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.exceptions.Reporter;
-import org.mockito.internal.util.MockitoLogger;
-import org.mockito.invocation.Invocation;
-import org.mockito.stubbing.Stubbing;
-
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.internal.exceptions.Reporter;
+import org.mockito.invocation.Invocation;
+import org.mockito.plugins.MockitoLogger;
+import org.mockito.stubbing.Stubbing;
+
 /**
  * Contains unused stubbings, knows how to format them
  */
@@ -43,6 +43,7 @@ public class UnusedStubbings {
         return unused.size();
     }
 
+    @Override
     public String toString() {
         return unused.toString();
     }
@@ -52,7 +53,7 @@ public class UnusedStubbings {
             return;
         }
 
-        List<Invocation> invocations = new LinkedList<Invocation>();
+        List<Invocation> invocations = new LinkedList<>();
         for (Stubbing stubbing : unused) {
             invocations.add(stubbing.getInvocation());
         }
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
index 14c61c5..c7fd12a 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
@@ -4,11 +4,7 @@
  */
 package org.mockito.internal.junit;
 
-import org.mockito.internal.invocation.finder.AllInvocationsFinder;
-import org.mockito.internal.stubbing.UnusedStubbingReporting;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-import org.mockito.invocation.Invocation;
-import org.mockito.stubbing.Stubbing;
+import static org.mockito.internal.util.collections.ListUtil.filter;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -17,7 +13,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import static org.mockito.internal.util.collections.ListUtil.filter;
+import org.mockito.internal.invocation.finder.AllInvocationsFinder;
+import org.mockito.internal.stubbing.UnusedStubbingReporting;
+import org.mockito.internal.util.collections.ListUtil.Filter;
+import org.mockito.invocation.Invocation;
+import org.mockito.stubbing.Stubbing;
 
 /**
  * Finds unused stubbings
@@ -31,11 +31,15 @@ public class UnusedStubbingsFinder {
     public UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
         Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
 
-        List<Stubbing> unused = filter(stubbings, new Filter<Stubbing>() {
-            public boolean isOut(Stubbing s) {
-                return !UnusedStubbingReporting.shouldBeReported(s);
-            }
-        });
+        List<Stubbing> unused =
+                filter(
+                        stubbings,
+                        new Filter<Stubbing>() {
+                            @Override
+                            public boolean isOut(Stubbing s) {
+                                return !UnusedStubbingReporting.shouldBeReported(s);
+                            }
+                        });
 
         return new UnusedStubbings(unused);
     }
@@ -53,9 +57,9 @@ public class UnusedStubbingsFinder {
     public Collection<Invocation> getUnusedStubbingsByLocation(Iterable<Object> mocks) {
         Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
 
-        //1st pass, collect all the locations of the stubbings that were used
-        //note that those are _not_ locations where the stubbings was used
-        Set<String> locationsOfUsedStubbings = new HashSet<String>();
+        // 1st pass, collect all the locations of the stubbings that were used
+        // note that those are _not_ locations where the stubbings was used
+        Set<String> locationsOfUsedStubbings = new HashSet<>();
         for (Stubbing s : stubbings) {
             if (!UnusedStubbingReporting.shouldBeReported(s)) {
                 String location = s.getInvocation().getLocation().toString();
@@ -63,11 +67,12 @@ public class UnusedStubbingsFinder {
             }
         }
 
-        //2nd pass, collect unused stubbings by location
-        //If the location matches we assume the stubbing was used in at least one test method
-        //Also, using map to deduplicate reported unused stubbings
-        // if unused stubbing appear in the setup method / constructor we don't want to report it per each test case
-        Map<String, Invocation> out = new LinkedHashMap<String, Invocation>();
+        // 2nd pass, collect unused stubbings by location
+        // If the location matches we assume the stubbing was used in at least one test method
+        // Also, using map to deduplicate reported unused stubbings
+        // if unused stubbing appear in the setup method / constructor we don't want to report it
+        // per each test case
+        Map<String, Invocation> out = new LinkedHashMap<>();
         for (Stubbing s : stubbings) {
             String location = s.getInvocation().getLocation().toString();
             if (!locationsOfUsedStubbings.contains(location)) {
diff --git a/src/main/java/org/mockito/internal/junit/VerificationCollectorImpl.java b/src/main/java/org/mockito/internal/junit/VerificationCollectorImpl.java
index 7c19d35..dcb4d16 100644
--- a/src/main/java/org/mockito/internal/junit/VerificationCollectorImpl.java
+++ b/src/main/java/org/mockito/internal/junit/VerificationCollectorImpl.java
@@ -27,6 +27,7 @@ public class VerificationCollectorImpl implements VerificationCollector {
         this.resetBuilder();
     }
 
+    @Override
     public Statement apply(final Statement base, final Description description) {
         return new Statement() {
             @Override
@@ -36,16 +37,20 @@ public class VerificationCollectorImpl implements VerificationCollector {
                     base.evaluate();
                     VerificationCollectorImpl.this.collectAndReport();
                 } finally {
-                    // If base.evaluate() throws an error, we must explicitly reset the VerificationStrategy
+                    // If base.evaluate() throws an error, we must explicitly reset the
+                    // VerificationStrategy
                     // to prevent subsequent tests to be assert lazily
-                    mockingProgress().setVerificationStrategy(MockingProgressImpl.getDefaultVerificationStrategy());
+                    mockingProgress()
+                            .setVerificationStrategy(
+                                    MockingProgressImpl.getDefaultVerificationStrategy());
                 }
             }
         };
     }
 
     public void collectAndReport() throws MockitoAssertionError {
-        mockingProgress().setVerificationStrategy(MockingProgressImpl.getDefaultVerificationStrategy());
+        mockingProgress()
+                .setVerificationStrategy(MockingProgressImpl.getDefaultVerificationStrategy());
 
         if (this.numberOfFailures > 0) {
             String error = this.builder.toString();
@@ -56,26 +61,32 @@ public class VerificationCollectorImpl implements VerificationCollector {
         }
     }
 
+    @Override
     public VerificationCollector assertLazily() {
-        mockingProgress().setVerificationStrategy(new VerificationStrategy() {
-            public VerificationMode maybeVerifyLazily(VerificationMode mode) {
-                return new VerificationWrapper(mode);
-            }
-        });
+        mockingProgress()
+                .setVerificationStrategy(
+                        new VerificationStrategy() {
+                            @Override
+                            public VerificationMode maybeVerifyLazily(VerificationMode mode) {
+                                return new VerificationWrapper(mode);
+                            }
+                        });
         return this;
     }
 
     private void resetBuilder() {
-        this.builder = new StringBuilder()
-                .append("There were multiple verification failures:");
+        this.builder = new StringBuilder().append("There were multiple verification failures:");
         this.numberOfFailures = 0;
     }
 
     private void append(String message) {
         this.numberOfFailures++;
-        this.builder.append('\n')
-                .append(this.numberOfFailures).append(". ")
-                .append(message.substring(1, message.length()));
+        this.builder
+                .append('\n')
+                .append(this.numberOfFailures)
+                .append(". ")
+                .append(message.trim())
+                .append('\n');
     }
 
     private class VerificationWrapper implements VerificationMode {
@@ -86,17 +97,18 @@ public class VerificationCollectorImpl implements VerificationCollector {
             this.delegate = delegate;
         }
 
+        @Override
         public void verify(VerificationData data) {
             try {
                 this.delegate.verify(data);
-            } catch (MockitoAssertionError error) {
+            } catch (AssertionError error) {
                 VerificationCollectorImpl.this.append(error.getMessage());
             }
         }
 
+        @Override
         public VerificationMode description(String description) {
             throw new IllegalStateException("Should not fail in this mode");
         }
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/junit/util/JUnitFailureHacker.java b/src/main/java/org/mockito/internal/junit/util/JUnitFailureHacker.java
deleted file mode 100644
index 393867b..0000000
--- a/src/main/java/org/mockito/internal/junit/util/JUnitFailureHacker.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.junit.util;
-
-import java.lang.reflect.Field;
-import org.junit.runner.notification.Failure;
-import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;
-
-@Deprecated
-public class JUnitFailureHacker {
-
-    public void appendWarnings(Failure failure, String warnings) {
-        if (isEmpty(warnings)) {
-            return;
-        }
-        //TODO: this has to protect the use in case jUnit changes and this internal state logic fails
-        Throwable throwable = (Throwable) getInternalState(failure, "fThrownException");
-
-        String newMessage = "contains both: actual test failure *and* Mockito warnings.\n" +
-                warnings + "\n *** The actual failure is because of: ***\n";
-
-        ExceptionIncludingMockitoWarnings e = new ExceptionIncludingMockitoWarnings(newMessage, throwable);
-        e.setStackTrace(throwable.getStackTrace());
-        setInternalState(failure, "fThrownException", e);
-    }
-
-    private boolean isEmpty(String warnings) {
-        return warnings == null || "".equals(warnings); // isEmpty() is in JDK 6+
-    }
-
-    private static Object getInternalState(Object target, String field) {
-        Class<?> c = target.getClass();
-        try {
-            Field f = getFieldFromHierarchy(c, field);
-            f.setAccessible(true);
-            return f.get(target);
-        } catch (Exception e) {
-            throw new RuntimeException("Unable to get internal state on a private field. Please report to mockito mailing list.", e);
-        }
-    }
-
-    private static void setInternalState(Object target, String field, Object value) {
-        Class<?> c = target.getClass();
-        try {
-            Field f = getFieldFromHierarchy(c, field);
-            f.setAccessible(true);
-            f.set(target, value);
-        } catch (Exception e) {
-            throw new RuntimeException("Unable to set internal state on a private field. Please report to mockito mailing list.", e);
-        }
-    }
-
-    private static Field getFieldFromHierarchy(Class<?> clazz, String field) {
-        Field f = getField(clazz, field);
-        while (f == null && clazz != Object.class) {
-            clazz = clazz.getSuperclass();
-            f = getField(clazz, field);
-        }
-        if (f == null) {
-            throw new RuntimeException(
-                    "You want me to get this field: '" + field +
-                            "' on this class: '" + clazz.getSimpleName() +
-                            "' but this field is not declared within the hierarchy of this class!");
-        }
-        return f;
-    }
-
-    private static Field getField(Class<?> clazz, String field) {
-        try {
-            return clazz.getDeclaredField(field);
-        } catch (NoSuchFieldException e) {
-            return null;
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/listeners/StubbingLookupListener.java b/src/main/java/org/mockito/internal/listeners/StubbingLookupListener.java
deleted file mode 100644
index 6fa37a1..0000000
--- a/src/main/java/org/mockito/internal/listeners/StubbingLookupListener.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2017 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.listeners;
-
-/**
- * Listens to attempts to look up stubbing answer for given mocks. This class is internal for now.
- * <p>
- * How does it work?
- * When method is called on the mock object, Mockito looks for any answer (stubbing) declared on that mock.
- * If the stubbed answer is found, that answer is invoked (value returned, thrown exception, etc.).
- * If the answer is not found (e.g. that invocation was not stubbed on the mock), mock's default answer is used.
- * This listener implementation is notified when Mockito looked up an answer for invocation on a mock.
- * <p>
- * If we make this interface a part of public API (and we should):
- *  - make the implementation unified with InvocationListener (for example: common parent, marker interface MockObjectListener
- *  single method for adding listeners so long they inherit from the parent)
- *  - make the error handling strict
- * so that Mockito provides decent message when listener fails due to poor implementation.
- */
-public interface StubbingLookupListener {
-
-    /**
-     * Called by the framework when Mockito looked up an answer for invocation on a mock.
-     *
-     * @param stubbingLookupEvent - Information about the looked up stubbing
-     */
-    void onStubbingLookup(StubbingLookupEvent stubbingLookupEvent);
-}
diff --git a/src/main/java/org/mockito/internal/listeners/StubbingLookupNotifier.java b/src/main/java/org/mockito/internal/listeners/StubbingLookupNotifier.java
index 3e55001..5331628 100644
--- a/src/main/java/org/mockito/internal/listeners/StubbingLookupNotifier.java
+++ b/src/main/java/org/mockito/internal/listeners/StubbingLookupNotifier.java
@@ -4,38 +4,45 @@
  */
 package org.mockito.internal.listeners;
 
+import java.util.Collection;
+import java.util.List;
+
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.invocation.Invocation;
+import org.mockito.listeners.StubbingLookupEvent;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Collection;
-import java.util.List;
-
-public class StubbingLookupNotifier {
+public final class StubbingLookupNotifier {
 
-    public static void notifyStubbedAnswerLookup(Invocation invocation, Stubbing stubbingFound,
-                                                 Collection<Stubbing> allStubbings, CreationSettings creationSettings) {
+    public static void notifyStubbedAnswerLookup(
+            Invocation invocation,
+            Stubbing stubbingFound,
+            Collection<Stubbing> allStubbings,
+            CreationSettings creationSettings) {
         List<StubbingLookupListener> listeners = creationSettings.getStubbingLookupListeners();
         if (listeners.isEmpty()) {
             return;
         }
-        StubbingLookupEvent event = new Event(invocation, stubbingFound, allStubbings, creationSettings);
+        StubbingLookupEvent event =
+                new Event(invocation, stubbingFound, allStubbings, creationSettings);
         for (StubbingLookupListener listener : listeners) {
             listener.onStubbingLookup(event);
         }
     }
 
     static class Event implements StubbingLookupEvent {
-        final private Invocation invocation;
-        final private Stubbing stubbing;
-        final private Collection<Stubbing> allStubbings;
-        final private MockCreationSettings mockSettings;
+        private final Invocation invocation;
+        private final Stubbing stubbing;
+        private final Collection<Stubbing> allStubbings;
+        private final MockCreationSettings mockSettings;
 
-        public Event(Invocation invocation,
-                     Stubbing stubbing,
-                     Collection<Stubbing> allStubbings,
-                     MockCreationSettings mockSettings) {
+        public Event(
+                Invocation invocation,
+                Stubbing stubbing,
+                Collection<Stubbing> allStubbings,
+                MockCreationSettings mockSettings) {
             this.invocation = invocation;
             this.stubbing = stubbing;
             this.allStubbings = allStubbings;
@@ -62,4 +69,6 @@ public class StubbingLookupNotifier {
             return mockSettings;
         }
     }
+
+    private StubbingLookupNotifier() {}
 }
diff --git a/src/main/java/org/mockito/internal/listeners/VerificationStartedNotifier.java b/src/main/java/org/mockito/internal/listeners/VerificationStartedNotifier.java
index 0292db0..9a5a890 100644
--- a/src/main/java/org/mockito/internal/listeners/VerificationStartedNotifier.java
+++ b/src/main/java/org/mockito/internal/listeners/VerificationStartedNotifier.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.internal.listeners;
 
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.MockingDetails;
 import org.mockito.Mockito;
 import org.mockito.internal.exceptions.Reporter;
@@ -12,12 +15,10 @@ import org.mockito.listeners.VerificationStartedEvent;
 import org.mockito.listeners.VerificationStartedListener;
 import org.mockito.mock.MockCreationSettings;
 
-import java.util.List;
-import java.util.Set;
-
-public class VerificationStartedNotifier {
+public final class VerificationStartedNotifier {
 
-    public static Object notifyVerificationStarted(List<VerificationStartedListener> listeners, MockingDetails originalMockingDetails) {
+    public static Object notifyVerificationStarted(
+            List<VerificationStartedListener> listeners, MockingDetails originalMockingDetails) {
         if (listeners.isEmpty()) {
             return originalMockingDetails.getMock();
         }
@@ -37,20 +38,28 @@ public class VerificationStartedNotifier {
             this.mock = originalMockingDetails.getMock();
         }
 
+        @Override
         public void setMock(Object mock) {
             if (mock == null) {
-                throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "null parameter.");
+                throw Reporter.methodDoesNotAcceptParameter(
+                        "VerificationStartedEvent.setMock", "null parameter.");
             }
             MockingDetails mockingDetails = Mockito.mockingDetails(mock);
             if (!mockingDetails.isMock()) {
-                throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "parameter which is not a Mockito mock.\n" +
-                    "  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
+                throw Reporter.methodDoesNotAcceptParameter(
+                        "VerificationStartedEvent.setMock",
+                        "parameter which is not a Mockito mock.\n"
+                                + "  Received parameter: "
+                                + ValuePrinter.print(mock)
+                                + ".\n ");
             }
-            MockCreationSettings originalMockSettings = this.originalMockingDetails.getMockCreationSettings();
+            MockCreationSettings originalMockSettings =
+                    this.originalMockingDetails.getMockCreationSettings();
             assertCompatibleTypes(mock, originalMockSettings);
             this.mock = mock;
         }
 
+        @Override
         public Object getMock() {
             return mock;
         }
@@ -59,21 +68,34 @@ public class VerificationStartedNotifier {
     static void assertCompatibleTypes(Object mock, MockCreationSettings originalSettings) {
         Class originalType = originalSettings.getTypeToMock();
         if (!originalType.isInstance(mock)) {
-            throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock",
-                "parameter which is not the same type as the original mock.\n" +
-                    "  Required type: " + originalType.getName() + "\n" +
-                    "  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
+            throw Reporter.methodDoesNotAcceptParameter(
+                    "VerificationStartedEvent.setMock",
+                    "parameter which is not the same type as the original mock.\n"
+                            + "  Required type: "
+                            + originalType.getName()
+                            + "\n"
+                            + "  Received parameter: "
+                            + ValuePrinter.print(mock)
+                            + ".\n ");
         }
 
         for (Class iface : (Set<Class>) originalSettings.getExtraInterfaces()) {
             if (!iface.isInstance(mock)) {
-                throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock",
-                    "parameter which does not implement all extra interfaces of the original mock.\n" +
-                        "  Required type: " + originalType.getName() + "\n" +
-                        "  Required extra interface: " + iface.getName() + "\n" +
-                        "  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
-
+                throw Reporter.methodDoesNotAcceptParameter(
+                        "VerificationStartedEvent.setMock",
+                        "parameter which does not implement all extra interfaces of the original mock.\n"
+                                + "  Required type: "
+                                + originalType.getName()
+                                + "\n"
+                                + "  Required extra interface: "
+                                + iface.getName()
+                                + "\n"
+                                + "  Received parameter: "
+                                + ValuePrinter.print(mock)
+                                + ".\n ");
             }
         }
     }
+
+    private VerificationStartedNotifier() {}
 }
diff --git a/src/main/java/org/mockito/internal/matchers/And.java b/src/main/java/org/mockito/internal/matchers/And.java
index 2c8f11c..417e88d 100644
--- a/src/main/java/org/mockito/internal/matchers/And.java
+++ b/src/main/java/org/mockito/internal/matchers/And.java
@@ -2,28 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
 
 import org.mockito.ArgumentMatcher;
 
-@SuppressWarnings({ "unchecked", "serial","rawtypes" })
+@SuppressWarnings({"unchecked", "serial", "rawtypes"})
 public class And implements ArgumentMatcher<Object>, Serializable {
-    private ArgumentMatcher m1;
-    private ArgumentMatcher m2;
+    private final ArgumentMatcher m1;
+    private final ArgumentMatcher m2;
 
     public And(ArgumentMatcher<?> m1, ArgumentMatcher<?> m2) {
         this.m1 = m1;
         this.m2 = m2;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return m1.matches(actual) && m2.matches(actual);
     }
 
+    @Override
     public String toString() {
-        return "and("+m1+", "+m2+")";
+        return "and(" + m1 + ", " + m2 + ")";
     }
 }
diff --git a/src/main/java/org/mockito/internal/matchers/Any.java b/src/main/java/org/mockito/internal/matchers/Any.java
index 58b6404..7ad113f 100644
--- a/src/main/java/org/mockito/internal/matchers/Any.java
+++ b/src/main/java/org/mockito/internal/matchers/Any.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
@@ -13,10 +12,12 @@ public class Any implements ArgumentMatcher<Object>, VarargMatcher, Serializable
 
     public static final Any ANY = new Any();
 
+    @Override
     public boolean matches(Object actual) {
         return true;
     }
 
+    @Override
     public String toString() {
         return "<any>";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/ArrayEquals.java b/src/main/java/org/mockito/internal/matchers/ArrayEquals.java
index d647d1e..b487773 100644
--- a/src/main/java/org/mockito/internal/matchers/ArrayEquals.java
+++ b/src/main/java/org/mockito/internal/matchers/ArrayEquals.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.lang.reflect.Array;
@@ -14,6 +13,7 @@ public class ArrayEquals extends Equals {
         super(wanted);
     }
 
+    @Override
     public boolean matches(Object actual) {
         Object wanted = getWanted();
         if (wanted == null || actual == null) {
@@ -40,6 +40,7 @@ public class ArrayEquals extends Equals {
         return false;
     }
 
+    @Override
     public String toString() {
         if (getWanted() != null && getWanted().getClass().isArray()) {
             return appendArray(createObjectArray(getWanted()));
@@ -49,10 +50,10 @@ public class ArrayEquals extends Equals {
     }
 
     private String appendArray(Object[] array) {
-        //TODO SF overlap with ValuePrinter
+        // TODO SF overlap with ValuePrinter
         StringBuilder out = new StringBuilder("[");
         for (int i = 0; i < array.length; i++) {
-            out.append(new Equals(array[i]).toString());
+            out.append(new Equals(array[i]));
             if (i != array.length - 1) {
                 out.append(", ");
             }
diff --git a/src/main/java/org/mockito/internal/matchers/CapturesArguments.java b/src/main/java/org/mockito/internal/matchers/CapturesArguments.java
index 0c13853..2e1981c 100644
--- a/src/main/java/org/mockito/internal/matchers/CapturesArguments.java
+++ b/src/main/java/org/mockito/internal/matchers/CapturesArguments.java
@@ -4,9 +4,7 @@
  */
 package org.mockito.internal.matchers;
 
-
 public interface CapturesArguments {
 
     void captureFrom(Object argument);
-
 }
diff --git a/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java b/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
index 1b30ce8..5138839 100644
--- a/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
+++ b/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import static org.mockito.internal.exceptions.Reporter.noArgumentValueWasCaptured;
 
 import java.io.Serializable;
@@ -15,19 +13,24 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
+import org.mockito.ArgumentMatcher;
+
 @SuppressWarnings("unchecked")
-public class CapturingMatcher<T> implements ArgumentMatcher<T>, CapturesArguments, VarargMatcher, Serializable {
+public class CapturingMatcher<T>
+        implements ArgumentMatcher<T>, CapturesArguments, VarargMatcher, Serializable {
 
-    private final List<Object> arguments = new ArrayList<Object>();
+    private final List<Object> arguments = new ArrayList<>();
 
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
     private final Lock readLock = lock.readLock();
     private final Lock writeLock = lock.writeLock();
 
+    @Override
     public boolean matches(Object argument) {
         return true;
     }
 
+    @Override
     public String toString() {
         return "<Capturing argument>";
     }
@@ -54,6 +57,7 @@ public class CapturingMatcher<T> implements ArgumentMatcher<T>, CapturesArgument
         }
     }
 
+    @Override
     public void captureFrom(Object argument) {
         writeLock.lock();
         try {
diff --git a/src/main/java/org/mockito/internal/matchers/CompareEqual.java b/src/main/java/org/mockito/internal/matchers/CompareEqual.java
index eb21c46..4c84f22 100644
--- a/src/main/java/org/mockito/internal/matchers/CompareEqual.java
+++ b/src/main/java/org/mockito/internal/matchers/CompareEqual.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/matchers/CompareTo.java b/src/main/java/org/mockito/internal/matchers/CompareTo.java
index 88f95cc..587bdc5 100644
--- a/src/main/java/org/mockito/internal/matchers/CompareTo.java
+++ b/src/main/java/org/mockito/internal/matchers/CompareTo.java
@@ -2,14 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
-public abstract class CompareTo<T extends Comparable<T>> implements ArgumentMatcher<T>, Serializable {
+import org.mockito.ArgumentMatcher;
+
+public abstract class CompareTo<T extends Comparable<T>>
+        implements ArgumentMatcher<T>, Serializable {
     private final T wanted;
 
     public CompareTo(T value) {
@@ -21,7 +21,7 @@ public abstract class CompareTo<T extends Comparable<T>> implements ArgumentMatc
         if (actual == null) {
             return false;
         }
-        if (!actual.getClass().isInstance(wanted)){
+        if (!actual.getClass().isInstance(wanted)) {
             return false;
         }
 
diff --git a/src/main/java/org/mockito/internal/matchers/Contains.java b/src/main/java/org/mockito/internal/matchers/Contains.java
index daa7608..a52f1fb 100644
--- a/src/main/java/org/mockito/internal/matchers/Contains.java
+++ b/src/main/java/org/mockito/internal/matchers/Contains.java
@@ -2,13 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
 
 public class Contains implements ArgumentMatcher<String>, Serializable {
 
@@ -18,10 +16,12 @@ public class Contains implements ArgumentMatcher<String>, Serializable {
         this.substring = substring;
     }
 
+    @Override
     public boolean matches(String actual) {
         return actual != null && actual.contains(substring);
     }
 
+    @Override
     public String toString() {
         return "contains(\"" + substring + "\")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java b/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
index 3b69fbc..8c698fd 100644
--- a/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
+++ b/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
@@ -9,18 +9,25 @@ package org.mockito.internal.matchers;
  * When ArgumentMatcher fails, chance is that the actual object has the same output of toString() than
  * the wanted object. This looks weird when failures are reported.
  * Therefore when matcher fails but toString() yields the same outputs,
- * we will try to use the {@link #toStringWithType()} method.
+ * we will try to use the {@link #toStringWithType(String)} method.
  */
 public interface ContainsExtraTypeInfo {
 
     /**
+     * @param className - name of the class to be printed in description
      * Returns more verbose description of the object which include type information
      */
-    String toStringWithType();
+    String toStringWithType(String className);
 
     /**
      * Checks if target target has matching type.
-     * If the type matches, there is no point in rendering result from {@link #toStringWithType()}
+     * If the type matches, there is no point in rendering result from {@link #toStringWithType(String)}
      */
     boolean typeMatches(Object target);
+
+    /**
+     *
+     * @return Returns the wanted argument
+     */
+    Object getWanted();
 }
diff --git a/src/main/java/org/mockito/internal/matchers/EndsWith.java b/src/main/java/org/mockito/internal/matchers/EndsWith.java
index 2abde2b..4056210 100644
--- a/src/main/java/org/mockito/internal/matchers/EndsWith.java
+++ b/src/main/java/org/mockito/internal/matchers/EndsWith.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
@@ -17,10 +16,12 @@ public class EndsWith implements ArgumentMatcher<String>, Serializable {
         this.suffix = suffix;
     }
 
+    @Override
     public boolean matches(String actual) {
         return actual != null && actual.endsWith(suffix);
     }
 
+    @Override
     public String toString() {
         return "endsWith(\"" + suffix + "\")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/Equality.java b/src/main/java/org/mockito/internal/matchers/Equality.java
index 9702550..a1cd701 100644
--- a/src/main/java/org/mockito/internal/matchers/Equality.java
+++ b/src/main/java/org/mockito/internal/matchers/Equality.java
@@ -6,13 +6,13 @@ package org.mockito.internal.matchers;
 
 import java.lang.reflect.Array;
 
-//stolen from hamcrest because I didn't want to have more dependency than Matcher class
-public class Equality {
+// stolen from hamcrest because I didn't want to have more dependency than Matcher class
+public final class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
-        if (o1 == o2 ) {
+        if (o1 == o2) {
             return true;
-    } else if (o1 == null || o2 == null) {
+        } else if (o1 == null || o2 == null) {
             return false;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
@@ -22,8 +22,7 @@ public class Equality {
     }
 
     static boolean areArraysEqual(Object o1, Object o2) {
-        return areArrayLengthsEqual(o1, o2)
-                && areArrayElementsEqual(o1, o2);
+        return areArrayLengthsEqual(o1, o2) && areArrayElementsEqual(o1, o2);
     }
 
     static boolean areArrayLengthsEqual(Object o1, Object o2) {
@@ -32,7 +31,9 @@ public class Equality {
 
     static boolean areArrayElementsEqual(Object o1, Object o2) {
         for (int i = 0; i < Array.getLength(o1); i++) {
-            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;
+            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) {
+                return false;
+            }
         }
         return true;
     }
@@ -40,4 +41,6 @@ public class Equality {
     static boolean isArray(Object o) {
         return o.getClass().isArray();
     }
+
+    private Equality() {}
 }
diff --git a/src/main/java/org/mockito/internal/matchers/Equals.java b/src/main/java/org/mockito/internal/matchers/Equals.java
index ba9f37f..8b07b2d 100644
--- a/src/main/java/org/mockito/internal/matchers/Equals.java
+++ b/src/main/java/org/mockito/internal/matchers/Equals.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
+import java.io.Serializable;
+
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.text.ValuePrinter;
 
-import java.io.Serializable;
-
 public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, Serializable {
 
     private final Object wanted;
@@ -18,10 +17,12 @@ public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, S
         this.wanted = wanted;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return Equality.areEqual(this.wanted, actual);
     }
 
+    @Override
     public String toString() {
         return describe(wanted);
     }
@@ -30,17 +31,19 @@ public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, S
         return ValuePrinter.print(object);
     }
 
-    protected final Object getWanted() {
+    @Override
+    public final Object getWanted() {
         return wanted;
     }
 
     @Override
     public boolean equals(Object o) {
-        if (o == null || !this.getClass().equals(o.getClass())) {
+        if (!(o instanceof Equals)) {
             return false;
         }
         Equals other = (Equals) o;
-        return this.wanted == null && other.wanted == null || this.wanted != null && this.wanted.equals(other.wanted);
+        return (this.wanted == null && other.wanted == null)
+                || this.wanted != null && this.wanted.equals(other.wanted);
     }
 
     @Override
@@ -48,10 +51,12 @@ public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, S
         return 1;
     }
 
-    public String toStringWithType() {
-        return "("+ wanted.getClass().getSimpleName() +") " + describe(wanted);
+    @Override
+    public String toStringWithType(String className) {
+        return "(" + className + ") " + describe(wanted);
     }
 
+    @Override
     public boolean typeMatches(Object target) {
         return wanted != null && target != null && target.getClass() == wanted.getClass();
     }
diff --git a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
index d5d8e19..46fd4d6 100644
--- a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
+++ b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
@@ -2,13 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+
 public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
 
     private final Number wanted;
@@ -19,6 +18,7 @@ public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
         this.delta = delta;
     }
 
+    @Override
     public boolean matches(Number actual) {
         if (wanted == null ^ actual == null) {
             return false;
@@ -29,10 +29,10 @@ public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
         }
 
         return wanted.doubleValue() - delta.doubleValue() <= actual.doubleValue()
-                && actual.doubleValue() <= wanted.doubleValue()
-                        + delta.doubleValue();
+                && actual.doubleValue() <= wanted.doubleValue() + delta.doubleValue();
     }
 
+    @Override
     public String toString() {
         return "eq(" + wanted + ", " + delta + ")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/Find.java b/src/main/java/org/mockito/internal/matchers/Find.java
index 178c444..530e4c0 100644
--- a/src/main/java/org/mockito/internal/matchers/Find.java
+++ b/src/main/java/org/mockito/internal/matchers/Find.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
@@ -18,11 +17,13 @@ public class Find implements ArgumentMatcher<String>, Serializable {
         this.regex = regex;
     }
 
+    @Override
     public boolean matches(String actual) {
         return actual != null && Pattern.compile(regex).matcher(actual).find();
     }
 
+    @Override
     public String toString() {
-        return "find(\"" + regex.replaceAll("\\\\", "\\\\\\\\") + "\")";
+        return "find(\"" + regex.replace("\\", "\\\\") + "\")";
     }
 }
diff --git a/src/main/java/org/mockito/internal/matchers/GreaterOrEqual.java b/src/main/java/org/mockito/internal/matchers/GreaterOrEqual.java
index f1c8ff2..45e1855 100644
--- a/src/main/java/org/mockito/internal/matchers/GreaterOrEqual.java
+++ b/src/main/java/org/mockito/internal/matchers/GreaterOrEqual.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/matchers/GreaterThan.java b/src/main/java/org/mockito/internal/matchers/GreaterThan.java
index 46497c1..3b1f96c 100644
--- a/src/main/java/org/mockito/internal/matchers/GreaterThan.java
+++ b/src/main/java/org/mockito/internal/matchers/GreaterThan.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/matchers/InstanceOf.java b/src/main/java/org/mockito/internal/matchers/InstanceOf.java
index 2876aa2..1b4b30e 100644
--- a/src/main/java/org/mockito/internal/matchers/InstanceOf.java
+++ b/src/main/java/org/mockito/internal/matchers/InstanceOf.java
@@ -2,19 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.util.Primitives;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.util.Primitives;
 
 public class InstanceOf implements ArgumentMatcher<Object>, Serializable {
 
     private final Class<?> clazz;
-    private String description;
+    private final String description;
 
     public InstanceOf(Class<?> clazz) {
         this(clazz, "isA(" + clazz.getCanonicalName() + ")");
@@ -25,12 +23,14 @@ public class InstanceOf implements ArgumentMatcher<Object>, Serializable {
         this.description = describedAs;
     }
 
+    @Override
     public boolean matches(Object actual) {
-        return (actual != null) &&
-                (Primitives.isAssignableFromWrapper(actual.getClass(), clazz)
+        return (actual != null)
+                && (Primitives.isAssignableFromWrapper(actual.getClass(), clazz)
                         || clazz.isAssignableFrom(actual.getClass()));
     }
 
+    @Override
     public String toString() {
         return description;
     }
@@ -45,6 +45,4 @@ public class InstanceOf implements ArgumentMatcher<Object>, Serializable {
             super(clazz, describedAs);
         }
     }
-
-
 }
diff --git a/src/main/java/org/mockito/internal/matchers/LessOrEqual.java b/src/main/java/org/mockito/internal/matchers/LessOrEqual.java
index 1b3d737..c634054 100644
--- a/src/main/java/org/mockito/internal/matchers/LessOrEqual.java
+++ b/src/main/java/org/mockito/internal/matchers/LessOrEqual.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/matchers/LessThan.java b/src/main/java/org/mockito/internal/matchers/LessThan.java
index c0c931e..67b7428 100644
--- a/src/main/java/org/mockito/internal/matchers/LessThan.java
+++ b/src/main/java/org/mockito/internal/matchers/LessThan.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
diff --git a/src/main/java/org/mockito/internal/matchers/Matches.java b/src/main/java/org/mockito/internal/matchers/Matches.java
index 2a15c47..dcd7347 100644
--- a/src/main/java/org/mockito/internal/matchers/Matches.java
+++ b/src/main/java/org/mockito/internal/matchers/Matches.java
@@ -2,11 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
 import java.util.regex.Pattern;
+
 import org.mockito.ArgumentMatcher;
 
 public class Matches implements ArgumentMatcher<Object>, Serializable {
@@ -21,11 +21,13 @@ public class Matches implements ArgumentMatcher<Object>, Serializable {
         this.pattern = pattern;
     }
 
+    @Override
     public boolean matches(Object actual) {
-        return (actual instanceof String) && pattern.matcher((String) actual).matches();
+        return (actual instanceof String) && pattern.matcher((String) actual).find();
     }
 
+    @Override
     public String toString() {
-        return "matches(\"" + pattern.pattern().replaceAll("\\\\", "\\\\\\\\") + "\")";
+        return "matches(\"" + pattern.pattern().replace("\\", "\\\\") + "\")";
     }
 }
diff --git a/src/main/java/org/mockito/internal/matchers/Not.java b/src/main/java/org/mockito/internal/matchers/Not.java
index 1cece9d..bd35eaf 100644
--- a/src/main/java/org/mockito/internal/matchers/Not.java
+++ b/src/main/java/org/mockito/internal/matchers/Not.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
-@SuppressWarnings({ "unchecked", "serial","rawtypes" })
+import org.mockito.ArgumentMatcher;
+
+@SuppressWarnings({"unchecked", "serial", "rawtypes"})
 public class Not implements ArgumentMatcher<Object>, Serializable {
 
     private final ArgumentMatcher matcher;
@@ -18,10 +17,12 @@ public class Not implements ArgumentMatcher<Object>, Serializable {
         this.matcher = matcher;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return !matcher.matches(actual);
     }
 
+    @Override
     public String toString() {
         return "not(" + matcher + ")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/NotNull.java b/src/main/java/org/mockito/internal/matchers/NotNull.java
index 1b4b36d..2902f57 100644
--- a/src/main/java/org/mockito/internal/matchers/NotNull.java
+++ b/src/main/java/org/mockito/internal/matchers/NotNull.java
@@ -2,24 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+
 public class NotNull implements ArgumentMatcher<Object>, Serializable {
 
     public static final NotNull NOT_NULL = new NotNull();
 
-    private NotNull() {
-    }
+    private NotNull() {}
 
+    @Override
     public boolean matches(Object actual) {
         return actual != null;
     }
 
+    @Override
     public String toString() {
         return "notNull()";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/Null.java b/src/main/java/org/mockito/internal/matchers/Null.java
index 650a606..69eee48 100644
--- a/src/main/java/org/mockito/internal/matchers/Null.java
+++ b/src/main/java/org/mockito/internal/matchers/Null.java
@@ -2,24 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+
 public class Null implements ArgumentMatcher<Object>, Serializable {
 
     public static final Null NULL = new Null();
 
-    private Null() {
-    }
+    private Null() {}
 
+    @Override
     public boolean matches(Object actual) {
         return actual == null;
     }
 
+    @Override
     public String toString() {
         return "isNull()";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/Or.java b/src/main/java/org/mockito/internal/matchers/Or.java
index 803a533..ed7bbde 100644
--- a/src/main/java/org/mockito/internal/matchers/Or.java
+++ b/src/main/java/org/mockito/internal/matchers/Or.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
 import java.io.Serializable;
 
 import org.mockito.ArgumentMatcher;
 
-@SuppressWarnings({ "unchecked", "serial","rawtypes" })
+@SuppressWarnings({"unchecked", "serial", "rawtypes"})
 public class Or implements ArgumentMatcher<Object>, Serializable {
     private final ArgumentMatcher m1;
     private final ArgumentMatcher m2;
@@ -19,11 +18,13 @@ public class Or implements ArgumentMatcher<Object>, Serializable {
         this.m2 = m2;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return m1.matches(actual) || m2.matches(actual);
     }
 
+    @Override
     public String toString() {
-        return "or("+m1+", "+m2+")";
+        return "or(" + m1 + ", " + m2 + ")";
     }
 }
diff --git a/src/main/java/org/mockito/internal/matchers/Same.java b/src/main/java/org/mockito/internal/matchers/Same.java
index b834376..0e23c5c 100644
--- a/src/main/java/org/mockito/internal/matchers/Same.java
+++ b/src/main/java/org/mockito/internal/matchers/Same.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
+import java.io.Serializable;
+
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.text.ValuePrinter;
 
-import java.io.Serializable;
-
 public class Same implements ArgumentMatcher<Object>, Serializable {
 
     private final Object wanted;
@@ -18,10 +17,12 @@ public class Same implements ArgumentMatcher<Object>, Serializable {
         this.wanted = wanted;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return wanted == actual;
     }
 
+    @Override
     public String toString() {
         return "same(" + ValuePrinter.print(wanted) + ")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/StartsWith.java b/src/main/java/org/mockito/internal/matchers/StartsWith.java
index f89c2c0..2daae97 100644
--- a/src/main/java/org/mockito/internal/matchers/StartsWith.java
+++ b/src/main/java/org/mockito/internal/matchers/StartsWith.java
@@ -2,13 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+
 public class StartsWith implements ArgumentMatcher<String>, Serializable {
 
     private final String prefix;
@@ -17,10 +16,12 @@ public class StartsWith implements ArgumentMatcher<String>, Serializable {
         this.prefix = prefix;
     }
 
+    @Override
     public boolean matches(String actual) {
         return actual != null && actual.startsWith(prefix);
     }
 
+    @Override
     public String toString() {
         return "startsWith(\"" + prefix + "\")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/VarargMatcher.java b/src/main/java/org/mockito/internal/matchers/VarargMatcher.java
index fc843f6..43a2759 100644
--- a/src/main/java/org/mockito/internal/matchers/VarargMatcher.java
+++ b/src/main/java/org/mockito/internal/matchers/VarargMatcher.java
@@ -10,5 +10,4 @@ import java.io.Serializable;
  * Internal interface that informs Mockito that the matcher is intended to capture varargs.
  * This information is needed when mockito collects the arguments.
  */
-public interface VarargMatcher extends Serializable {
-}
+public interface VarargMatcher extends Serializable {}
diff --git a/src/main/java/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java b/src/main/java/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java
index 92662c8..eaa1516 100644
--- a/src/main/java/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java
+++ b/src/main/java/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java
@@ -2,18 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
-//NON-STANDARD LICENCE HEADER HERE - THAT'S OK
-//Class comes from Apache Commons Lang, added some tiny changes
 package org.mockito.internal.matchers.apachecommons;
 
-import java.lang.reflect.AccessibleObject;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.plugins.MemberAccessor;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
+// Class comes from Apache Commons Lang, added some tiny changes
 /**
  * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>
  *
@@ -92,7 +93,7 @@ class EqualsBuilder {
         // do nothing for now.
     }
 
-    //-------------------------------------------------------------------------
+    // -------------------------------------------------------------------------
 
     /**
      * <p>This method uses reflection to determine if the two <code>Object</code>s
@@ -188,7 +189,8 @@ class EqualsBuilder {
      * @return <code>true</code> if the two Objects have tested equals.
      * @since 2.1.0
      */
-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {
+    public static boolean reflectionEquals(
+            Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {
         return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);
     }
 
@@ -218,7 +220,11 @@ class EqualsBuilder {
      * @return <code>true</code> if the two Objects have tested equals.
      * @since 2.1.0
      */
-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,
+    public static boolean reflectionEquals(
+            Object lhs,
+            Object rhs,
+            boolean testTransients,
+            Class<?> reflectUpToClass,
             String[] excludeFields) {
         if (lhs == rhs) {
             return true;
@@ -250,20 +256,16 @@ class EqualsBuilder {
             return false;
         }
         EqualsBuilder equalsBuilder = new EqualsBuilder();
-        try {
-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
-            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
-                testClass = testClass.getSuperclass();
-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
-            }
-        } catch (IllegalArgumentException e) {
-            // In this case, we tried to test a subclass vs. a superclass and
-            // the subclass has ivars or the ivars are transient and
-            // we are testing transients.
-            // If a subclass has ivars that we are trying to test them, we get an
-            // exception and we know that the objects are not equal.
+        if (reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields)) {
             return false;
         }
+        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
+            testClass = testClass.getSuperclass();
+            if (reflectionAppend(
+                    lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields)) {
+                return false;
+            }
+        }
         return equalsBuilder.isEquals();
     }
 
@@ -278,34 +280,41 @@ class EqualsBuilder {
      * @param useTransients  whether to test transient fields
      * @param excludeFields  array of field names to exclude from testing
      */
-    private static void reflectionAppend(
-        Object lhs,
-        Object rhs,
-        Class<?> clazz,
-        EqualsBuilder builder,
-        boolean useTransients,
-        String[] excludeFields) {
+    private static boolean reflectionAppend(
+            Object lhs,
+            Object rhs,
+            Class<?> clazz,
+            EqualsBuilder builder,
+            boolean useTransients,
+            String[] excludeFields) {
         Field[] fields = clazz.getDeclaredFields();
-        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();
-        AccessibleObject.setAccessible(fields, true);
+        List<String> excludedFieldList =
+                excludeFields != null
+                        ? Arrays.asList(excludeFields)
+                        : Collections.<String>emptyList();
+        MemberAccessor accessor = Plugins.getMemberAccessor();
         for (int i = 0; i < fields.length && builder.isEquals; i++) {
             Field f = fields[i];
             if (!excludedFieldList.contains(f.getName())
-                && (f.getName().indexOf('$') == -1)
-                && (useTransients || !Modifier.isTransient(f.getModifiers()))
-                && (!Modifier.isStatic(f.getModifiers()))) {
+                    && (f.getName().indexOf('$') == -1)
+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))
+                    && !Modifier.isStatic(f.getModifiers())) {
                 try {
-                    builder.append(f.get(lhs), f.get(rhs));
-                } catch (IllegalAccessException e) {
-                    //this can't happen. Would get a Security exception instead
-                    //throw a runtime exception in case the impossible happens.
-                    throw new InternalError("Unexpected IllegalAccessException");
+                    builder.append(accessor.get(f, lhs), accessor.get(f, rhs));
+                } catch (RuntimeException | IllegalAccessException ignored) {
+                    // In this case, we tried to test a subclass vs. a superclass and
+                    // the subclass has ivars or the ivars are transient and we are
+                    // testing transients. If a subclass has ivars that we are trying
+                    // to test them, we get an exception and we know that the objects
+                    // are not equal.
+                    return true;
                 }
             }
         }
+        return false;
     }
 
-    //-------------------------------------------------------------------------
+    // -------------------------------------------------------------------------
 
     /**
      * <p>Adds the result of <code>super.equals()</code> to this builder.</p>
@@ -319,7 +328,7 @@ class EqualsBuilder {
         return this;
     }
 
-    //-------------------------------------------------------------------------
+    // -------------------------------------------------------------------------
 
     /**
      * <p>Test if two <code>Object</code>s are equal using their
@@ -342,8 +351,8 @@ class EqualsBuilder {
         }
         Class<?> lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
-            if (lhs instanceof java.math.BigDecimal && rhs instanceof java.math.BigDecimal) {
-                isEquals = (((java.math.BigDecimal) lhs).compareTo((java.math.BigDecimal) rhs) == 0);
+            if (lhs instanceof BigDecimal && rhs instanceof BigDecimal) {
+                isEquals = (((BigDecimal) lhs).compareTo((BigDecimal) rhs) == 0);
             } else {
                 // The simple case, not an array, just test the element
                 isEquals = lhs.equals(rhs);
@@ -352,8 +361,8 @@ class EqualsBuilder {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]
             this.setEquals(false);
 
-        // 'Switch' on type of array, to dispatch to the correct handler
-        // This handles multi dimensional arrays of the same depth
+            // 'Switch' on type of array, to dispatch to the correct handler
+            // This handles multi dimensional arrays of the same depth
         } else if (lhs instanceof long[]) {
             append((long[]) lhs, (long[]) rhs);
         } else if (lhs instanceof int[]) {
@@ -487,7 +496,7 @@ class EqualsBuilder {
      * @param lhs  the left hand <code>boolean</code>
      * @param rhs  the right hand <code>boolean</code>
      * @return EqualsBuilder - used to chain calls.
-      */
+     */
     public EqualsBuilder append(boolean lhs, boolean rhs) {
         isEquals &= (lhs == rhs);
         return this;
diff --git a/src/main/java/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java b/src/main/java/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java
index 2787e97..6dcbfc6 100644
--- a/src/main/java/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java
+++ b/src/main/java/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java
@@ -2,13 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers.apachecommons;
 
-import org.mockito.ArgumentMatcher;
-
 import java.io.Serializable;
 
+import org.mockito.ArgumentMatcher;
+
 public class ReflectionEquals implements ArgumentMatcher<Object>, Serializable {
 
     private final Object wanted;
@@ -19,10 +18,12 @@ public class ReflectionEquals implements ArgumentMatcher<Object>, Serializable {
         this.excludeFields = excludeFields;
     }
 
+    @Override
     public boolean matches(Object actual) {
         return EqualsBuilder.reflectionEquals(wanted, actual, excludeFields);
     }
 
+    @Override
     public String toString() {
         return "refEq(" + wanted + ")";
     }
diff --git a/src/main/java/org/mockito/internal/matchers/text/MatcherToString.java b/src/main/java/org/mockito/internal/matchers/text/MatcherToString.java
index f67b868..d59cbac 100644
--- a/src/main/java/org/mockito/internal/matchers/text/MatcherToString.java
+++ b/src/main/java/org/mockito/internal/matchers/text/MatcherToString.java
@@ -5,15 +5,14 @@
 package org.mockito.internal.matchers.text;
 
 import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
-import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
+import static org.mockito.internal.util.StringUtil.decamelizeMatcherName;
 
 import java.lang.reflect.Method;
+
 import org.mockito.ArgumentMatcher;
 
-/**
- * Provides better toString() text for matcher that don't have toString() method declared.
- */
-class MatcherToString {
+/** Provides better toString() text for matcher that don't have toString() method declared. */
+final class MatcherToString {
 
     /**
      * Attempts to provide more descriptive toString() for given matcher.
@@ -27,17 +26,28 @@ class MatcherToString {
      */
     static String toString(ArgumentMatcher<?> matcher) {
         Class<?> cls = matcher.getClass();
-        while(cls != Object.class) {
+        while (cls != Object.class) {
             Method[] methods = cls.getDeclaredMethods();
             for (Method m : methods) {
-                if(isToStringMethod(m)) {
+                if (isToStringMethod(m)) {
                     return matcher.toString();
                 }
             }
             cls = cls.getSuperclass();
         }
-        return decamelizeMatcher(matcher.getClass().getSimpleName());
-    }
 
+        String matcherName;
+        Class<?> matcherClass = matcher.getClass();
+        // Lambdas have non-empty getSimpleName() (despite being synthetic)
+        // but that name is not useful for user
+        if (matcherClass.isSynthetic()) {
+            matcherName = "";
+        } else {
+            matcherName = matcherClass.getSimpleName();
+        }
+
+        return decamelizeMatcherName(matcherName);
+    }
 
+    private MatcherToString() {}
 }
diff --git a/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java b/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
index 98194fc..9ceab39 100644
--- a/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
+++ b/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.matchers.text;
 
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.matchers.ContainsExtraTypeInfo;
-import org.mockito.internal.reporting.PrintSettings;
-
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.matchers.ContainsExtraTypeInfo;
+import org.mockito.internal.reporting.PrintSettings;
+
 @SuppressWarnings("unchecked")
 public class MatchersPrinter {
 
@@ -25,12 +25,30 @@ public class MatchersPrinter {
         return ValuePrinter.printValues("(\n    ", ",\n    ", "\n);", args);
     }
 
-    private Iterator<FormattedText> applyPrintSettings(List<ArgumentMatcher> matchers, PrintSettings printSettings) {
-        List<FormattedText> out = new LinkedList<FormattedText>();
+    private Iterator<FormattedText> applyPrintSettings(
+            List<ArgumentMatcher> matchers, PrintSettings printSettings) {
+        List<FormattedText> out = new LinkedList<>();
         int i = 0;
         for (final ArgumentMatcher matcher : matchers) {
-            if (matcher instanceof ContainsExtraTypeInfo && printSettings.extraTypeInfoFor(i)) {
-                out.add(new FormattedText(((ContainsExtraTypeInfo) matcher).toStringWithType()));
+            if (matcher instanceof ContainsExtraTypeInfo) {
+                ContainsExtraTypeInfo typeInfoMatcher = (ContainsExtraTypeInfo) matcher;
+                Object wanted = typeInfoMatcher.getWanted();
+                String simpleNameOfArgument =
+                        wanted != null ? wanted.getClass().getSimpleName() : "";
+                String fullyQualifiedClassName =
+                        wanted != null ? wanted.getClass().getCanonicalName() : "";
+
+                if (printSettings.extraTypeInfoFor(i)) {
+                    out.add(
+                            new FormattedText(
+                                    typeInfoMatcher.toStringWithType(simpleNameOfArgument)));
+                } else if (printSettings.fullyQualifiedNameFor(simpleNameOfArgument)) {
+                    out.add(
+                            new FormattedText(
+                                    typeInfoMatcher.toStringWithType(fullyQualifiedClassName)));
+                } else {
+                    out.add(new FormattedText(MatcherToString.toString(matcher)));
+                }
             } else {
                 out.add(new FormattedText(MatcherToString.toString(matcher)));
             }
diff --git a/src/main/java/org/mockito/internal/matchers/text/ValuePrinter.java b/src/main/java/org/mockito/internal/matchers/text/ValuePrinter.java
index 6f5882f..4517d75 100644
--- a/src/main/java/org/mockito/internal/matchers/text/ValuePrinter.java
+++ b/src/main/java/org/mockito/internal/matchers/text/ValuePrinter.java
@@ -8,15 +8,13 @@ import java.lang.reflect.Array;
 import java.util.Iterator;
 import java.util.Map;
 
-import static java.lang.String.valueOf;
-
 /**
  * Prints a Java object value in a way humans can read it neatly.
  * Inspired on hamcrest. Used for printing arguments in verification errors.
  */
 public class ValuePrinter {
 
-    private ValuePrinter(){}
+    private ValuePrinter() {}
 
     /**
      * Prints given value so that it is neatly readable by humans.
@@ -51,21 +49,27 @@ public class ValuePrinter {
             return printMap((Map<?, ?>) value);
         }
         if (value.getClass().isArray()) {
-            return printValues("[", ", ", "]", new Iterator<Object>() {
-                private int currentIndex = 0;
+            return printValues(
+                    "[",
+                    ", ",
+                    "]",
+                    new Iterator<Object>() {
+                        private int currentIndex = 0;
 
-                public boolean hasNext() {
-                    return currentIndex < Array.getLength(value);
-                }
+                        @Override
+                        public boolean hasNext() {
+                            return currentIndex < Array.getLength(value);
+                        }
 
-                public Object next() {
-                    return Array.get(value, currentIndex++);
-                }
+                        public Object next() {
+                            return Array.get(value, currentIndex++);
+                        }
 
-                public void remove() {
-                    throw new UnsupportedOperationException("cannot remove items from an array");
-                }
-            });
+                        public void remove() {
+                            throw new UnsupportedOperationException(
+                                    "cannot remove items from an array");
+                        }
+                    });
         }
         if (value instanceof FormattedText) {
             return (((FormattedText) value).getText());
@@ -74,7 +78,7 @@ public class ValuePrinter {
         return descriptionOf(value);
     }
 
-    private static String printMap(Map<?,?> map) {
+    private static String printMap(Map<?, ?> map) {
         StringBuilder result = new StringBuilder();
         Iterator<? extends Map.Entry<?, ?>> iterator = map.entrySet().iterator();
         while (iterator.hasNext()) {
@@ -84,7 +88,7 @@ public class ValuePrinter {
                 result.append(", ");
             }
         }
-        return "{" + result.toString() + "}";
+        return "{" + result + "}";
     }
 
     /**
@@ -97,19 +101,20 @@ public class ValuePrinter {
      *
      * @return neatly formatted value list
      */
-    public static String printValues(String start, String separator, String end, Iterator<?> values) {
-        if(start == null){
+    public static String printValues(
+            String start, String separator, String end, Iterator<?> values) {
+        if (start == null) {
             start = "(";
         }
-        if (separator == null){
+        if (separator == null) {
             separator = ",";
         }
-        if (end == null){
+        if (end == null) {
             end = ")";
         }
 
         StringBuilder sb = new StringBuilder(start);
-        while(values.hasNext()) {
+        while (values.hasNext()) {
             sb.append(print(values.next()));
             if (values.hasNext()) {
                 sb.append(separator);
@@ -143,9 +148,8 @@ public class ValuePrinter {
 
     private static String descriptionOf(Object value) {
         try {
-            return valueOf(value);
-        }
-        catch (Exception e) {
+            return String.valueOf(value);
+        } catch (RuntimeException e) {
             return value.getClass().getName() + "@" + Integer.toHexString(value.hashCode());
         }
     }
diff --git a/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorage.java b/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorage.java
index 572b9d4..24bb8a4 100644
--- a/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorage.java
+++ b/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorage.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.progress;
 
+import java.util.List;
+
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.LocalizedMatcher;
 
-import java.util.List;
-
 @SuppressWarnings("unchecked")
 public interface ArgumentMatcherStorage {
 
@@ -25,5 +25,4 @@ public interface ArgumentMatcherStorage {
     void validateState();
 
     void reset();
-
 }
diff --git a/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java b/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java
index 6e8dd24..dbbc027 100644
--- a/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java
+++ b/src/main/java/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java
@@ -2,39 +2,41 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.matchers.And;
-import org.mockito.internal.matchers.LocalizedMatcher;
-import org.mockito.internal.matchers.Not;
-import org.mockito.internal.matchers.Or;
-
 import static java.util.Collections.emptyList;
+
 import static org.mockito.internal.exceptions.Reporter.incorrectUseOfAdditionalMatchers;
 import static org.mockito.internal.exceptions.Reporter.misplacedArgumentMatcher;
 import static org.mockito.internal.exceptions.Reporter.reportNoSubMatchersFound;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.matchers.And;
+import org.mockito.internal.matchers.LocalizedMatcher;
+import org.mockito.internal.matchers.Not;
+import org.mockito.internal.matchers.Or;
 
 public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
 
     private static final int TWO_SUB_MATCHERS = 2;
     private static final int ONE_SUB_MATCHER = 1;
-    private final Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();
+    private final Stack<LocalizedMatcher> matcherStack = new Stack<>();
 
+    @Override
     public void reportMatcher(ArgumentMatcher<?> matcher) {
         matcherStack.push(new LocalizedMatcher(matcher));
     }
 
+    @Override
     public List<LocalizedMatcher> pullLocalizedMatchers() {
         if (matcherStack.isEmpty()) {
             return emptyList();
         }
 
-        List<LocalizedMatcher> lastMatchers = resetStack();
-        return lastMatchers;
+        return resetStack();
     }
 
     public void reportAnd() {
@@ -46,6 +48,7 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
         reportMatcher(new And(m1, m2));
     }
 
+    @Override
     public void reportOr() {
         assertStateFor("Or(?)", TWO_SUB_MATCHERS);
 
@@ -55,6 +58,7 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
         reportMatcher(new Or(m1, m2));
     }
 
+    @Override
     public void reportNot() {
         assertStateFor("Not(?)", ONE_SUB_MATCHER);
 
@@ -63,6 +67,7 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
         reportMatcher(new Not(m));
     }
 
+    @Override
     public void validateState() {
         if (!matcherStack.isEmpty()) {
             List<LocalizedMatcher> lastMatchers = resetStack();
@@ -70,6 +75,7 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
         }
     }
 
+    @Override
     public void reset() {
         matcherStack.clear();
     }
@@ -80,7 +86,8 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
         }
         if (matcherStack.size() < subMatchersCount) {
             List<LocalizedMatcher> lastMatchers = resetStack();
-            throw incorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount, lastMatchers);
+            throw incorrectUseOfAdditionalMatchers(
+                    additionalMatcherName, subMatchersCount, lastMatchers);
         }
     }
 
@@ -89,9 +96,8 @@ public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {
     }
 
     private List<LocalizedMatcher> resetStack() {
-        ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
+        ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<>(matcherStack);
         reset();
         return lastMatchers;
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/progress/MockingProgress.java b/src/main/java/org/mockito/internal/progress/MockingProgress.java
index 47bc900..abdf68d 100644
--- a/src/main/java/org/mockito/internal/progress/MockingProgress.java
+++ b/src/main/java/org/mockito/internal/progress/MockingProgress.java
@@ -2,10 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
 import java.util.Set;
+
 import org.mockito.listeners.MockitoListener;
 import org.mockito.listeners.VerificationListener;
 import org.mockito.mock.MockCreationSettings;
@@ -43,6 +43,8 @@ public interface MockingProgress {
 
     void mockingStarted(Object mock, MockCreationSettings settings);
 
+    void mockingStarted(Class<?> mock, MockCreationSettings settings);
+
     void addListener(MockitoListener listener);
 
     void removeListener(MockitoListener listener);
diff --git a/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java b/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
index 5c4fbbc..991b5e4 100644
--- a/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
+++ b/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
+import static org.mockito.internal.exceptions.Reporter.unfinishedStubbing;
+import static org.mockito.internal.exceptions.Reporter.unfinishedVerificationException;
+
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.internal.configuration.GlobalConfiguration;
 import org.mockito.internal.debugging.Localized;
 import org.mockito.internal.debugging.LocationImpl;
@@ -19,14 +26,6 @@ import org.mockito.stubbing.OngoingStubbing;
 import org.mockito.verification.VerificationMode;
 import org.mockito.verification.VerificationStrategy;
 
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import static org.mockito.internal.exceptions.Reporter.unfinishedStubbing;
-import static org.mockito.internal.exceptions.Reporter.unfinishedVerificationException;
-
 @SuppressWarnings("unchecked")
 public class MockingProgressImpl implements MockingProgress {
 
@@ -36,7 +35,7 @@ public class MockingProgressImpl implements MockingProgress {
     private Localized<VerificationMode> verificationMode;
     private Location stubbingInProgress = null;
     private VerificationStrategy verificationStrategy;
-    private final Set<MockitoListener> listeners = new LinkedHashSet<MockitoListener>();
+    private final Set<MockitoListener> listeners = new LinkedHashSet<>();
 
     public MockingProgressImpl() {
         this.verificationStrategy = getDefaultVerificationStrategy();
@@ -44,16 +43,19 @@ public class MockingProgressImpl implements MockingProgress {
 
     public static VerificationStrategy getDefaultVerificationStrategy() {
         return new VerificationStrategy() {
+            @Override
             public VerificationMode maybeVerifyLazily(VerificationMode mode) {
                 return mode;
             }
         };
     }
 
+    @Override
     public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {
         this.ongoingStubbing = ongoingStubbing;
     }
 
+    @Override
     public OngoingStubbing<?> pullOngoingStubbing() {
         OngoingStubbing<?> temp = ongoingStubbing;
         ongoingStubbing = null;
@@ -62,7 +64,7 @@ public class MockingProgressImpl implements MockingProgress {
 
     @Override
     public Set<VerificationListener> verificationListeners() {
-        final LinkedHashSet<VerificationListener> verificationListeners = new LinkedHashSet<VerificationListener>();
+        final LinkedHashSet<VerificationListener> verificationListeners = new LinkedHashSet<>();
 
         for (MockitoListener listener : listeners) {
             if (listener instanceof VerificationListener) {
@@ -73,20 +75,23 @@ public class MockingProgressImpl implements MockingProgress {
         return verificationListeners;
     }
 
-
+    @Override
     public void verificationStarted(VerificationMode verify) {
         validateState();
         resetOngoingStubbing();
         verificationMode = new Localized(verify);
     }
 
-    /* (non-Javadoc)
+    /**
+     * (non-Javadoc)
+     *
      * @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing()
      */
     public void resetOngoingStubbing() {
         ongoingStubbing = null;
     }
 
+    @Override
     public VerificationMode pullVerificationMode() {
         if (verificationMode == null) {
             return null;
@@ -97,15 +102,17 @@ public class MockingProgressImpl implements MockingProgress {
         return temp;
     }
 
+    @Override
     public void stubbingStarted() {
         validateState();
         stubbingInProgress = new LocationImpl();
     }
 
+    @Override
     public void validateState() {
         validateMostStuff();
 
-        //validate stubbing:
+        // validate stubbing:
         if (stubbingInProgress != null) {
             Location temp = stubbingInProgress;
             stubbingInProgress = null;
@@ -114,8 +121,9 @@ public class MockingProgressImpl implements MockingProgress {
     }
 
     private void validateMostStuff() {
-        //State is cool when GlobalConfiguration is already loaded
-        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class
+        // State is cool when GlobalConfiguration is already loaded
+        // this cannot really be tested functionally because I cannot dynamically mess up
+        // org.mockito.configuration.MockitoConfiguration class
         GlobalConfiguration.validate();
 
         if (verificationMode != null) {
@@ -127,26 +135,34 @@ public class MockingProgressImpl implements MockingProgress {
         getArgumentMatcherStorage().validateState();
     }
 
+    @Override
     public void stubbingCompleted() {
         stubbingInProgress = null;
     }
 
+    @Override
     public String toString() {
-        return  "ongoingStubbing: " + ongoingStubbing +
-        ", verificationMode: " + verificationMode +
-        ", stubbingInProgress: " + stubbingInProgress;
+        return "ongoingStubbing: "
+                + ongoingStubbing
+                + ", verificationMode: "
+                + verificationMode
+                + ", stubbingInProgress: "
+                + stubbingInProgress;
     }
 
+    @Override
     public void reset() {
         stubbingInProgress = null;
         verificationMode = null;
         getArgumentMatcherStorage().reset();
     }
 
+    @Override
     public ArgumentMatcherStorage getArgumentMatcherStorage() {
         return argumentMatcherStorage;
     }
 
+    @Override
     public void mockingStarted(Object mock, MockCreationSettings settings) {
         for (MockitoListener listener : listeners) {
             if (listener instanceof MockCreationListener) {
@@ -156,55 +172,70 @@ public class MockingProgressImpl implements MockingProgress {
         validateMostStuff();
     }
 
+    @Override
+    public void mockingStarted(Class<?> mock, MockCreationSettings settings) {
+        for (MockitoListener listener : listeners) {
+            if (listener instanceof MockCreationListener) {
+                ((MockCreationListener) listener).onStaticMockCreated(mock, settings);
+            }
+        }
+        validateMostStuff();
+    }
+
+    @Override
     public void addListener(MockitoListener listener) {
         addListener(listener, listeners);
     }
 
     static void addListener(MockitoListener listener, Set<MockitoListener> listeners) {
-        List<MockitoListener> delete = new LinkedList<MockitoListener>();
+        List<MockitoListener> delete = new LinkedList<>();
         for (MockitoListener existing : listeners) {
             if (existing.getClass().equals(listener.getClass())) {
-                if (existing instanceof AutoCleanableListener && ((AutoCleanableListener) existing).isListenerDirty()) {
-                    //dirty listener means that there was an exception even before the test started
-                    //if we fail here with redundant mockito listener exception there will be multiple failures causing confusion
-                    //so we simply remove the existing listener and move on
+                if (existing instanceof AutoCleanableListener
+                        && ((AutoCleanableListener) existing).isListenerDirty()) {
+                    // dirty listener means that there was an exception even before the test started
+                    // if we fail here with redundant mockito listener exception there will be
+                    // multiple failures causing confusion
+                    // so we simply remove the existing listener and move on
                     delete.add(existing);
                 } else {
                     Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
                 }
             }
         }
-        //delete dirty listeners so they don't occupy state/memory and don't receive notifications
-        for (MockitoListener toDelete : delete) {
-            listeners.remove(toDelete);
-        }
+        // delete dirty listeners so they don't occupy state/memory and don't receive notifications
+        listeners.removeAll(delete);
         listeners.add(listener);
     }
 
+    @Override
     public void removeListener(MockitoListener listener) {
         this.listeners.remove(listener);
     }
 
+    @Override
     public void setVerificationStrategy(VerificationStrategy strategy) {
         this.verificationStrategy = strategy;
     }
 
+    @Override
     public VerificationMode maybeVerifyLazily(VerificationMode mode) {
         return this.verificationStrategy.maybeVerifyLazily(mode);
     }
 
+    @Override
     public void clearListeners() {
         listeners.clear();
     }
 
-     /*
+    /*
 
-     //TODO 545 thread safety of all mockito
+    //TODO 545 thread safety of all mockito
 
-     use cases:
-        - single threaded execution throughout
-        - single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
-        - thread per test case
+    use cases:
+       - single threaded execution throughout
+       - single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
+       - thread per test case
 
-     */
+    */
 }
diff --git a/src/main/java/org/mockito/internal/progress/SequenceNumber.java b/src/main/java/org/mockito/internal/progress/SequenceNumber.java
index bc7a07d..50e45cc 100644
--- a/src/main/java/org/mockito/internal/progress/SequenceNumber.java
+++ b/src/main/java/org/mockito/internal/progress/SequenceNumber.java
@@ -4,11 +4,13 @@
  */
 package org.mockito.internal.progress;
 
-public class SequenceNumber {
+public final class SequenceNumber {
 
     private static int sequenceNumber = 1;
 
     public static synchronized int next() {
         return sequenceNumber++;
     }
+
+    private SequenceNumber() {}
 }
diff --git a/src/main/java/org/mockito/internal/progress/ThreadSafeMockingProgress.java b/src/main/java/org/mockito/internal/progress/ThreadSafeMockingProgress.java
index 4735a11..adb9b99 100644
--- a/src/main/java/org/mockito/internal/progress/ThreadSafeMockingProgress.java
+++ b/src/main/java/org/mockito/internal/progress/ThreadSafeMockingProgress.java
@@ -9,15 +9,15 @@ package org.mockito.internal.progress;
  */
 public class ThreadSafeMockingProgress {
 
-    private static final ThreadLocal<MockingProgress> MOCKING_PROGRESS_PROVIDER = new ThreadLocal<MockingProgress>() {
-        @Override
-        protected MockingProgress initialValue() {
-            return new MockingProgressImpl();
-        }
-    };
+    private static final ThreadLocal<MockingProgress> MOCKING_PROGRESS_PROVIDER =
+            new ThreadLocal<MockingProgress>() {
+                @Override
+                protected MockingProgress initialValue() {
+                    return new MockingProgressImpl();
+                }
+            };
 
-    private ThreadSafeMockingProgress() {
-    }
+    private ThreadSafeMockingProgress() {}
 
     /**
      * Returns the {@link MockingProgress} for the current Thread.
@@ -26,7 +26,7 @@ public class ThreadSafeMockingProgress {
      *
      * @return never <code>null</code>
      */
-    public final static MockingProgress mockingProgress() {
+    public static final MockingProgress mockingProgress() {
         return MOCKING_PROGRESS_PROVIDER.get();
     }
 }
diff --git a/src/main/java/org/mockito/internal/reporting/Pluralizer.java b/src/main/java/org/mockito/internal/reporting/Pluralizer.java
index 1e8d0e3..a8b083f 100644
--- a/src/main/java/org/mockito/internal/reporting/Pluralizer.java
+++ b/src/main/java/org/mockito/internal/reporting/Pluralizer.java
@@ -4,7 +4,7 @@
  */
 package org.mockito.internal.reporting;
 
-public class Pluralizer {
+public final class Pluralizer {
 
     public static String pluralize(int number) {
         return number == 1 ? "1 time" : number + " times";
@@ -17,4 +17,6 @@ public class Pluralizer {
             return "were exactly " + x + " interactions";
         }
     }
+
+    private Pluralizer() {}
 }
diff --git a/src/main/java/org/mockito/internal/reporting/PrintSettings.java b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
index 7986c35..41794ad 100644
--- a/src/main/java/org/mockito/internal/reporting/PrintSettings.java
+++ b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
@@ -4,22 +4,24 @@
  */
 package org.mockito.internal.reporting;
 
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.ArgumentMatcher;
-import org.mockito.internal.invocation.ArgumentsProcessor;
 import org.mockito.internal.matchers.text.MatchersPrinter;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-
 public class PrintSettings {
 
     public static final int MAX_LINE_LENGTH = 45;
     private boolean multiline;
-    private List<Integer> withTypeInfo = new LinkedList<Integer>();
+    private List<Integer> withTypeInfo = new LinkedList<>();
+    private Set<String> withFullyQualifiedName = Collections.emptySet();
 
     public void setMultiline(boolean multiline) {
         this.multiline = multiline;
@@ -29,7 +31,7 @@ public class PrintSettings {
         return multiline;
     }
 
-    public static PrintSettings verboseMatchers(Integer ... indexesOfMatchers) {
+    public static PrintSettings verboseMatchers(Integer... indexesOfMatchers) {
         PrintSettings settings = new PrintSettings();
         settings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchers);
         return settings;
@@ -39,13 +41,22 @@ public class PrintSettings {
         return withTypeInfo.contains(argumentIndex);
     }
 
+    public boolean fullyQualifiedNameFor(String simpleClassName) {
+        return withFullyQualifiedName.contains(simpleClassName);
+    }
+
     public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {
         this.withTypeInfo = Arrays.asList(indexesOfMatchers);
     }
 
+    public void setMatchersToBeDescribedWithFullName(Set<String> indexesOfMatchers) {
+        this.withFullyQualifiedName = indexesOfMatchers;
+    }
+
     public String print(List<ArgumentMatcher> matchers, Invocation invocation) {
         MatchersPrinter matchersPrinter = new MatchersPrinter();
-        String qualifiedName = MockUtil.getMockName(invocation.getMock()) + "." + invocation.getMethod().getName();
+        String qualifiedName =
+                MockUtil.getMockName(invocation.getMock()) + "." + invocation.getMethod().getName();
         String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);
         if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > MAX_LINE_LENGTH)) {
             return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);
@@ -55,7 +66,7 @@ public class PrintSettings {
     }
 
     public String print(Invocation invocation) {
-        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);
+        return print(invocation.getArgumentsAsMatchers(), invocation);
     }
 
     public String print(MatchableInvocation invocation) {
diff --git a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
index 8da053d..f4b1f71 100644
--- a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
+++ b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.reporting;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
 
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
@@ -16,22 +20,54 @@ import org.mockito.invocation.MatchableInvocation;
 public class SmartPrinter {
 
     private final String wanted;
-    private final String actual;
+    private final List<String> actuals;
 
-    public SmartPrinter(MatchableInvocation wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
+    public SmartPrinter(
+            MatchableInvocation wanted,
+            Invocation actual,
+            Integer... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
+        this(
+                wanted,
+                Collections.singletonList(actual),
+                indexesOfMatchersToBeDescribedWithExtraTypeInfo,
+                Collections.emptySet());
+    }
+
+    public SmartPrinter(
+            MatchableInvocation wanted,
+            List<Invocation> allActualInvocations,
+            Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo,
+            Set<String> classNamesToBeDescribedWithFullName) {
         PrintSettings printSettings = new PrintSettings();
-        printSettings.setMultiline(wanted.toString().contains("\n") || actual.toString().contains("\n"));
-        printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);
+        printSettings.setMultiline(isMultiLine(wanted, allActualInvocations));
+        printSettings.setMatchersToBeDescribedWithExtraTypeInfo(
+                indexesOfMatchersToBeDescribedWithExtraTypeInfo);
+        printSettings.setMatchersToBeDescribedWithFullName(classNamesToBeDescribedWithFullName);
 
         this.wanted = printSettings.print(wanted);
-        this.actual = printSettings.print(actual);
+
+        List<String> actuals = new ArrayList<>();
+        for (Invocation actual : allActualInvocations) {
+            actuals.add(printSettings.print(actual));
+        }
+        this.actuals = Collections.unmodifiableList(actuals);
     }
 
     public String getWanted() {
         return wanted;
     }
 
-    public String getActual() {
-        return actual;
+    public List<String> getActuals() {
+        return actuals;
+    }
+
+    private static boolean isMultiLine(
+            MatchableInvocation wanted, List<Invocation> allActualInvocations) {
+        boolean isWantedMultiline = wanted.toString().contains("\n");
+        boolean isAnyActualMultiline = false;
+        for (Invocation invocation : allActualInvocations) {
+            isAnyActualMultiline |= invocation.toString().contains("\n");
+        }
+        return isWantedMultiline || isAnyActualMultiline;
     }
 }
diff --git a/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java b/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java
index 2f26ff1..6b69b82 100644
--- a/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java
+++ b/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java
@@ -24,71 +24,95 @@ public class DefaultInternalRunner implements InternalRunner {
 
     private final BlockJUnit4ClassRunner runner;
 
-    public DefaultInternalRunner(Class<?> testClass, final Supplier<MockitoTestListener> listenerSupplier) throws InitializationError {
-        runner = new BlockJUnit4ClassRunner(testClass) {
+    public DefaultInternalRunner(
+            Class<?> testClass, final Supplier<MockitoTestListener> listenerSupplier)
+            throws InitializationError {
+        runner =
+                new BlockJUnit4ClassRunner(testClass) {
 
-            public Object target;
-            private MockitoTestListener mockitoTestListener;
-
-            protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {
-                this.target = target;
-                // get new test listener and add it to the framework
-                mockitoTestListener = listenerSupplier.get();
-                Mockito.framework().addListener(mockitoTestListener);
-                // init annotated mocks before tests
-                MockitoAnnotations.initMocks(target);
-                return super.withBefores(method, target, statement);
-            }
-
-            public void run(final RunNotifier notifier) {
-                RunListener listener = new RunListener() {
-                    private boolean started;
-                    Throwable failure;
+                    public Object target;
+                    private MockitoTestListener mockitoTestListener;
 
                     @Override
-                    public void testStarted(Description description) throws Exception {
-                        started = true;
+                    protected Statement withBefores(
+                            FrameworkMethod method, final Object target, Statement statement) {
+                        this.target = target;
+                        final Statement base = super.withBefores(method, target, statement);
+                        return new Statement() {
+                            @Override
+                            public void evaluate() throws Throwable {
+                                AutoCloseable closeable;
+                                if (mockitoTestListener == null) {
+                                    // get new test listener and add it to the framework
+                                    mockitoTestListener = listenerSupplier.get();
+                                    Mockito.framework().addListener(mockitoTestListener);
+                                    // init annotated mocks before tests
+                                    closeable = MockitoAnnotations.openMocks(target);
+                                } else {
+                                    closeable = null;
+                                }
+                                try {
+                                    base.evaluate();
+                                } finally {
+                                    if (closeable != null) {
+                                        closeable.close();
+                                    }
+                                }
+                            }
+                        };
                     }
 
-                    @Override
-                    public void testFailure(Failure failure) throws Exception {
-                        this.failure = failure.getException();
-                        // If the test fails during the setup, `testFinished` is never invoked
-                        // Therefore, if we have not started, cleanup the testlistener
-                        if (!started && mockitoTestListener != null) {
-                            Mockito.framework().removeListener(mockitoTestListener);
-                        }
-                    }
+                    public void run(final RunNotifier notifier) {
+                        RunListener listener =
+                                new RunListener() {
+                                    Throwable failure;
 
-                    @Override
-                    public void testFinished(Description description) throws Exception {
-                        try {
-                            if (mockitoTestListener != null) {
-                                Mockito.framework().removeListener(mockitoTestListener);
-                                mockitoTestListener.testFinished(new DefaultTestFinishedEvent(target, description.getMethodName(), failure));
-                            }
-                            Mockito.validateMockitoUsage();
-                        } catch (Throwable t) {
-                            //In order to produce clean exception to the user we need to fire test failure with the right description
-                            //Otherwise JUnit framework will report failure with some generic test name
-                            notifier.fireTestFailure(new Failure(description, t));
-                        }
+                                    @Override
+                                    public void testFailure(Failure failure) throws Exception {
+                                        this.failure = failure.getException();
+                                    }
+
+                                    @Override
+                                    public void testFinished(Description description)
+                                            throws Exception {
+                                        try {
+                                            if (mockitoTestListener != null) {
+                                                Mockito.framework()
+                                                        .removeListener(mockitoTestListener);
+                                                mockitoTestListener.testFinished(
+                                                        new DefaultTestFinishedEvent(
+                                                                target,
+                                                                description.getMethodName(),
+                                                                failure));
+                                                mockitoTestListener = null;
+                                            }
+                                            Mockito.validateMockitoUsage();
+                                        } catch (Throwable t) {
+                                            // In order to produce clean exception to the user we
+                                            // need to fire test failure with the right description
+                                            // Otherwise JUnit framework will report failure with
+                                            // some generic test name
+                                            notifier.fireTestFailure(new Failure(description, t));
+                                        }
+                                    }
+                                };
+                        notifier.addListener(listener);
+                        super.run(notifier);
                     }
                 };
-                notifier.addListener(listener);
-                super.run(notifier);
-            }
-        };
     }
 
+    @Override
     public void run(final RunNotifier notifier) {
         runner.run(notifier);
     }
 
+    @Override
     public Description getDescription() {
         return runner.getDescription();
     }
 
+    @Override
     public void filter(Filter filter) throws NoTestsRemainException {
         runner.filter(filter);
     }
diff --git a/src/main/java/org/mockito/internal/runners/InternalRunner.java b/src/main/java/org/mockito/internal/runners/InternalRunner.java
index 85b2f3c..d06d005 100644
--- a/src/main/java/org/mockito/internal/runners/InternalRunner.java
+++ b/src/main/java/org/mockito/internal/runners/InternalRunner.java
@@ -17,5 +17,4 @@ public interface InternalRunner extends Filterable {
     void run(RunNotifier notifier);
 
     Description getDescription();
-
 }
diff --git a/src/main/java/org/mockito/internal/runners/RunnerFactory.java b/src/main/java/org/mockito/internal/runners/RunnerFactory.java
index 61456dc..369dc8b 100644
--- a/src/main/java/org/mockito/internal/runners/RunnerFactory.java
+++ b/src/main/java/org/mockito/internal/runners/RunnerFactory.java
@@ -4,44 +4,46 @@
  */
 package org.mockito.internal.runners;
 
+import static org.mockito.internal.runners.util.TestMethodsFinder.hasTestMethods;
+
+import java.lang.reflect.InvocationTargetException;
+
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.junit.MismatchReportingTestListener;
 import org.mockito.internal.junit.MockitoTestListener;
 import org.mockito.internal.junit.NoOpTestListener;
 import org.mockito.internal.junit.StrictStubsRunnerTestListener;
 import org.mockito.internal.runners.util.RunnerProvider;
-import org.mockito.internal.util.ConsoleMockitoLogger;
 import org.mockito.internal.util.Supplier;
 
-import java.lang.reflect.InvocationTargetException;
-
-import static org.mockito.internal.runners.util.TestMethodsFinder.hasTestMethods;
-
 /**
  * Creates instances of Mockito JUnit Runner in a safe way, e.g. detecting inadequate version of JUnit, etc.
  */
 public class RunnerFactory {
 
-    /**
-     * Creates silent runner implementation
-     */
+    /** Creates silent runner implementation */
     public InternalRunner create(Class<?> klass) throws InvocationTargetException {
-        return create(klass, new Supplier<MockitoTestListener>() {
-            public MockitoTestListener get() {
-                return new NoOpTestListener();
-            }
-        });
+        return create(
+                klass,
+                new Supplier<MockitoTestListener>() {
+                    public MockitoTestListener get() {
+                        return new NoOpTestListener();
+                    }
+                });
     }
 
     /**
      * Creates strict runner implementation
      */
     public InternalRunner createStrict(Class<?> klass) throws InvocationTargetException {
-        return create(klass, new Supplier<MockitoTestListener>() {
-            public MockitoTestListener get() {
-                return new MismatchReportingTestListener(new ConsoleMockitoLogger());
-            }
-        });
+        return create(
+                klass,
+                new Supplier<MockitoTestListener>() {
+                    public MockitoTestListener get() {
+                        return new MismatchReportingTestListener(Plugins.getMockitoLogger());
+                    }
+                });
     }
 
     /**
@@ -50,43 +52,49 @@ public class RunnerFactory {
      * TODO, let's try to apply Brice suggestion and use switch + Strictness
      */
     public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
-        return create(klass, new Supplier<MockitoTestListener>() {
-            public MockitoTestListener get() {
-                return new StrictStubsRunnerTestListener();
-            }
-        });
+        return create(
+                klass,
+                new Supplier<MockitoTestListener>() {
+                    public MockitoTestListener get() {
+                        return new StrictStubsRunnerTestListener();
+                    }
+                });
     }
 
     /**
      * Creates runner implementation with provided listener supplier
      */
-    public InternalRunner create(Class<?> klass, Supplier<MockitoTestListener> listenerSupplier) throws InvocationTargetException {
+    public InternalRunner create(Class<?> klass, Supplier<MockitoTestListener> listenerSupplier)
+            throws InvocationTargetException {
         try {
             String runnerClassName = "org.mockito.internal.runners.DefaultInternalRunner";
-            //Warning: I'm using String literal on purpose!
-            //When JUnit is not on classpath, we want the code to throw exception here so that we can catch it
-            //If we statically link the class, we will get Error when class is loaded
+            // Warning: I'm using String literal on purpose!
+            // When JUnit is not on classpath, we want the code to throw exception here so that we
+            // can catch it
+            // If we statically link the class, we will get Error when class is loaded
             return new RunnerProvider().newInstance(runnerClassName, klass, listenerSupplier);
         } catch (InvocationTargetException e) {
             if (!hasTestMethods(klass)) {
                 throw new MockitoException(
-                    "\n" +
-                    "\n" +
-                    "No tests found in " + klass.getSimpleName() + "\n" +
-                    "Is the method annotated with @Test?\n" +
-                    "Is the method public?\n"
-                    , e);
+                        "\n"
+                                + "\n"
+                                + "No tests found in "
+                                + klass.getSimpleName()
+                                + "\n"
+                                + "Is the method annotated with @Test?\n"
+                                + "Is the method public?\n",
+                        e);
             }
             throw e;
         } catch (Throwable t) {
             throw new MockitoException(
-                    "\n" +
-                    "\n" +
-                    "MockitoRunner can only be used with JUnit 4.5 or higher.\n" +
-                    "You can upgrade your JUnit version or write your own Runner (please consider contributing your runner to the Mockito community).\n" +
-                    "Bear in mind that you can still enjoy all features of the framework without using runners (they are completely optional).\n" +
-                    "If you get this error despite using JUnit 4.5 or higher then please report this error to the mockito mailing list.\n"
-                    , t);
+                    "\n"
+                            + "\n"
+                            + "MockitoRunner can only be used with JUnit 4.5 or higher.\n"
+                            + "You can upgrade your JUnit version or write your own Runner (please consider contributing your runner to the Mockito community).\n"
+                            + "Bear in mind that you can still enjoy all features of the framework without using runners (they are completely optional).\n"
+                            + "If you get this error despite using JUnit 4.5 or higher then please report this error to the mockito mailing list.\n",
+                    t);
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/runners/StrictRunner.java b/src/main/java/org/mockito/internal/runners/StrictRunner.java
index d87289f..b3ea774 100644
--- a/src/main/java/org/mockito/internal/runners/StrictRunner.java
+++ b/src/main/java/org/mockito/internal/runners/StrictRunner.java
@@ -27,8 +27,10 @@ public class StrictRunner implements InternalRunner {
         this.testClass = testClass;
     }
 
+    @Override
     public void run(RunNotifier notifier) {
-        //TODO need to be able to opt in for full stack trace instead of just relying on the stack trace filter
+        // TODO need to be able to opt in for full stack trace instead of just relying on the stack
+        // trace filter
         UnnecessaryStubbingsReporter reporter = new UnnecessaryStubbingsReporter();
         FailureDetector listener = new FailureDetector();
 
@@ -42,18 +44,22 @@ public class StrictRunner implements InternalRunner {
         }
 
         if (!filterRequested && listener.isSuccessful()) {
-            //only report when:
-            //1. if all tests from given test have ran (filter requested is false)
-            //   Otherwise we would report unnecessary stubs even if the user runs just single test from the class
-            //2. tests are successful (we don't want to add an extra failure on top of any existing failure, to avoid confusion)
+            // only report when:
+            // 1. if all tests from given test have ran (filter requested is false)
+            //   Otherwise we would report unnecessary stubs even if the user runs just single test
+            // from the class
+            // 2. tests are successful (we don't want to add an extra failure on top of any existing
+            // failure, to avoid confusion)
             reporter.validateUnusedStubs(testClass, notifier);
         }
     }
 
+    @Override
     public Description getDescription() {
         return runner.getDescription();
     }
 
+    @Override
     public void filter(Filter filter) throws NoTestsRemainException {
         filterRequested = true;
         runner.filter(filter);
diff --git a/src/main/java/org/mockito/internal/runners/util/RunnerProvider.java b/src/main/java/org/mockito/internal/runners/util/RunnerProvider.java
index e3ed92a..30c6c4c 100644
--- a/src/main/java/org/mockito/internal/runners/util/RunnerProvider.java
+++ b/src/main/java/org/mockito/internal/runners/util/RunnerProvider.java
@@ -4,19 +4,21 @@
  */
 package org.mockito.internal.runners.util;
 
-import org.mockito.internal.runners.InternalRunner;
-
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 
+import org.mockito.internal.runners.InternalRunner;
+
 public class RunnerProvider {
 
-    public InternalRunner newInstance(String runnerClassName, Object ... constructorArgs) throws Exception {
+    public InternalRunner newInstance(String runnerClassName, Object... constructorArgs)
+            throws Exception {
         Constructor<?> constructor;
         try {
             Class<?> runnerClass = Class.forName(runnerClassName);
             if (runnerClass.getConstructors().length != 1) {
-                throw new IllegalArgumentException("Expected " + runnerClassName + " to have exactly one constructor.");
+                throw new IllegalArgumentException(
+                        "Expected " + runnerClassName + " to have exactly one constructor.");
             }
             constructor = runnerClass.getConstructors()[0];
         } catch (Exception e) {
diff --git a/src/main/java/org/mockito/internal/runners/util/TestMethodsFinder.java b/src/main/java/org/mockito/internal/runners/util/TestMethodsFinder.java
index f435df3..40d71ea 100644
--- a/src/main/java/org/mockito/internal/runners/util/TestMethodsFinder.java
+++ b/src/main/java/org/mockito/internal/runners/util/TestMethodsFinder.java
@@ -4,17 +4,17 @@
  */
 package org.mockito.internal.runners.util;
 
-import org.junit.Test;
-
 import java.lang.reflect.Method;
 
+import org.junit.Test;
+
 public class TestMethodsFinder {
 
     private TestMethodsFinder() {}
 
     public static boolean hasTestMethods(Class<?> klass) {
         Method[] methods = klass.getMethods();
-        for(Method m:methods) {
+        for (Method m : methods) {
             if (m.isAnnotationPresent(Test.class)) {
                 return true;
             }
diff --git a/src/main/java/org/mockito/internal/session/DefaultMockitoSessionBuilder.java b/src/main/java/org/mockito/internal/session/DefaultMockitoSessionBuilder.java
index d9b21e5..6fe3dcb 100644
--- a/src/main/java/org/mockito/internal/session/DefaultMockitoSessionBuilder.java
+++ b/src/main/java/org/mockito/internal/session/DefaultMockitoSessionBuilder.java
@@ -4,22 +4,22 @@
  */
 package org.mockito.internal.session;
 
+import static java.util.Collections.emptyList;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.mockito.MockitoSession;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.framework.DefaultMockitoSession;
-import org.mockito.internal.util.ConsoleMockitoLogger;
-import org.mockito.internal.util.MockitoLogger;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.quality.Strictness;
 import org.mockito.session.MockitoSessionBuilder;
 import org.mockito.session.MockitoSessionLogger;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import static java.util.Collections.emptyList;
-
 public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
 
-    private List<Object> testClassInstances = new ArrayList<Object>();
+    private final List<Object> testClassInstances = new ArrayList<Object>();
     private String name;
     private Strictness strictness;
     private MockitoSessionLogger logger;
@@ -62,19 +62,25 @@ public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
 
     @Override
     public MockitoSession startMocking() {
-        //Configure default values
+        // Configure default values
         List<Object> effectiveTestClassInstances;
         String effectiveName;
         if (testClassInstances.isEmpty()) {
             effectiveTestClassInstances = emptyList();
             effectiveName = this.name == null ? "<Unnamed Session>" : this.name;
         } else {
-            effectiveTestClassInstances = new ArrayList<Object>(testClassInstances);
+            effectiveTestClassInstances = new ArrayList<>(testClassInstances);
             Object lastTestClassInstance = testClassInstances.get(testClassInstances.size() - 1);
-            effectiveName = this.name == null ? lastTestClassInstance.getClass().getName() : this.name;
+            effectiveName =
+                    this.name == null ? lastTestClassInstance.getClass().getName() : this.name;
         }
-        Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
-        MockitoLogger logger = this.logger == null ? new ConsoleMockitoLogger() : new MockitoLoggerAdapter(this.logger);
-        return new DefaultMockitoSession(effectiveTestClassInstances, effectiveName, effectiveStrictness, logger);
+        Strictness effectiveStrictness =
+                this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
+        MockitoLogger logger =
+                this.logger == null
+                        ? Plugins.getMockitoLogger()
+                        : new MockitoLoggerAdapter(this.logger);
+        return new DefaultMockitoSession(
+                effectiveTestClassInstances, effectiveName, effectiveStrictness, logger);
     }
 }
diff --git a/src/main/java/org/mockito/internal/session/MockitoLoggerAdapter.java b/src/main/java/org/mockito/internal/session/MockitoLoggerAdapter.java
index b7329e7..2197317 100644
--- a/src/main/java/org/mockito/internal/session/MockitoLoggerAdapter.java
+++ b/src/main/java/org/mockito/internal/session/MockitoLoggerAdapter.java
@@ -4,7 +4,7 @@
  */
 package org.mockito.internal.session;
 
-import org.mockito.internal.util.MockitoLogger;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.session.MockitoSessionLogger;
 
 class MockitoLoggerAdapter implements MockitoLogger {
diff --git a/src/main/java/org/mockito/internal/session/MockitoSessionLoggerAdapter.java b/src/main/java/org/mockito/internal/session/MockitoSessionLoggerAdapter.java
index 2e8634b..f4770c5 100644
--- a/src/main/java/org/mockito/internal/session/MockitoSessionLoggerAdapter.java
+++ b/src/main/java/org/mockito/internal/session/MockitoSessionLoggerAdapter.java
@@ -4,7 +4,7 @@
  */
 package org.mockito.internal.session;
 
-import org.mockito.internal.util.MockitoLogger;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.session.MockitoSessionLogger;
 
 public class MockitoSessionLoggerAdapter implements MockitoSessionLogger {
diff --git a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
index 6dd99cd..7a59cf1 100644
--- a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
+++ b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
@@ -6,15 +6,29 @@ package org.mockito.internal.stubbing;
 
 import static org.mockito.internal.exceptions.Reporter.notAnException;
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-import static org.objenesis.ObjenesisHelper.newInstance;
 
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
+import org.mockito.internal.stubbing.answers.ThrowsExceptionForClassType;
+import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.OngoingStubbing;
 
 public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
 
+    // Keep strong ref to mock preventing premature garbage collection when using 'One-liner stubs'.
+    // See #1541.
+    private final Object strongMockRef;
+
+    BaseStubbing(Object mock) {
+        this.strongMockRef = mock;
+    }
+
+    @Override
+    public OngoingStubbing<T> then(Answer<?> answer) {
+        return thenAnswer(answer);
+    }
+
     @Override
     public OngoingStubbing<T> thenReturn(T value) {
         return thenAnswer(new Returns(value));
@@ -25,7 +39,8 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
         OngoingStubbing<T> stubbing = thenReturn(value);
         if (values == null) {
             // For no good reason we're configuring null answer here
-            // This has been like that since forever, so let's keep it for compatibility (unless users complain)
+            // This has been like that since forever, so let's keep it for compatibility (unless
+            // users complain)
             return stubbing.thenReturn(null);
         }
         for (T v : values) {
@@ -60,11 +75,12 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
             mockingProgress().reset();
             throw notAnException();
         }
-        return thenThrow(newInstance(throwableType));
+        return thenAnswer(new ThrowsExceptionForClassType(throwableType));
     }
 
     @Override
-    public OngoingStubbing<T> thenThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
+    public OngoingStubbing<T> thenThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
         if (nextToBeThrown == null) {
             return thenThrow((Class<Throwable>) null);
         }
@@ -79,6 +95,10 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
     public OngoingStubbing<T> thenCallRealMethod() {
         return thenAnswer(new CallsRealMethods());
     }
-}
-
 
+    @Override
+    @SuppressWarnings("unchecked")
+    public <M> M getMock() {
+        return (M) this.strongMockRef;
+    }
+}
diff --git a/src/main/java/org/mockito/internal/stubbing/ConsecutiveStubbing.java b/src/main/java/org/mockito/internal/stubbing/ConsecutiveStubbing.java
index a5cdc04..e7b269f 100644
--- a/src/main/java/org/mockito/internal/stubbing/ConsecutiveStubbing.java
+++ b/src/main/java/org/mockito/internal/stubbing/ConsecutiveStubbing.java
@@ -8,23 +8,17 @@ import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.OngoingStubbing;
 
 public class ConsecutiveStubbing<T> extends BaseStubbing<T> {
-    private final InvocationContainerImpl invocationContainerImpl;
 
-    public ConsecutiveStubbing(InvocationContainerImpl invocationContainerImpl) {
-        this.invocationContainerImpl = invocationContainerImpl;
+    private final InvocationContainerImpl invocationContainer;
+
+    ConsecutiveStubbing(InvocationContainerImpl invocationContainer) {
+        super(invocationContainer.invokedMock());
+        this.invocationContainer = invocationContainer;
     }
 
+    @Override
     public OngoingStubbing<T> thenAnswer(Answer<?> answer) {
-        invocationContainerImpl.addConsecutiveAnswer(answer);
+        invocationContainer.addConsecutiveAnswer(answer);
         return this;
     }
-
-    public OngoingStubbing<T> then(Answer<?> answer) {
-        return thenAnswer(answer);
-    }
-
-    @SuppressWarnings("unchecked")
-    public <M> M getMock() {
-        return (M) invocationContainerImpl.invokedMock();
-    }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/DefaultLenientStubber.java b/src/main/java/org/mockito/internal/stubbing/DefaultLenientStubber.java
index 0f3fe07..6986c20 100644
--- a/src/main/java/org/mockito/internal/stubbing/DefaultLenientStubber.java
+++ b/src/main/java/org/mockito/internal/stubbing/DefaultLenientStubber.java
@@ -13,7 +13,7 @@ import org.mockito.stubbing.Stubber;
 
 public class DefaultLenientStubber implements LenientStubber {
 
-    private final static MockitoCore MOCKITO_CORE = new MockitoCore();
+    private static final MockitoCore MOCKITO_CORE = new MockitoCore();
 
     @Override
     public Stubber doThrow(Throwable... toBeThrown) {
@@ -26,7 +26,8 @@ public class DefaultLenientStubber implements LenientStubber {
     }
 
     @Override
-    public Stubber doThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
+    public Stubber doThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
         return stubber().doThrow(toBeThrown, nextToBeThrown);
     }
 
@@ -57,7 +58,8 @@ public class DefaultLenientStubber implements LenientStubber {
 
     @Override
     public <T> OngoingStubbing<T> when(T methodCall) {
-        OngoingStubbingImpl<T> ongoingStubbing = (OngoingStubbingImpl) MOCKITO_CORE.when(methodCall);
+        OngoingStubbingImpl<T> ongoingStubbing =
+                (OngoingStubbingImpl) MOCKITO_CORE.when(methodCall);
         ongoingStubbing.setStrictness(Strictness.LENIENT);
         return ongoingStubbing;
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/DoAnswerStyleStubbing.java b/src/main/java/org/mockito/internal/stubbing/DoAnswerStyleStubbing.java
index 56491b8..e143379 100644
--- a/src/main/java/org/mockito/internal/stubbing/DoAnswerStyleStubbing.java
+++ b/src/main/java/org/mockito/internal/stubbing/DoAnswerStyleStubbing.java
@@ -4,19 +4,19 @@
  */
 package org.mockito.internal.stubbing;
 
-import org.mockito.quality.Strictness;
-import org.mockito.stubbing.Answer;
-
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.mockito.quality.Strictness;
+import org.mockito.stubbing.Answer;
+
 /**
  * Holds answers declared using 'doAnswer' stubbing style.
  */
 class DoAnswerStyleStubbing implements Serializable {
 
-    private final List<Answer<?>> answers = new ArrayList<Answer<?>>();
+    private final List<Answer<?>> answers = new ArrayList<>();
     private Strictness stubbingStrictness;
 
     void setAnswers(List<Answer<?>> answers, Strictness stubbingStrictness) {
diff --git a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
index 6c98f37..3091670 100644
--- a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
@@ -4,6 +4,14 @@
  */
 package org.mockito.internal.stubbing;
 
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
 import org.mockito.internal.invocation.StubInfoImpl;
 import org.mockito.internal.verification.DefaultRegisteredInvocations;
 import org.mockito.internal.verification.RegisteredInvocations;
@@ -17,19 +25,11 @@ import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.Stubbing;
 import org.mockito.stubbing.ValidableAnswer;
 
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-
 @SuppressWarnings("unchecked")
 public class InvocationContainerImpl implements InvocationContainer, Serializable {
 
     private static final long serialVersionUID = -5334301962749537177L;
-    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();
+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<>();
     private final DoAnswerStyleStubbing doAnswerStyleStubbing;
     private final RegisteredInvocations registeredInvocations;
     private final Strictness mockStrictness;
@@ -56,14 +56,9 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
         addAnswer(answer, false, stubbingStrictness);
     }
 
-    public void addConsecutiveAnswer(Answer answer) {
-        addAnswer(answer, true, null);
-    }
-
-    /**
-     * Adds new stubbed answer and returns the invocation matcher the answer was added to.
-     */
-    public StubbedInvocationMatcher addAnswer(Answer answer, boolean isConsecutive, Strictness stubbingStrictness) {
+    /** Adds new stubbed answer and returns the invocation matcher the answer was added to. */
+    public StubbedInvocationMatcher addAnswer(
+            Answer answer, boolean isConsecutive, Strictness stubbingStrictness) {
         Invocation invocation = invocationForStubbing.getInvocation();
         mockingProgress().stubbingCompleted();
         if (answer instanceof ValidableAnswer) {
@@ -74,13 +69,20 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
             if (isConsecutive) {
                 stubbed.getFirst().addAnswer(answer);
             } else {
-                Strictness effectiveStrictness = stubbingStrictness != null ? stubbingStrictness : this.mockStrictness;
-                stubbed.addFirst(new StubbedInvocationMatcher(answer, invocationForStubbing, effectiveStrictness));
+                Strictness effectiveStrictness =
+                        stubbingStrictness != null ? stubbingStrictness : this.mockStrictness;
+                stubbed.addFirst(
+                        new StubbedInvocationMatcher(
+                                answer, invocationForStubbing, effectiveStrictness));
             }
             return stubbed.getFirst();
         }
     }
 
+    public void addConsecutiveAnswer(Answer answer) {
+        addAnswer(answer, true, null);
+    }
+
     Object answerTo(Invocation invocation) throws Throwable {
         return findAnswerFor(invocation).answer(invocation);
     }
@@ -90,7 +92,8 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
             for (StubbedInvocationMatcher s : stubbed) {
                 if (s.matches(invocation)) {
                     s.markStubUsed(invocation);
-                    //TODO we should mark stubbed at the point of stubbing, not at the point where the stub is being used
+                    // TODO we should mark stubbed at the point of stubbing, not at the point where
+                    // the stub is being used
                     invocation.markStubbed(new StubInfoImpl(s));
                     return s;
                 }
@@ -119,7 +122,10 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
         invocationForStubbing = invocation;
         assert hasAnswersForStubbing();
         for (int i = 0; i < doAnswerStyleStubbing.getAnswers().size(); i++) {
-            addAnswer(doAnswerStyleStubbing.getAnswers().get(i), i != 0, doAnswerStyleStubbing.getStubbingStrictness());
+            addAnswer(
+                    doAnswerStyleStubbing.getAnswers().get(i),
+                    i != 0,
+                    doAnswerStyleStubbing.getStubbingStrictness());
         }
         doAnswerStyleStubbing.clear();
     }
@@ -148,7 +154,7 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
      * Stubbings in ascending order, most recent last
      */
     public Collection<Stubbing> getStubbingsAscending() {
-        List<Stubbing> result = new LinkedList<Stubbing>(stubbed);
+        List<Stubbing> result = new LinkedList<>(stubbed);
         Collections.reverse(result);
         return result;
     }
@@ -157,13 +163,20 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
         return invocationForStubbing.getInvocation().getMock();
     }
 
-    public MatchableInvocation getInvocationForStubbing() {
-        return invocationForStubbing;
-    }
-
     private RegisteredInvocations createRegisteredInvocations(MockCreationSettings mockSettings) {
         return mockSettings.isStubOnly()
-          ? new SingleRegisteredInvocation()
-          : new DefaultRegisteredInvocations();
+                ? new SingleRegisteredInvocation()
+                : new DefaultRegisteredInvocations();
+    }
+
+    public Answer findStubbedAnswer() {
+        synchronized (stubbed) {
+            for (StubbedInvocationMatcher s : stubbed) {
+                if (invocationForStubbing.matches(s.getInvocation())) {
+                    return s;
+                }
+            }
+        }
+        return null;
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java b/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
index cd27c39..a5bb086 100644
--- a/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
@@ -4,27 +4,28 @@
  */
 package org.mockito.internal.stubbing;
 
+import static org.mockito.internal.exceptions.Reporter.incorrectUseOfApi;
+
+import java.util.List;
+
 import org.mockito.invocation.Invocation;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.OngoingStubbing;
 
-import java.util.List;
-
-import static org.mockito.internal.exceptions.Reporter.incorrectUseOfApi;
-
 public class OngoingStubbingImpl<T> extends BaseStubbing<T> {
 
     private final InvocationContainerImpl invocationContainer;
     private Strictness strictness;
 
     public OngoingStubbingImpl(InvocationContainerImpl invocationContainer) {
+        super(invocationContainer.invokedMock());
         this.invocationContainer = invocationContainer;
     }
 
     @Override
     public OngoingStubbing<T> thenAnswer(Answer<?> answer) {
-        if(!invocationContainer.hasInvocationForPotentialStubbing()) {
+        if (!invocationContainer.hasInvocationForPotentialStubbing()) {
             throw incorrectUseOfApi();
         }
 
@@ -32,25 +33,12 @@ public class OngoingStubbingImpl<T> extends BaseStubbing<T> {
         return new ConsecutiveStubbing<T>(invocationContainer);
     }
 
-    @Override
-    public OngoingStubbing<T> then(Answer<?> answer) {
-        return thenAnswer(answer);
-    }
-
     public List<Invocation> getRegisteredInvocations() {
-        //TODO interface for tests
+        // TODO interface for tests
         return invocationContainer.getInvocations();
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public <M> M getMock() {
-        return (M) invocationContainer.invokedMock();
-    }
-
     public void setStrictness(Strictness strictness) {
         this.strictness = strictness;
     }
 }
-
-
diff --git a/src/main/java/org/mockito/internal/stubbing/StrictnessSelector.java b/src/main/java/org/mockito/internal/stubbing/StrictnessSelector.java
index 6009e93..6422fd5 100644
--- a/src/main/java/org/mockito/internal/stubbing/StrictnessSelector.java
+++ b/src/main/java/org/mockito/internal/stubbing/StrictnessSelector.java
@@ -11,7 +11,7 @@ import org.mockito.stubbing.Stubbing;
 /**
  * Helps determining the actual strictness given that it can be configured in multiple ways (at mock, at stubbing, in rule)
  */
-public class StrictnessSelector {
+public final class StrictnessSelector {
 
     /**
      * Determines the actual strictness in the following importance order:
@@ -25,7 +25,8 @@ public class StrictnessSelector {
      *
      * @return actual strictness, can be null.
      */
-    public static Strictness determineStrictness(Stubbing stubbing, MockCreationSettings mockSettings, Strictness testLevelStrictness) {
+    public static Strictness determineStrictness(
+            Stubbing stubbing, MockCreationSettings mockSettings, Strictness testLevelStrictness) {
         if (stubbing != null && stubbing.getStrictness() != null) {
             return stubbing.getStrictness();
         }
@@ -36,4 +37,6 @@ public class StrictnessSelector {
 
         return testLevelStrictness;
     }
+
+    private StrictnessSelector() {}
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java b/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
index e7ccac4..a4ab2fd 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.stubbing;
 
+import java.io.Serializable;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.invocation.DescribedInvocation;
 import org.mockito.invocation.InvocationOnMock;
@@ -12,28 +16,27 @@ import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.Stubbing;
 
-import java.io.Serializable;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
 @SuppressWarnings("unchecked")
 public class StubbedInvocationMatcher extends InvocationMatcher implements Serializable, Stubbing {
 
     private static final long serialVersionUID = 4919105134123672727L;
-    private final Queue<Answer> answers = new ConcurrentLinkedQueue<Answer>();
+    private final Queue<Answer> answers = new ConcurrentLinkedQueue<>();
     private final Strictness strictness;
+    private final Object usedAtLock = new Object[0];
     private DescribedInvocation usedAt;
 
-    public StubbedInvocationMatcher(Answer answer, MatchableInvocation invocation, Strictness strictness) {
+    public StubbedInvocationMatcher(
+            Answer answer, MatchableInvocation invocation, Strictness strictness) {
         super(invocation.getInvocation(), invocation.getMatchers());
         this.strictness = strictness;
         this.answers.add(answer);
     }
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
-        //see ThreadsShareGenerouslyStubbedMockTest
+        // see ThreadsShareGenerouslyStubbedMockTest
         Answer a;
-        synchronized(answers) {
+        synchronized (answers) {
             a = answers.size() == 1 ? answers.peek() : answers.poll();
         }
         return a.answer(invocation);
@@ -44,11 +47,16 @@ public class StubbedInvocationMatcher extends InvocationMatcher implements Seria
     }
 
     public void markStubUsed(DescribedInvocation usedAt) {
-        this.usedAt = usedAt;
+        synchronized (usedAtLock) {
+            this.usedAt = usedAt;
+        }
     }
 
+    @Override
     public boolean wasUsed() {
-        return usedAt != null;
+        synchronized (usedAtLock) {
+            return usedAt != null;
+        }
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
index 2172809..a357de6 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
@@ -4,25 +4,25 @@
  */
 package org.mockito.internal.stubbing;
 
+import static org.mockito.internal.exceptions.Reporter.notAMockPassedToWhenMethod;
+import static org.mockito.internal.exceptions.Reporter.notAnException;
+import static org.mockito.internal.exceptions.Reporter.nullPassedToWhenMethod;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
+import static org.mockito.internal.util.MockUtil.isMock;
+
+import java.util.LinkedList;
+import java.util.List;
+
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
+import org.mockito.internal.stubbing.answers.ThrowsExceptionForClassType;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.Stubber;
 
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.mockito.internal.exceptions.Reporter.notAMockPassedToWhenMethod;
-import static org.mockito.internal.exceptions.Reporter.notAnException;
-import static org.mockito.internal.exceptions.Reporter.nullPassedToWhenMethod;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
-import static org.mockito.internal.util.MockUtil.isMock;
-import static org.objenesis.ObjenesisHelper.newInstance;
-
 public class StubberImpl implements Stubber {
 
     private final Strictness strictness;
@@ -31,15 +31,17 @@ public class StubberImpl implements Stubber {
         this.strictness = strictness;
     }
 
-    private final List<Answer<?>> answers = new LinkedList<Answer<?>>();
+    private final List<Answer<?>> answers = new LinkedList<>();
 
     @Override
     public <T> T when(T mock) {
         if (mock == null) {
+            mockingProgress().reset();
             throw nullPassedToWhenMethod();
         }
 
         if (!isMock(mock)) {
+            mockingProgress().reset();
             throw notAMockPassedToWhenMethod();
         }
 
@@ -87,18 +89,12 @@ public class StubberImpl implements Stubber {
             mockingProgress().reset();
             throw notAnException();
         }
-        Throwable e;
-        try {
-            e = newInstance(toBeThrown);
-        } catch (RuntimeException instantiationError) {
-            mockingProgress().reset();
-            throw instantiationError;
-        }
-        return doThrow(e);
+        return doAnswer(new ThrowsExceptionForClassType(toBeThrown));
     }
 
     @Override
-    public Stubber doThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
+    public Stubber doThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
         Stubber stubber = doThrow(toBeThrown);
 
         if (nextToBeThrown == null) {
@@ -110,7 +106,6 @@ public class StubberImpl implements Stubber {
             stubber = stubber.doThrow(next);
         }
         return stubber;
-
     }
 
     @Override
@@ -131,5 +126,3 @@ public class StubberImpl implements Stubber {
         return this;
     }
 }
-
-
diff --git a/src/main/java/org/mockito/internal/stubbing/StubbingComparator.java b/src/main/java/org/mockito/internal/stubbing/StubbingComparator.java
index b7f7ad5..4d8e678 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubbingComparator.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubbingComparator.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.stubbing;
 
+import java.util.Comparator;
+
 import org.mockito.internal.invocation.InvocationComparator;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Comparator;
-
 /**
  * Compares stubbings based on {@link InvocationComparator}
  */
@@ -16,6 +16,7 @@ public class StubbingComparator implements Comparator<Stubbing> {
 
     private final InvocationComparator invocationComparator = new InvocationComparator();
 
+    @Override
     public int compare(Stubbing o1, Stubbing o2) {
         return invocationComparator.compare(o1.getInvocation(), o2.getInvocation());
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/UnusedStubbingReporting.java b/src/main/java/org/mockito/internal/stubbing/UnusedStubbingReporting.java
index 6a96592..38247a5 100644
--- a/src/main/java/org/mockito/internal/stubbing/UnusedStubbingReporting.java
+++ b/src/main/java/org/mockito/internal/stubbing/UnusedStubbingReporting.java
@@ -7,10 +7,8 @@ package org.mockito.internal.stubbing;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Stubbing;
 
-/**
- * Helps determining if stubbing should be reported as unused
- */
-public class UnusedStubbingReporting {
+/** Helps determining if stubbing should be reported as unused */
+public final class UnusedStubbingReporting {
 
     /**
      * Decides if the stubbing should be reported as unused.
@@ -19,4 +17,6 @@ public class UnusedStubbingReporting {
     public static boolean shouldBeReported(Stubbing stubbing) {
         return !stubbing.wasUsed() && stubbing.getStrictness() != Strictness.LENIENT;
     }
+
+    private UnusedStubbingReporting() {}
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java b/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java
new file mode 100644
index 0000000..6bcca9d
--- /dev/null
+++ b/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.answers;
+
+import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
+import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
+
+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+import org.mockito.internal.util.MockUtil;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.mockito.stubbing.ValidableAnswer;
+
+public abstract class AbstractThrowsException implements Answer<Object>, ValidableAnswer {
+
+    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
+
+    protected abstract Throwable getThrowable();
+
+    @Override
+    public Object answer(InvocationOnMock invocation) throws Throwable {
+        Throwable throwable = getThrowable();
+        if (throwable == null) {
+            throw new IllegalStateException(
+                    "throwable is null: " + "you shall not call #answer if #validateFor fails!");
+        }
+        if (MockUtil.isMock(throwable)) {
+            throw throwable;
+        }
+        Throwable t = throwable.fillInStackTrace();
+
+        if (t == null) {
+            // Custom exceptions sometimes return null, see #866
+            throw throwable;
+        }
+        filter.filter(t);
+        throw t;
+    }
+
+    @Override
+    public void validateFor(InvocationOnMock invocation) {
+        Throwable throwable = getThrowable();
+        if (throwable == null) {
+            throw cannotStubWithNullThrowable();
+        }
+
+        if (throwable instanceof RuntimeException || throwable instanceof Error) {
+            return;
+        }
+
+        if (!new InvocationInfo(invocation).isValidException(throwable)) {
+            throw checkedExceptionInvalid(throwable);
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java b/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java
index e1a92a4..e4692f2 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java
@@ -11,11 +11,13 @@ import org.mockito.stubbing.Answer2;
 import org.mockito.stubbing.Answer3;
 import org.mockito.stubbing.Answer4;
 import org.mockito.stubbing.Answer5;
+import org.mockito.stubbing.Answer6;
 import org.mockito.stubbing.VoidAnswer1;
 import org.mockito.stubbing.VoidAnswer2;
 import org.mockito.stubbing.VoidAnswer3;
 import org.mockito.stubbing.VoidAnswer4;
 import org.mockito.stubbing.VoidAnswer5;
+import org.mockito.stubbing.VoidAnswer6;
 
 /**
  * Functional interfaces to make it easy to implement answers in Java 8
@@ -23,11 +25,10 @@ import org.mockito.stubbing.VoidAnswer5;
  * @since 2.1.0
  */
 public class AnswerFunctionalInterfaces {
-	/**
+    /**
      * Hide constructor to avoid instantiation of class with only static methods
      */
-    private AnswerFunctionalInterfaces() {
-    }
+    private AnswerFunctionalInterfaces() {}
 
     /**
      * Construct an answer from a two parameter answer interface
@@ -38,9 +39,10 @@ public class AnswerFunctionalInterfaces {
      */
     public static <T, A> Answer<T> toAnswer(final Answer1<T, A> answer) {
         return new Answer<T>() {
+            @Override
             @SuppressWarnings("unchecked")
             public T answer(InvocationOnMock invocation) throws Throwable {
-                return answer.answer((A)invocation.getArgument(0));
+                return answer.answer((A) invocation.getArgument(0));
             }
         };
     }
@@ -53,9 +55,10 @@ public class AnswerFunctionalInterfaces {
      */
     public static <A> Answer<Void> toAnswer(final VoidAnswer1<A> answer) {
         return new Answer<Void>() {
+            @Override
             @SuppressWarnings("unchecked")
             public Void answer(InvocationOnMock invocation) throws Throwable {
-                answer.answer((A)invocation.getArgument(0));
+                answer.answer((A) invocation.getArgument(0));
                 return null;
             }
         };
@@ -71,11 +74,10 @@ public class AnswerFunctionalInterfaces {
      */
     public static <T, A, B> Answer<T> toAnswer(final Answer2<T, A, B> answer) {
         return new Answer<T>() {
+            @Override
             @SuppressWarnings("unchecked")
             public T answer(InvocationOnMock invocation) throws Throwable {
-                return answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1));
+                return answer.answer((A) invocation.getArgument(0), (B) invocation.getArgument(1));
             }
         };
     }
@@ -89,11 +91,10 @@ public class AnswerFunctionalInterfaces {
      */
     public static <A, B> Answer<Void> toAnswer(final VoidAnswer2<A, B> answer) {
         return new Answer<Void>() {
+            @Override
             @SuppressWarnings("unchecked")
             public Void answer(InvocationOnMock invocation) throws Throwable {
-                answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1));
+                answer.answer((A) invocation.getArgument(0), (B) invocation.getArgument(1));
                 return null;
             }
         };
@@ -110,12 +111,13 @@ public class AnswerFunctionalInterfaces {
      */
     public static <T, A, B, C> Answer<T> toAnswer(final Answer3<T, A, B, C> answer) {
         return new Answer<T>() {
+            @Override
             @SuppressWarnings("unchecked")
             public T answer(InvocationOnMock invocation) throws Throwable {
                 return answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2));
             }
         };
     }
@@ -130,12 +132,13 @@ public class AnswerFunctionalInterfaces {
      */
     public static <A, B, C> Answer<Void> toAnswer(final VoidAnswer3<A, B, C> answer) {
         return new Answer<Void>() {
+            @Override
             @SuppressWarnings("unchecked")
             public Void answer(InvocationOnMock invocation) throws Throwable {
                 answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2));
                 return null;
             }
         };
@@ -153,13 +156,14 @@ public class AnswerFunctionalInterfaces {
      */
     public static <T, A, B, C, D> Answer<T> toAnswer(final Answer4<T, A, B, C, D> answer) {
         return new Answer<T>() {
+            @Override
             @SuppressWarnings("unchecked")
             public T answer(InvocationOnMock invocation) throws Throwable {
                 return answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2),
-                        (D)invocation.getArgument(3));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3));
             }
         };
     }
@@ -175,13 +179,14 @@ public class AnswerFunctionalInterfaces {
      */
     public static <A, B, C, D> Answer<Void> toAnswer(final VoidAnswer4<A, B, C, D> answer) {
         return new Answer<Void>() {
+            @Override
             @SuppressWarnings("unchecked")
             public Void answer(InvocationOnMock invocation) throws Throwable {
                 answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2),
-                        (D)invocation.getArgument(3));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3));
                 return null;
             }
         };
@@ -200,14 +205,15 @@ public class AnswerFunctionalInterfaces {
      */
     public static <T, A, B, C, D, E> Answer<T> toAnswer(final Answer5<T, A, B, C, D, E> answer) {
         return new Answer<T>() {
+            @Override
             @SuppressWarnings("unchecked")
             public T answer(InvocationOnMock invocation) throws Throwable {
                 return answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2),
-                        (D)invocation.getArgument(3),
-                        (E)invocation.getArgument(4));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3),
+                        (E) invocation.getArgument(4));
             }
         };
     }
@@ -224,14 +230,75 @@ public class AnswerFunctionalInterfaces {
      */
     public static <A, B, C, D, E> Answer<Void> toAnswer(final VoidAnswer5<A, B, C, D, E> answer) {
         return new Answer<Void>() {
+            @Override
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer(
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3),
+                        (E) invocation.getArgument(4));
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a six parameter answer interface
+     *
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     * @param <F> input parameter 6 type
+     * @return a new answer object
+     */
+    public static <T, A, B, C, D, E, F> Answer<T> toAnswer(
+            final Answer6<T, A, B, C, D, E, F> answer) {
+        return new Answer<T>() {
+            @Override
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer(
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3),
+                        (E) invocation.getArgument(4),
+                        (F) invocation.getArgument(5));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a five parameter answer interface
+     *
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     * @param <F> input parameter 6 type
+     * @return a new answer object
+     */
+    public static <A, B, C, D, E, F> Answer<Void> toAnswer(
+            final VoidAnswer6<A, B, C, D, E, F> answer) {
+        return new Answer<Void>() {
+            @Override
             @SuppressWarnings("unchecked")
             public Void answer(InvocationOnMock invocation) throws Throwable {
                 answer.answer(
-                        (A)invocation.getArgument(0),
-                        (B)invocation.getArgument(1),
-                        (C)invocation.getArgument(2),
-                        (D)invocation.getArgument(3),
-                        (E)invocation.getArgument(4));
+                        (A) invocation.getArgument(0),
+                        (B) invocation.getArgument(1),
+                        (C) invocation.getArgument(2),
+                        (D) invocation.getArgument(3),
+                        (E) invocation.getArgument(4),
+                        (F) invocation.getArgument(5));
                 return null;
             }
         };
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/AnswersWithDelay.java b/src/main/java/org/mockito/internal/stubbing/answers/AnswersWithDelay.java
index 083b082..f0f23d5 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/AnswersWithDelay.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/AnswersWithDelay.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import java.io.Serializable;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
-import java.io.Serializable;
-import java.util.concurrent.TimeUnit;
-
 /**
  * Returns as the provided answer would return, after delaying the specified amount.
  *
@@ -33,7 +33,7 @@ public class AnswersWithDelay implements Answer<Object>, ValidableAnswer, Serial
 
     @Override
     public Object answer(final InvocationOnMock invocation) throws Throwable {
-        TimeUnit.MILLISECONDS.sleep(sleepyTime);
+        MILLISECONDS.sleep(sleepyTime);
         return answer.answer(invocation);
     }
 
@@ -44,4 +44,3 @@ public class AnswersWithDelay implements Answer<Object>, ValidableAnswer, Serial
         }
     }
 }
-
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/CallsRealMethods.java b/src/main/java/org/mockito/internal/stubbing/answers/CallsRealMethods.java
index 59a82e6..bab007b 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/CallsRealMethods.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/CallsRealMethods.java
@@ -4,15 +4,16 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.mockito.Answers.RETURNS_DEFAULTS;
+import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
+
 import java.io.Serializable;
 import java.lang.reflect.Modifier;
+
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
-import static org.mockito.Answers.RETURNS_DEFAULTS;
-import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
-
 /**
  * Optional Answer that adds partial mocking support
  * <p>
@@ -30,12 +31,13 @@ import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMet
  * <p>
  * However, there are rare cases when partial mocks come handy:
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
- * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+ * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
  * <p>
  */
 public class CallsRealMethods implements Answer<Object>, ValidableAnswer, Serializable {
     private static final long serialVersionUID = 9057165148930624087L;
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
             return RETURNS_DEFAULTS.answer(invocation);
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ClonesArguments.java b/src/main/java/org/mockito/internal/stubbing/answers/ClonesArguments.java
index 25e8be7..0f0c15b 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/ClonesArguments.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ClonesArguments.java
@@ -4,24 +4,39 @@
  */
 package org.mockito.internal.stubbing.answers;
 
-import org.mockito.internal.configuration.plugins.Plugins;
+import java.lang.reflect.Array;
+
 import org.mockito.creation.instance.Instantiator;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-//TODO this needs documentation and further analysis - what if someone changes the answer?
-//we might think about implementing it straight on MockSettings
+// TODO this needs documentation and further analysis - what if someone changes the answer?
+// we might think about implementing it straight on MockSettings
 public class ClonesArguments implements Answer<Object> {
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         Object[] arguments = invocation.getArguments();
         for (int i = 0; i < arguments.length; i++) {
             Object from = arguments[i];
-            Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(null);
-            Object newInstance = instantiator.newInstance(from.getClass());
-            new LenientCopyTool().copyToRealObject(from, newInstance);
-            arguments[i] = newInstance;
+            if (from != null) {
+                if (from.getClass().isArray()) {
+                    int len = Array.getLength(from);
+                    Object newInstance = Array.newInstance(from.getClass().getComponentType(), len);
+                    for (int j = 0; j < len; ++j) {
+                        Array.set(newInstance, j, Array.get(from, j));
+                    }
+                    arguments[i] = newInstance;
+                } else {
+                    Instantiator instantiator =
+                            Plugins.getInstantiatorProvider().getInstantiator(null);
+                    Object newInstance = instantiator.newInstance(from.getClass());
+                    new LenientCopyTool().copyToRealObject(from, newInstance);
+                    arguments[i] = newInstance;
+                }
+            }
         }
         return new ReturnsEmptyValues().answer(invocation);
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidator.java b/src/main/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidator.java
index da1d2a7..b6a384e 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidator.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidator.java
@@ -2,15 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.stubbing.answers;
 
-import org.mockito.invocation.InvocationOnMock;
-
 import static org.mockito.internal.exceptions.Reporter.wrongTypeReturnedByDefaultAnswer;
 
+import org.mockito.invocation.InvocationOnMock;
+
 public abstract class DefaultAnswerValidator {
-    public static void validateReturnValueFor(InvocationOnMock invocation, Object returnedValue) throws Throwable {
+    public static void validateReturnValueFor(InvocationOnMock invocation, Object returnedValue)
+            throws Throwable {
         InvocationInfo invocationInfo = new InvocationInfo(invocation);
         if (returnedValue != null && !invocationInfo.isValidReturnType(returnedValue.getClass())) {
             throw wrongTypeReturnedByDefaultAnswer(
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/DoesNothing.java b/src/main/java/org/mockito/internal/stubbing/answers/DoesNothing.java
index bc625fb..d044e12 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/DoesNothing.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/DoesNothing.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.mockito.internal.exceptions.Reporter.onlyVoidMethodsCanBeSetToDoNothing;
+
 import java.io.Serializable;
 
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
-import static org.mockito.internal.exceptions.Reporter.onlyVoidMethodsCanBeSetToDoNothing;
-
 public class DoesNothing implements Answer<Object>, ValidableAnswer, Serializable {
 
     private static final long serialVersionUID = 4840880517740698416L;
@@ -20,12 +20,12 @@ public class DoesNothing implements Answer<Object>, ValidableAnswer, Serializabl
 
     private DoesNothing() {}
 
-    public static DoesNothing doesNothing(){
+    public static DoesNothing doesNothing() {
         return SINGLETON;
     }
 
     @Override
-    public Object answer(InvocationOnMock invocation){
+    public Object answer(InvocationOnMock invocation) {
         return null;
     }
 
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
index 11498b7..8bfffca 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
@@ -6,16 +6,22 @@ package org.mockito.internal.stubbing.answers;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+
 import org.mockito.internal.invocation.AbstractAwareMethod;
+import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.Primitives;
+import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
+import org.mockito.mock.MockCreationSettings;
 
 public class InvocationInfo implements AbstractAwareMethod {
 
     private final Method method;
+    private final InvocationOnMock invocation;
 
     public InvocationInfo(InvocationOnMock theInvocation) {
         this.method = theInvocation.getMethod();
+        this.invocation = theInvocation;
     }
 
     public boolean isValidException(Throwable throwable) {
@@ -32,7 +38,8 @@ public class InvocationInfo implements AbstractAwareMethod {
 
     public boolean isValidReturnType(Class<?> clazz) {
         if (method.getReturnType().isPrimitive() || clazz.isPrimitive()) {
-            return Primitives.primitiveTypeOf(clazz) == Primitives.primitiveTypeOf(method.getReturnType());
+            return Primitives.primitiveTypeOf(clazz)
+                    == Primitives.primitiveTypeOf(method.getReturnType());
         } else {
             return method.getReturnType().isAssignableFrom(clazz);
         }
@@ -43,8 +50,13 @@ public class InvocationInfo implements AbstractAwareMethod {
      * E.g:  {@code void foo()} or {@code Void bar()}
      */
     public boolean isVoid() {
-        Class<?> returnType = this.method.getReturnType();
-        return returnType == Void.TYPE|| returnType == Void.class;
+        final MockCreationSettings mockSettings =
+                MockUtil.getMockHandler(invocation.getMock()).getMockSettings();
+        Class<?> returnType =
+                GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock())
+                        .resolveGenericReturnType(this.method)
+                        .rawType();
+        return returnType == Void.TYPE || returnType == Void.class;
     }
 
     public String printMethodReturnType() {
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/Returns.java b/src/main/java/org/mockito/internal/stubbing/answers/Returns.java
index f34003b..d4d97cb 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/Returns.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/Returns.java
@@ -4,15 +4,16 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.mockito.internal.exceptions.Reporter.cannotStubVoidMethodWithAReturnValue;
+import static org.mockito.internal.exceptions.Reporter.wrongTypeOfReturnValue;
+
 import java.io.Serializable;
 
+import org.mockito.internal.util.KotlinInlineClassUtil;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
-import static org.mockito.internal.exceptions.Reporter.cannotStubVoidMethodWithAReturnValue;
-import static org.mockito.internal.exceptions.Reporter.wrongTypeOfReturnValue;
-
 public class Returns implements Answer<Object>, ValidableAnswer, Serializable {
 
     private static final long serialVersionUID = -6245608253574215396L;
@@ -22,8 +23,9 @@ public class Returns implements Answer<Object>, ValidableAnswer, Serializable {
         this.value = value;
     }
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
-        return value;
+        return KotlinInlineClassUtil.unboxUnderlyingValueIfNeeded(invocation, value);
     }
 
     @Override
@@ -34,11 +36,18 @@ public class Returns implements Answer<Object>, ValidableAnswer, Serializable {
         }
 
         if (returnsNull() && invocationInfo.returnsPrimitive()) {
-            throw wrongTypeOfReturnValue(invocationInfo.printMethodReturnType(), "null", invocationInfo.getMethodName());
+            throw wrongTypeOfReturnValue(
+                    invocationInfo.printMethodReturnType(), "null", invocationInfo.getMethodName());
         }
 
-        if (!returnsNull() && !invocationInfo.isValidReturnType(returnType())) {
-            throw wrongTypeOfReturnValue(invocationInfo.printMethodReturnType(), printReturnType(), invocationInfo.getMethodName());
+        if (!returnsNull()
+                && !invocationInfo.isValidReturnType(returnType())
+                && !KotlinInlineClassUtil.isInlineClassWithAssignableUnderlyingType(
+                        returnType(), invocationInfo.getMethod().getReturnType())) {
+            throw wrongTypeOfReturnValue(
+                    invocationInfo.printMethodReturnType(),
+                    printReturnType(),
+                    invocationInfo.getMethodName());
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java b/src/main/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java
index 5419819..cd66115 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java
@@ -10,6 +10,7 @@ import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToRetu
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
+
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
@@ -54,14 +55,14 @@ public class ReturnsArgumentAt implements Answer<Object>, ValidableAnswer, Seria
         int argumentPosition = inferWantedArgumentPosition(invocation);
         validateIndexWithinInvocationRange(invocation, argumentPosition);
 
-        if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
+        if (wantedArgIndexIsVarargAndSameTypeAsReturnType(
+                invocation.getMethod(), argumentPosition)) {
             // answer raw vararg array argument
             return ((Invocation) invocation).getRawArguments()[argumentPosition];
         }
 
         // answer expanded argument at wanted position
         return invocation.getArgument(argumentPosition);
-
     }
 
     @Override
@@ -72,17 +73,18 @@ public class ReturnsArgumentAt implements Answer<Object>, ValidableAnswer, Seria
     }
 
     private int inferWantedArgumentPosition(InvocationOnMock invocation) {
-        if (wantedArgumentPosition == LAST_ARGUMENT)
+        if (wantedArgumentPosition == LAST_ARGUMENT) {
             return invocation.getArguments().length - 1;
+        }
 
         return wantedArgumentPosition;
     }
 
-    private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
+    private void validateIndexWithinInvocationRange(
+            InvocationOnMock invocation, int argumentPosition) {
         if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
-            throw invalidArgumentPositionRangeAtInvocationTime(invocation,
-                                                               wantedArgumentPosition == LAST_ARGUMENT,
-                                                               wantedArgumentPosition);
+            throw invalidArgumentPositionRangeAtInvocationTime(
+                    invocation, wantedArgumentPosition == LAST_ARGUMENT, wantedArgumentPosition);
         }
     }
 
@@ -91,22 +93,25 @@ public class ReturnsArgumentAt implements Answer<Object>, ValidableAnswer, Seria
 
         Class<?> inferredArgumentType = inferArgumentType(invocation, argumentPosition);
 
-        if (!invocationInfo.isValidReturnType(inferredArgumentType)){
-            throw wrongTypeOfArgumentToReturn(invocation,
-                                              invocationInfo.printMethodReturnType(),
-                                              inferredArgumentType,
-                                              wantedArgumentPosition);
+        if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
+            throw wrongTypeOfArgumentToReturn(
+                    invocation,
+                    invocationInfo.printMethodReturnType(),
+                    inferredArgumentType,
+                    wantedArgumentPosition);
         }
     }
 
-    private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
+    private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(
+            Method method, int argumentPosition) {
         Class<?>[] parameterTypes = method.getParameterTypes();
-        return method.isVarArgs() &&
-              argumentPosition == /* vararg index */ parameterTypes.length - 1 &&
-              method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
+        return method.isVarArgs()
+                && argumentPosition == /* vararg index */ parameterTypes.length - 1
+                && method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
     }
 
-    private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
+    private boolean wantedArgumentPositionIsValidForInvocation(
+            InvocationOnMock invocation, int argumentPosition) {
         if (argumentPosition < 0) {
             return false;
         }
@@ -142,12 +147,11 @@ public class ReturnsArgumentAt implements Answer<Object>, ValidableAnswer, Seria
         // if wanted argument is vararg
         if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentIndex)) {
             // return the vararg array if return type is compatible
-            // because the user probably want to return the array itself if the return type is compatible
+            // because the user probably want to return the array itself if the return type is
+            // compatible
             return parameterTypes[argumentIndex]; // move to MethodInfo ?
         }
         // return the type in this vararg array
         return parameterTypes[varargIndex].getComponentType();
-
     }
 }
-
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java b/src/main/java/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java
index aaf6750..cbd8a14 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java
@@ -6,6 +6,7 @@ package org.mockito.internal.stubbing.answers;
 
 import java.util.Collection;
 import java.util.LinkedList;
+
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
@@ -35,16 +36,17 @@ public class ReturnsElementsOf implements Answer<Object> {
 
     public ReturnsElementsOf(Collection<?> elements) {
         if (elements == null) {
-            throw new MockitoException("ReturnsElementsOf does not accept null as constructor argument.\n" +
-                    "Please pass a collection instance");
+            throw new MockitoException(
+                    "ReturnsElementsOf does not accept null as constructor argument.\n"
+                            + "Please pass a collection instance");
         }
-        this.elements = new LinkedList<Object>(elements);
+        this.elements = new LinkedList<>(elements);
     }
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
-        if (elements.size() == 1)
+        if (elements.size() == 1) {
             return elements.get(0);
-        else
-            return elements.poll();
+        } else return elements.poll();
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
index 502e359..a971201 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
@@ -5,23 +5,17 @@
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
-import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
-import org.mockito.internal.util.MockUtil;
+
 import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
-import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
-import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
-
 /**
  * An answer that always throws the same throwable.
  */
-public class ThrowsException implements Answer<Object>, ValidableAnswer, Serializable {
+public class ThrowsException extends AbstractThrowsException implements Serializable {
 
     private static final long serialVersionUID = 1128820328555183980L;
     private final Throwable throwable;
-    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
 
     /**
      * Creates a new answer always throwing the given throwable. If it is null,
@@ -32,36 +26,8 @@ public class ThrowsException implements Answer<Object>, ValidableAnswer, Seriali
         this.throwable = throwable;
     }
 
-    public Object answer(InvocationOnMock invocation) throws Throwable {
-        if (throwable == null) {
-            throw new IllegalStateException("throwable is null: " +
-                "you shall not call #answer if #validateFor fails!");
-        }
-        if (MockUtil.isMock(throwable)) {
-            throw throwable;
-        }
-        Throwable t = throwable.fillInStackTrace();
-
-        if (t == null) {
-            //Custom exceptions sometimes return null, see #866
-            throw throwable;
-        }
-        filter.filter(t);
-        throw t;
-    }
-
     @Override
-    public void validateFor(InvocationOnMock invocation) {
-        if (throwable == null) {
-            throw cannotStubWithNullThrowable();
-        }
-
-        if (throwable instanceof RuntimeException || throwable instanceof Error) {
-            return;
-        }
-
-        if (!new InvocationInfo(invocation).isValidException(throwable)) {
-            throw checkedExceptionInvalid(throwable);
-        }
+    protected Throwable getThrowable() {
+        return throwable;
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java
new file mode 100644
index 0000000..2c3d923
--- /dev/null
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.answers;
+
+import java.io.Serializable;
+
+import org.mockito.creation.instance.Instantiator;
+import org.mockito.internal.configuration.plugins.Plugins;
+
+public class ThrowsExceptionForClassType extends AbstractThrowsException implements Serializable {
+
+    private final Class<? extends Throwable> throwableClass;
+
+    public ThrowsExceptionForClassType(Class<? extends Throwable> throwableClass) {
+        this.throwableClass = throwableClass;
+    }
+
+    @Override
+    protected Throwable getThrowable() {
+        Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(null);
+        return instantiator.newInstance(throwableClass);
+    }
+}
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
index 9165142..5f596b7 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
@@ -11,8 +11,10 @@ import java.io.Serializable;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
+import org.mockito.plugins.MemberAccessor;
 import org.mockito.stubbing.Answer;
 
 /**
@@ -23,26 +25,31 @@ import org.mockito.stubbing.Answer;
 public class ForwardsInvocations implements Answer<Object>, Serializable {
     private static final long serialVersionUID = -8343690268123254910L;
 
-    private Object delegatedObject = null ;
+    private Object delegatedObject = null;
 
     public ForwardsInvocations(Object delegatedObject) {
-        this.delegatedObject = delegatedObject ;
+        this.delegatedObject = delegatedObject;
     }
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         Method mockMethod = invocation.getMethod();
 
         try {
             Method delegateMethod = getDelegateMethod(mockMethod);
 
-            if (!compatibleReturnTypes(mockMethod.getReturnType(), delegateMethod.getReturnType())) {
-                throw delegatedMethodHasWrongReturnType(mockMethod, delegateMethod, invocation.getMock(), delegatedObject);
+            if (!compatibleReturnTypes(
+                    mockMethod.getReturnType(), delegateMethod.getReturnType())) {
+                throw delegatedMethodHasWrongReturnType(
+                        mockMethod, delegateMethod, invocation.getMock(), delegatedObject);
             }
 
+            MemberAccessor accessor = Plugins.getMemberAccessor();
             Object[] rawArguments = ((Invocation) invocation).getRawArguments();
-            return delegateMethod.invoke(delegatedObject, rawArguments);
+            return accessor.invoke(delegateMethod, delegatedObject, rawArguments);
         } catch (NoSuchMethodException e) {
-            throw delegatedMethodDoesNotExistOnDelegate(mockMethod, invocation.getMock(), delegatedObject);
+            throw delegatedMethodDoesNotExistOnDelegate(
+                    mockMethod, invocation.getMock(), delegatedObject);
         } catch (InvocationTargetException e) {
             // propagate the original exception from the delegate
             throw e.getCause();
@@ -55,7 +62,9 @@ public class ForwardsInvocations implements Answer<Object>, Serializable {
             return mockMethod;
         } else {
             // Return method of delegate object with the same signature as mockMethod.
-            return delegatedObject.getClass().getMethod(mockMethod.getName(), mockMethod.getParameterTypes());
+            return delegatedObject
+                    .getClass()
+                    .getMethod(mockMethod.getName(), mockMethod.getParameterTypes());
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java
index a25832f..51a70aa 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java
@@ -20,6 +20,7 @@ public class GloballyConfiguredAnswer implements Answer<Object>, Serializable {
 
     private static final long serialVersionUID = 3585893470101750917L;
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         return new GlobalConfiguration().getDefaultAnswer().answer(invocation);
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/RetrieveGenericsForDefaultAnswers.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/RetrieveGenericsForDefaultAnswers.java
new file mode 100644
index 0000000..fa6a72f
--- /dev/null
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/RetrieveGenericsForDefaultAnswers.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.defaultanswers;
+
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
+import org.mockito.internal.MockitoCore;
+import org.mockito.internal.util.MockUtil;
+import org.mockito.internal.util.reflection.GenericMetadataSupport;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.mock.MockCreationSettings;
+
+final class RetrieveGenericsForDefaultAnswers {
+
+    private static final MockitoCore MOCKITO_CORE = new MockitoCore();
+
+    static Object returnTypeForMockWithCorrectGenerics(
+            InvocationOnMock invocation, AnswerCallback answerCallback) {
+        Class<?> type = invocation.getMethod().getReturnType();
+
+        final Type returnType = invocation.getMethod().getGenericReturnType();
+
+        Object defaultReturnValue = null;
+
+        if (returnType instanceof TypeVariable) {
+            type = findTypeFromGeneric(invocation, (TypeVariable) returnType);
+            if (type != null) {
+                defaultReturnValue = delegateChains(type);
+            }
+        }
+
+        if (defaultReturnValue != null) {
+            return defaultReturnValue;
+        }
+
+        if (type != null) {
+            if (!MOCKITO_CORE.isTypeMockable(type)) {
+                return null;
+            }
+
+            return answerCallback.apply(type);
+        }
+
+        return answerCallback.apply(null);
+    }
+
+    /**
+     * Try to resolve the result value using {@link ReturnsEmptyValues} and {@link ReturnsMoreEmptyValues}.
+     *
+     * This will try to use all parent class (superclass and interfaces) to retrieve the value..
+     *
+     * @param type the return type of the method
+     * @return a non-null instance if the type has been resolve. Null otherwise.
+     */
+    private static Object delegateChains(final Class<?> type) {
+        final ReturnsEmptyValues returnsEmptyValues = new ReturnsEmptyValues();
+        Object result = returnsEmptyValues.returnValueFor(type);
+
+        if (result == null) {
+            Class<?> emptyValueForClass = type;
+            while (emptyValueForClass != null && result == null) {
+                final Class<?>[] classes = emptyValueForClass.getInterfaces();
+                for (Class<?> clazz : classes) {
+                    result = returnsEmptyValues.returnValueFor(clazz);
+                    if (result != null) {
+                        break;
+                    }
+                }
+                emptyValueForClass = emptyValueForClass.getSuperclass();
+            }
+        }
+
+        if (result == null) {
+            result = new ReturnsMoreEmptyValues().returnValueFor(type);
+        }
+
+        return result;
+    }
+
+    /**
+     * Retrieve the expected type when it came from a primitive. If the type cannot be retrieve, return null.
+     *
+     * @param invocation the current invocation
+     * @param returnType the expected return type
+     * @return the type or null if not found
+     */
+    private static Class<?> findTypeFromGeneric(
+            final InvocationOnMock invocation, final TypeVariable returnType) {
+        // Class level
+        final MockCreationSettings mockSettings =
+                MockUtil.getMockHandler(invocation.getMock()).getMockSettings();
+        final GenericMetadataSupport returnTypeSupport =
+                GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock())
+                        .resolveGenericReturnType(invocation.getMethod());
+        final Class<?> rawType = returnTypeSupport.rawType();
+
+        // Method level
+        if (rawType == Object.class) {
+            return findTypeFromGenericInArguments(invocation, returnType);
+        }
+        return rawType;
+    }
+
+    /**
+     * Find a return type using generic arguments provided by the calling method.
+     *
+     * @param invocation the current invocation
+     * @param returnType the expected return type
+     * @return the return type or null if the return type cannot be found
+     */
+    private static Class<?> findTypeFromGenericInArguments(
+            final InvocationOnMock invocation, final TypeVariable returnType) {
+        final Type[] parameterTypes = invocation.getMethod().getGenericParameterTypes();
+        for (int i = 0; i < parameterTypes.length; i++) {
+            Type argType = parameterTypes[i];
+            if (returnType.equals(argType)) {
+                Object argument = invocation.getArgument(i);
+
+                if (argument == null) {
+                    return null;
+                }
+
+                return argument.getClass();
+            }
+            if (argType instanceof GenericArrayType) {
+                argType = ((GenericArrayType) argType).getGenericComponentType();
+                if (returnType.equals(argType)) {
+                    return invocation.getArgument(i).getClass();
+                }
+            }
+        }
+        return null;
+    }
+
+    interface AnswerCallback {
+        Object apply(Class<?> type);
+    }
+
+    private RetrieveGenericsForDefaultAnswers() {}
+}
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
index 3909ff0..097b11b 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import static org.mockito.Mockito.withSettings;
+
+import java.io.IOException;
+import java.io.Serializable;
+
 import org.mockito.MockSettings;
 import org.mockito.Mockito;
 import org.mockito.internal.MockitoCore;
@@ -15,17 +20,11 @@ import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
-import org.mockito.stubbing.Stubbing;
-
-import java.io.IOException;
-import java.io.Serializable;
-
-import static org.mockito.Mockito.withSettings;
 
 /**
  * Returning deep stub implementation.
  *
- * Will return previously created mock if the invocation matches.
+ * <p>Will return previously created mock if the invocation matches.
  *
  * <p>Supports nested generic information, with this answer you can write code like this :
  *
@@ -37,6 +36,8 @@ import static org.mockito.Mockito.withSettings;
  * </code></pre>
  * </p>
  *
+ * <p>However this answer does not support generics information when the mock has been deserialized.
+ *
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
@@ -44,34 +45,50 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {
 
     private static final long serialVersionUID = -7105341425736035847L;
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
-                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
+                actualParameterizedType(invocation.getMock())
+                        .resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!mockitoCore().isTypeMockable(rawType)) {
-            return delegate().returnValueFor(rawType);
+            if (invocation.getMethod().getReturnType().equals(rawType)) {
+                return delegate().answer(invocation);
+            } else {
+                return delegate().returnValueFor(rawType);
+            }
+        }
+
+        // When dealing with erased generics, we only receive the Object type as rawType. At this
+        // point, there is nothing to salvage for Mockito. Instead of trying to be smart and
+        // generate
+        // a mock that would potentially match the return signature, instead return `null`. This
+        // is valid per the CheckCast JVM instruction and is better than causing a
+        // ClassCastException
+        // on runtime.
+        if (rawType.equals(Object.class) && !returnTypeGenericMetadata.hasRawExtraInterfaces()) {
+            return null;
         }
 
         return deepStub(invocation, returnTypeGenericMetadata);
     }
 
-    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
+    private Object deepStub(
+            InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata)
+            throws Throwable {
         InvocationContainerImpl container = MockUtil.getInvocationContainer(invocation.getMock());
 
-        // matches invocation for verification
-        // TODO why don't we do container.findAnswer here?
-        for (Stubbing stubbing : container.getStubbingsDescending()) {
-            if (container.getInvocationForStubbing().matches(stubbing.getInvocation())) {
-                return stubbing.answer(invocation);
-            }
+        Answer existingAnswer = container.findStubbedAnswer();
+        if (existingAnswer != null) {
+            return existingAnswer.answer(invocation);
         }
 
         // record deep stub answer
-        StubbedInvocationMatcher stubbing = recordDeepStubAnswer(
-                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
-                container
-        );
+        StubbedInvocationMatcher stubbing =
+                recordDeepStubAnswer(
+                        newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
+                        container);
 
         // deep stubbing creates a stubbing and immediately uses it
         // so the stubbing is actually used by the same invocation
@@ -88,50 +105,60 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {
      * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.
      *
      * @param returnTypeGenericMetadata The metadata to use to create the new mock.
-     * @param parentMock The parent of the current deep stub mock.
+     * @param parentMock                The parent of the current deep stub mock.
      * @return The mock
      */
-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
+    private Object newDeepStubMock(
+            GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
         MockCreationSettings parentMockSettings = MockUtil.getMockSettings(parentMock);
-        return mockitoCore().mock(
-                returnTypeGenericMetadata.rawType(),
-                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
-        );
+        return mockitoCore()
+                .mock(
+                        returnTypeGenericMetadata.rawType(),
+                        withSettingsUsing(returnTypeGenericMetadata, parentMockSettings));
     }
 
-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
-        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
-                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
-                : withSettings();
+    private MockSettings withSettingsUsing(
+            GenericMetadataSupport returnTypeGenericMetadata,
+            MockCreationSettings parentMockSettings) {
+        MockSettings mockSettings =
+                returnTypeGenericMetadata.hasRawExtraInterfaces()
+                        ? withSettings()
+                                .extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
+                        : withSettings();
 
         return propagateSerializationSettings(mockSettings, parentMockSettings)
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
-    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
+    private MockSettings propagateSerializationSettings(
+            MockSettings mockSettings, MockCreationSettings parentMockSettings) {
         return mockSettings.serializable(parentMockSettings.getSerializableMode());
     }
 
-    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(
+            final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
     }
 
-    private StubbedInvocationMatcher recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) {
+    private StubbedInvocationMatcher recordDeepStubAnswer(
+            final Object mock, InvocationContainerImpl container) {
         DeeplyStubbedAnswer answer = new DeeplyStubbedAnswer(mock);
         return container.addAnswer(answer, false, null);
     }
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
-        CreationSettings mockSettings = (CreationSettings) MockUtil.getMockHandler(mock).getMockSettings();
+        CreationSettings mockSettings =
+                (CreationSettings) MockUtil.getMockHandler(mock).getMockSettings();
         return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());
     }
 
-
-    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs implements Serializable {
+    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs
+            implements Serializable {
         @SuppressWarnings("serial") // not gonna be serialized
         private final GenericMetadataSupport returnTypeGenericMetadata;
 
-        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {
+        public ReturnsDeepStubsSerializationFallback(
+                GenericMetadataSupport returnTypeGenericMetadata) {
             this.returnTypeGenericMetadata = returnTypeGenericMetadata;
         }
 
@@ -139,25 +166,35 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {
         protected GenericMetadataSupport actualParameterizedType(Object mock) {
             return returnTypeGenericMetadata;
         }
+
+        /**
+         * Generics support and serialization with deep stubs don't work together.
+         * <p>
+         * The issue is that GenericMetadataSupport is not serializable because
+         * the type elements inferred via reflection are not serializable. Supporting
+         * serialization would require to replace all types coming from the Java reflection
+         * with our own and still managing type equality with the JDK ones.
+         */
         private Object writeReplace() throws IOException {
             return Mockito.RETURNS_DEEP_STUBS;
         }
     }
 
-
     private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {
-        @SuppressWarnings("serial") // serialization will fail with a nice message if mock not serializable
+        @SuppressWarnings(
+                "serial") // serialization will fail with a nice message if mock not serializable
         private final Object mock;
 
         DeeplyStubbedAnswer(Object mock) {
             this.mock = mock;
         }
+
+        @Override
         public Object answer(InvocationOnMock invocation) throws Throwable {
             return mock;
         }
     }
 
-
     private static MockitoCore mockitoCore() {
         return LazyHolder.MOCKITO_CORE;
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
index 8452589..ad8e7e2 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
@@ -4,6 +4,24 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import static org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod;
+import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.TreeMap;
+import java.util.TreeSet;
 import org.mockito.internal.util.JavaEightUtil;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.Primitives;
@@ -11,12 +29,6 @@ import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockName;
 import org.mockito.stubbing.Answer;
 
-import static org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod;
-import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
-
-import java.io.Serializable;
-import java.util.*;
-
 /**
  * Default answer of every Mockito mock.
  * <ul>
@@ -42,6 +54,9 @@ import java.util.*;
  * Returns an {@code java.util.stream.Stream#empty() empty Stream} for Stream. Similarly for primitive stream variants.
  * </li>
  * <li>
+ * Returns an {@code java.time.Duration.ZERO zero Duration} for empty Duration and {@code java.time.Period.ZERO zero Period} for empty Period.
+ * </li>
+ * <li>
  * Returns null for everything else
  * </li>
  * </ul>
@@ -50,23 +65,27 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {
 
     private static final long serialVersionUID = 1998191268711234347L;
 
-
     /* (non-Javadoc)
      * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)
      */
+    @Override
     public Object answer(InvocationOnMock invocation) {
         if (isToStringMethod(invocation.getMethod())) {
             Object mock = invocation.getMock();
             MockName name = MockUtil.getMockName(mock);
             if (name.isDefault()) {
-                return "Mock for " + MockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + ", hashCode: " + mock.hashCode();
+                return "Mock for "
+                        + MockUtil.getMockSettings(mock).getTypeToMock().getSimpleName()
+                        + ", hashCode: "
+                        + mock.hashCode();
             } else {
                 return name.toString();
             }
         } else if (isCompareToMethod(invocation.getMethod())) {
-            //see issue 184.
-            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
-            //Only for compareTo() method by the Comparable interface
+            // see issue 184.
+            // mocks by default should return 0 if references are the same, otherwise some other
+            // value because they are not the same. Hence we return 1 (anything but 0 is good).
+            // Only for compareTo() method by the Comparable interface
             return invocation.getMock() == invocation.getArgument(0) ? 0 : 1;
         }
 
@@ -77,38 +96,39 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {
     Object returnValueFor(Class<?> type) {
         if (Primitives.isPrimitiveOrWrapper(type)) {
             return Primitives.defaultValue(type);
-            //new instances are used instead of Collections.emptyList(), etc.
-            //to avoid UnsupportedOperationException if code under test modifies returned collection
+            // new instances are used instead of Collections.emptyList(), etc.
+            // to avoid UnsupportedOperationException if code under test modifies returned
+            // collection
         } else if (type == Iterable.class) {
-            return new ArrayList<Object>(0);
+            return new ArrayList<>(0);
         } else if (type == Collection.class) {
-            return new LinkedList<Object>();
+            return new LinkedList<>();
         } else if (type == Set.class) {
-            return new HashSet<Object>();
+            return new HashSet<>();
         } else if (type == HashSet.class) {
-            return new HashSet<Object>();
+            return new HashSet<>();
         } else if (type == SortedSet.class) {
-            return new TreeSet<Object>();
+            return new TreeSet<>();
         } else if (type == TreeSet.class) {
-            return new TreeSet<Object>();
+            return new TreeSet<>();
         } else if (type == LinkedHashSet.class) {
-            return new LinkedHashSet<Object>();
+            return new LinkedHashSet<>();
         } else if (type == List.class) {
-            return new LinkedList<Object>();
+            return new LinkedList<>();
         } else if (type == LinkedList.class) {
-            return new LinkedList<Object>();
+            return new LinkedList<>();
         } else if (type == ArrayList.class) {
-            return new ArrayList<Object>();
+            return new ArrayList<>();
         } else if (type == Map.class) {
-            return new HashMap<Object, Object>();
+            return new HashMap<>();
         } else if (type == HashMap.class) {
-            return new HashMap<Object, Object>();
+            return new HashMap<>();
         } else if (type == SortedMap.class) {
-            return new TreeMap<Object, Object>();
+            return new TreeMap<>();
         } else if (type == TreeMap.class) {
-            return new TreeMap<Object, Object>();
+            return new TreeMap<>();
         } else if (type == LinkedHashMap.class) {
-            return new LinkedHashMap<Object, Object>();
+            return new LinkedHashMap<>();
         } else if ("java.util.Optional".equals(type.getName())) {
             return JavaEightUtil.emptyOptional();
         } else if ("java.util.OptionalDouble".equals(type.getName())) {
@@ -125,9 +145,13 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {
             return JavaEightUtil.emptyIntStream();
         } else if ("java.util.stream.LongStream".equals(type.getName())) {
             return JavaEightUtil.emptyLongStream();
+        } else if ("java.time.Duration".equals(type.getName())) {
+            return JavaEightUtil.emptyDuration();
+        } else if ("java.time.Period".equals(type.getName())) {
+            return JavaEightUtil.emptyPeriod();
         }
 
-        //Let's not care about the rest of collections.
+        // Let's not care about the rest of collections.
         return null;
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java
index 302e4df..0ef6f0d 100755
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java
@@ -4,33 +4,39 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
-import org.mockito.internal.MockitoCore;
+import java.io.Serializable;
+
+import org.mockito.Mockito;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import java.io.Serializable;
-
 public class ReturnsMocks implements Answer<Object>, Serializable {
 
     private static final long serialVersionUID = -6755257986994634579L;
-    private final MockitoCore mockitoCore = new MockitoCore();
     private final Answer<Object> delegate = new ReturnsMoreEmptyValues();
 
-    public Object answer(InvocationOnMock invocation) throws Throwable {
-        Object ret = delegate.answer(invocation);
-        if (ret != null) {
-            return ret;
-        }
-
-        return returnValueFor(invocation.getMethod().getReturnType());
-    }
+    @Override
+    public Object answer(final InvocationOnMock invocation) throws Throwable {
+        Object defaultReturnValue = delegate.answer(invocation);
 
-    Object returnValueFor(Class<?> clazz) {
-        if (!mockitoCore.isTypeMockable(clazz)) {
-            return null;
+        if (defaultReturnValue != null) {
+            return defaultReturnValue;
         }
 
-        return mockitoCore.mock(clazz, new MockSettingsImpl().defaultAnswer(this));
+        return RetrieveGenericsForDefaultAnswers.returnTypeForMockWithCorrectGenerics(
+                invocation,
+                new RetrieveGenericsForDefaultAnswers.AnswerCallback() {
+                    @Override
+                    public Object apply(Class<?> type) {
+                        if (type == null) {
+                            return null;
+                        }
+
+                        return Mockito.mock(
+                                type,
+                                new MockSettingsImpl<Object>().defaultAnswer(ReturnsMocks.this));
+                    }
+                });
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java
index 6111887..c39f535 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java
@@ -2,17 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.stubbing.defaultanswers;
 
 import java.io.Serializable;
 import java.lang.reflect.Array;
+
 import org.mockito.Mockito;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 /**
- * It's likely this implementation will be used by default by every Mockito 3.0.0 mock.
+ * It's likely this implementation will be used by default by every Mockito 4.0.0 mock.
  * <p>
  * Currently <b>used only</b> by {@link Mockito#RETURNS_SMART_NULLS}
  * <p>
@@ -52,6 +52,7 @@ public class ReturnsMoreEmptyValues implements Answer<Object>, Serializable {
     /* (non-Javadoc)
      * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)
      */
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         Object ret = delegate.answer(invocation);
         if (ret != null) {
@@ -65,7 +66,7 @@ public class ReturnsMoreEmptyValues implements Answer<Object>, Serializable {
     Object returnValueFor(Class<?> type) {
         if (type == String.class) {
             return "";
-        }  else if (type.isArray()) {
+        } else if (type.isArray()) {
             Class<?> componentType = type.getComponentType();
             return Array.newInstance(componentType, 0);
         }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
index 7487e89..2402f36 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
@@ -8,7 +8,6 @@ import static org.mockito.internal.exceptions.Reporter.smartNullPointerException
 import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 
 import java.io.Serializable;
-import java.lang.reflect.Modifier;
 
 import org.mockito.Mockito;
 import org.mockito.internal.debugging.LocationImpl;
@@ -40,32 +39,45 @@ public class ReturnsSmartNulls implements Answer<Object>, Serializable {
 
     private final Answer<Object> delegate = new ReturnsMoreEmptyValues();
 
+    @Override
     public Object answer(final InvocationOnMock invocation) throws Throwable {
         Object defaultReturnValue = delegate.answer(invocation);
+
         if (defaultReturnValue != null) {
             return defaultReturnValue;
         }
-        Class<?> type = invocation.getMethod().getReturnType();
-        if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {
-            final Location location = new LocationImpl();
-            return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));
-        }
-        return null;
+
+        return RetrieveGenericsForDefaultAnswers.returnTypeForMockWithCorrectGenerics(
+                invocation,
+                new RetrieveGenericsForDefaultAnswers.AnswerCallback() {
+                    @Override
+                    public Object apply(Class<?> type) {
+                        if (type == null) {
+                            return null;
+                        }
+
+                        return Mockito.mock(
+                                type, new ThrowsSmartNullPointer(invocation, new LocationImpl()));
+                    }
+                });
     }
 
     private static class ThrowsSmartNullPointer implements Answer {
+
         private final InvocationOnMock unstubbedInvocation;
+
         private final Location location;
 
-        public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {
+        ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {
             this.unstubbedInvocation = unstubbedInvocation;
             this.location = location;
         }
 
+        @Override
         public Object answer(InvocationOnMock currentInvocation) throws Throwable {
             if (isToStringMethod(currentInvocation.getMethod())) {
-                return "SmartNull returned by this unstubbed method call on a mock:\n" +
-                        unstubbedInvocation.toString();
+                return "SmartNull returned by this unstubbed method call on a mock:\n"
+                        + unstubbedInvocation;
             }
 
             throw smartNullPointerException(unstubbedInvocation.toString(), location);
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/TriesToReturnSelf.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/TriesToReturnSelf.java
index 27cf121..58a64d7 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/TriesToReturnSelf.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/TriesToReturnSelf.java
@@ -4,16 +4,17 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import java.io.Serializable;
+
 import org.mockito.internal.util.MockUtil;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import java.io.Serializable;
-
-public class TriesToReturnSelf implements Answer<Object>, Serializable{
+public class TriesToReturnSelf implements Answer<Object>, Serializable {
 
     private final ReturnsEmptyValues defaultReturn = new ReturnsEmptyValues();
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
         Class<?> methodReturnType = invocation.getMethod().getReturnType();
         Object mock = invocation.getMock();
@@ -25,5 +26,4 @@ public class TriesToReturnSelf implements Answer<Object>, Serializable{
 
         return defaultReturn.returnValueFor(methodReturnType);
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/util/Checks.java b/src/main/java/org/mockito/internal/util/Checks.java
index b672f6a..f7ed59d 100644
--- a/src/main/java/org/mockito/internal/util/Checks.java
+++ b/src/main/java/org/mockito/internal/util/Checks.java
@@ -2,20 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util;
 
-/**
- * Pre-made preconditions
- */
-public class Checks {
+/** Pre-made preconditions */
+public final class Checks {
 
     public static <T> T checkNotNull(T value, String checkedValue) {
         return checkNotNull(value, checkedValue, null);
     }
 
     public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
-        if(value == null) {
+        if (value == null) {
             String message = checkedValue + " should not be null";
             if (additionalMessage != null) {
                 message += ". " + additionalMessage;
@@ -32,4 +29,6 @@ public class Checks {
         }
         return iterable;
     }
+
+    private Checks() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/ConsoleMockitoLogger.java b/src/main/java/org/mockito/internal/util/ConsoleMockitoLogger.java
index d8df8eb..aff681c 100644
--- a/src/main/java/org/mockito/internal/util/ConsoleMockitoLogger.java
+++ b/src/main/java/org/mockito/internal/util/ConsoleMockitoLogger.java
@@ -4,9 +4,13 @@
  */
 package org.mockito.internal.util;
 
+import org.mockito.plugins.MockitoLogger;
+
 public class ConsoleMockitoLogger implements MockitoLogger {
 
-    /* (non-Javadoc)
+    /**
+     * (non-Javadoc)
+     *
      * @see org.mockito.internal.util.Logger#print(java.lang.Object)
      */
     public void log(Object what) {
diff --git a/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java b/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
index 4f739cd..1ad5a75 100644
--- a/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
+++ b/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.internal.util;
 
+import java.util.Collection;
+
 import org.mockito.MockingDetails;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.debugging.InvocationsPrinter;
@@ -13,8 +15,6 @@ import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Collection;
-
 /**
  * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is
  * a wrapper for {@link org.mockito.internal.util.MockUtil}.
@@ -23,17 +23,17 @@ public class DefaultMockingDetails implements MockingDetails {
 
     private final Object toInspect;
 
-    public DefaultMockingDetails(Object toInspect){
+    public DefaultMockingDetails(Object toInspect) {
         this.toInspect = toInspect;
     }
 
     @Override
-    public boolean isMock(){
+    public boolean isMock() {
         return MockUtil.isMock(toInspect);
     }
 
     @Override
-    public boolean isSpy(){
+    public boolean isSpy() {
         return MockUtil.isSpy(toInspect);
     }
 
@@ -73,17 +73,20 @@ public class DefaultMockingDetails implements MockingDetails {
         return toInspect;
     }
 
-    private MockHandler<Object> mockHandler() {
+    private MockHandler<?> mockHandler() {
         assertGoodMock();
         return MockUtil.getMockHandler(toInspect);
     }
 
     private void assertGoodMock() {
         if (toInspect == null) {
-            throw new NotAMockException("Argument passed to Mockito.mockingDetails() should be a mock, but is null!");
+            throw new NotAMockException(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is null!");
         } else if (!isMock()) {
-            throw new NotAMockException("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of " + toInspect.getClass() + "!");
+            throw new NotAMockException(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of "
+                            + toInspect.getClass()
+                            + "!");
         }
     }
 }
-
diff --git a/src/main/java/org/mockito/internal/util/JavaEightUtil.java b/src/main/java/org/mockito/internal/util/JavaEightUtil.java
index 80ac635..20c6e80 100644
--- a/src/main/java/org/mockito/internal/util/JavaEightUtil.java
+++ b/src/main/java/org/mockito/internal/util/JavaEightUtil.java
@@ -4,10 +4,11 @@
  */
 package org.mockito.internal.util;
 
-import org.mockito.internal.creation.instance.InstantiationException;
-
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 
+import org.mockito.creation.instance.InstantiationException;
+
 /**
  * Helper class to work with features that were introduced in Java versions after 1.5.
  * This class uses reflection in most places to avoid coupling with a newer JDK.
@@ -19,6 +20,8 @@ public final class JavaEightUtil {
     private static Object emptyOptionalDouble;
     private static Object emptyOptionalInt;
     private static Object emptyOptionalLong;
+    private static Object emptyDuration;
+    private static Object emptyPeriod;
 
     private JavaEightUtil() {
         // utility class
@@ -38,7 +41,6 @@ public final class JavaEightUtil {
         return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
     }
 
-
     /**
      * Creates an empty OptionalDouble using reflection to stay backwards-compatible with older JDKs.
      *
@@ -50,7 +52,8 @@ public final class JavaEightUtil {
             return emptyOptionalDouble;
         }
 
-        return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
+        return emptyOptionalDouble =
+                invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
     }
 
     /**
@@ -121,6 +124,34 @@ public final class JavaEightUtil {
         return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
     }
 
+    /**
+     * Creates an empty Duration using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @return an empty (ZERO) Duration.
+     */
+    public static Object emptyDuration() {
+        // no need for double-checked locking
+        if (emptyDuration != null) {
+            return emptyDuration;
+        }
+
+        return emptyDuration = getStaticFieldValue("java.time.Duration", "ZERO");
+    }
+
+    /**
+     * Creates an empty Period using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @return an empty (ZERO) Period.
+     */
+    public static Object emptyPeriod() {
+        // no need for double-checked locking
+        if (emptyPeriod != null) {
+            return emptyPeriod;
+        }
+
+        return emptyPeriod = getStaticFieldValue("java.time.Period", "ZERO");
+    }
+
     /**
      * Invokes a nullary static factory method using reflection to stay backwards-compatible with older JDKs.
      *
@@ -130,9 +161,7 @@ public final class JavaEightUtil {
      */
     private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
         try {
-            final Class<?> type = Class.forName(fqcn);
-            final Method method = type.getMethod(methodName);
-
+            final Method method = getMethod(fqcn, methodName);
             return method.invoke(null);
             // any exception is really unexpected since the type name has
             // already been verified
@@ -141,4 +170,59 @@ public final class JavaEightUtil {
                     String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
         }
     }
+
+    /**
+     * Gets a value of the classes' field using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @param fieldName The name of th classes' field which value is going to be returned.
+     * @return the restored value.
+     */
+    private static Object getStaticFieldValue(final String fqcn, final String fieldName) {
+        try {
+            final Class<?> type = getClass(fqcn);
+            final Field field = type.getField(fieldName);
+            return field.get(null);
+            // any exception is really unexpected since the type name has
+            // already been verified
+        } catch (Exception e) {
+            throw new InstantiationException(
+                    String.format("Could not get %s#%s(): %s", fqcn, fieldName, e), e);
+        }
+    }
+
+    /**
+     * Returns the {@code Class} object associated with the class or interface with the given string name.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @return the Class object for the class with the specified name.
+     */
+    private static Class<?> getClass(String fqcn) {
+        try {
+            return Class.forName(fqcn);
+            // any exception is really unexpected since the type name has
+            // already been verified
+        } catch (ClassNotFoundException e) {
+            throw new InstantiationException(String.format("Could not find %s: %s", fqcn, e), e);
+        }
+    }
+
+    /**
+     * Returns a Method object that reflects the specified public member method of the class or interface represented by the fully qualified class name.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @param methodName The name of the method.
+     * @param parameterClasses The list of parameters.
+     * @return The Method object that matches the specified name and parameterTypes.
+     */
+    private static Method getMethod(
+            final String fqcn, final String methodName, final Class<?>... parameterClasses) {
+        try {
+            final Class<?> type = getClass(fqcn);
+            return type.getMethod(methodName, parameterClasses);
+        } catch (Exception e) {
+            throw new InstantiationException(
+                    String.format("Could not find %s#%s(): %s", fqcn, methodName, e), e);
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/util/KotlinInlineClassUtil.java b/src/main/java/org/mockito/internal/util/KotlinInlineClassUtil.java
new file mode 100644
index 0000000..890f160
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/KotlinInlineClassUtil.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util;
+
+import org.mockito.internal.exceptions.Reporter;
+import org.mockito.internal.stubbing.answers.InvocationInfo;
+import org.mockito.invocation.InvocationOnMock;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class KotlinInlineClassUtil {
+    private static Class<Annotation> jvmInlineAnnotation;
+
+    static {
+        try {
+            jvmInlineAnnotation = (Class<Annotation>) Class.forName("kotlin.jvm.JvmInline");
+        } catch (ClassNotFoundException e) {
+            // Do nothing: kotlin is pre 1.5.0
+        }
+    }
+
+    // When mocking function, returning inline class, its return type is
+    // underlying type.
+    // So, `thenReturn` calls fails, because of non-compatible types.
+    public static boolean isInlineClassWithAssignableUnderlyingType(
+            Class<?> inlineClass, Class<?> underlyingType) {
+        try {
+            // Since 1.5.0 inline classes have @JvmInline annotation
+            if (jvmInlineAnnotation == null
+                    || !inlineClass.isAnnotationPresent(jvmInlineAnnotation)) return false;
+
+            // All inline classes have 'box-impl' method, which accepts
+            // underlying type and returns inline class.
+            // Make sure that the current inline class is also the class that is compatible with the
+            // underlying type.
+            // If we don't make this check, then we would potentially pass a mock of inline type A
+            // into a method
+            // that accepts inline type B.
+            Object ignored = inlineClass.getDeclaredMethod("box-impl", underlyingType);
+            return true;
+        } catch (NoSuchMethodException e) {
+            return false;
+        }
+    }
+
+    private static Object unboxInlineClassIfPossible(Object boxedValue) {
+        Class<?> inlineClass = boxedValue.getClass();
+        try {
+            Method unboxImpl = inlineClass.getDeclaredMethod("unbox-impl");
+            return unboxImpl.invoke(boxedValue);
+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+            throw Reporter.inlineClassWithoutUnboxImpl(inlineClass, e);
+        }
+    }
+
+    public static Object unboxUnderlyingValueIfNeeded(InvocationOnMock invocation, Object value) {
+        // Short path - Kotlin 1.5+ is not present.
+        if (value == null || jvmInlineAnnotation == null) {
+            return value;
+        }
+
+        Class<?> valueType = value.getClass();
+        InvocationInfo invocationInfo = new InvocationInfo(invocation);
+        Class<?> returnType = invocationInfo.getMethod().getReturnType();
+        if (valueType.isAssignableFrom(returnType)) return value;
+
+        if (isInlineClassWithAssignableUnderlyingType(valueType, returnType)) {
+            return unboxInlineClassIfPossible(value);
+        } else {
+            return value;
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/util/MockCreationValidator.java b/src/main/java/org/mockito/internal/util/MockCreationValidator.java
index 5dba346..7baa4e2 100644
--- a/src/main/java/org/mockito/internal/util/MockCreationValidator.java
+++ b/src/main/java/org/mockito/internal/util/MockCreationValidator.java
@@ -25,7 +25,8 @@ public class MockCreationValidator {
         }
     }
 
-    public void validateExtraInterfaces(Class<?> classToMock, Collection<Class<?>> extraInterfaces) {
+    public void validateExtraInterfaces(
+            Class<?> classToMock, Collection<Class<?>> extraInterfaces) {
         if (extraInterfaces == null) {
             return;
         }
diff --git a/src/main/java/org/mockito/internal/util/MockNameImpl.java b/src/main/java/org/mockito/internal/util/MockNameImpl.java
index 7759979..6374687 100644
--- a/src/main/java/org/mockito/internal/util/MockNameImpl.java
+++ b/src/main/java/org/mockito/internal/util/MockNameImpl.java
@@ -4,10 +4,10 @@
  */
 package org.mockito.internal.util;
 
-import org.mockito.mock.MockName;
-
 import java.io.Serializable;
 
+import org.mockito.mock.MockName;
+
 public class MockNameImpl implements MockName, Serializable {
 
     private static final long serialVersionUID = 8014974700844306925L;
@@ -15,9 +15,9 @@ public class MockNameImpl implements MockName, Serializable {
     private boolean defaultName;
 
     @SuppressWarnings("unchecked")
-    public MockNameImpl(String mockName, Class<?> classToMock) {
+    public MockNameImpl(String mockName, Class<?> type, boolean mockedStatic) {
         if (mockName == null) {
-            this.mockName = toInstanceName(classToMock);
+            this.mockName = mockedStatic ? toClassName(type) : toInstanceName(type);
             this.defaultName = true;
         } else {
             this.mockName = mockName;
@@ -31,13 +31,23 @@ public class MockNameImpl implements MockName, Serializable {
     private static String toInstanceName(Class<?> clazz) {
         String className = clazz.getSimpleName();
         if (className.length() == 0) {
-            //it's an anonymous class, let's get name from the parent
+            // it's an anonymous class, let's get name from the parent
             className = clazz.getSuperclass().getSimpleName();
         }
-        //lower case first letter
+        // lower case first letter
         return className.substring(0, 1).toLowerCase() + className.substring(1);
     }
 
+    private static String toClassName(Class<?> clazz) {
+        String className = clazz.getSimpleName();
+        if (className.length() == 0) {
+            // it's an anonymous class, let's get name from the parent
+            className = clazz.getSuperclass().getSimpleName() + "$";
+        }
+        return className + ".class";
+    }
+
+    @Override
     public boolean isDefault() {
         return defaultName;
     }
diff --git a/src/main/java/org/mockito/internal/util/MockUtil.java b/src/main/java/org/mockito/internal/util/MockUtil.java
index df0deb1..2159608 100644
--- a/src/main/java/org/mockito/internal/util/MockUtil.java
+++ b/src/main/java/org/mockito/internal/util/MockUtil.java
@@ -4,6 +4,7 @@
  */
 package org.mockito.internal.util;
 
+import org.mockito.MockedConstruction;
 import org.mockito.Mockito;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.configuration.plugins.Plugins;
@@ -15,6 +16,9 @@ import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.MockName;
 import org.mockito.plugins.MockMaker;
 import org.mockito.plugins.MockMaker.TypeMockability;
+import org.mockito.plugins.MockResolver;
+
+import java.util.function.Function;
 
 import static org.mockito.internal.handler.MockHandlerFactory.createMockHandler;
 
@@ -26,37 +30,51 @@ public class MockUtil {
     private MockUtil() {}
 
     public static TypeMockability typeMockabilityOf(Class<?> type) {
-      return mockMaker.isTypeMockable(type);
+        return mockMaker.isTypeMockable(type);
     }
 
     public static <T> T createMock(MockCreationSettings<T> settings) {
-        MockHandler mockHandler =  createMockHandler(settings);
-
-        T mock = mockMaker.createMock(settings, mockHandler);
+        MockHandler mockHandler = createMockHandler(settings);
 
         Object spiedInstance = settings.getSpiedInstance();
+
+        T mock;
         if (spiedInstance != null) {
-            new LenientCopyTool().copyToMock(spiedInstance, mock);
+            mock =
+                    mockMaker
+                            .createSpy(settings, mockHandler, (T) spiedInstance)
+                            .orElseGet(
+                                    () -> {
+                                        T instance = mockMaker.createMock(settings, mockHandler);
+                                        new LenientCopyTool().copyToMock(spiedInstance, instance);
+                                        return instance;
+                                    });
+        } else {
+            mock = mockMaker.createMock(settings, mockHandler);
         }
 
         return mock;
     }
 
-    public static <T> void resetMock(T mock) {
+    public static void resetMock(Object mock) {
         MockHandler oldHandler = getMockHandler(mock);
         MockCreationSettings settings = oldHandler.getMockSettings();
         MockHandler newHandler = createMockHandler(settings);
 
+        mock = resolve(mock);
         mockMaker.resetMock(mock, newHandler, settings);
     }
 
-    public static <T> MockHandler<T> getMockHandler(T mock) {
+    public static MockHandler<?> getMockHandler(Object mock) {
         if (mock == null) {
             throw new NotAMockException("Argument should be a mock, but is null!");
         }
 
-        if (isMock(mock)) {
-            return mockMaker.getHandler(mock);
+        mock = resolve(mock);
+
+        MockHandler handler = mockMaker.getHandler(mock);
+        if (handler != null) {
+            return handler;
         } else {
             throw new NotAMockException("Argument should be a mock, but is: " + mock.getClass());
         }
@@ -67,18 +85,43 @@ public class MockUtil {
     }
 
     public static boolean isSpy(Object mock) {
-        return isMock(mock) && getMockSettings(mock).getDefaultAnswer() == Mockito.CALLS_REAL_METHODS;
+        return isMock(mock)
+                && getMockSettings(mock).getDefaultAnswer() == Mockito.CALLS_REAL_METHODS;
     }
 
     public static boolean isMock(Object mock) {
-        // TODO SF (perf tweak) in our codebase we call mockMaker.getHandler() multiple times unnecessarily
-        // This is not ideal because getHandler() can be expensive (reflective calls inside mock maker)
-        // The frequent pattern in the codebase are separate calls to: 1) isMock(mock) then 2) getMockHandler(mock)
+        // TODO SF (perf tweak) in our codebase we call mockMaker.getHandler() multiple times
+        // unnecessarily
+        // This is not ideal because getHandler() can be expensive (reflective calls inside mock
+        // maker)
+        // The frequent pattern in the codebase are separate calls to: 1) isMock(mock) then 2)
+        // getMockHandler(mock)
         // We could replace it with using mockingDetails().isMock()
         // Let's refactor the codebase and use new mockingDetails() in all relevant places.
-        // Potentially we could also move other methods to MockitoMock, some other candidates: getInvocationContainer, isSpy, etc.
+        // Potentially we could also move other methods to MockitoMock, some other candidates:
+        // getInvocationContainer, isSpy, etc.
         // This also allows us to reuse our public API MockingDetails
-        return mock != null && mockMaker.getHandler(mock) != null;
+        if (mock == null) {
+            return false;
+        }
+
+        mock = resolve(mock);
+
+        return mockMaker.getHandler(mock) != null;
+    }
+
+    private static Object resolve(Object mock) {
+        if (mock instanceof Class<?>) { // static mocks are resolved by definition
+            return mock;
+        }
+        for (MockResolver mockResolver : Plugins.getMockResolvers()) {
+            mock = mockResolver.resolve(mock);
+        }
+        return mock;
+    }
+
+    public static boolean areSameMocks(Object mockA, Object mockB) {
+        return mockA == mockB || resolve(mockA) == resolve(mockB);
     }
 
     public static MockName getMockName(Object mock) {
@@ -87,9 +130,9 @@ public class MockUtil {
 
     public static void maybeRedefineMockName(Object mock, String newName) {
         MockName mockName = getMockName(mock);
-        //TODO SF hacky...
+        // TODO SF hacky...
         MockCreationSettings mockSettings = getMockHandler(mock).getMockSettings();
-		if (mockName.isDefault() && mockSettings instanceof CreationSettings) {
+        if (mockName.isDefault() && mockSettings instanceof CreationSettings) {
             ((CreationSettings) mockSettings).setMockName(new MockNameImpl(newName));
         }
     }
@@ -97,4 +140,24 @@ public class MockUtil {
     public static MockCreationSettings getMockSettings(Object mock) {
         return getMockHandler(mock).getMockSettings();
     }
+
+    public static <T> MockMaker.StaticMockControl<T> createStaticMock(
+            Class<T> type, MockCreationSettings<T> settings) {
+        MockHandler<T> handler = createMockHandler(settings);
+        return mockMaker.createStaticMock(type, settings, handler);
+    }
+
+    public static <T> MockMaker.ConstructionMockControl<T> createConstructionMock(
+            Class<T> type,
+            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        Function<MockedConstruction.Context, MockHandler<T>> handlerFactory =
+                context -> createMockHandler(settingsFactory.apply(context));
+        return mockMaker.createConstructionMock(
+                type, settingsFactory, handlerFactory, mockInitializer);
+    }
+
+    public static void clearAllCaches() {
+        mockMaker.clearAllCaches();
+    }
 }
diff --git a/src/main/java/org/mockito/internal/util/MockitoLogger.java b/src/main/java/org/mockito/internal/util/MockitoLogger.java
deleted file mode 100644
index af66cee..0000000
--- a/src/main/java/org/mockito/internal/util/MockitoLogger.java
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util;
-
-public interface MockitoLogger {
-
-    void log(Object what);
-
-}
diff --git a/src/main/java/org/mockito/internal/util/ObjectMethodsGuru.java b/src/main/java/org/mockito/internal/util/ObjectMethodsGuru.java
index d2a1690..b46f29a 100644
--- a/src/main/java/org/mockito/internal/util/ObjectMethodsGuru.java
+++ b/src/main/java/org/mockito/internal/util/ObjectMethodsGuru.java
@@ -5,19 +5,19 @@
 package org.mockito.internal.util;
 
 import java.lang.reflect.Method;
+
 import org.mockito.internal.creation.DelegatingMethod;
 import org.mockito.internal.invocation.MockitoMethod;
 
-public class ObjectMethodsGuru{
+public class ObjectMethodsGuru {
 
-    private ObjectMethodsGuru() {
-    }
+    private ObjectMethodsGuru() {}
 
     public static boolean isToStringMethod(Method method) {
         MockitoMethod m = new DelegatingMethod(method);
-        return m.getReturnType() == String.class &&
-               m.getParameterTypes().length == 0 &&
-               "toString".equals(m.getName());
+        return m.getReturnType() == String.class
+                && m.getParameterTypes().length == 0
+                && "toString".equals(m.getName());
     }
 
     public static boolean isCompareToMethod(Method method) {
diff --git a/src/main/java/org/mockito/internal/util/Platform.java b/src/main/java/org/mockito/internal/util/Platform.java
index 897ebed..946e4ff 100644
--- a/src/main/java/org/mockito/internal/util/Platform.java
+++ b/src/main/java/org/mockito/internal/util/Platform.java
@@ -4,16 +4,18 @@
  */
 package org.mockito.internal.util;
 
+import static org.mockito.internal.util.StringUtil.join;
+
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static org.mockito.internal.util.StringUtil.join;
-
 public abstract class Platform {
 
-    private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME = Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
-    private static final Pattern JAVA_8_DEV_VERSION_SCHEME = Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
+    private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME =
+            Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
+    private static final Pattern JAVA_8_DEV_VERSION_SCHEME =
+            Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
     public static final String JAVA_VERSION = System.getProperty("java.specification.version");
     public static final String JVM_VERSION = System.getProperty("java.runtime.version");
     public static final String JVM_VENDOR = System.getProperty("java.vm.vendor");
@@ -23,8 +25,7 @@ public abstract class Platform {
     public static final String OS_NAME = System.getProperty("os.name");
     public static final String OS_VERSION = System.getProperty("os.version");
 
-    private Platform() {
-    }
+    private Platform() {}
 
     public static boolean isAndroid() {
         return System.getProperty("java.vendor", "").toLowerCase(Locale.US).contains("android");
@@ -35,32 +36,34 @@ public abstract class Platform {
     }
 
     public static String describe() {
-        String description = String.format("Java               : %s\n" +
-                             "JVM vendor name    : %s\n" +
-                             "JVM vendor version : %s\n" +
-                             "JVM name           : %s\n" +
-                             "JVM version        : %s\n" +
-                             "JVM info           : %s\n" +
-                             "OS name            : %s\n" +
-                             "OS version         : %s\n",
-                             JAVA_VERSION,
-                             JVM_VENDOR,
-                             JVM_VENDOR_VERSION,
-                             JVM_NAME,
-                             JVM_VERSION,
-                             JVM_INFO,
-                             OS_NAME,
-                             OS_VERSION);
+        String description =
+                String.format(
+                        "Java               : %s\n"
+                                + "JVM vendor name    : %s\n"
+                                + "JVM vendor version : %s\n"
+                                + "JVM name           : %s\n"
+                                + "JVM version        : %s\n"
+                                + "JVM info           : %s\n"
+                                + "OS name            : %s\n"
+                                + "OS version         : %s\n",
+                        JAVA_VERSION,
+                        JVM_VENDOR,
+                        JVM_VENDOR_VERSION,
+                        JVM_NAME,
+                        JVM_VERSION,
+                        JVM_INFO,
+                        OS_NAME,
+                        OS_VERSION);
         if (isAndroid()) {
-            description = join(
-                    "IMPORTANT INFORMATION FOR ANDROID USERS:",
-                    "",
-                    "The regular Byte Buddy mock makers cannot generate code on an Android VM!",
-                    "To resolve this, please use the 'mockito-android' dependency for your application:",
-                    "http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22",
-                    "",
-                    description
-            );
+            description =
+                    join(
+                            "IMPORTANT INFORMATION FOR ANDROID USERS:",
+                            "",
+                            "The regular Byte Buddy mock makers cannot generate code on an Android VM!",
+                            "To resolve this, please use the 'mockito-android' dependency for your application:",
+                            "https://search.maven.org/artifact/org.mockito/mockito-android",
+                            "",
+                            description);
         }
         return description;
     }
@@ -84,19 +87,19 @@ public abstract class Platform {
 
         matcher = Pattern.compile("1\\.8\\.0-b\\d+").matcher(jvmVersion);
         return matcher.matches();
-
     }
 
-    public static String warnForVM(String vmName1, String warnMessage1,
-                                   String vmName2, String warnMessage2) {
-        return warnForVM(JVM_NAME,
-                         vmName1, warnMessage1,
-                         vmName2, warnMessage2);
+    public static String warnForVM(
+            String vmName1, String warnMessage1, String vmName2, String warnMessage2) {
+        return warnForVM(JVM_NAME, vmName1, warnMessage1, vmName2, warnMessage2);
     }
 
-    static String warnForVM(String current,
-                            String vmName1, String warnMessage1,
-                            String vmName2, String warnMessage2) {
+    static String warnForVM(
+            String current,
+            String vmName1,
+            String warnMessage1,
+            String vmName2,
+            String warnMessage2) {
         if (vmName1 != null && current.contains(vmName1)) {
             return warnMessage1;
         }
diff --git a/src/main/java/org/mockito/internal/util/Primitives.java b/src/main/java/org/mockito/internal/util/Primitives.java
index 80dd0af..ba7e5c7 100644
--- a/src/main/java/org/mockito/internal/util/Primitives.java
+++ b/src/main/java/org/mockito/internal/util/Primitives.java
@@ -8,11 +8,11 @@ import java.util.HashMap;
 import java.util.Map;
 
 @SuppressWarnings("unchecked")
-public class Primitives {
-
-    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>();
-    private static final Map<Class<?>, Object> PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES = new HashMap<Class<?>, Object>();
+public final class Primitives {
 
+    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES = new HashMap<>();
+    private static final Map<Class<?>, Object> PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES =
+            new HashMap<>();
 
     /**
      * Returns the primitive type of the given class.
@@ -43,8 +43,9 @@ public class Primitives {
     }
 
     public static boolean isAssignableFromWrapper(Class<?> valueClass, Class<?> referenceType) {
-        if(isPrimitiveOrWrapper(valueClass) && isPrimitiveOrWrapper(referenceType)) {
-            return Primitives.primitiveTypeOf(valueClass).isAssignableFrom(Primitives.primitiveTypeOf(referenceType));
+        if (isPrimitiveOrWrapper(valueClass) && isPrimitiveOrWrapper(referenceType)) {
+            return Primitives.primitiveTypeOf(valueClass)
+                    .isAssignableFrom(Primitives.primitiveTypeOf(referenceType));
         }
         return false;
     }
@@ -60,7 +61,6 @@ public class Primitives {
         return (T) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.get(primitiveOrWrapperType);
     }
 
-
     static {
         PRIMITIVE_TYPES.put(Boolean.class, Boolean.TYPE);
         PRIMITIVE_TYPES.put(Character.class, Character.TYPE);
@@ -91,4 +91,6 @@ public class Primitives {
         PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(float.class, 0F);
         PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(double.class, 0D);
     }
+
+    private Primitives() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/StringUtil.java b/src/main/java/org/mockito/internal/util/StringUtil.java
index 3070fe6..7e55666 100644
--- a/src/main/java/org/mockito/internal/util/StringUtil.java
+++ b/src/main/java/org/mockito/internal/util/StringUtil.java
@@ -28,7 +28,7 @@ public class StringUtil {
      * Joins Strings with line break character. It adds line break in front, too.
      * This makes it something like 'format' no really 'join'.
      */
-    public static String join(Object ... linesToBreak) {
+    public static String join(Object... linesToBreak) {
         return join("\n", asList(linesToBreak));
     }
 
@@ -57,10 +57,10 @@ public class StringUtil {
         for (Object line : lines) {
             out.append(linePrefix).append(line).append("\n");
         }
-        return out.substring(0, out.length() - 1); //lose last EOL
+        return out.substring(0, out.length() - 1); // lose last EOL
     }
 
-    public static String decamelizeMatcher(String className) {
+    public static String decamelizeMatcherName(String className) {
         if (className.length() == 0) {
             return "<custom argument matcher>";
         }
diff --git a/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java b/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java
index d8b581c..50e194d 100644
--- a/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java
+++ b/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java
@@ -38,8 +38,12 @@ public class HashCodeAndEqualsMockWrapper {
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof HashCodeAndEqualsMockWrapper)) return false;
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof HashCodeAndEqualsMockWrapper)) {
+            return false;
+        }
 
         HashCodeAndEqualsMockWrapper that = (HashCodeAndEqualsMockWrapper) o;
 
@@ -55,13 +59,20 @@ public class HashCodeAndEqualsMockWrapper {
         return new HashCodeAndEqualsMockWrapper(mock);
     }
 
-    @Override public String toString() {
-        return "HashCodeAndEqualsMockWrapper{" +
-                "mockInstance=" + (MockUtil.isMock(mockInstance) ? MockUtil.getMockName(mockInstance) : typeInstanceString()) +
-                '}';
+    @Override
+    public String toString() {
+        return "HashCodeAndEqualsMockWrapper{"
+                + "mockInstance="
+                + (MockUtil.isMock(mockInstance)
+                        ? MockUtil.getMockName(mockInstance)
+                        : typeInstanceString())
+                + '}';
     }
 
     private String typeInstanceString() {
-        return mockInstance.getClass().getSimpleName() + "(" + System.identityHashCode(mockInstance) + ")";
+        return mockInstance.getClass().getSimpleName()
+                + "("
+                + System.identityHashCode(mockInstance)
+                + ")";
     }
 }
diff --git a/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java b/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java
index d422dba..a547067 100644
--- a/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java
+++ b/src/main/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java
@@ -4,7 +4,7 @@
  */
 package org.mockito.internal.util.collections;
 
-import org.mockito.internal.util.Checks;
+import static java.lang.reflect.Array.*;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -12,7 +12,7 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
-import static java.lang.reflect.Array.*;
+import org.mockito.internal.util.Checks;
 
 /**
  * hashCode and equals safe hash based set.
@@ -31,12 +31,15 @@ import static java.lang.reflect.Array.*;
  */
 public class HashCodeAndEqualsSafeSet implements Set<Object> {
 
-    private final HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();
+    private final HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<>();
 
+    @Override
     public Iterator<Object> iterator() {
         return new Iterator<Object>() {
-            private final Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();
+            private final Iterator<HashCodeAndEqualsMockWrapper> iterator =
+                    backingHashSet.iterator();
 
+            @Override
             public boolean hasNext() {
                 return iterator.hasNext();
             }
@@ -51,35 +54,43 @@ public class HashCodeAndEqualsSafeSet implements Set<Object> {
         };
     }
 
+    @Override
     public int size() {
         return backingHashSet.size();
     }
 
+    @Override
     public boolean isEmpty() {
         return backingHashSet.isEmpty();
     }
 
+    @Override
     public boolean contains(Object mock) {
         return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));
     }
 
+    @Override
     public boolean add(Object mock) {
         return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));
     }
 
+    @Override
     public boolean remove(Object mock) {
         return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));
     }
 
+    @Override
     public void clear() {
         backingHashSet.clear();
     }
 
-    @Override public Object clone() throws CloneNotSupportedException {
+    @Override
+    public Object clone() throws CloneNotSupportedException {
         throw new CloneNotSupportedException();
     }
 
-    @Override public boolean equals(Object o) {
+    @Override
+    public boolean equals(Object o) {
         if (!(o instanceof HashCodeAndEqualsSafeSet)) {
             return false;
         }
@@ -87,7 +98,8 @@ public class HashCodeAndEqualsSafeSet implements Set<Object> {
         return backingHashSet.equals(that.backingHashSet);
     }
 
-    @Override public int hashCode() {
+    @Override
+    public int hashCode() {
         return backingHashSet.hashCode();
     }
 
@@ -95,6 +107,15 @@ public class HashCodeAndEqualsSafeSet implements Set<Object> {
         return unwrapTo(new Object[size()]);
     }
 
+    @SuppressWarnings("unchecked")
+    public <T> T[] toArray(T[] typedArray) {
+        T[] array =
+                typedArray.length >= size()
+                        ? typedArray
+                        : (T[]) newInstance(typedArray.getClass().getComponentType(), size());
+        return unwrapTo(array);
+    }
+
     @SuppressWarnings("unchecked")
     private <T> T[] unwrapTo(T[] array) {
         Iterator<Object> iterator = iterator();
@@ -106,39 +127,37 @@ public class HashCodeAndEqualsSafeSet implements Set<Object> {
         return array;
     }
 
-    @SuppressWarnings("unchecked")
-    public <T> T[] toArray(T[] typedArray) {
-        T[] array = typedArray.length >= size() ? typedArray : (T[]) newInstance(typedArray.getClass().getComponentType(), size());
-        return unwrapTo(array);
-    }
-
     public boolean removeAll(Collection<?> mocks) {
         return backingHashSet.removeAll(asWrappedMocks(mocks));
     }
 
+    @Override
     public boolean containsAll(Collection<?> mocks) {
         return backingHashSet.containsAll(asWrappedMocks(mocks));
     }
 
+    @Override
     public boolean addAll(Collection<?> mocks) {
         return backingHashSet.addAll(asWrappedMocks(mocks));
     }
 
+    @Override
     public boolean retainAll(Collection<?> mocks) {
         return backingHashSet.retainAll(asWrappedMocks(mocks));
     }
 
     private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {
         Checks.checkNotNull(mocks, "Passed collection should notify() be null");
-        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();
+        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<>();
         for (Object mock : mocks) {
-            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : "WRONG";
+            assert !(mock instanceof HashCodeAndEqualsMockWrapper) : "WRONG";
             hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));
         }
         return hashSet;
     }
 
-    @Override public String toString() {
+    @Override
+    public String toString() {
         return backingHashSet.toString();
     }
 
diff --git a/src/main/java/org/mockito/internal/util/collections/IdentitySet.java b/src/main/java/org/mockito/internal/util/collections/IdentitySet.java
index 76c6178..e0b2359 100644
--- a/src/main/java/org/mockito/internal/util/collections/IdentitySet.java
+++ b/src/main/java/org/mockito/internal/util/collections/IdentitySet.java
@@ -12,7 +12,7 @@ public class IdentitySet {
     private final LinkedList list = new LinkedList();
 
     public boolean contains(Object o) {
-        for(Object existing:list) {
+        for (Object existing : list) {
             if (existing == o) {
                 return true;
             }
diff --git a/src/main/java/org/mockito/internal/util/collections/Iterables.java b/src/main/java/org/mockito/internal/util/collections/Iterables.java
index 933ce89..50eb016 100644
--- a/src/main/java/org/mockito/internal/util/collections/Iterables.java
+++ b/src/main/java/org/mockito/internal/util/collections/Iterables.java
@@ -4,22 +4,20 @@
  */
 package org.mockito.internal.util.collections;
 
+import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 
-/**
- * Utilities for Iterables
- */
-public class Iterables {
+/** Utilities for Iterables */
+public final class Iterables {
 
     /**
      * Converts enumeration into iterable
      */
     public static <T> Iterable<T> toIterable(Enumeration<T> in) {
-        List<T> out = new LinkedList<T>();
-        while(in.hasMoreElements()) {
+        List<T> out = new ArrayList<T>();
+        while (in.hasMoreElements()) {
             out.add(in.nextElement());
         }
         return out;
@@ -35,8 +33,11 @@ public class Iterables {
     public static <T> T firstOf(Iterable<T> iterable) {
         Iterator<T> iterator = iterable.iterator();
         if (!iterator.hasNext()) {
-            throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
+            throw new IllegalArgumentException(
+                    "Cannot provide 1st element from empty iterable: " + iterable);
         }
         return iterator.next();
     }
+
+    private Iterables() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/collections/ListUtil.java b/src/main/java/org/mockito/internal/util/collections/ListUtil.java
index 0a4d268..f94afd8 100644
--- a/src/main/java/org/mockito/internal/util/collections/ListUtil.java
+++ b/src/main/java/org/mockito/internal/util/collections/ListUtil.java
@@ -2,19 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util.collections;
 
 import java.util.Collection;
 import java.util.LinkedList;
 
 /**
- * Basic list/collection operators.
- * We know that there are existing libraries that implement those use cases neatly.
- * However, we want to keep Mockito dependencies minimal.
- * In Java8 we should be able to get rid of this class.
+ * Basic list/collection operators. We know that there are existing libraries that implement those
+ * use cases neatly. However, we want to keep Mockito dependencies minimal. In Java8 we should be
+ * able to get rid of this class.
  */
-public class ListUtil {
+public final class ListUtil {
 
     public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {
         LinkedList<T> filtered = new LinkedList<T>();
@@ -26,9 +24,10 @@ public class ListUtil {
         return filtered;
     }
 
-    public static <From, To> LinkedList<To> convert(Collection<From> collection, Converter<From, To> converter) {
+    public static <FromT, To> LinkedList<To> convert(
+            Collection<FromT> collection, Converter<FromT, To> converter) {
         LinkedList<To> converted = new LinkedList<To>();
-        for (From f: collection) {
+        for (FromT f : collection) {
             converted.add(converter.convert(f));
         }
         return converted;
@@ -38,7 +37,9 @@ public class ListUtil {
         boolean isOut(T object);
     }
 
-    public interface Converter<From, To> {
-        To convert(From from);
+    public interface Converter<FromT, To> {
+        To convert(FromT from);
     }
+
+    private ListUtil() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/collections/Sets.java b/src/main/java/org/mockito/internal/util/collections/Sets.java
index f1972e9..f42f76a 100644
--- a/src/main/java/org/mockito/internal/util/collections/Sets.java
+++ b/src/main/java/org/mockito/internal/util/collections/Sets.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.util.collections;
 
+import static java.util.Arrays.asList;
+
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-import static java.util.Arrays.asList;
-
 public abstract class Sets {
     public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {
         return HashCodeAndEqualsSafeSet.of(mocks);
@@ -18,9 +18,10 @@ public abstract class Sets {
         return HashCodeAndEqualsSafeSet.of(mocks);
     }
 
-    public static <T> Set<T> newSet(T ... elements) {
+    public static <T> Set<T> newSet(T... elements) {
         if (elements == null) {
-            throw new IllegalArgumentException("Expected an array of elements (or empty array) but received a null.");
+            throw new IllegalArgumentException(
+                    "Expected an array of elements (or empty array) but received a null.");
         }
         return new LinkedHashSet<T>(asList(elements));
     }
diff --git a/src/main/java/org/mockito/internal/util/concurrent/DetachedThreadLocal.java b/src/main/java/org/mockito/internal/util/concurrent/DetachedThreadLocal.java
index 3768a03..9a81403 100644
--- a/src/main/java/org/mockito/internal/util/concurrent/DetachedThreadLocal.java
+++ b/src/main/java/org/mockito/internal/util/concurrent/DetachedThreadLocal.java
@@ -19,20 +19,22 @@ public class DetachedThreadLocal<T> implements Runnable {
         switch (cleaner) {
             case THREAD:
             case MANUAL:
-                map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
-                    @Override
-                    protected T defaultValue(Thread key) {
-                        return DetachedThreadLocal.this.initialValue(key);
-                    }
-                };
+                map =
+                        new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
+                            @Override
+                            protected T defaultValue(Thread key) {
+                                return DetachedThreadLocal.this.initialValue(key);
+                            }
+                        };
                 break;
             case INLINE:
-                map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
-                    @Override
-                    protected T defaultValue(Thread key) {
-                        return DetachedThreadLocal.this.initialValue(key);
-                    }
-                };
+                map =
+                        new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
+                            @Override
+                            protected T defaultValue(Thread key) {
+                                return DetachedThreadLocal.this.initialValue(key);
+                            }
+                        };
                 break;
             default:
                 throw new AssertionError();
@@ -43,6 +45,14 @@ public class DetachedThreadLocal<T> implements Runnable {
         return map.get(Thread.currentThread());
     }
 
+    /**
+     * @param thread The thread for which to set a thread-local value.
+     * @return The value associated with this thread.
+     */
+    public T get(Thread thread) {
+        return map.get(thread);
+    }
+
     public void set(T value) {
         map.put(Thread.currentThread(), value);
     }
@@ -84,15 +94,7 @@ public class DetachedThreadLocal<T> implements Runnable {
 
     /**
      * @param thread The thread for which to set a thread-local value.
-     * @return The value associated with this thread.
-     */
-    public T get(Thread thread) {
-        return map.get(thread);
-    }
-
-    /**
-     * @param thread The thread for which to set a thread-local value.
-     * @param value  The value to set.
+     * @param value The value to set.
      */
     public void define(Thread thread, T value) {
         map.put(thread, value);
@@ -133,6 +135,8 @@ public class DetachedThreadLocal<T> implements Runnable {
      * ({@link Cleaner#MANUAL}).
      */
     public enum Cleaner {
-        THREAD, INLINE, MANUAL
+        THREAD,
+        INLINE,
+        MANUAL
     }
 }
diff --git a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
index 487d223..e25c41c 100644
--- a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
+++ b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
@@ -22,7 +22,8 @@ import java.util.concurrent.atomic.AtomicLong;
  * This class does not implement the {@link java.util.Map} interface because this implementation is incompatible
  * with the map contract. While iterating over a map's entries, any key that has not passed iteration is referenced non-weakly.
  */
-public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnable, Iterable<Map.Entry<K, V>> {
+public class WeakConcurrentMap<K, V> extends ReferenceQueue<K>
+        implements Runnable, Iterable<Map.Entry<K, V>> {
 
     private static final AtomicLong ID = new AtomicLong();
 
@@ -34,7 +35,7 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
      * @param cleanerThread {@code true} if a thread should be started that removes stale entries.
      */
     public WeakConcurrentMap(boolean cleanerThread) {
-        target = new ConcurrentHashMap<WeakKey<K>, V>();
+        target = new ConcurrentHashMap<>();
         if (cleanerThread) {
             thread = new Thread(this);
             thread.setName("weak-ref-cleaner-" + ID.getAndIncrement());
@@ -52,7 +53,9 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
      */
     @SuppressWarnings("CollectionIncompatibleType")
     public V get(K key) {
-        if (key == null) throw new NullPointerException();
+        if (key == null) {
+            throw new NullPointerException();
+        }
         V value = target.get(new LatentKey<K>(key));
         if (value == null) {
             value = defaultValue(key);
@@ -72,7 +75,9 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
      */
     @SuppressWarnings("CollectionIncompatibleType")
     public boolean containsKey(K key) {
-        if (key == null) throw new NullPointerException();
+        if (key == null) {
+            throw new NullPointerException();
+        }
         return target.containsKey(new LatentKey<K>(key));
     }
 
@@ -82,7 +87,9 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
      * @return The previous entry or {@code null} if it does not exist.
      */
     public V put(K key, V value) {
-        if (key == null || value == null) throw new NullPointerException();
+        if (key == null || value == null) {
+            throw new NullPointerException();
+        }
         return target.put(new WeakKey<K>(key, this), value);
     }
 
@@ -92,7 +99,9 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
      */
     @SuppressWarnings("CollectionIncompatibleType")
     public V remove(K key) {
-        if (key == null) throw new NullPointerException();
+        if (key == null) {
+            throw new NullPointerException();
+        }
         return target.remove(new LatentKey<K>(key));
     }
 
@@ -360,7 +369,9 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
 
         @Override
         public V setValue(V value) {
-            if (value == null) throw new NullPointerException();
+            if (value == null) {
+                throw new NullPointerException();
+            }
             return entry.setValue(value);
         }
     }
diff --git a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentSet.java b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentSet.java
index 0f1cde6..d18dc3b 100644
--- a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentSet.java
+++ b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentSet.java
@@ -21,11 +21,11 @@ public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
     public WeakConcurrentSet(Cleaner cleaner) {
         switch (cleaner) {
             case INLINE:
-                target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
+                target = new WeakConcurrentMap.WithInlinedExpunction<>();
                 break;
             case THREAD:
             case MANUAL:
-                target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
+                target = new WeakConcurrentMap<>(cleaner == Cleaner.THREAD);
                 break;
             default:
                 throw new AssertionError();
@@ -53,7 +53,7 @@ public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
      * @return {@code true} if the value is contained in the set.
      */
     public boolean remove(V value) {
-        return target.remove(value);
+        return target.remove(value) != null;
     }
 
     /**
@@ -84,7 +84,9 @@ public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
      * ({@link Cleaner#MANUAL}).
      */
     public enum Cleaner {
-        THREAD, INLINE, MANUAL
+        THREAD,
+        INLINE,
+        MANUAL
     }
 
     /**
diff --git a/src/main/java/org/mockito/internal/util/io/IOUtil.java b/src/main/java/org/mockito/internal/util/io/IOUtil.java
index 42bbfd9..1223cbe 100644
--- a/src/main/java/org/mockito/internal/util/io/IOUtil.java
+++ b/src/main/java/org/mockito/internal/util/io/IOUtil.java
@@ -4,17 +4,24 @@
  */
 package org.mockito.internal.util.io;
 
-import org.mockito.exceptions.base.MockitoException;
-
-import java.io.*;
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
+import org.mockito.exceptions.base.MockitoException;
 
 /**
- * IO utils. A bit of reinventing the wheel but we don't want extra dependencies at this stage and we want to be java.
+ * IO utils. A bit of reinventing the wheel but we don't want extra dependencies at this stage and
+ * we want to be java.
  */
-public class IOUtil {
+public final class IOUtil {
 
     /**
      * Writes text to file
@@ -32,11 +39,11 @@ public class IOUtil {
     }
 
     public static Collection<String> readLines(InputStream is) {
-        List<String> out = new LinkedList<String>();
+        List<String> out = new LinkedList<>();
         BufferedReader r = new BufferedReader(new InputStreamReader(is));
         String line;
         try {
-            while((line = r.readLine()) != null) {
+            while ((line = r.readLine()) != null) {
                 out.add(line);
             }
         } catch (IOException e) {
@@ -54,7 +61,7 @@ public class IOUtil {
         try {
             close(closeable);
         } catch (MockitoException ignored) {
-            //ignore, for backwards compatibility
+            // ignore, for backwards compatibility
         }
     }
 
@@ -72,4 +79,6 @@ public class IOUtil {
             }
         }
     }
+
+    private IOUtil() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java b/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java
index f02acbe..9d1b756 100644
--- a/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java
+++ b/src/main/java/org/mockito/internal/util/reflection/AccessibilityChanger.java
@@ -6,7 +6,7 @@ package org.mockito.internal.util.reflection;
 
 import java.lang.reflect.AccessibleObject;
 
-public class AccessibilityChanger {
+class AccessibilityChanger {
 
     private Boolean wasAccessible = null;
 
diff --git a/src/main/java/org/mockito/internal/util/reflection/BeanPropertySetter.java b/src/main/java/org/mockito/internal/util/reflection/BeanPropertySetter.java
index 9ef9481..d904f62 100644
--- a/src/main/java/org/mockito/internal/util/reflection/BeanPropertySetter.java
+++ b/src/main/java/org/mockito/internal/util/reflection/BeanPropertySetter.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.internal.util.reflection;
 
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.plugins.MemberAccessor;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -26,7 +29,8 @@ public class BeanPropertySetter {
      * @param propertyField The field that should be accessed with the setter
      * @param reportNoSetterFound Allow the set method to raise an Exception if the setter cannot be found
      */
-    public BeanPropertySetter(final Object target, final Field propertyField, boolean reportNoSetterFound) {
+    public BeanPropertySetter(
+            final Object target, final Field propertyField, boolean reportNoSetterFound) {
         this.field = propertyField;
         this.target = target;
         this.reportNoSetterFound = reportNoSetterFound;
@@ -50,24 +54,36 @@ public class BeanPropertySetter {
      */
     public boolean set(final Object value) {
 
-        AccessibilityChanger changer = new AccessibilityChanger();
+        MemberAccessor accessor = Plugins.getMemberAccessor();
         Method writeMethod = null;
         try {
             writeMethod = target.getClass().getMethod(setterName(field.getName()), field.getType());
-
-            changer.enableAccess(writeMethod);
-            writeMethod.invoke(target, value);
+            accessor.invoke(writeMethod, target, value);
             return true;
         } catch (InvocationTargetException e) {
-            throw new RuntimeException("Setter '" + writeMethod + "' of '" + target + "' with value '" + value + "' threw exception : '" + e.getTargetException() + "'", e);
+            throw new RuntimeException(
+                    "Setter '"
+                            + writeMethod
+                            + "' of '"
+                            + target
+                            + "' with value '"
+                            + value
+                            + "' threw exception : '"
+                            + e.getTargetException()
+                            + "'",
+                    e);
         } catch (IllegalAccessException e) {
-            throw new RuntimeException("Access not authorized on field '" + field + "' of object '" + target + "' with value: '" + value + "'", e);
+            throw new RuntimeException(
+                    "Access not authorized on field '"
+                            + field
+                            + "' of object '"
+                            + target
+                            + "' with value: '"
+                            + value
+                            + "'",
+                    e);
         } catch (NoSuchMethodException e) {
             reportNoSetterFound();
-        } finally {
-            if(writeMethod != null) {
-                changer.safelyDisableAccess(writeMethod);
-            }
         }
 
         reportNoSetterFound();
@@ -85,14 +101,18 @@ public class BeanPropertySetter {
     private String setterName(String fieldName) {
         return new StringBuilder(SET_PREFIX)
                 .append(fieldName.substring(0, 1).toUpperCase(Locale.ENGLISH))
-                .append(fieldName.substring(1))
+                .append(fieldName, 1, fieldName.length())
                 .toString();
     }
 
     private void reportNoSetterFound() {
-        if(reportNoSetterFound) {
-            throw new RuntimeException("Problems setting value on object: [" + target + "] for property : [" + field.getName() + "], setter not found");
+        if (reportNoSetterFound) {
+            throw new RuntimeException(
+                    "Problems setting value on object: ["
+                            + target
+                            + "] for property : ["
+                            + field.getName()
+                            + "], setter not found");
         }
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldCopier.java b/src/main/java/org/mockito/internal/util/reflection/FieldCopier.java
deleted file mode 100644
index 67f7203..0000000
--- a/src/main/java/org/mockito/internal/util/reflection/FieldCopier.java
+++ /dev/null
@@ -1,15 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util.reflection;
-
-import java.lang.reflect.Field;
-
-public class FieldCopier {
-
-    public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {
-        Object value = field.get(from);
-        field.set(to, value);
-    }
-}
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldInitializationReport.java b/src/main/java/org/mockito/internal/util/reflection/FieldInitializationReport.java
index 8d04765..13d9c5d 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldInitializationReport.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldInitializationReport.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util.reflection;
 
 /**
@@ -13,7 +12,10 @@ public class FieldInitializationReport {
     private final boolean wasInitialized;
     private final boolean wasInitializedUsingConstructorArgs;
 
-    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized, boolean wasInitializedUsingConstructorArgs) {
+    public FieldInitializationReport(
+            Object fieldInstance,
+            boolean wasInitialized,
+            boolean wasInitializedUsingConstructorArgs) {
         this.fieldInstance = fieldInstance;
         this.wasInitialized = wasInitialized;
         this.wasInitializedUsingConstructorArgs = wasInitializedUsingConstructorArgs;
@@ -55,4 +57,3 @@ public class FieldInitializationReport {
         return fieldInstance != null ? fieldInstance.getClass() : null;
     }
 }
-
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java b/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
index 609b30e..3f104d1 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
@@ -5,10 +5,9 @@
 package org.mockito.internal.util.reflection;
 
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.util.MockUtil;
-
-import static java.lang.reflect.Modifier.isStatic;
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
+import org.mockito.plugins.MemberAccessor;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -19,6 +18,8 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 
+import static java.lang.reflect.Modifier.isStatic;
+
 /**
  * Initialize a field with type instance if a default constructor can be found.
  *
@@ -34,7 +35,6 @@ public class FieldInitializer {
     private final Field field;
     private final ConstructorInstantiator instantiator;
 
-
     /**
      * Prepare initializer with the given field on the given instance.
      *
@@ -60,18 +60,21 @@ public class FieldInitializer {
      * @param field Field to be initialize.
      * @param argResolver Constructor parameters resolver
      */
-    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {
-        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));
+    public FieldInitializer(
+            Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {
+        this(
+                fieldOwner,
+                field,
+                new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));
     }
 
     private FieldInitializer(Object fieldOwner, Field field, ConstructorInstantiator instantiator) {
-        if(new FieldReader(fieldOwner, field).isNull()) {
+        if (new FieldReader(fieldOwner, field).isNull()) {
             checkNotLocal(field);
             checkNotInner(field);
             checkNotInterface(field);
             checkNotEnum(field);
             checkNotAbstract(field);
-
         }
         this.fieldOwner = fieldOwner;
         this.field = field;
@@ -84,53 +87,59 @@ public class FieldInitializer {
      * @return Actual field instance.
      */
     public FieldInitializationReport initialize() {
-        final AccessibilityChanger changer = new AccessibilityChanger();
-        changer.enableAccess(field);
-
         try {
             return acquireFieldInstance();
-        } catch(IllegalAccessException e) {
-            throw new MockitoException("Problems initializing field '" + field.getName() + "' of type '" + field.getType().getSimpleName() + "'", e);
-        } finally {
-            changer.safelyDisableAccess(field);
+        } catch (IllegalAccessException e) {
+            throw new MockitoException(
+                    "Problems initializing field '"
+                            + field.getName()
+                            + "' of type '"
+                            + field.getType().getSimpleName()
+                            + "'",
+                    e);
         }
     }
 
     private void checkNotLocal(Field field) {
-        if(field.getType().isLocalClass()) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is a local class.");
+        if (field.getType().isLocalClass()) {
+            throw new MockitoException(
+                    "the type '" + field.getType().getSimpleName() + "' is a local class.");
         }
     }
 
     private void checkNotInner(Field field) {
         Class<?> type = field.getType();
-        if(type.isMemberClass() && !isStatic(type.getModifiers())) {
-            throw new MockitoException("the type '" + type.getSimpleName() + "' is an inner non static class.");
+        if (type.isMemberClass() && !isStatic(type.getModifiers())) {
+            throw new MockitoException(
+                    "the type '" + type.getSimpleName() + "' is an inner non static class.");
         }
     }
 
     private void checkNotInterface(Field field) {
-        if(field.getType().isInterface()) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an interface.");
+        if (field.getType().isInterface()) {
+            throw new MockitoException(
+                    "the type '" + field.getType().getSimpleName() + "' is an interface.");
         }
     }
 
     private void checkNotAbstract(Field field) {
-        if(Modifier.isAbstract(field.getType().getModifiers())) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an abstract class.");
+        if (Modifier.isAbstract(field.getType().getModifiers())) {
+            throw new MockitoException(
+                    "the type '" + field.getType().getSimpleName() + "' is an abstract class.");
         }
     }
 
     private void checkNotEnum(Field field) {
-        if(field.getType().isEnum()) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an enum.");
+        if (field.getType().isEnum()) {
+            throw new MockitoException(
+                    "the type '" + field.getType().getSimpleName() + "' is an enum.");
         }
     }
 
-
     private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {
-        Object fieldInstance = field.get(fieldOwner);
-        if(fieldInstance != null) {
+        final MemberAccessor accessor = Plugins.getMemberAccessor();
+        Object fieldInstance = accessor.get(field, fieldOwner);
+        if (fieldInstance != null) {
             return new FieldInitializationReport(fieldInstance, false, false);
         }
 
@@ -184,30 +193,36 @@ public class FieldInitializer {
             this.field = field;
         }
 
+        @Override
         public FieldInitializationReport instantiate() {
-            final AccessibilityChanger changer = new AccessibilityChanger();
-            Constructor<?> constructor = null;
+            final MemberAccessor invoker = Plugins.getMemberAccessor();
             try {
-                constructor = field.getType().getDeclaredConstructor();
-                changer.enableAccess(constructor);
+                Constructor<?> constructor = field.getType().getDeclaredConstructor();
 
                 final Object[] noArg = new Object[0];
-                Object newFieldInstance = constructor.newInstance(noArg);
-                setField(testClass, field,newFieldInstance);
+                Object newFieldInstance = invoker.newInstance(constructor, noArg);
+                invoker.set(field, testClass, newFieldInstance);
 
-                return new FieldInitializationReport(field.get(testClass), true, false);
+                return new FieldInitializationReport(invoker.get(field, testClass), true, false);
             } catch (NoSuchMethodException e) {
-                throw new MockitoException("the type '" + field.getType().getSimpleName() + "' has no default constructor", e);
+                throw new MockitoException(
+                        "the type '"
+                                + field.getType().getSimpleName()
+                                + "' has no default constructor",
+                        e);
             } catch (InvocationTargetException e) {
-                throw new MockitoException("the default constructor of type '" + field.getType().getSimpleName() + "' has raised an exception (see the stack trace for cause): " + e.getTargetException().toString(), e);
+                throw new MockitoException(
+                        "the default constructor of type '"
+                                + field.getType().getSimpleName()
+                                + "' has raised an exception (see the stack trace for cause): "
+                                + e.getTargetException(),
+                        e);
             } catch (InstantiationException e) {
-                throw new MockitoException("InstantiationException (see the stack trace for cause): " + e.toString(), e);
+                throw new MockitoException(
+                        "InstantiationException (see the stack trace for cause): " + e, e);
             } catch (IllegalAccessException e) {
-                throw new MockitoException("IllegalAccessException (see the stack trace for cause): " + e.toString(), e);
-            } finally {
-                if(constructor != null) {
-                    changer.safelyDisableAccess(constructor);
-                }
+                throw new MockitoException(
+                        "IllegalAccessException (see the stack trace for cause): " + e, e);
             }
         }
     }
@@ -226,73 +241,90 @@ public class FieldInitializer {
         private final Object testClass;
         private final Field field;
         private final ConstructorArgumentResolver argResolver;
-        private final Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {
-            public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {
-                int argLengths = constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;
-                if (argLengths == 0) {
-                    int constructorAMockableParamsSize = countMockableParams(constructorA);
-                    int constructorBMockableParamsSize = countMockableParams(constructorB);
-                    return constructorBMockableParamsSize - constructorAMockableParamsSize;
-                }
-                return argLengths;
-            }
+        private final Comparator<Constructor<?>> byParameterNumber =
+                new Comparator<Constructor<?>>() {
+                    @Override
+                    public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {
+                        int argLengths =
+                                constructorB.getParameterTypes().length
+                                        - constructorA.getParameterTypes().length;
+                        if (argLengths == 0) {
+                            int constructorAMockableParamsSize = countMockableParams(constructorA);
+                            int constructorBMockableParamsSize = countMockableParams(constructorB);
+                            return constructorBMockableParamsSize - constructorAMockableParamsSize;
+                        }
+                        return argLengths;
+                    }
 
-            private int countMockableParams(Constructor<?> constructor) {
-                int constructorMockableParamsSize = 0;
-                for (Class<?> aClass : constructor.getParameterTypes()) {
-                    if(MockUtil.typeMockabilityOf(aClass).mockable()){
-                        constructorMockableParamsSize++;
+                    private int countMockableParams(Constructor<?> constructor) {
+                        int constructorMockableParamsSize = 0;
+                        for (Class<?> aClass : constructor.getParameterTypes()) {
+                            if (MockUtil.typeMockabilityOf(aClass).mockable()) {
+                                constructorMockableParamsSize++;
+                            }
+                        }
+                        return constructorMockableParamsSize;
                     }
-                }
-                return constructorMockableParamsSize;
-            }
-        };
+                };
 
         /**
          * Internal, checks are done by FieldInitializer.
          * Fields are assumed to be accessible.
          */
-        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver argumentResolver) {
+        ParameterizedConstructorInstantiator(
+                Object testClass, Field field, ConstructorArgumentResolver argumentResolver) {
             this.testClass = testClass;
             this.field = field;
             this.argResolver = argumentResolver;
         }
 
+        @Override
         public FieldInitializationReport instantiate() {
-            final AccessibilityChanger changer = new AccessibilityChanger();
-            Constructor<?> constructor = null;
+            final MemberAccessor accessor = Plugins.getMemberAccessor();
+            Constructor<?> constructor = biggestConstructor(field.getType());
+            final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());
             try {
-                constructor = biggestConstructor(field.getType());
-                changer.enableAccess(constructor);
-
-                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());
-                Object newFieldInstance = constructor.newInstance(args);
-                setField(testClass, field,newFieldInstance);
+                Object newFieldInstance = accessor.newInstance(constructor, args);
+                accessor.set(field, testClass, newFieldInstance);
 
-                return new FieldInitializationReport(field.get(testClass), false, true);
+                return new FieldInitializationReport(accessor.get(field, testClass), false, true);
             } catch (IllegalArgumentException e) {
-                throw new MockitoException("internal error : argResolver provided incorrect types for constructor " + constructor + " of type " + field.getType().getSimpleName(), e);
+                throw new MockitoException(
+                        "internal error : argResolver provided incorrect types for constructor "
+                                + constructor
+                                + " of type "
+                                + field.getType().getSimpleName(),
+                        e);
             } catch (InvocationTargetException e) {
-                throw new MockitoException("the constructor of type '" + field.getType().getSimpleName() + "' has raised an exception (see the stack trace for cause): " + e.getTargetException().toString(), e);
+                throw new MockitoException(
+                        "the constructor of type '"
+                                + field.getType().getSimpleName()
+                                + "' has raised an exception (see the stack trace for cause): "
+                                + e.getTargetException(),
+                        e);
             } catch (InstantiationException e) {
-                throw new MockitoException("InstantiationException (see the stack trace for cause): " + e.toString(), e);
+                throw new MockitoException(
+                        "InstantiationException (see the stack trace for cause): " + e, e);
             } catch (IllegalAccessException e) {
-                throw new MockitoException("IllegalAccessException (see the stack trace for cause): " + e.toString(), e);
-            } finally {
-                if(constructor != null) {
-                    changer.safelyDisableAccess(constructor);
-                }
+                throw new MockitoException(
+                        "IllegalAccessException (see the stack trace for cause): " + e, e);
             }
         }
 
         private void checkParameterized(Constructor<?> constructor, Field field) {
-            if(constructor.getParameterTypes().length == 0) {
-                throw new MockitoException("the field " + field.getName() + " of type " + field.getType() + " has no parameterized constructor");
+            if (constructor.getParameterTypes().length == 0) {
+                throw new MockitoException(
+                        "the field "
+                                + field.getName()
+                                + " of type "
+                                + field.getType()
+                                + " has no parameterized constructor");
             }
         }
 
         private Constructor<?> biggestConstructor(Class<?> clazz) {
-            final List<? extends Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());
+            final List<? extends Constructor<?>> constructors =
+                    Arrays.asList(clazz.getDeclaredConstructors());
             Collections.sort(constructors, byParameterNumber);
 
             Constructor<?> constructor = constructors.get(0);
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldReader.java b/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
index 1cae117..6c3c120 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
@@ -4,31 +4,33 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.mockito.exceptions.base.MockitoException;
-
 import java.lang.reflect.Field;
 
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.plugins.MemberAccessor;
+
 public class FieldReader {
 
     final Object target;
     final Field field;
-    final AccessibilityChanger changer = new AccessibilityChanger();
+    final MemberAccessor accessor = Plugins.getMemberAccessor();
 
     public FieldReader(Object target, Field field) {
         this.target = target;
         this.field = field;
-        changer.enableAccess(field);
     }
 
     public boolean isNull() {
-            return read() == null;
+        return read() == null;
     }
 
     public Object read() {
         try {
-            return field.get(target);
+            return accessor.get(field, target);
         } catch (Exception e) {
-            throw new MockitoException("Cannot read state from field: " + field + ", on instance: " + target);
+            throw new MockitoException(
+                    "Cannot read state from field: " + field + ", on instance: " + target, e);
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java b/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java
index 69b5b16..35b1210 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldSetter.java
@@ -6,10 +6,14 @@ package org.mockito.internal.util.reflection;
 
 import java.lang.reflect.Field;
 
+/** Do not use. To be removed after last usage is gone. */
+@Deprecated
 public class FieldSetter {
 
     private FieldSetter(){}
 
+    /** Do not use. To be removed after last usage is gone. */
+    @Deprecated
     public static void setField(Object target, Field field,Object value) {
         AccessibilityChanger changer = new AccessibilityChanger();
         changer.enableAccess(field);
diff --git a/src/main/java/org/mockito/internal/util/reflection/Fields.java b/src/main/java/org/mockito/internal/util/reflection/Fields.java
index 1d1befe..f749649 100644
--- a/src/main/java/org/mockito/internal/util/reflection/Fields.java
+++ b/src/main/java/org/mockito/internal/util/reflection/Fields.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.mockito.internal.util.Checks;
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.mockito.internal.util.Checks;
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
+
 /**
  * Small fluent reflection tools to work with fields.
  *
@@ -27,8 +27,10 @@ public abstract class Fields {
      * @return InstanceFields of this object instance.
      */
     public static InstanceFields allDeclaredFieldsOf(Object instance) {
-        List<InstanceField> instanceFields = new ArrayList<InstanceField>();
-        for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {
+        List<InstanceField> instanceFields = new ArrayList<>();
+        for (Class<?> clazz = instance.getClass();
+                clazz != Object.class;
+                clazz = clazz.getSuperclass()) {
             instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));
         }
         return new InstanceFields(instance, instanceFields);
@@ -41,13 +43,13 @@ public abstract class Fields {
      * @return InstanceFields of this object instance.
      */
     public static InstanceFields declaredFieldsOf(Object instance) {
-        List<InstanceField> instanceFields = new ArrayList<InstanceField>();
+        List<InstanceField> instanceFields = new ArrayList<>();
         instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));
         return new InstanceFields(instance, instanceFields);
     }
 
     private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {
-        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();
+        List<InstanceField> instanceDeclaredFields = new ArrayList<>();
         for (Field field : fields) {
             InstanceField instanceField = new InstanceField(field, instance);
             instanceDeclaredFields.add(instanceField);
@@ -62,13 +64,15 @@ public abstract class Fields {
      * @return The filter.
      */
     @SuppressWarnings({"unchecked", "vararg"})
-    public static Filter<InstanceField> annotatedBy(final Class<? extends Annotation>... annotations) {
+    public static Filter<InstanceField> annotatedBy(
+            final Class<? extends Annotation>... annotations) {
         return new Filter<InstanceField>() {
+            @Override
             public boolean isOut(InstanceField instanceField) {
                 Checks.checkNotNull(annotations, "Provide at least one annotation class");
 
                 for (Class<? extends Annotation> annotation : annotations) {
-                    if(instanceField.isAnnotatedBy(annotation)) {
+                    if (instanceField.isAnnotatedBy(annotation)) {
                         return false;
                     }
                 }
@@ -84,6 +88,7 @@ public abstract class Fields {
      */
     private static Filter<InstanceField> nullField() {
         return new Filter<InstanceField>() {
+            @Override
             public boolean isOut(InstanceField instanceField) {
                 return instanceField.isNull();
             }
@@ -97,6 +102,7 @@ public abstract class Fields {
      */
     public static Filter<InstanceField> syntheticField() {
         return new Filter<InstanceField>() {
+            @Override
             public boolean isOut(InstanceField instanceField) {
                 return instanceField.isSynthetic();
             }
@@ -122,11 +128,11 @@ public abstract class Fields {
         }
 
         public List<InstanceField> instanceFields() {
-            return new ArrayList<InstanceField>(instanceFields);
+            return new ArrayList<>(instanceFields);
         }
 
         public List<Object> assignedValues() {
-            List<Object> values = new ArrayList<Object>(instanceFields.size());
+            List<Object> values = new ArrayList<>(instanceFields.size());
             for (InstanceField instanceField : instanceFields) {
                 values.add(instanceField.read());
             }
@@ -134,7 +140,7 @@ public abstract class Fields {
         }
 
         public List<String> names() {
-            List<String> fieldNames = new ArrayList<String>(instanceFields.size());
+            List<String> fieldNames = new ArrayList<>(instanceFields.size());
             for (InstanceField instanceField : instanceFields) {
                 fieldNames.add(instanceField.name());
             }
diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMaster.java b/src/main/java/org/mockito/internal/util/reflection/GenericMaster.java
index a477ba4..be3db7f 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericMaster.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericMaster.java
@@ -22,12 +22,11 @@ public class GenericMaster {
             if (actual instanceof Class) {
                 return (Class<?>) actual;
             } else if (actual instanceof ParameterizedType) {
-                //in case of nested generics we don't go deep
+                // in case of nested generics we don't go deep
                 return (Class<?>) ((ParameterizedType) actual).getRawType();
             }
         }
 
         return Object.class;
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
index 8efd384..c7edd9c 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
@@ -4,33 +4,45 @@
  */
 package org.mockito.internal.util.reflection;
 
-
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.Checks;
 
-import java.lang.reflect.*;
-import java.util.*;
-
-
 /**
  * This class can retrieve generic meta-data that the compiler stores on classes
  * and accessible members.
  *
  * <p>
- *     The main idea of this code is to create a Map that will help to resolve return types.
- *     In order to actually work with nested generics, this map will have to be passed along new instances
- *     as a type context.
+ * The main idea of this code is to create a Map that will help to resolve return types.
+ * In order to actually work with nested generics, this map will have to be passed along new instances
+ * as a type context.
  * </p>
  *
  * <p>
- *     Hence :
- *     <ul>
- *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real
- *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>
+ * Hence :
+ * <ul>
+ * <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real
+ * <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>
  *
- *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using
- *         {@link #resolveGenericReturnType(Method)}.</li>
- *     </ul>
+ * <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using
+ * {@link #resolveGenericReturnType(Method)}.</li>
+ * </ul>
  * </p>
  *
  * <p>
@@ -57,10 +69,8 @@ public abstract class GenericMetadataSupport {
 
     // public static MockitoLogger logger = new ConsoleMockitoLogger();
 
-    /**
-     * Represents actual type variables resolved for current class.
-     */
-    protected Map<TypeVariable<?>, Type> contextualActualTypeParameters = new HashMap<TypeVariable<?>, Type>();
+    /** Represents actual type variables resolved for current class. */
+    protected Map<TypeVariable<?>, Type> contextualActualTypeParameters = new HashMap<>();
 
     /**
      * Registers the type variables for the given type and all of its superclasses and superinterfaces.
@@ -81,7 +91,7 @@ public abstract class GenericMetadataSupport {
 
             Class<?> rawType = extractRawTypeOf(typeToRegister);
             typesToRegister.add(rawType.getGenericSuperclass());
-            typesToRegister.addAll(Arrays.asList(rawType.getGenericInterfaces()));
+            Collections.addAll(typesToRegister, rawType.getGenericInterfaces());
         }
     }
 
@@ -97,8 +107,9 @@ public abstract class GenericMetadataSupport {
         }
         if (type instanceof TypeVariable) {
             /*
-             * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
-             * on the class definition, such as such as List<E>.
+             * If type is a TypeVariable, then it is needed to gather data elsewhere.
+             * Usually TypeVariables are declared on the class definition, such as such
+             * as List<E>.
              */
             return extractRawTypeOf(contextualActualTypeParameters.get(type));
         }
@@ -110,18 +121,41 @@ public abstract class GenericMetadataSupport {
             return;
         }
         ParameterizedType parameterizedType = (ParameterizedType) classType;
-        TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
+        TypeVariable<?>[] typeParameters =
+                ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
         Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
         for (int i = 0; i < actualTypeArguments.length; i++) {
             TypeVariable<?> typeParameter = typeParameters[i];
             Type actualTypeArgument = actualTypeArguments[i];
 
+            if (actualTypeArgument instanceof TypeVariable) {
+                /*
+                 * If actualTypeArgument is a TypeVariable, and it is not present in
+                 * the context map then it is needed to try harder to gather more data
+                 * from the type argument itself. In some case the type argument do
+                 * define upper bounds, this allow to look for them if not in the
+                 * context map.
+                 */
+                registerTypeVariableIfNotPresent((TypeVariable<?>) actualTypeArgument);
+
+                // Prevent registration of a cycle of TypeVariables. This can happen when we are
+                // processing
+                // type parameters in a Method, while we already processed the type parameters of a
+                // class.
+                if (contextualActualTypeParameters.containsKey(typeParameter)) {
+                    continue;
+                }
+            }
+
             if (actualTypeArgument instanceof WildcardType) {
-                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
+                contextualActualTypeParameters.put(
+                        typeParameter, boundsOf((WildcardType) actualTypeArgument));
             } else if (typeParameter != actualTypeArgument) {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
-            // logger.log("For '" + parameterizedType + "' found type variable : { '" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "' : '" + actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "' }");
+            // logger.log("For '" + parameterizedType + "' found type variable : { '" +
+            // typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "' : '" +
+            // actualTypeArgument + "(" + System.identityHashCode(typeParameter) + ")" + "' }");
         }
     }
 
@@ -134,14 +168,16 @@ public abstract class GenericMetadataSupport {
     private void registerTypeVariableIfNotPresent(TypeVariable<?> typeVariable) {
         if (!contextualActualTypeParameters.containsKey(typeVariable)) {
             contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));
-            // logger.log("For '" + typeVariable.getGenericDeclaration() + "' found type variable : { '" + typeVariable + "(" + System.identityHashCode(typeVariable) + ")" + "' : '" + boundsOf(typeVariable) + "' }");
+            // logger.log("For '" + typeVariable.getGenericDeclaration() + "' found type variable :
+            // { '" + typeVariable + "(" + System.identityHashCode(typeVariable) + ")" + "' : '" +
+            // boundsOf(typeVariable) + "' }");
         }
     }
 
     /**
      * @param typeParameter The TypeVariable parameter
      * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable
-     *         then retrieve BoundedType of this TypeVariable
+     * then retrieve BoundedType of this TypeVariable
      */
     private BoundedType boundsOf(TypeVariable<?> typeParameter) {
         if (typeParameter.getBounds()[0] instanceof TypeVariable) {
@@ -153,13 +189,17 @@ public abstract class GenericMetadataSupport {
     /**
      * @param wildCard The WildCard type
      * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable
-     *         then retrieve BoundedType of this TypeVariable
+     * then retrieve BoundedType of this TypeVariable
      */
     private BoundedType boundsOf(WildcardType wildCard) {
         /*
-         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):
-         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)
-         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)
+         *  According to JLS(https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1):
+         *  - Lower and upper can't coexist: (for instance, this is not allowed:
+         *    <? extends List<String> & super MyInterface>)
+         *  - Multiple concrete type bounds are not supported (for instance, this is not allowed:
+         *    <? extends ArrayList<String> & MyInterface>)
+         *    But the following form is possible where there is a single concrete tyep bound followed by interface type bounds
+         *    <T extends List<String> & Comparable>
          */
 
         WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);
@@ -201,14 +241,16 @@ public abstract class GenericMetadataSupport {
      */
     public Map<TypeVariable<?>, Type> actualTypeArguments() {
         TypeVariable<?>[] typeParameters = rawType().getTypeParameters();
-        LinkedHashMap<TypeVariable<?>, Type> actualTypeArguments = new LinkedHashMap<TypeVariable<?>, Type>();
+        LinkedHashMap<TypeVariable<?>, Type> actualTypeArguments = new LinkedHashMap<>();
 
         for (TypeVariable<?> typeParameter : typeParameters) {
 
             Type actualType = getActualTypeArgumentFor(typeParameter);
 
             actualTypeArguments.put(typeParameter, actualType);
-            // logger.log("For '" + rawType().getCanonicalName() + "' returning explicit TypeVariable : { '" + typeParameter + "(" + System.identityHashCode(typeParameter) + ")" + "' : '" + actualType +"' }");
+            // logger.log("For '" + rawType().getCanonicalName() + "' returning explicit
+            // TypeVariable : { '" + typeParameter + "(" + System.identityHashCode(typeParameter) +
+            // ")" + "' : '" + actualType +"' }");
         }
 
         return actualTypeArguments;
@@ -232,15 +274,18 @@ public abstract class GenericMetadataSupport {
      */
     public GenericMetadataSupport resolveGenericReturnType(Method method) {
         Type genericReturnType = method.getGenericReturnType();
-        // logger.log("Method '" + method.toGenericString() + "' has return type : " + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + " : " + genericReturnType);
+        // logger.log("Method '" + method.toGenericString() + "' has return type : " +
+        // genericReturnType.getClass().getInterfaces()[0].getSimpleName() + " : " +
+        // genericReturnType);
 
         int arity = 0;
-        while(genericReturnType instanceof GenericArrayType) {
+        while (genericReturnType instanceof GenericArrayType) {
             arity++;
             genericReturnType = ((GenericArrayType) genericReturnType).getGenericComponentType();
         }
 
-        GenericMetadataSupport genericMetadataSupport = resolveGenericType(genericReturnType, method);
+        GenericMetadataSupport genericMetadataSupport =
+                resolveGenericType(genericReturnType, method);
         if (arity == 0) {
             return genericMetadataSupport;
         } else {
@@ -254,21 +299,29 @@ public abstract class GenericMetadataSupport {
             return new NotGenericReturnTypeSupport(this, type);
         }
         if (type instanceof ParameterizedType) {
-            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) type);
+            return new ParameterizedReturnType(
+                    this, method.getTypeParameters(), (ParameterizedType) type);
         }
         if (type instanceof TypeVariable) {
-            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable<?>) type);
+            return new TypeVariableReturnType(
+                    this, method.getTypeParameters(), (TypeVariable<?>) type);
         }
 
-        throw new MockitoException("Ouch, it shouldn't happen, type '" + type.getClass().getCanonicalName() + "' on method : '" + method.toGenericString() + "' is not supported : " + type);
+        throw new MockitoException(
+                "Ouch, it shouldn't happen, type '"
+                        + type.getClass().getCanonicalName()
+                        + "' on method : '"
+                        + method.toGenericString()
+                        + "' is not supported : "
+                        + type);
     }
 
     /**
      * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.
      *
      * <p>
-     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise
-     *     it'll throw a {@link MockitoException}.
+     * At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise
+     * it'll throw a {@link MockitoException}.
      * </p>
      *
      * @param type The class from which the {@link GenericMetadataSupport} should be built.
@@ -284,17 +337,21 @@ public abstract class GenericMetadataSupport {
             return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);
         }
 
-        throw new MockitoException("Type meta-data for this Type (" + type.getClass().getCanonicalName() + ") is not supported : " + type);
+        throw new MockitoException(
+                "Type meta-data for this Type ("
+                        + type.getClass().getCanonicalName()
+                        + ") is not supported : "
+                        + type);
     }
 
-
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types
+    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible
+    // Types
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
     /**
      * Generic metadata implementation for {@link Class}.
-     *
+     * <p>
      * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on
      * the class and its ancestors and interfaces.
      */
@@ -316,16 +373,17 @@ public abstract class GenericMetadataSupport {
 
     /**
      * Generic metadata implementation for "standalone" {@link ParameterizedType}.
-     *
+     * <p>
      * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of
      * the related raw type and declared type variable of this parameterized type.
-     *
+     * <p>
      * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as
      * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).
      * That's what meant the "standalone" word at the beginning of the Javadoc.
      * Instead use {@link ParameterizedReturnType}.
      */
-    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {
+    private static class FromParameterizedTypeGenericMetadataSupport
+            extends GenericMetadataSupport {
         private final ParameterizedType parameterizedType;
 
         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {
@@ -350,7 +408,10 @@ public abstract class GenericMetadataSupport {
         private final ParameterizedType parameterizedType;
         private final TypeVariable<?>[] typeParameters;
 
-        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable<?>[] typeParameters, ParameterizedType parameterizedType) {
+        public ParameterizedReturnType(
+                GenericMetadataSupport source,
+                TypeVariable<?>[] typeParameters,
+                ParameterizedType parameterizedType) {
             this.parameterizedType = parameterizedType;
             this.typeParameters = typeParameters;
             this.contextualActualTypeParameters = source.contextualActualTypeParameters;
@@ -371,7 +432,6 @@ public abstract class GenericMetadataSupport {
         public Class<?> rawType() {
             return (Class<?>) parameterizedType.getRawType();
         }
-
     }
 
     /**
@@ -381,8 +441,12 @@ public abstract class GenericMetadataSupport {
         private final TypeVariable<?> typeVariable;
         private final TypeVariable<?>[] typeParameters;
         private Class<?> rawType;
+        private List<Type> extraInterfaces;
 
-        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable<?>[] typeParameters, TypeVariable<?> typeVariable) {
+        public TypeVariableReturnType(
+                GenericMetadataSupport source,
+                TypeVariable<?>[] typeParameters,
+                TypeVariable<?> typeVariable) {
             this.typeParameters = typeParameters;
             this.typeVariable = typeVariable;
             this.contextualActualTypeParameters = source.contextualActualTypeParameters;
@@ -399,7 +463,7 @@ public abstract class GenericMetadataSupport {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
-            registerTypeParametersOn(new TypeVariable[] { typeVariable });
+            registerTypeParametersOn(new TypeVariable[] {typeVariable});
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
@@ -413,30 +477,36 @@ public abstract class GenericMetadataSupport {
 
         @Override
         public List<Type> extraInterfaces() {
+            if (extraInterfaces != null) {
+                return extraInterfaces;
+            }
             Type type = extractActualBoundedTypeOf(typeVariable);
             if (type instanceof BoundedType) {
-                return Arrays.asList(((BoundedType) type).interfaceBounds());
+                return extraInterfaces = Arrays.asList(((BoundedType) type).interfaceBounds());
             }
             if (type instanceof ParameterizedType) {
-                return Collections.singletonList(type);
+                return extraInterfaces = Collections.singletonList(type);
             }
             if (type instanceof Class) {
-                return Collections.emptyList();
+                return extraInterfaces = Collections.emptyList();
             }
-            throw new MockitoException("Cannot extract extra-interfaces from '" + typeVariable + "' : '" + type + "'");
+            throw new MockitoException(
+                    "Cannot extract extra-interfaces from '" + typeVariable + "' : '" + type + "'");
         }
 
         /**
          * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.
          * @see #extractRawTypeOf(java.lang.reflect.Type)
          */
+        @Override
         public Class<?>[] rawExtraInterfaces() {
             List<Type> extraInterfaces = extraInterfaces();
-            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();
+            List<Class<?>> rawExtraInterfaces = new ArrayList<>();
             for (Type extraInterface : extraInterfaces) {
                 Class<?> rawInterface = extractRawTypeOf(extraInterface);
-                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)
-                if(!rawType().equals(rawInterface)) {
+                // avoid interface collision with actual raw type (with typevariables, resolution ca
+                // be quite aggressive)
+                if (!rawType().equals(rawInterface)) {
                     rawExtraInterfaces.add(rawInterface);
                 }
             }
@@ -452,9 +522,11 @@ public abstract class GenericMetadataSupport {
                 return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));
             }
             if (type instanceof BoundedType) {
-                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());
+                Type actualFirstBound =
+                        extractActualBoundedTypeOf(((BoundedType) type).firstBound());
                 if (!(actualFirstBound instanceof BoundedType)) {
-                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType
+                    return type; // avoid going one step further, ie avoid : O(TypeVar) ->
+                    // K(TypeVar) -> Some ParamType
                 }
                 return actualFirstBound;
             }
@@ -481,9 +553,16 @@ public abstract class GenericMetadataSupport {
                 stringBuilder.append("[");
             }
             try {
-                return Class.forName(stringBuilder.append("L").append(rawComponentType.getName()).append(";").toString(), false, rawComponentType.getClassLoader());
+                return Class.forName(
+                        stringBuilder
+                                .append("L")
+                                .append(rawComponentType.getName())
+                                .append(";")
+                                .toString(),
+                        false,
+                        rawComponentType.getClassLoader());
             } catch (ClassNotFoundException e) {
-                throw new IllegalStateException("This was not supposed to happend", e);
+                throw new IllegalStateException("This was not supposed to happen.", e);
             }
         }
     }
@@ -507,15 +586,13 @@ public abstract class GenericMetadataSupport {
         }
     }
 
-
-
     /**
      * Type representing bounds of a type
      *
      * @see TypeVarBoundedType
-     * @see <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>
+     * @see <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4</a>
      * @see WildCardBoundedType
-     * @see <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>
+     * @see <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1</a>
      */
     public interface BoundedType extends Type {
         Type firstBound();
@@ -531,7 +608,7 @@ public abstract class GenericMetadataSupport {
      *
      * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and
      * interfacesBound will be an array of the additional interfaces.
-     *
+     * <p>
      * i.e. <code>SomeClass</code>.
      * <pre class="code"><code class="java">
      *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {
@@ -541,7 +618,7 @@ public abstract class GenericMetadataSupport {
      * </code></pre>
      * </p>
      *
-     * @see <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>
+     * @see <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4</a>
      */
     public static class TypeVarBoundedType implements BoundedType {
         private final TypeVariable<?> typeVariable;
@@ -553,6 +630,7 @@ public abstract class GenericMetadataSupport {
         /**
          * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.
          */
+        @Override
         public Type firstBound() {
             return typeVariable.getBounds()[0]; //
         }
@@ -564,19 +642,28 @@ public abstract class GenericMetadataSupport {
          * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,
          * empty array if no other bound declared.
          */
+        @Override
         public Type[] interfaceBounds() {
             Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];
-            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);
+            System.arraycopy(
+                    typeVariable.getBounds(),
+                    1,
+                    interfaceBounds,
+                    0,
+                    typeVariable.getBounds().length - 1);
             return interfaceBounds;
         }
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
 
             return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);
-
         }
 
         @Override
@@ -586,7 +673,11 @@ public abstract class GenericMetadataSupport {
 
         @Override
         public String toString() {
-            return "{firstBound=" + firstBound() + ", interfaceBounds=" + Arrays.deepToString(interfaceBounds()) + '}';
+            return "{firstBound="
+                    + firstBound()
+                    + ", interfaceBounds="
+                    + Arrays.deepToString(interfaceBounds())
+                    + '}';
         }
 
         public TypeVariable<?> typeVariable() {
@@ -600,19 +691,17 @@ public abstract class GenericMetadataSupport {
      * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds
      * are not allowed.
      *
-     * @see <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>
+     * @see <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4</a>
      */
     public static class WildCardBoundedType implements BoundedType {
         private final WildcardType wildcard;
 
-
         public WildCardBoundedType(WildcardType wildcard) {
             this.wildcard = wildcard;
         }
 
-        /**
-         * @return The first bound, either a type or a reference to a TypeVariable
-         */
+        /** @return The first bound, either a type or a reference to a TypeVariable */
+        @Override
         public Type firstBound() {
             Type[] lowerBounds = wildcard.getLowerBounds();
             Type[] upperBounds = wildcard.getUpperBounds();
@@ -620,20 +709,22 @@ public abstract class GenericMetadataSupport {
             return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];
         }
 
-        /**
-         * @return An empty array as, wildcard don't support multiple bounds.
-         */
+        /** @return An empty array as, wildcard don't support multiple bounds. */
+        @Override
         public Type[] interfaceBounds() {
             return new Type[0];
         }
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
 
             return wildcard.equals(((TypeVarBoundedType) o).typeVariable);
-
         }
 
         @Override
@@ -650,7 +741,4 @@ public abstract class GenericMetadataSupport {
             return wildcard;
         }
     }
-
 }
-
-
diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java b/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java
index 6d3bd70..fb56a37 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericTypeExtractor.java
@@ -7,10 +7,8 @@ package org.mockito.internal.util.reflection;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 
-/**
- * Attempts to extract generic type of given target base class or target interface
- */
-public class GenericTypeExtractor {
+/** Attempts to extract generic type of given target base class or target interface */
+public final class GenericTypeExtractor {
 
     /**
      * Extract generic type of root class either from the target base class or from target base interface.
@@ -34,20 +32,21 @@ public class GenericTypeExtractor {
      *                            it will be used for generic type extraction
      * @return generic interface if found, Object.class if not found.
      */
-    public static Class<?> genericTypeOf(Class<?> rootClass, Class<?> targetBaseClass, Class<?> targetBaseInterface) {
-        //looking for candidates in the hierarchy of rootClass
+    public static Class<?> genericTypeOf(
+            Class<?> rootClass, Class<?> targetBaseClass, Class<?> targetBaseInterface) {
+        // looking for candidates in the hierarchy of rootClass
         Class<?> match = rootClass;
-        while(match != Object.class) {
-            //check the super class first
+        while (match != Object.class) {
+            // check the super class first
             if (match.getSuperclass() == targetBaseClass) {
                 return extractGeneric(match.getGenericSuperclass());
             }
-            //check the interfaces (recursively)
+            // check the interfaces (recursively)
             Type genericInterface = findGenericInterface(match, targetBaseInterface);
             if (genericInterface != null) {
                 return extractGeneric(genericInterface);
             }
-            //recurse the hierarchy
+            // recurse the hierarchy
             match = match.getSuperclass();
         }
         return Object.class;
@@ -61,7 +60,7 @@ public class GenericTypeExtractor {
         for (int i = 0; i < sourceClass.getInterfaces().length; i++) {
             Class<?> inter = sourceClass.getInterfaces()[i];
             if (inter == targetBaseInterface) {
-                return sourceClass.getGenericInterfaces()[0];
+                return sourceClass.getGenericInterfaces()[i];
             } else {
                 Type deeper = findGenericInterface(inter, targetBaseInterface);
                 if (deeper != null) {
@@ -85,4 +84,6 @@ public class GenericTypeExtractor {
         }
         return Object.class;
     }
+
+    private GenericTypeExtractor() {}
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/InstanceField.java b/src/main/java/org/mockito/internal/util/reflection/InstanceField.java
index 8756e6a..ffefaec 100644
--- a/src/main/java/org/mockito/internal/util/reflection/InstanceField.java
+++ b/src/main/java/org/mockito/internal/util/reflection/InstanceField.java
@@ -4,17 +4,18 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.mockito.internal.util.Checks;
-
-import static org.mockito.internal.util.reflection.FieldSetter.setField;
-
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.util.Checks;
+import org.mockito.plugins.MemberAccessor;
+
 /**
  * Represents an accessible instance field.
  *
- * Contains the instance reference on which the field can be read adn write.
+ * Contains the instance reference on which the field can be read and write.
  */
 public class InstanceField {
     private final Field field;
@@ -47,10 +48,14 @@ public class InstanceField {
      * Set the given value to the field of this instance.
      *
      * @param value The value that should be written to the field.
-     * @see FieldSetter
      */
     public void set(Object value) {
-        setField(instance, field,value);
+        MemberAccessor accessor = Plugins.getMemberAccessor();
+        try {
+            accessor.set(field, instance, value);
+        } catch (IllegalAccessException e) {
+            throw new MockitoException("Access to " + field + " was denied", e);
+        }
     }
 
     /**
@@ -124,8 +129,12 @@ public class InstanceField {
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
 
         InstanceField that = (InstanceField) o;
         return field.equals(that.field) && instance.equals(that.instance);
diff --git a/src/main/java/org/mockito/internal/util/reflection/InstrumentationMemberAccessor.java b/src/main/java/org/mockito/internal/util/reflection/InstrumentationMemberAccessor.java
new file mode 100644
index 0000000..0a972d8
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/reflection/InstrumentationMemberAccessor.java
@@ -0,0 +1,422 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.reflection;
+
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.agent.ByteBuddyAgent;
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
+import net.bytebuddy.implementation.MethodCall;
+import org.mockito.exceptions.base.MockitoInitializationException;
+import org.mockito.internal.SuppressSignatureCheck;
+import org.mockito.plugins.MemberAccessor;
+
+import java.lang.instrument.Instrumentation;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static net.bytebuddy.matcher.ElementMatchers.named;
+import static org.mockito.internal.util.StringUtil.join;
+
+@SuppressSignatureCheck
+class InstrumentationMemberAccessor implements MemberAccessor {
+
+    private static final Map<Class<?>, Class<?>> WRAPPERS = new HashMap<>();
+
+    private static final Instrumentation INSTRUMENTATION;
+    private static final Dispatcher DISPATCHER;
+
+    private static final Throwable INITIALIZATION_ERROR;
+
+    static {
+        WRAPPERS.put(boolean.class, Boolean.class);
+        WRAPPERS.put(byte.class, Byte.class);
+        WRAPPERS.put(short.class, Short.class);
+        WRAPPERS.put(char.class, Character.class);
+        WRAPPERS.put(int.class, Integer.class);
+        WRAPPERS.put(long.class, Long.class);
+        WRAPPERS.put(float.class, Float.class);
+        WRAPPERS.put(double.class, Double.class);
+        Instrumentation instrumentation;
+        Dispatcher dispatcher;
+        Throwable throwable;
+        try {
+            instrumentation = ByteBuddyAgent.install();
+            // We need to generate a dispatcher instance that is located in a distinguished class
+            // loader to create a unique (unnamed) module to which we can open other packages to.
+            // This way, we assure that classes within Mockito's module (which might be a shared,
+            // unnamed module) do not face escalated privileges where tests might pass that would
+            // otherwise fail without Mockito's opening.
+            dispatcher =
+                    new ByteBuddy()
+                            .subclass(Dispatcher.class)
+                            .method(named("getLookup"))
+                            .intercept(MethodCall.invoke(MethodHandles.class.getMethod("lookup")))
+                            .method(named("getModule"))
+                            .intercept(
+                                    MethodCall.invoke(Class.class.getMethod("getModule"))
+                                            .onMethodCall(
+                                                    MethodCall.invoke(
+                                                            Object.class.getMethod("getClass"))))
+                            .method(named("setAccessible"))
+                            .intercept(
+                                    MethodCall.invoke(
+                                                    AccessibleObject.class.getMethod(
+                                                            "setAccessible", boolean.class))
+                                            .onArgument(0)
+                                            .withArgument(1))
+                            .method(named("invokeWithArguments"))
+                            .intercept(
+                                    MethodCall.invoke(
+                                                    MethodHandle.class.getMethod(
+                                                            "invokeWithArguments", Object[].class))
+                                            .onArgument(0)
+                                            .withArgument(1))
+                            .make()
+                            .load(
+                                    InstrumentationMemberAccessor.class.getClassLoader(),
+                                    ClassLoadingStrategy.Default.WRAPPER)
+                            .getLoaded()
+                            .getConstructor()
+                            .newInstance();
+            throwable = null;
+        } catch (Throwable t) {
+            instrumentation = null;
+            dispatcher = null;
+            throwable = t;
+        }
+        INSTRUMENTATION = instrumentation;
+        DISPATCHER = dispatcher;
+        INITIALIZATION_ERROR = throwable;
+    }
+
+    @SuppressWarnings(value = "unused")
+    private final MethodHandle getModule;
+
+    @SuppressWarnings(value = "unused")
+    private final MethodHandle isOpen;
+
+    @SuppressWarnings(value = "unused")
+    private final MethodHandle redefineModule;
+
+    @SuppressWarnings(value = "unused")
+    private final MethodHandle privateLookupIn;
+
+    InstrumentationMemberAccessor() {
+        if (INITIALIZATION_ERROR != null) {
+            throw new MockitoInitializationException(
+                    join(
+                            "Could not initialize the Mockito instrumentation member accessor",
+                            "",
+                            "This is unexpected on JVMs from Java 9 or later - possibly, the instrumentation API could not be resolved"),
+                    INITIALIZATION_ERROR);
+        }
+        try {
+            Class<?> module = Class.forName("java.lang.Module");
+            getModule =
+                    MethodHandles.publicLookup()
+                            .findVirtual(Class.class, "getModule", MethodType.methodType(module));
+            isOpen =
+                    MethodHandles.publicLookup()
+                            .findVirtual(
+                                    module,
+                                    "isOpen",
+                                    MethodType.methodType(boolean.class, String.class));
+            redefineModule =
+                    MethodHandles.publicLookup()
+                            .findVirtual(
+                                    Instrumentation.class,
+                                    "redefineModule",
+                                    MethodType.methodType(
+                                            void.class,
+                                            module,
+                                            Set.class,
+                                            Map.class,
+                                            Map.class,
+                                            Set.class,
+                                            Map.class));
+            privateLookupIn =
+                    MethodHandles.publicLookup()
+                            .findStatic(
+                                    MethodHandles.class,
+                                    "privateLookupIn",
+                                    MethodType.methodType(
+                                            MethodHandles.Lookup.class,
+                                            Class.class,
+                                            MethodHandles.Lookup.class));
+        } catch (Throwable t) {
+            throw new MockitoInitializationException(
+                    "Could not resolve instrumentation invoker", t);
+        }
+    }
+
+    @Override
+    public Object newInstance(Constructor<?> constructor, Object... arguments)
+            throws InstantiationException, InvocationTargetException {
+        return newInstance(constructor, ConstructionDispatcher::newInstance, arguments);
+    }
+
+    @Override
+    public Object newInstance(
+            Constructor<?> constructor, OnConstruction onConstruction, Object... arguments)
+            throws InstantiationException, InvocationTargetException {
+        if (Modifier.isAbstract(constructor.getDeclaringClass().getModifiers())) {
+            throw new InstantiationException(
+                    "Cannot instantiate abstract " + constructor.getDeclaringClass().getTypeName());
+        }
+        assureArguments(constructor, null, null, arguments, constructor.getParameterTypes());
+        try {
+            Object module =
+                    DISPATCHER.invokeWithArguments(
+                            getModule.bindTo(constructor.getDeclaringClass()));
+            String packageName = constructor.getDeclaringClass().getPackage().getName();
+            assureOpen(module, packageName);
+            MethodHandle handle =
+                    ((MethodHandles.Lookup)
+                                    DISPATCHER.invokeWithArguments(
+                                            privateLookupIn,
+                                            constructor.getDeclaringClass(),
+                                            DISPATCHER.getLookup()))
+                            .unreflectConstructor(constructor);
+            AtomicBoolean thrown = new AtomicBoolean();
+            Object value =
+                    onConstruction.invoke(
+                            () -> {
+                                try {
+                                    return DISPATCHER.invokeWithArguments(handle, arguments);
+                                } catch (Throwable throwable) {
+                                    thrown.set(true);
+                                    return throwable;
+                                }
+                            });
+            if (thrown.get()) {
+                throw new InvocationTargetException((Throwable) value);
+            } else {
+                return value;
+            }
+        } catch (InvocationTargetException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new IllegalStateException(
+                    "Could not construct "
+                            + constructor
+                            + " with arguments "
+                            + Arrays.toString(arguments),
+                    t);
+        }
+    }
+
+    @Override
+    public Object invoke(Method method, Object target, Object... arguments)
+            throws InvocationTargetException {
+        assureArguments(
+                method,
+                Modifier.isStatic(method.getModifiers()) ? null : target,
+                method.getDeclaringClass(),
+                arguments,
+                method.getParameterTypes());
+        try {
+            Object module =
+                    DISPATCHER.invokeWithArguments(getModule.bindTo(method.getDeclaringClass()));
+            String packageName = method.getDeclaringClass().getPackage().getName();
+            assureOpen(module, packageName);
+            MethodHandle handle =
+                    ((MethodHandles.Lookup)
+                                    DISPATCHER.invokeWithArguments(
+                                            privateLookupIn,
+                                            method.getDeclaringClass(),
+                                            DISPATCHER.getLookup()))
+                            .unreflect(method);
+            if (!Modifier.isStatic(method.getModifiers())) {
+                handle = handle.bindTo(target);
+            }
+            try {
+                return DISPATCHER.invokeWithArguments(handle, arguments);
+            } catch (Throwable t) {
+                throw new InvocationTargetException(t);
+            }
+        } catch (InvocationTargetException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new IllegalStateException(
+                    "Could not invoke "
+                            + method
+                            + " on "
+                            + target
+                            + " with arguments "
+                            + Arrays.toString(arguments),
+                    t);
+        }
+    }
+
+    @Override
+    public Object get(Field field, Object target) {
+        assureArguments(
+                field,
+                Modifier.isStatic(field.getModifiers()) ? null : target,
+                field.getDeclaringClass(),
+                new Object[0],
+                new Class<?>[0]);
+        try {
+            Object module =
+                    DISPATCHER.invokeWithArguments(getModule.bindTo(field.getDeclaringClass()));
+            String packageName = field.getDeclaringClass().getPackage().getName();
+            assureOpen(module, packageName);
+            MethodHandle handle =
+                    ((MethodHandles.Lookup)
+                                    DISPATCHER.invokeWithArguments(
+                                            privateLookupIn,
+                                            field.getDeclaringClass(),
+                                            DISPATCHER.getLookup()))
+                            .unreflectGetter(field);
+            if (!Modifier.isStatic(field.getModifiers())) {
+                handle = handle.bindTo(target);
+            }
+            return DISPATCHER.invokeWithArguments(handle);
+        } catch (Throwable t) {
+            throw new IllegalStateException("Could not read " + field + " on " + target, t);
+        }
+    }
+
+    @Override
+    public void set(Field field, Object target, Object value) throws IllegalAccessException {
+        assureArguments(
+                field,
+                Modifier.isStatic(field.getModifiers()) ? null : target,
+                field.getDeclaringClass(),
+                new Object[] {value},
+                new Class<?>[] {field.getType()});
+        boolean illegalAccess = false;
+        try {
+            Object module =
+                    DISPATCHER.invokeWithArguments(getModule.bindTo(field.getDeclaringClass()));
+            String packageName = field.getDeclaringClass().getPackage().getName();
+            assureOpen(module, packageName);
+            // Method handles do not allow setting final fields where setAccessible(true)
+            // is required before unreflecting.
+            boolean isFinal;
+            if (Modifier.isFinal(field.getModifiers())) {
+                isFinal = true;
+                try {
+                    DISPATCHER.setAccessible(field, true);
+                } catch (Throwable ignored) {
+                    illegalAccess =
+                            true; // To distinguish from propagated illegal access exception.
+                    throw new IllegalAccessException(
+                            "Could not make final field " + field + " accessible");
+                }
+            } else {
+                isFinal = false;
+            }
+            try {
+                MethodHandle handle =
+                        ((MethodHandles.Lookup)
+                                        DISPATCHER.invokeWithArguments(
+                                                privateLookupIn,
+                                                field.getDeclaringClass(),
+                                                DISPATCHER.getLookup()))
+                                .unreflectSetter(field);
+                if (!Modifier.isStatic(field.getModifiers())) {
+                    handle = handle.bindTo(target);
+                }
+                DISPATCHER.invokeWithArguments(handle, value);
+            } finally {
+                if (isFinal) {
+                    DISPATCHER.setAccessible(field, false);
+                }
+            }
+        } catch (Throwable t) {
+            if (illegalAccess) {
+                throw (IllegalAccessException) t;
+            } else {
+                throw new IllegalStateException("Could not read " + field + " on " + target, t);
+            }
+        }
+    }
+
+    private void assureOpen(Object module, String packageName) throws Throwable {
+        // It would be more reliable to check if a module's package already is opened to
+        // the dispatcher module from before. Unfortunately, there is no reliable check
+        // for doing so since the isOpen(String, Module) method always returns true
+        // if the second argument is an unnamed module. Therefore, for now, we need
+        // to reopen packages even if they are already opened to the dispatcher module.
+        if (!(Boolean) DISPATCHER.invokeWithArguments(isOpen, module, packageName)) {
+            DISPATCHER.invokeWithArguments(
+                    redefineModule.bindTo(INSTRUMENTATION),
+                    module,
+                    Collections.emptySet(),
+                    Collections.emptyMap(),
+                    Collections.singletonMap(
+                            packageName, Collections.singleton(DISPATCHER.getModule())),
+                    Collections.emptySet(),
+                    Collections.emptyMap());
+        }
+    }
+
+    private static void assureArguments(
+            AccessibleObject target,
+            Object owner,
+            Class<?> type,
+            Object[] values,
+            Class<?>[] types) {
+        if (owner != null) {
+            if (!type.isAssignableFrom(owner.getClass())) {
+                throw new IllegalArgumentException("Cannot access " + target + " on " + owner);
+            }
+        }
+        if (types.length != values.length) {
+            throw new IllegalArgumentException(
+                    "Incorrect number of arguments for "
+                            + target
+                            + ": expected "
+                            + types.length
+                            + " but recevied "
+                            + values.length);
+        }
+        for (int index = 0; index < values.length; index++) {
+            if (values[index] == null) {
+                if (types[index].isPrimitive()) {
+                    throw new IllegalArgumentException(
+                            "Cannot assign null to primitive type "
+                                    + types[index].getTypeName()
+                                    + " for "
+                                    + index
+                                    + " parameter of "
+                                    + target);
+                }
+            } else {
+                Class<?> resolved = WRAPPERS.getOrDefault(types[index], types[index]);
+                if (!resolved.isAssignableFrom(values[index].getClass())) {
+                    throw new IllegalArgumentException(
+                            "Cannot assign value of type "
+                                    + values[index].getClass()
+                                    + " to "
+                                    + resolved
+                                    + " for "
+                                    + index
+                                    + " parameter of "
+                                    + target);
+                }
+            }
+        }
+    }
+
+    public interface Dispatcher {
+
+        MethodHandles.Lookup getLookup();
+
+        Object getModule();
+
+        void setAccessible(AccessibleObject target, boolean value);
+
+        // Used to avoid invoke/invokeExact being exposed to Android where this class should
+        // never be loaded. Since the invocation happens from the generated code, the Android
+        // build pipeline does not fail.
+        Object invokeWithArguments(MethodHandle handle, Object... arguments) throws Throwable;
+    }
+}
diff --git a/src/main/java/org/mockito/internal/util/reflection/LenientCopyTool.java b/src/main/java/org/mockito/internal/util/reflection/LenientCopyTool.java
index c6b9919..95b3019 100644
--- a/src/main/java/org/mockito/internal/util/reflection/LenientCopyTool.java
+++ b/src/main/java/org/mockito/internal/util/reflection/LenientCopyTool.java
@@ -4,13 +4,15 @@
  */
 package org.mockito.internal.util.reflection;
 
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.plugins.MemberAccessor;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
-@SuppressWarnings("unchecked")
 public class LenientCopyTool {
 
-    FieldCopier fieldCopier = new FieldCopier();
+    MemberAccessor accessor = Plugins.getMemberAccessor();
 
     public <T> void copyToMock(T from, T mock) {
         copy(from, mock, from.getClass());
@@ -35,14 +37,11 @@ public class LenientCopyTool {
             if (Modifier.isStatic(field.getModifiers())) {
                 continue;
             }
-            AccessibilityChanger accessibilityChanger = new AccessibilityChanger();
             try {
-                accessibilityChanger.enableAccess(field);
-                fieldCopier.copyValue(from, mock, field);
+                Object value = accessor.get(field, from);
+                accessor.set(field, mock, value);
             } catch (Throwable t) {
-                //Ignore - be lenient - if some field cannot be copied then let's be it
-            } finally {
-                accessibilityChanger.safelyDisableAccess(field);
+                // Ignore - be lenient - if some field cannot be copied then let's be it
             }
         }
     }
diff --git a/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java b/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java
new file mode 100644
index 0000000..08e55a5
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.reflection;
+
+import net.bytebuddy.ClassFileVersion;
+import org.mockito.plugins.MemberAccessor;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class ModuleMemberAccessor implements MemberAccessor {
+
+    private final MemberAccessor delegate;
+
+    public ModuleMemberAccessor() {
+        MemberAccessor delegate;
+        try {
+            delegate = delegate();
+        } catch (Throwable ignored) {
+            // Fallback in case Byte Buddy is not used as a mock maker and not available on the
+            // class loader.
+            delegate = new ReflectionMemberAccessor();
+        }
+        this.delegate = delegate;
+    }
+
+    private static MemberAccessor delegate() {
+        if (ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V9)) {
+            return new InstrumentationMemberAccessor();
+        } else {
+            return new ReflectionMemberAccessor();
+        }
+    }
+
+    @Override
+    public Object newInstance(Constructor<?> constructor, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException {
+        return delegate.newInstance(constructor, arguments);
+    }
+
+    @Override
+    public Object newInstance(
+            Constructor<?> constructor, OnConstruction onConstruction, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException {
+        return delegate.newInstance(constructor, onConstruction, arguments);
+    }
+
+    @Override
+    public Object invoke(Method method, Object target, Object... arguments)
+            throws InvocationTargetException, IllegalAccessException {
+        return delegate.invoke(method, target, arguments);
+    }
+
+    @Override
+    public Object get(Field field, Object target) throws IllegalAccessException {
+        return delegate.get(field, target);
+    }
+
+    @Override
+    public void set(Field field, Object target, Object value) throws IllegalAccessException {
+        delegate.set(field, target, value);
+    }
+}
diff --git a/src/main/java/org/mockito/internal/util/reflection/ReflectionMemberAccessor.java b/src/main/java/org/mockito/internal/util/reflection/ReflectionMemberAccessor.java
new file mode 100644
index 0000000..deb884d
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/reflection/ReflectionMemberAccessor.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.reflection;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import org.mockito.plugins.MemberAccessor;
+
+public class ReflectionMemberAccessor implements MemberAccessor {
+
+    @Override
+    public Object newInstance(Constructor<?> constructor, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException {
+        return newInstance(constructor, ConstructionDispatcher::newInstance, arguments);
+    }
+
+    @Override
+    public Object newInstance(
+            Constructor<?> constructor, OnConstruction onConstruction, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException {
+        silentSetAccessible(constructor, true);
+        try {
+            return onConstruction.invoke(() -> constructor.newInstance(arguments));
+        } catch (InvocationTargetException
+                | IllegalAccessException
+                | InstantiationException
+                | IllegalArgumentException e) {
+            throw e;
+        } catch (RuntimeException e) {
+            throw new IllegalStateException(
+                    "Failed to invoke " + constructor + " with " + Arrays.toString(arguments), e);
+        } finally {
+            silentSetAccessible(constructor, false);
+        }
+    }
+
+    @Override
+    public Object invoke(Method method, Object target, Object... arguments)
+            throws InvocationTargetException, IllegalAccessException {
+        silentSetAccessible(method, true);
+        try {
+            return method.invoke(target, arguments);
+        } catch (InvocationTargetException | IllegalAccessException | IllegalArgumentException e) {
+            throw e;
+        } catch (RuntimeException e) {
+            throw new IllegalStateException("Could not invoke " + method + " on " + target, e);
+        } finally {
+            silentSetAccessible(method, false);
+        }
+    }
+
+    @Override
+    public Object get(Field field, Object target) throws IllegalAccessException {
+        silentSetAccessible(field, true);
+        try {
+            return field.get(target);
+        } catch (IllegalAccessException | IllegalArgumentException e) {
+            throw e;
+        } catch (RuntimeException e) {
+            throw new IllegalStateException("Could not read " + field + " from " + target, e);
+        } finally {
+            silentSetAccessible(field, false);
+        }
+    }
+
+    @Override
+    public void set(Field field, Object target, Object value) throws IllegalAccessException {
+        silentSetAccessible(field, true);
+        try {
+            field.set(target, value);
+        } catch (IllegalAccessException | IllegalArgumentException e) {
+            throw e;
+        } catch (RuntimeException e) {
+            throw new IllegalStateException("Could not write " + field + " to " + target, e);
+        } finally {
+            silentSetAccessible(field, false);
+        }
+    }
+
+    private static void silentSetAccessible(AccessibleObject object, boolean value) {
+        try {
+            object.setAccessible(value);
+        } catch (RuntimeException ignored) {
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/util/reflection/SuperTypesLastSorter.java b/src/main/java/org/mockito/internal/util/reflection/SuperTypesLastSorter.java
index 8f5c161..32ed974 100644
--- a/src/main/java/org/mockito/internal/util/reflection/SuperTypesLastSorter.java
+++ b/src/main/java/org/mockito/internal/util/reflection/SuperTypesLastSorter.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2015 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util.reflection;
 
 import java.lang.reflect.Field;
@@ -18,15 +17,14 @@ import java.util.List;
  */
 public class SuperTypesLastSorter {
 
-    private SuperTypesLastSorter() {
-    }
+    private SuperTypesLastSorter() {}
 
     /**
      * Return a new collection with the fields sorted first by name,
      * then with any fields moved after their supertypes.
      */
     public static List<Field> sortSuperTypesLast(Collection<? extends Field> unsortedFields) {
-        List<Field> fields = new ArrayList<Field>(unsortedFields);
+        List<Field> fields = new ArrayList<>(unsortedFields);
 
         Collections.sort(fields, compareFieldsByName);
 
@@ -55,11 +53,8 @@ public class SuperTypesLastSorter {
         return fields;
     }
 
-
-    private static final Comparator<Field> compareFieldsByName = new Comparator<Field>() {
-        @Override
-        public int compare(Field o1, Field o2) {
-            return o1.getName().compareTo(o2.getName());
-        }
-    };
+    private static final Comparator<Field> compareFieldsByName =
+            (Field o1, Field o2) -> {
+                return o1.getName().compareTo(o2.getName());
+            };
 }
diff --git a/src/main/java/org/mockito/internal/verification/AtLeast.java b/src/main/java/org/mockito/internal/verification/AtLeast.java
index 768cc92..5f70649 100644
--- a/src/main/java/org/mockito/internal/verification/AtLeast.java
+++ b/src/main/java/org/mockito/internal/verification/AtLeast.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker.checkAtLeastNumberOfInvocations;
@@ -28,7 +27,7 @@ public class AtLeast implements VerificationInOrderMode, VerificationMode {
     @Override
     public void verify(VerificationData data) {
         if (wantedCount == 1) {
-             checkMissingInvocation(data.getAllInvocations(), data.getTarget());
+            checkMissingInvocation(data.getAllInvocations(), data.getTarget());
         }
         checkAtLeastNumberOfInvocations(data.getAllInvocations(), data.getTarget(), wantedCount);
     }
@@ -36,18 +35,15 @@ public class AtLeast implements VerificationInOrderMode, VerificationMode {
     @Override
     public void verifyInOrder(VerificationDataInOrder data) {
         if (wantedCount == 1) {
-             checkMissingInvocation(data.getAllInvocations(), data.getWanted(),  data.getOrderingContext());
+            checkMissingInvocation(
+                    data.getAllInvocations(), data.getWanted(), data.getOrderingContext());
         }
-        checkAtLeastNumberOfInvocations(data.getAllInvocations(), data.getWanted(), wantedCount, data.getOrderingContext());
+        checkAtLeastNumberOfInvocations(
+                data.getAllInvocations(), data.getWanted(), wantedCount, data.getOrderingContext());
     }
 
     @Override
     public String toString() {
         return "Wanted invocations count: at least " + wantedCount;
     }
-
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/AtMost.java b/src/main/java/org/mockito/internal/verification/AtMost.java
index 0c31878..72c0d00 100644
--- a/src/main/java/org/mockito/internal/verification/AtMost.java
+++ b/src/main/java/org/mockito/internal/verification/AtMost.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.exceptions.Reporter.wantedAtMostX;
@@ -11,10 +10,11 @@ import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 
 import java.util.Iterator;
 import java.util.List;
+
 import org.mockito.exceptions.base.MockitoException;
-import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.MatchableInvocation;
 import org.mockito.verification.VerificationMode;
 
 public class AtMost implements VerificationMode {
@@ -28,6 +28,7 @@ public class AtMost implements VerificationMode {
         this.maxNumberOfInvocations = maxNumberOfInvocations;
     }
 
+    @Override
     public void verify(VerificationData data) {
         List<Invocation> invocations = data.getAllInvocations();
         MatchableInvocation wanted = data.getTarget();
@@ -42,11 +43,6 @@ public class AtMost implements VerificationMode {
         markVerified(found, wanted);
     }
 
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
-
     private void removeAlreadyVerified(List<Invocation> invocations) {
         for (Iterator<Invocation> iterator = invocations.iterator(); iterator.hasNext(); ) {
             Invocation i = iterator.next();
@@ -55,4 +51,9 @@ public class AtMost implements VerificationMode {
             }
         }
     }
+
+    @Override
+    public String toString() {
+        return "Wanted invocations count: at most " + maxNumberOfInvocations;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/Calls.java b/src/main/java/org/mockito/internal/verification/Calls.java
index 9083752..f52fd66 100644
--- a/src/main/java/org/mockito/internal/verification/Calls.java
+++ b/src/main/java/org/mockito/internal/verification/Calls.java
@@ -2,13 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
 import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
 
 import java.util.List;
+
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.internal.verification.api.VerificationDataInOrder;
@@ -22,15 +22,15 @@ public class Calls implements VerificationMode, VerificationInOrderMode {
     final int wantedCount;
 
     public Calls(int wantedNumberOfInvocations) {
-        if( wantedNumberOfInvocations <= 0 ) {
-            throw new MockitoException( "Negative and zero values are not allowed here" );
+        if (wantedNumberOfInvocations <= 0) {
+            throw new MockitoException("Negative and zero values are not allowed here");
         }
         this.wantedCount = wantedNumberOfInvocations;
     }
 
     @Override
     public void verify(VerificationData data) {
-        throw new MockitoException( "calls is only intended to work with InOrder" );
+        throw new MockitoException("calls is only intended to work with InOrder");
     }
 
     @Override
@@ -38,17 +38,13 @@ public class Calls implements VerificationMode, VerificationInOrderMode {
         List<Invocation> allInvocations = data.getAllInvocations();
         MatchableInvocation wanted = data.getWanted();
 
-        checkMissingInvocation(allInvocations, wanted,  data.getOrderingContext());
-        checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
+        checkMissingInvocation(allInvocations, wanted, data.getOrderingContext());
+        checkNumberOfInvocationsNonGreedy(
+                allInvocations, wanted, wantedCount, data.getOrderingContext());
     }
 
     @Override
     public String toString() {
         return "Wanted invocations count (non-greedy): " + wantedCount;
     }
-
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
index 20518ae..f81a537 100644
--- a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
+++ b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
@@ -2,55 +2,59 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-import org.mockito.invocation.Invocation;
-
 import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 
 import java.io.Serializable;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
+import org.mockito.invocation.Invocation;
 
 public class DefaultRegisteredInvocations implements RegisteredInvocations, Serializable {
 
     private static final long serialVersionUID = -2674402327380736290L;
-    private final LinkedList<Invocation> invocations = new LinkedList<Invocation>();
+    private final LinkedList<Invocation> invocations = new LinkedList<>();
 
+    @Override
     public void add(Invocation invocation) {
         synchronized (invocations) {
             invocations.add(invocation);
         }
     }
 
+    @Override
     public void removeLast() {
-        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)
+        // TODO: add specific test for synchronization of this block (it is tested by
+        // InvocationContainerImplTest at the moment)
         synchronized (invocations) {
-            if (! invocations.isEmpty()) {
+            if (!invocations.isEmpty()) {
                 invocations.removeLast();
             }
         }
     }
 
+    @Override
     public List<Invocation> getAll() {
         List<Invocation> copiedList;
         synchronized (invocations) {
-            copiedList = new LinkedList<Invocation>(invocations) ;
+            copiedList = new LinkedList<>(invocations);
         }
 
         return ListUtil.filter(copiedList, new RemoveToString());
     }
 
+    @Override
     public void clear() {
         synchronized (invocations) {
             invocations.clear();
         }
     }
 
+    @Override
     public boolean isEmpty() {
         synchronized (invocations) {
             return invocations.isEmpty();
@@ -58,9 +62,9 @@ public class DefaultRegisteredInvocations implements RegisteredInvocations, Seri
     }
 
     private static class RemoveToString implements Filter<Invocation> {
+        @Override
         public boolean isOut(Invocation invocation) {
             return isToStringMethod(invocation.getMethod());
         }
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/verification/Description.java b/src/main/java/org/mockito/internal/verification/Description.java
index b11f99a..10651e2 100644
--- a/src/main/java/org/mockito/internal/verification/Description.java
+++ b/src/main/java/org/mockito/internal/verification/Description.java
@@ -39,13 +39,8 @@ public class Description implements VerificationMode {
         try {
             verification.verify(data);
 
-        } catch (MockitoAssertionError e) {
+        } catch (AssertionError e) {
             throw new MockitoAssertionError(e, description);
         }
     }
-
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/InOrderContextImpl.java b/src/main/java/org/mockito/internal/verification/InOrderContextImpl.java
index b7a7a96..46a0177 100644
--- a/src/main/java/org/mockito/internal/verification/InOrderContextImpl.java
+++ b/src/main/java/org/mockito/internal/verification/InOrderContextImpl.java
@@ -12,10 +12,12 @@ public class InOrderContextImpl implements InOrderContext {
 
     final IdentitySet verified = new IdentitySet();
 
+    @Override
     public boolean isVerified(Invocation invocation) {
         return verified.contains(invocation);
     }
 
+    @Override
     public void markVerified(Invocation i) {
         verified.add(i);
     }
diff --git a/src/main/java/org/mockito/internal/verification/InOrderWrapper.java b/src/main/java/org/mockito/internal/verification/InOrderWrapper.java
index 88a4d70..b829195 100644
--- a/src/main/java/org/mockito/internal/verification/InOrderWrapper.java
+++ b/src/main/java/org/mockito/internal/verification/InOrderWrapper.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.internal.verification;
 
+import java.util.List;
+
 import org.mockito.internal.InOrderImpl;
 import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;
 import org.mockito.internal.verification.api.VerificationData;
@@ -12,8 +14,6 @@ import org.mockito.internal.verification.api.VerificationInOrderMode;
 import org.mockito.invocation.Invocation;
 import org.mockito.verification.VerificationMode;
 
-import java.util.List;
-
 public class InOrderWrapper implements VerificationMode {
 
     private final VerificationInOrderMode mode;
@@ -24,14 +24,12 @@ public class InOrderWrapper implements VerificationMode {
         this.inOrder = inOrder;
     }
 
+    @Override
     public void verify(VerificationData data) {
-        List<Invocation> invocations = VerifiableInvocationsFinder.find(inOrder.getMocksToBeVerifiedInOrder());
-        VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl(inOrder, invocations, data.getTarget());
+        List<Invocation> invocations =
+                VerifiableInvocationsFinder.find(inOrder.getMocksToBeVerifiedInOrder());
+        VerificationDataInOrderImpl dataInOrder =
+                new VerificationDataInOrderImpl(inOrder, invocations, data.getTarget());
         mode.verifyInOrder(dataInOrder);
     }
-
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/MockAwareVerificationMode.java b/src/main/java/org/mockito/internal/verification/MockAwareVerificationMode.java
index af4c0e8..490f917 100644
--- a/src/main/java/org/mockito/internal/verification/MockAwareVerificationMode.java
+++ b/src/main/java/org/mockito/internal/verification/MockAwareVerificationMode.java
@@ -5,6 +5,7 @@
 package org.mockito.internal.verification;
 
 import java.util.Set;
+
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.listeners.VerificationListener;
 import org.mockito.verification.VerificationEvent;
@@ -16,26 +17,24 @@ public class MockAwareVerificationMode implements VerificationMode {
     private final VerificationMode mode;
     private final Set<VerificationListener> listeners;
 
-    public MockAwareVerificationMode(Object mock, VerificationMode mode, Set<VerificationListener> listeners) {
+    public MockAwareVerificationMode(
+            Object mock, VerificationMode mode, Set<VerificationListener> listeners) {
         this.mock = mock;
         this.mode = mode;
         this.listeners = listeners;
     }
 
+    @Override
     public void verify(VerificationData data) {
         try {
             mode.verify(data);
             notifyListeners(new VerificationEventImpl(mock, mode, data, null));
-        } catch (RuntimeException e) {
-            notifyListeners(new VerificationEventImpl(mock, mode, data, e));
-            throw e;
-        } catch (Error e) {
+        } catch (RuntimeException | Error e) {
             notifyListeners(new VerificationEventImpl(mock, mode, data, e));
             throw e;
         }
     }
 
-
     private void notifyListeners(VerificationEvent event) {
         for (VerificationListener listener : listeners) {
             listener.onVerification(event);
@@ -45,8 +44,4 @@ public class MockAwareVerificationMode implements VerificationMode {
     public Object getMock() {
         return mock;
     }
-
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/NoInteractions.java b/src/main/java/org/mockito/internal/verification/NoInteractions.java
new file mode 100644
index 0000000..c307abd
--- /dev/null
+++ b/src/main/java/org/mockito/internal/verification/NoInteractions.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.verification;
+
+import static org.mockito.internal.exceptions.Reporter.noInteractionsWanted;
+
+import java.util.List;
+
+import org.mockito.internal.verification.api.VerificationData;
+import org.mockito.invocation.Invocation;
+import org.mockito.verification.VerificationMode;
+
+public class NoInteractions implements VerificationMode {
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public void verify(VerificationData data) {
+        List<Invocation> invocations = data.getAllInvocations();
+        if (!invocations.isEmpty()) {
+            throw noInteractionsWanted(invocations.get(0).getMock(), (List) invocations);
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/verification/NoMoreInteractions.java b/src/main/java/org/mockito/internal/verification/NoMoreInteractions.java
index 8110849..ad8018f 100644
--- a/src/main/java/org/mockito/internal/verification/NoMoreInteractions.java
+++ b/src/main/java/org/mockito/internal/verification/NoMoreInteractions.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.exceptions.Reporter.noMoreInteractionsWanted;
@@ -20,6 +19,7 @@ import org.mockito.verification.VerificationMode;
 
 public class NoMoreInteractions implements VerificationMode, VerificationInOrderMode {
 
+    @Override
     @SuppressWarnings("unchecked")
     public void verify(VerificationData data) {
         Invocation unverified = findFirstUnverified(data.getAllInvocations());
@@ -28,6 +28,7 @@ public class NoMoreInteractions implements VerificationMode, VerificationInOrder
         }
     }
 
+    @Override
     public void verifyInOrder(VerificationDataInOrder data) {
         List<Invocation> invocations = data.getAllInvocations();
         Invocation unverified = findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);
@@ -36,9 +37,4 @@ public class NoMoreInteractions implements VerificationMode, VerificationInOrder
             throw noMoreInteractionsWantedInOrder(unverified);
         }
     }
-
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/Only.java b/src/main/java/org/mockito/internal/verification/Only.java
index 009f660..aea8981 100644
--- a/src/main/java/org/mockito/internal/verification/Only.java
+++ b/src/main/java/org/mockito/internal/verification/Only.java
@@ -12,18 +12,19 @@ import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 
 import java.util.List;
 
-import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.MatchableInvocation;
 import org.mockito.verification.VerificationMode;
 
 public class Only implements VerificationMode {
 
+    @Override
     @SuppressWarnings("unchecked")
     public void verify(VerificationData data) {
         MatchableInvocation target = data.getTarget();
         List<Invocation> invocations = data.getAllInvocations();
-        List<Invocation> chunk = findInvocations(invocations,target);
+        List<Invocation> chunk = findInvocations(invocations, target);
         if (invocations.size() != 1 && !chunk.isEmpty()) {
             Invocation unverified = findFirstUnverified(invocations);
             throw noMoreInteractionsWanted(unverified, (List) invocations);
@@ -34,7 +35,8 @@ public class Only implements VerificationMode {
         markVerified(chunk.get(0), target);
     }
 
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
+    @Override
+    public String toString() {
+        return "Wanted invocations count: 1 and no other method invoked";
     }
 }
diff --git a/src/main/java/org/mockito/internal/verification/RegisteredInvocations.java b/src/main/java/org/mockito/internal/verification/RegisteredInvocations.java
index dcc49d9..8aa088e 100644
--- a/src/main/java/org/mockito/internal/verification/RegisteredInvocations.java
+++ b/src/main/java/org/mockito/internal/verification/RegisteredInvocations.java
@@ -2,13 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
-import org.mockito.invocation.Invocation;
-
 import java.util.List;
 
+import org.mockito.invocation.Invocation;
 
 public interface RegisteredInvocations {
 
@@ -21,5 +19,4 @@ public interface RegisteredInvocations {
     void clear();
 
     boolean isEmpty();
-
 }
diff --git a/src/main/java/org/mockito/internal/verification/SingleRegisteredInvocation.java b/src/main/java/org/mockito/internal/verification/SingleRegisteredInvocation.java
index 67ceafa..78ef006 100644
--- a/src/main/java/org/mockito/internal/verification/SingleRegisteredInvocation.java
+++ b/src/main/java/org/mockito/internal/verification/SingleRegisteredInvocation.java
@@ -2,35 +2,39 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
-import org.mockito.invocation.Invocation;
-
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.List;
 
+import org.mockito.invocation.Invocation;
+
 public class SingleRegisteredInvocation implements RegisteredInvocations, Serializable {
 
     private Invocation invocation;
 
+    @Override
     public void add(Invocation invocation) {
         this.invocation = invocation;
     }
 
+    @Override
     public void removeLast() {
         invocation = null;
     }
 
+    @Override
     public List<Invocation> getAll() {
         return Collections.emptyList();
     }
 
+    @Override
     public void clear() {
         invocation = null;
     }
 
+    @Override
     public boolean isEmpty() {
         return invocation == null;
     }
diff --git a/src/main/java/org/mockito/internal/verification/Times.java b/src/main/java/org/mockito/internal/verification/Times.java
index e786a23..122ba64 100644
--- a/src/main/java/org/mockito/internal/verification/Times.java
+++ b/src/main/java/org/mockito/internal/verification/Times.java
@@ -2,19 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
 import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
 
 import java.util.List;
+
 import org.mockito.exceptions.base.MockitoException;
-import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.internal.verification.api.VerificationDataInOrder;
 import org.mockito.internal.verification.api.VerificationInOrderMode;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.MatchableInvocation;
 import org.mockito.verification.VerificationMode;
 
 public class Times implements VerificationInOrderMode, VerificationMode {
@@ -34,10 +34,11 @@ public class Times implements VerificationInOrderMode, VerificationMode {
         MatchableInvocation wanted = data.getTarget();
 
         if (wantedCount > 0) {
-             checkMissingInvocation(data.getAllInvocations(), data.getTarget());
+            checkMissingInvocation(data.getAllInvocations(), data.getTarget());
         }
         checkNumberOfInvocations(invocations, wanted, wantedCount);
     }
+
     @Override
     public void verifyInOrder(VerificationDataInOrder data) {
         List<Invocation> allInvocations = data.getAllInvocations();
diff --git a/src/main/java/org/mockito/internal/verification/VerificationDataImpl.java b/src/main/java/org/mockito/internal/verification/VerificationDataImpl.java
index d4fd127..a566ab5 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationDataImpl.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationDataImpl.java
@@ -4,17 +4,17 @@
  */
 package org.mockito.internal.verification;
 
+import static org.mockito.internal.exceptions.Reporter.cannotVerifyToString;
+import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
+
+import java.util.List;
+
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 
-import java.util.List;
-
-import static org.mockito.internal.exceptions.Reporter.cannotVerifyToString;
-import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
-
 public class VerificationDataImpl implements VerificationData {
 
     private final InvocationMatcher wanted;
@@ -36,11 +36,6 @@ public class VerificationDataImpl implements VerificationData {
         return wanted;
     }
 
-    @Override
-    public InvocationMatcher getWanted() {
-        return wanted;
-    }
-
     private void assertWantedIsVerifiable() {
         if (wanted == null) {
             return;
diff --git a/src/main/java/org/mockito/internal/verification/VerificationEventImpl.java b/src/main/java/org/mockito/internal/verification/VerificationEventImpl.java
index bf85055..56fabce 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationEventImpl.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationEventImpl.java
@@ -14,26 +14,30 @@ public class VerificationEventImpl implements VerificationEvent {
     private final VerificationData data;
     private final Throwable cause;
 
-
-    public VerificationEventImpl(Object mock, VerificationMode mode, VerificationData data, Throwable cause) {
+    public VerificationEventImpl(
+            Object mock, VerificationMode mode, VerificationData data, Throwable cause) {
         this.mock = mock;
         this.mode = mode;
         this.data = data;
         this.cause = cause;
     }
 
+    @Override
     public Object getMock() {
         return mock;
     }
 
+    @Override
     public VerificationMode getMode() {
         return mode;
     }
 
+    @Override
     public VerificationData getData() {
         return data;
     }
 
+    @Override
     public Throwable getVerificationError() {
         return cause;
     }
diff --git a/src/main/java/org/mockito/internal/verification/VerificationModeFactory.java b/src/main/java/org/mockito/internal/verification/VerificationModeFactory.java
index 1f8e8b6..b3ba446 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationModeFactory.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationModeFactory.java
@@ -2,12 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
 import org.mockito.verification.VerificationMode;
 
-public class VerificationModeFactory {
+public final class VerificationModeFactory {
 
     public static VerificationMode atLeastOnce() {
         return atLeast(1);
@@ -18,7 +17,7 @@ public class VerificationModeFactory {
     }
 
     public static VerificationMode only() {
-        return new Only(); //TODO make exception message nicer
+        return new Only(); // TODO make exception message nicer
     }
 
     public static Times times(int wantedNumberOfInvocations) {
@@ -26,13 +25,21 @@ public class VerificationModeFactory {
     }
 
     public static Calls calls(int wantedNumberOfInvocations) {
-        return new Calls( wantedNumberOfInvocations );
+        return new Calls(wantedNumberOfInvocations);
     }
 
     public static NoMoreInteractions noMoreInteractions() {
         return new NoMoreInteractions();
     }
 
+    public static NoInteractions noInteractions() {
+        return new NoInteractions();
+    }
+
+    public static VerificationMode atMostOnce() {
+        return atMost(1);
+    }
+
     public static VerificationMode atMost(int maxNumberOfInvocations) {
         return new AtMost(maxNumberOfInvocations);
     }
@@ -47,4 +54,6 @@ public class VerificationModeFactory {
     public static VerificationMode description(VerificationMode mode, String description) {
         return new Description(mode, description);
     }
+
+    private VerificationModeFactory() {}
 }
diff --git a/src/main/java/org/mockito/internal/verification/VerificationOverTimeImpl.java b/src/main/java/org/mockito/internal/verification/VerificationOverTimeImpl.java
index aa91dab..2e7b8e7 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationOverTimeImpl.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationOverTimeImpl.java
@@ -32,7 +32,11 @@ public class VerificationOverTimeImpl implements VerificationMode {
      *                        the delegate is satisfied and the full duration has passed (as in
      *                        {@link org.mockito.verification.VerificationAfterDelay}).
      */
-    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess) {
+    public VerificationOverTimeImpl(
+            long pollingPeriodMillis,
+            long durationMillis,
+            VerificationMode delegate,
+            boolean returnOnSuccess) {
         this(pollingPeriodMillis, delegate, returnOnSuccess, new Timer(durationMillis));
     }
 
@@ -47,7 +51,11 @@ public class VerificationOverTimeImpl implements VerificationMode {
      *                        {@link org.mockito.verification.VerificationAfterDelay}).
      * @param timer Checker of whether the duration of the verification is still acceptable
      */
-    public VerificationOverTimeImpl(long pollingPeriodMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {
+    public VerificationOverTimeImpl(
+            long pollingPeriodMillis,
+            VerificationMode delegate,
+            boolean returnOnSuccess,
+            Timer timer) {
         this.pollingPeriodMillis = pollingPeriodMillis;
         this.delegate = delegate;
         this.returnOnSuccess = returnOnSuccess;
@@ -69,6 +77,7 @@ public class VerificationOverTimeImpl implements VerificationMode {
      *
      * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout
      */
+    @Override
     public void verify(VerificationData data) {
         AssertionError error = null;
 
@@ -82,10 +91,7 @@ public class VerificationOverTimeImpl implements VerificationMode {
                 } else {
                     error = null;
                 }
-            } catch (MockitoAssertionError e) {
-                error = handleVerifyException(e);
-            }
-            catch (AssertionError e) {
+            } catch (AssertionError e) {
                 error = handleVerifyException(e);
             }
         }
@@ -105,11 +111,13 @@ public class VerificationOverTimeImpl implements VerificationMode {
     }
 
     protected boolean canRecoverFromFailure(VerificationMode verificationMode) {
-        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);
+        return !(verificationMode instanceof AtMost
+                || verificationMode instanceof NoMoreInteractions);
     }
 
     public VerificationOverTimeImpl copyWithVerificationMode(VerificationMode verificationMode) {
-        return new VerificationOverTimeImpl(pollingPeriodMillis, timer.duration(), verificationMode, returnOnSuccess);
+        return new VerificationOverTimeImpl(
+                pollingPeriodMillis, timer.duration(), verificationMode, returnOnSuccess);
     }
 
     private void sleep(long sleep) {
@@ -120,11 +128,6 @@ public class VerificationOverTimeImpl implements VerificationMode {
         }
     }
 
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
-
     public boolean isReturnOnSuccess() {
         return returnOnSuccess;
     }
diff --git a/src/main/java/org/mockito/internal/verification/VerificationWrapper.java b/src/main/java/org/mockito/internal/verification/VerificationWrapper.java
index b471342..6bc592a 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationWrapper.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationWrapper.java
@@ -7,22 +7,26 @@ package org.mockito.internal.verification;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.verification.VerificationMode;
 
-public abstract class VerificationWrapper<WrapperType extends VerificationMode> implements VerificationMode {
+public abstract class VerificationWrapper<WrapperT extends VerificationMode>
+        implements VerificationMode {
 
-    protected final WrapperType wrappedVerification;
+    protected final WrapperT wrappedVerification;
 
-    public VerificationWrapper(WrapperType wrappedVerification) {
+    public VerificationWrapper(WrapperT wrappedVerification) {
         this.wrappedVerification = wrappedVerification;
     }
 
+    @Override
     public void verify(VerificationData data) {
         wrappedVerification.verify(data);
     }
 
-    protected abstract VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode);
+    protected abstract VerificationMode copySelfWithNewVerificationMode(
+            VerificationMode verificationMode);
 
     public VerificationMode times(int wantedNumberOfInvocations) {
-        return copySelfWithNewVerificationMode(VerificationModeFactory.times(wantedNumberOfInvocations));
+        return copySelfWithNewVerificationMode(
+                VerificationModeFactory.times(wantedNumberOfInvocations));
     }
 
     public VerificationMode never() {
@@ -34,15 +38,20 @@ public abstract class VerificationWrapper<WrapperType extends VerificationMode>
     }
 
     public VerificationMode atLeast(int minNumberOfInvocations) {
-        return copySelfWithNewVerificationMode(VerificationModeFactory.atLeast(minNumberOfInvocations));
+        return copySelfWithNewVerificationMode(
+                VerificationModeFactory.atLeast(minNumberOfInvocations));
+    }
+
+    public VerificationMode atMostOnce() {
+        return copySelfWithNewVerificationMode(VerificationModeFactory.atMostOnce());
     }
 
     public VerificationMode atMost(int maxNumberOfInvocations) {
-        return copySelfWithNewVerificationMode(VerificationModeFactory.atMost(maxNumberOfInvocations));
+        return copySelfWithNewVerificationMode(
+                VerificationModeFactory.atMost(maxNumberOfInvocations));
     }
 
     public VerificationMode only() {
         return copySelfWithNewVerificationMode(VerificationModeFactory.only());
     }
-
 }
diff --git a/src/main/java/org/mockito/internal/verification/VerificationWrapperInOrderWrapper.java b/src/main/java/org/mockito/internal/verification/VerificationWrapperInOrderWrapper.java
index 840efb7..16b8c3d 100644
--- a/src/main/java/org/mockito/internal/verification/VerificationWrapperInOrderWrapper.java
+++ b/src/main/java/org/mockito/internal/verification/VerificationWrapperInOrderWrapper.java
@@ -13,12 +13,15 @@ import org.mockito.verification.VerificationMode;
 public class VerificationWrapperInOrderWrapper implements VerificationMode {
     private final VerificationMode delegate;
 
-    public VerificationWrapperInOrderWrapper(VerificationWrapper<?> verificationWrapper, InOrderImpl inOrder) {
+    public VerificationWrapperInOrderWrapper(
+            VerificationWrapper<?> verificationWrapper, InOrderImpl inOrder) {
         VerificationMode verificationMode = verificationWrapper.wrappedVerification;
 
-        VerificationMode inOrderWrappedVerificationMode = wrapInOrder(verificationWrapper, verificationMode, inOrder);
+        VerificationMode inOrderWrappedVerificationMode =
+                wrapInOrder(verificationWrapper, verificationMode, inOrder);
 
-        delegate = verificationWrapper.copySelfWithNewVerificationMode(inOrderWrappedVerificationMode);
+        delegate =
+                verificationWrapper.copySelfWithNewVerificationMode(inOrderWrappedVerificationMode);
     }
 
     @Override
@@ -26,30 +29,33 @@ public class VerificationWrapperInOrderWrapper implements VerificationMode {
         delegate.verify(data);
     }
 
-    @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
-    }
-
-    private VerificationMode wrapInOrder(VerificationWrapper<?> verificationWrapper, VerificationMode verificationMode, InOrderImpl inOrder) {
+    private VerificationMode wrapInOrder(
+            VerificationWrapper<?> verificationWrapper,
+            VerificationMode verificationMode,
+            InOrderImpl inOrder) {
         if (verificationMode instanceof VerificationInOrderMode) {
-            final VerificationInOrderMode verificationInOrderMode = (VerificationInOrderMode)verificationMode;
+            final VerificationInOrderMode verificationInOrderMode =
+                    (VerificationInOrderMode) verificationMode;
             return new InOrderWrapper(verificationInOrderMode, inOrder);
         }
 
         if (verificationMode instanceof VerificationOverTimeImpl) {
-            final VerificationOverTimeImpl verificationOverTime = (VerificationOverTimeImpl)verificationMode;
+            final VerificationOverTimeImpl verificationOverTime =
+                    (VerificationOverTimeImpl) verificationMode;
             if (verificationOverTime.isReturnOnSuccess()) {
-                return new VerificationOverTimeImpl(verificationOverTime.getPollingPeriodMillis(),
+                return new VerificationOverTimeImpl(
+                        verificationOverTime.getPollingPeriodMillis(),
                         verificationOverTime.getTimer().duration(),
-                        wrapInOrder(verificationWrapper, verificationOverTime.getDelegate(), inOrder),
+                        wrapInOrder(
+                                verificationWrapper, verificationOverTime.getDelegate(), inOrder),
                         verificationOverTime.isReturnOnSuccess());
             }
         }
 
-        //TODO ugly exception message!!!
-        throw new MockitoException(verificationMode.getClass().getSimpleName() +
-                " is not implemented to work with InOrder wrapped inside a " +
-                verificationWrapper.getClass().getSimpleName());
+        // TODO ugly exception message!!!
+        throw new MockitoException(
+                verificationMode.getClass().getSimpleName()
+                        + " is not implemented to work with InOrder wrapped inside a "
+                        + verificationWrapper.getClass().getSimpleName());
     }
 }
diff --git a/src/main/java/org/mockito/internal/verification/api/InOrderContext.java b/src/main/java/org/mockito/internal/verification/api/InOrderContext.java
index c6953be..9672d7e 100644
--- a/src/main/java/org/mockito/internal/verification/api/InOrderContext.java
+++ b/src/main/java/org/mockito/internal/verification/api/InOrderContext.java
@@ -11,5 +11,4 @@ public interface InOrderContext {
     boolean isVerified(Invocation invocation);
 
     void markVerified(Invocation i);
-
 }
diff --git a/src/main/java/org/mockito/internal/verification/api/VerificationData.java b/src/main/java/org/mockito/internal/verification/api/VerificationData.java
index fd102ed..6d579b8 100644
--- a/src/main/java/org/mockito/internal/verification/api/VerificationData.java
+++ b/src/main/java/org/mockito/internal/verification/api/VerificationData.java
@@ -4,12 +4,11 @@
  */
 package org.mockito.internal.verification.api;
 
-import org.mockito.internal.invocation.InvocationMatcher;
+import java.util.List;
+
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 
-import java.util.List;
-
 /**
  * Data needed to perform verification of interactions.
  * This interface is considered public even though it lives in private package.
@@ -27,10 +26,10 @@ public interface VerificationData {
      * The target or wanted invocation.
      * Below example illustrates what is the 'target' invocation:
      * <pre class="code"><code class="java">
-     *   mock.foo();   // <- invocation 1
-     *   mock.bar();   // <- invocation 2
+     *   mock.foo();   // &lt;- invocation 1
+     *   mock.bar();   // &lt;- invocation 2
      *
-     *   verify(mock).bar();  // <- target invocation
+     *   verify(mock).bar();  // &lt;- target invocation
      * </code></pre>
      *
      * Target invocation can contain argument matchers therefore the returned type is {@link MatchableInvocation}
@@ -39,13 +38,4 @@ public interface VerificationData {
      * @since 2.2.12
      */
     MatchableInvocation getTarget();
-
-    /**
-     * @deprecated - This internal method leaks internal class <code>InvocationMatcher</code>.
-     * Please use {@link org.mockito.internal.verification.api.VerificationData#getTarget()} instead.
-     *
-     * Deprecated since 2.2.12
-     */
-    @Deprecated
-    InvocationMatcher getWanted();
 }
diff --git a/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrder.java b/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrder.java
index 0f46063..6103f57 100644
--- a/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrder.java
+++ b/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrder.java
@@ -16,5 +16,4 @@ public interface VerificationDataInOrder {
     MatchableInvocation getWanted();
 
     InOrderContext getOrderingContext();
-
 }
diff --git a/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java b/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java
index 4013b07..838ce5b 100644
--- a/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java
+++ b/src/main/java/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java
@@ -15,20 +15,24 @@ public class VerificationDataInOrderImpl implements VerificationDataInOrder {
     private final List<Invocation> allInvocations;
     private final MatchableInvocation wanted;
 
-    public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, MatchableInvocation wanted) {
+    public VerificationDataInOrderImpl(
+            InOrderContext inOrder, List<Invocation> allInvocations, MatchableInvocation wanted) {
         this.inOrder = inOrder;
         this.allInvocations = allInvocations;
         this.wanted = wanted;
     }
 
+    @Override
     public List<Invocation> getAllInvocations() {
         return allInvocations;
     }
 
+    @Override
     public InOrderContext getOrderingContext() {
         return inOrder;
     }
 
+    @Override
     public MatchableInvocation getWanted() {
         return wanted;
     }
diff --git a/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
index af31d60..060ea09 100644
--- a/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
+++ b/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
@@ -4,25 +4,31 @@
  */
 package org.mockito.internal.verification.argumentmatching;
 
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.matchers.ContainsExtraTypeInfo;
-
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.matchers.ContainsExtraTypeInfo;
 
 @SuppressWarnings("unchecked")
 public class ArgumentMatchingTool {
 
-    private ArgumentMatchingTool(){}
+    private ArgumentMatchingTool() {}
     /**
      * Suspiciously not matching arguments are those that don't match, the toString() representation is the same but types are different.
      */
-    public static Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<ArgumentMatcher> matchers, Object[] arguments) {
+    public static Integer[] getSuspiciouslyNotMatchingArgsIndexes(
+            List<ArgumentMatcher> matchers, Object[] arguments) {
         if (matchers.size() != arguments.length) {
             return new Integer[0];
         }
 
-        List<Integer> suspicious = new LinkedList<Integer>();
+        List<Integer> suspicious = new LinkedList<>();
         int i = 0;
         for (ArgumentMatcher m : matchers) {
             if (m instanceof ContainsExtraTypeInfo
@@ -45,6 +51,39 @@ public class ArgumentMatchingTool {
     }
 
     private static boolean toStringEquals(ArgumentMatcher m, Object arg) {
-        return m.toString().equals(arg == null ? "null" : arg.toString());
+        return m.toString().equals(String.valueOf(arg));
+    }
+
+    /**
+     * Suspiciously not matching arguments are those that don't match, and the classes have same simple name.
+     */
+    public static Set<String> getNotMatchingArgsWithSameName(
+            List<ArgumentMatcher> matchers, Object[] arguments) {
+        Map<String, Set<String>> classesHavingSameName = new HashMap<>();
+        for (ArgumentMatcher m : matchers) {
+            if (m instanceof ContainsExtraTypeInfo) {
+                Object wanted = ((ContainsExtraTypeInfo) m).getWanted();
+                if (wanted == null) {
+                    continue;
+                }
+                Class wantedClass = wanted.getClass();
+                classesHavingSameName
+                        .computeIfAbsent(wantedClass.getSimpleName(), className -> new HashSet<>())
+                        .add(wantedClass.getCanonicalName());
+            }
+        }
+        for (Object argument : arguments) {
+            if (argument == null) {
+                continue;
+            }
+            Class wantedClass = argument.getClass();
+            classesHavingSameName
+                    .computeIfAbsent(wantedClass.getSimpleName(), className -> new HashSet<>())
+                    .add(wantedClass.getCanonicalName());
+        }
+        return classesHavingSameName.entrySet().stream()
+                .filter(classEntry -> classEntry.getValue().size() > 1)
+                .map(classEntry -> classEntry.getKey())
+                .collect(Collectors.toSet());
     }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java b/src/main/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java
index d0eb0b5..68a1af1 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java
@@ -2,47 +2,57 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
-import java.util.List;
-import org.mockito.internal.verification.api.InOrderContext;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.Location;
-import org.mockito.invocation.MatchableInvocation;
-
-import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocations;
-import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
+import static org.mockito.internal.exceptions.Reporter.tooFewActualInvocations;
+import static org.mockito.internal.exceptions.Reporter.tooFewActualInvocationsInOrder;
 import static org.mockito.internal.invocation.InvocationMarker.markVerified;
 import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
 import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks;
 import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 import static org.mockito.internal.invocation.InvocationsFinder.getAllLocations;
 
-public class AtLeastXNumberOfInvocationsChecker {
+import java.util.List;
 
-    public static void checkAtLeastNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
+import org.mockito.internal.verification.api.InOrderContext;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
+import org.mockito.invocation.MatchableInvocation;
+
+public final class AtLeastXNumberOfInvocationsChecker {
+
+    public static void checkAtLeastNumberOfInvocations(
+            List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
         List<Invocation> actualInvocations = findInvocations(invocations, wanted);
 
         int actualCount = actualInvocations.size();
         if (wantedCount > actualCount) {
             List<Location> allLocations = getAllLocations(actualInvocations);
-            throw tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, allLocations);
+            throw tooFewActualInvocations(
+                    new AtLeastDiscrepancy(wantedCount, actualCount), wanted, allLocations);
         }
 
         markVerified(actualInvocations, wanted);
     }
 
-    public static void checkAtLeastNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount,InOrderContext orderingContext) {
-        List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);
+    public static void checkAtLeastNumberOfInvocations(
+            List<Invocation> invocations,
+            MatchableInvocation wanted,
+            int wantedCount,
+            InOrderContext orderingContext) {
+        List<Invocation> chunk =
+                findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);
 
         int actualCount = chunk.size();
 
         if (wantedCount > actualCount) {
             List<Location> allLocations = getAllLocations(chunk);
-            throw tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, allLocations);
+            throw tooFewActualInvocationsInOrder(
+                    new AtLeastDiscrepancy(wantedCount, actualCount), wanted, allLocations);
         }
 
         markVerifiedInOrder(chunk, wanted, orderingContext);
     }
+
+    private AtLeastXNumberOfInvocationsChecker() {}
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
index 3f89c77..aeb86b9 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
 import static org.mockito.internal.exceptions.Reporter.argumentsAreDifferent;
@@ -12,24 +11,28 @@ import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingU
 import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 import static org.mockito.internal.invocation.InvocationsFinder.findPreviousVerifiedInOrder;
 import static org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation;
+import static org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getNotMatchingArgsWithSameName;
 import static org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes;
 
 import java.util.List;
+import java.util.Set;
 
 import org.mockito.internal.reporting.SmartPrinter;
+import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
 import org.mockito.invocation.MatchableInvocation;
 
 public class MissingInvocationChecker {
 
-    private MissingInvocationChecker() {
-    }
+    private MissingInvocationChecker() {}
 
-    public static void checkMissingInvocation(List<Invocation> invocations, MatchableInvocation wanted) {
+    public static void checkMissingInvocation(
+            List<Invocation> invocations, MatchableInvocation wanted) {
         List<Invocation> actualInvocations = findInvocations(invocations, wanted);
 
-        if (!actualInvocations.isEmpty()){
+        if (!actualInvocations.isEmpty()) {
             return;
         }
 
@@ -38,13 +41,29 @@ public class MissingInvocationChecker {
             throw wantedButNotInvoked(wanted, invocations);
         }
 
-        Integer[] indexesOfSuspiciousArgs = getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());
-        SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);
-        throw argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());
+        Integer[] indexesOfSuspiciousArgs =
+                getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());
+        Set<String> classesWithSameSimpleName =
+                getNotMatchingArgsWithSameName(wanted.getMatchers(), similar.getArguments());
+        SmartPrinter smartPrinter =
+                new SmartPrinter(
+                        wanted, invocations, indexesOfSuspiciousArgs, classesWithSameSimpleName);
+        List<Location> actualLocations =
+                ListUtil.convert(
+                        invocations,
+                        new ListUtil.Converter<Invocation, Location>() {
+                            @Override
+                            public Location convert(Invocation invocation) {
+                                return invocation.getLocation();
+                            }
+                        });
 
+        throw argumentsAreDifferent(
+                smartPrinter.getWanted(), smartPrinter.getActuals(), actualLocations);
     }
 
-    public static void checkMissingInvocation(List<Invocation> invocations, MatchableInvocation wanted, InOrderContext context) {
+    public static void checkMissingInvocation(
+            List<Invocation> invocations, MatchableInvocation wanted, InOrderContext context) {
         List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, context);
 
         if (!chunk.isEmpty()) {
diff --git a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
index 1dfc2f1..78a276e 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
@@ -2,20 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
-import java.util.Arrays;
-import java.util.List;
-import org.mockito.internal.reporting.Discrepancy;
-import org.mockito.internal.verification.api.InOrderContext;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.Location;
-import org.mockito.invocation.MatchableInvocation;
-
 import static org.mockito.internal.exceptions.Reporter.neverWantedButInvoked;
-import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocations;
-import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
+import static org.mockito.internal.exceptions.Reporter.tooFewActualInvocations;
+import static org.mockito.internal.exceptions.Reporter.tooFewActualInvocationsInOrder;
 import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocations;
 import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
 import static org.mockito.internal.invocation.InvocationMarker.markVerified;
@@ -25,55 +16,79 @@ import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
 import static org.mockito.internal.invocation.InvocationsFinder.getAllLocations;
 
+import java.util.Arrays;
+import java.util.List;
+
+import org.mockito.internal.reporting.Discrepancy;
+import org.mockito.internal.verification.api.InOrderContext;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
+import org.mockito.invocation.MatchableInvocation;
+
 public class NumberOfInvocationsChecker {
 
-    private NumberOfInvocationsChecker() {
-    }
+    private NumberOfInvocationsChecker() {}
 
-    public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
+    public static void checkNumberOfInvocations(
+            List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
         List<Invocation> actualInvocations = findInvocations(invocations, wanted);
 
         int actualCount = actualInvocations.size();
         if (wantedCount > actualCount) {
             List<Location> allLocations = getAllLocations(actualInvocations);
-            throw tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, allLocations);
+            throw tooFewActualInvocations(
+                    new Discrepancy(wantedCount, actualCount), wanted, allLocations);
         }
         if (wantedCount == 0 && actualCount > 0) {
-            throw neverWantedButInvoked(wanted, getAllLocations(actualInvocations));
+            throw neverWantedButInvoked(wanted, actualInvocations);
         }
         if (wantedCount < actualCount) {
-            throw tooManyActualInvocations(wantedCount, actualCount, wanted, getAllLocations(actualInvocations));
+            throw tooManyActualInvocations(
+                    wantedCount, actualCount, wanted, getAllLocations(actualInvocations));
         }
 
         markVerified(actualInvocations, wanted);
     }
 
-    public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
+    public static void checkNumberOfInvocations(
+            List<Invocation> invocations,
+            MatchableInvocation wanted,
+            int wantedCount,
+            InOrderContext context) {
         List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
 
         int actualCount = chunk.size();
 
         if (wantedCount > actualCount) {
             List<Location> allLocations = getAllLocations(chunk);
-            throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, allLocations);
+            throw tooFewActualInvocationsInOrder(
+                    new Discrepancy(wantedCount, actualCount), wanted, allLocations);
         }
         if (wantedCount < actualCount) {
-            throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, getAllLocations(chunk));
+            throw tooManyActualInvocationsInOrder(
+                    wantedCount, actualCount, wanted, getAllLocations(chunk));
         }
 
         markVerifiedInOrder(chunk, wanted, context);
     }
 
-    public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
+    public static void checkNumberOfInvocationsNonGreedy(
+            List<Invocation> invocations,
+            MatchableInvocation wanted,
+            int wantedCount,
+            InOrderContext context) {
         int actualCount = 0;
         Location lastLocation = null;
-        while( actualCount < wantedCount ){
-            Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
-            if( next == null ){
-                throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, Arrays.asList(lastLocation));
+        while (actualCount < wantedCount) {
+            Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context);
+            if (next == null) {
+                throw tooFewActualInvocationsInOrder(
+                        new Discrepancy(wantedCount, actualCount),
+                        wanted,
+                        Arrays.asList(lastLocation));
             }
-            markVerified( next, wanted );
-            context.markVerified( next );
+            markVerified(next, wanted);
+            context.markVerified(next);
             lastLocation = next.getLocation();
             actualCount++;
         }
diff --git a/src/main/java/org/mockito/invocation/DescribedInvocation.java b/src/main/java/org/mockito/invocation/DescribedInvocation.java
index fc975ab..1c54201 100644
--- a/src/main/java/org/mockito/invocation/DescribedInvocation.java
+++ b/src/main/java/org/mockito/invocation/DescribedInvocation.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.invocation;
 
-
 /**
  * Provides information about the invocation, specifically a human readable description and the location.
  */
@@ -15,6 +14,7 @@ public interface DescribedInvocation {
      *
      * @return the description of this invocation.
      */
+    @Override
     String toString();
 
     /**
diff --git a/src/main/java/org/mockito/invocation/Invocation.java b/src/main/java/org/mockito/invocation/Invocation.java
index 131db84..7aeecce 100644
--- a/src/main/java/org/mockito/invocation/Invocation.java
+++ b/src/main/java/org/mockito/invocation/Invocation.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.invocation;
 
+import java.util.List;
+
+import org.mockito.ArgumentMatcher;
 import org.mockito.NotExtensible;
 
 /**
@@ -34,9 +37,8 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
      */
     int getSequenceNumber();
 
-    /**
-     * @return the location in code of this invocation.
-     */
+    /** @return the location in code of this invocation. */
+    @Override
     Location getLocation();
 
     /**
@@ -47,6 +49,16 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
      */
     Object[] getRawArguments();
 
+    /**
+     * Wraps each argument using {@link org.mockito.ArgumentMatchers#eq(Object)} or
+     * {@link org.mockito.AdditionalMatchers#aryEq(Object[])}
+     * Used internally for the purposes of human-readable invocation printing.
+     *
+     * @return a list of {@link ArgumentMatcher} wrapping each of this invocation arguments
+     * @since 2.25.6
+     */
+    List<ArgumentMatcher> getArgumentsAsMatchers();
+
     /**
      * Returns unprocessed arguments whereas {@link #getArguments()} returns
      * arguments already processed (e.g. varargs expended, etc.).
diff --git a/src/main/java/org/mockito/invocation/InvocationContainer.java b/src/main/java/org/mockito/invocation/InvocationContainer.java
index 9f0e82a..d12df44 100644
--- a/src/main/java/org/mockito/invocation/InvocationContainer.java
+++ b/src/main/java/org/mockito/invocation/InvocationContainer.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.invocation;
 
-import org.mockito.Incubating;
 import org.mockito.NotExtensible;
 
 /**
@@ -17,5 +16,4 @@ import org.mockito.NotExtensible;
  * @since 2.10.0
  */
 @NotExtensible
-@Incubating
 public interface InvocationContainer {}
diff --git a/src/main/java/org/mockito/invocation/InvocationFactory.java b/src/main/java/org/mockito/invocation/InvocationFactory.java
index 1803718..c28ef71 100644
--- a/src/main/java/org/mockito/invocation/InvocationFactory.java
+++ b/src/main/java/org/mockito/invocation/InvocationFactory.java
@@ -4,13 +4,11 @@
  */
 package org.mockito.invocation;
 
-import org.mockito.Incubating;
-import org.mockito.MockitoFramework;
-import org.mockito.mock.MockCreationSettings;
-
 import java.io.Serializable;
 import java.lang.reflect.Method;
-import java.util.concurrent.Callable;
+
+import org.mockito.MockitoFramework;
+import org.mockito.mock.MockCreationSettings;
 
 /**
  * Available via {@link MockitoFramework#getInvocationFactory()}.
@@ -24,31 +22,8 @@ import java.util.concurrent.Callable;
  *
  * @since 2.10.0
  */
-@Incubating
 public interface InvocationFactory {
 
-    /**
-     * @deprecated Use {@link #createInvocation(Object, MockCreationSettings, Method, RealMethodBehavior, Object...)} instead.
-     *
-     * Why deprecated? We found use cases where we need to handle Throwable and ensure correct stack trace filtering
-     * (removing Mockito internals from the stack trace). Hence the introduction of {@link RealMethodBehavior}.
-     *
-     * Creates instance of an {@link Invocation} object.
-     * This method is useful for framework integrators to programmatically simulate method calls on mocks using {@link MockHandler}.
-     * It enables advanced framework integrations.
-     *
-     * @param target the mock object the method is invoked on.
-     * @param settings creation settings of the mock object.
-     * @param method java method invoked on mock.
-     * @param realMethod real method behavior. Needed for spying / invoking real behavior on mock objects.
-     * @param args the java method arguments
-     *
-     * @return invocation instance
-     * @since 2.10.0
-     */
-    @Deprecated
-    Invocation createInvocation(Object target, MockCreationSettings settings, Method method, Callable realMethod, Object... args);
-
     /**
      * Behavior of the real method.
      *
@@ -72,6 +47,10 @@ public interface InvocationFactory {
      * @return invocation instance
      * @since 2.14.0
      */
-    @Incubating
-    Invocation createInvocation(Object target, MockCreationSettings settings, Method method, RealMethodBehavior realMethod, Object... args);
+    Invocation createInvocation(
+            Object target,
+            MockCreationSettings settings,
+            Method method,
+            RealMethodBehavior realMethod,
+            Object... args);
 }
diff --git a/src/main/java/org/mockito/invocation/InvocationOnMock.java b/src/main/java/org/mockito/invocation/InvocationOnMock.java
index 345ddb9..269926e 100644
--- a/src/main/java/org/mockito/invocation/InvocationOnMock.java
+++ b/src/main/java/org/mockito/invocation/InvocationOnMock.java
@@ -2,18 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.invocation;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 
+import org.mockito.NotExtensible;
+
 /**
  * An invocation on a mock.
  *
  * <p>
  * A placeholder for mock, the method that was called and the arguments that were passed.
  */
+@NotExtensible
 public interface InvocationOnMock extends Serializable {
 
     /**
@@ -44,12 +46,37 @@ public interface InvocationOnMock extends Serializable {
      *
      * Can lookup in expanded arguments form {@link #getArguments()}.
      *
+     * This method is preferred over {@link #getArgument(int, Class)} for readability. Please read
+     * the documentation of {@link #getArgument(int, Class)} for an overview of situations when
+     * that method is preferred over this one.
+     *
      * @param index argument index
      * @return casted argument at the given index
      * @since 2.1.0
      */
     <T> T getArgument(int index);
 
+    /**
+     * Returns casted argument at the given index. This method is analogous to
+     * {@link #getArgument(int)}, but is necessary to circumvent issues when dealing with generics.
+     *
+     * In general, {@link #getArgument(int)} is the appropriate function to use. This particular
+     * function is only necessary if you are doing one of the following things:
+     *
+     * <ol>
+     *  <li>You want to directly invoke a method on the result of {@link #getArgument(int)}.</li>
+     *  <li>You want to directly pass the result of the invocation into a function that accepts a generic parameter.</li>
+     * </ol>
+     *
+     * If you prefer to use {@link #getArgument(int)} instead, you can circumvent the compilation
+     * issues by storing the intermediate result into a local variable with the correct type.
+     *
+     * @param index argument index
+     * @param clazz class to cast the argument to
+     * @return casted argument at the given index
+     */
+    <T> T getArgument(int index, Class<T> clazz);
+
     /**
      * calls real method
      * <p>
diff --git a/src/main/java/org/mockito/invocation/Location.java b/src/main/java/org/mockito/invocation/Location.java
index e362704..ea3c274 100644
--- a/src/main/java/org/mockito/invocation/Location.java
+++ b/src/main/java/org/mockito/invocation/Location.java
@@ -4,14 +4,27 @@
  */
 package org.mockito.invocation;
 
+import org.mockito.NotExtensible;
+
 /**
  * Describes the location of something in the source code.
  */
+@NotExtensible
 public interface Location {
 
     /**
-     * @return the location
+     * Human readable location in the source code, see {@link Invocation#getLocation()}
+     *
+     * @return location
      */
+    @Override
     String toString();
 
+    /**
+     * Source file of this location
+     *
+     * @return source file
+     * @since 2.24.6
+     */
+    String getSourceFile();
 }
diff --git a/src/main/java/org/mockito/invocation/MatchableInvocation.java b/src/main/java/org/mockito/invocation/MatchableInvocation.java
index ff0290a..af642e5 100644
--- a/src/main/java/org/mockito/invocation/MatchableInvocation.java
+++ b/src/main/java/org/mockito/invocation/MatchableInvocation.java
@@ -4,18 +4,18 @@
  */
 package org.mockito.invocation;
 
-import org.mockito.ArgumentMatcher;
-
 import java.util.List;
 
+import org.mockito.ArgumentMatcher;
+
 /**
  * <code>MatchableInvocation</code> wraps {@link Invocation} instance
  * and holds argument matchers associated with that invocation.
  * It is used during verification process:
  *
  * <pre class="code"><code class="java">
- *   mock.foo();   // <- invocation
- *   verify(mock).bar();  // <- matchable invocation
+ *   mock.foo();   // &lt;- invocation
+ *   verify(mock).bar();  // &lt;- matchable invocation
  * </code></pre>
  *
  * @since 2.2.12
diff --git a/src/main/java/org/mockito/invocation/MockHandler.java b/src/main/java/org/mockito/invocation/MockHandler.java
index 273cdb5..56a0004 100644
--- a/src/main/java/org/mockito/invocation/MockHandler.java
+++ b/src/main/java/org/mockito/invocation/MockHandler.java
@@ -4,12 +4,11 @@
  */
 package org.mockito.invocation;
 
-import org.mockito.Incubating;
+import java.io.Serializable;
+
 import org.mockito.MockSettings;
 import org.mockito.mock.MockCreationSettings;
 
-import java.io.Serializable;
-
 /**
  * Mockito handler of an invocation on a mock. This is a core part of the API, the heart of Mockito.
  * See also the {@link org.mockito.plugins.MockMaker}.
@@ -44,7 +43,6 @@ public interface MockHandler<T> extends Serializable {
      * @return read-only settings of the mock
      * @since 2.10.0
      */
-    @Incubating
     MockCreationSettings<T> getMockSettings();
 
     /**
@@ -60,6 +58,5 @@ public interface MockHandler<T> extends Serializable {
      *          The container is not part of the public API, please do not cast it or provide custom implementations.
      * @since 2.10.0
      */
-    @Incubating
     InvocationContainer getInvocationContainer();
 }
diff --git a/src/main/java/org/mockito/junit/MockitoJUnit.java b/src/main/java/org/mockito/junit/MockitoJUnit.java
index da9428b..bbe6130 100644
--- a/src/main/java/org/mockito/junit/MockitoJUnit.java
+++ b/src/main/java/org/mockito/junit/MockitoJUnit.java
@@ -4,10 +4,11 @@
  */
 package org.mockito.junit;
 
-import org.mockito.Incubating;
+import org.junit.rules.TestRule;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.junit.JUnitRule;
+import org.mockito.internal.junit.JUnitTestRule;
 import org.mockito.internal.junit.VerificationCollectorImpl;
-import org.mockito.internal.util.ConsoleMockitoLogger;
 import org.mockito.quality.Strictness;
 
 /**
@@ -15,12 +16,12 @@ import org.mockito.quality.Strictness;
  * <li>
  *     <ul>JUnit Rules - see {@link MockitoRule}</ul>
  *     <ul>JUnit runners - see {@link MockitoJUnitRunner}</ul>
- *     <ul><a href="http://javadoc.io/page/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html">JUnit Jupiter extension</a></ul>
+ *     <ul><a href="http://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html">JUnit Jupiter extension</a></ul>
  * </li>
  *
  * @since 1.10.17
  */
-public class MockitoJUnit {
+public final class MockitoJUnit {
 
     /**
      * Creates rule instance that initiates &#064;Mocks
@@ -30,7 +31,21 @@ public class MockitoJUnit {
      * @since 1.10.17
      */
     public static MockitoRule rule() {
-        return new JUnitRule(new ConsoleMockitoLogger(), Strictness.WARN);
+        return new JUnitRule(Plugins.getMockitoLogger(), Strictness.WARN);
+    }
+
+    /**
+     * Creates a rule instance that initiates &#064;Mocks and is a {@link TestRule}. Use this method
+     * only when you need to explicitly need a {@link TestRule}, for example if you need to compose
+     * multiple rules using a {@link org.junit.rules.RuleChain}. Otherwise, always prefer {@link #rule()}
+     * See {@link MockitoRule}.
+     *
+     * @param testInstance The instance to initiate mocks for
+     * @return the rule instance
+     * @since 3.3.0
+     */
+    public static MockitoTestRule testRule(Object testInstance) {
+        return new JUnitTestRule(Plugins.getMockitoLogger(), Strictness.WARN, testInstance);
     }
 
     /**
@@ -40,8 +55,9 @@ public class MockitoJUnit {
      * @return the rule instance
      * @since 2.1.0
      */
-    @Incubating
     public static VerificationCollector collector() {
         return new VerificationCollectorImpl();
     }
+
+    private MockitoJUnit() {}
 }
diff --git a/src/main/java/org/mockito/junit/MockitoJUnitRunner.java b/src/main/java/org/mockito/junit/MockitoJUnitRunner.java
index 59bc92b..c59f972 100644
--- a/src/main/java/org/mockito/junit/MockitoJUnitRunner.java
+++ b/src/main/java/org/mockito/junit/MockitoJUnitRunner.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.junit;
 
+import java.lang.reflect.InvocationTargetException;
+
 import org.junit.runner.Description;
 import org.junit.runner.Runner;
 import org.junit.runner.manipulation.Filter;
@@ -21,9 +23,6 @@ import org.mockito.internal.runners.StrictRunner;
 import org.mockito.quality.MockitoHint;
 import org.mockito.quality.Strictness;
 
-import java.lang.reflect.InvocationTargetException;
-
-
 /**
  * Mockito JUnit Runner keeps tests clean and improves debugging experience.
  * Make sure to try out {@link MockitoJUnitRunner.StrictStubs} which automatically
@@ -38,7 +37,7 @@ import java.lang.reflect.InvocationTargetException;
  *       To opt-out from this feature, use {@code}&#064;RunWith(MockitoJUnitRunner.Silent.class){@code}
  *   <li>
  *      Initializes mocks annotated with {@link Mock},
- *      so that explicit usage of {@link MockitoAnnotations#initMocks(Object)} is not necessary.
+ *      so that explicit usage of {@link MockitoAnnotations#openMocks(Object)} is not necessary.
  *      Mocks are initialized before each test method.
  *   <li>
  *      Validates framework usage after each test method. See javadoc for {@link Mockito#validateMockitoUsage()}.
@@ -47,7 +46,7 @@ import java.lang.reflect.InvocationTargetException;
  *      It drives cleaner tests and improves debugging experience.
  *      The only reason this feature is not turned on by default
  *      is because it would have been an incompatible change
- *      and Mockito strictly follows <a href="http://semver.org">semantic versioning</a>.
+ *      and Mockito strictly follows <a href="https://semver.org">semantic versioning</a>.
  * </ul>
  *
  * Runner is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.
@@ -70,7 +69,7 @@ import java.lang.reflect.InvocationTargetException;
  * </code></pre>
  *
  * If you would like to take advantage of Mockito JUnit runner features
- * but you cannot use the runner because, for example, you use TestNG, there is a solution!
+ * but you cannot use the runner there is a solution!
  * {@link MockitoSession} API is intended to offer cleaner tests and improved debuggability
  * to users that cannot use Mockito's built-in JUnit support (runner or the rule).
  */
@@ -150,7 +149,8 @@ public class MockitoJUnitRunner extends Runner implements Filterable {
     private final InternalRunner runner;
 
     public MockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
-        //by default, StrictRunner is used. We can change that potentially based on feedback from users
+        // by default, StrictRunner is used. We can change that potentially based on feedback from
+        // users
         this(new StrictRunner(new RunnerFactory().createStrict(klass), klass));
     }
 
@@ -168,8 +168,9 @@ public class MockitoJUnitRunner extends Runner implements Filterable {
         return runner.getDescription();
     }
 
+    @Override
     public void filter(Filter filter) throws NoTestsRemainException {
-        //filter is required because without it UnrootedTests show up in Eclipse
+        // filter is required because without it UnrootedTests show up in Eclipse
         runner.filter(filter);
     }
 }
diff --git a/src/main/java/org/mockito/junit/MockitoRule.java b/src/main/java/org/mockito/junit/MockitoRule.java
index 561fff7..10a2735 100644
--- a/src/main/java/org/mockito/junit/MockitoRule.java
+++ b/src/main/java/org/mockito/junit/MockitoRule.java
@@ -5,14 +5,13 @@
 package org.mockito.junit;
 
 import org.junit.rules.MethodRule;
-import org.mockito.Incubating;
 import org.mockito.MockSettings;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.quality.MockitoHint;
 import org.mockito.quality.Strictness;
-import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 
 /**
  * Mockito JUnit Rule helps keeping tests clean.
@@ -37,7 +36,7 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
  *      See also {@link MockitoHint}.
  *   <li>
  *      Initializes mocks annotated with {@link org.mockito.Mock},
- *      so that explicit usage of {@link MockitoAnnotations#initMocks(Object)} is not necessary.
+ *      so that explicit usage of {@link MockitoAnnotations#openMocks(Object)} is not necessary.
  *      Mocks are initialized before each test method.
  *   <li>
  *      Validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.
@@ -46,7 +45,7 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
  *      It drives cleaner tests and improves debugging experience.
  *      The only reason this feature is not turned on by default
  *      is because it would have been an incompatible change
- *      and Mockito strictly follows <a href="http://semver.org">semantic versioning</a>.
+ *      and Mockito strictly follows <a href="https://semver.org">semantic versioning</a>.
  *
  * </ul>
  * Example use:
@@ -67,7 +66,7 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
  * </code></pre>
  *
  * If you would like to take advantage of Mockito JUnit rule features
- * but you cannot use the rule because, for example, you use TestNG, there is a solution!
+ * but you cannot use the rule there is a solution!
  * {@link MockitoSession} API is intended to offer cleaner tests and improved debuggability
  * to users that cannot use Mockito's built-in JUnit support (runner or the rule).
  *
@@ -146,6 +145,5 @@ public interface MockitoRule extends MethodRule {
      *
      * @since 2.3.0
      */
-    @Incubating
     MockitoRule strictness(Strictness strictness);
 }
diff --git a/src/main/java/org/mockito/junit/MockitoTestRule.java b/src/main/java/org/mockito/junit/MockitoTestRule.java
new file mode 100644
index 0000000..5efc690
--- /dev/null
+++ b/src/main/java/org/mockito/junit/MockitoTestRule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.junit;
+
+import org.junit.rules.TestRule;
+import org.mockito.quality.Strictness;
+
+/**
+ * Equivalent to {@link MockitoRule}, but inherits a different JUnit4 base interface {@link TestRule}.
+ * For more information, please see the documentation on {@link MockitoRule}.
+ *
+ * @since 3.3.0
+ */
+public interface MockitoTestRule extends TestRule {
+
+    /**
+     * Equivalent to {@link MockitoRule#silent()}.
+     *
+     * @since 3.3.0
+     */
+    MockitoTestRule silent();
+
+    /**
+     * Equivalent to {@link MockitoRule#strictness(Strictness)}.
+     *
+     * @since 3.3.0
+     */
+    MockitoTestRule strictness(Strictness strictness);
+}
diff --git a/src/main/java/org/mockito/junit/VerificationCollector.java b/src/main/java/org/mockito/junit/VerificationCollector.java
index 08962b5..c214b5d 100644
--- a/src/main/java/org/mockito/junit/VerificationCollector.java
+++ b/src/main/java/org/mockito/junit/VerificationCollector.java
@@ -5,7 +5,6 @@
 package org.mockito.junit;
 
 import org.junit.rules.TestRule;
-import org.mockito.Incubating;
 import org.mockito.exceptions.base.MockitoAssertionError;
 
 /**
@@ -37,7 +36,6 @@ import org.mockito.exceptions.base.MockitoAssertionError;
  * @see org.mockito.Mockito#verify(Object, org.mockito.verification.VerificationMode)
  * @since 2.1.0
  */
-@Incubating
 public interface VerificationCollector extends TestRule {
 
     /**
@@ -70,7 +68,6 @@ public interface VerificationCollector extends TestRule {
      * @throws MockitoAssertionError If there were failed verifications
      * @since 2.1.0
      */
-    @Incubating
     void collectAndReport() throws MockitoAssertionError;
 
     /**
@@ -96,6 +93,5 @@ public interface VerificationCollector extends TestRule {
      * @return this
      * @since 2.1.0
      */
-    @Incubating
     VerificationCollector assertLazily();
 }
diff --git a/src/main/java/org/mockito/listeners/MockCreationListener.java b/src/main/java/org/mockito/listeners/MockCreationListener.java
index 24a1904..7ab15f8 100644
--- a/src/main/java/org/mockito/listeners/MockCreationListener.java
+++ b/src/main/java/org/mockito/listeners/MockCreationListener.java
@@ -19,4 +19,12 @@ public interface MockCreationListener extends MockitoListener {
      * @param settings the settings used for creation
      */
     void onMockCreated(Object mock, MockCreationSettings settings);
+
+    /**
+     * Static mock object was just created.
+     *
+     * @param mock the type being mocked
+     * @param settings the settings used for creation
+     */
+    default void onStaticMockCreated(Class<?> mock, MockCreationSettings settings) {}
 }
diff --git a/src/main/java/org/mockito/listeners/MockitoListener.java b/src/main/java/org/mockito/listeners/MockitoListener.java
index ea8dcb6..b5a4e5e 100644
--- a/src/main/java/org/mockito/listeners/MockitoListener.java
+++ b/src/main/java/org/mockito/listeners/MockitoListener.java
@@ -8,5 +8,4 @@ package org.mockito.listeners;
  * Marker interface for all types of Mockito listeners.
  * For more information, see {@link org.mockito.MockitoFramework#addListener(MockitoListener)}.
  */
-public interface MockitoListener {
-}
+public interface MockitoListener {}
diff --git a/src/main/java/org/mockito/internal/listeners/StubbingLookupEvent.java b/src/main/java/org/mockito/listeners/StubbingLookupEvent.java
similarity index 87%
rename from src/main/java/org/mockito/internal/listeners/StubbingLookupEvent.java
rename to src/main/java/org/mockito/listeners/StubbingLookupEvent.java
index 0d45edd..30642cc 100644
--- a/src/main/java/org/mockito/internal/listeners/StubbingLookupEvent.java
+++ b/src/main/java/org/mockito/listeners/StubbingLookupEvent.java
@@ -2,35 +2,42 @@
  * Copyright (c) 2018 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-package org.mockito.internal.listeners;
+package org.mockito.listeners;
+
+import java.util.Collection;
 
 import org.mockito.invocation.Invocation;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Stubbing;
 
-import java.util.Collection;
-
 /**
  * Represent an information about the looked up stubbing
+ *
+ * @since 2.24.6
  */
 public interface StubbingLookupEvent {
+
     /**
      * @return The invocation that causes stubbing lookup
+     * @since 2.24.6
      */
     Invocation getInvocation();
 
     /**
      * @return Looked up stubbing. It can be <code>null</code>, which indicates that the invocation was not stubbed
+     * @since 2.24.6
      */
     Stubbing getStubbingFound();
 
     /**
      * @return All stubbings declared on the mock object that we are invoking
+     * @since 2.24.6
      */
     Collection<Stubbing> getAllStubbings();
 
     /**
      * @return Settings of the mock object that we are invoking
+     * @since 2.24.6
      */
     MockCreationSettings getMockSettings();
 }
diff --git a/src/main/java/org/mockito/listeners/StubbingLookupListener.java b/src/main/java/org/mockito/listeners/StubbingLookupListener.java
new file mode 100644
index 0000000..b33e063
--- /dev/null
+++ b/src/main/java/org/mockito/listeners/StubbingLookupListener.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.listeners;
+
+import org.mockito.MockSettings;
+import org.mockito.mock.MockCreationSettings;
+
+/**
+ * When a method is called on a mock object Mockito looks up any stubbings recorded on that mock.
+ * This listener gets notified on stubbing lookup.
+ * Register listener via {@link MockSettings#stubbingLookupListeners(StubbingLookupListener...)}.
+ * This API is used by Mockito to implement {@link org.mockito.exceptions.misusing.PotentialStubbingProblem}
+ * (part of Mockito {@link org.mockito.quality.Strictness}).
+ * <p>
+ * Details: When method is called on the mock object, Mockito looks for any answer (stubbing) declared on that mock.
+ * If the stubbed answer is found, that answer is then invoked (value returned, thrown exception, etc.).
+ * If the answer is not found (e.g. that invocation was not stubbed on the mock), mock's default answer is used.
+ * This listener implementation is notified when Mockito attempts to find an answer for invocation on a mock.
+ * <p>
+ * The listeners can be accessed via {@link MockCreationSettings#getStubbingLookupListeners()}.
+ *
+ * @since 2.24.6
+ */
+public interface StubbingLookupListener {
+
+    /**
+     * Called by the framework when Mockito looked up an answer for invocation on a mock.
+     * For details, see {@link StubbingLookupListener}.
+     *
+     * @param stubbingLookupEvent - Information about the looked up stubbing
+     * @since 2.24.6
+     */
+    void onStubbingLookup(StubbingLookupEvent stubbingLookupEvent);
+}
diff --git a/src/main/java/org/mockito/listeners/VerificationListener.java b/src/main/java/org/mockito/listeners/VerificationListener.java
index c42be31..9f3aaae 100644
--- a/src/main/java/org/mockito/listeners/VerificationListener.java
+++ b/src/main/java/org/mockito/listeners/VerificationListener.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.listeners;
 
-import org.mockito.Incubating;
 import org.mockito.verification.VerificationEvent;
 
 /**
@@ -12,7 +11,6 @@ import org.mockito.verification.VerificationEvent;
  * <p>
  * For this to happen, it must be registered using {@link org.mockito.internal.progress.MockingProgress#addListener(MockitoListener)}.
  */
-@Incubating
 public interface VerificationListener extends MockitoListener {
     /**
      * Called after a verification happened.
diff --git a/src/main/java/org/mockito/listeners/VerificationStartedEvent.java b/src/main/java/org/mockito/listeners/VerificationStartedEvent.java
index b2f4a00..0eb72ce 100644
--- a/src/main/java/org/mockito/listeners/VerificationStartedEvent.java
+++ b/src/main/java/org/mockito/listeners/VerificationStartedEvent.java
@@ -4,15 +4,12 @@
  */
 package org.mockito.listeners;
 
-import org.mockito.Incubating;
-
 /**
  * The instance of this class is passed to {@link VerificationStartedListener}.
  * For all the details, including how and why to use this API, see {@link VerificationStartedListener}.
  *
  * @since 2.11.0
  */
-@Incubating
 public interface VerificationStartedEvent {
 
     /**
@@ -27,7 +24,6 @@ public interface VerificationStartedEvent {
      * @param mock to be used for verification.
      * @since 2.11.0
      */
-    @Incubating
     void setMock(Object mock);
 
     /**
@@ -37,6 +33,5 @@ public interface VerificationStartedEvent {
      *
      * @since 2.11.0
      */
-    @Incubating
     Object getMock();
 }
diff --git a/src/main/java/org/mockito/listeners/VerificationStartedListener.java b/src/main/java/org/mockito/listeners/VerificationStartedListener.java
index f555125..d942a1c 100644
--- a/src/main/java/org/mockito/listeners/VerificationStartedListener.java
+++ b/src/main/java/org/mockito/listeners/VerificationStartedListener.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.listeners;
 
-import org.mockito.Incubating;
-
 /**
  * This listener gets notified when the user starts verification.
  * It allows to replace the mock object for verification.
@@ -54,7 +52,6 @@ import org.mockito.Incubating;
  *
  * @since 2.11.0
  */
-@Incubating
 public interface VerificationStartedListener {
 
     /**
@@ -64,6 +61,5 @@ public interface VerificationStartedListener {
      * @param event object that allows to identify and replace mock for verification.
      * @since 2.11.0
      */
-    @Incubating
     void onVerificationStarted(VerificationStartedEvent event);
 }
diff --git a/src/main/java/org/mockito/mock/MockCreationSettings.java b/src/main/java/org/mockito/mock/MockCreationSettings.java
index 7e74be8..23d5418 100644
--- a/src/main/java/org/mockito/mock/MockCreationSettings.java
+++ b/src/main/java/org/mockito/mock/MockCreationSettings.java
@@ -2,20 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.mock;
 
-import org.mockito.Incubating;
+import java.util.List;
+import java.util.Set;
+
 import org.mockito.MockSettings;
 import org.mockito.NotExtensible;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockito.listeners.VerificationStartedListener;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 
-import java.util.List;
-import java.util.Set;
-
 /**
  * Informs about the mock settings. An immutable view of {@link org.mockito.MockSettings}.
  */
@@ -70,7 +69,17 @@ public interface MockCreationSettings<T> {
     boolean isStripAnnotations();
 
     /**
-     * {@link InvocationListener} instances attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.
+     * Returns {@link StubbingLookupListener} instances attached to this mock via {@link MockSettings#stubbingLookupListeners(StubbingLookupListener...)}.
+     * The resulting list is mutable, you can add/remove listeners even after the mock was created.
+     * <p>
+     * For more details see {@link StubbingLookupListener}.
+     *
+     * @since 2.24.6
+     */
+    List<StubbingLookupListener> getStubbingLookupListeners();
+
+    /**
+     * {@link InvocationListener} instances attached to this mock, see {@link org.mockito.MockSettings#invocationListeners(InvocationListener...)}.
      */
     List<InvocationListener> getInvocationListeners();
 
@@ -80,7 +89,6 @@ public interface MockCreationSettings<T> {
      *
      * @since 2.11.0
      */
-    @Incubating
     List<VerificationStartedListener> getVerificationStartedListeners();
 
     /**
@@ -88,7 +96,6 @@ public interface MockCreationSettings<T> {
      *
      * @since 1.10.12
      */
-    @Incubating
     boolean isUsingConstructor();
 
     /**
@@ -100,7 +107,6 @@ public interface MockCreationSettings<T> {
      *
      * @since 2.7.14
      */
-    @Incubating
     Object[] getConstructorArgs();
 
     /**
@@ -109,7 +115,6 @@ public interface MockCreationSettings<T> {
      * @return the outer class instance used for creation of the mock object via the constructor.
      * @since 1.10.12
      */
-    @Incubating
     Object getOuterClassInstance();
 
     /**
@@ -118,6 +123,5 @@ public interface MockCreationSettings<T> {
      *
      * @since 2.20.0
      */
-    @Incubating
     boolean isLenient();
 }
diff --git a/src/main/java/org/mockito/mock/MockName.java b/src/main/java/org/mockito/mock/MockName.java
index d3f6e7d..64ce8f7 100644
--- a/src/main/java/org/mockito/mock/MockName.java
+++ b/src/main/java/org/mockito/mock/MockName.java
@@ -9,9 +9,8 @@ package org.mockito.mock;
  */
 public interface MockName {
 
-    /**
-     * the name
-     */
+    /** the name */
+    @Override
     String toString();
 
     /**
diff --git a/src/main/java/org/mockito/mock/SerializableMode.java b/src/main/java/org/mockito/mock/SerializableMode.java
index 790fc04..41a5f36 100644
--- a/src/main/java/org/mockito/mock/SerializableMode.java
+++ b/src/main/java/org/mockito/mock/SerializableMode.java
@@ -4,12 +4,9 @@
  */
 package org.mockito.mock;
 
-import org.mockito.Incubating;
-
 /**
  * Mock serializable style.
  */
-@Incubating
 public enum SerializableMode {
 
     /**
@@ -25,6 +22,5 @@ public enum SerializableMode {
     /**
      * Useful if the mock is deserialized in a different classloader / vm.
      */
-    @Incubating
     ACROSS_CLASSLOADERS
 }
diff --git a/src/main/java/org/mockito/plugins/AnnotationEngine.java b/src/main/java/org/mockito/plugins/AnnotationEngine.java
index c60f477..c6365e9 100644
--- a/src/main/java/org/mockito/plugins/AnnotationEngine.java
+++ b/src/main/java/org/mockito/plugins/AnnotationEngine.java
@@ -13,7 +13,7 @@ package org.mockito.plugins;
  * or replace mockito default engine.
  *
  * <p>
- * If you are interested then see implementations or source code of {@link org.mockito.MockitoAnnotations#initMocks(Object)}
+ * If you are interested then see implementations or source code of {@link org.mockito.MockitoAnnotations#openMocks(Object)}
  *
  * <p>This plugin mechanism supersedes the {@link org.mockito.configuration.IMockitoConfiguration}
  * in regard of switching mockito components.
@@ -25,5 +25,11 @@ public interface AnnotationEngine {
      * @param clazz Class where to extract field information, check implementation for details
      * @param testInstance Test instance
      */
-    void process(Class<?> clazz, Object testInstance);
+    AutoCloseable process(Class<?> clazz, Object testInstance);
+
+    class NoAction implements AutoCloseable {
+
+        @Override
+        public void close() {}
+    }
 }
diff --git a/src/main/java/org/mockito/plugins/DoNotMockEnforcer.java b/src/main/java/org/mockito/plugins/DoNotMockEnforcer.java
new file mode 100644
index 0000000..a033bbc
--- /dev/null
+++ b/src/main/java/org/mockito/plugins/DoNotMockEnforcer.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.plugins;
+
+/**
+ * Enforcer that is applied to every type in the type hierarchy of the class-to-be-mocked.
+ */
+public interface DoNotMockEnforcer {
+
+    /**
+     * If this type is allowed to be mocked. Return an empty optional if the enforcer allows
+     * this type to be mocked. Return a message if there is a reason this type can not be mocked.
+     *
+     * Note that Mockito performs traversal of the type hierarchy. Implementations of this class
+     * should therefore not perform type traversal themselves but rely on Mockito.
+     *
+     * @param type The type to check
+     * @return Optional message if this type can not be mocked, or an empty optional if type can be mocked
+     */
+    String checkTypeForDoNotMockViolation(Class<?> type);
+}
diff --git a/src/main/java/org/mockito/plugins/InlineMockMaker.java b/src/main/java/org/mockito/plugins/InlineMockMaker.java
index ddc3ff6..08fab59 100644
--- a/src/main/java/org/mockito/plugins/InlineMockMaker.java
+++ b/src/main/java/org/mockito/plugins/InlineMockMaker.java
@@ -2,10 +2,8 @@
  * Copyright (c) 2019 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.plugins;
 
-import org.mockito.Incubating;
 import org.mockito.MockitoFramework;
 
 /**
@@ -27,7 +25,6 @@ import org.mockito.MockitoFramework;
  *
  * @since 2.25.0
  */
-@Incubating
 public interface InlineMockMaker extends MockMaker {
 
     /**
@@ -37,7 +34,6 @@ public interface InlineMockMaker extends MockMaker {
      * @param mock the mock instance whose internal state is to be cleaned.
      * @since 2.25.0
      */
-    @Incubating
     void clearMock(Object mock);
 
     /**
@@ -46,8 +42,5 @@ public interface InlineMockMaker extends MockMaker {
      *
      * @since 2.25.0
      */
-    @Incubating
     void clearAllMocks();
-
 }
-
diff --git a/src/main/java/org/mockito/plugins/InstantiatorProvider.java b/src/main/java/org/mockito/plugins/InstantiatorProvider.java
deleted file mode 100644
index 354b87b..0000000
--- a/src/main/java/org/mockito/plugins/InstantiatorProvider.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.plugins;
-
-import org.mockito.internal.creation.instance.Instantiator;
-import org.mockito.mock.MockCreationSettings;
-
-/**
- * @deprecated since 2.15.4 because this internal class was leaking from the public API.
- * For more information why deprecated, see {@link org.mockito.plugins.InstantiatorProvider2} and
- * <a href="https://github.com/mockito/mockito/issues/1303">Issue 1303</a>
- *
- * <p>
- *     Mockito will invoke this interface in order to fetch an instance instantiator provider.
- * </p>
- *
- * <p>
- *     By default, an internal byte-buddy/asm/objenesis based implementation is used.
- * </p>
- *
- * <h3>Using the extension point</h3>
- *
- * <p>
- *     The plugin mechanism of mockito works in a similar way as the
- *     {@link java.util.ServiceLoader}, however instead of looking in the <code>META-INF</code>
- *     directory, Mockito will look in <code>mockito-extensions</code> directory.
- *     <em>The reason for that is that Android SDK strips jar from the <code>META-INF</code>
- *     directory when creating an APK.</em>
- * </p>
- *
- * <ol style="list-style-type: lower-alpha">
- *     <li>The implementation itself, for example
- *         <code>org.awesome.mockito.AwesomeInstantiatorProvider</code> that implements the
- *         <code>InstantiatorProvider</code>.</li>
- *     <li>A file "<code>mockito-extensions/org.mockito.plugins.InstantiatorProvider</code>".
- *         The content of this file is exactly a <strong>one</strong> line with the qualified
- *         name: <code>org.awesome.mockito.AwesomeInstantiatorProvider</code>.</li>
- * </ol></p>
- *
- * <p>
- *     Note that if several <code>mockito-extensions/org.mockito.plugins.InstantiatorProvider</code>
- *     files exists in the classpath, Mockito will only use the first returned by the standard
- *     {@link ClassLoader#getResource} mechanism.
- * <p>
- *     So just create a custom implementation of {@link InstantiatorProvider} and place the
- *     qualified name in the following file
- *     <code>mockito-extensions/org.mockito.plugins.InstantiatorProvider</code>.
- * </p>
- * <p>
- *     This class is deprecated and was replaced by
- *     {@link org.mockito.plugins.InstantiatorProvider2}. Hence if there is both a
- *     <code>mockito-extensions/org.mockito.plugins.InstantiatorProvider</code> and
- *     <code>mockito-extensions/org.mockito.plugins.InstantiatorProvider2</code> the second one
- *     takes preference.
- * </p>
- *
- * @since 2.0.31
- */
-@Deprecated
-public interface InstantiatorProvider {
-
-    /**
-     * @deprecated, see {@link InstantiatorProvider}.
-     *
-     * Returns an instantiator, used to create new class instances.
-     */
-    @Deprecated
-    Instantiator getInstantiator(MockCreationSettings<?> settings);
-}
diff --git a/src/main/java/org/mockito/plugins/MemberAccessor.java b/src/main/java/org/mockito/plugins/MemberAccessor.java
new file mode 100644
index 0000000..6a39d6c
--- /dev/null
+++ b/src/main/java/org/mockito/plugins/MemberAccessor.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.plugins;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * A member accessor is responsible for invoking methods, constructors and for setting
+ * and reading field values.
+ */
+public interface MemberAccessor {
+
+    Object newInstance(Constructor<?> constructor, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException;
+
+    default Object newInstance(
+            Constructor<?> constructor, OnConstruction onConstruction, Object... arguments)
+            throws InstantiationException, InvocationTargetException, IllegalAccessException {
+        return onConstruction.invoke(() -> newInstance(constructor, arguments));
+    }
+
+    Object invoke(Method method, Object target, Object... arguments)
+            throws InvocationTargetException, IllegalAccessException;
+
+    Object get(Field field, Object target) throws IllegalAccessException;
+
+    void set(Field field, Object target, Object value) throws IllegalAccessException;
+
+    interface OnConstruction {
+
+        Object invoke(ConstructionDispatcher dispatcher)
+                throws InstantiationException, InvocationTargetException, IllegalAccessException;
+    }
+
+    interface ConstructionDispatcher {
+
+        Object newInstance()
+                throws InstantiationException, InvocationTargetException, IllegalAccessException;
+    }
+}
diff --git a/src/main/java/org/mockito/plugins/MockMaker.java b/src/main/java/org/mockito/plugins/MockMaker.java
index e4b0ca8..93a87ef 100644
--- a/src/main/java/org/mockito/plugins/MockMaker.java
+++ b/src/main/java/org/mockito/plugins/MockMaker.java
@@ -4,10 +4,17 @@
  */
 package org.mockito.plugins;
 
-import org.mockito.Incubating;
+import org.mockito.MockedConstruction;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Function;
+
+import static org.mockito.internal.util.StringUtil.join;
+
 /**
  * The facility to create mocks.
  *
@@ -31,7 +38,7 @@ import org.mockito.mock.MockCreationSettings;
  *         A file "<code>mockito-extensions/org.mockito.plugins.MockMaker</code>". The content of this file is
  *         exactly a <strong>one</strong> line with the qualified name:
  *         <code>org.awesome.mockito.AwesomeMockMaker</code>.
-*      </li>
+ *      </li>
  * </ol>
  * </p>
  *
@@ -64,10 +71,26 @@ public interface MockMaker {
      * @return The mock instance.
      * @since 1.9.5
      */
-    <T> T createMock(
-            MockCreationSettings<T> settings,
-            MockHandler handler
-    );
+    <T> T createMock(MockCreationSettings<T> settings, MockHandler handler);
+
+    /**
+     * By implementing this method, a mock maker can optionally support the creation of spies where all fields
+     * are set within a constructor. This avoids problems when creating spies of classes that declare
+     * effectively final instance fields where setting field values from outside the constructor is prohibited.
+     *
+     * @param settings Mock creation settings like type to mock, extra interfaces and so on.
+     * @param handler See {@link org.mockito.invocation.MockHandler}.
+     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of
+     *                {@link #getHandler(Object)} will return this instance.
+     * @param instance  The object to spy upon.
+     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.
+     * @return The spy instance, if this mock maker supports direct spy creation.
+     * @since 3.5.0
+     */
+    default <T> Optional<T> createSpy(
+            MockCreationSettings<T> settings, MockHandler handler, T instance) {
+        return Optional.empty();
+    }
 
     /**
      * Returns the handler for the {@code mock}. <b>Do not</b> provide your own implementations at this time
@@ -95,11 +118,7 @@ public interface MockMaker {
      * @param settings The mock settings - should you need to access some of the mock creation details.
      * @since 1.9.5
      */
-    void resetMock(
-            Object mock,
-            MockHandler newHandler,
-            MockCreationSettings settings
-    );
+    void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings);
 
     /**
      * Indicates if the given type can be mocked by this mockmaker.
@@ -112,15 +131,79 @@ public interface MockMaker {
      * @return object that carries the information about mockability of given type.
      * @since 2.1.0
      */
-    @Incubating
     TypeMockability isTypeMockable(Class<?> type);
 
+    /**
+     * If you want to provide your own implementation of {@code MockMaker} this method should:
+     * <ul>
+     *     <li>Alter the supplied class to only change its behavior in the current thread.</li>
+     *     <li>Only alters the static method's behavior after being enabled.</li>
+     *     <li>Stops the altered behavior when disabled.</li>
+     * </ul>
+     *
+     * @param settings Mock creation settings like type to mock, extra interfaces and so on.
+     * @param handler See {@link org.mockito.invocation.MockHandler}.
+     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of
+     *                {@link #getHandler(Object)} will return this instance.
+     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.
+     * @return A control for the static mock.
+     * @since 3.4.0
+     */
+    default <T> StaticMockControl<T> createStaticMock(
+            Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
+        throw new MockitoException(
+                join(
+                        "The used MockMaker "
+                                + getClass().getSimpleName()
+                                + " does not support the creation of static mocks",
+                        "",
+                        "Mockito's inline mock maker supports static mocks based on the Instrumentation API.",
+                        "You can simply enable this mock mode, by placing the 'mockito-inline' artifact where you are currently using 'mockito-core'.",
+                        "Note that Mockito's inline mock maker is not supported on Android."));
+    }
+
+    /**
+     * If you want to provide your own implementation of {@code MockMaker} this method should:
+     * <ul>
+     *     <li>Intercept all constructions of the specified type in the current thread</li>
+     *     <li>Only intercept the construction after being enabled.</li>
+     *     <li>Stops the interception when disabled.</li>
+     * </ul>
+     *
+     * @param settingsFactory Factory for mock creation settings like type to mock, extra interfaces and so on.
+     * @param handlerFactory Factory for settings. See {@link org.mockito.invocation.MockHandler}.
+     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of
+     *                {@link #getHandler(Object)} will return this instance.
+     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.
+     * @return A control for the mocked construction.
+     * @since 3.5.0
+     */
+    default <T> ConstructionMockControl<T> createConstructionMock(
+            Class<T> type,
+            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+            Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+            MockedConstruction.MockInitializer<T> mockInitializer) {
+        throw new MockitoException(
+                join(
+                        "The used MockMaker "
+                                + getClass().getSimpleName()
+                                + " does not support the creation of construction mocks",
+                        "",
+                        "Mockito's inline mock maker supports construction mocks based on the Instrumentation API.",
+                        "You can simply enable this mock mode, by placing the 'mockito-inline' artifact where you are currently using 'mockito-core'.",
+                        "Note that Mockito's inline mock maker is not supported on Android."));
+    }
+
+    /**
+     * Clears all cashes for mocked types and removes all byte code alterations, if possible.
+     */
+    default void clearAllCaches() {}
+
     /**
      * Carries the mockability information
      *
      * @since 2.1.0
      */
-    @Incubating
     interface TypeMockability {
         /**
          * informs if type is mockable
@@ -132,4 +215,24 @@ public interface MockMaker {
          */
         String nonMockableReason();
     }
+
+    interface StaticMockControl<T> {
+
+        Class<T> getType();
+
+        void enable();
+
+        void disable();
+    }
+
+    interface ConstructionMockControl<T> {
+
+        Class<T> getType();
+
+        void enable();
+
+        void disable();
+
+        List<T> getMocks();
+    }
 }
diff --git a/src/main/java/org/mockito/plugins/MockResolver.java b/src/main/java/org/mockito/plugins/MockResolver.java
new file mode 100644
index 0000000..6eaa756
--- /dev/null
+++ b/src/main/java/org/mockito/plugins/MockResolver.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.plugins;
+
+/**
+ * A mock resolver offers an opportunity to resolve a mock from any instance that is
+ * provided to the {@link org.mockito.Mockito}-DSL. This mechanism can be used by
+ * frameworks that provide mocks that are implemented by Mockito but which are wrapped
+ * by other instances to enhance the proxy further.
+ */
+public interface MockResolver {
+
+    /**
+     * Returns the provided instance or the unwrapped mock that the provided
+     * instance represents. This method must not return {@code null}.
+     * @param instance The instance passed to the {@link org.mockito.Mockito}-DSL.
+     * @return The provided instance or the unwrapped mock.
+     */
+    Object resolve(Object instance);
+}
diff --git a/src/main/java/org/mockito/plugins/MockitoLogger.java b/src/main/java/org/mockito/plugins/MockitoLogger.java
new file mode 100644
index 0000000..d1f981b
--- /dev/null
+++ b/src/main/java/org/mockito/plugins/MockitoLogger.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.plugins;
+
+/**
+ * Mockito logger.
+ *
+ * <p>By default logs to console</p>
+ *
+ * <p>All mockito logging goes through this class and could be customized as usual Mockito plugin.</p>
+ *
+ * <h3>Using the extension point</h3>
+ *
+ * <p>Suppose you wrote an extension to customize logging, in order to tell Mockito to use it you need to put
+ * in your <strong>classpath</strong>:
+ * <ol style="list-style-type: lower-alpha">
+ *     <li>
+ *         The implementation itself, for example <code>org.awesome.mockito.AwesomeLogger</code> that
+ *         extends the <code>MockitoLogger</code>.
+ *     </li>
+ *     <li>
+ *         A file "<code>mockito-extensions/org.mockito.plugins.MockitoLogger</code>". The content of this file is
+ *         exactly a <strong>one</strong> line with the qualified name:
+ *         <code>org.awesome.mockito.AwesomeLogger</code>.
+ *      </li>
+ * </ol>
+ * </p>
+ *
+ * <p>Note that if several <code>mockito-extensions/org.mockito.plugins.MockitoLogger</code> files exists in the
+ * classpath Mockito will only use the first returned by the standard {@link ClassLoader#getResource} mechanism.
+ *
+ * @since 2.23.19
+ */
+public interface MockitoLogger {
+    /**
+     * Log specified object.
+     *
+     * @param what to be logged
+     */
+    void log(Object what);
+}
diff --git a/src/main/java/org/mockito/plugins/PluginSwitch.java b/src/main/java/org/mockito/plugins/PluginSwitch.java
index 916db24..a5db347 100644
--- a/src/main/java/org/mockito/plugins/PluginSwitch.java
+++ b/src/main/java/org/mockito/plugins/PluginSwitch.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.plugins;
 
-import org.mockito.Incubating;
-
 /**
  * Allows switching off the plugins that are discovered on classpath.
  *
@@ -42,7 +40,6 @@ import org.mockito.Incubating;
  *
  * @since 1.10.15
  */
-@Incubating
 public interface PluginSwitch {
 
     /**
diff --git a/src/main/java/org/mockito/quality/MockitoHint.java b/src/main/java/org/mockito/quality/MockitoHint.java
index f261ac1..cf36a6c 100644
--- a/src/main/java/org/mockito/quality/MockitoHint.java
+++ b/src/main/java/org/mockito/quality/MockitoHint.java
@@ -75,5 +75,4 @@ import org.mockito.junit.MockitoJUnitRunner;
  *
  * @since 2.1.0
  */
-public interface MockitoHint {
-}
+public interface MockitoHint {}
diff --git a/src/main/java/org/mockito/quality/Strictness.java b/src/main/java/org/mockito/quality/Strictness.java
index ea9fed8..b25cab3 100644
--- a/src/main/java/org/mockito/quality/Strictness.java
+++ b/src/main/java/org/mockito/quality/Strictness.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.quality;
 
-import org.mockito.Incubating;
 import org.mockito.MockitoSession;
 import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
@@ -22,7 +21,7 @@ import org.mockito.junit.MockitoRule;
  * <ol>
  *     <li>{@link Strictness#STRICT_STUBS} - ensures clean tests, reduces test code duplication, improves debuggability.
  *       Best combination of flexibility and productivity. Highly recommended.
- *       Planned as default for Mockito v3.
+ *       Planned as default for Mockito v4.
  *       Enable it via {@link MockitoRule}, {@link MockitoJUnitRunner} or {@link MockitoSession}.
  *       See {@link #STRICT_STUBS} for the details.</li>
  *     <li>{@link Strictness#LENIENT} - no added behavior.
@@ -38,7 +37,6 @@ import org.mockito.junit.MockitoRule;
  *
  * @since 2.3.0
  */
-@Incubating
 public enum Strictness {
 
     /**
@@ -49,7 +47,6 @@ public enum Strictness {
      *
      * @since 2.3.0
      */
-    @Incubating
     LENIENT,
 
     /**
@@ -62,14 +59,13 @@ public enum Strictness {
      *
      * @since 2.3.0
      */
-    @Incubating
     WARN,
 
     /**
      * Ensures clean tests, reduces test code duplication, improves debuggability.
      * Offers best combination of flexibility and productivity.
      * Highly recommended.
-     * Planned as default for Mockito v3.
+     * Planned as default for Mockito v4.
      * Enable it via our JUnit support ({@link MockitoJUnit}) or {@link MockitoSession}.
      * <p>
      * Adds following behavior:
@@ -88,6 +84,5 @@ public enum Strictness {
      *
      * @since 2.3.0
      */
-    @Incubating
     STRICT_STUBS;
 }
diff --git a/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java b/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java
deleted file mode 100644
index 522b795..0000000
--- a/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.runners;
-
-import org.junit.runner.Description;
-import org.junit.runner.Runner;
-import org.junit.runner.manipulation.Filter;
-import org.junit.runner.manipulation.Filterable;
-import org.junit.runner.manipulation.NoTestsRemainException;
-import org.junit.runner.notification.Failure;
-import org.junit.runner.notification.RunListener;
-import org.junit.runner.notification.RunNotifier;
-import org.mockito.internal.debugging.WarningsCollector;
-import org.mockito.internal.runners.RunnerFactory;
-import org.mockito.internal.runners.InternalRunner;
-import org.mockito.internal.util.ConsoleMockitoLogger;
-import org.mockito.internal.util.MockitoLogger;
-
-import java.lang.reflect.InvocationTargetException;
-
-/**
- * @deprecated as of 2.1.0. Use the {@link org.mockito.junit.MockitoJUnitRunner} runner instead
- * which contains support for detecting unused stubs.
- * <p>
- * If you still prefer using this runner, tell us why (create ticket in our issue tracker).
- */
-@Deprecated
-public class ConsoleSpammingMockitoJUnitRunner extends Runner implements Filterable {
-
-    private final MockitoLogger logger;
-    private final InternalRunner runner;
-
-    public ConsoleSpammingMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
-        this(new ConsoleMockitoLogger(), new RunnerFactory().create(klass));
-    }
-
-    ConsoleSpammingMockitoJUnitRunner(MockitoLogger logger, InternalRunner runner) {
-        this.runner = runner;
-        this.logger = logger;
-    }
-
-    @Override
-    public void run(RunNotifier notifier) {
-        RunListener listener = new RunListener() {
-            WarningsCollector warningsCollector;
-
-            @Override
-            public void testStarted(Description description) throws Exception {
-                warningsCollector = new WarningsCollector();
-            }
-
-            @Override public void testFailure(Failure failure) throws Exception {
-                logger.log(warningsCollector.getWarnings());
-            }
-        };
-
-        notifier.addListener(listener);
-
-        runner.run(notifier);
-    }
-
-    @Override
-    public Description getDescription() {
-        return runner.getDescription();
-    }
-
-    public void filter(Filter filter) throws NoTestsRemainException {
-        //filter is required because without it UnrootedTests show up in Eclipse
-        runner.filter(filter);
-    }
-}
diff --git a/src/main/java/org/mockito/runners/MockitoJUnitRunner.java b/src/main/java/org/mockito/runners/MockitoJUnitRunner.java
deleted file mode 100644
index 74f025c..0000000
--- a/src/main/java/org/mockito/runners/MockitoJUnitRunner.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.runners;
-
-import java.lang.reflect.InvocationTargetException;
-import org.junit.runner.Description;
-import org.junit.runner.manipulation.Filter;
-import org.junit.runner.manipulation.NoTestsRemainException;
-import org.junit.runner.notification.RunNotifier;
-
-
-/**
- * Runner moved to a new place see {@link org.mockito.junit.MockitoJUnitRunner}
- *
- * @deprecated Moved to {@link org.mockito.junit.MockitoJUnitRunner}, this class will be removed with Mockito 3
- */
-@Deprecated
-public class MockitoJUnitRunner extends org.mockito.junit.MockitoJUnitRunner {
-
-    /**
-     * Silent runner moved to a new place see {@link org.mockito.junit.MockitoJUnitRunner.Silent}
-     *
-     * @deprecated Moved to {@link org.mockito.junit.MockitoJUnitRunner.Silent}, this class will be removed with Mockito 3
-     */
-    @Deprecated
-    public static class Silent extends MockitoJUnitRunner {
-        public Silent(Class<?> klass) throws InvocationTargetException {
-            super(klass);
-        }
-    }
-
-    /**
-     * Silent runner moved to a new place see {@link org.mockito.junit.MockitoJUnitRunner.Strict}
-     *
-     * @deprecated Moved to {@link org.mockito.junit.MockitoJUnitRunner.Strict}, this class will be removed with Mockito 3
-     */
-    @Deprecated
-    public static class Strict extends MockitoJUnitRunner {
-        public Strict(Class<?> klass) throws InvocationTargetException {
-            super(klass);
-        }
-    }
-
-    public MockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
-        super(klass);
-    }
-
-    @Deprecated
-    @Override
-    public void run(final RunNotifier notifier) {
-        super.run(notifier);
-    }
-
-    @Deprecated
-    @Override
-    public Description getDescription() {
-        return super.getDescription();
-    }
-
-    @Deprecated
-    public void filter(Filter filter) throws NoTestsRemainException {
-        super.filter(filter);
-    }
-}
diff --git a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java b/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java
deleted file mode 100644
index b86a891..0000000
--- a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.runners;
-
-import java.lang.reflect.InvocationTargetException;
-import org.junit.runner.Description;
-import org.junit.runner.Runner;
-import org.junit.runner.manipulation.Filter;
-import org.junit.runner.manipulation.Filterable;
-import org.junit.runner.manipulation.NoTestsRemainException;
-import org.junit.runner.notification.Failure;
-import org.junit.runner.notification.RunListener;
-import org.junit.runner.notification.RunNotifier;
-import org.mockito.internal.debugging.WarningsCollector;
-import org.mockito.internal.junit.util.JUnitFailureHacker;
-import org.mockito.internal.runners.RunnerFactory;
-import org.mockito.internal.runners.InternalRunner;
-
-/**
- * @deprecated as of 2.1.0. Use the {@link org.mockito.junit.MockitoJUnitRunner} runner instead
- * which contains support for detecting unused stubs.
- * <p>
- * If you still prefer using this runner, tell us why (create ticket in our issue tracker).
- */
-@Deprecated
-public class VerboseMockitoJUnitRunner extends Runner implements Filterable {
-
-    private final InternalRunner runner;
-
-    public VerboseMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {
-        this(new RunnerFactory().create(klass));
-    }
-
-    VerboseMockitoJUnitRunner(InternalRunner runner) {
-        this.runner = runner;
-    }
-
-    @Override
-    public void run(RunNotifier notifier) {
-
-        //a listener that changes the failure's exception in a very hacky way...
-        RunListener listener = new RunListener() {
-
-            WarningsCollector warningsCollector;
-
-            @Override
-            public void testStarted(Description description) throws Exception {
-                warningsCollector = new WarningsCollector();
-            }
-
-            @Override
-            @SuppressWarnings("deprecation")
-            public void testFailure(final Failure failure) throws Exception {
-                String warnings = warningsCollector.getWarnings();
-                new JUnitFailureHacker().appendWarnings(failure, warnings);
-            }
-        };
-
-        notifier.addFirstListener(listener);
-
-        runner.run(notifier);
-    }
-
-    @Override
-    public Description getDescription() {
-        return runner.getDescription();
-    }
-
-    public void filter(Filter filter) throws NoTestsRemainException {
-        //filter is required because without it UnrootedTests show up in Eclipse
-        runner.filter(filter);
-    }
-}
diff --git a/src/main/java/org/mockito/session/MockitoSessionBuilder.java b/src/main/java/org/mockito/session/MockitoSessionBuilder.java
index b3a758b..6a84205 100644
--- a/src/main/java/org/mockito/session/MockitoSessionBuilder.java
+++ b/src/main/java/org/mockito/session/MockitoSessionBuilder.java
@@ -4,9 +4,9 @@
  */
 package org.mockito.session;
 
-import org.mockito.Incubating;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
+import org.mockito.NotExtensible;
 import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
 import org.mockito.quality.Strictness;
 
@@ -16,7 +16,7 @@ import org.mockito.quality.Strictness;
  *
  * @since 2.7.0
  */
-@Incubating
+@NotExtensible
 public interface MockitoSessionBuilder {
 
     /**
@@ -24,10 +24,10 @@ public interface MockitoSessionBuilder {
      * like {@link org.mockito.Mock}.
      * When this method is invoked it <strong>does not perform</strong> initialization of mocks on the spot!
      * Only when {@link #startMocking()} is invoked then annotated fields will be initialized.
-     * Traditional API to initialize mocks, the {@link MockitoAnnotations#initMocks(Object)} method
+     * Traditional API to initialize mocks, the {@link MockitoAnnotations#openMocks(Object)} method
      * has limited support for driving cleaner tests because it does not support configuring {@link Strictness}.
      * Want cleaner tests and better productivity?
-     * Migrate from {@link MockitoAnnotations#initMocks(Object)}
+     * Migrate from {@link MockitoAnnotations#openMocks(Object)}
      * to {@link MockitoSession}!
      * <p>
      * This method may be called multiple times to add multiple, e.g. nested, test class instances.
@@ -39,7 +39,6 @@ public interface MockitoSessionBuilder {
      * @return the same builder instance for fluent configuration of {@code MockitoSession}.
      * @since 2.7.0
      */
-    @Incubating
     MockitoSessionBuilder initMocks(Object testClassInstance);
 
     /**
@@ -57,7 +56,6 @@ public interface MockitoSessionBuilder {
      * @see #initMocks(Object)
      * @since 2.15.0
      */
-    @Incubating
     MockitoSessionBuilder initMocks(Object... testClassInstances);
 
     /**
@@ -79,7 +77,6 @@ public interface MockitoSessionBuilder {
      * @see org.mockito.quality.MockitoHint
      * @since 2.15.0
      */
-    @Incubating
     MockitoSessionBuilder name(String name);
 
     /**
@@ -93,7 +90,6 @@ public interface MockitoSessionBuilder {
      * @return the same builder instance for fluent configuration of {@code MockitoSession}.
      * @since 2.7.0
      */
-    @Incubating
     MockitoSessionBuilder strictness(Strictness strictness);
 
     /**
@@ -112,7 +108,6 @@ public interface MockitoSessionBuilder {
      * @see org.mockito.quality.MockitoHint
      * @since 2.15.0
      */
-    @Incubating
     MockitoSessionBuilder logger(MockitoSessionLogger logger);
 
     /**
@@ -134,6 +129,5 @@ public interface MockitoSessionBuilder {
      * @throws UnfinishedMockingSessionException
      *  when previous session was not concluded with {@link MockitoSession#finishMocking()}
      */
-    @Incubating
     MockitoSession startMocking() throws UnfinishedMockingSessionException;
 }
diff --git a/src/main/java/org/mockito/session/MockitoSessionLogger.java b/src/main/java/org/mockito/session/MockitoSessionLogger.java
index e5f40ad..7d2e135 100644
--- a/src/main/java/org/mockito/session/MockitoSessionLogger.java
+++ b/src/main/java/org/mockito/session/MockitoSessionLogger.java
@@ -4,8 +4,8 @@
  */
 package org.mockito.session;
 
-import org.mockito.Incubating;
 import org.mockito.MockitoSession;
+import org.mockito.NotExtensible;
 
 /**
  * Logger for {@linkplain org.mockito.quality.MockitoHint hints} emitted when
@@ -16,7 +16,7 @@ import org.mockito.MockitoSession;
  *
  * @since 2.15.0
  */
-@Incubating
+@NotExtensible
 public interface MockitoSessionLogger {
 
     /**
@@ -24,7 +24,5 @@ public interface MockitoSessionLogger {
      *
      * @param hint to log; never {@code null}
      */
-    @Incubating
     void log(String hint);
-
 }
diff --git a/src/main/java/org/mockito/stubbing/Answer1.java b/src/main/java/org/mockito/stubbing/Answer1.java
index afc2a5e..e370dca 100644
--- a/src/main/java/org/mockito/stubbing/Answer1.java
+++ b/src/main/java/org/mockito/stubbing/Answer1.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a single argument invocation.
  *
@@ -31,7 +29,6 @@ import org.mockito.Incubating;
  * @param <A0> type of the single argument
  * @see Answer
  */
-@Incubating
 public interface Answer1<T, A0> {
     /**
      * @param argument0 the single argument.
diff --git a/src/main/java/org/mockito/stubbing/Answer2.java b/src/main/java/org/mockito/stubbing/Answer2.java
index 77944b7..71b5a03 100644
--- a/src/main/java/org/mockito/stubbing/Answer2.java
+++ b/src/main/java/org/mockito/stubbing/Answer2.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a two argument invocation.
  *
@@ -32,7 +30,6 @@ import org.mockito.Incubating;
  * @param <A1> type of the second argument
  * @see Answer
  */
-@Incubating
 public interface Answer2<T, A0, A1> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/Answer3.java b/src/main/java/org/mockito/stubbing/Answer3.java
index e80f06e..1aa4abf 100644
--- a/src/main/java/org/mockito/stubbing/Answer3.java
+++ b/src/main/java/org/mockito/stubbing/Answer3.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a three argument invocation.
  *
@@ -33,7 +31,6 @@ import org.mockito.Incubating;
  * @param <A2> type of the third argument
  * @see Answer
  */
-@Incubating
 public interface Answer3<T, A0, A1, A2> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/Answer4.java b/src/main/java/org/mockito/stubbing/Answer4.java
index f89a201..bfc6c31 100644
--- a/src/main/java/org/mockito/stubbing/Answer4.java
+++ b/src/main/java/org/mockito/stubbing/Answer4.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a four argument invocation.
  *
@@ -34,7 +32,6 @@ import org.mockito.Incubating;
  * @param <A3> type of the fourth argument
  * @see Answer
  */
-@Incubating
 public interface Answer4<T, A0, A1, A2, A3> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/Answer5.java b/src/main/java/org/mockito/stubbing/Answer5.java
index 3e83968..d5e12e1 100644
--- a/src/main/java/org/mockito/stubbing/Answer5.java
+++ b/src/main/java/org/mockito/stubbing/Answer5.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a five argument invocation.
  *
@@ -34,7 +32,6 @@ import org.mockito.Incubating;
  * @param <A3> type of the fourth argument
  * @see Answer
  */
-@Incubating
 public interface Answer5<T, A0, A1, A2, A3, A4> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/Answer6.java b/src/main/java/org/mockito/stubbing/Answer6.java
new file mode 100644
index 0000000..b3248db
--- /dev/null
+++ b/src/main/java/org/mockito/stubbing/Answer6.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2016 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.stubbing;
+
+/**
+ * Generic interface to be used for configuring mock's answer for a six argument invocation.
+ *
+ * Answer specifies an action that is executed and a return value that is returned when you interact with the mock.
+ * <p>
+ * Example of stubbing a mock with this custom answer:
+ *
+ * <pre class="code"><code class="java">
+ * import static org.mockito.AdditionalAnswers.answer;
+ *
+ * when(mock.someMethod(anyInt(), anyString(), anyChar(), any(), any(), anyBoolean())).then(answer(
+ *     new Answer6&lt;StringBuilder, Integer, String, Character, Object, Object, Boolean&gt;() {
+ *         public StringBuilder answer(Integer i, String s, Character c, Object o1, Object o2, Boolean isIt) {
+ *             return new StringBuilder().append(i).append(s).append(c).append(o1.hashCode()).append(o2.hashCode()).append(isIt);
+ *         }
+ * }));
+ *
+ * //Following will print a string like "3xyz131635550true"
+ * System.out.println(mock.someMethod(3, "xy", 'z', new Object(), new Object(), true));
+ * </code></pre>
+ *
+ * @param <T> return type
+ * @param <A0> type of the first argument
+ * @param <A1> type of the second argument
+ * @param <A2> type of the third argument
+ * @param <A3> type of the fourth argument
+ * @param <A4> type of the fifth argument
+ * @param <A5> type of the sixth argument
+ * @see Answer
+ */
+public interface Answer6<T, A0, A1, A2, A3, A4, A5> {
+    /**
+     * @param argument0 the first argument.
+     * @param argument1 the second argument.
+     * @param argument2 the third argument.
+     * @param argument3 the fourth argument.
+     * @param argument4 the fifth argument.
+     * @param argument5 the sixth argument.
+     *
+     * @return the value to be returned.
+     *
+     * @throws Throwable the throwable to be thrown
+     */
+    T answer(A0 argument0, A1 argument1, A2 argument2, A3 argument3, A4 argument4, A5 argument5)
+            throws Throwable;
+}
diff --git a/src/main/java/org/mockito/stubbing/BaseStubber.java b/src/main/java/org/mockito/stubbing/BaseStubber.java
index 8c31928..7ac714d 100644
--- a/src/main/java/org/mockito/stubbing/BaseStubber.java
+++ b/src/main/java/org/mockito/stubbing/BaseStubber.java
@@ -61,9 +61,11 @@ public interface BaseStubber {
      *
      * @since 2.1.0
      */
-    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
-    @SuppressWarnings ({"unchecked", "varargs"})
-    Stubber doThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown);
+    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
+    // creation
+    @SuppressWarnings({"unchecked", "varargs"})
+    Stubber doThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown);
 
     /**
      * Use it for stubbing consecutive calls in {@link Mockito#doAnswer(Answer)} style:
diff --git a/src/main/java/org/mockito/stubbing/OngoingStubbing.java b/src/main/java/org/mockito/stubbing/OngoingStubbing.java
index e2d298b..16c5f39 100644
--- a/src/main/java/org/mockito/stubbing/OngoingStubbing.java
+++ b/src/main/java/org/mockito/stubbing/OngoingStubbing.java
@@ -5,6 +5,7 @@
 package org.mockito.stubbing;
 
 import org.mockito.Mockito;
+import org.mockito.NotExtensible;
 
 /**
  * Simply put: "<b>When</b> the x method is called <b>then</b> return y". E.g:
@@ -31,6 +32,7 @@ import org.mockito.Mockito;
  *
  * See examples in javadoc for {@link Mockito#when}
  */
+@NotExtensible
 public interface OngoingStubbing<T> {
 
     /**
@@ -62,8 +64,9 @@ public interface OngoingStubbing<T> {
      *
      * @return object that allows stubbing consecutive calls
      */
-    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation warnings (on call site)
-    @SuppressWarnings ({"unchecked", "varargs"})
+    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
+    // creation warnings (on call site)
+    @SuppressWarnings({"unchecked", "varargs"})
     OngoingStubbing<T> thenReturn(T value, T... values);
 
     /**
@@ -144,9 +147,11 @@ public interface OngoingStubbing<T> {
      * @return object that allows stubbing consecutive calls
      * @since 2.1.0
      */
-    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation warnings (on call site)
-    @SuppressWarnings ({"unchecked", "varargs"})
-    OngoingStubbing<T> thenThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown);
+    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array
+    // creation warnings (on call site)
+    @SuppressWarnings({"unchecked", "varargs"})
+    OngoingStubbing<T> thenThrow(
+            Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown);
 
     /**
      * Sets the real implementation to be called when the method is called on a mock object.
@@ -159,7 +164,7 @@ public interface OngoingStubbing<T> {
      * <p>
      * However, there are rare cases when partial mocks come handy:
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
+     * However, I wouldn't use partial mocks for new, test-driven and well-designed code.
      * <pre class="code"><code class="java">
      *   // someMethod() must be safe (e.g. doesn't throw, doesn't have dependencies to the object state, etc.)
      *   // if it isn't safe then you will have trouble stubbing it using this api. Use Mockito.doCallRealMethod() instead.
@@ -221,7 +226,7 @@ public interface OngoingStubbing<T> {
      * <p>
      * It allows to create a stub in one line of code.
      * This can be helpful to keep test code clean.
-     * For example, some boring stub can be created & stubbed at field initialization in a test:
+     * For example, some boring stub can be created and stubbed at field initialization in a test:
      * <pre class="code"><code class="java">
      * public class CarTest {
      *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();
@@ -234,5 +239,4 @@ public interface OngoingStubbing<T> {
      * @since 1.9.0
      */
     <M> M getMock();
-
 }
diff --git a/src/main/java/org/mockito/stubbing/Stubber.java b/src/main/java/org/mockito/stubbing/Stubber.java
index 5de954b..6b860db 100644
--- a/src/main/java/org/mockito/stubbing/Stubber.java
+++ b/src/main/java/org/mockito/stubbing/Stubber.java
@@ -4,6 +4,7 @@
  */
 package org.mockito.stubbing;
 
+import org.mockito.CheckReturnValue;
 import org.mockito.Mockito;
 import org.mockito.NotExtensible;
 
@@ -39,6 +40,7 @@ import org.mockito.NotExtensible;
  *
  * See examples in javadoc for {@link Mockito}
  */
+@CheckReturnValue
 @SuppressWarnings("unchecked")
 @NotExtensible
 public interface Stubber extends BaseStubber {
diff --git a/src/main/java/org/mockito/stubbing/Stubbing.java b/src/main/java/org/mockito/stubbing/Stubbing.java
index cba0917..48b5ee4 100644
--- a/src/main/java/org/mockito/stubbing/Stubbing.java
+++ b/src/main/java/org/mockito/stubbing/Stubbing.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
 import org.mockito.MockingDetails;
 import org.mockito.Mockito;
 import org.mockito.NotExtensible;
@@ -60,6 +59,5 @@ public interface Stubbing extends Answer {
      *
      * @since 2.20.0
      */
-    @Incubating
     Strictness getStrictness();
 }
diff --git a/src/main/java/org/mockito/stubbing/ValidableAnswer.java b/src/main/java/org/mockito/stubbing/ValidableAnswer.java
index 382beab..a5dacaa 100644
--- a/src/main/java/org/mockito/stubbing/ValidableAnswer.java
+++ b/src/main/java/org/mockito/stubbing/ValidableAnswer.java
@@ -2,10 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
 import org.mockito.invocation.InvocationOnMock;
 
 /**
@@ -40,7 +38,7 @@ import org.mockito.invocation.InvocationOnMock;
  *
  * <pre class="code"><code class="java">
  * when(mock.someMethod(anyString(), anyInt())).then(doSomethingTricky()); // fail at answer execution time
- * when(mock.incompatibleMethod(anyVararg())).then(doSomethingTricky()); // fail at answer execution time
+ * when(mock.incompatibleMethod(any())).then(doSomethingTricky()); // fail at answer execution time
  * </code></pre>
  * </p>
  *
@@ -49,7 +47,7 @@ import org.mockito.invocation.InvocationOnMock;
  * validable at <em>stub time</em> by implementing this contract.
  *
  * <pre class="code"><code class="java">
- * when(mock.incompatibleMethod(anyVararg())).then(doSomethingTricky()); // fail at answer stub time
+ * when(mock.incompatibleMethod(any())).then(doSomethingTricky()); // fail at answer stub time
  *
  * static Answer doSomethingTricky() {
  *     return new TrickyAnswer();
@@ -69,7 +67,6 @@ import org.mockito.invocation.InvocationOnMock;
  *
  * @since 2.3.8
  */
-@Incubating
 public interface ValidableAnswer {
 
     /**
@@ -89,5 +86,4 @@ public interface ValidableAnswer {
      * @since 2.3.8
      */
     void validateFor(InvocationOnMock invocation);
-
 }
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer1.java b/src/main/java/org/mockito/stubbing/VoidAnswer1.java
index 9f75bf5..df563a9 100644
--- a/src/main/java/org/mockito/stubbing/VoidAnswer1.java
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer1.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a single argument invocation that returns nothing.
  *
@@ -30,7 +28,6 @@ import org.mockito.Incubating;
  * @param <A0> type of the single argument
  * @see Answer
  */
-@Incubating
 public interface VoidAnswer1<A0> {
     /**
      * @param argument0 the single argument.
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer2.java b/src/main/java/org/mockito/stubbing/VoidAnswer2.java
index 8d062f1..a9b6ef4 100644
--- a/src/main/java/org/mockito/stubbing/VoidAnswer2.java
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer2.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a two argument invocation that returns nothing.
  *
@@ -31,7 +29,6 @@ import org.mockito.Incubating;
  * @param <A1> type of the second argument
  * @see Answer
  */
-@Incubating
 public interface VoidAnswer2<A0, A1> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer3.java b/src/main/java/org/mockito/stubbing/VoidAnswer3.java
index b564982..a2c6a07 100644
--- a/src/main/java/org/mockito/stubbing/VoidAnswer3.java
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer3.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a three argument invocation that returns nothing.
  *
@@ -32,7 +30,6 @@ import org.mockito.Incubating;
  * @param <A2> type of the third argument
  * @see Answer
  */
-@Incubating
 public interface VoidAnswer3<A0, A1, A2> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer4.java b/src/main/java/org/mockito/stubbing/VoidAnswer4.java
index c34abee..650bce3 100644
--- a/src/main/java/org/mockito/stubbing/VoidAnswer4.java
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer4.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a four argument invocation that returns nothing.
  *
@@ -23,7 +21,7 @@ import org.mockito.Incubating;
  *         }
  * })).when(mock).someMethod(anyString(), anyInt(), anyString(), anyChar());
  *
- * //Following will raise an exception with the message "ka-boom <3"
+ * //Following will raise an exception with the message "ka-boom &lt;3"
  * mock.someMethod("%s-boom %c%d", 3, "ka", '&lt;');
  * </code></pre>
  *
@@ -33,7 +31,6 @@ import org.mockito.Incubating;
  * @param <A3> type of the fourth argument
  * @see Answer
  */
-@Incubating
 public interface VoidAnswer4<A0, A1, A2, A3> {
     /**
      * @param argument0 the first argument.
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer5.java b/src/main/java/org/mockito/stubbing/VoidAnswer5.java
index 1ac667c..4b4c34b 100644
--- a/src/main/java/org/mockito/stubbing/VoidAnswer5.java
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer5.java
@@ -4,8 +4,6 @@
  */
 package org.mockito.stubbing;
 
-import org.mockito.Incubating;
-
 /**
  * Generic interface to be used for configuring mock's answer for a five argument invocation that returns nothing.
  *
@@ -23,7 +21,7 @@ import org.mockito.Incubating;
  *         }
  * })).when(mock).someMethod(anyString(), anyInt(), anyString(), anyChar(), anyString());
  *
- * //Following will raise an exception with the message "ka-boom <3 mockito"
+ * //Following will raise an exception with the message "ka-boom &lt;3 mockito"
  * mock.someMethod("%s-boom %c%d %s", 3, "ka", '&lt;', "mockito");
  * </code></pre>
  *
@@ -34,7 +32,6 @@ import org.mockito.Incubating;
  * @param <A4> type of the fifth argument
  * @see Answer
  */
-@Incubating
 public interface VoidAnswer5<A0, A1, A2, A3, A4> {
     /**
      * @param argument0 the first argument.
@@ -45,5 +42,6 @@ public interface VoidAnswer5<A0, A1, A2, A3, A4> {
      *
      * @throws Throwable the throwable to be thrown
      */
-    void answer(A0 argument0, A1 argument1, A2 argument2, A3 argument3, A4 argument4) throws Throwable;
+    void answer(A0 argument0, A1 argument1, A2 argument2, A3 argument3, A4 argument4)
+            throws Throwable;
 }
diff --git a/src/main/java/org/mockito/stubbing/VoidAnswer6.java b/src/main/java/org/mockito/stubbing/VoidAnswer6.java
new file mode 100644
index 0000000..bf4dc94
--- /dev/null
+++ b/src/main/java/org/mockito/stubbing/VoidAnswer6.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2016 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.stubbing;
+
+/**
+ * Generic interface to be used for configuring mock's answer for a six argument invocation that returns nothing.
+ *
+ * Answer specifies an action that is executed when you interact with the mock.
+ * <p>
+ * Example of stubbing a mock with this custom answer:
+ *
+ * <pre class="code"><code class="java">
+ * import static org.mockito.AdditionalAnswers.answerVoid;
+ *
+ * doAnswer(answerVoid(
+ *     new VoidAnswer5&lt;String, Integer, String, Character, Object, String&gt;() {
+ *         public void answer(String msg, Integer count, String another, Character c, Object o, String subject) throws Exception {
+ *             throw new Exception(String.format(msg, another, c, o, count, subject));
+ *         }
+ * })).when(mock).someMethod(anyString(), anyInt(), anyString(), anyChar(), any(), anyString());
+ *
+ * // The following will raise an exception with the message "ka-boom &lt;3 mockito"
+ * mock.someMethod("%s-boom %c%d %s", 3, "ka", '&lt;', new Object(), "mockito");
+ * </code></pre>
+ *
+ * @param <A0> type of the first argument
+ * @param <A1> type of the second argument
+ * @param <A2> type of the third argument
+ * @param <A3> type of the fourth argument
+ * @param <A4> type of the fifth argument
+ * @param <A5> type of the sixth argument
+ * @see Answer
+ */
+public interface VoidAnswer6<A0, A1, A2, A3, A4, A5> {
+    /**
+     * @param argument0 the first argument.
+     * @param argument1 the second argument.
+     * @param argument2 the third argument.
+     * @param argument3 the fourth argument.
+     * @param argument4 the fifth argument.
+     * @param argument5 the sixth argument.
+     *
+     * @throws Throwable the throwable to be thrown
+     */
+    void answer(A0 argument0, A1 argument1, A2 argument2, A3 argument3, A4 argument4, A5 argument5)
+            throws Throwable;
+}
diff --git a/src/main/java/org/mockito/verification/After.java b/src/main/java/org/mockito/verification/After.java
index a8eeafa..ed87333 100644
--- a/src/main/java/org/mockito/verification/After.java
+++ b/src/main/java/org/mockito/verification/After.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.verification;
 
-import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.VerificationOverTimeImpl;
 import org.mockito.internal.verification.VerificationWrapper;
 
@@ -14,7 +13,8 @@ import org.mockito.internal.verification.VerificationWrapper;
  * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.
  * See javadoc for {@link VerificationWithTimeout}
  */
-public class After extends VerificationWrapper<VerificationOverTimeImpl> implements VerificationAfterDelay {
+public class After extends VerificationWrapper<VerificationOverTimeImpl>
+        implements VerificationAfterDelay {
 
     /**
      * See the javadoc for {@link VerificationAfterDelay}
@@ -40,7 +40,11 @@ public class After extends VerificationWrapper<VerificationOverTimeImpl> impleme
     }
 
     @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
+    public String toString() {
+        return "Wanted after "
+                + wrappedVerification.getTimer().duration()
+                + " ms: ["
+                + wrappedVerification.getDelegate()
+                + "]";
     }
 }
diff --git a/src/main/java/org/mockito/verification/Timeout.java b/src/main/java/org/mockito/verification/Timeout.java
index c918d0f..405a435 100644
--- a/src/main/java/org/mockito/verification/Timeout.java
+++ b/src/main/java/org/mockito/verification/Timeout.java
@@ -7,7 +7,6 @@ package org.mockito.verification;
 import static org.mockito.internal.exceptions.Reporter.atMostAndNeverShouldNotBeUsedWithTimeout;
 
 import org.mockito.internal.util.Timer;
-import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.VerificationOverTimeImpl;
 import org.mockito.internal.verification.VerificationWrapper;
 
@@ -17,7 +16,8 @@ import org.mockito.internal.verification.VerificationWrapper;
  * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.
  * See javadoc for {@link VerificationWithTimeout}
  */
-public class Timeout extends VerificationWrapper<VerificationOverTimeImpl> implements VerificationWithTimeout {
+public class Timeout extends VerificationWrapper<VerificationOverTimeImpl>
+        implements VerificationWithTimeout {
 
     /**
      * See the javadoc for {@link VerificationWithTimeout}
@@ -48,21 +48,27 @@ public class Timeout extends VerificationWrapper<VerificationOverTimeImpl> imple
     }
 
     @Override
-    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode newVerificationMode) {
+    protected VerificationMode copySelfWithNewVerificationMode(
+            VerificationMode newVerificationMode) {
         return new Timeout(wrappedVerification.copyWithVerificationMode(newVerificationMode));
     }
 
+    @Override
     public VerificationMode atMost(int maxNumberOfInvocations) {
         throw atMostAndNeverShouldNotBeUsedWithTimeout();
     }
 
+    @Override
     public VerificationMode never() {
         throw atMostAndNeverShouldNotBeUsedWithTimeout();
     }
 
     @Override
-    public VerificationMode description(String description) {
-        return VerificationModeFactory.description(this, description);
+    public String toString() {
+        return "Wanted after at most "
+                + wrappedVerification.getTimer().duration()
+                + " ms: ["
+                + wrappedVerification.getDelegate()
+                + "]";
     }
-
 }
diff --git a/src/main/java/org/mockito/verification/VerificationAfterDelay.java b/src/main/java/org/mockito/verification/VerificationAfterDelay.java
index b48cb6b..c99a34d 100644
--- a/src/main/java/org/mockito/verification/VerificationAfterDelay.java
+++ b/src/main/java/org/mockito/verification/VerificationAfterDelay.java
@@ -2,12 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.verification;
 
 import org.mockito.Mockito;
 
-
 /**
  * VerificationAfterDelay is a {@link VerificationMode} that allows combining existing verification modes with an initial delay, e.g.
  * <pre class="code"><code class="java">
@@ -49,6 +47,12 @@ public interface VerificationAfterDelay extends VerificationMode {
      */
     VerificationMode atLeast(int minNumberOfInvocations);
 
+    /**
+     * Verifies that there is  most 1 invocation during the given period. This will wait the full period given,
+     * unless too many invocations occur (in which case there will be an immediate failure)
+     */
+    VerificationMode atMostOnce();
+
     /**
      * Verifies that there is are most N invocations during the given period. This will wait the full period given,
      * unless too many invocations occur (in which case there will be an immediate failure)
@@ -60,5 +64,4 @@ public interface VerificationAfterDelay extends VerificationMode {
      * period given, unless another method is invoked (in which case there will be an immediate failure)
      */
     VerificationMode only();
-
 }
diff --git a/src/main/java/org/mockito/verification/VerificationEvent.java b/src/main/java/org/mockito/verification/VerificationEvent.java
index fad511b..0469bd2 100644
--- a/src/main/java/org/mockito/verification/VerificationEvent.java
+++ b/src/main/java/org/mockito/verification/VerificationEvent.java
@@ -4,13 +4,11 @@
  */
 package org.mockito.verification;
 
-import org.mockito.Incubating;
 import org.mockito.internal.verification.api.VerificationData;
 
 /**
  * Contains all information about a verification that has happened.
  */
-@Incubating
 public interface VerificationEvent {
     /**
      * @return The mock that a verification happened on.
diff --git a/src/main/java/org/mockito/verification/VerificationMode.java b/src/main/java/org/mockito/verification/VerificationMode.java
index 2a04ad5..6ca3804 100644
--- a/src/main/java/org/mockito/verification/VerificationMode.java
+++ b/src/main/java/org/mockito/verification/VerificationMode.java
@@ -2,10 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.verification;
 
 import org.mockito.Mockito;
+import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationData;
 
 /**
@@ -42,5 +42,7 @@ public interface VerificationMode {
      * @return VerificationMode
      * @since 2.1.0
      */
-    VerificationMode description(String description);
+    default VerificationMode description(String description) {
+        return VerificationModeFactory.description(this, description);
+    }
 }
diff --git a/src/main/java/org/mockito/verification/VerificationWithTimeout.java b/src/main/java/org/mockito/verification/VerificationWithTimeout.java
index 0a4f533..ad110d0 100644
--- a/src/main/java/org/mockito/verification/VerificationWithTimeout.java
+++ b/src/main/java/org/mockito/verification/VerificationWithTimeout.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.verification;
 
 import org.mockito.Mockito;
diff --git a/src/test/java/org/concurrentmockito/ThreadVerifiesContinuoslyInteractingMockTest.java b/src/test/java/org/concurrentmockito/ThreadVerifiesContinuouslyInteractingMockTest.java
similarity index 58%
rename from src/test/java/org/concurrentmockito/ThreadVerifiesContinuoslyInteractingMockTest.java
rename to src/test/java/org/concurrentmockito/ThreadVerifiesContinuouslyInteractingMockTest.java
index 0f91bb3..4e2d8b9 100644
--- a/src/test/java/org/concurrentmockito/ThreadVerifiesContinuoslyInteractingMockTest.java
+++ b/src/test/java/org/concurrentmockito/ThreadVerifiesContinuouslyInteractingMockTest.java
@@ -2,25 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.concurrentmockito;
 
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.verify;
-
-//this test exposes the problem most of the time
-public class ThreadVerifiesContinuoslyInteractingMockTest extends TestBase {
+// this test exposes the problem most of the time
+public class ThreadVerifiesContinuouslyInteractingMockTest extends TestBase {
 
     @Mock private IMethods mock;
 
     @Test
     public void shouldAllowVerifyingInThreads() throws Exception {
-        for(int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++) {
             performTest();
         }
     }
@@ -30,17 +29,18 @@ public class ThreadVerifiesContinuoslyInteractingMockTest extends TestBase {
         final Thread[] listeners = new Thread[2];
         for (int i = 0; i < listeners.length; i++) {
             final int x = i;
-            listeners[i] = new Thread() {
-                @Override
-                public void run() {
-                    try {
-                        Thread.sleep(x * 10);
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException(e);
-                    }
-                    mock.simpleMethod();
-                }
-            };
+            listeners[i] =
+                    new Thread() {
+                        @Override
+                        public void run() {
+                            try {
+                                Thread.sleep(x * 10);
+                            } catch (InterruptedException e) {
+                                throw new RuntimeException(e);
+                            }
+                            mock.simpleMethod();
+                        }
+                    };
             listeners[i].start();
         }
 
diff --git a/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java b/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
index e9862b3..3443c79 100644
--- a/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
+++ b/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
@@ -4,6 +4,14 @@
  */
 package org.concurrentmockito;
 
+import static org.junit.Assert.assertEquals;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -52,14 +60,6 @@ import org.mockitousage.stubbing.StubbingWithThrowablesTest;
 import org.mockitousage.verification.*;
 import org.mockitoutil.TestBase;
 
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import static org.junit.Assert.assertEquals;
-
 public class ThreadsRunAllTestsHalfManualTest extends TestBase {
 
     private static class AllTestsRunner extends Thread {
@@ -67,74 +67,74 @@ public class ThreadsRunAllTestsHalfManualTest extends TestBase {
         private Set<Class<?>> failed = new HashSet<Class<?>>();
 
         public void run() {
-            Result result = JUnitCore.runClasses(
-                    EqualsTest.class,
-                    ListUtilTest.class,
-                    MockingProgressImplTest.class,
-                    TimesTest.class,
-                    MockHandlerImplTest.class,
-                    AllInvocationsFinderTest.class,
-                    ReturnsEmptyValuesTest.class,
-                    NumberOfInvocationsCheckerTest.class,
-                    DefaultRegisteredInvocationsTest.class,
-                    MissingInvocationCheckerTest.class,
-                    NumberOfInvocationsInOrderCheckerTest.class,
-                    MissingInvocationInOrderCheckerTest.class,
-                    TypeCachingMockBytecodeGeneratorTest.class,
-                    InvocationMatcherTest.class,
-                    InvocationsFinderTest.class,
-                    MockitoTest.class,
-                    MockUtilTest.class,
-                    ReporterTest.class,
-                    MockitoAssertionErrorTest.class,
-                    MockitoExceptionTest.class,
-                    StackTraceFilteringTest.class,
-                    BridgeMethodPuzzleTest.class,
-                    OverloadingPuzzleTest.class,
-                    InvalidUsageTest.class,
-                    UsingVarargsTest.class,
-                    CustomMatchersTest.class,
-                    ComparableMatchersTest.class,
-                    InvalidUseOfMatchersTest.class,
-                    MatchersTest.class,
-                    MatchersToStringTest.class,
-                    VerificationAndStubbingUsingMatchersTest.class,
-                    BasicStubbingTest.class,
-                    ReturningDefaultValuesTest.class,
-                    StubbingWithThrowablesTest.class,
-                    AtMostXVerificationTest.class,
-                    BasicVerificationTest.class,
-                    ExactNumberOfTimesVerificationTest.class,
-                    VerificationInOrderTest.class,
-                    NoMoreInteractionsVerificationTest.class,
-                    SelectedMocksInOrderVerificationTest.class,
-                    VerificationOnMultipleMocksUsingMatchersTest.class,
-                    VerificationUsingMatchersTest.class,
-                    RelaxedVerificationInOrderTest.class,
-                    DescriptiveMessagesWhenVerificationFailsTest.class,
-                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,
-                    BasicVerificationInOrderTest.class,
-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,
-                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,
-                    InvalidStateDetectionTest.class,
-                    ReplacingObjectMethodsTest.class,
-                    ClickableStackTracesTest.class,
-                    ExampleTest.class,
-                    PointingStackTraceToActualInvocationTest.class,
-                    VerificationInOrderFromMultipleThreadsTest.class,
-                    ResetTest.class,
-                    ReturnsGenericDeepStubsTest.class
-                );
+            Result result =
+                    JUnitCore.runClasses(
+                            EqualsTest.class,
+                            ListUtilTest.class,
+                            MockingProgressImplTest.class,
+                            TimesTest.class,
+                            MockHandlerImplTest.class,
+                            AllInvocationsFinderTest.class,
+                            ReturnsEmptyValuesTest.class,
+                            NumberOfInvocationsCheckerTest.class,
+                            DefaultRegisteredInvocationsTest.class,
+                            MissingInvocationCheckerTest.class,
+                            NumberOfInvocationsInOrderCheckerTest.class,
+                            MissingInvocationInOrderCheckerTest.class,
+                            TypeCachingMockBytecodeGeneratorTest.class,
+                            InvocationMatcherTest.class,
+                            InvocationsFinderTest.class,
+                            MockitoTest.class,
+                            MockUtilTest.class,
+                            ReporterTest.class,
+                            MockitoAssertionErrorTest.class,
+                            MockitoExceptionTest.class,
+                            StackTraceFilteringTest.class,
+                            BridgeMethodPuzzleTest.class,
+                            OverloadingPuzzleTest.class,
+                            InvalidUsageTest.class,
+                            UsingVarargsTest.class,
+                            CustomMatchersTest.class,
+                            ComparableMatchersTest.class,
+                            InvalidUseOfMatchersTest.class,
+                            MatchersTest.class,
+                            MatchersToStringTest.class,
+                            VerificationAndStubbingUsingMatchersTest.class,
+                            BasicStubbingTest.class,
+                            ReturningDefaultValuesTest.class,
+                            StubbingWithThrowablesTest.class,
+                            AtMostXVerificationTest.class,
+                            BasicVerificationTest.class,
+                            ExactNumberOfTimesVerificationTest.class,
+                            VerificationInOrderTest.class,
+                            NoMoreInteractionsVerificationTest.class,
+                            SelectedMocksInOrderVerificationTest.class,
+                            VerificationOnMultipleMocksUsingMatchersTest.class,
+                            VerificationUsingMatchersTest.class,
+                            RelaxedVerificationInOrderTest.class,
+                            DescriptiveMessagesWhenVerificationFailsTest.class,
+                            DescriptiveMessagesWhenTimesXVerificationFailsTest.class,
+                            BasicVerificationInOrderTest.class,
+                            VerificationInOrderMixedWithOrdinaryVerificationTest.class,
+                            DescriptiveMessagesOnVerificationInOrderErrorsTest.class,
+                            InvalidStateDetectionTest.class,
+                            ReplacingObjectMethodsTest.class,
+                            ClickableStackTracesTest.class,
+                            ExampleTest.class,
+                            PointingStackTraceToActualInvocationTest.class,
+                            VerificationInOrderFromMultipleThreadsTest.class,
+                            ResetTest.class,
+                            ReturnsGenericDeepStubsTest.class);
 
-                if (!result.wasSuccessful()) {
-                    System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");
-                    List<Failure> failures = result.getFailures();
-                    System.err.println(failures.size());
-                    for (Failure failure : failures) {
-                        System.err.println(failure.getTrace());
-                        failed.add(failure.getDescription().getTestClass());
-                    }
+            if (!result.wasSuccessful()) {
+                System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");
+                List<Failure> failures = result.getFailures();
+                System.err.println(failures.size());
+                for (Failure failure : failures) {
+                    System.err.println(failure.getTrace());
+                    failed.add(failure.getDescription().getTestClass());
                 }
+            }
         }
 
         public Set<Class<?>> getFailed() {
@@ -144,8 +144,11 @@ public class ThreadsRunAllTestsHalfManualTest extends TestBase {
 
     @Test
     public void shouldRunInMultipleThreads() throws Exception {
-        //this test ALWAYS fails if there is a single failing unit
-        assertEquals("Run in multiple thread failed for tests", Collections.emptySet(), runInMultipleThreads(3));
+        // this test ALWAYS fails if there is a single failing unit
+        assertEquals(
+                "Run in multiple thread failed for tests",
+                Collections.emptySet(),
+                runInMultipleThreads(3));
     }
 
     public static Set<Class<?>> runInMultipleThreads(int numberOfThreads) throws Exception {
@@ -172,7 +175,14 @@ public class ThreadsRunAllTestsHalfManualTest extends TestBase {
         long before = System.currentTimeMillis();
         Set<Class<?>> failed = runInMultipleThreads(numberOfThreads);
         long after = System.currentTimeMillis();
-        long executionTime = (after-before)/1000;
-        System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds. (" + failed.size() + " tests failed)");
+        long executionTime = (after - before) / 1000;
+        System.out.println(
+                "Finished tests in "
+                        + numberOfThreads
+                        + " threads in "
+                        + executionTime
+                        + " seconds. ("
+                        + failed.size()
+                        + " tests failed)");
     }
 }
diff --git a/src/test/java/org/concurrentmockito/ThreadsShareAMockTest.java b/src/test/java/org/concurrentmockito/ThreadsShareAMockTest.java
index 8854789..d27276a 100644
--- a/src/test/java/org/concurrentmockito/ThreadsShareAMockTest.java
+++ b/src/test/java/org/concurrentmockito/ThreadsShareAMockTest.java
@@ -2,22 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.concurrentmockito;
 
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
 public class ThreadsShareAMockTest extends TestBase {
 
     private IMethods mock;
 
     @Test
     public void shouldAllowVerifyingInThreads() throws Exception {
-        for(int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++) {
             performTest();
         }
     }
@@ -26,12 +25,13 @@ public class ThreadsShareAMockTest extends TestBase {
         mock = mock(IMethods.class);
         final Thread[] listeners = new Thread[3];
         for (int i = 0; i < listeners.length; i++) {
-            listeners[i] = new Thread() {
-                @Override
-                public void run() {
-                    mock.simpleMethod("foo");
-                }
-            };
+            listeners[i] =
+                    new Thread() {
+                        @Override
+                        public void run() {
+                            mock.simpleMethod("foo");
+                        }
+                    };
             listeners[i].start();
         }
         for (Thread listener : listeners) {
diff --git a/src/test/java/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java b/src/test/java/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java
index 502e205..f937674 100644
--- a/src/test/java/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java
+++ b/src/test/java/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java
@@ -2,25 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.concurrentmockito;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-//this test always passes but please keep looking sys err
-//this test should be run 10 times, manually
+// this test always passes but please keep looking sys err
+// this test should be run 10 times, manually
 public class ThreadsShareGenerouslyStubbedMockTest extends TestBase {
 
     private IMethods mock;
 
     @Test
     public void shouldAllowVerifyingInThreads() throws Exception {
-        for(int i = 0; i < 50; i++) {
+        for (int i = 0; i < 50; i++) {
             performTest();
         }
     }
@@ -29,30 +28,31 @@ public class ThreadsShareGenerouslyStubbedMockTest extends TestBase {
         mock = mock(IMethods.class);
 
         when(mock.simpleMethod("foo"))
-            .thenReturn("foo")
-            .thenReturn("bar")
-            .thenReturn("baz")
-            .thenReturn("foo")
-            .thenReturn("bar")
-            .thenReturn("baz");
+                .thenReturn("foo")
+                .thenReturn("bar")
+                .thenReturn("baz")
+                .thenReturn("foo")
+                .thenReturn("bar")
+                .thenReturn("baz");
 
         final Thread[] listeners = new Thread[100];
         for (int i = 0; i < listeners.length; i++) {
-            listeners[i] = new Thread() {
-                @Override
-                public void run() {
-                    try {
-                        mock.simpleMethod("foo");
-                        mock.simpleMethod("foo");
-                        mock.simpleMethod("foo");
-                        mock.simpleMethod("foo");
-                        mock.simpleMethod("foo");
-                        mock.simpleMethod("foo");
-                    } catch (Exception e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            };
+            listeners[i] =
+                    new Thread() {
+                        @Override
+                        public void run() {
+                            try {
+                                mock.simpleMethod("foo");
+                                mock.simpleMethod("foo");
+                                mock.simpleMethod("foo");
+                                mock.simpleMethod("foo");
+                                mock.simpleMethod("foo");
+                                mock.simpleMethod("foo");
+                            } catch (Exception e) {
+                                throw new RuntimeException(e);
+                            }
+                        }
+                    };
             listeners[i].start();
         }
         for (Thread listener : listeners) {
diff --git a/src/test/java/org/concurrentmockito/VerificationInOrderFromMultipleThreadsTest.java b/src/test/java/org/concurrentmockito/VerificationInOrderFromMultipleThreadsTest.java
index 055da2d..8f2c5e8 100644
--- a/src/test/java/org/concurrentmockito/VerificationInOrderFromMultipleThreadsTest.java
+++ b/src/test/java/org/concurrentmockito/VerificationInOrderFromMultipleThreadsTest.java
@@ -2,35 +2,38 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.concurrentmockito;
 
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-
 public class VerificationInOrderFromMultipleThreadsTest extends TestBase {
 
     @Test
     public void shouldVerifyInOrderWhenMultipleThreadsInteractWithMock() throws Exception {
         final Foo testInf = mock(Foo.class);
 
-        Thread threadOne = new Thread(new Runnable(){
-            public void run() {
-                testInf.methodOne();
-            }
-        });
+        Thread threadOne =
+                new Thread(
+                        new Runnable() {
+                            public void run() {
+                                testInf.methodOne();
+                            }
+                        });
         threadOne.start();
         threadOne.join();
 
-        Thread threadTwo = new Thread(new Runnable(){
-            public void run() {
-                testInf.methodTwo();
-            }
-        });
+        Thread threadTwo =
+                new Thread(
+                        new Runnable() {
+                            public void run() {
+                                testInf.methodTwo();
+                            }
+                        });
         threadTwo.start();
         threadTwo.join();
 
@@ -41,6 +44,7 @@ public class VerificationInOrderFromMultipleThreadsTest extends TestBase {
 
     public interface Foo {
         void methodOne();
+
         void methodTwo();
     }
 }
diff --git a/src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java b/src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java
index 1d9dfbb..6a017d5 100644
--- a/src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java
+++ b/src/test/java/org/mockito/AnnotationsAreCopiedFromMockedTypeTest.java
@@ -4,8 +4,10 @@
  */
 package org.mockito;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import static java.lang.annotation.ElementType.*;
+
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
 
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
@@ -15,18 +17,21 @@ import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 
-import static java.lang.annotation.ElementType.*;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.mock;
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
 
 public class AnnotationsAreCopiedFromMockedTypeTest {
 
     @Test
     public void mock_should_have_annotations_copied_from_mocked_type_at_class_level() {
-        AnnotationWithDefaultValue onClassDefaultValue = mock(OnClass.class).getClass().getAnnotation(AnnotationWithDefaultValue.class);
-        AnnotationWithCustomValue onClassCustomValue = mock(OnClass.class).getClass().getAnnotation(AnnotationWithCustomValue.class);
+        AnnotationWithDefaultValue onClassDefaultValue =
+                mock(OnClass.class).getClass().getAnnotation(AnnotationWithDefaultValue.class);
+        AnnotationWithCustomValue onClassCustomValue =
+                mock(OnClass.class).getClass().getAnnotation(AnnotationWithCustomValue.class);
 
-        assumeTrue("Annotation copying does not apply for inline mocks", mock(OnClass.class).getClass() != OnClass.class);
+        assumeTrue(
+                "Annotation copying does not apply for inline mocks",
+                mock(OnClass.class).getClass() != OnClass.class);
 
         Assertions.assertThat(onClassDefaultValue.value()).isEqualTo("yup");
         Assertions.assertThat(onClassCustomValue.value()).isEqualTo("yay");
@@ -34,8 +39,12 @@ public class AnnotationsAreCopiedFromMockedTypeTest {
 
     @Test
     public void mock_should_have_annotations_copied_from_mocked_type_on_methods() {
-        AnnotationWithDefaultValue onClassDefaultValue = method("method", mock(OnMethod.class)).getAnnotation(AnnotationWithDefaultValue.class);
-        AnnotationWithCustomValue onClassCustomValue = method("method", mock(OnMethod.class)).getAnnotation(AnnotationWithCustomValue.class);
+        AnnotationWithDefaultValue onClassDefaultValue =
+                method("method", mock(OnMethod.class))
+                        .getAnnotation(AnnotationWithDefaultValue.class);
+        AnnotationWithCustomValue onClassCustomValue =
+                method("method", mock(OnMethod.class))
+                        .getAnnotation(AnnotationWithCustomValue.class);
 
         Assertions.assertThat(onClassDefaultValue.value()).isEqualTo("yup");
         Assertions.assertThat(onClassCustomValue.value()).isEqualTo("yay");
@@ -43,8 +52,12 @@ public class AnnotationsAreCopiedFromMockedTypeTest {
 
     @Test
     public void mock_should_have_annotations_copied_from_mocked_type_on_method_parameters() {
-        AnnotationWithDefaultValue onClassDefaultValue = firstParamOf(method("method", mock(OnMethod.class))).getAnnotation(AnnotationWithDefaultValue.class);
-        AnnotationWithCustomValue onClassCustomValue = firstParamOf(method("method", mock(OnMethod.class))).getAnnotation(AnnotationWithCustomValue.class);
+        AnnotationWithDefaultValue onClassDefaultValue =
+                firstParamOf(method("method", mock(OnMethod.class)))
+                        .getAnnotation(AnnotationWithDefaultValue.class);
+        AnnotationWithCustomValue onClassCustomValue =
+                firstParamOf(method("method", mock(OnMethod.class)))
+                        .getAnnotation(AnnotationWithCustomValue.class);
 
         Assertions.assertThat(onClassDefaultValue.value()).isEqualTo("yup");
         Assertions.assertThat(onClassCustomValue.value()).isEqualTo("yay");
@@ -84,7 +97,7 @@ public class AnnotationsAreCopiedFromMockedTypeTest {
 
     private Method method(String methodName, Object mock) {
         for (Method method : mock.getClass().getDeclaredMethods()) {
-            if(methodName.equals(method.getName())) {
+            if (methodName.equals(method.getName())) {
                 return method;
             }
         }
@@ -93,7 +106,7 @@ public class AnnotationsAreCopiedFromMockedTypeTest {
 
     private Field field(String fieldName, Object mock) {
         for (Field field : mock.getClass().getDeclaredFields()) {
-            if(fieldName.equals(field.getName())) {
+            if (fieldName.equals(field.getName())) {
                 return field;
             }
         }
@@ -102,17 +115,15 @@ public class AnnotationsAreCopiedFromMockedTypeTest {
 
     @AnnotationWithDefaultValue
     @AnnotationWithCustomValue("yay")
-    public class OnClass { }
-
+    public class OnClass {}
 
     public class OnMethod {
         @AnnotationWithDefaultValue
         @AnnotationWithCustomValue("yay")
         public String method(
-                @AnnotationWithDefaultValue
-                @AnnotationWithCustomValue("yay")
-                String ignored
-        ) { return ""; }
+                @AnnotationWithDefaultValue @AnnotationWithCustomValue("yay") String ignored) {
+            return "";
+        }
     }
 
     @Retention(RetentionPolicy.RUNTIME)
diff --git a/src/test/java/org/mockito/ArgumentCaptorTest.java b/src/test/java/org/mockito/ArgumentCaptorTest.java
index 0ab5ff7..13b37c8 100644
--- a/src/test/java/org/mockito/ArgumentCaptorTest.java
+++ b/src/test/java/org/mockito/ArgumentCaptorTest.java
@@ -4,33 +4,30 @@
  */
 package org.mockito;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.validateMockitoUsage;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.validateMockitoUsage;
-
 public class ArgumentCaptorTest {
 
-	/**
-	 * Clean up the internal Mockito-Stubbing state
-	 */
-	@After
-	public void tearDown() {
-		try {
-			validateMockitoUsage();
-		} catch (InvalidUseOfMatchersException ignore) {
-		}
-
-	}
-
-	@Test
-	public void tell_handy_return_values_to_return_value_for() throws Exception {
-
-		ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
-		assertThat(captor.capture()).isNull();
-
-	}
-
+    /**
+     * Clean up the internal Mockito-Stubbing state
+     */
+    @After
+    public void tearDown() {
+        try {
+            validateMockitoUsage();
+        } catch (InvalidUseOfMatchersException ignore) {
+        }
+    }
+
+    @Test
+    public void tell_handy_return_values_to_return_value_for() throws Exception {
+
+        ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+        assertThat(captor.capture()).isNull();
+    }
 }
diff --git a/src/test/java/org/mockito/DescriptionTest.java b/src/test/java/org/mockito/DescriptionTest.java
new file mode 100644
index 0000000..3f8306a
--- /dev/null
+++ b/src/test/java/org/mockito/DescriptionTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.description;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoAssertionError;
+
+/**
+ * Tests for https://github.com/mockito/mockito/issues/1712
+ */
+public class DescriptionTest {
+
+    @Test
+    public void verify_method_not_called_should_include_description_in_report() {
+        final String description = "Failed to call doSomethingElse";
+
+        Dependency dependency = spy(Dependency.class);
+        SystemUnderTest systemUnderTest = new SystemUnderTest();
+        systemUnderTest.doNothing(dependency);
+
+        assertThatThrownBy(
+                        () -> {
+                            verify(dependency, description(description)).doSomethingElse(false);
+                        })
+                .isInstanceOf(MockitoAssertionError.class)
+                .hasMessageContaining(description);
+    }
+
+    @Test
+    public void
+            verify_method_called_with_unexpected_argument_should_include_description_in_report() {
+        final String description = "Failed to call doSomethingElse with expected argument";
+
+        Dependency dependency = spy(Dependency.class);
+        SystemUnderTest systemUnderTest = new SystemUnderTest();
+        systemUnderTest.doSomething(dependency);
+
+        assertThatThrownBy(
+                        () -> {
+                            verify(dependency, description(description)).doSomethingElse(false);
+                        })
+                .isInstanceOf(MockitoAssertionError.class)
+                .hasMessageContaining(description);
+    }
+
+    static class SystemUnderTest {
+        @SuppressWarnings("unused")
+        void doNothing(Dependency dependency) {}
+
+        void doSomething(Dependency dependency) {
+            dependency.doSomethingElse(true);
+        }
+    }
+
+    static class Dependency {
+        @SuppressWarnings("unused")
+        void doSomethingElse(boolean value) {}
+    }
+}
diff --git a/src/test/java/org/mockito/InvocationFactoryTest.java b/src/test/java/org/mockito/InvocationFactoryTest.java
index 893f95f..8864e05 100644
--- a/src/test/java/org/mockito/InvocationFactoryTest.java
+++ b/src/test/java/org/mockito/InvocationFactoryTest.java
@@ -2,21 +2,18 @@
  * Copyright (c) 2018 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
-import org.junit.Test;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.InvocationFactory;
-import org.mockitoutil.TestBase;
-
-import java.util.concurrent.Callable;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.withSettings;
 
+import org.junit.Test;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationFactory;
+import org.mockitoutil.TestBase;
+
 public class InvocationFactoryTest extends TestBase {
     static class TestClass {
         public String testMethod() throws Throwable {
@@ -28,15 +25,19 @@ public class InvocationFactoryTest extends TestBase {
 
     @Test
     public void call_method_that_throws_a_throwable() throws Throwable {
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock,
-            withSettings().build(TestClass.class),
-            TestClass.class.getDeclaredMethod("testMethod"),
-            new InvocationFactory.RealMethodBehavior() {
-            @Override
-            public Object call() throws Throwable {
-                throw new Throwable("mocked");
-            }
-        });
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(TestClass.class),
+                                TestClass.class.getDeclaredMethod("testMethod"),
+                                new InvocationFactory.RealMethodBehavior() {
+                                    @Override
+                                    public Object call() throws Throwable {
+                                        throw new Throwable("mocked");
+                                    }
+                                });
 
         try {
             Mockito.mockingDetails(mock).getMockHandler().handle(invocation);
@@ -50,30 +51,19 @@ public class InvocationFactoryTest extends TestBase {
 
     @Test
     public void call_method_that_returns_a_string() throws Throwable {
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock,
-            withSettings().build(TestClass.class),
-            TestClass.class.getDeclaredMethod("testMethod"),
-            new InvocationFactory.RealMethodBehavior() {
-                @Override
-                public Object call() throws Throwable {
-                    return "mocked";
-                }
-            });
-
-        Object ret = Mockito.mockingDetails(mock).getMockHandler().handle(invocation);
-        assertEquals("mocked", ret);
-    }
-
-    @Test
-    public void deprecated_api_still_works() throws Throwable {
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock,
-            withSettings().build(TestClass.class),
-            TestClass.class.getDeclaredMethod("testMethod"),
-            new Callable() {
-                public Object call() throws Exception {
-                    return "mocked";
-                }
-            });
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(TestClass.class),
+                                TestClass.class.getDeclaredMethod("testMethod"),
+                                new InvocationFactory.RealMethodBehavior() {
+                                    @Override
+                                    public Object call() throws Throwable {
+                                        return "mocked";
+                                    }
+                                });
 
         Object ret = Mockito.mockingDetails(mock).getMockHandler().handle(invocation);
         assertEquals("mocked", ret);
diff --git a/src/test/java/org/mockito/MockitoClearTest.java b/src/test/java/org/mockito/MockitoClearTest.java
new file mode 100644
index 0000000..26b7f76
--- /dev/null
+++ b/src/test/java/org/mockito/MockitoClearTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class MockitoClearTest {
+
+    @Test
+    public void can_clear_mock() {
+        Base mock = Mockito.mock(Base.class);
+        assertThat(Mockito.mock(Base.class).getClass()).isEqualTo(mock.getClass());
+
+        Mockito.clearAllCaches();
+
+        assertThat(Mockito.mock(Base.class).getClass()).isNotEqualTo(mock.getClass());
+    }
+
+    abstract static class Base {}
+}
diff --git a/src/test/java/org/mockito/MockitoTest.java b/src/test/java/org/mockito/MockitoTest.java
index ca8c4d4..8455011 100644
--- a/src/test/java/org/mockito/MockitoTest.java
+++ b/src/test/java/org/mockito/MockitoTest.java
@@ -2,16 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.Mockito.times;
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 
 import java.util.List;
+
 import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.NotAMockException;
+import org.mockito.exceptions.misusing.NullInsteadOfMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 
 @SuppressWarnings("unchecked")
@@ -21,45 +24,113 @@ public class MockitoTest {
     public void shouldRemoveStubbableFromProgressAfterStubbing() {
         List mock = Mockito.mock(List.class);
         Mockito.when(mock.add("test")).thenReturn(true);
-        //TODO Consider to move to separate test
+        // TODO Consider to move to separate test
         assertThat(mockingProgress().pullOngoingStubbing()).isNull();
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldValidateMockWhenVerifying() {
-        Mockito.verify("notMock");
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verify("notMock");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContaining(
+                        "Argument passed to verify() is of type String and is not a mock!")
+                .hasMessageContaining("Make sure you place the parenthesis correctly!");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {
-        Mockito.verify("notMock", times(19));
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verify("notMock", times(19));
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContaining(
+                        "Argument passed to verify() is of type String and is not a mock!")
+                .hasMessageContaining("Make sure you place the parenthesis correctly!");
     }
 
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldValidateMockWhenVerifyingNoMoreInteractions() {
-        Mockito.verifyNoMoreInteractions("notMock");
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verifyNoMoreInteractions("notMock");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContaining("Argument(s) passed is not a mock!");
     }
 
-    @Test(expected=NotAMockException.class)
-    public void shouldValidateMockWhenVerifyingZeroInteractions() {
-        Mockito.verifyZeroInteractions("notMock");
+    @Test
+    public void shouldValidateMockWhenVerifyingNoInteractions() {
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verifyNoInteractions("notMock");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContaining("Argument(s) passed is not a mock!");
+    }
+
+    @Test
+    public void shouldValidateNullMockWhenVerifyingNoInteractions() {
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verifyNoInteractions(new Object[] {null});
+                        })
+                .isInstanceOf(NullInsteadOfMockException.class)
+                .hasMessageContaining("Argument(s) passed is null!");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldValidateMockWhenCreatingInOrderObject() {
-        Mockito.inOrder("notMock");
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.inOrder("notMock");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContaining("Argument(s) passed is not a mock!");
+    }
+
+    @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
+    @Test
+    public void shouldGiveExplanationOnStaticMockingWithoutInlineMockMaker() {
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.mockStatic(Object.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "The used MockMaker SubclassByteBuddyMockMaker does not support the creation of static mocks",
+                        "Mockito's inline mock maker supports static mocks based on the Instrumentation API.",
+                        "You can simply enable this mock mode, by placing the 'mockito-inline' artifact where you are currently using 'mockito-core'.",
+                        "Note that Mockito's inline mock maker is not supported on Android.");
+    }
+
+    @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
+    @Test
+    public void shouldGiveExplanationOnConstructionMockingWithoutInlineMockMaker() {
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.mockConstruction(Object.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "The used MockMaker SubclassByteBuddyMockMaker does not support the creation of construction mocks",
+                        "Mockito's inline mock maker supports construction mocks based on the Instrumentation API.",
+                        "You can simply enable this mock mode, by placing the 'mockito-inline' artifact where you are currently using 'mockito-core'.",
+                        "Note that Mockito's inline mock maker is not supported on Android.");
     }
 
     @Test
     public void shouldStartingMockSettingsContainDefaultBehavior() {
-        //when
+        // given
         MockSettingsImpl<?> settings = (MockSettingsImpl<?>) Mockito.withSettings();
 
-        //then
-        assertThat(Mockito.RETURNS_DEFAULTS).isEqualTo(settings.getDefaultAnswer());
+        // when / then
+        assertThat(settings.getDefaultAnswer()).isEqualTo(Mockito.RETURNS_DEFAULTS);
     }
-
 }
diff --git a/src/test/java/org/mockito/PrematureGarbageCollectionTest.java b/src/test/java/org/mockito/PrematureGarbageCollectionTest.java
new file mode 100644
index 0000000..ed5b534
--- /dev/null
+++ b/src/test/java/org/mockito/PrematureGarbageCollectionTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+@Ignore("https://github.com/mockito/mockito/issues/2478")
+public class PrematureGarbageCollectionTest {
+
+    @Test
+    public void provoke_premature_garbage_collection() {
+        for (int i = 0; i < 500; i++) {
+            populateNodeList();
+        }
+    }
+
+    private static void populateNodeList() {
+        Node node = nodes();
+        while (node != null) {
+            Node next = node.next;
+            node.object.run();
+            node = next;
+        }
+    }
+
+    private static Node nodes() {
+        Node node = null;
+        for (int i = 0; i < 1_000; ++i) {
+            Node next = new Node();
+            next.next = node;
+            node = next;
+        }
+        return node;
+    }
+
+    private static class Node {
+
+        private Node next;
+
+        private final Runnable object = Mockito.mock(Runnable.class);
+    }
+}
diff --git a/src/test/java/org/mockito/StateMaster.java b/src/test/java/org/mockito/StateMaster.java
index c0100e7..e58edc2 100644
--- a/src/test/java/org/mockito/StateMaster.java
+++ b/src/test/java/org/mockito/StateMaster.java
@@ -2,13 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito;
 
-import org.mockito.listeners.MockitoListener;
-
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 
+import org.mockito.listeners.MockitoListener;
+
 public class StateMaster {
 
     public void reset() {
diff --git a/src/test/java/org/mockito/StaticMockingExperimentTest.java b/src/test/java/org/mockito/StaticMockingExperimentTest.java
index cc8a598..361ac13 100644
--- a/src/test/java/org/mockito/StaticMockingExperimentTest.java
+++ b/src/test/java/org/mockito/StaticMockingExperimentTest.java
@@ -4,19 +4,6 @@
  */
 package org.mockito;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.InvocationFactory;
-import org.mockito.invocation.MockHandler;
-import org.mockitoutil.TestBase;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -27,6 +14,19 @@ import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationFactory;
+import org.mockito.invocation.MockHandler;
+import org.mockitoutil.TestBase;
+
 /**
  * This test is an experimental use of Mockito API to simulate static mocking.
  * Other frameworks can use it to build good support for static mocking.
@@ -43,119 +43,197 @@ public class StaticMockingExperimentTest extends TestBase {
     Foo mock = Mockito.mock(Foo.class);
     MockHandler handler = Mockito.mockingDetails(mock).getMockHandler();
     Method staticMethod;
-    InvocationFactory.RealMethodBehavior realMethod = new InvocationFactory.RealMethodBehavior() {
-        @Override
-        public Object call() throws Throwable {
-            return null;
-        }
-    };
-
-    @Before public void before() throws Throwable {
+    InvocationFactory.RealMethodBehavior realMethod =
+            new InvocationFactory.RealMethodBehavior() {
+                @Override
+                public Object call() throws Throwable {
+                    return null;
+                }
+            };
+
+    @Before
+    public void before() throws Throwable {
         staticMethod = Foo.class.getDeclaredMethod("staticMethod", String.class);
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void verify_static_method() throws Throwable {
-        //register staticMethod call on mock
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "some arg");
+        // register staticMethod call on mock
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "some arg");
         handler.handle(invocation);
 
-        //verify staticMethod on mock
-        //Mockito cannot capture static methods so we will simulate this scenario in 3 steps:
-        //1. Call standard 'verify' method. Internally, it will add verificationMode to the thread local state.
-        //  Effectively, we indicate to Mockito that right now we are about to verify a method call on this mock.
+        // verify staticMethod on mock
+        // Mockito cannot capture static methods so we will simulate this scenario in 3 steps:
+        // 1. Call standard 'verify' method. Internally, it will add verificationMode to the thread
+        // local state.
+        //  Effectively, we indicate to Mockito that right now we are about to verify a method call
+        // on this mock.
         verify(mock);
-        //2. Create the invocation instance using the new public API
-        //  Mockito cannot capture static methods but we can create an invocation instance of that static invocation
-        Invocation verification = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "some arg");
-        //3. Make Mockito handle the static method invocation
-        //  Mockito will find verification mode in thread local state and will try verify the invocation
+        // 2. Create the invocation instance using the new public API
+        //  Mockito cannot capture static methods but we can create an invocation instance of that
+        // static invocation
+        Invocation verification =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "some arg");
+        // 3. Make Mockito handle the static method invocation
+        //  Mockito will find verification mode in thread local state and will try verify the
+        // invocation
         handler.handle(verification);
 
-        //verify zero times, method with different argument
+        // verify zero times, method with different argument
         verify(mock, times(0));
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "different arg");
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "different arg");
         handler.handle(differentArg);
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void verification_failure_static_method() throws Throwable {
-        //register staticMethod call on mock
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "foo");
+        // register staticMethod call on mock
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "foo");
         handler.handle(invocation);
 
-        //verify staticMethod on mock
+        // verify staticMethod on mock
         verify(mock);
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "different arg");
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "different arg");
 
         try {
             handler.handle(differentArg);
             fail();
-        } catch (ArgumentsAreDifferent e) {}
+        } catch (ArgumentsAreDifferent e) {
+        }
     }
 
     @Test
     public void stubbing_static_method() throws Throwable {
-        //register staticMethod call on mock
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "foo");
+        // register staticMethod call on mock
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "foo");
         handler.handle(invocation);
 
-        //register stubbing
+        // register stubbing
         when(null).thenReturn("hey");
 
-        //validate stubbed return value
+        // validate stubbed return value
         assertEquals("hey", handler.handle(invocation));
         assertEquals("hey", handler.handle(invocation));
 
-        //default null value is returned if invoked with different argument
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "different arg");
+        // default null value is returned if invoked with different argument
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "different arg");
         assertEquals(null, handler.handle(differentArg));
     }
 
     @Test
     public void do_answer_stubbing_static_method() throws Throwable {
-        //register stubbed return value
-        doReturn("hey").when(mock);
-
-        //complete stubbing by triggering an invocation that needs to be stubbed
-        Invocation invocation = Mockito.framework().getInvocationFactory()
-            .createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "foo");
+        // register stubbed return value
+        Object ignored = doReturn("hey").when(mock);
+
+        // complete stubbing by triggering an invocation that needs to be stubbed
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "foo");
         handler.handle(invocation);
 
-        //validate stubbed return value
+        // validate stubbed return value
         assertEquals("hey", handler.handle(invocation));
         assertEquals("hey", handler.handle(invocation));
 
-        //default null value is returned if invoked with different argument
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "different arg");
+        // default null value is returned if invoked with different argument
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "different arg");
         assertEquals(null, handler.handle(differentArg));
     }
 
     @Test
     public void verify_no_more_interactions() throws Throwable {
-        //works for now because there are not interactions
+        // works for now because there are not interactions
         verifyNoMoreInteractions(mock);
 
-        //register staticMethod call on mock
-        Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
-            "foo");
+        // register staticMethod call on mock
+        Invocation invocation =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                staticMethod,
+                                realMethod,
+                                "foo");
         handler.handle(invocation);
 
-        //fails now because we have one static invocation recorded
+        // fails now because we have one static invocation recorded
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -163,19 +241,35 @@ public class StaticMockingExperimentTest extends TestBase {
         Constructor<Foo> ctr = Foo.class.getConstructor(String.class);
         Method adapter = ConstructorMethodAdapter.class.getDeclaredMethods()[0];
 
-        //stub constructor
-        doReturn(new Foo("hey!")).when(mock);
-        Invocation constructor = Mockito.framework().getInvocationFactory().createInvocation(
-            mock, withSettings().build(Foo.class), adapter, realMethod, ctr, "foo");
+        // stub constructor
+        Object ignored = doReturn(new Foo("hey!")).when(mock);
+        Invocation constructor =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                adapter,
+                                realMethod,
+                                ctr,
+                                "foo");
         handler.handle(constructor);
 
-        //test stubbing
+        // test stubbing
         Object result = handler.handle(constructor);
         assertEquals("foo:hey!", result.toString());
 
-        //stubbing miss
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class),
-            adapter, realMethod, ctr, "different arg");
+        // stubbing miss
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                adapter,
+                                realMethod,
+                                ctr,
+                                "different arg");
         Object result2 = handler.handle(differentArg);
         assertEquals(null, result2);
     }
@@ -186,26 +280,40 @@ public class StaticMockingExperimentTest extends TestBase {
         Constructor<Foo> ctr = Foo.class.getConstructor(String.class);
         Method adapter = ConstructorMethodAdapter.class.getDeclaredMethods()[0];
 
-        //invoke constructor
-        Invocation constructor = Mockito.framework().getInvocationFactory().createInvocation(
-            mock, withSettings().build(Foo.class), adapter, realMethod, ctr, "matching arg");
+        // invoke constructor
+        Invocation constructor =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                adapter,
+                                realMethod,
+                                ctr,
+                                "matching arg");
         handler.handle(constructor);
 
-        //verify successfully
+        // verify successfully
         verify(mock);
         handler.handle(constructor);
 
-        //verification failure
+        // verification failure
         verify(mock);
-        Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class),
-            adapter, realMethod, ctr, "different arg");
+        Invocation differentArg =
+                Mockito.framework()
+                        .getInvocationFactory()
+                        .createInvocation(
+                                mock,
+                                withSettings().build(Foo.class),
+                                adapter,
+                                realMethod,
+                                ctr,
+                                "different arg");
         try {
             handler.handle(differentArg);
             fail();
         } catch (WantedButNotInvoked e) {
-            assertThat(e.getMessage())
-                .contains("matching arg")
-                .contains("different arg");
+            assertThat(e.getMessage()).contains("matching arg").contains("different arg");
         }
     }
 
diff --git a/src/test/java/org/mockito/configuration/MockitoConfiguration.java b/src/test/java/org/mockito/configuration/MockitoConfiguration.java
index bc7df84..ab65516 100644
--- a/src/test/java/org/mockito/configuration/MockitoConfiguration.java
+++ b/src/test/java/org/mockito/configuration/MockitoConfiguration.java
@@ -5,34 +5,34 @@
 package org.mockito.configuration;
 
 import org.mockito.stubbing.Answer;
-import org.mockitousage.configuration.CustomizedAnnotationForSmartMockTest;
 
-public class MockitoConfiguration extends DefaultMockitoConfiguration implements IMockitoConfiguration {
+public class MockitoConfiguration extends DefaultMockitoConfiguration
+        implements IMockitoConfiguration {
 
     private Answer<Object> overriddenDefaultAnswer = null;
 
     private boolean cleansStackTrace;
 
-    private AnnotationEngine overriddenEngine;
+    private org.mockito.plugins.AnnotationEngine overriddenEngine;
 
     private boolean enableClassCache = true;
 
-    //for testing purposes, allow to override the configuration
+    // for testing purposes, allow to override the configuration
     public void overrideDefaultAnswer(Answer<Object> defaultAnswer) {
         this.overriddenDefaultAnswer = defaultAnswer;
     }
 
-    //for testing purposes, allow to override the configuration
+    // for testing purposes, allow to override the configuration
     public void overrideCleansStackTrace(boolean cleansStackTrace) {
         this.cleansStackTrace = cleansStackTrace;
     }
 
-    //for testing purposes, allow to override the annotation engine
-    public void overrideAnnotationEngine(AnnotationEngine engine) {
+    // for testing purposes, allow to override the annotation engine
+    public void overrideAnnotationEngine(org.mockito.plugins.AnnotationEngine engine) {
         this.overriddenEngine = engine;
     }
 
-    //for testing purposes, allow to override the annotation engine
+    // for testing purposes, allow to override the annotation engine
     public void overrideEnableClassCache(boolean enableClassCache) {
         this.enableClassCache = enableClassCache;
     }
@@ -46,14 +46,6 @@ public class MockitoConfiguration extends DefaultMockitoConfiguration implements
         }
     }
 
-    @Override
-    public AnnotationEngine getAnnotationEngine() {
-        if (this.overriddenEngine != null) {
-            return this.overriddenEngine;
-        }
-        return new CustomizedAnnotationForSmartMockTest.CustomInjectingAnnotationEngine();
-    }
-
     @Override
     public boolean cleansStackTrace() {
         return cleansStackTrace;
@@ -63,5 +55,4 @@ public class MockitoConfiguration extends DefaultMockitoConfiguration implements
     public boolean enableClassCache() {
         return enableClassCache;
     }
-
 }
diff --git a/src/test/java/org/mockito/exceptions/base/MockitoAssertionErrorTest.java b/src/test/java/org/mockito/exceptions/base/MockitoAssertionErrorTest.java
index 515ed9f..d54e740 100644
--- a/src/test/java/org/mockito/exceptions/base/MockitoAssertionErrorTest.java
+++ b/src/test/java/org/mockito/exceptions/base/MockitoAssertionErrorTest.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class MockitoAssertionErrorTest extends TestBase {
 
     private void throwIt() {
@@ -30,7 +29,8 @@ public class MockitoAssertionErrorTest extends TestBase {
     @Test
     public void should_prepend_message_to_original() {
         MockitoAssertionError original = new MockitoAssertionError("original message");
-        MockitoAssertionError errorWithPrependedMessage = new MockitoAssertionError(original, "new message");
+        MockitoAssertionError errorWithPrependedMessage =
+                new MockitoAssertionError(original, "new message");
         assertEquals("new message\noriginal message", errorWithPrependedMessage.getMessage());
     }
 }
diff --git a/src/test/java/org/mockito/exceptions/base/MockitoExceptionTest.java b/src/test/java/org/mockito/exceptions/base/MockitoExceptionTest.java
index 00d4033..ea9833b 100644
--- a/src/test/java/org/mockito/exceptions/base/MockitoExceptionTest.java
+++ b/src/test/java/org/mockito/exceptions/base/MockitoExceptionTest.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class MockitoExceptionTest extends TestBase {
 
     private void throwIt() {
diff --git a/src/test/java/org/mockito/exceptions/base/MockitoSerializationIssueTest.java b/src/test/java/org/mockito/exceptions/base/MockitoSerializationIssueTest.java
index 47db7b1..edd6af4 100644
--- a/src/test/java/org/mockito/exceptions/base/MockitoSerializationIssueTest.java
+++ b/src/test/java/org/mockito/exceptions/base/MockitoSerializationIssueTest.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
-import org.junit.Test;
-import org.mockito.internal.configuration.ConfigurationAccess;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Arrays;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
+import org.mockito.internal.configuration.ConfigurationAccess;
 
 public class MockitoSerializationIssueTest {
 
@@ -20,11 +19,14 @@ public class MockitoSerializationIssueTest {
         ConfigurationAccess.getConfig().overrideCleansStackTrace(true);
 
         // when
-        MockitoSerializationIssue issue = new MockitoSerializationIssue("msg", new Exception("cause"));
+        MockitoSerializationIssue issue =
+                new MockitoSerializationIssue("msg", new Exception("cause"));
 
         // then
-        assertThat(Arrays.toString(issue.getUnfilteredStackTrace())).contains("MockitoSerializationIssueTest");
-        assertThat(Arrays.toString(issue.getStackTrace())).doesNotContain("MockitoSerializationIssueTest");
+        assertThat(Arrays.toString(issue.getUnfilteredStackTrace()))
+                .contains("MockitoSerializationIssueTest");
+        assertThat(Arrays.toString(issue.getStackTrace()))
+                .doesNotContain("MockitoSerializationIssueTest");
     }
 
     @Test
@@ -33,10 +35,13 @@ public class MockitoSerializationIssueTest {
         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);
 
         // when
-        MockitoSerializationIssue issue = new MockitoSerializationIssue("msg", new Exception("cause"));
+        MockitoSerializationIssue issue =
+                new MockitoSerializationIssue("msg", new Exception("cause"));
 
         // then
-        assertThat(Arrays.toString(issue.getUnfilteredStackTrace())).contains("MockitoSerializationIssueTest");
-        assertThat(Arrays.toString(issue.getStackTrace())).contains("MockitoSerializationIssueTest");
+        assertThat(Arrays.toString(issue.getUnfilteredStackTrace()))
+                .contains("MockitoSerializationIssueTest");
+        assertThat(Arrays.toString(issue.getStackTrace()))
+                .contains("MockitoSerializationIssueTest");
     }
 }
diff --git a/src/test/java/org/mockito/exceptions/base/StackTraceBuilder.java b/src/test/java/org/mockito/exceptions/base/StackTraceBuilder.java
index a0bbced..d7bf186 100644
--- a/src/test/java/org/mockito/exceptions/base/StackTraceBuilder.java
+++ b/src/test/java/org/mockito/exceptions/base/StackTraceBuilder.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
 import java.util.Arrays;
@@ -12,7 +11,7 @@ public class StackTraceBuilder {
 
     private String[] methods;
 
-    public StackTraceBuilder methods(String ... methods) {
+    public StackTraceBuilder methods(String... methods) {
         this.methods = methods;
         return this;
     }
diff --git a/src/test/java/org/mockito/exceptions/base/TraceBuilder.java b/src/test/java/org/mockito/exceptions/base/TraceBuilder.java
index 247ad38..7763913 100644
--- a/src/test/java/org/mockito/exceptions/base/TraceBuilder.java
+++ b/src/test/java/org/mockito/exceptions/base/TraceBuilder.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.exceptions.base;
 
 import java.util.Collections;
@@ -39,12 +38,12 @@ public class TraceBuilder {
         return toTraceList().toArray(new StackTraceElement[0]);
     }
 
-    public TraceBuilder classes(String ... classes) {
+    public TraceBuilder classes(String... classes) {
         this.classes = classes;
         return this;
     }
 
-    public TraceBuilder methods(String ... methods) {
+    public TraceBuilder methods(String... methods) {
         this.methods = methods;
         return this;
     }
diff --git a/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java b/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
index e0f051e..832d6d7 100644
--- a/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
+++ b/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.exceptions.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.junit.Test;
 import org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleaner;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class StackTraceCleanerTest {
 
-    private DefaultStackTraceCleaner cleaner= new DefaultStackTraceCleaner();
+    private DefaultStackTraceCleaner cleaner = new DefaultStackTraceCleaner();
 
     @Test
     public void allow_or_disallow_mockito_mockito_objects_in_stacktrace() throws Exception {
@@ -34,11 +34,15 @@ public class StackTraceCleanerTest {
     }
 
     private void assertAcceptedInStackTrace(String className) {
-        assertThat(cleaner.isIn(stackTraceElementWith(className))).describedAs("Must be accepted in stacktrace %s", className).isTrue();
+        assertThat(cleaner.isIn(stackTraceElementWith(className)))
+                .describedAs("Must be accepted in stacktrace %s", className)
+                .isTrue();
     }
 
     private void assertRejectedInStackTrace(String className) {
-        assertThat(cleaner.isIn(stackTraceElementWith(className))).describedAs("Must be rejected in stacktrace %s", className).isFalse();
+        assertThat(cleaner.isIn(stackTraceElementWith(className)))
+                .describedAs("Must be rejected in stacktrace %s", className)
+                .isFalse();
     }
 
     private StackTraceElement stackTraceElementWith(String className) {
diff --git a/src/test/java/org/mockito/internal/AllInvocationsFinderTest.java b/src/test/java/org/mockito/internal/AllInvocationsFinderTest.java
index 7022672..dac34c0 100644
--- a/src/test/java/org/mockito/internal/AllInvocationsFinderTest.java
+++ b/src/test/java/org/mockito/internal/AllInvocationsFinderTest.java
@@ -2,20 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.stubbing.Stubbing;
-import org.mockito.invocation.Invocation;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import static java.util.Arrays.asList;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
@@ -23,6 +13,16 @@ import static org.mockito.Mockito.when;
 import static org.mockito.internal.invocation.finder.AllInvocationsFinder.find;
 import static org.mockito.internal.invocation.finder.AllInvocationsFinder.findStubbings;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.invocation.Invocation;
+import org.mockito.stubbing.Stubbing;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
 public class AllInvocationsFinderTest extends TestBase {
 
     private IMethods mockTwo;
@@ -36,22 +36,22 @@ public class AllInvocationsFinderTest extends TestBase {
 
     @Test
     public void no_interactions() throws Exception {
-        //expect
+        // expect
         assertTrue(find(asList(mockOne, mockTwo)).isEmpty());
         assertTrue(findStubbings(asList(mockOne, mockTwo)).isEmpty());
     }
 
     @Test
     public void provides_invocations_in_order() throws Exception {
-        //given
+        // given
         mockOne.simpleMethod(100);
         mockTwo.simpleMethod(200);
         mockOne.simpleMethod(300);
 
-        //when
+        // when
         List<Invocation> invocations = find(asList(mockOne, mockTwo));
 
-        //then
+        // then
         assertEquals(3, invocations.size());
         assertArgumentEquals(100, invocations.get(0));
         assertArgumentEquals(200, invocations.get(1));
@@ -60,28 +60,29 @@ public class AllInvocationsFinderTest extends TestBase {
 
     @Test
     public void deduplicates_interactions_from_the_same_mock() throws Exception {
-        //given
+        // given
         mockOne.simpleMethod(100);
 
-        //when
+        // when
         List<Invocation> invocations = find(asList(mockOne, mockOne, mockOne));
 
-        //then
+        // then
         assertEquals(1, invocations.size());
     }
 
     @Test
     public void provides_stubbings_in_order() throws Exception {
-        //given
-        mockOne.simpleMethod(50); //ignored, not a stubbing
+        // given
+        mockOne.simpleMethod(50); // ignored, not a stubbing
         when(mockOne.simpleMethod(100)).thenReturn("100");
         when(mockOne.simpleMethod(200)).thenReturn("200");
         when(mockTwo.simpleMethod(300)).thenReturn("300");
 
-        //when
-        List<Stubbing> stubbings = new ArrayList<Stubbing>(findStubbings(asList(mockOne, mockOne, mockTwo)));
+        // when
+        List<Stubbing> stubbings =
+                new ArrayList<Stubbing>(findStubbings(asList(mockOne, mockOne, mockTwo)));
 
-        //then
+        // then
         assertEquals(3, stubbings.size());
         assertArgumentEquals(100, stubbings.get(0).getInvocation());
         assertArgumentEquals(200, stubbings.get(1).getInvocation());
diff --git a/src/test/java/org/mockito/internal/InOrderImplTest.java b/src/test/java/org/mockito/internal/InOrderImplTest.java
index 9fccd27..5224a4f 100644
--- a/src/test/java/org/mockito/internal/InOrderImplTest.java
+++ b/src/test/java/org/mockito/internal/InOrderImplTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal;
 
+import static java.util.Collections.singletonList;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.internal.invocation.InvocationBuilder;
@@ -11,10 +16,6 @@ import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 @SuppressWarnings("unchecked")
 public class InOrderImplTest extends TestBase {
 
@@ -22,15 +23,15 @@ public class InOrderImplTest extends TestBase {
 
     @Test
     public void shouldMarkVerifiedInOrder() throws Exception {
-        //given
+        // given
         InOrderImpl impl = new InOrderImpl(singletonList(mock));
         Invocation i = new InvocationBuilder().toInvocation();
         assertFalse(impl.isVerified(i));
 
-        //when
+        // when
         impl.markVerified(i);
 
-        //then
+        // then
         assertTrue(impl.isVerified(i));
     }
 }
diff --git a/src/test/java/org/mockito/internal/InvalidStateDetectionTest.java b/src/test/java/org/mockito/internal/InvalidStateDetectionTest.java
index 6baae82..be466a0 100644
--- a/src/test/java/org/mockito/internal/InvalidStateDetectionTest.java
+++ b/src/test/java/org/mockito/internal/InvalidStateDetectionTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -15,10 +18,6 @@ import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 /**
  * invalid state happens if:
  *
@@ -31,12 +30,10 @@ import static org.mockito.Mockito.*;
  *
  *    -on method call on mock
  *    -on verify
- *    -on verifyZeroInteractions
  *    -on verifyNoMoreInteractions
  *    -on verify in order
  *    -on stub
  */
-@SuppressWarnings({"unchecked", "deprecation"})
 public class InvalidStateDetectionTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -62,10 +59,10 @@ public class InvalidStateDetectionTest extends TestBase {
         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);
 
         when(mock.simpleMethod());
-        detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);
+        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);
 
         when(mock.simpleMethod());
-        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);
+        detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
 
         when(mock.simpleMethod());
         detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);
@@ -87,10 +84,10 @@ public class InvalidStateDetectionTest extends TestBase {
         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);
 
         doAnswer(null);
-        detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);
+        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);
 
         doAnswer(null);
-        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);
+        detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
 
         doAnswer(null);
         detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);
@@ -109,10 +106,10 @@ public class InvalidStateDetectionTest extends TestBase {
         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedVerificationException.class);
 
         verify(mock);
-        detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedVerificationException.class);
+        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);
 
         verify(mock);
-        detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);
+        detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedVerificationException.class);
 
         verify(mock);
         detectsAndCleansUp(new OnDoAnswer(), UnfinishedVerificationException.class);
@@ -120,36 +117,38 @@ public class InvalidStateDetectionTest extends TestBase {
 
     @Test
     public void shouldDetectMisplacedArgumentMatcher() {
-        anyObject();
+        Object ignored = any();
         detectsAndCleansUp(new OnVerify(), InvalidUseOfMatchersException.class);
 
-        anyObject();
+        ignored = any();
         detectsAndCleansUp(new OnVerifyInOrder(), InvalidUseOfMatchersException.class);
 
-        anyObject();
-        detectsAndCleansUp(new OnVerifyZeroInteractions(), InvalidUseOfMatchersException.class);
-
-        anyObject();
+        ignored = any();
         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), InvalidUseOfMatchersException.class);
 
-        anyObject();
+        ignored = any();
+        detectsAndCleansUp(new OnVerifyNoInteractions(), InvalidUseOfMatchersException.class);
+
+        ignored = any();
         detectsAndCleansUp(new OnDoAnswer(), InvalidUseOfMatchersException.class);
     }
 
     @Test
     public void shouldCorrectStateAfterDetectingUnfinishedStubbing() {
-        doThrow(new RuntimeException()).when(mock);
+        Object ignored = doThrow(new RuntimeException()).when(mock);
 
         try {
-        	doThrow(new RuntimeException()).when(mock).oneArg(true);
+            doThrow(new RuntimeException()).when(mock).oneArg(true);
             fail();
-        } catch (UnfinishedStubbingException e) {}
+        } catch (UnfinishedStubbingException e) {
+        }
 
         doThrow(new RuntimeException()).when(mock).oneArg(true);
         try {
             mock.oneArg(true);
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
@@ -161,7 +160,8 @@ public class InvalidStateDetectionTest extends TestBase {
         try {
             verify(mock).simpleMethod();
             fail();
-        } catch (UnfinishedVerificationException e) {}
+        } catch (UnfinishedVerificationException e) {
+        }
 
         verify(mock).simpleMethod();
     }
@@ -184,17 +184,17 @@ public class InvalidStateDetectionTest extends TestBase {
         }
     }
 
-    private static class OnVerifyZeroInteractions implements DetectsInvalidState {
+    private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {
         @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
         public void detect(IMethods mock) {
-            verifyZeroInteractions(mock);
+            verifyNoMoreInteractions(mock);
         }
     }
 
-    private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {
+    private static class OnVerifyNoInteractions implements DetectsInvalidState {
         @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
         public void detect(IMethods mock) {
-            verifyNoMoreInteractions(mock);
+            verifyNoInteractions(mock);
         }
     }
 
@@ -239,7 +239,7 @@ public class InvalidStateDetectionTest extends TestBase {
         } catch (Exception e) {
             assertEquals(expected, e.getClass());
         }
-        //Make sure state is cleaned up
+        // Make sure state is cleaned up
         new StateMaster().validate();
     }
 }
diff --git a/src/test/java/org/mockito/internal/configuration/ClassPathLoaderTest.java b/src/test/java/org/mockito/internal/configuration/ClassPathLoaderTest.java
index 5b5c710..faf86d7 100644
--- a/src/test/java/org/mockito/internal/configuration/ClassPathLoaderTest.java
+++ b/src/test/java/org/mockito/internal/configuration/ClassPathLoaderTest.java
@@ -4,23 +4,26 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
 import org.junit.Test;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
 public class ClassPathLoaderTest extends TestBase {
 
     @Test
     public void shouldReadConfigurationClassFromClassPath() {
-        ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>() {
-            public Object answer(InvocationOnMock invocation) {
-                return "foo";
-            }});
+        ConfigurationAccess.getConfig()
+                .overrideDefaultAnswer(
+                        new Answer<Object>() {
+                            public Object answer(InvocationOnMock invocation) {
+                                return "foo";
+                            }
+                        });
 
         IMethods mock = mock(IMethods.class);
         assertEquals("foo", mock.simpleMethod());
diff --git a/src/test/java/org/mockito/internal/configuration/GlobalConfigurationTest.java b/src/test/java/org/mockito/internal/configuration/GlobalConfigurationTest.java
index 5725670..48cf998 100644
--- a/src/test/java/org/mockito/internal/configuration/GlobalConfigurationTest.java
+++ b/src/test/java/org/mockito/internal/configuration/GlobalConfigurationTest.java
@@ -4,44 +4,40 @@
  */
 package org.mockito.internal.configuration;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import net.bytebuddy.ByteBuddy;
 import org.assertj.core.api.Assertions;
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.mockito.configuration.AnnotationEngine;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockitoutil.ClassLoaders;
 import org.objenesis.Objenesis;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class GlobalConfigurationTest {
     @Test
-    public void returns_mockito_configuration_annotation_engine_if_non_default() throws Exception {
-        ConfigurationAccess.getConfig().overrideAnnotationEngine(new CustomAnnotationEngine());
-        assertThat(new GlobalConfiguration().getAnnotationEngine()).isInstanceOf(CustomAnnotationEngine.class);
-        assertThat(new GlobalConfiguration().tryGetPluginAnnotationEngine()).isInstanceOf(CustomAnnotationEngine.class);
-    }
-
-    @Test
-    public void returns_mockito_annotation_engine_of_Plugins_if_no_MockitoConfiguration() throws Throwable {
-        ClassLoader anotherWorld = ClassLoaders.isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, Objenesis.class)
-                .withPrivateCopyOf("org.mockito", "net.bytebuddy", "org.objenesis")
-                .withCodeSourceUrlOf(Assertions.class)
-                .withPrivateCopyOf("org.assertj")
-                .without("org.mockito.configuration.MockitoConfiguration")
-                .build();
+    public void returns_mockito_annotation_engine_of_Plugins_if_no_MockitoConfiguration()
+            throws Throwable {
+        ClassLoader anotherWorld =
+                ClassLoaders.isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, Objenesis.class)
+                        .withPrivateCopyOf("org.mockito", "net.bytebuddy", "org.objenesis")
+                        .withCodeSourceUrlOf(Assertions.class)
+                        .withPrivateCopyOf("org.assertj")
+                        .without("org.mockito.configuration.MockitoConfiguration")
+                        .build();
 
-        ClassLoaders.using(anotherWorld).execute(new Runnable() {
-            @Override
-            public void run() {
-                assertThat(new GlobalConfiguration().getAnnotationEngine()).isInstanceOf(Plugins.getAnnotationEngine().getClass());
-                assertThat(new GlobalConfiguration().tryGetPluginAnnotationEngine()).isInstanceOf(Plugins.getAnnotationEngine().getClass());
-            }
-        });
+        ClassLoaders.using(anotherWorld)
+                .execute(
+                        new Runnable() {
+                            @Override
+                            public void run() {
+                                assertThat(new GlobalConfiguration().tryGetPluginAnnotationEngine())
+                                        .isInstanceOf(Plugins.getAnnotationEngine().getClass());
+                            }
+                        });
     }
 
     @After
@@ -49,7 +45,10 @@ public class GlobalConfigurationTest {
         ConfigurationAccess.getConfig().overrideAnnotationEngine(null);
     }
 
-    private static class CustomAnnotationEngine implements AnnotationEngine {
-        @Override public void process(Class<?> clazz, Object testInstance) { }
+    private static class CustomAnnotationEngine implements org.mockito.plugins.AnnotationEngine {
+        @Override
+        public AutoCloseable process(Class<?> clazz, Object testInstance) {
+            return new NoAction();
+        }
     }
 }
diff --git a/src/test/java/org/mockito/internal/configuration/InjectingAnnotationEngineTest.java b/src/test/java/org/mockito/internal/configuration/InjectingAnnotationEngineTest.java
new file mode 100644
index 0000000..274db3b
--- /dev/null
+++ b/src/test/java/org/mockito/internal/configuration/InjectingAnnotationEngineTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.configuration;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.MockitoJUnitRunner;
+
+class I {}
+
+@RunWith(MockitoJUnitRunner.class)
+public class InjectingAnnotationEngineTest extends I {
+    @InjectMocks Target target;
+    @Mock Foo foo;
+    @Spy Bar bar = new Bar();
+
+    /*
+     If the test case has super classes, the @InjectMocks field has a field that not listed in the constructor argument
+     will fill by setter/property injection .
+
+     https://github.com/mockito/mockito/issues/1631
+    */
+    @Test
+    public void injectMocks() {
+        Assert.assertEquals(foo, target.getFoo());
+        Assert.assertNotNull(target.getBar());
+    }
+
+    public static class Target {
+        private final Foo foo;
+        private Bar bar;
+
+        public Target(Foo foo) {
+            this.foo = foo;
+        }
+
+        public Foo getFoo() {
+            return foo;
+        }
+
+        public Bar getBar() {
+            return bar;
+        }
+    }
+
+    public static class Foo {}
+
+    public static class Bar {}
+}
diff --git a/src/test/java/org/mockito/internal/configuration/MockAnnotationProcessorTest.java b/src/test/java/org/mockito/internal/configuration/MockAnnotationProcessorTest.java
new file mode 100644
index 0000000..b9e9dd0
--- /dev/null
+++ b/src/test/java/org/mockito/internal/configuration/MockAnnotationProcessorTest.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.configuration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.MockedStatic;
+import org.mockito.exceptions.base.MockitoException;
+
+public class MockAnnotationProcessorTest {
+
+    @SuppressWarnings("unused")
+    private MockedStatic<Void> nonGeneric;
+
+    @SuppressWarnings("unused")
+    private MockedStatic<List<?>> generic;
+
+    @SuppressWarnings({"raw", "unused"})
+    private MockedStatic raw;
+
+    @Test
+    public void testNonGeneric() throws Exception {
+        Class<?> type =
+                MockAnnotationProcessor.inferParameterizedType(
+                        MockAnnotationProcessorTest.class
+                                .getDeclaredField("nonGeneric")
+                                .getGenericType(),
+                        "nonGeneric",
+                        "Sample");
+        assertThat(type).isEqualTo(Void.class);
+    }
+
+    @Test
+    public void testGeneric() {
+        assertThatThrownBy(
+                        () -> {
+                            MockAnnotationProcessor.inferParameterizedType(
+                                    MockAnnotationProcessorTest.class
+                                            .getDeclaredField("generic")
+                                            .getGenericType(),
+                                    "generic",
+                                    "Sample");
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "Mockito cannot infer a static mock from a raw type for generic");
+    }
+
+    @Test
+    public void testRaw() {
+        assertThatThrownBy(
+                        () -> {
+                            MockAnnotationProcessor.inferParameterizedType(
+                                    MockAnnotationProcessorTest.class
+                                            .getDeclaredField("raw")
+                                            .getGenericType(),
+                                    "raw",
+                                    "Sample");
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Mockito cannot infer a static mock from a raw type for raw");
+    }
+}
diff --git a/src/test/java/org/mockito/internal/configuration/MockInjectionTest.java b/src/test/java/org/mockito/internal/configuration/MockInjectionTest.java
index 4abb528..75f0b6e 100644
--- a/src/test/java/org/mockito/internal/configuration/MockInjectionTest.java
+++ b/src/test/java/org/mockito/internal/configuration/MockInjectionTest.java
@@ -2,20 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration;
 
-import org.junit.After;
-import org.junit.Test;
-import org.mockito.internal.configuration.injection.MockInjection;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
 
 import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.Observer;
 import java.util.Set;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
+import org.junit.After;
+import org.junit.Test;
+import org.mockito.internal.configuration.injection.MockInjection;
 
 @SuppressWarnings("unchecked")
 public class MockInjectionTest {
@@ -29,51 +29,82 @@ public class MockInjectionTest {
         withoutConstructor = null;
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
     public void should_not_allow_null_on_field() {
-        MockInjection.onField((Field) null, this);
+        assertThatThrownBy(
+                        () -> {
+                            MockInjection.onField((Field) null, this);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("item in fields should not be null");
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
     public void should_not_allow_null_on_fields() {
-        MockInjection.onFields((Set<Field>) null, this);
+        assertThatThrownBy(
+                        () -> {
+                            MockInjection.onFields((Set<Field>) null, this);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("fields should not be null");
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void should_not_allow_null_on_instance_owning_the_field() throws Exception {
-        MockInjection.onField(field("withConstructor"), null);
+    @Test
+    public void should_not_allow_null_on_instance_owning_the_field() {
+        assertThatThrownBy(
+                        () -> {
+                            MockInjection.onField(field("withConstructor"), null);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("fieldOwner should not be null");
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void should_not_allow_null_on_mocks() throws Exception {
-        MockInjection.onField(field("withConstructor"), this).withMocks(null);
+    @Test
+    public void should_not_allow_null_on_mocks() {
+        assertThatThrownBy(
+                        () -> {
+                            MockInjection.onField(field("withConstructor"), this).withMocks(null);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("mocks should not be null");
     }
 
-
     @Test
     public void can_try_constructor_injection() throws Exception {
-        MockInjection.onField(field("withConstructor"), this).withMocks(oneSetMock()).tryConstructorInjection().apply();
+        MockInjection.onField(field("withConstructor"), this)
+                .withMocks(oneSetMock())
+                .tryConstructorInjection()
+                .apply();
 
-        assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);
+        assertThat(withConstructor.initializedWithConstructor).isTrue();
     }
 
     @Test
     public void should_not_fail_if_constructor_injection_is_not_possible() throws Exception {
-        MockInjection.onField(field("withoutConstructor"), this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();
+        MockInjection.onField(field("withoutConstructor"), this)
+                .withMocks(otherKindOfMocks())
+                .tryConstructorInjection()
+                .apply();
 
         assertThat(withoutConstructor).isNull();
     }
 
     @Test
     public void can_try_property_or_setter_injection() throws Exception {
-        MockInjection.onField(field("withoutConstructor"), this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();
+        MockInjection.onField(field("withoutConstructor"), this)
+                .withMocks(oneSetMock())
+                .tryPropertyOrFieldInjection()
+                .apply();
 
         assertThat(withoutConstructor.theSet).isNotNull();
     }
 
     @Test
     public void should_not_fail_if_property_or_field_injection_is_not_possible() throws Exception {
-        MockInjection.onField(field("withoutConstructor"), this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();
+        MockInjection.onField(field("withoutConstructor"), this)
+                .withMocks(otherKindOfMocks())
+                .tryPropertyOrFieldInjection()
+                .apply();
 
         assertThat(withoutConstructor.theSet).isNull();
     }
@@ -90,9 +121,9 @@ public class MockInjectionTest {
         return getClass().getDeclaredField(field);
     }
 
-
     public static class AnObjectWithConstructor {
         public boolean initializedWithConstructor = false;
+
         public AnObjectWithConstructor(Set<String> strings) {
             initializedWithConstructor = true;
         }
diff --git a/src/test/java/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java b/src/test/java/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java
index 335d2e4..4023160 100644
--- a/src/test/java/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java
+++ b/src/test/java/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java
@@ -2,22 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.junit.MockitoJUnitRunner;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 import java.lang.reflect.Field;
 import java.util.HashSet;
 import java.util.Observer;
 import java.util.Set;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
 
 @RunWith(MockitoJUnitRunner.class)
 public class ConstructorInjectionTest {
diff --git a/src/test/java/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java b/src/test/java/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java
index 4f3017d..4b4da06 100644
--- a/src/test/java/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java
+++ b/src/test/java/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java
@@ -2,25 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.configuration.injection;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.*;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
 
 public class SimpleArgumentResolverTest {
 
     @Test
     public void should_return_object_matching_given_types() throws Exception {
         ConstructorInjection.SimpleArgumentResolver resolver =
-                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet<Long>(), new ByteArrayOutputStream(), new HashMap<String, String>()));
+                new ConstructorInjection.SimpleArgumentResolver(
+                        newSetOf(
+                                new HashSet<Long>(),
+                                new ByteArrayOutputStream(),
+                                new HashMap<String, String>()));
 
-        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);
+        Object[] resolvedInstance =
+                resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);
 
         assertEquals(3, resolvedInstance.length);
         assertTrue(resolvedInstance[0] instanceof Set);
@@ -31,9 +35,11 @@ public class SimpleArgumentResolverTest {
     @Test
     public void should_return_null_when_match_is_not_possible_on_given_types() throws Exception {
         ConstructorInjection.SimpleArgumentResolver resolver =
-                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet<Float>(), new ByteArrayOutputStream()));
+                new ConstructorInjection.SimpleArgumentResolver(
+                        newSetOf(new HashSet<Float>(), new ByteArrayOutputStream()));
 
-        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);
+        Object[] resolvedInstance =
+                resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);
 
         assertEquals(3, resolvedInstance.length);
         assertTrue(resolvedInstance[0] instanceof Set);
@@ -44,9 +50,11 @@ public class SimpleArgumentResolverTest {
     @Test
     public void should_return_null_when_types_are_primitives() throws Exception {
         ConstructorInjection.SimpleArgumentResolver resolver =
-                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap<Integer, String>(), new TreeSet<Integer>()));
+                new ConstructorInjection.SimpleArgumentResolver(
+                        newSetOf(new HashMap<Integer, String>(), new TreeSet<Integer>()));
 
-        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, Boolean.class);
+        Object[] resolvedInstance =
+                resolver.resolveTypeInstances(Set.class, Map.class, Boolean.class);
 
         assertEquals(3, resolvedInstance.length);
         assertTrue(resolvedInstance[0] instanceof Set);
@@ -57,6 +65,4 @@ public class SimpleArgumentResolverTest {
     private Set<Object> newSetOf(Object... objects) {
         return new HashSet<Object>(Arrays.asList(objects));
     }
-
-
 }
diff --git a/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java b/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
index 5935eae..44afe0b 100644
--- a/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
+++ b/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
@@ -4,28 +4,37 @@
  */
 package org.mockito.internal.configuration.plugins;
 
+import static org.junit.Assert.*;
+import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.INLINE_ALIAS;
+import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.PROXY_ALIAS;
+
 import org.junit.Test;
 import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;
 import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
-import org.mockito.plugins.InstantiatorProvider;
+import org.mockito.internal.util.ConsoleMockitoLogger;
 import org.mockito.plugins.InstantiatorProvider2;
 import org.mockito.plugins.MockMaker;
+import org.mockito.plugins.MockitoLogger;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.INLINE_ALIAS;
-
 public class DefaultMockitoPluginsTest extends TestBase {
 
     private DefaultMockitoPlugins plugins = new DefaultMockitoPlugins();
 
     @Test
     public void provides_plugins() throws Exception {
-        assertEquals("org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker",
-            plugins.getDefaultPluginClass(INLINE_ALIAS));
+        assertEquals(
+                "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker",
+                plugins.getDefaultPluginClass(INLINE_ALIAS));
         assertEquals(InlineByteBuddyMockMaker.class, plugins.getInlineMockMaker().getClass());
-        assertEquals(ByteBuddyMockMaker.class, plugins.getDefaultPlugin(MockMaker.class).getClass());
-        assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider.class));
+        assertEquals(
+                "org.mockito.internal.creation.proxy.ProxyMockMaker",
+                plugins.getDefaultPluginClass(PROXY_ALIAS));
+        assertEquals(
+                ByteBuddyMockMaker.class, plugins.getDefaultPlugin(MockMaker.class).getClass());
         assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider2.class));
+        assertEquals(
+                ConsoleMockitoLogger.class,
+                plugins.getDefaultPlugin(MockitoLogger.class).getClass());
     }
 }
diff --git a/src/test/java/org/mockito/internal/configuration/plugins/PluginFileReaderTest.java b/src/test/java/org/mockito/internal/configuration/plugins/PluginFileReaderTest.java
index 5892931..e33e302 100644
--- a/src/test/java/org/mockito/internal/configuration/plugins/PluginFileReaderTest.java
+++ b/src/test/java/org/mockito/internal/configuration/plugins/PluginFileReaderTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.configuration.plugins;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class PluginFileReaderTest extends TestBase {
 
@@ -20,12 +20,12 @@ public class PluginFileReaderTest extends TestBase {
 
     @Test
     public void no_class_in_resource() throws IOException {
-        //no class
+        // no class
         assertNull(reader.readPluginClass(impl("")));
         assertNull(reader.readPluginClass(impl("  ")));
         assertNull(reader.readPluginClass(impl(" \n ")));
 
-        //commented out
+        // commented out
         assertNull(reader.readPluginClass(impl("#foo")));
         assertNull(reader.readPluginClass(impl("  # foo  ")));
         assertNull(reader.readPluginClass(impl("  # # # java.langString # ")));
@@ -41,7 +41,8 @@ public class PluginFileReaderTest extends TestBase {
         assertEquals("java.lang.String", reader.readPluginClass(impl("java.lang.String")));
         assertEquals("x", reader.readPluginClass(impl("x")));
         assertEquals("x y z", reader.readPluginClass(impl(" x y z ")));
-        assertEquals("foo.Foo", reader.readPluginClass(impl(" #my class\n  foo.Foo \n #other class ")));
+        assertEquals(
+                "foo.Foo", reader.readPluginClass(impl(" #my class\n  foo.Foo \n #other class ")));
         assertEquals("foo.Foo", reader.readPluginClass(impl("foo.Foo  # cool class")));
     }
 }
diff --git a/src/test/java/org/mockito/internal/configuration/plugins/PluginFinderTest.java b/src/test/java/org/mockito/internal/configuration/plugins/PluginFinderTest.java
index 7af3e5b..4b70446 100644
--- a/src/test/java/org/mockito/internal/configuration/plugins/PluginFinderTest.java
+++ b/src/test/java/org/mockito/internal/configuration/plugins/PluginFinderTest.java
@@ -4,6 +4,17 @@
  */
 package org.mockito.internal.configuration.plugins;
 
+import static java.util.Arrays.asList;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.net.URL;
+import java.util.Collections;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -13,106 +24,115 @@ import org.mockito.internal.util.io.IOUtil;
 import org.mockito.plugins.PluginSwitch;
 import org.mockitoutil.TestBase;
 
-import java.io.File;
-import java.net.URL;
-import java.util.Collections;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.when;
-
 public class PluginFinderTest extends TestBase {
 
-    @Mock
-    PluginSwitch switcher;
+    @Mock PluginSwitch switcher;
     @InjectMocks PluginFinder finder;
     public @Rule TemporaryFolder tmp = new TemporaryFolder();
 
-    @Test public void empty_resources() {
+    @Test
+    public void empty_resources() {
         assertNull(finder.findPluginClass(Collections.<URL>emptyList()));
     }
 
-    @Test public void no_valid_impl() throws Exception {
+    @Test
+    public void no_valid_impl() throws Exception {
         File f = tmp.newFile();
 
-        //when
+        // when
         IOUtil.writeText("  \n  ", f);
 
-        //then
+        // then
         assertNull(finder.findPluginClass(asList(f.toURI().toURL())));
     }
 
-    @Test public void single_implementation() throws Exception {
+    @Test
+    public void single_implementation() throws Exception {
         File f = tmp.newFile();
         when(switcher.isEnabled("foo.Foo")).thenReturn(true);
 
-        //when
+        // when
         IOUtil.writeText("  foo.Foo  ", f);
 
-        //then
+        // then
         assertEquals("foo.Foo", finder.findPluginClass(asList(f.toURI().toURL())));
     }
 
-    @Test public void single_implementation_disabled() throws Exception {
+    @Test
+    public void single_implementation_disabled() throws Exception {
         File f = tmp.newFile();
         when(switcher.isEnabled("foo.Foo")).thenReturn(false);
 
-        //when
+        // when
         IOUtil.writeText("  foo.Foo  ", f);
 
-        //then
+        // then
         assertEquals(null, finder.findPluginClass(asList(f.toURI().toURL())));
     }
 
-    @Test public void multiple_implementations_only_one_enabled() throws Exception {
-        File f1 = tmp.newFile(); File f2 = tmp.newFile();
+    @Test
+    public void multiple_implementations_only_one_enabled() throws Exception {
+        File f1 = tmp.newFile();
+        File f2 = tmp.newFile();
 
         when(switcher.isEnabled("Bar")).thenReturn(true);
 
-        //when
-        IOUtil.writeText("Foo", f1); IOUtil.writeText("Bar", f2);
+        // when
+        IOUtil.writeText("Foo", f1);
+        IOUtil.writeText("Bar", f2);
 
-        //then
+        // then
         assertEquals("Bar", finder.findPluginClass(asList(f1.toURI().toURL(), f2.toURI().toURL())));
     }
 
-    @Test public void multiple_implementations_only_one_useful() throws Exception {
-        File f1 = tmp.newFile(); File f2 = tmp.newFile();
+    @Test
+    public void multiple_implementations_only_one_useful() throws Exception {
+        File f1 = tmp.newFile();
+        File f2 = tmp.newFile();
 
         when(switcher.isEnabled(anyString())).thenReturn(true);
 
-        //when
-        IOUtil.writeText("   ", f1); IOUtil.writeText("X", f2);
+        // when
+        IOUtil.writeText("   ", f1);
+        IOUtil.writeText("X", f2);
 
-        //then
+        // then
         assertEquals("X", finder.findPluginClass(asList(f1.toURI().toURL(), f2.toURI().toURL())));
     }
 
-    @Test public void multiple_empty_implementations() throws Exception {
-        File f1 = tmp.newFile(); File f2 = tmp.newFile();
+    @Test
+    public void multiple_empty_implementations() throws Exception {
+        File f1 = tmp.newFile();
+        File f2 = tmp.newFile();
 
         when(switcher.isEnabled(anyString())).thenReturn(true);
 
-        //when
-        IOUtil.writeText("   ", f1); IOUtil.writeText("\n", f2);
+        // when
+        IOUtil.writeText("   ", f1);
+        IOUtil.writeText("\n", f2);
 
-        //then
+        // then
         assertEquals(null, finder.findPluginClass(asList(f1.toURI().toURL(), f2.toURI().toURL())));
     }
 
-    @Test public void problems_loading_impl() throws Exception {
+    @Test
+    public void problems_loading_impl() throws Exception {
+        String fileName = "xxx";
+        File f = tmp.newFile(fileName);
+
+        // when
+        IOUtil.writeText("Bar", f);
+
         when(switcher.isEnabled(anyString())).thenThrow(new RuntimeException("Boo!"));
 
         try {
-            //when
-            finder.findPluginClass(asList(new File("xxx").toURI().toURL()));
-            //then
+            // when
+            finder.findPluginClass(asList(f.toURI().toURL()));
+            // then
             fail();
-        } catch(Exception e) {
-            assertThat(e).hasMessageContaining("xxx");
-            e.getCause().getMessage().equals("Boo!");
+        } catch (Exception e) {
+            assertThat(e).hasMessageContaining(fileName);
+            assertThat(e.getCause()).hasMessage("Boo!");
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/configuration/plugins/PluginLoaderTest.java b/src/test/java/org/mockito/internal/configuration/plugins/PluginLoaderTest.java
index ab01858..543af68 100644
--- a/src/test/java/org/mockito/internal/configuration/plugins/PluginLoaderTest.java
+++ b/src/test/java/org/mockito/internal/configuration/plugins/PluginLoaderTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal.configuration.plugins;
 
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.mockito.BDDMockito.willReturn;
+import static org.mockito.Mockito.when;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Rule;
@@ -14,11 +19,6 @@ import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.mockito.quality.Strictness;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.mockito.BDDMockito.willReturn;
-import static org.mockito.Mockito.when;
-
 public class PluginLoaderTest {
 
     @Rule public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
@@ -31,10 +31,10 @@ public class PluginLoaderTest {
     public void loads_plugin() {
         when(initializer.loadImpl(FooPlugin.class)).thenReturn(new FooPlugin());
 
-        //when
+        // when
         FooPlugin plugin = loader.loadPlugin(FooPlugin.class);
 
-        //then
+        // then
         assertNotNull(plugin);
     }
 
@@ -44,10 +44,10 @@ public class PluginLoaderTest {
         BarPlugin expected = new BarPlugin();
         willReturn(expected).given(initializer).loadImpl(BarPlugin.class);
 
-        //when
+        // when
         Object plugin = loader.loadPlugin(FooPlugin.class, BarPlugin.class);
 
-        //then
+        // then
         assertSame(plugin, expected);
     }
 
@@ -58,10 +58,10 @@ public class PluginLoaderTest {
         FooPlugin expected = new FooPlugin();
         willReturn(expected).given(plugins).getDefaultPlugin(FooPlugin.class);
 
-        //when
+        // when
         Object plugin = loader.loadPlugin(FooPlugin.class, BarPlugin.class);
 
-        //then
+        // then
         assertSame(plugin, expected);
     }
 
@@ -70,21 +70,26 @@ public class PluginLoaderTest {
         RuntimeException cause = new RuntimeException("Boo!");
         when(initializer.loadImpl(Foo.class)).thenThrow(cause);
 
-        //when
+        // when
         final Foo plugin = loader.loadPlugin(Foo.class);
 
-        //then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                plugin.toString(); //call any method on the plugin
-            }
-        }).isInstanceOf(IllegalStateException.class)
-            .hasMessage("Could not initialize plugin: interface org.mockito.internal.configuration.plugins.PluginLoaderTest$Foo (alternate: null)")
-            .hasCause(cause);
+        // then
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                plugin.toString(); // call any method on the plugin
+                            }
+                        })
+                .isInstanceOf(IllegalStateException.class)
+                .hasMessage(
+                        "Could not initialize plugin: interface org.mockito.internal.configuration.plugins.PluginLoaderTest$Foo (alternate: null)")
+                .hasCause(cause);
     }
 
     static class FooPlugin {}
+
     static class BarPlugin {}
+
     static interface Foo {}
 }
diff --git a/src/test/java/org/mockito/internal/creation/AbstractMockMakerTest.java b/src/test/java/org/mockito/internal/creation/AbstractMockMakerTest.java
new file mode 100644
index 0000000..d594778
--- /dev/null
+++ b/src/test/java/org/mockito/internal/creation/AbstractMockMakerTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation;
+
+import org.junit.Test;
+import org.mockito.internal.handler.MockHandlerImpl;
+import org.mockito.internal.stubbing.answers.CallsRealMethods;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.InvocationContainer;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.mock.SerializableMode;
+import org.mockito.plugins.MockMaker;
+import org.mockito.stubbing.Answer;
+
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public abstract class AbstractMockMakerTest<MM extends MockMaker, C> {
+
+    protected final MM mockMaker;
+
+    private final Class<C> target;
+
+    protected AbstractMockMakerTest(MM mockMaker, Class<C> target) {
+        this.mockMaker = mockMaker;
+        this.target = target;
+    }
+
+    @Test
+    public void should_mocks_have_different_interceptors() throws Exception {
+        C mockOne = mockMaker.createMock(settingsFor(target), dummyHandler());
+        C mockTwo = mockMaker.createMock(settingsFor(target), dummyHandler());
+
+        MockHandler handlerOne = mockMaker.getHandler(mockOne);
+        MockHandler handlerTwo = mockMaker.getHandler(mockTwo);
+
+        assertThat(handlerOne).isNotSameAs(handlerTwo);
+    }
+
+    @Test
+    public void should_reset_mock_and_set_new_handler() throws Throwable {
+        MockCreationSettings<C> settings = settingsWithSuperCall(target);
+        C proxy = mockMaker.createMock(settings, new MockHandlerImpl<C>(settings));
+
+        MockHandler handler = new MockHandlerImpl<C>(settings);
+        mockMaker.resetMock(proxy, handler, settings);
+        assertThat(mockMaker.getHandler(proxy)).isSameAs(handler);
+    }
+
+    protected static <T> MockCreationSettings<T> settingsFor(
+            Class<T> type, Class<?>... extraInterfaces) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.setTypeToMock(type);
+        if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
+        return mockSettings;
+    }
+
+    protected static <T> MockCreationSettings<T> serializableSettingsFor(
+            Class<T> type, SerializableMode serializableMode) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.serializable(serializableMode);
+        mockSettings.setTypeToMock(type);
+        return mockSettings;
+    }
+
+    protected static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.setTypeToMock(type);
+        return mockSettings;
+    }
+
+    protected static <T> MockCreationSettings<T> settingsWithSuperCall(Class<T> type) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.setTypeToMock(type);
+        mockSettings.defaultAnswer(new CallsRealMethods());
+        return mockSettings;
+    }
+
+    protected static MockHandler dummyHandler() {
+        return new DummyMockHandler();
+    }
+
+    private static class DummyMockHandler implements MockHandler<Object> {
+        public Object handle(Invocation invocation) throws Throwable {
+            return null;
+        }
+
+        public MockCreationSettings<Object> getMockSettings() {
+            return null;
+        }
+
+        public InvocationContainer getInvocationContainer() {
+            return null;
+        }
+
+        public void setAnswersForStubbing(List<Answer<?>> list) {}
+    }
+}
diff --git a/src/test/java/org/mockito/internal/creation/DelegatingMethodTest.java b/src/test/java/org/mockito/internal/creation/DelegatingMethodTest.java
index ff46656..e78e96f 100644
--- a/src/test/java/org/mockito/internal/creation/DelegatingMethodTest.java
+++ b/src/test/java/org/mockito/internal/creation/DelegatingMethodTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.creation;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import java.lang.reflect.Method;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class DelegatingMethodTest extends TestBase {
 
diff --git a/src/test/java/org/mockito/internal/creation/InterfaceOverrideTest.java b/src/test/java/org/mockito/internal/creation/InterfaceOverrideTest.java
index e1261fb..8b3e35e 100644
--- a/src/test/java/org/mockito/internal/creation/InterfaceOverrideTest.java
+++ b/src/test/java/org/mockito/internal/creation/InterfaceOverrideTest.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.creation;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockito.Mockito;
 
-import static org.junit.Assert.assertEquals;
-
 public class InterfaceOverrideTest {
 
     public interface CloneableInterface extends Cloneable {
diff --git a/src/test/java/org/mockito/internal/creation/MockSettingsImplTest.java b/src/test/java/org/mockito/internal/creation/MockSettingsImplTest.java
index 18911e4..9e8d68d 100644
--- a/src/test/java/org/mockito/internal/creation/MockSettingsImplTest.java
+++ b/src/test/java/org/mockito/internal/creation/MockSettingsImplTest.java
@@ -4,163 +4,260 @@
  */
 package org.mockito.internal.creation;
 
-import org.assertj.core.api.Assertions;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.debugging.VerboseMockInvocationLogger;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class MockSettingsImplTest extends TestBase {
 
     private MockSettingsImpl<?> mockSettingsImpl = new MockSettingsImpl<Object>();
 
     @Mock private InvocationListener invocationListener;
+    @Mock private StubbingLookupListener stubbingLookupListener;
 
-    @Test(expected=MockitoException.class)
+    @Test
     @SuppressWarnings("unchecked")
     public void shouldNotAllowSettingNullInterface() {
-        mockSettingsImpl.extraInterfaces(List.class, null);
+        assertThatThrownBy(
+                        () -> {
+                            mockSettingsImpl.extraInterfaces(List.class, null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("extraInterfaces() does not accept null parameters.");
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     @SuppressWarnings("unchecked")
     public void shouldNotAllowNonInterfaces() {
-        mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);
+        assertThatThrownBy(
+                        () -> {
+                            mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "extraInterfaces() accepts only interfaces",
+                        "You passed following type: LinkedList which is not an interface.");
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     @SuppressWarnings("unchecked")
     public void shouldNotAllowUsingTheSameInterfaceAsExtra() {
-        mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);
+        assertThatThrownBy(
+                        () -> {
+                            mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "extraInterfaces() accepts only interfaces.",
+                        "You passed following type: LinkedList which is not an interface.");
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     @SuppressWarnings("unchecked")
     public void shouldNotAllowEmptyExtraInterfaces() {
-        mockSettingsImpl.extraInterfaces();
+        assertThatThrownBy(
+                        () -> {
+                            mockSettingsImpl.extraInterfaces();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("extraInterfaces() requires at least one interface.");
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     @SuppressWarnings("unchecked")
     public void shouldNotAllowNullArrayOfExtraInterfaces() {
-        mockSettingsImpl.extraInterfaces((Class<?>[]) null);
+        assertThatThrownBy(
+                        () -> {
+                            mockSettingsImpl.extraInterfaces((Class<?>[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("extraInterfaces() requires at least one interface.");
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void shouldAllowMultipleInterfaces() {
-        //when
+        // when
         mockSettingsImpl.extraInterfaces(List.class, Set.class);
 
-        //then
-        assertEquals(2, mockSettingsImpl.getExtraInterfaces().size());
-        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(List.class));
-        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(Set.class));
+        // then
+        assertThat(mockSettingsImpl.getExtraInterfaces().size()).isEqualTo(2);
+        assertThat(mockSettingsImpl.getExtraInterfaces()).contains(List.class);
+        assertThat(mockSettingsImpl.getExtraInterfaces()).contains(Set.class);
     }
 
     @Test
-    public void shouldSetMockToBeSerializable() throws Exception {
-        //when
+    public void shouldSetMockToBeSerializable() {
+        // when
         mockSettingsImpl.serializable();
 
-        //then
-        assertTrue(mockSettingsImpl.isSerializable());
+        // then
+        assertThat(mockSettingsImpl.isSerializable()).isTrue();
     }
 
     @Test
-    public void shouldKnowIfIsSerializable() throws Exception {
-        //given
-        assertFalse(mockSettingsImpl.isSerializable());
+    public void shouldKnowIfIsSerializable() {
+        // given
+        assertThat(mockSettingsImpl.isSerializable()).isFalse();
 
-        //when
+        // when
         mockSettingsImpl.serializable();
 
-        //then
-        assertTrue(mockSettingsImpl.isSerializable());
+        // then
+        assertThat(mockSettingsImpl.isSerializable()).isTrue();
     }
 
     @Test
     public void shouldAddVerboseLoggingListener() {
-        //given
-        assertFalse(mockSettingsImpl.hasInvocationListeners());
+        // given
+        assertThat(mockSettingsImpl.hasInvocationListeners()).isFalse();
 
-        //when
+        // when
         mockSettingsImpl.verboseLogging();
 
-        //then
-        assertThat(mockSettingsImpl.getInvocationListeners()).extracting("class").contains(VerboseMockInvocationLogger.class);
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners())
+                .extracting("class")
+                .contains(VerboseMockInvocationLogger.class);
     }
 
     @Test
     public void shouldAddVerboseLoggingListenerOnlyOnce() {
-        //given
-        assertFalse(mockSettingsImpl.hasInvocationListeners());
+        // given
+        assertThat(mockSettingsImpl.hasInvocationListeners()).isFalse();
 
-        //when
+        // when
         mockSettingsImpl.verboseLogging().verboseLogging();
 
-        //then
-        Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowNullListener() {
-        mockSettingsImpl.invocationListeners((InvocationListener[])null);
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void shouldAddInvocationListener() {
-        //given
-        assertFalse(mockSettingsImpl.hasInvocationListeners());
+        // given
+        assertThat(mockSettingsImpl.hasInvocationListeners()).isFalse();
 
-        //when
+        // when
         mockSettingsImpl.invocationListeners(invocationListener);
 
-        //then
-        Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere() {
-        //given
-        assertFalse(mockSettingsImpl.hasInvocationListeners());
+        // given
+        assertThat(mockSettingsImpl.hasInvocationListeners()).isFalse();
+
+        // when
+        mockSettingsImpl
+                .invocationListeners(invocationListener, invocationListener)
+                .invocationListeners(invocationListener);
+
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners())
+                .containsSequence(invocationListener, invocationListener, invocationListener);
+    }
+
+    @Test
+    public void validates_listeners() {
+        assertThatThrownBy(
+                        () ->
+                                mockSettingsImpl.addListeners(
+                                        new Object[] {}, new LinkedList<Object>(), "myListeners"))
+                .hasMessageContaining("myListeners() requires at least one listener");
+
+        assertThatThrownBy(
+                        () ->
+                                mockSettingsImpl.addListeners(
+                                        null, new LinkedList<Object>(), "myListeners"))
+                .hasMessageContaining("myListeners() does not accept null vararg array");
+
+        assertThatThrownBy(
+                        () ->
+                                mockSettingsImpl.addListeners(
+                                        new Object[] {null},
+                                        new LinkedList<Object>(),
+                                        "myListeners"))
+                .hasMessageContaining("myListeners() does not accept null listeners");
+    }
+
+    @Test
+    public void validates_stubbing_lookup_listeners() {
+        assertThatThrownBy(
+                        () ->
+                                mockSettingsImpl.stubbingLookupListeners(
+                                        new StubbingLookupListener[] {}))
+                .hasMessageContaining("stubbingLookupListeners() requires at least one listener");
+
+        assertThatThrownBy(() -> mockSettingsImpl.stubbingLookupListeners(null))
+                .hasMessageContaining(
+                        "stubbingLookupListeners() does not accept null vararg array");
+
+        assertThatThrownBy(
+                        () ->
+                                mockSettingsImpl.stubbingLookupListeners(
+                                        new StubbingLookupListener[] {null}))
+                .hasMessageContaining("stubbingLookupListeners() does not accept null listeners");
+    }
 
-        //when
-        mockSettingsImpl.invocationListeners(invocationListener, invocationListener).invocationListeners(invocationListener);
+    @Test
+    public void validates_invocation_listeners() {
+        assertThatThrownBy(() -> mockSettingsImpl.invocationListeners(new InvocationListener[] {}))
+                .hasMessageContaining("invocationListeners() requires at least one listener");
 
-        //then
-        Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener, invocationListener, invocationListener);
+        assertThatThrownBy(() -> mockSettingsImpl.invocationListeners(null))
+                .hasMessageContaining("invocationListeners() does not accept null vararg array");
+
+        assertThatThrownBy(
+                        () -> mockSettingsImpl.invocationListeners(new InvocationListener[] {null}))
+                .hasMessageContaining("invocationListeners() does not accept null listeners");
     }
 
     @Test
-    public void shouldReportErrorWhenAddingNoInvocationListeners() throws Exception {
-        try {
-            mockSettingsImpl.invocationListeners();
-            fail();
-        } catch (Exception e) {
-            Assertions.assertThat(e.getMessage()).contains("at least one listener");
-        }
+    public void addListeners_has_empty_listeners_by_default() {
+        assertThat(mockSettingsImpl.getInvocationListeners()).isEmpty();
+        assertThat(mockSettingsImpl.getStubbingLookupListeners()).isEmpty();
+    }
+
+    @Test
+    public void addListeners_shouldAddMockObjectListeners() {
+        // when
+        mockSettingsImpl.invocationListeners(invocationListener);
+        mockSettingsImpl.stubbingLookupListeners(stubbingLookupListener);
+
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);
+        assertThat(mockSettingsImpl.getStubbingLookupListeners()).contains(stubbingLookupListener);
     }
 
     @Test
-    public void shouldReportErrorWhenAddingANullInvocationListener() throws Exception {
-        try {
-            mockSettingsImpl.invocationListeners(invocationListener, null);
-            fail();
-        } catch (Exception e) {
-            Assertions.assertThat(e.getMessage()).contains("does not accept null");
-        }
+    public void addListeners_canAddDuplicateMockObjectListeners_ItsNotOurBusinessThere() {
+        // when
+        mockSettingsImpl
+                .stubbingLookupListeners(stubbingLookupListener)
+                .stubbingLookupListeners(stubbingLookupListener)
+                .invocationListeners(invocationListener)
+                .invocationListeners(invocationListener);
+
+        // then
+        assertThat(mockSettingsImpl.getInvocationListeners())
+                .containsSequence(invocationListener, invocationListener);
+        assertThat(mockSettingsImpl.getStubbingLookupListeners())
+                .containsSequence(stubbingLookupListener, stubbingLookupListener);
     }
 }
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/AbstractByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/AbstractByteBuddyMockMakerTest.java
index 2b08c10..93c8913 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/AbstractByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/AbstractByteBuddyMockMakerTest.java
@@ -4,52 +4,47 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockitoutil.ClassLoaders.coverageTool;
+
+import java.io.Serializable;
+
 import net.bytebuddy.ByteBuddy;
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.mockito.internal.creation.MockSettingsImpl;
+import org.mockito.internal.creation.AbstractMockMakerTest;
 import org.mockito.internal.handler.MockHandlerImpl;
-import org.mockito.invocation.InvocationContainer;
-import org.mockito.internal.stubbing.answers.CallsRealMethods;
-import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.SerializableMode;
 import org.mockito.plugins.MockMaker;
-import org.mockito.stubbing.Answer;
 import org.mockitoutil.ClassLoaders;
 import org.mockitoutil.SimpleSerializationUtil;
 import org.objenesis.ObjenesisStd;
 
-import java.io.Serializable;
-import java.util.List;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockitoutil.ClassLoaders.coverageTool;
+public abstract class AbstractByteBuddyMockMakerTest<MM extends MockMaker>
+        extends AbstractMockMakerTest<MM, AbstractByteBuddyMockMakerTest.SomeClass> {
 
-public abstract class AbstractByteBuddyMockMakerTest<MM extends MockMaker> {
-
-    protected final MM mockMaker;
-
-    public AbstractByteBuddyMockMakerTest(MM mockMaker) {
-        this.mockMaker = mockMaker;
+    protected AbstractByteBuddyMockMakerTest(MM mockMaker) {
+        super(mockMaker, SomeClass.class);
     }
 
     protected abstract Class<?> mockTypeOf(Class<?> type);
 
     @Test
     public void should_create_mock_from_interface() throws Exception {
-        SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
+        SomeInterface proxy =
+                mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
 
         Class<?> superClass = proxy.getClass().getSuperclass();
         assertThat(superClass).isEqualTo(Object.class);
     }
 
-
     @Test
     public void should_create_mock_from_class() throws Exception {
-        ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyHandler());
+        ClassWithoutConstructor proxy =
+                mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyHandler());
 
         Class<?> superClass = mockTypeOf(proxy.getClass());
         assertThat(superClass).isEqualTo(ClassWithoutConstructor.class);
@@ -60,40 +55,36 @@ public abstract class AbstractByteBuddyMockMakerTest<MM extends MockMaker> {
         try {
             new ClassWithDodgyConstructor();
             fail();
-        } catch (Exception expected) {}
+        } catch (Exception expected) {
+        }
 
-        ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyHandler());
+        ClassWithDodgyConstructor mock =
+                mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyHandler());
         assertThat(mock).isNotNull();
     }
 
-    @Test
-    public void should_mocks_have_different_interceptors() throws Exception {
-        SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyHandler());
-        SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyHandler());
-
-        MockHandler handlerOne = mockMaker.getHandler(mockOne);
-        MockHandler handlerTwo = mockMaker.getHandler(mockTwo);
-
-
-        assertThat(handlerOne).isNotSameAs(handlerTwo);
-    }
-
     @Test
     public void should_use_ancillary_Types() {
-        SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyHandler());
+        SomeClass mock =
+                mockMaker.createMock(
+                        settingsFor(SomeClass.class, SomeInterface.class), dummyHandler());
 
         assertThat(mock).isInstanceOf(SomeInterface.class);
     }
 
     @Test
     public void should_create_class_by_constructor() {
-        OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyHandler());
+        OtherClass mock =
+                mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyHandler());
         assertThat(mock).isNotNull();
     }
 
     @Test
     public void should_allow_serialization() throws Exception {
-        SerializableClass proxy = mockMaker.createMock(serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC), dummyHandler());
+        SerializableClass proxy =
+                mockMaker.createMock(
+                        serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC),
+                        dummyHandler());
 
         SerializableClass serialized = SimpleSerializationUtil.serializeAndBack(proxy);
         assertThat(serialized).isNotNull();
@@ -106,24 +97,20 @@ public abstract class AbstractByteBuddyMockMakerTest<MM extends MockMaker> {
 
     @Test
     public void should_create_mock_from_class_with_super_call_to_final_method() throws Exception {
-        MockCreationSettings<CallingSuperMethodClass> settings = settingsWithSuperCall(CallingSuperMethodClass.class);
-        SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<CallingSuperMethodClass>(settings));
+        MockCreationSettings<CallingSuperMethodClass> settings =
+                settingsWithSuperCall(CallingSuperMethodClass.class);
+        SampleClass proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<CallingSuperMethodClass>(settings));
         assertThat(proxy.foo()).isEqualTo("foo");
     }
 
-    @Test
-    public void should_reset_mock_and_set_new_handler() throws Throwable {
-        MockCreationSettings<SampleClass> settings = settingsWithSuperCall(SampleClass.class);
-        SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<SampleClass>(settings));
-
-        MockHandler handler = new MockHandlerImpl<SampleClass>(settings);
-        mockMaker.resetMock(proxy, handler, settings);
-        assertThat(mockMaker.getHandler(proxy)).isSameAs(handler);
-    }
-
     class SomeClass {}
+
     interface SomeInterface {}
+
     static class OtherClass {}
+
     static class SerializableClass implements Serializable {}
 
     private class ClassWithoutConstructor {}
@@ -137,61 +124,24 @@ public abstract class AbstractByteBuddyMockMakerTest<MM extends MockMaker> {
     @Test
     public void instantiate_fine_when_objenesis_on_the_classpath() throws Exception {
         // given
-        ClassLoader classpath_with_objenesis = ClassLoaders.excludingClassLoader()
-                .withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
-                .withCodeSourceUrlOf(coverageTool())
-                .build();
-
-        Class<?> mock_maker_class_loaded_fine_until = Class.forName(
-                "org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker",
-                true,
-                classpath_with_objenesis
-        );
+        ClassLoader classpath_with_objenesis =
+                ClassLoaders.excludingClassLoader()
+                        .withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
+                        .withCodeSourceUrlOf(coverageTool())
+                        .build();
+
+        Class<?> mock_maker_class_loaded_fine_until =
+                Class.forName(
+                        "org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker",
+                        true,
+                        classpath_with_objenesis);
 
         // when
-        mock_maker_class_loaded_fine_until.newInstance();
+        mock_maker_class_loaded_fine_until.getConstructor().newInstance();
 
         // then everything went fine
     }
 
-    private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.setTypeToMock(type);
-        if(extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
-        return mockSettings;
-    }
-
-    private static <T> MockCreationSettings<T> serializableSettingsFor(Class<T> type, SerializableMode serializableMode) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.serializable(serializableMode);
-        mockSettings.setTypeToMock(type);
-        return mockSettings;
-    }
-
-    private static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.setTypeToMock(type);
-        return mockSettings;
-    }
-
-    private static <T> MockCreationSettings<T> settingsWithSuperCall(Class<T> type) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.setTypeToMock(type);
-        mockSettings.defaultAnswer(new CallsRealMethods());
-        return mockSettings;
-    }
-
-    protected static MockHandler dummyHandler() {
-        return new DummyMockHandler();
-    }
-
-    private static class DummyMockHandler implements MockHandler<Object> {
-        public Object handle(Invocation invocation) throws Throwable { return null; }
-        public MockCreationSettings<Object> getMockSettings() { return null; }
-        public InvocationContainer getInvocationContainer() { return null; }
-        public void setAnswersForStubbing(List<Answer<?>> list) { }
-    }
-
     private static class SampleClass {
         public String foo() {
             return "foo";
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
index 858f623..1a9eebe 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
@@ -4,25 +4,22 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
-import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.handler.MockHandlerImpl;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.verify;
-
 public class ByteBuddyMockMakerTest extends TestBase {
 
-    @InjectMocks
-    private ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker();
-
-    @Mock
-    private ClassCreatingMockMaker delegate;
+    @Mock private SubclassByteBuddyMockMaker delegate;
 
     @Test
     public void should_delegate_call() {
+        ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker(delegate);
+
         CreationSettings<Object> creationSettings = new CreationSettings<Object>();
         MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
 
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
index 3613b5f..9069e50 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
@@ -4,398 +4,45 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import net.bytebuddy.ByteBuddy;
-import net.bytebuddy.ClassFileVersion;
-import net.bytebuddy.description.modifier.Visibility;
-import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.implementation.StubMethod;
 import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.creation.MockSettingsImpl;
+import org.mockito.Mock;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.handler.MockHandlerImpl;
-import org.mockito.internal.stubbing.answers.Returns;
-import org.mockito.internal.util.collections.Sets;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.mock.SerializableMode;
-import org.mockito.plugins.MockMaker;
+import org.mockitoutil.TestBase;
 
-import java.util.HashMap;
-import java.util.List;
-import java.util.Observable;
-import java.util.Observer;
-import java.util.Set;
-import java.util.regex.Pattern;
+import static org.mockito.Mockito.verify;
 
-import static net.bytebuddy.ClassFileVersion.JAVA_V8;
-import static net.bytebuddy.matcher.ElementMatchers.named;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.junit.Assume.assumeTrue;
+public class InlineByteBuddyMockMakerTest extends TestBase {
 
-public class InlineByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest<InlineByteBuddyMockMaker> {
-
-    public InlineByteBuddyMockMakerTest() {
-        super(new InlineByteBuddyMockMaker());
-    }
-
-    @Override
-    protected Class<?> mockTypeOf(Class<?> type) {
-        return type;
-    }
-
-    @Test
-    public void should_create_mock_from_final_class() throws Exception {
-        MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
-        FinalClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_final_class_in_the_JDK() throws Exception {
-        MockCreationSettings<Pattern> settings = settingsFor(Pattern.class);
-        Pattern proxy = mockMaker.createMock(settings, new MockHandlerImpl<Pattern>(settings));
-        assertThat(proxy.pattern()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
-        MockCreationSettings<FinalMethodAbstractType> settings = settingsFor(FinalMethodAbstractType.class);
-        FinalMethodAbstractType proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-        assertThat(proxy.bar()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
-        MockCreationSettings<FinalMethod> settings = settingsFor(FinalMethod.class, SampleInterface.class);
-        FinalMethod proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-        assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_detect_non_overridden_generic_method_of_supertype() throws Exception {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(proxy.value()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_hashmap() throws Exception {
-        MockCreationSettings<HashMap> settings = settingsFor(HashMap.class);
-        HashMap proxy = mockMaker.createMock(settings, new MockHandlerImpl<HashMap>(settings));
-        assertThat(proxy.get(null)).isEqualTo("bar");
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void should_throw_exception_redefining_unmodifiable_class() {
-        MockCreationSettings settings = settingsFor(int.class);
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            e.printStackTrace();
-            assertThat(e).hasMessageContaining("Could not modify all classes");
-        }
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void should_throw_exception_redefining_array() {
-        int[] array = new int[5];
-        MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e).hasMessageContaining("Arrays cannot be mocked");
-        }
-    }
-
-    @Test
-    public void should_create_mock_from_enum() throws Exception {
-        MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
-        EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_fail_at_creating_a_mock_of_a_final_class_with_explicit_serialization() throws Exception {
-        MockCreationSettings<FinalClass> settings = new CreationSettings<FinalClass>()
-                .setTypeToMock(FinalClass.class)
-                .setSerializableMode(SerializableMode.BASIC);
-
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e)
-                    .hasMessageContaining("Unsupported settings")
-                    .hasMessageContaining("serialization")
-                    .hasMessageContaining("extra interfaces");
-        }
-    }
-
-    @Test
-    public void should_fail_at_creating_a_mock_of_a_final_class_with_extra_interfaces() throws Exception {
-        MockCreationSettings<FinalClass> settings = new CreationSettings<FinalClass>()
-                .setTypeToMock(FinalClass.class)
-                .setExtraInterfaces(Sets.<Class<?>>newSet(List.class));
-
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e)
-                    .hasMessageContaining("Unsupported settings")
-                    .hasMessageContaining("serialization")
-                    .hasMessageContaining("extra interfaces");
-        }
-    }
-
-    @Test
-    public void should_mock_interface() {
-        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
-        mockSettings.setTypeToMock(Set.class);
-        mockSettings.defaultAnswer(new Returns(10));
-        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
-
-        assertThat(proxy.size()).isEqualTo(10);
-    }
-
-    @Test
-    public void should_mock_interface_to_string() {
-        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
-        mockSettings.setTypeToMock(Set.class);
-        mockSettings.defaultAnswer(new Returns("foo"));
-        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
-
-        assertThat(proxy.toString()).isEqualTo("foo");
-    }
-
-    @Test
-    public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
-        StackTraceElement[] stack = new StackTraceElement[]{
-                new StackTraceElement("foo", "", "", -1),
-                new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
-                new StackTraceElement("qux", "", "", -1),
-                new StackTraceElement("bar", "", "", -1),
-                new StackTraceElement("baz", "", "", -1)
-        };
-
-        Throwable throwable = new Throwable();
-        throwable.setStackTrace(stack);
-        throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
-
-        assertThat(throwable.getStackTrace()).isEqualTo(new StackTraceElement[]{
-                new StackTraceElement("foo", "", "", -1),
-                new StackTraceElement("bar", "", "", -1),
-                new StackTraceElement("baz", "", "", -1)
-        });
-    }
-
-    @Test
-    public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
-        Throwable throwable = new Throwable();
-        throwable.setStackTrace(new StackTraceElement[0]);
-        assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
-    }
-
-    @Test
-    public void should_provide_reason_for_wrapper_class() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
-        assertThat(mockable.nonMockableReason()).isEqualTo("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void should_provide_reason_for_vm_unsupported() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int[].class);
-        assertThat(mockable.nonMockableReason()).isEqualTo("VM does not not support modification of given type");
-    }
-
-    @Test
-    public void should_mock_method_of_package_private_class() throws Exception {
-        MockCreationSettings<NonPackagePrivateSubClass> settings = settingsFor(NonPackagePrivateSubClass.class);
-        NonPackagePrivateSubClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<NonPackagePrivateSubClass>(settings));
-        assertThat(proxy.value()).isEqualTo("bar");
-    }
+    @Mock private InlineDelegateByteBuddyMockMaker delegate;
 
     @Test
-    public void is_type_mockable_excludes_String() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(String.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason()).contains("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void is_type_mockable_excludes_Class() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Class.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason()).contains("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void is_type_mockable_excludes_primitive_classes() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason()).contains("primitive");
-    }
-
-    @Test
-    public void is_type_mockable_allows_anonymous() {
-        Observer anonymous = new Observer() {
-            @Override
-            public void update(Observable o, Object arg) {
-            }
-        };
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(anonymous.getClass());
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).contains("");
-    }
-
-    @Test
-    public void is_type_mockable_give_empty_reason_if_type_is_mockable() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(SomeClass.class);
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).isEqualTo("");
-    }
-
-    @Test
-    public void is_type_mockable_give_allow_final_mockable_from_JDK() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Pattern.class);
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).isEqualTo("");
-    }
+    public void should_delegate_call() {
+        InlineByteBuddyMockMaker mockMaker = new InlineByteBuddyMockMaker(delegate);
 
-    @Test
-    public void test_parameters_retention() throws Exception {
-        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V8));
-
-        Class<?> typeWithParameters = new ByteBuddy()
-                .subclass(Object.class)
-                .defineMethod("foo", void.class, Visibility.PUBLIC)
-                .withParameter(String.class, "bar")
-                .intercept(StubMethod.INSTANCE)
-                .make()
-                .load(null)
-                .getLoaded();
-
-        MockCreationSettings<?> settings = settingsFor(typeWithParameters);
-        @SuppressWarnings("unchecked")
-        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
-
-        assertThat(proxy.getClass()).isEqualTo(typeWithParameters);
-        assertThat(new TypeDescription.ForLoadedType(typeWithParameters).getDeclaredMethods().filter(named("foo"))
-                .getOnly().getParameters().getOnly().getName()).isEqualTo("bar");
-    }
-
-    @Test
-    public void test_clear_mock_clears_handler() {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy)).isNotNull();
-
-        //when
-        mockMaker.clearMock(proxy);
+        CreationSettings<Object> creationSettings = new CreationSettings<Object>();
+        MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
 
-        //then
-        assertThat(mockMaker.getHandler(proxy)).isNull();
-    }
-
-    @Test
-    public void test_clear_all_mock_clears_handler() {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy1 = mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
-
-        settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy2 = mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
-
-        //when
+        mockMaker.createMockType(creationSettings);
+        mockMaker.createMock(creationSettings, handler);
+        mockMaker.createStaticMock(Object.class, creationSettings, handler);
+        mockMaker.createConstructionMock(Object.class, null, null, null);
+        mockMaker.getHandler(this);
+        mockMaker.isTypeMockable(Object.class);
+        mockMaker.resetMock(this, handler, creationSettings);
+        mockMaker.clearMock(this);
         mockMaker.clearAllMocks();
-
-        //then
-        assertThat(mockMaker.getHandler(proxy1)).isNull();
-        assertThat(mockMaker.getHandler(proxy2)).isNull();
-    }
-
-    private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.setTypeToMock(type);
-        mockSettings.defaultAnswer(new Returns("bar"));
-        if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
-        return mockSettings;
-    }
-
-    @Test
-    public void testMockDispatcherIsRelocated() throws Exception {
-        assertThat(InlineByteBuddyMockMaker.class.getClassLoader().getResource("org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw")).isNotNull();
-    }
-
-    private static final class FinalClass {
-
-        public String foo() {
-            return "foo";
-        }
-    }
-
-    private enum EnumClass {
-
-        INSTANCE;
-
-        public String foo() {
-            return "foo";
-        }
-    }
-
-    private abstract static class FinalMethodAbstractType {
-
-        public final String foo() {
-            return "foo";
-        }
-
-        public abstract String bar();
-    }
-
-    private static class FinalMethod {
-
-        public final String foo() {
-            return "foo";
-        }
-    }
-
-    private interface SampleInterface {
-
-        String bar();
-    }
-
-    /*package-private*/ abstract class PackagePrivateSuperClass {
-
-        public abstract String indirect();
-
-        public String value() {
-            return indirect() + "qux";
-        }
-    }
-
-    public class NonPackagePrivateSubClass extends PackagePrivateSuperClass {
-
-        @Override
-        public String indirect() {
-            return "foo";
-        }
-    }
-
-    public static class GenericClass<T> {
-
-        public T value() {
-            return null;
-        }
-    }
-
-    public static class GenericSubClass extends GenericClass<String> {
+        mockMaker.clearAllCaches();
+
+        verify(delegate).createMock(creationSettings, handler);
+        verify(delegate).createStaticMock(Object.class, creationSettings, handler);
+        verify(delegate).createConstructionMock(Object.class, null, null, null);
+        verify(delegate).createMockType(creationSettings);
+        verify(delegate).getHandler(this);
+        verify(delegate).isTypeMockable(Object.class);
+        verify(delegate).resetMock(this, handler, creationSettings);
+        verify(delegate).clearMock(this);
+        verify(delegate).clearAllMocks();
+        verify(delegate).clearAllCaches();
     }
 }
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
new file mode 100644
index 0000000..3d42f3a
--- /dev/null
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
@@ -0,0 +1,649 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.bytebuddy;
+
+import static net.bytebuddy.ClassFileVersion.JAVA_V11;
+import static net.bytebuddy.ClassFileVersion.JAVA_V8;
+import static net.bytebuddy.matcher.ElementMatchers.named;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.junit.Assert.*;
+import static org.junit.Assume.assumeTrue;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.Callable;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.ClassFileVersion;
+import net.bytebuddy.description.modifier.Visibility;
+import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.implementation.FixedValue;
+import net.bytebuddy.implementation.StubMethod;
+import net.bytebuddy.utility.JavaConstant;
+import org.junit.Test;
+import org.mockito.Answers;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.creation.MockSettingsImpl;
+import org.mockito.internal.creation.settings.CreationSettings;
+import org.mockito.internal.handler.MockHandlerImpl;
+import org.mockito.internal.stubbing.answers.Returns;
+import org.mockito.internal.util.collections.Sets;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.mock.SerializableMode;
+import org.mockito.plugins.MockMaker;
+
+public class InlineDelegateByteBuddyMockMakerTest
+        extends AbstractByteBuddyMockMakerTest<InlineByteBuddyMockMaker> {
+
+    public InlineDelegateByteBuddyMockMakerTest() {
+        super(new InlineByteBuddyMockMaker());
+    }
+
+    @Override
+    protected Class<?> mockTypeOf(Class<?> type) {
+        return type;
+    }
+
+    @Test
+    public void should_create_mock_from_final_class() throws Exception {
+        MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
+        FinalClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_spy() throws Exception {
+        MockCreationSettings<FinalSpy> settings = settingsFor(FinalSpy.class);
+        Optional<FinalSpy> proxy =
+                mockMaker.createSpy(
+                        settings,
+                        new MockHandlerImpl<>(settings),
+                        new FinalSpy("value", true, (byte) 1, (short) 1, (char) 1, 1, 1L, 1f, 1d));
+        assertThat(proxy)
+                .hasValueSatisfying(
+                        spy -> {
+                            assertThat(spy.aString).isEqualTo("value");
+                            assertThat(spy.aBoolean).isTrue();
+                            assertThat(spy.aByte).isEqualTo((byte) 1);
+                            assertThat(spy.aShort).isEqualTo((short) 1);
+                            assertThat(spy.aChar).isEqualTo((char) 1);
+                            assertThat(spy.anInt).isEqualTo(1);
+                            assertThat(spy.aLong).isEqualTo(1L);
+                            assertThat(spy.aFloat).isEqualTo(1f);
+                            assertThat(spy.aDouble).isEqualTo(1d);
+                        });
+    }
+
+    @Test
+    public void should_create_mock_from_non_constructable_class() throws Exception {
+        MockCreationSettings<NonConstructableClass> settings =
+                settingsFor(NonConstructableClass.class);
+        NonConstructableClass proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<NonConstructableClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_class_in_the_JDK() throws Exception {
+        MockCreationSettings<Pattern> settings = settingsFor(Pattern.class);
+        Pattern proxy = mockMaker.createMock(settings, new MockHandlerImpl<Pattern>(settings));
+        assertThat(proxy.pattern()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
+        MockCreationSettings<FinalMethodAbstractType> settings =
+                settingsFor(FinalMethodAbstractType.class);
+        FinalMethodAbstractType proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(proxy.bar()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
+        MockCreationSettings<FinalMethod> settings =
+                settingsFor(FinalMethod.class, SampleInterface.class);
+        FinalMethod proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_detect_non_overridden_generic_method_of_supertype() throws Exception {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(proxy.value()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_hashmap() throws Exception {
+        MockCreationSettings<HashMap> settings = settingsFor(HashMap.class);
+        HashMap proxy = mockMaker.createMock(settings, new MockHandlerImpl<HashMap>(settings));
+        assertThat(proxy.get(null)).isEqualTo("bar");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void should_throw_exception_redefining_unmodifiable_class() {
+        MockCreationSettings settings = settingsFor(int.class);
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            e.printStackTrace();
+            assertThat(e).hasMessageContaining("Could not modify all classes");
+        }
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void should_throw_exception_redefining_array() {
+        int[] array = new int[5];
+        MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e).hasMessageContaining("Arrays cannot be mocked");
+        }
+    }
+
+    @Test
+    public void should_create_mock_from_enum() throws Exception {
+        MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
+        EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_fail_at_creating_a_mock_of_a_final_class_with_explicit_serialization()
+            throws Exception {
+        MockCreationSettings<FinalClass> settings =
+                new CreationSettings<FinalClass>()
+                        .setTypeToMock(FinalClass.class)
+                        .setSerializableMode(SerializableMode.BASIC);
+
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e)
+                    .hasMessageContaining("Unsupported settings")
+                    .hasMessageContaining("serialization")
+                    .hasMessageContaining("extra interfaces");
+        }
+    }
+
+    @Test
+    public void should_fail_at_creating_a_mock_of_a_final_class_with_extra_interfaces()
+            throws Exception {
+        MockCreationSettings<FinalClass> settings =
+                new CreationSettings<FinalClass>()
+                        .setTypeToMock(FinalClass.class)
+                        .setExtraInterfaces(Sets.<Class<?>>newSet(List.class));
+
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e)
+                    .hasMessageContaining("Unsupported settings")
+                    .hasMessageContaining("serialization")
+                    .hasMessageContaining("extra interfaces");
+        }
+    }
+
+    @Test
+    public void should_mock_interface() {
+        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
+        mockSettings.setTypeToMock(Set.class);
+        mockSettings.defaultAnswer(new Returns(10));
+        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
+
+        assertThat(proxy.size()).isEqualTo(10);
+    }
+
+    @Test
+    public void should_mock_interface_to_string() {
+        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
+        mockSettings.setTypeToMock(Set.class);
+        mockSettings.defaultAnswer(new Returns("foo"));
+        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
+
+        assertThat(proxy.toString()).isEqualTo("foo");
+    }
+
+    /**
+     * @see <a href="https://github.com/mockito/mockito/issues/2154">https://github.com/mockito/mockito/issues/2154</a>
+     */
+    @Test
+    public void should_mock_class_to_string() {
+        MockSettingsImpl<Object> mockSettings = new MockSettingsImpl<Object>();
+        mockSettings.setTypeToMock(Object.class);
+        mockSettings.defaultAnswer(new Returns("foo"));
+        Object proxy =
+                mockMaker.createMock(mockSettings, new MockHandlerImpl<Object>(mockSettings));
+
+        assertThat(proxy.toString()).isEqualTo("foo");
+    }
+
+    @Test
+    public void should_leave_causing_stack() throws Exception {
+        MockSettingsImpl<ExceptionThrowingClass> settings = new MockSettingsImpl<>();
+        settings.setTypeToMock(ExceptionThrowingClass.class);
+        settings.defaultAnswer(Answers.CALLS_REAL_METHODS);
+
+        Optional<ExceptionThrowingClass> proxy =
+                mockMaker.createSpy(
+                        settings, new MockHandlerImpl<>(settings), new ExceptionThrowingClass());
+
+        StackTraceElement[] returnedStack =
+                assertThrows(IOException.class, () -> proxy.get().throwException()).getStackTrace();
+
+        assertNotNull("Stack trace from mockito expected", returnedStack);
+
+        List<StackTraceElement> exceptionClassElements =
+                Arrays.stream(returnedStack)
+                        .filter(
+                                element ->
+                                        element.getClassName()
+                                                .equals(ExceptionThrowingClass.class.getName()))
+                        .collect(Collectors.toList());
+        assertEquals(3, exceptionClassElements.size());
+        assertEquals("internalThrowException", exceptionClassElements.get(0).getMethodName());
+        assertEquals("internalThrowException", exceptionClassElements.get(1).getMethodName());
+        assertEquals("throwException", exceptionClassElements.get(2).getMethodName());
+    }
+
+    @Test
+    public void should_leave_causing_stack_with_two_spies() throws Exception {
+        // given
+        MockSettingsImpl<ExceptionThrowingClass> settingsEx = new MockSettingsImpl<>();
+        settingsEx.setTypeToMock(ExceptionThrowingClass.class);
+        settingsEx.defaultAnswer(Answers.CALLS_REAL_METHODS);
+        Optional<ExceptionThrowingClass> proxyEx =
+                mockMaker.createSpy(
+                        settingsEx,
+                        new MockHandlerImpl<>(settingsEx),
+                        new ExceptionThrowingClass());
+
+        MockSettingsImpl<WrapperClass> settingsWr = new MockSettingsImpl<>();
+        settingsWr.setTypeToMock(WrapperClass.class);
+        settingsWr.defaultAnswer(Answers.CALLS_REAL_METHODS);
+        Optional<WrapperClass> proxyWr =
+                mockMaker.createSpy(
+                        settingsWr, new MockHandlerImpl<>(settingsWr), new WrapperClass());
+
+        // when
+        IOException ex =
+                assertThrows(IOException.class, () -> proxyWr.get().callWrapped(proxyEx.get()));
+        List<StackTraceElement> wrapperClassElements =
+                Arrays.stream(ex.getStackTrace())
+                        .filter(
+                                element ->
+                                        element.getClassName().equals(WrapperClass.class.getName()))
+                        .collect(Collectors.toList());
+
+        // then
+        assertEquals(1, wrapperClassElements.size());
+        assertEquals("callWrapped", wrapperClassElements.get(0).getMethodName());
+    }
+
+    @Test
+    public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
+        StackTraceElement[] stack =
+                new StackTraceElement[] {
+                    new StackTraceElement("foo", "", "", -1),
+                    new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
+                    new StackTraceElement("qux", "", "", -1),
+                    new StackTraceElement("bar", "", "", -1),
+                    new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
+                    new StackTraceElement("baz", "", "", -1)
+                };
+
+        Throwable throwable = new Throwable();
+        throwable.setStackTrace(stack);
+        throwable = MockMethodAdvice.removeRecursiveCalls(throwable, SampleInterface.class);
+
+        assertThat(throwable.getStackTrace())
+                .isEqualTo(
+                        new StackTraceElement[] {
+                            new StackTraceElement("foo", "", "", -1),
+                            new StackTraceElement("qux", "", "", -1),
+                            new StackTraceElement("bar", "", "", -1),
+                            new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
+                            new StackTraceElement("baz", "", "", -1)
+                        });
+    }
+
+    @Test
+    public void should_handle_missing_or_inconsistent_stack_trace() {
+        Throwable throwable = new Throwable();
+        throwable.setStackTrace(new StackTraceElement[0]);
+        assertThat(MockMethodAdvice.removeRecursiveCalls(throwable, SampleInterface.class))
+                .isSameAs(throwable);
+    }
+
+    @Test
+    public void should_provide_reason_for_wrapper_class() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
+        assertThat(mockable.nonMockableReason())
+                .isEqualTo("Cannot mock wrapper types, String.class or Class.class");
+    }
+
+    @Test
+    public void should_provide_reason_for_vm_unsupported() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int[].class);
+        assertThat(mockable.nonMockableReason())
+                .isEqualTo("VM does not support modification of given type");
+    }
+
+    @Test
+    public void should_mock_method_of_package_private_class() throws Exception {
+        MockCreationSettings<NonPackagePrivateSubClass> settings =
+                settingsFor(NonPackagePrivateSubClass.class);
+        NonPackagePrivateSubClass proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<NonPackagePrivateSubClass>(settings));
+        assertThat(proxy.value()).isEqualTo("bar");
+    }
+
+    @Test
+    public void is_type_mockable_excludes_String() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(String.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason())
+                .contains("Cannot mock wrapper types, String.class or Class.class");
+    }
+
+    @Test
+    public void is_type_mockable_excludes_Class() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Class.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason())
+                .contains("Cannot mock wrapper types, String.class or Class.class");
+    }
+
+    @Test
+    public void is_type_mockable_excludes_primitive_classes() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason()).contains("primitive");
+    }
+
+    @Test
+    public void is_type_mockable_allows_anonymous() {
+        Observer anonymous =
+                new Observer() {
+                    @Override
+                    public void update(Observable o, Object arg) {}
+                };
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(anonymous.getClass());
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).contains("");
+    }
+
+    @Test
+    public void is_type_mockable_give_empty_reason_if_type_is_mockable() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(SomeClass.class);
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).isEqualTo("");
+    }
+
+    @Test
+    public void is_type_mockable_give_allow_final_mockable_from_JDK() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Pattern.class);
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).isEqualTo("");
+    }
+
+    @Test
+    public void test_parameters_retention() throws Exception {
+        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V8));
+
+        Class<?> typeWithParameters =
+                new ByteBuddy()
+                        .subclass(Object.class)
+                        .defineMethod("foo", void.class, Visibility.PUBLIC)
+                        .withParameter(String.class, "bar")
+                        .intercept(StubMethod.INSTANCE)
+                        .make()
+                        .load(null)
+                        .getLoaded();
+
+        MockCreationSettings<?> settings = settingsFor(typeWithParameters);
+        @SuppressWarnings("unchecked")
+        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
+
+        assertThat(proxy.getClass()).isEqualTo(typeWithParameters);
+        assertThat(
+                        new TypeDescription.ForLoadedType(typeWithParameters)
+                                .getDeclaredMethods()
+                                .filter(named("foo"))
+                                .getOnly()
+                                .getParameters()
+                                .getOnly()
+                                .getName())
+                .isEqualTo("bar");
+    }
+
+    @Test
+    public void test_constant_dynamic_compatibility() throws Exception {
+        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V11));
+
+        Class<?> typeWithCondy =
+                new ByteBuddy()
+                        .subclass(Callable.class)
+                        .method(named("call"))
+                        .intercept(FixedValue.value(JavaConstant.Dynamic.ofNullConstant()))
+                        .make()
+                        .load(null)
+                        .getLoaded();
+
+        MockCreationSettings<?> settings = settingsFor(typeWithCondy);
+        @SuppressWarnings("unchecked")
+        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
+
+        assertThat(proxy.getClass()).isEqualTo(typeWithCondy);
+    }
+
+    @Test
+    public void test_clear_mock_clears_handler() {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy)).isNotNull();
+
+        // when
+        mockMaker.clearMock(proxy);
+
+        // then
+        assertThat(mockMaker.getHandler(proxy)).isNull();
+    }
+
+    @Test
+    public void test_clear_all_mock_clears_handler() {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy1 =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
+
+        settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy2 =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
+
+        // when
+        mockMaker.clearAllMocks();
+
+        // then
+        assertThat(mockMaker.getHandler(proxy1)).isNull();
+        assertThat(mockMaker.getHandler(proxy2)).isNull();
+    }
+
+    protected static <T> MockCreationSettings<T> settingsFor(
+            Class<T> type, Class<?>... extraInterfaces) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.setTypeToMock(type);
+        mockSettings.defaultAnswer(new Returns("bar"));
+        if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
+        return mockSettings;
+    }
+
+    @Test
+    public void testMockDispatcherIsRelocated() throws Exception {
+        assertThat(
+                        InlineByteBuddyMockMaker.class
+                                .getClassLoader()
+                                .getResource(
+                                        "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.raw"))
+                .isNotNull();
+    }
+
+    private static final class FinalClass {
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private static final class FinalSpy {
+
+        private final String aString;
+        private final boolean aBoolean;
+        private final byte aByte;
+        private final short aShort;
+        private final char aChar;
+        private final int anInt;
+        private final long aLong;
+        private final float aFloat;
+        private final double aDouble;
+
+        private FinalSpy(
+                String aString,
+                boolean aBoolean,
+                byte aByte,
+                short aShort,
+                char aChar,
+                int anInt,
+                long aLong,
+                float aFloat,
+                double aDouble) {
+            this.aString = aString;
+            this.aBoolean = aBoolean;
+            this.aByte = aByte;
+            this.aShort = aShort;
+            this.aChar = aChar;
+            this.anInt = anInt;
+            this.aLong = aLong;
+            this.aFloat = aFloat;
+            this.aDouble = aDouble;
+        }
+    }
+
+    private static class NonConstructableClass {
+
+        private NonConstructableClass() {
+            throw new AssertionError();
+        }
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private enum EnumClass {
+        INSTANCE;
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private abstract static class FinalMethodAbstractType {
+
+        public final String foo() {
+            return "foo";
+        }
+
+        public abstract String bar();
+    }
+
+    private static class FinalMethod {
+
+        public final String foo() {
+            return "foo";
+        }
+    }
+
+    private interface SampleInterface {
+
+        String bar();
+    }
+
+    /*package-private*/ abstract class PackagePrivateSuperClass {
+
+        public abstract String indirect();
+
+        public String value() {
+            return indirect() + "qux";
+        }
+    }
+
+    public class NonPackagePrivateSubClass extends PackagePrivateSuperClass {
+
+        @Override
+        public String indirect() {
+            return "foo";
+        }
+    }
+
+    public static class GenericClass<T> {
+
+        public T value() {
+            return null;
+        }
+    }
+
+    public static class WrapperClass {
+        public void callWrapped(ExceptionThrowingClass exceptionThrowingClass) throws IOException {
+            exceptionThrowingClass.throwException();
+        }
+    }
+
+    public static class GenericSubClass extends GenericClass<String> {}
+
+    public static class ExceptionThrowingClass {
+        public IOException getException() {
+            try {
+                throwException();
+            } catch (IOException ex) {
+                return ex;
+            }
+            return null;
+        }
+
+        public void throwException() throws IOException {
+            internalThrowException(1);
+        }
+
+        void internalThrowException(int test) throws IOException {
+            // some lines of code, so the exception is not thrown in the first line of the method
+            int i = 0;
+            if (test != i) {
+                throw new IOException("fatal");
+            }
+        }
+    }
+}
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMakerTest.java
index 6b79640..6e08228 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMakerTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.ClassFileVersion;
+import net.bytebuddy.description.modifier.TypeManifestation;
+import net.bytebuddy.dynamic.DynamicType;
 import org.junit.Test;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.plugins.MockMaker;
@@ -15,7 +19,8 @@ import java.util.Observer;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest<SubclassByteBuddyMockMaker> {
+public class SubclassByteBuddyMockMakerTest
+        extends AbstractByteBuddyMockMakerTest<SubclassByteBuddyMockMaker> {
 
     public SubclassByteBuddyMockMakerTest() {
         super(new SubclassByteBuddyMockMaker());
@@ -28,6 +33,25 @@ public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTe
         assertThat(mockable.nonMockableReason()).contains("final");
     }
 
+    @Test
+    public void is_type_mockable_excludes_sealed_classes() {
+        if (ClassFileVersion.ofThisVm().isAtMost(ClassFileVersion.JAVA_V16)) {
+            return;
+        }
+        DynamicType.Builder<?> base = new ByteBuddy().subclass(Object.class);
+        DynamicType.Builder<?> subclass =
+                new ByteBuddy().subclass(base.toTypeDescription()).merge(TypeManifestation.FINAL);
+        Class<?> type =
+                base.permittedSubclass(subclass.toTypeDescription())
+                        .make()
+                        .include(subclass.make())
+                        .load(null)
+                        .getLoaded();
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(type);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason()).contains("sealed");
+    }
+
     @Test
     public void is_type_mockable_excludes_primitive_classes() {
         MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int.class);
@@ -37,9 +61,11 @@ public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTe
 
     @Test
     public void is_type_mockable_allow_anonymous() {
-        Observer anonymous = new Observer() {
-            @Override public void update(Observable o, Object arg) { }
-        };
+        Observer anonymous =
+                new Observer() {
+                    @Override
+                    public void update(Observable o, Object arg) {}
+                };
         MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(anonymous.getClass());
         assertThat(mockable.mockable()).isTrue();
         assertThat(mockable.nonMockableReason()).contains("");
@@ -54,7 +80,8 @@ public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTe
 
     @Test
     public void mock_type_with_annotations() throws Exception {
-        MockSettingsImpl<ClassWithAnnotation> mockSettings = new MockSettingsImpl<ClassWithAnnotation>();
+        MockSettingsImpl<ClassWithAnnotation> mockSettings =
+                new MockSettingsImpl<ClassWithAnnotation>();
         mockSettings.setTypeToMock(ClassWithAnnotation.class);
 
         ClassWithAnnotation proxy = mockMaker.createMock(mockSettings, dummyHandler());
@@ -62,20 +89,34 @@ public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTe
         assertThat(proxy.getClass().isAnnotationPresent(SampleAnnotation.class)).isTrue();
         assertThat(proxy.getClass().getAnnotation(SampleAnnotation.class).value()).isEqualTo("foo");
 
-        assertThat(proxy.getClass().getMethod("sampleMethod").isAnnotationPresent(SampleAnnotation.class)).isTrue();
-        assertThat(proxy.getClass().getMethod("sampleMethod").getAnnotation(SampleAnnotation.class).value()).isEqualTo("bar");
+        assertThat(
+                        proxy.getClass()
+                                .getMethod("sampleMethod")
+                                .isAnnotationPresent(SampleAnnotation.class))
+                .isTrue();
+        assertThat(
+                        proxy.getClass()
+                                .getMethod("sampleMethod")
+                                .getAnnotation(SampleAnnotation.class)
+                                .value())
+                .isEqualTo("bar");
     }
 
     @Test
     public void mock_type_without_annotations() throws Exception {
-        MockSettingsImpl<ClassWithAnnotation> mockSettings = new MockSettingsImpl<ClassWithAnnotation>();
+        MockSettingsImpl<ClassWithAnnotation> mockSettings =
+                new MockSettingsImpl<ClassWithAnnotation>();
         mockSettings.setTypeToMock(ClassWithAnnotation.class);
         mockSettings.withoutAnnotations();
 
         ClassWithAnnotation proxy = mockMaker.createMock(mockSettings, dummyHandler());
 
         assertThat(proxy.getClass().isAnnotationPresent(SampleAnnotation.class)).isFalse();
-        assertThat(proxy.getClass().getMethod("sampleMethod").isAnnotationPresent(SampleAnnotation.class)).isFalse();
+        assertThat(
+                        proxy.getClass()
+                                .getMethod("sampleMethod")
+                                .isAnnotationPresent(SampleAnnotation.class))
+                .isFalse();
     }
 
     @Override
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
index 54c503e..026fba3 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
@@ -4,22 +4,25 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.mock.SerializableMode;
-import org.mockitoutil.VmArgAssumptions;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.internal.creation.bytebuddy.MockFeatures.withMockFeatures;
+import static org.mockitoutil.ClassLoaders.inMemoryClassLoader;
+import static org.mockitoutil.SimpleClassGenerator.makeMarkerInterface;
 
 import java.lang.ref.PhantomReference;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.Set;
 import java.util.WeakHashMap;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.internal.creation.bytebuddy.MockFeatures.withMockFeatures;
-import static org.mockitoutil.ClassLoaders.inMemoryClassLoader;
-import static org.mockitoutil.SimpleClassGenerator.makeMarkerInterface;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Answers;
+import org.mockito.mock.SerializableMode;
+import org.mockitoutil.VmArgAssumptions;
 
 public class TypeCachingMockBytecodeGeneratorTest {
 
@@ -29,23 +32,29 @@ public class TypeCachingMockBytecodeGeneratorTest {
     }
 
     @Test
-    public void ensure_cache_is_cleared_if_no_reference_to_classloader_and_classes() throws Exception {
+    public void ensure_cache_is_cleared_if_no_reference_to_classloader_and_classes()
+            throws Exception {
         // given
-        ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
-                .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
-                .build();
-
-        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
-
-        Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.NONE,
-                false
-        ));
+        ClassLoader classloader_with_life_shorter_than_cache =
+                inMemoryClassLoader()
+                        .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
+                        .build();
+
+        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator =
+                new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
+
+        Class<?> the_mock_type =
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.NONE,
+                                false,
+                                Answers.RETURNS_DEFAULTS));
 
         ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
-        Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
+        Reference<Object> typeReference =
+                new PhantomReference<Object>(the_mock_type, referenceQueue);
 
         // when
         classloader_with_life_shorter_than_cache = is_no_more_referenced();
@@ -61,29 +70,36 @@ public class TypeCachingMockBytecodeGeneratorTest {
     @Test
     public void ensure_cache_returns_same_instance() throws Exception {
         // given
-        ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
-                .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
-                .build();
-
-        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
-        Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                        classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                        Collections.<Class<?>>emptySet(),
-                        SerializableMode.NONE,
-                        false
-                ));
-
-        Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.NONE,
-                false
-        ));
+        ClassLoader classloader_with_life_shorter_than_cache =
+                inMemoryClassLoader()
+                        .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
+                        .build();
+
+        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator =
+                new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
+        Class<?> the_mock_type =
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.NONE,
+                                false,
+                                Answers.RETURNS_DEFAULTS));
+
+        Class<?> other_mock_type =
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.NONE,
+                                false,
+                                Answers.RETURNS_DEFAULTS));
 
         assertThat(other_mock_type).isSameAs(the_mock_type);
 
         ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
-        Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
+        Reference<Object> typeReference =
+                new PhantomReference<Object>(the_mock_type, referenceQueue);
 
         // when
         classloader_with_life_shorter_than_cache = is_no_more_referenced();
@@ -100,37 +116,85 @@ public class TypeCachingMockBytecodeGeneratorTest {
     @Test
     public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
         // given
-        ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
-                .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
-                .build();
-
-        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
-        Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.NONE,
-                false
-        ));
-
-        Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.BASIC,
-                false
-        ));
+        ClassLoader classloader_with_life_shorter_than_cache =
+                inMemoryClassLoader()
+                        .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
+                        .build();
+
+        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator =
+                new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
+        Class<?> the_mock_type =
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.NONE,
+                                false,
+                                Answers.RETURNS_DEFAULTS));
+
+        Class<?> other_mock_type =
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.BASIC,
+                                false,
+                                Answers.RETURNS_DEFAULTS));
 
         assertThat(other_mock_type).isNotSameAs(the_mock_type);
     }
 
     @Test
-    public void validate_simple_code_idea_where_weakhashmap_with_classloader_as_key_get_GCed_when_no_more_references() throws Exception {
+    public void ensure_cache_returns_same_instance_defaultAnswer() throws Exception {
+        // given
+        ClassLoader classloader_with_life_shorter_than_cache =
+                inMemoryClassLoader()
+                        .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
+                        .build();
+
+        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator =
+                new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
+
+        Answers[] answers = Answers.values();
+        Set<Class<?>> classes = Collections.newSetFromMap(new IdentityHashMap<>());
+        classes.add(
+                cachingMockBytecodeGenerator.mockClass(
+                        withMockFeatures(
+                                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                Collections.<Class<?>>emptySet(),
+                                SerializableMode.NONE,
+                                false,
+                                null)));
+        for (Answers answer : answers) {
+            Class<?> klass =
+                    cachingMockBytecodeGenerator.mockClass(
+                            withMockFeatures(
+                                    classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
+                                    Collections.<Class<?>>emptySet(),
+                                    SerializableMode.NONE,
+                                    false,
+                                    answer));
+            assertThat(classes.add(klass)).isFalse();
+        }
+
+        assertThat(classes).hasSize(1);
+    }
+
+    @Test
+    public void
+            validate_simple_code_idea_where_weakhashmap_with_classloader_as_key_get_GCed_when_no_more_references()
+                    throws Exception {
         // given
         WeakHashMap<ClassLoader, Object> cache = new WeakHashMap<ClassLoader, Object>();
-        ClassLoader short_lived_classloader = inMemoryClassLoader()
-                .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
-                .build();
+        ClassLoader short_lived_classloader =
+                inMemoryClassLoader()
+                        .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
+                        .build();
 
-        cache.put(short_lived_classloader, new HoldingAReference(new WeakReference<Class<?>>(short_lived_classloader.loadClass("foo.Bar"))));
+        cache.put(
+                short_lived_classloader,
+                new HoldingAReference(
+                        new WeakReference<Class<?>>(short_lived_classloader.loadClass("foo.Bar"))));
 
         assertThat(cache).hasSize(1);
 
@@ -152,7 +216,6 @@ public class TypeCachingMockBytecodeGeneratorTest {
         }
     }
 
-
     private static <T> T is_no_more_referenced() {
         return null;
     }
diff --git a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
index 320287c..a498073 100644
--- a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
+++ b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
@@ -5,69 +5,87 @@
 package org.mockito.internal.creation.instance;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
 
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 public class ConstructorInstantiatorTest extends TestBase {
 
-    static class SomeClass {
+    static class SomeClass {}
 
-    }
-
-    class SomeInnerClass {
-
-    }
+    class SomeInnerClass {}
 
-    class ChildOfThis extends ConstructorInstantiatorTest {
-
-    }
+    class ChildOfThis extends ConstructorInstantiatorTest {}
 
     static class SomeClass2 {
 
-        SomeClass2(String x) {
-        }
+        SomeClass2(String x) {}
     }
 
     static class SomeClass3 {
 
-        SomeClass3(int i) {
-
-        }
+        SomeClass3(int i) {}
     }
 
     @Test
     public void creates_instances() {
-        assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
+        assertThat(
+                        new ConstructorInstantiator(false, new Object[0])
+                                .newInstance(SomeClass.class)
+                                .getClass())
+                .isEqualTo(SomeClass.class);
     }
 
     @Test
     public void creates_instances_of_inner_classes() {
-        assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
-        assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
+        assertThat(
+                        new ConstructorInstantiator(true, this)
+                                .newInstance(SomeInnerClass.class)
+                                .getClass())
+                .isEqualTo(SomeInnerClass.class);
+        assertThat(
+                        new ConstructorInstantiator(true, new ChildOfThis())
+                                .newInstance(SomeInnerClass.class)
+                                .getClass())
+                .isEqualTo(SomeInnerClass.class);
     }
 
     @Test
     public void creates_instances_with_arguments() {
-        assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
+        assertThat(
+                        new ConstructorInstantiator(false, "someString")
+                                .newInstance(SomeClass2.class)
+                                .getClass())
+                .isEqualTo(SomeClass2.class);
     }
 
     @Test
     public void creates_instances_with_null_arguments() {
-        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
+        assertThat(
+                        new ConstructorInstantiator(false, new Object[] {null})
+                                .newInstance(SomeClass2.class)
+                                .getClass())
+                .isEqualTo(SomeClass2.class);
     }
 
     @Test
     public void creates_instances_with_primitive_arguments() {
-        assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
+        assertThat(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass())
+                .isEqualTo(SomeClass3.class);
     }
 
-    @Test(expected = org.mockito.creation.instance.InstantiationException.class)
+    @Test
     public void fails_when_null_is_passed_for_a_primitive() {
-        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
+        assertThatThrownBy(
+                        () -> {
+                            new ConstructorInstantiator(false, new Object[] {null})
+                                    .newInstance(SomeClass3.class)
+                                    .getClass();
+                        })
+                .isInstanceOf(org.mockito.creation.instance.InstantiationException.class)
+                .hasMessageContaining("Unable to create instance of 'SomeClass3'.");
     }
 
     @Test
@@ -76,8 +94,10 @@ public class ConstructorInstantiatorTest extends TestBase {
             new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
             fail();
         } catch (org.mockito.creation.instance.InstantiationException e) {
-            assertThat(e).hasMessageContaining("Unable to create instance of 'SomeClass2'.\n" +
-                    "Please ensure that the target class has a 0-arg constructor.");
+            assertThat(e)
+                    .hasMessageContaining(
+                            "Unable to create instance of 'SomeClass2'.\n"
+                                    + "Please ensure that the target class has a 0-arg constructor.");
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/creation/proxy/ProxyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/proxy/ProxyMockMakerTest.java
new file mode 100644
index 0000000..fd6009d
--- /dev/null
+++ b/src/test/java/org/mockito/internal/creation/proxy/ProxyMockMakerTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.creation.proxy;
+
+import org.junit.Test;
+import org.mockito.internal.creation.AbstractMockMakerTest;
+
+import java.io.Serializable;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Proxy;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class ProxyMockMakerTest
+        extends AbstractMockMakerTest<ProxyMockMaker, ProxyMockMakerTest.SomeInterface> {
+
+    public ProxyMockMakerTest() {
+        super(new ProxyMockMaker(), SomeInterface.class);
+    }
+
+    @Test
+    public void should_create_mock_from_interface() {
+        SomeInterface proxy =
+                mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
+
+        Class<?> superClass = proxy.getClass().getSuperclass();
+        assertThat(superClass).isEqualTo(Proxy.class);
+    }
+
+    @Test
+    public void should_create_mock_from_interface_with_extra_interface() {
+        SomeInterface proxy =
+                mockMaker.createMock(
+                        settingsFor(SomeInterface.class, Serializable.class), dummyHandler());
+
+        Class<?> superClass = proxy.getClass().getSuperclass();
+        assertThat(superClass).isEqualTo(Proxy.class);
+        assertThat(proxy).isInstanceOf(Serializable.class);
+    }
+
+    @Test
+    public void should_discover_mockable_input() {
+        assertThat(mockMaker.isTypeMockable(Number.class).mockable()).isFalse();
+        assertThat(mockMaker.isTypeMockable(Number.class).nonMockableReason())
+                .isEqualTo("non-interface");
+        assertThat(mockMaker.isTypeMockable(SomeInterface.class).mockable()).isTrue();
+        assertThat(mockMaker.isTypeMockable(Object.class).mockable()).isTrue();
+    }
+
+    @Test
+    public void can_compute_hash_code() throws Throwable {
+        SomeInterface proxy =
+                mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
+
+        InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+
+        assertThat(handler.invoke(proxy, Object.class.getMethod("hashCode"), null))
+                .isEqualTo(System.identityHashCode(proxy));
+    }
+
+    @Test
+    public void can_compute_equality() throws Throwable {
+        SomeInterface proxy =
+                mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
+
+        InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+
+        assertThat(
+                        handler.invoke(
+                                proxy,
+                                Object.class.getMethod("equals", Object.class),
+                                new Object[] {proxy}))
+                .isEqualTo(true);
+        assertThat(
+                        handler.invoke(
+                                proxy,
+                                Object.class.getMethod("equals", Object.class),
+                                new Object[] {null}))
+                .isEqualTo(false);
+        assertThat(
+                        handler.invoke(
+                                proxy,
+                                Object.class.getMethod("equals", Object.class),
+                                new Object[] {new Object()}))
+                .isEqualTo(false);
+    }
+
+    @Test
+    public void can_invoke_toString() throws Throwable {
+        SomeInterface proxy =
+                mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
+
+        InvocationHandler handler = Proxy.getInvocationHandler(proxy);
+
+        assertThat(handler.invoke(proxy, Object.class.getMethod("toString"), null)).isNull();
+    }
+
+    interface SomeInterface {}
+}
diff --git a/src/test/java/org/mockito/internal/debugging/LoggingListenerTest.java b/src/test/java/org/mockito/internal/debugging/LoggingListenerTest.java
index e2ae6e5..54c5bec 100644
--- a/src/test/java/org/mockito/internal/debugging/LoggingListenerTest.java
+++ b/src/test/java/org/mockito/internal/debugging/LoggingListenerTest.java
@@ -4,41 +4,41 @@
  */
 package org.mockito.internal.debugging;
 
+import static org.junit.Assert.assertEquals;
 
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class LoggingListenerTest extends TestBase {
 
     @Test
     public void may_not_have_any_information() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(true);
 
-        //expect
+        // expect
         assertEquals("", listener.getStubbingInfo());
     }
 
     @Test
     public void informs_about_unused_stubs() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(false);
 
-        //when
+        // when
         listener.foundUnusedStub(invocationAt("at com.FooTest:30"));
         listener.foundUnusedStub(invocationAt("at com.FooTest:32"));
 
-        //then
+        // then
         assertEquals(
-            "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
-            "[Mockito]\n" +
-            "[Mockito] Unused stubbing (perhaps can be removed from the test?):\n" +
-            "[Mockito]\n" +
-            "[Mockito] 1. at com.FooTest:30\n" +
-            "[Mockito] 2. at com.FooTest:32", listener.getStubbingInfo());
+                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Unused stubbing (perhaps can be removed from the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. at com.FooTest:30\n"
+                        + "[Mockito] 2. at com.FooTest:32",
+                listener.getStubbingInfo());
     }
 
     @Test
@@ -51,79 +51,85 @@ public class LoggingListenerTest extends TestBase {
 
     @Test
     public void informs_about_unused_stubs_due_arg_mismatch() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(false);
 
-        //when
-        listener.foundStubCalledWithDifferentArgs(invocationAt("at com.FooTest:20"), invocationMatcherAt("at com.Foo:100"));
-        listener.foundStubCalledWithDifferentArgs(invocationAt("at com.FooTest:21"), invocationMatcherAt("at com.Foo:121"));
+        // when
+        listener.foundStubCalledWithDifferentArgs(
+                invocationAt("at com.FooTest:20"), invocationMatcherAt("at com.Foo:100"));
+        listener.foundStubCalledWithDifferentArgs(
+                invocationAt("at com.FooTest:21"), invocationMatcherAt("at com.Foo:121"));
 
-        //then
+        // then
         assertEquals(
-            "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
-            "[Mockito]\n" +
-            "[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):\n" +
-            "[Mockito]\n" +
-            "[Mockito] 1. Stubbed at com.FooTest:20\n" +
-            "[Mockito]    Invoked at com.Foo:100\n" +
-            "[Mockito] 2. Stubbed at com.FooTest:21\n" +
-            "[Mockito]    Invoked at com.Foo:121", listener.getStubbingInfo());
+                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. Stubbed at com.FooTest:20\n"
+                        + "[Mockito]    Invoked at com.Foo:100\n"
+                        + "[Mockito] 2. Stubbed at com.FooTest:21\n"
+                        + "[Mockito]    Invoked at com.Foo:121",
+                listener.getStubbingInfo());
     }
 
     @Test
     public void informs_about_various_kinds_of_stubs() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(true);
 
-        //when
+        // when
         listener.foundUnusedStub(invocationAt("at com.FooTest:30"));
-        listener.foundStubCalledWithDifferentArgs(invocationAt("at com.FooTest:20"), invocationMatcherAt("at com.Foo:100"));
+        listener.foundStubCalledWithDifferentArgs(
+                invocationAt("at com.FooTest:20"), invocationMatcherAt("at com.Foo:100"));
         listener.foundUnstubbed(invocationMatcherAt("at com.Foo:96"));
 
-        //then
+        // then
         assertEquals(
-            "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
-            "[Mockito]\n" +
-            "[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):\n" +
-            "[Mockito]\n" +
-            "[Mockito] 1. Stubbed at com.FooTest:20\n" +
-            "[Mockito]    Invoked at com.Foo:100\n" +
-            "[Mockito]\n" +
-            "[Mockito] Unused stubbing (perhaps can be removed from the test?):\n" +
-            "[Mockito]\n" +
-            "[Mockito] 1. at com.FooTest:30\n" +
-            "[Mockito]\n" +
-            "[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):\n" +
-            "[Mockito]\n" +
-            "[Mockito] 1. at com.Foo:96", listener.getStubbingInfo());
+                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Argument mismatch between stubbing and actual invocation (is stubbing correct in the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. Stubbed at com.FooTest:20\n"
+                        + "[Mockito]    Invoked at com.Foo:100\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Unused stubbing (perhaps can be removed from the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. at com.FooTest:30\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. at com.Foo:96",
+                listener.getStubbingInfo());
     }
 
     @Test
     public void hides_unstubbed() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(false);
 
-        //when
+        // when
         listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());
 
-        //then
+        // then
         assertEquals("", listener.getStubbingInfo());
     }
 
     @Test
     public void informs_about_unstubbed() {
-        //given
+        // given
         LoggingListener listener = new LoggingListener(true);
 
-        //when
+        // when
         listener.foundUnstubbed(invocationMatcherAt("com.Foo:20"));
 
-        //then
+        // then
         assertEquals(
-                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
-                "[Mockito]\n" +
-                "[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):\n" +
-                "[Mockito]\n" +
-                "[Mockito] 1. com.Foo:20", listener.getStubbingInfo());
+                "[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] Unstubbed method invocations (perhaps missing stubbing in the test?):\n"
+                        + "[Mockito]\n"
+                        + "[Mockito] 1. com.Foo:20",
+                listener.getStubbingInfo());
     }
 }
diff --git a/src/test/java/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java b/src/test/java/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java
index 83ef473..2fb7a0d 100644
--- a/src/test/java/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java
+++ b/src/test/java/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal.debugging;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -13,11 +18,6 @@ import org.mockito.internal.invocation.StubInfoImpl;
 import org.mockito.invocation.DescribedInvocation;
 import org.mockito.invocation.Invocation;
 
-import java.io.ByteArrayOutputStream;
-import java.io.PrintStream;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class VerboseMockInvocationLoggerTest {
 
     private VerboseMockInvocationLogger listener;
@@ -57,7 +57,8 @@ public class VerboseMockInvocationLoggerTest {
     @Test
     public void should_print_invocation_with_exception() {
         // when
-        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
+        listener.reportInvocation(
+                new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
 
         // then
         assertThat(printed())
@@ -87,13 +88,16 @@ public class VerboseMockInvocationLoggerTest {
     @Test
     public void should_log_count_of_interactions() {
         // when & then
-        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
+        listener.reportInvocation(
+                new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
         assertThat(printed()).contains("#1");
 
-        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
+        listener.reportInvocation(
+                new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
         assertThat(printed()).contains("#2");
 
-        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
+        listener.reportInvocation(
+                new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));
         assertThat(printed()).contains("#3");
     }
 
diff --git a/src/test/java/org/mockito/internal/debugging/WarningsFinderTest.java b/src/test/java/org/mockito/internal/debugging/WarningsFinderTest.java
index e0a6352..c8fd02f 100644
--- a/src/test/java/org/mockito/internal/debugging/WarningsFinderTest.java
+++ b/src/test/java/org/mockito/internal/debugging/WarningsFinderTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockito.internal.debugging;
 
+import static java.util.Arrays.asList;
+
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.verify;
+
+import java.util.Arrays;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.internal.invocation.InvocationBuilder;
@@ -12,12 +19,6 @@ import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-
-import static java.util.Arrays.asList;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verify;
-
 public class WarningsFinderTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -29,7 +30,8 @@ public class WarningsFinderTest extends TestBase {
         Invocation unusedStub = new InvocationBuilder().simpleMethod().toInvocation();
 
         // when
-        WarningsFinder finder = new WarningsFinder(asList(unusedStub), Arrays.<InvocationMatcher>asList());
+        WarningsFinder finder =
+                new WarningsFinder(asList(unusedStub), Arrays.<InvocationMatcher>asList());
         finder.find(listener);
 
         // then
@@ -39,10 +41,14 @@ public class WarningsFinderTest extends TestBase {
     @Test
     public void shouldPrintUnstubbedInvocation() {
         // given
-        InvocationMatcher unstubbedInvocation = new InvocationBuilder().differentMethod().toInvocationMatcher();
+        InvocationMatcher unstubbedInvocation =
+                new InvocationBuilder().differentMethod().toInvocationMatcher();
 
         // when
-        WarningsFinder finder = new WarningsFinder(Arrays.<Invocation>asList(), Arrays.<InvocationMatcher>asList(unstubbedInvocation));
+        WarningsFinder finder =
+                new WarningsFinder(
+                        Arrays.<Invocation>asList(),
+                        Arrays.<InvocationMatcher>asList(unstubbedInvocation));
         finder.find(listener);
 
         // then
@@ -53,10 +59,14 @@ public class WarningsFinderTest extends TestBase {
     public void shouldPrintStubWasUsedWithDifferentArgs() {
         // given
         Invocation stub = new InvocationBuilder().arg("foo").mock(mock).toInvocation();
-        InvocationMatcher wrongArg = new InvocationBuilder().arg("bar").mock(mock).toInvocationMatcher();
+        InvocationMatcher wrongArg =
+                new InvocationBuilder().arg("bar").mock(mock).toInvocationMatcher();
 
         // when
-        WarningsFinder finder = new WarningsFinder(Arrays.<Invocation> asList(stub), Arrays.<InvocationMatcher> asList(wrongArg));
+        WarningsFinder finder =
+                new WarningsFinder(
+                        Arrays.<Invocation>asList(stub),
+                        Arrays.<InvocationMatcher>asList(wrongArg));
         finder.find(listener);
 
         // then
diff --git a/src/test/java/org/mockito/internal/exceptions/ReporterTest.java b/src/test/java/org/mockito/internal/exceptions/ReporterTest.java
index c0bb512..9e4ca23 100644
--- a/src/test/java/org/mockito/internal/exceptions/ReporterTest.java
+++ b/src/test/java/org/mockito/internal/exceptions/ReporterTest.java
@@ -2,14 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.stubbing.answers.Returns;
@@ -17,69 +22,181 @@ import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.lang.reflect.Field;
-import java.util.Collections;
-
-import static org.mockito.Mockito.mock;
-
 public class ReporterTest extends TestBase {
 
-    @Test(expected = TooLittleActualInvocations.class)
-    public void should_let_passing_null_last_actual_stack_trace() throws Exception {
-        throw Reporter.tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);
+    @Test
+    public void should_let_passing_null_last_actual_stack_trace() {
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.tooFewActualInvocations(
+                                    new org.mockito.internal.reporting.Discrepancy(1, 2),
+                                    new InvocationBuilder().toInvocation(),
+                                    null);
+                        })
+                .isInstanceOf(TooFewActualInvocations.class)
+                .hasMessageContainingAll(
+                        "iMethods.simpleMethod();", "Wanted 1 time:", "But was 2 times:");
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_throw_correct_exception_for_null_invocation_listener() throws Exception {
-        throw Reporter.methodDoesNotAcceptParameter("invocationListeners", "null vararg array");
+    @Test
+    public void should_throw_correct_exception_for_null_invocation_listener() {
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.methodDoesNotAcceptParameter(
+                                    "invocationListeners", "null vararg array");
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "invocationListeners() does not accept null vararg array See the Javadoc.");
     }
 
-    @Test(expected = NoInteractionsWanted.class)
-    public void can_use_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        throw Reporter.noMoreInteractionsWanted(invocation_with_bogus_default_answer, Collections.<VerificationAwareInvocation>emptyList());
+    @Test
+    public void
+            can_use_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted() {
+        Invocation invocation_with_bogus_default_answer =
+                new InvocationBuilder()
+                        .mock(mock(IMethods.class, new Returns(false)))
+                        .toInvocation();
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.noMoreInteractionsWanted(
+                                    invocation_with_bogus_default_answer,
+                                    Collections.<VerificationAwareInvocation>emptyList());
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContainingAll(
+                        "No interactions wanted here:",
+                        "But found this interaction on mock 'iMethods':");
     }
 
-    @Test(expected = VerificationInOrderFailure.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        throw Reporter.noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer);
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() {
+        Invocation invocation_with_bogus_default_answer =
+                new InvocationBuilder()
+                        .mock(mock(IMethods.class, new Returns(false)))
+                        .toInvocation();
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.noMoreInteractionsWantedInOrder(
+                                    invocation_with_bogus_default_answer);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "No interactions wanted here:",
+                        "But found this interaction on mock 'iMethods':");
     }
 
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_invalid_argument_position() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation_with_bogus_default_answer, true, 0);
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_invalid_argument_position() {
+        Invocation invocation_with_bogus_default_answer =
+                new InvocationBuilder()
+                        .mock(mock(IMethods.class, new Returns(false)))
+                        .toInvocation();
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.invalidArgumentPositionRangeAtInvocationTime(
+                                    invocation_with_bogus_default_answer, true, 0);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Invalid argument index for the current invocation of method :",
+                        " -> iMethods.simpleMethod()",
+                        "Last parameter wanted but the method has no arguments.");
     }
 
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_wrong_argument_to_return() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        throw Reporter.wrongTypeOfArgumentToReturn(invocation_with_bogus_default_answer, "", String.class, 0);
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_wrong_argument_to_return() {
+        Invocation invocation_with_bogus_default_answer =
+                new InvocationBuilder()
+                        .mock(mock(IMethods.class, new Returns(false)))
+                        .toInvocation();
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.wrongTypeOfArgumentToReturn(
+                                    invocation_with_bogus_default_answer, "", String.class, 0);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "The argument of type 'String' cannot be returned because the following",
+                        "method should return the type ''",
+                        " -> iMethods.simpleMethod()",
+                        "The reason for this error can be :",
+                        "1. The wanted argument position is incorrect.",
+                        "2. The answer is used on the wrong interaction.",
+                        "Position of the wanted argument is 0 and the method has no arguments.");
     }
 
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_dont_exists() throws Exception {
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_dont_exists() {
         Invocation dumb_invocation = new InvocationBuilder().toInvocation();
         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        throw Reporter.delegatedMethodDoesNotExistOnDelegate(dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.delegatedMethodDoesNotExistOnDelegate(
+                                    dumb_invocation.getMethod(),
+                                    mock_with_bogus_default_answer,
+                                    String.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Methods called on mock must exist in delegated instance.",
+                        "When calling: public abstract java.lang.String org.mockitousage.IMethods.simpleMethod() on mock: iMethods",
+                        "no such method was found.",
+                        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                        "(delegate instance had type: Class)");
     }
 
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_has_wrong_return_type() throws Exception {
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_has_wrong_return_type() {
         Invocation dumb_invocation = new InvocationBuilder().toInvocation();
         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        throw Reporter.delegatedMethodHasWrongReturnType(dumb_invocation.getMethod(), dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.delegatedMethodHasWrongReturnType(
+                                    dumb_invocation.getMethod(),
+                                    dumb_invocation.getMethod(),
+                                    mock_with_bogus_default_answer,
+                                    String.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Methods called on delegated instance must have compatible return types with the mock.",
+                        "When calling: public abstract java.lang.String org.mockitousage.IMethods.simpleMethod() on mock: iMethods",
+                        "return type should be: String, but was: String",
+                        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                        "(delegate instance had type: Class)");
     }
 
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_injection_failure() throws Exception {
+    @Test
+    public void
+            can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_injection_failure() {
         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        throw Reporter.cannotInjectDependency(someField(), mock_with_bogus_default_answer, new Exception());
+
+        assertThatThrownBy(
+                        () -> {
+                            throw Reporter.cannotInjectDependency(
+                                    someField(), mock_with_bogus_default_answer, new Exception());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Mockito couldn't inject mock dependency 'iMethods' on field",
+                        "'static final org.mockito.internal.MockitoCore org.mockito.Mockito.MOCKITO_CORE'",
+                        "whose type 'org.mockito.Mockito' was annotated by @InjectMocks in your test.",
+                        "Also I failed because: null");
     }
 
     private Field someField() {
         return Mockito.class.getDeclaredFields()[0];
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilterTest.java b/src/test/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilterTest.java
index a92bf1f..064bca5 100644
--- a/src/test/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilterTest.java
+++ b/src/test/java/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilterTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.exceptions.stacktrace;
 
+import static org.mockitoutil.Conditions.onlyThoseClassesInStackTrace;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.base.TraceBuilder;
 import org.mockito.internal.configuration.ConfigurationAccess;
 import org.mockitoutil.TestBase;
 
-import static org.mockitoutil.Conditions.onlyThoseClassesInStackTrace;
-
 public class ConditionalStackTraceFilterTest extends TestBase {
 
     private ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
@@ -20,24 +20,27 @@ public class ConditionalStackTraceFilterTest extends TestBase {
     public void shouldNotFilterWhenConfigurationSaysNo() {
         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);
 
-        Throwable t = new TraceBuilder().classes(
-                "org.test.MockitoSampleTest",
-                "org.mockito.Mockito"
-        ).toThrowable();
+        Throwable t =
+                new TraceBuilder()
+                        .classes("org.test.MockitoSampleTest", "org.mockito.Mockito")
+                        .toThrowable();
 
         filter.filter(t);
 
-        Assertions.assertThat(t).has(onlyThoseClassesInStackTrace("org.mockito.Mockito", "org.test.MockitoSampleTest"));
+        Assertions.assertThat(t)
+                .has(
+                        onlyThoseClassesInStackTrace(
+                                "org.mockito.Mockito", "org.test.MockitoSampleTest"));
     }
 
     @Test
     public void shouldFilterWhenConfigurationSaysYes() {
         ConfigurationAccess.getConfig().overrideCleansStackTrace(true);
 
-        Throwable t = new TraceBuilder().classes(
-                "org.test.MockitoSampleTest",
-                "org.mockito.Mockito"
-        ).toThrowable();
+        Throwable t =
+                new TraceBuilder()
+                        .classes("org.test.MockitoSampleTest", "org.mockito.Mockito")
+                        .toThrowable();
 
         filter.filter(t);
 
diff --git a/src/test/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java b/src/test/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java
index a039bb4..589c03c 100644
--- a/src/test/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java
+++ b/src/test/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java
@@ -2,27 +2,26 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.exceptions.stacktrace;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockitoutil.Conditions.onlyThoseClasses;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.base.TraceBuilder;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockitoutil.Conditions.onlyThoseClasses;
-
 public class StackTraceFilterTest extends TestBase {
 
     private final StackTraceFilter filter = new StackTraceFilter();
 
     @Test
     public void shouldFilterOutCglibGarbage() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-            "MockitoExampleTest",
-            "List$$EnhancerByMockitoWithCGLIB$$2c406024"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes("MockitoExampleTest", "List$$EnhancerByMockitoWithCGLIB$$2c406024")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
@@ -31,23 +30,24 @@ public class StackTraceFilterTest extends TestBase {
 
     @Test
     public void shouldFilterOutByteBuddyGarbage() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "MockitoExampleTest",
-                "org.testcase.MockedClass$MockitoMock$1882975947.doSomething(Unknown Source)"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "MockitoExampleTest",
+                                "org.testcase.MockedClass$MockitoMock$1882975947.doSomething(Unknown Source)")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
         Assertions.assertThat(filtered).has(onlyThoseClasses("MockitoExampleTest"));
     }
 
-
     @Test
     public void shouldFilterOutMockitoPackage() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-            "org.test.MockitoSampleTest",
-            "org.mockito.Mockito"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes("org.test.MockitoSampleTest", "org.mockito.Mockito")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
@@ -56,100 +56,134 @@ public class StackTraceFilterTest extends TestBase {
 
     @Test
     public void shouldNotFilterOutTracesMiddleGoodTraces() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.test.MockitoSampleTest",
-                "org.test.TestSupport",
-                "org.mockito.Mockito",
-                "org.test.TestSupport",
-                "org.mockito.Mockito"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.test.MockitoSampleTest",
+                                "org.test.TestSupport",
+                                "org.mockito.Mockito",
+                                "org.test.TestSupport",
+                                "org.mockito.Mockito")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
-        Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.TestSupport", "org.test.TestSupport", "org.test.MockitoSampleTest"));
+        Assertions.assertThat(filtered)
+                .has(
+                        onlyThoseClasses(
+                                "org.test.TestSupport",
+                                "org.test.TestSupport",
+                                "org.test.MockitoSampleTest"));
     }
 
     @Test
     public void shouldKeepRunners() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.mockito.runners.Runner",
-                "junit.stuff",
-                "org.test.MockitoSampleTest",
-                "org.mockito.Mockito"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.mockito.runners.Runner",
+                                "junit.stuff",
+                                "org.test.MockitoSampleTest",
+                                "org.mockito.Mockito")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
-        Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "junit.stuff", "org.mockito.runners.Runner"));
+        Assertions.assertThat(filtered)
+                .has(
+                        onlyThoseClasses(
+                                "org.test.MockitoSampleTest",
+                                "junit.stuff",
+                                "org.mockito.runners.Runner"));
     }
 
     @Test
     public void shouldNotFilterElementsAboveMockitoJUnitRule() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:16)",
-                "org.mockito.runners.Runner",
-                "junit.stuff",
-                "org.test.MockitoSampleTest",
-                "org.mockito.internal.MockitoCore.verifyNoMoreInteractions",
-                "org.mockito.internal.debugging.LocationImpl"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:16)",
+                                "org.mockito.runners.Runner",
+                                "junit.stuff",
+                                "org.test.MockitoSampleTest",
+                                "org.mockito.internal.MockitoCore.verifyNoMoreInteractions",
+                                "org.mockito.internal.debugging.LocationImpl")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
-        Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "junit.stuff", "org.mockito.runners.Runner","org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:16)"));
+        Assertions.assertThat(filtered)
+                .has(
+                        onlyThoseClasses(
+                                "org.test.MockitoSampleTest",
+                                "junit.stuff",
+                                "org.mockito.runners.Runner",
+                                "org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:16)"));
     }
 
     @Test
     public void shouldKeepInternalRunners() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.mockito.internal.runners.Runner",
-                "org.test.MockitoSampleTest"
-        ).toTraceArray();
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.mockito.internal.runners.Runner", "org.test.MockitoSampleTest")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, false);
 
-        Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "org.mockito.internal.runners.Runner"));
+        Assertions.assertThat(filtered)
+                .has(
+                        onlyThoseClasses(
+                                "org.test.MockitoSampleTest",
+                                "org.mockito.internal.runners.Runner"));
     }
 
     @Test
     public void shouldStartFilteringAndKeepTop() {
-        //given
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.test.Good",
-                "org.mockito.internal.Bad",
-                "org.test.MockitoSampleTest"
-        ).toTraceArray();
-
-        //when
+        // given
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.test.Good",
+                                "org.mockito.internal.Bad",
+                                "org.test.MockitoSampleTest")
+                        .toTraceArray();
+
+        // when
         StackTraceElement[] filtered = filter.filter(t, true);
 
-        //then
-        Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "org.test.Good"));
+        // then
+        Assertions.assertThat(filtered)
+                .has(onlyThoseClasses("org.test.MockitoSampleTest", "org.test.Good"));
     }
 
     @Test
-    public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions() {
-        StackTraceElement[] t = new TraceBuilder().classes(
-                "org.good.Trace",
-                "org.yet.another.good.Trace",
-                "org.mockito.internal.to.be.Filtered",
-                "org.test.MockitoSampleTest"
-        ).toTraceArray();
+    public void
+            shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions() {
+        StackTraceElement[] t =
+                new TraceBuilder()
+                        .classes(
+                                "org.good.Trace",
+                                "org.yet.another.good.Trace",
+                                "org.mockito.internal.to.be.Filtered",
+                                "org.test.MockitoSampleTest")
+                        .toTraceArray();
 
         StackTraceElement[] filtered = filter.filter(t, true);
 
-        Assertions.assertThat(filtered).has(onlyThoseClasses(
-                "org.test.MockitoSampleTest",
-                "org.yet.another.good.Trace",
-                "org.good.Trace"
-                ));
+        Assertions.assertThat(filtered)
+                .has(
+                        onlyThoseClasses(
+                                "org.test.MockitoSampleTest",
+                                "org.yet.another.good.Trace",
+                                "org.good.Trace"));
     }
 
     @Test
     public void shouldReturnEmptyArrayWhenInputIsEmpty() throws Exception {
-        //when
+        // when
         StackTraceElement[] filtered = filter.filter(new StackTraceElement[0], false);
-        //then
+        // then
         assertEquals(0, filtered.length);
     }
 }
diff --git a/src/test/java/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java b/src/test/java/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java
index f0e22d4..68df193 100644
--- a/src/test/java/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java
+++ b/src/test/java/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java
@@ -4,16 +4,17 @@
  */
 package org.mockito.internal.exceptions.util;
 
+import static java.util.Arrays.asList;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
 @SuppressWarnings("unchecked")
 public class ScenarioPrinterTest extends TestBase {
 
@@ -21,28 +22,26 @@ public class ScenarioPrinterTest extends TestBase {
 
     @Test
     public void shouldPrintInvocations() {
-        //given
+        // given
         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();
         Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();
 
-        //when
+        // when
         String out = sp.print((List) asList(verified, unverified));
 
-        //then
-        assertThat(out)
-            .contains("1. -> at")
-            .contains("2. [?]-> at");
+        // then
+        assertThat(out).contains("1. -> at").contains("2. [?]-> at");
     }
 
     @Test
     public void shouldNotPrintInvocationsWhenSingleUnwanted() {
-        //given
+        // given
         Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();
 
-        //when
+        // when
         String out = sp.print((List) asList(unverified));
 
-        //then
+        // then
         assertThat(out).contains("Actually, above is the only interaction with this mock.");
     }
 }
diff --git a/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java b/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
index ae21488..3b2884e 100644
--- a/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
+++ b/src/test/java/org/mockito/internal/framework/DefaultMockitoFrameworkTest.java
@@ -4,6 +4,22 @@
  */
 package org.mockito.internal.framework;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.mockingDetails;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.withSettings;
+import static org.mockitoutil.ThrowableAssert.assertThat;
+
+import java.util.List;
+import java.util.Set;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.ArgumentMatchers;
@@ -17,42 +33,38 @@ import org.mockito.mock.MockCreationSettings;
 import org.mockito.plugins.InlineMockMaker;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-import java.util.Set;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.mockingDetails;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.withSettings;
-import static org.mockitoutil.ThrowableAssert.assertThat;
-
 public class DefaultMockitoFrameworkTest extends TestBase {
 
     private DefaultMockitoFramework framework = new DefaultMockitoFramework();
 
-    @After public void clearListeners() {
+    @After
+    public void clearListeners() {
         new StateMaster().clearMockitoListeners();
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
     public void prevents_adding_null_listener() {
-        framework.addListener(null);
+        assertThatThrownBy(
+                        () -> {
+                            framework.addListener(null);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("listener should not be null");
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
     public void prevents_removing_null_listener() {
-        framework.removeListener(null);
+        assertThatThrownBy(
+                        () -> {
+                            framework.removeListener(null);
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("listener should not be null");
     }
 
     @Test
     public void ok_to_remove_unknown_listener() {
-        //it is safe to remove listener that was not added before
+        // it is safe to remove listener that was not added before
         framework.removeListener(new MockitoListener() {});
     }
 
@@ -60,26 +72,26 @@ public class DefaultMockitoFrameworkTest extends TestBase {
     public void ok_to_remove_listener_multiple_times() {
         MockitoListener listener = new MockitoListener() {};
 
-        //when
+        // when
         framework.addListener(listener);
 
-        //then it is ok to:
+        // then it is ok to:
         framework.removeListener(listener);
         framework.removeListener(listener);
     }
 
     @Test
     public void adds_creation_listener() {
-        //given creation listener is added
+        // given creation listener is added
         MockCreationListener listener = mock(MockCreationListener.class);
         framework.addListener(listener);
 
-        //when
+        // when
         MockSettings settings = withSettings().name("my list");
         List mock = mock(List.class, settings);
         Set mock2 = mock(Set.class);
 
-        //then
+        // then
         verify(listener).onMockCreated(eq(mock), any(MockCreationSettings.class));
         verify(listener).onMockCreated(eq(mock2), any(MockCreationSettings.class));
         verifyNoMoreInteractions(listener);
@@ -88,84 +100,88 @@ public class DefaultMockitoFrameworkTest extends TestBase {
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void removes_creation_listener() {
-        //given creation listener is added
+        // given creation listener is added
         MockCreationListener listener = mock(MockCreationListener.class);
         framework.addListener(listener);
 
-        //and hooked up correctly
+        // and hooked up correctly
         mock(List.class);
         verify(listener).onMockCreated(ArgumentMatchers.any(), any(MockCreationSettings.class));
 
-        //when
+        // when
         framework.removeListener(listener);
         mock(Set.class);
 
-        //then
+        // then
         verifyNoMoreInteractions(listener);
     }
 
-    @Test public void prevents_duplicate_listeners_of_the_same_type() {
-        //given creation listener is added
+    @Test
+    public void prevents_duplicate_listeners_of_the_same_type() {
+        // given creation listener is added
         framework.addListener(new MyListener());
 
-        assertThat(new Runnable() {
-            @Override
-            public void run() {
-                framework.addListener(new MyListener());
-            }
-        })  .throwsException(RedundantListenerException.class)
-            .throwsMessage("\n" +
-                    "Problems adding Mockito listener.\n" +
-                    "Listener of type 'MyListener' has already been added and not removed.\n" +
-                    "It indicates that previous listener was not removed according to the API.\n" +
-                    "When you add a listener, don't forget to remove the listener afterwards:\n" +
-                    "  Mockito.framework().removeListener(myListener);\n" +
-                    "For more information, see the javadoc for RedundantListenerException class.");
+        assertThat(
+                        new Runnable() {
+                            @Override
+                            public void run() {
+                                framework.addListener(new MyListener());
+                            }
+                        })
+                .throwsException(RedundantListenerException.class)
+                .throwsMessage(
+                        "\n"
+                                + "Problems adding Mockito listener.\n"
+                                + "Listener of type 'MyListener' has already been added and not removed.\n"
+                                + "It indicates that previous listener was not removed according to the API.\n"
+                                + "When you add a listener, don't forget to remove the listener afterwards:\n"
+                                + "  Mockito.framework().removeListener(myListener);\n"
+                                + "For more information, see the javadoc for RedundantListenerException class.");
     }
 
     @Test
     public void clearing_all_mocks_is_safe_regardless_of_mock_maker_type() {
         List mock = mock(List.class);
 
-        //expect
+        // expect
         assertTrue(mockingDetails(mock).isMock());
         framework.clearInlineMocks();
     }
 
     @Test
     public void clears_all_mocks() {
-        //clearing mocks only works with inline mocking
+        // clearing mocks only works with inline mocking
         assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
 
-        //given
+        // given
         List list1 = mock(List.class);
         assertTrue(mockingDetails(list1).isMock());
         List list2 = mock(List.class);
         assertTrue(mockingDetails(list2).isMock());
 
-        //when
+        // when
         framework.clearInlineMocks();
 
-        //then
+        // then
         assertFalse(mockingDetails(list1).isMock());
         assertFalse(mockingDetails(list2).isMock());
     }
 
     @Test
     public void clears_mock() {
-        //clearing mocks only works with inline mocking
+        // clearing mocks only works with inline mocking
         assumeTrue(Plugins.getMockMaker() instanceof InlineMockMaker);
 
-        //given
+        // given
         List list1 = mock(List.class);
         assertTrue(mockingDetails(list1).isMock());
         List list2 = mock(List.class);
         assertTrue(mockingDetails(list2).isMock());
 
-        //when
+        // when
         framework.clearInlineMock(list1);
 
-        //then
+        // then
         assertFalse(mockingDetails(list1).isMock());
         assertTrue(mockingDetails(list2).isMock());
     }
diff --git a/src/test/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractorTest.java b/src/test/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractorTest.java
index 1ae96ed..154a7bc 100644
--- a/src/test/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractorTest.java
+++ b/src/test/java/org/mockito/internal/hamcrest/MatcherGenericTypeExtractorTest.java
@@ -4,93 +4,106 @@
  */
 package org.mockito.internal.hamcrest;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.internal.hamcrest.MatcherGenericTypeExtractor.genericTypeOfMatcher;
+
+import java.io.Serializable;
+import java.util.HashMap;
+
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
 import org.hamcrest.Matcher;
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import java.io.Serializable;
-import java.util.HashMap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.internal.hamcrest.MatcherGenericTypeExtractor.genericTypeOfMatcher;
-
 public class MatcherGenericTypeExtractorTest extends TestBase {
 
-    //traditional inner class for matcher
+    // traditional inner class for matcher
     private class IntMatcher extends BaseMatcher<Integer> {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
-    //static class with matcher
+    // static class with matcher
     private static class StaticIntMatcher extends BaseMatcher<Integer> {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
-    //static subclass
+    // static subclass
     private static class StaticIntMatcherSubclass extends StaticIntMatcher {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
-    //non-generic
+    // non-generic
     @SuppressWarnings("rawtypes")
     private static class NonGenericMatcher extends BaseMatcher {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
-    //Matcher interface implementation (instead of the BaseMatcher)
+    // Matcher interface implementation (instead of the BaseMatcher)
     private class IntMatcherFromInterface extends BaseMatcher<Integer> {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeMismatch(Object item, Description mismatchDescription) {}
+
         public void describeTo(Description description) {}
     }
 
-    //Static Matcher interface implementation (instead of the BaseMatcher)
+    // Static Matcher interface implementation (instead of the BaseMatcher)
     private static class StaticIntMatcherFromInterface extends BaseMatcher<Integer> {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeMismatch(Object item, Description mismatchDescription) {}
+
         public void describeTo(Description description) {}
     }
 
-    //non-generic matcher implementing the interface
+    // non-generic matcher implementing the interface
     @SuppressWarnings("rawtypes")
     private static class NonGenericMatcherFromInterface extends BaseMatcher {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeMismatch(Object item, Description mismatchDescription) {}
+
         public void describeTo(Description description) {}
     }
 
     private interface IMatcher extends Matcher<Integer> {}
 
-    //non-generic matcher implementing the interface
-    private static class SubclassGenericMatcherFromInterface extends BaseMatcher<Integer> implements Serializable, Cloneable, IMatcher {
+    // non-generic matcher implementing the interface
+    private static class SubclassGenericMatcherFromInterface extends BaseMatcher<Integer>
+            implements Serializable, Cloneable, IMatcher {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeMismatch(Object item, Description mismatchDescription) {}
+
         public void describeTo(Description description) {}
     }
 
-    //I refuse to comment on the sanity of this case
+    // I refuse to comment on the sanity of this case
     private static class InsaneEdgeCase extends SubclassGenericMatcherFromInterface {}
 
     @Test
@@ -101,34 +114,39 @@ public class MatcherGenericTypeExtractorTest extends TestBase {
         assertEquals(Integer.class, genericTypeOfMatcher(StaticIntMatcherSubclass.class));
         assertEquals(Integer.class, genericTypeOfMatcher(IntMatcherFromInterface.class));
         assertEquals(Integer.class, genericTypeOfMatcher(StaticIntMatcherFromInterface.class));
-        assertEquals(Integer.class, genericTypeOfMatcher(SubclassGenericMatcherFromInterface.class));
+        assertEquals(
+                Integer.class, genericTypeOfMatcher(SubclassGenericMatcherFromInterface.class));
         assertEquals(Integer.class, genericTypeOfMatcher(InsaneEdgeCase.class));
 
-        assertEquals(Integer.class, genericTypeOfMatcher(new BaseMatcher<Integer>() {
-            public void describeTo(Description description) {
-            }
-
-            public boolean matches(Object o) {
-                return false;
-            }
-        }.getClass()));
-        assertEquals(Integer.class, genericTypeOfMatcher(new BaseMatcher<Integer>() {
-            public void describeTo(Description description) {
-            }
-
-            public boolean matches(Object o) {
-                return false;
-            }
-
-            public void describeMismatch(Object item, Description mismatchDescription) {
-            }
-        }.getClass()));
+        assertEquals(
+                Integer.class,
+                genericTypeOfMatcher(
+                        new BaseMatcher<Integer>() {
+                            public void describeTo(Description description) {}
+
+                            public boolean matches(Object o) {
+                                return false;
+                            }
+                        }.getClass()));
+        assertEquals(
+                Integer.class,
+                genericTypeOfMatcher(
+                        new BaseMatcher<Integer>() {
+                            public void describeTo(Description description) {}
+
+                            public boolean matches(Object o) {
+                                return false;
+                            }
+
+                            public void describeMismatch(
+                                    Object item, Description mismatchDescription) {}
+                        }.getClass()));
 
         assertEquals(Object.class, genericTypeOfMatcher(Object.class));
         assertEquals(Object.class, genericTypeOfMatcher(String.class));
         assertEquals(Object.class, genericTypeOfMatcher(HashMap.class));
-        assertEquals(Object.class, genericTypeOfMatcher(new HashMap<String, String>() {
-        }.getClass()));
+        assertEquals(
+                Object.class, genericTypeOfMatcher(new HashMap<String, String>() {}.getClass()));
         assertEquals(Object.class, genericTypeOfMatcher(NonGenericMatcher.class));
         assertEquals(Object.class, genericTypeOfMatcher(NonGenericMatcherFromInterface.class));
     }
diff --git a/src/test/java/org/mockito/internal/handler/InvocationNotifierHandlerTest.java b/src/test/java/org/mockito/internal/handler/InvocationNotifierHandlerTest.java
index 8fe818d..54e8394 100644
--- a/src/test/java/org/mockito/internal/handler/InvocationNotifierHandlerTest.java
+++ b/src/test/java/org/mockito/internal/handler/InvocationNotifierHandlerTest.java
@@ -4,6 +4,18 @@
  */
 package org.mockito.internal.handler;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.willThrow;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.text.ParseException;
+import java.util.ArrayList;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,18 +30,6 @@ import org.mockito.listeners.MethodInvocationReport;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
-import java.text.ParseException;
-import java.util.ArrayList;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-
 @RunWith(MockitoJUnitRunner.class)
 @SuppressWarnings("unchecked")
 public class InvocationNotifierHandlerTest {
@@ -38,7 +38,6 @@ public class InvocationNotifierHandlerTest {
     private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();
     private static final Answer<?> SOME_ANSWER = mock(Answer.class);
 
-
     @Mock private InvocationListener listener1;
     @Mock private InvocationListener listener2;
     @Spy private CustomListener customListener;
@@ -50,10 +49,12 @@ public class InvocationNotifierHandlerTest {
 
     @Before
     public void setUp() throws Exception {
-        notifier = new InvocationNotifierHandler<ArrayList<Answer<?>>>(
-                mockHandler,
-                (MockCreationSettings<ArrayList<Answer<?>>>) new MockSettingsImpl<ArrayList<Answer<?>>>().invocationListeners(customListener, listener1, listener2)
-        );
+        notifier =
+                new InvocationNotifierHandler<>(
+                        mockHandler,
+                        (MockCreationSettings<ArrayList<Answer<?>>>)
+                                new MockSettingsImpl<ArrayList<Answer<?>>>()
+                                        .invocationListeners(customListener, listener1, listener2));
     }
 
     @Test
@@ -65,12 +66,15 @@ public class InvocationNotifierHandlerTest {
         notifier.handle(invocation);
 
         // then
-        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));
-        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));
+        verify(listener1)
+                .reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));
+        verify(listener2)
+                .reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));
     }
 
     @Test
-    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {
+    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex()
+            throws Throwable {
         // given
         Exception computedException = new Exception("computed");
         given(mockHandler.handle(invocation)).willReturn(computedException);
@@ -79,30 +83,42 @@ public class InvocationNotifierHandlerTest {
         notifier.handle(invocation);
 
         // then
-        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));
-        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));
+        verify(listener1)
+                .reportInvocation(
+                        new NotifiedMethodInvocationReport(invocation, (Object) computedException));
+        verify(listener2)
+                .reportInvocation(
+                        new NotifiedMethodInvocationReport(invocation, (Object) computedException));
     }
 
-    @Test(expected = ParseException.class)
-    public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {
+    @Test
+    public void
+            should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it()
+                    throws Throwable {
         // given
         ParseException parseException = new ParseException("", 0);
         given(mockHandler.handle(invocation)).willThrow(parseException);
 
         // when
-        try {
-            notifier.handle(invocation);
-            fail();
-        } finally {
-            // then
-            verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));
-            verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));
-        }
+        assertThatThrownBy(
+                        () -> {
+                            notifier.handle(invocation);
+                        })
+                .isInstanceOf(ParseException.class)
+                .hasMessage("");
+
+        // then
+        verify(listener1)
+                .reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));
+        verify(listener2)
+                .reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));
     }
 
     @Test
     public void should_report_listener_exception() throws Throwable {
-        willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));
+        willThrow(new NullPointerException())
+                .given(customListener)
+                .reportInvocation(any(MethodInvocationReport.class));
 
         try {
             notifier.handle(invocation);
@@ -117,7 +133,7 @@ public class InvocationNotifierHandlerTest {
     }
 
     @Test
-    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {
+    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() {
         notifier.getInvocationContainer();
         notifier.getMockSettings();
 
diff --git a/src/test/java/org/mockito/internal/handler/MockHandlerFactoryTest.java b/src/test/java/org/mockito/internal/handler/MockHandlerFactoryTest.java
index 890a8cb..d82bc78 100644
--- a/src/test/java/org/mockito/internal/handler/MockHandlerFactoryTest.java
+++ b/src/test/java/org/mockito/internal/handler/MockHandlerFactoryTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.handler;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.internal.handler.MockHandlerFactory.createMockHandler;
+
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockito.internal.creation.MockSettingsImpl;
@@ -14,10 +18,6 @@ import org.mockito.mock.MockCreationSettings;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.internal.handler.MockHandlerFactory.createMockHandler;
-
 /**
  * by Szczepan Faber, created at: 5/22/12
  */
@@ -26,37 +26,39 @@ public class MockHandlerFactoryTest extends TestBase {
     private final IMethods mock = Mockito.mock(IMethods.class);
 
     @Test
-    //see issue 331
+    // see issue 331
     public void handle_result_must_not_be_null_for_primitives() throws Throwable {
-        //given:
-        MockCreationSettings<?> settings = (MockCreationSettings<?>) new MockSettingsImpl().defaultAnswer(new Returns(null));
-		MockHandler<?> handler = createMockHandler(settings);
+        // given:
+        MockCreationSettings<?> settings =
+                (MockCreationSettings<?>) new MockSettingsImpl().defaultAnswer(new Returns(null));
+        MockHandler<?> handler = createMockHandler(settings);
 
         mock.intReturningMethod();
         Invocation invocation = super.getLastInvocation();
 
-        //when:
+        // when:
         Object result = handler.handle(invocation);
 
-        //then null value is not a valid result for a primitive
+        // then null value is not a valid result for a primitive
         assertNotNull(result);
         assertEquals(0, result);
     }
 
     @Test
-    //see issue 331
+    // see issue 331
     public void valid_handle_result_is_permitted() throws Throwable {
-        //given:
-        MockCreationSettings<?> settings = (MockCreationSettings<?>) new MockSettingsImpl().defaultAnswer(new Returns(123));
-        MockHandler<?> handler =  createMockHandler(settings);
+        // given:
+        MockCreationSettings<?> settings =
+                (MockCreationSettings<?>) new MockSettingsImpl().defaultAnswer(new Returns(123));
+        MockHandler<?> handler = createMockHandler(settings);
 
         mock.intReturningMethod();
         Invocation invocation = super.getLastInvocation();
 
-        //when:
+        // when:
         Object result = handler.handle(invocation);
 
-        //then
+        // then
         assertEquals(123, result);
     }
 }
diff --git a/src/test/java/org/mockito/internal/handler/MockHandlerImplTest.java b/src/test/java/org/mockito/internal/handler/MockHandlerImplTest.java
index 31e1fe6..a0169c2 100644
--- a/src/test/java/org/mockito/internal/handler/MockHandlerImplTest.java
+++ b/src/test/java/org/mockito/internal/handler/MockHandlerImplTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.handler;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
@@ -14,8 +22,6 @@ import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.invocation.MatchersBinder;
 import org.mockito.internal.progress.ArgumentMatcherStorage;
-import org.mockito.internal.stubbing.InvocationContainerImpl;
-import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.invocation.Invocation;
@@ -23,22 +29,9 @@ import org.mockito.listeners.InvocationListener;
 import org.mockito.listeners.MethodInvocationReport;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-
-@SuppressWarnings({"unchecked", "serial"})
+@SuppressWarnings({"unchecked"})
 public class MockHandlerImplTest extends TestBase {
 
-    private StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);
-    private Invocation invocation = mock(Invocation.class);
-
     @Test
     public void should_remove_verification_mode_even_when_invalid_matchers() throws Throwable {
         // given
@@ -46,11 +39,13 @@ public class MockHandlerImplTest extends TestBase {
         @SuppressWarnings("rawtypes")
         MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());
         mockingProgress().verificationStarted(VerificationModeFactory.atLeastOnce());
-        handler.matchersBinder = new MatchersBinder() {
-            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
-                throw new InvalidUseOfMatchersException();
-            }
-        };
+        handler.matchersBinder =
+                new MatchersBinder() {
+                    public InvocationMatcher bindMatchers(
+                            ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
+                        throw new InvalidUseOfMatchersException();
+                    }
+                };
 
         try {
             // when
@@ -64,53 +59,46 @@ public class MockHandlerImplTest extends TestBase {
         assertNull(mockingProgress().pullVerificationMode());
     }
 
-
-    @Test(expected = MockitoException.class)
-    public void should_throw_mockito_exception_when_invocation_handler_throws_anything() throws Throwable {
+    @Test
+    public void should_throw_mockito_exception_when_invocation_handler_throws_anything() {
         // given
         InvocationListener throwingListener = mock(InvocationListener.class);
-        doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));
-        MockHandlerImpl<?> handler = create_correctly_stubbed_handler(throwingListener);
-
-        // when
-        handler.handle(invocation);
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            doThrow(new Throwable())
+                                    .when(throwingListener)
+                                    .reportInvocation(any(MethodInvocationReport.class));
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Checked exception is invalid for this method!",
+                        "Invalid: java.lang.Throwable");
     }
 
-    @Test(expected = WrongTypeOfReturnValue.class)
+    @Test
     public void should_report_bogus_default_answer() throws Throwable {
+        // given
         MockSettingsImpl mockSettings = mock(MockSettingsImpl.class);
         MockHandlerImpl<?> handler = new MockHandlerImpl(mockSettings);
         given(mockSettings.getDefaultAnswer()).willReturn(new Returns(AWrongType.WRONG_TYPE));
-
-        @SuppressWarnings("unused") // otherwise cast is not done
-        String there_should_not_be_a_CCE_here = (String) handler.handle(
-                new InvocationBuilder().method(Object.class.getDeclaredMethod("toString")).toInvocation()
-        );
-    }
-
-    private MockHandlerImpl<?> create_correctly_stubbed_handler(InvocationListener throwingListener) {
-        MockHandlerImpl<?> handler = create_handler_with_listeners(throwingListener);
-        stub_ordinary_invocation_with_given_return_value(handler);
-        return handler;
-    }
-
-    private void stub_ordinary_invocation_with_given_return_value(MockHandlerImpl<?> handler) {
-        stub_ordinary_invocation_with_invocation_matcher(handler, stubbedInvocationMatcher);
-    }
-
-
-    private void stub_ordinary_invocation_with_invocation_matcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {
-        handler.invocationContainer = mock(InvocationContainerImpl.class);
-        given(handler.invocationContainer.findAnswerFor(any(Invocation.class))).willReturn(value);
-    }
-
-
-    private MockHandlerImpl<?> create_handler_with_listeners(InvocationListener... listener) {
-        @SuppressWarnings("rawtypes")
-        MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));
-        handler.matchersBinder = mock(MatchersBinder.class);
-        given(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));
-        return handler;
+        Invocation invocation =
+                new InvocationBuilder()
+                        .method(Object.class.getDeclaredMethod("toString"))
+                        .toInvocation();
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            @SuppressWarnings("unused") // otherwise cast is not done
+                            String there_should_not_be_a_CCE_here =
+                                    (String) handler.handle(invocation);
+                        })
+                .isInstanceOf(WrongTypeOfReturnValue.class)
+                .hasMessageContainingAll(
+                        "Default answer returned a result with the wrong type:",
+                        "AWrongType cannot be returned by toString()",
+                        "toString() should return String",
+                        "The default answer of iMethods that was configured on the mock is probably incorrectly implemented.");
     }
 
     private static class AWrongType {
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
index b3106a6..281d41b 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
@@ -2,22 +2,23 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
-import org.mockito.Mockito;
-import org.mockito.internal.invocation.mockref.MockStrongReference;
-import org.mockito.internal.debugging.LocationImpl;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.Location;
-import org.mockitousage.IMethods;
+import static java.util.Arrays.asList;
+
+import static org.mockito.internal.invocation.InterceptedInvocation.NO_OP;
 
 import java.lang.reflect.Method;
 import java.util.LinkedList;
 import java.util.List;
 
-import static java.util.Arrays.asList;
-import static org.mockito.internal.invocation.InterceptedInvocation.NO_OP;
+import org.mockito.Mockito;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.mockref.MockReference;
+import org.mockito.internal.invocation.mockref.MockStrongReference;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
+import org.mockitousage.IMethods;
 
 /**
  * Build an invocation.
@@ -27,7 +28,7 @@ public class InvocationBuilder {
 
     private String methodName = "simpleMethod";
     private int sequenceNumber = 0;
-    private Object[] args = new Object[]{};
+    private Object[] args = new Object[] {};
     private Object mock = Mockito.mock(IMethods.class);
     private Method method;
     private boolean verified;
@@ -55,24 +56,40 @@ public class InvocationBuilder {
             }
 
             try {
-                method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));
+                method =
+                        IMethods.class.getMethod(
+                                methodName, argTypes.toArray(new Class[argTypes.size()]));
             } catch (Exception e) {
-                throw new RuntimeException("builder only creates invocations of IMethods interface", e);
+                throw new RuntimeException(
+                        "builder only creates invocations of IMethods interface", e);
             }
         }
 
-        Invocation i = new InterceptedInvocation(new MockStrongReference<Object>(mock, false),
-            new SerializableMethod(method),
-            args,
-            NO_OP,
-            location == null ? new LocationImpl() : location,
-            1);
+        Invocation i =
+                createInvocation(
+                        new MockStrongReference<Object>(mock, false),
+                        new SerializableMethod(method),
+                        args,
+                        NO_OP,
+                        location == null ? new LocationImpl() : location,
+                        1);
         if (verified) {
             i.markVerified();
         }
         return i;
     }
 
+    protected Invocation createInvocation(
+            MockReference<Object> mockRef,
+            MockitoMethod mockitoMethod,
+            Object[] arguments,
+            RealMethod realMethod,
+            Location location,
+            int sequenceNumber) {
+        return new InterceptedInvocation(
+                mockRef, mockitoMethod, arguments, realMethod, location, sequenceNumber);
+    }
+
     public InvocationBuilder method(String methodName) {
         this.methodName = methodName;
         return this;
@@ -89,7 +106,7 @@ public class InvocationBuilder {
     }
 
     public InvocationBuilder arg(Object o) {
-        this.args = new Object[]{o};
+        this.args = new Object[] {o};
         return this;
     }
 
@@ -126,11 +143,16 @@ public class InvocationBuilder {
     }
 
     public InvocationBuilder location(final String location) {
-        this.location = new Location() {
-            public String toString() {
-                return location;
-            }
-        };
+        this.location =
+                new Location() {
+                    public String toString() {
+                        return location;
+                    }
+
+                    public String getSourceFile() {
+                        return "SomeClass";
+                    }
+                };
         return this;
     }
 }
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationMarkerTest.java b/src/test/java/org/mockito/internal/invocation/InvocationMarkerTest.java
index 6d48b96..55b721e 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationMarkerTest.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationMarkerTest.java
@@ -4,53 +4,55 @@
  */
 package org.mockito.internal.invocation;
 
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicReference;
+
 import org.junit.Test;
 import org.mockito.internal.verification.InOrderContextImpl;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.junit.Assert.*;
-
 public class InvocationMarkerTest extends TestBase {
 
     @Test
     public void shouldMarkInvocationAsVerified() {
-        //given
+        // given
         Invocation i = new InvocationBuilder().toInvocation();
         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();
         assertFalse(i.isVerified());
 
-        //when
+        // when
         InvocationMarker.markVerified(Arrays.asList(i), im);
 
-        //then
+        // then
         assertTrue(i.isVerified());
     }
 
     @Test
     public void shouldCaptureArguments() {
-        //given
+        // given
         Invocation i = new InvocationBuilder().toInvocation();
         final AtomicReference<Invocation> box = new AtomicReference<Invocation>();
-        MatchableInvocation c = new InvocationMatcher(i) {
-            public void captureArgumentsFrom(Invocation i) {
-                box.set(i);
-            }};
+        MatchableInvocation c =
+                new InvocationMatcher(i) {
+                    public void captureArgumentsFrom(Invocation i) {
+                        box.set(i);
+                    }
+                };
 
-        //when
+        // when
         InvocationMarker.markVerified(Arrays.asList(i), c);
 
-        //then
+        // then
         assertEquals(i, box.get());
     }
 
     @Test
     public void shouldMarkInvocationsAsVerifiedInOrder() {
-        //given
+        // given
         InOrderContextImpl context = new InOrderContextImpl();
 
         Invocation i = new InvocationBuilder().toInvocation();
@@ -58,10 +60,10 @@ public class InvocationMarkerTest extends TestBase {
         assertFalse(context.isVerified(i));
         assertFalse(i.isVerified());
 
-        //when
+        // when
         InvocationMarker.markVerifiedInOrder(Arrays.asList(i), im, context);
 
-        //then
+        // then
         assertTrue(context.isVerified(i));
         assertTrue(i.isVerified());
     }
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java b/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
index 7ef9406..0b3d09d 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
@@ -2,14 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
 import static java.util.Arrays.asList;
+
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.internal.matchers.Any.ANY;
 
 import java.lang.reflect.Method;
@@ -17,6 +17,7 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Before;
 import org.junit.Test;
@@ -54,8 +55,10 @@ public class InvocationMatcherTest extends TestBase {
 
     @Test
     public void should_not_equal_if_number_of_arguments_differ() throws Exception {
-        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
-        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());
+        InvocationMatcher withOneArg =
+                new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
+        InvocationMatcher withTwoArgs =
+                new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());
 
         assertFalse(withOneArg.equals(null));
         assertFalse(withOneArg.equals(withTwoArgs));
@@ -64,9 +67,11 @@ public class InvocationMatcherTest extends TestBase {
     @Test
     public void should_to_string_with_matchers() throws Exception {
         ArgumentMatcher m = NotNull.NOT_NULL;
-        InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));
+        InvocationMatcher notNull =
+                new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));
         ArgumentMatcher mTwo = new Equals('x');
-        InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));
+        InvocationMatcher equals =
+                new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));
 
         assertThat(notNull.toString()).contains("simpleMethod(notNull())");
         assertThat(equals.toString()).contains("simpleMethod('x')");
@@ -89,19 +94,23 @@ public class InvocationMatcherTest extends TestBase {
 
     @Test
     public void should_not_be_similar_if_mocks_are_different() throws Exception {
-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();
+        Invocation onDifferentMock =
+                new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();
         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));
     }
 
     @Test
-    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {
+    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg()
+            throws Exception {
         Method method = IMethods.class.getMethod("simpleMethod", String.class);
         Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);
 
         String sameArg = "test";
 
-        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();
-        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();
+        InvocationMatcher invocation =
+                new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();
+        Invocation overloadedInvocation =
+                new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();
 
         assertFalse(invocation.hasSimilarMethod(overloadedInvocation));
     }
@@ -111,76 +120,84 @@ public class InvocationMatcherTest extends TestBase {
         Method method = IMethods.class.getMethod("simpleMethod", String.class);
         Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);
 
-        InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();
-        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();
+        InvocationMatcher invocation =
+                new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();
+        Invocation overloadedInvocation =
+                new InvocationBuilder()
+                        .mock(mock)
+                        .method(overloadedMethod)
+                        .arg("bar")
+                        .toInvocation();
 
         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));
     }
 
     @Test
     public void should_capture_arguments_from_invocation() throws Exception {
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();
         CapturingMatcher capturingMatcher = new CapturingMatcher();
-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("1"), capturingMatcher));
+        InvocationMatcher invocationMatcher =
+                new InvocationMatcher(invocation, (List) asList(new Equals("1"), capturingMatcher));
 
-        //when
+        // when
         invocationMatcher.captureArgumentsFrom(invocation);
 
-        //then
+        // then
         assertEquals(1, capturingMatcher.getAllValues().size());
         assertEquals(100, capturingMatcher.getLastValue());
     }
 
     @Test
     public void should_match_varargs_using_any_varargs() throws Exception {
-        //given
+        // given
         mock.varargs("1", "2");
         Invocation invocation = getLastInvocation();
         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(ANY));
 
-        //when
+        // when
         boolean match = invocationMatcher.matches(invocation);
 
-        //then
+        // then
         assertTrue(match);
     }
 
     @Test
     public void should_capture_varargs_as_vararg() throws Exception {
-        //given
+        // given
         mock.mixedVarargs(1, "a", "b");
         Invocation invocation = getLastInvocation();
         CapturingMatcher m = new CapturingMatcher();
-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, Arrays.<ArgumentMatcher>asList(new Equals(1), m));
+        InvocationMatcher invocationMatcher =
+                new InvocationMatcher(invocation, Arrays.<ArgumentMatcher>asList(new Equals(1), m));
 
-        //when
+        // when
         invocationMatcher.captureArgumentsFrom(invocation);
 
-        //then
+        // then
         Assertions.assertThat(m.getAllValues()).containsExactly("a", "b");
     }
 
-    @Test  // like using several time the captor in the vararg
+    @Test // like using several time the captor in the vararg
     public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {
-        //given
+        // given
         mock.varargs();
         Invocation invocation = getLastInvocation();
 
-        //when
-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation,(List) asList(ANY));
+        // when
+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(ANY));
 
-        //then
+        // then
         invocationMatcher.captureArgumentsFrom(invocation);
     }
 
     @Test
     public void should_create_from_invocations() throws Exception {
-        //given
+        // given
         Invocation i = new InvocationBuilder().toInvocation();
-        //when
+        // when
         List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));
-        //then
+        // then
         assertEquals(1, out.size());
         assertEquals(i, out.get(0).getInvocation());
     }
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationsFinderTest.java b/src/test/java/org/mockito/internal/invocation/InvocationsFinderTest.java
index 7172998..fd02ac5 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationsFinderTest.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationsFinderTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.invocation;
 
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Before;
 import org.junit.Test;
@@ -16,16 +24,6 @@ import org.mockito.invocation.Location;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-
 public class InvocationsFinderTest extends TestBase {
 
     private LinkedList<Invocation> invocations = new LinkedList<Invocation>();
@@ -33,26 +31,36 @@ public class InvocationsFinderTest extends TestBase {
     private Invocation simpleMethodInvocationTwo;
     private Invocation differentMethodInvocation;
 
-
     private final InOrderContext context = new InOrderContextImpl();
 
     @Mock private IMethods mock;
 
     @Before
     public void setup() throws Exception {
-        simpleMethodInvocation = new InvocationBuilder().mock(mock).simpleMethod().seq(1).toInvocation();
-        simpleMethodInvocationTwo = new InvocationBuilder().mock(mock).simpleMethod().seq(2).toInvocation();
-        differentMethodInvocation = new InvocationBuilder().mock(mock).differentMethod().seq(3).toInvocation();
-        invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));
-
+        simpleMethodInvocation =
+                new InvocationBuilder().mock(mock).simpleMethod().seq(1).toInvocation();
+        simpleMethodInvocationTwo =
+                new InvocationBuilder().mock(mock).simpleMethod().seq(2).toInvocation();
+        differentMethodInvocation =
+                new InvocationBuilder().mock(mock).differentMethod().seq(3).toInvocation();
+        invocations.addAll(
+                Arrays.asList(
+                        simpleMethodInvocation,
+                        simpleMethodInvocationTwo,
+                        differentMethodInvocation));
     }
 
     @Test
     public void shouldFindActualInvocations() throws Exception {
-        List<Invocation> actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));
-        Assertions.assertThat(actual).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
-
-        actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));
+        List<Invocation> actual =
+                InvocationsFinder.findInvocations(
+                        invocations, new InvocationMatcher(simpleMethodInvocation));
+        Assertions.assertThat(actual)
+                .containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
+
+        actual =
+                InvocationsFinder.findInvocations(
+                        invocations, new InvocationMatcher(differentMethodInvocation));
         Assertions.assertThat(actual).containsSequence(differentMethodInvocation);
     }
 
@@ -71,60 +79,75 @@ public class InvocationsFinderTest extends TestBase {
 
     @Test
     public void shouldFindFirstUnverifiedInOrder() throws Exception {
-        //given
+        // given
         InOrderContextImpl context = new InOrderContextImpl();
-        assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
+        assertSame(
+                simpleMethodInvocation,
+                InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
 
-        //when
+        // when
         context.markVerified(simpleMethodInvocationTwo);
         context.markVerified(simpleMethodInvocation);
 
-        //then
-        assertSame(differentMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
+        // then
+        assertSame(
+                differentMethodInvocation,
+                InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
 
-        //when
+        // when
         context.markVerified(differentMethodInvocation);
 
-        //then
+        // then
         assertNull(InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
     }
 
     @Test
     public void shouldFindFirstUnverifiedInOrderAndRespectSequenceNumber() throws Exception {
-        //given
+        // given
         InOrderContextImpl context = new InOrderContextImpl();
-        assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
+        assertSame(
+                simpleMethodInvocation,
+                InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
 
-        //when
-        //skipping verification of first invocation, then:
+        // when
+        // skipping verification of first invocation, then:
         context.markVerified(simpleMethodInvocationTwo);
         context.markVerified(differentMethodInvocation);
 
-        //then
+        // then
         assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
     }
 
     @Test
     public void shouldFindFirstUnverifiedInvocationOnMock() throws Exception {
-        assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));
+        assertSame(
+                simpleMethodInvocation,
+                InvocationsFinder.findFirstUnverified(
+                        invocations, simpleMethodInvocation.getMock()));
         assertNull(InvocationsFinder.findFirstUnverified(invocations, "different mock"));
     }
 
     @Test
     public void shouldFindFirstSimilarInvocationByName() throws Exception {
-        Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg("test").toInvocation();
+        Invocation overloadedSimpleMethod =
+                new InvocationBuilder().mock(mock).simpleMethod().arg("test").toInvocation();
 
-        Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));
+        Invocation found =
+                InvocationsFinder.findSimilarInvocation(
+                        invocations, new InvocationMatcher(overloadedSimpleMethod));
         assertSame(found, simpleMethodInvocation);
     }
 
     @Test
     public void shouldFindInvocationWithTheSameMethod() throws Exception {
-        Invocation overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg("test").toInvocation();
+        Invocation overloadedDifferentMethod =
+                new InvocationBuilder().differentMethod().arg("test").toInvocation();
 
         invocations.add(overloadedDifferentMethod);
 
-        Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));
+        Invocation found =
+                InvocationsFinder.findSimilarInvocation(
+                        invocations, new InvocationMatcher(overloadedDifferentMethod));
         assertSame(found, overloadedDifferentMethod);
     }
 
@@ -138,22 +161,32 @@ public class InvocationsFinderTest extends TestBase {
 
     @Test
     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {
-        List<Invocation> allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
-        Assertions.assertThat(allMatching).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
+        List<Invocation> allMatching =
+                InvocationsFinder.findAllMatchingUnverifiedChunks(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), context);
+        Assertions.assertThat(allMatching)
+                .containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
 
         context.markVerified(simpleMethodInvocation);
-        allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
+        allMatching =
+                InvocationsFinder.findAllMatchingUnverifiedChunks(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), context);
         Assertions.assertThat(allMatching).containsSequence(simpleMethodInvocationTwo);
 
         context.markVerified(simpleMethodInvocationTwo);
-        allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
+        allMatching =
+                InvocationsFinder.findAllMatchingUnverifiedChunks(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), context);
         assertTrue(allMatching.isEmpty());
     }
 
     @Test
     public void shouldFindMatchingChunk() throws Exception {
-        List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);
-        Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
+        List<Invocation> chunk =
+                InvocationsFinder.findMatchingChunk(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);
+        Assertions.assertThat(chunk)
+                .containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
     }
 
     @Test
@@ -161,8 +194,14 @@ public class InvocationsFinderTest extends TestBase {
         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();
         invocations.add(simpleMethodInvocationThree);
 
-        List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
-        Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree);
+        List<Invocation> chunk =
+                InvocationsFinder.findMatchingChunk(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
+        Assertions.assertThat(chunk)
+                .containsSequence(
+                        simpleMethodInvocation,
+                        simpleMethodInvocationTwo,
+                        simpleMethodInvocationThree);
     }
 
     @Test
@@ -170,8 +209,14 @@ public class InvocationsFinderTest extends TestBase {
         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();
         invocations.add(simpleMethodInvocationThree);
 
-        List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
-        Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree);
+        List<Invocation> chunk =
+                InvocationsFinder.findMatchingChunk(
+                        invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
+        Assertions.assertThat(chunk)
+                .containsSequence(
+                        simpleMethodInvocation,
+                        simpleMethodInvocationTwo,
+                        simpleMethodInvocationThree);
     }
 
     @Test
@@ -189,11 +234,17 @@ public class InvocationsFinderTest extends TestBase {
     @Test
     public void shouldFindAllStackTraces() {
         List<Location> all = InvocationsFinder.getAllLocations(invocations);
-        Assertions.assertThat(all).contains(simpleMethodInvocation.getLocation(), simpleMethodInvocationTwo.getLocation(), differentMethodInvocation.getLocation());
+        Assertions.assertThat(all)
+                .contains(
+                        simpleMethodInvocation.getLocation(),
+                        simpleMethodInvocationTwo.getLocation(),
+                        differentMethodInvocation.getLocation());
     }
 
     @Test
     public void shouldNotFindLocationsForEmptyInvocationsList() {
-        Assertions.assertThat(InvocationsFinder.getAllLocations(Collections.<Invocation>emptyList())).isEmpty();
+        Assertions.assertThat(
+                        InvocationsFinder.getAllLocations(Collections.<Invocation>emptyList()))
+                .isEmpty();
     }
 }
diff --git a/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java b/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
index 46a75eb..285bfec 100644
--- a/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
+++ b/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
@@ -5,9 +5,10 @@
 package org.mockito.internal.invocation;
 
 import static java.util.Arrays.asList;
+
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
 import static org.mockito.internal.matchers.Any.ANY;
 
@@ -32,8 +33,7 @@ import org.mockitoutil.TestBase;
 @SuppressWarnings("unchecked")
 public class MatcherApplicationStrategyTest extends TestBase {
 
-    @Mock
-    IMethods mock;
+    @Mock IMethods mock;
     private Invocation invocation;
     private List matchers;
 
@@ -51,7 +51,9 @@ public class MatcherApplicationStrategyTest extends TestBase {
         matchers = asList(new Equals("1"));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(RETURN_ALWAYS_FALSE);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(RETURN_ALWAYS_FALSE);
 
         // then
         assertFalse(match);
@@ -64,7 +66,9 @@ public class MatcherApplicationStrategyTest extends TestBase {
         matchers = asList(new Equals("1"));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
 
         // then
         assertTrue(match);
@@ -77,7 +81,9 @@ public class MatcherApplicationStrategyTest extends TestBase {
         matchers = asList(new Equals("1"));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
 
         // then
         assertFalse(match);
@@ -90,7 +96,9 @@ public class MatcherApplicationStrategyTest extends TestBase {
         matchers = asList(new Equals("1"), new Equals("2"));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(RETURN_ALWAYS_TRUE);
 
         // then
         assertFalse(match);
@@ -103,59 +111,69 @@ public class MatcherApplicationStrategyTest extends TestBase {
         matchers = asList(new Equals("1"), Any.ANY, new InstanceOf(String.class));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(recordAction);
 
         // then
         assertTrue(match);
     }
 
     @Test
-    public void shouldAllowAnyVarargMatchEntireVararg() {
+    public void shouldAllowAnyMatchEntireVararg() {
         // given
         invocation = varargs("1", "2");
         matchers = asList(ANY);
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(recordAction);
 
         // then
         assertTrue(match);
     }
 
     @Test
-    public void shouldNotAllowAnyObjectWithMixedVarargs() {
+    public void shouldNotAllowAnyWithMixedVarargs() {
         // given
         invocation = mixedVarargs(1, "1", "2");
         matchers = asList(new Equals(1));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(recordAction);
 
         // then
         assertFalse(match);
     }
 
     @Test
-    public void shouldAllowAnyObjectWithMixedVarargs() {
+    public void shouldAllowanyWithMixedVarargs() {
         // given
         invocation = mixedVarargs(1, "1", "2");
         matchers = asList(new Equals(1), ANY);
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(recordAction);
 
         // then
         assertTrue(match);
     }
 
     @Test
-    public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs() {
+    public void shouldAnyDealWithDifferentSizeOfArgs() {
         // given
         invocation = mixedVarargs(1, "1", "2");
         matchers = asList(new Equals(1));
 
         // when
-        boolean match = getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        boolean match =
+                getMatcherApplicationStrategyFor(invocation, matchers)
+                        .forEachMatcherAndArgument(recordAction);
 
         // then
         assertFalse(match);
@@ -164,41 +182,43 @@ public class MatcherApplicationStrategyTest extends TestBase {
     }
 
     @Test
-    public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull() {
+    public void shouldMatchAnyEvenIfOneOfTheArgsIsNull() {
         // given
         invocation = mixedVarargs(null, null, "2");
         matchers = asList(new Equals(null), ANY);
 
         // when
-        getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        getMatcherApplicationStrategyFor(invocation, matchers)
+                .forEachMatcherAndArgument(recordAction);
 
         // then
         recordAction.assertContainsExactly(new Equals(null), ANY, ANY);
-
     }
 
     @Test
-    public void shouldMatchAnyVarargEvenIfMatcherIsDecorated() {
+    public void shouldMatchAnyEvenIfMatcherIsDecorated() {
         // given
         invocation = varargs("1", "2");
         matchers = asList(ANY);
 
         // when
-        getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        getMatcherApplicationStrategyFor(invocation, matchers)
+                .forEachMatcherAndArgument(recordAction);
 
         // then
         recordAction.assertContainsExactly(ANY, ANY);
     }
 
     @Test
-    public void shouldMatchAnyVarargEvenIfMatcherIsWrappedInHamcrestMatcher() {
+    public void shouldMatchAnyEvenIfMatcherIsWrappedInHamcrestMatcher() {
         // given
         invocation = varargs("1", "2");
         HamcrestArgumentMatcher argumentMatcher = new HamcrestArgumentMatcher(new IntMatcher());
         matchers = asList(argumentMatcher);
 
         // when
-        getMatcherApplicationStrategyFor(invocation, matchers).forEachMatcherAndArgument(recordAction);
+        getMatcherApplicationStrategyFor(invocation, matchers)
+                .forEachMatcherAndArgument(recordAction);
 
         // then
         recordAction.assertContainsExactly(argumentMatcher, argumentMatcher);
@@ -208,6 +228,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
@@ -239,18 +260,19 @@ public class MatcherApplicationStrategyTest extends TestBase {
         }
     }
 
-    private static final ArgumentMatcherAction RETURN_ALWAYS_TRUE = new ArgumentMatcherAction() {
-        @Override
-        public boolean apply(ArgumentMatcher<?> matcher, Object argument) {
-            return true;
-        }
-    };
-
-    private static final ArgumentMatcherAction RETURN_ALWAYS_FALSE = new ArgumentMatcherAction() {
-        @Override
-        public boolean apply(ArgumentMatcher<?> matcher, Object argument) {
-            return false;
-        }
-    };
-
+    private static final ArgumentMatcherAction RETURN_ALWAYS_TRUE =
+            new ArgumentMatcherAction() {
+                @Override
+                public boolean apply(ArgumentMatcher<?> matcher, Object argument) {
+                    return true;
+                }
+            };
+
+    private static final ArgumentMatcherAction RETURN_ALWAYS_FALSE =
+            new ArgumentMatcherAction() {
+                @Override
+                public boolean apply(ArgumentMatcher<?> matcher, Object argument) {
+                    return false;
+                }
+            };
 }
diff --git a/src/test/java/org/mockito/internal/invocation/SerializableMethodTest.java b/src/test/java/org/mockito/internal/invocation/SerializableMethodTest.java
index d320f25..bbf7eb9 100644
--- a/src/test/java/org/mockito/internal/invocation/SerializableMethodTest.java
+++ b/src/test/java/org/mockito/internal/invocation/SerializableMethodTest.java
@@ -4,16 +4,15 @@
  */
 package org.mockito.internal.invocation;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.*;
 
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectOutputStream;
 import java.lang.reflect.Method;
 
-import static org.junit.Assert.*;
-
+import org.junit.Before;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class SerializableMethodTest extends TestBase {
 
@@ -70,6 +69,6 @@ public class SerializableMethodTest extends TestBase {
         assertFalse(new SerializableMethod(testBaseToStringMethod).equals(method));
     }
 
-    //TODO: add tests for generated equals() method
+    // TODO: add tests for generated equals() method
 
 }
diff --git a/src/test/java/org/mockito/internal/invocation/TypeSafeMatchingTest.java b/src/test/java/org/mockito/internal/invocation/TypeSafeMatchingTest.java
index 94b4a23..0a29cee 100644
--- a/src/test/java/org/mockito/internal/invocation/TypeSafeMatchingTest.java
+++ b/src/test/java/org/mockito/internal/invocation/TypeSafeMatchingTest.java
@@ -25,11 +25,9 @@ public class TypeSafeMatchingTest {
 
     private static final Object NOT_A_COMPARABLE = new Object();
 
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
 
-    @Mock
-    public IMethods mock;
+    @Mock public IMethods mock;
 
     /**
      * Should not throw an {@link NullPointerException}
@@ -40,7 +38,6 @@ public class TypeSafeMatchingTest {
     public void compareNullArgument() {
         boolean match = matchesTypeSafe().apply(new LessOrEqual<Integer>(5), null);
         assertThat(match).isFalse();
-
     }
 
     /**
@@ -102,7 +99,6 @@ public class TypeSafeMatchingTest {
             public boolean matches(Integer arg, Void v) {
                 throw new UnsupportedOperationException();
             }
-
         }
 
         boolean match = matchesTypeSafe().apply(new TestMatcher(), 123);
@@ -111,8 +107,7 @@ public class TypeSafeMatchingTest {
 
     @Test
     public void matchesWithSubTypeExtendingGenericClass() {
-        abstract class GenericMatcher<T> implements ArgumentMatcher<T> {
-        }
+        abstract class GenericMatcher<T> implements ArgumentMatcher<T> {}
         class TestMatcher extends GenericMatcher<Integer> {
             @Override
             public boolean matches(Integer argument) {
@@ -127,8 +122,7 @@ public class TypeSafeMatchingTest {
     public void dontMatchesWithSubTypeExtendingGenericClass() {
         final AtomicBoolean wasCalled = new AtomicBoolean();
 
-        abstract class GenericMatcher<T> implements ArgumentMatcher<T> {
-        }
+        abstract class GenericMatcher<T> implements ArgumentMatcher<T> {}
         class TestMatcher extends GenericMatcher<Integer> {
             @Override
             public boolean matches(Integer argument) {
diff --git a/src/test/java/org/mockito/internal/invocation/mockref/MockWeakReferenceTest.java b/src/test/java/org/mockito/internal/invocation/mockref/MockWeakReferenceTest.java
index 1e3d8e9..5c31e5a 100644
--- a/src/test/java/org/mockito/internal/invocation/mockref/MockWeakReferenceTest.java
+++ b/src/test/java/org/mockito/internal/invocation/mockref/MockWeakReferenceTest.java
@@ -4,21 +4,20 @@
  */
 package org.mockito.internal.invocation.mockref;
 
+import static org.junit.Assert.fail;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
-import org.mockito.internal.invocation.mockref.MockWeakReference;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-
 public class MockWeakReferenceTest extends TestBase {
 
     @Test
     public void descriptive_exception_when_mock_was_collected() {
         try {
-            //when
+            // when
             new MockWeakReference(null).get();
-            //then
+            // then
             fail();
         } catch (Exception e) {
             Assertions.assertThat(e).hasMessageContaining("The mock object was garbage collected");
diff --git a/src/test/java/org/mockito/internal/junit/ArgMismatchFinderTest.java b/src/test/java/org/mockito/internal/junit/ArgMismatchFinderTest.java
index 4c59809..2659412 100644
--- a/src/test/java/org/mockito/internal/junit/ArgMismatchFinderTest.java
+++ b/src/test/java/org/mockito/internal/junit/ArgMismatchFinderTest.java
@@ -4,15 +4,16 @@
  */
 package org.mockito.internal.junit;
 
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static java.util.Arrays.asList;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.when;
-
 public class ArgMismatchFinderTest extends TestBase {
 
     ArgMismatchFinder finder = new ArgMismatchFinder();
@@ -21,109 +22,112 @@ public class ArgMismatchFinderTest extends TestBase {
 
     @Test
     public void no_interactions() throws Exception {
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(0, mismatches.size());
     }
 
     @Test
     public void no_mismatch_when_mock_different() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
-        mock2.simpleMethod(2); //arg mismatch on different mock
+        mock2.simpleMethod(2); // arg mismatch on different mock
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(0, mismatches.size());
     }
 
     @Test
     public void no_mismatch_when_method_different() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
         mock1.otherMethod();
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(0, mismatches.size());
     }
 
     @Test
     public void no_mismatch_when_stubbing_used() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
         mock1.simpleMethod(1); // stub used
         mock1.simpleMethod(2); // no stubbing, but we don't want it to be reported, either
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(0, mismatches.size());
     }
 
     @Test
     public void stubbing_mismatch() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
         mock1.simpleMethod(2);
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(1, mismatches.size());
     }
 
     @Test
     public void single_mismatch_with_multiple_invocations() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
         mock1.simpleMethod(2);
         mock1.simpleMethod(3);
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(1, mismatches.size());
-        assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(2);, mock1.simpleMethod(3);]}", mismatches.toString());
+        assertEquals(
+                "{mock1.simpleMethod(1);=[mock1.simpleMethod(2);, mock1.simpleMethod(3);]}",
+                mismatches.toString());
     }
 
     @Test
     public void single_invocation_with_multiple_stubs() throws Exception {
-        //given
+        // given
         when(mock1.simpleMethod(1)).thenReturn("1");
         when(mock1.simpleMethod(2)).thenReturn("2");
         mock1.simpleMethod(3);
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(2, mismatches.size());
-        assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(3);], mock1.simpleMethod(2);=[mock1.simpleMethod(3);]}"
-                , mismatches.toString());
+        assertEquals(
+                "{mock1.simpleMethod(1);=[mock1.simpleMethod(3);], mock1.simpleMethod(2);=[mock1.simpleMethod(3);]}",
+                mismatches.toString());
     }
 
     @Test
     public void mismatch_reports_only_unstubbed_invocations() throws Exception {
-        //given
-        when(mock1.simpleMethod(1)).thenReturn("1"); //unused
-        when(mock1.simpleMethod(2)).thenReturn("2"); //used
-        mock1.simpleMethod(2); //stubbed
-        mock1.simpleMethod(3); //unstubbed
+        // given
+        when(mock1.simpleMethod(1)).thenReturn("1"); // unused
+        when(mock1.simpleMethod(2)).thenReturn("2"); // used
+        mock1.simpleMethod(2); // stubbed
+        mock1.simpleMethod(3); // unstubbed
 
-        //when
+        // when
         StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(3);]}", mismatches.toString());
     }
 }
diff --git a/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java b/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
index a1e2564..69baf30 100644
--- a/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
+++ b/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
@@ -8,51 +8,121 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockitoutil.ClassLoaders.excludingClassLoader;
 
 import java.lang.reflect.Method;
+
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.mockito.exceptions.verification.ArgumentsAreDifferent;
 
 public class ExceptionFactoryTest {
 
-    private static ClassLoader classLoaderWithoutJUnit = excludingClassLoader().withCodeSourceUrlOf(ExceptionFactory.class).without("org.junit", "junit").build();
+    private static ClassLoader classLoaderWithoutJUnitOrOpenTest =
+            excludingClassLoader()
+                    .withCodeSourceUrlOf(ExceptionFactory.class)
+                    .without("org.junit", "junit", "org.opentest4j")
+                    .build();
+    private static ClassLoader classLoaderWithoutOpenTest =
+            excludingClassLoader()
+                    .withCodeSourceUrlOf(ExceptionFactory.class, org.junit.ComparisonFailure.class)
+                    .without("org.opentest4j")
+                    .build();
+    private static ClassLoader currentClassLoader = ExceptionFactoryTest.class.getClassLoader();
+
+    /** loaded by the current classloader */
+    private static Class<?> opentestComparisonFailure;
+
+    private static Class<?> opentestArgumentsAreDifferent;
 
-    /** loaded by the current current class loader */
-    private static Class<?> junitArgumentsAreDifferent;
+    /** loaded by the classloader {@value #classLoaderWithoutOpenTest}, which excludes OpenTest4J classes */
+    private static Class<?> junit3ComparisonFailure;
 
-    /** loaded by the custom classloader {@value #classLoaderWithoutJUnit}, which excludes junit-classes */
+    private static Class<?> junit3ArgumentsAreDifferent;
+
+    /** loaded by the custom classloader {@value #classLoaderWithoutJUnitOrOpenTest}, which excludes JUnit and OpenTest4J classes */
     private static Class<?> nonJunitArgumentsAreDifferent;
 
     @BeforeClass
     public static void init() throws ClassNotFoundException {
-        nonJunitArgumentsAreDifferent = classLoaderWithoutJUnit.loadClass(ArgumentsAreDifferent.class.getName());
-        junitArgumentsAreDifferent = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class;
+        nonJunitArgumentsAreDifferent =
+                classLoaderWithoutJUnitOrOpenTest.loadClass(ArgumentsAreDifferent.class.getName());
+        junit3ComparisonFailure =
+                classLoaderWithoutOpenTest.loadClass(
+                        junit.framework.ComparisonFailure.class.getName());
+        junit3ArgumentsAreDifferent =
+                classLoaderWithoutOpenTest.loadClass(
+                        org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class
+                                .getName());
+        opentestComparisonFailure = org.opentest4j.AssertionFailedError.class;
+        opentestArgumentsAreDifferent =
+                org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent.class;
+    }
+
+    @Test
+    public void createArgumentsAreDifferentException_withoutJUnitOrOpenTest() throws Exception {
+        AssertionError e = invokeFactoryThroughLoader(classLoaderWithoutJUnitOrOpenTest);
+
+        assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
+    }
+
+    @Test
+    public void createArgumentsAreDifferentException_withJUnit3_butNotOpenTest() throws Exception {
+        AssertionError e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
+
+        assertThat(e)
+                .isExactlyInstanceOf(junit3ArgumentsAreDifferent)
+                .isInstanceOf(junit3ComparisonFailure);
+    }
+
+    @Test
+    public void createArgumentsAreDifferentException_withOpenTest() throws Exception {
+        AssertionError e = invokeFactoryThroughLoader(currentClassLoader);
+
+        assertThat(e)
+                .isExactlyInstanceOf(opentestArgumentsAreDifferent)
+                .isInstanceOf(opentestComparisonFailure);
     }
 
     @Test
-    public void createArgumentsAreDifferentException_withoutJUnit() throws Exception {
-        Class<?> exceptionFactory = classLoaderWithoutJUnit.loadClass(ExceptionFactory.class.getName());
+    public void createArgumentsAreDifferentException_withoutJUnitOrOpenTest_2x() throws Exception {
+        AssertionError e;
 
-        Method m = exceptionFactory.getDeclaredMethod("createArgumentsAreDifferentException", String.class, String.class, String.class);
-        Object e = m.invoke(null, "message", "wanted", "actual");
+        e = invokeFactoryThroughLoader(classLoaderWithoutJUnitOrOpenTest);
+        assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
 
+        e = invokeFactoryThroughLoader(classLoaderWithoutJUnitOrOpenTest);
         assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
     }
 
     @Test
-    public void createArgumentsAreDifferentException_withJUnit() throws Exception {
-        AssertionError e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
+    public void createArgumentsAreDifferentException_withJUnit3_2x() throws Exception {
+        AssertionError e;
+
+        e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
+        assertThat(e).isExactlyInstanceOf(junit3ArgumentsAreDifferent);
 
-        assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
+        e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
+        assertThat(e).isExactlyInstanceOf(junit3ArgumentsAreDifferent);
     }
 
     @Test
-    public void createArgumentsAreDifferentException_withJUnit2x() throws Exception {
+    public void createArgumentsAreDifferentException_withOpenTest_2x() throws Exception {
         AssertionError e;
 
-        e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
-        assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
+        e = invokeFactoryThroughLoader(currentClassLoader);
+        assertThat(e).isExactlyInstanceOf(opentestArgumentsAreDifferent);
+
+        e = invokeFactoryThroughLoader(currentClassLoader);
+        assertThat(e).isExactlyInstanceOf(opentestArgumentsAreDifferent);
+    }
+
+    private static AssertionError invokeFactoryThroughLoader(ClassLoader loader) throws Exception {
+        Class<?> exceptionFactory = loader.loadClass(ExceptionFactory.class.getName());
 
-        e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
-        assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
+        Method m =
+                exceptionFactory.getDeclaredMethod(
+                        "createArgumentsAreDifferentException",
+                        String.class,
+                        String.class,
+                        String.class);
+        return (AssertionError) m.invoke(null, "message", "wanted", "actual");
     }
 }
diff --git a/src/test/java/org/mockito/internal/junit/JUnitRuleTest.java b/src/test/java/org/mockito/internal/junit/JUnitRuleTest.java
index 7d5968d..f971893 100644
--- a/src/test/java/org/mockito/internal/junit/JUnitRuleTest.java
+++ b/src/test/java/org/mockito/internal/junit/JUnitRuleTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockito.internal.junit;
 
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mockingDetails;
+import static org.mockito.Mockito.when;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,16 +17,13 @@ import org.mockito.junit.MockitoJUnit;
 import org.mockitousage.IMethods;
 import org.mockitoutil.SafeJUnitRule;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mockingDetails;
-import static org.mockito.Mockito.when;
-
 public class JUnitRuleTest {
 
     @Rule public SafeJUnitRule rule = new SafeJUnitRule(MockitoJUnit.rule());
     @Mock IMethods mock;
 
-    @Test public void injects_into_test_case() throws Throwable {
+    @Test
+    public void injects_into_test_case() throws Throwable {
         assertTrue(mockingDetails(mock).isMock());
     }
 
@@ -42,9 +43,9 @@ public class JUnitRuleTest {
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void does_not_check_invalid_mockito_usage_on_failure() throws Throwable {
-        //This intended behavior is questionable
-        //However, it was like that since the beginning of JUnit rule support
-        //Users never questioned this behavior. Hence, let's stick to it unless we have more data
+        // This intended behavior is questionable
+        // However, it was like that since the beginning of JUnit rule support
+        // Users never questioned this behavior. Hence, let's stick to it unless we have more data
         rule.expectFailure(RuntimeException.class, "foo");
 
         Mockito.when(mock.simpleMethod()); // <--- unfinished stubbing
diff --git a/src/test/java/org/mockito/internal/junit/StubbingArgMismatchesTest.java b/src/test/java/org/mockito/internal/junit/StubbingArgMismatchesTest.java
index c597659..5349364 100644
--- a/src/test/java/org/mockito/internal/junit/StubbingArgMismatchesTest.java
+++ b/src/test/java/org/mockito/internal/junit/StubbingArgMismatchesTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.junit;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.util.SimpleMockitoLogger;
 import org.mockito.invocation.Invocation;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 public class StubbingArgMismatchesTest extends TestBase {
 
     SimpleMockitoLogger logger = new SimpleMockitoLogger();
@@ -20,51 +20,67 @@ public class StubbingArgMismatchesTest extends TestBase {
 
     @Test
     public void no_op_when_no_mismatches() throws Exception {
-        //when
+        // when
         mismatches.format("MyTest.myTestMethod", logger);
 
-        //then
+        // then
         assertTrue(logger.isEmpty());
     }
 
     @Test
     public void logs_mismatch() throws Exception {
-        //given
+        // given
         mismatches.add(
                 new InvocationBuilder().args("a").location("-> at A.java").toInvocation(),
                 new InvocationBuilder().args("b").location("-> at B.java").toInvocation());
 
-        //when
+        // when
         mismatches.format("MyTest.myTestMethod", logger);
 
-        //then
+        // then
         assertEquals(
-            "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
-            "[MockitoHint] 1. Unused... -> at B.java\n" +
-            "[MockitoHint]  ...args ok? -> at A.java\n", logger.getLoggedInfo());
+                "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n"
+                        + "[MockitoHint] 1. Unused... -> at B.java\n"
+                        + "[MockitoHint]  ...args ok? -> at A.java\n",
+                logger.getLoggedInfo());
     }
 
     @Test
-    public void multiple_matching_invocations_per_stub_plus_some_other_invocation() throws Exception {
-        //given
-        Invocation stubbing = new InvocationBuilder().args("a").location("-> at A.java").toInvocation();
-        mismatches.add(new InvocationBuilder().args("x").location("-> at X.java").toInvocation(), stubbing);
-        mismatches.add(new InvocationBuilder().args("y").location("-> at Y.java").toInvocation(), stubbing);
+    public void multiple_matching_invocations_per_stub_plus_some_other_invocation()
+            throws Exception {
+        // given
+        Invocation stubbing =
+                new InvocationBuilder().args("a").location("-> at A.java").toInvocation();
+        mismatches.add(
+                new InvocationBuilder().args("x").location("-> at X.java").toInvocation(),
+                stubbing);
+        mismatches.add(
+                new InvocationBuilder().args("y").location("-> at Y.java").toInvocation(),
+                stubbing);
 
         mismatches.add(
-                new InvocationBuilder().method("differentMethod").args("n").location("-> at N.java").toInvocation(),
-                new InvocationBuilder().method("differentMethod").args("m").location("-> at M.java").toInvocation());
+                new InvocationBuilder()
+                        .method("differentMethod")
+                        .args("n")
+                        .location("-> at N.java")
+                        .toInvocation(),
+                new InvocationBuilder()
+                        .method("differentMethod")
+                        .args("m")
+                        .location("-> at M.java")
+                        .toInvocation());
 
-        //when
+        // when
         mismatches.format("MyTest.myTestMethod", logger);
 
-        //then
+        // then
         assertEquals(
-            "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
-            "[MockitoHint] 1. Unused... -> at A.java\n" +
-            "[MockitoHint]  ...args ok? -> at X.java\n" +
-            "[MockitoHint]  ...args ok? -> at Y.java\n" +
-            "[MockitoHint] 2. Unused... -> at M.java\n" +
-            "[MockitoHint]  ...args ok? -> at N.java\n", logger.getLoggedInfo());
+                "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n"
+                        + "[MockitoHint] 1. Unused... -> at A.java\n"
+                        + "[MockitoHint]  ...args ok? -> at X.java\n"
+                        + "[MockitoHint]  ...args ok? -> at Y.java\n"
+                        + "[MockitoHint] 2. Unused... -> at M.java\n"
+                        + "[MockitoHint]  ...args ok? -> at N.java\n",
+                logger.getLoggedInfo());
     }
 }
diff --git a/src/test/java/org/mockito/internal/junit/UnusedStubbingsTest.java b/src/test/java/org/mockito/internal/junit/UnusedStubbingsTest.java
index af1d3a1..9083d19 100644
--- a/src/test/java/org/mockito/internal/junit/UnusedStubbingsTest.java
+++ b/src/test/java/org/mockito/internal/junit/UnusedStubbingsTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockito.internal.junit;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
+
+import java.util.Arrays;
+import java.util.Collections;
+
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
@@ -11,49 +18,50 @@ import org.mockito.internal.util.SimpleMockitoLogger;
 import org.mockito.stubbing.Stubbing;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-import java.util.Collections;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
-
 public class UnusedStubbingsTest extends TestBase {
 
     private SimpleMockitoLogger logger = new SimpleMockitoLogger();
 
     @Test
     public void no_unused_stubbings() throws Exception {
-        //given
+        // given
         UnusedStubbings stubbings = new UnusedStubbings(Collections.<Stubbing>emptyList());
 
-        //when
+        // when
         stubbings.format("MyTest.myTestMethod", logger);
 
-        //then
+        // then
         assertEquals("", logger.getLoggedInfo());
     }
 
     @Test
     public void unused_stubbings() throws Exception {
-        //given
-        UnusedStubbings stubbings = new UnusedStubbings(Arrays.asList(
-            new StubbedInvocationMatcher(doesNothing(), new InvocationBuilder().toInvocationMatcher(), null),
-            new StubbedInvocationMatcher(doesNothing(), new InvocationBuilder().toInvocationMatcher(), null)
-        ));
-
+        // given
+        UnusedStubbings stubbings =
+                new UnusedStubbings(
+                        Arrays.asList(
+                                new StubbedInvocationMatcher(
+                                        doesNothing(),
+                                        new InvocationBuilder().toInvocationMatcher(),
+                                        null),
+                                new StubbedInvocationMatcher(
+                                        doesNothing(),
+                                        new InvocationBuilder().toInvocationMatcher(),
+                                        null)));
 
-        //when
+        // when
         stubbings.format("MyTest.myTestMethod", logger);
 
-        //then
-        assertThat(filterLineNo(logger.getLoggedInfo())).isIn(
-            "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +  //Java <9
-                                    "[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
-                                    "[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
-            "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +  //Java 9
-                                    "[MockitoHint] 1. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
-                                    "[MockitoHint] 2. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n"
-        );
+        // then
+        assertThat(filterLineNo(logger.getLoggedInfo()))
+                .isIn(
+                        "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n"
+                                + // Java <9
+                                "[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n"
+                                + "[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
+                        "[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n"
+                                + // Java 9
+                                "[MockitoHint] 1. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n"
+                                + "[MockitoHint] 2. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n");
     }
 }
diff --git a/src/test/java/org/mockito/internal/junit/util/JUnitFailureHackerTest.java b/src/test/java/org/mockito/internal/junit/util/JUnitFailureHackerTest.java
deleted file mode 100644
index ff23b0b..0000000
--- a/src/test/java/org/mockito/internal/junit/util/JUnitFailureHackerTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.junit.util;
-
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.junit.runner.Description;
-import org.junit.runner.notification.Failure;
-import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.assertEquals;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class JUnitFailureHackerTest extends TestBase {
-
-    JUnitFailureHacker hacker = new JUnitFailureHacker();
-
-    @Test
-    public void shouldReplaceException() throws Exception {
-        //given
-        RuntimeException actualExc = new RuntimeException("foo");
-        Failure failure = new Failure(Description.EMPTY, actualExc);
-
-        //when
-        hacker.appendWarnings(failure, "unused stubbing");
-
-        //then
-        assertEquals(ExceptionIncludingMockitoWarnings.class, failure.getException().getClass());
-        assertEquals(actualExc, failure.getException().getCause());
-        Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());
-    }
-
-    @Test
-    public void shouldAppendWarning() throws Exception {
-        Failure failure = new Failure(Description.EMPTY, new RuntimeException("foo"));
-
-        //when
-        hacker.appendWarnings(failure, "unused stubbing blah");
-
-        //then
-        assertThat(failure.getException()).hasMessageContaining("unused stubbing blah");
-    }
-
-    @Test
-    public void shouldNotAppendWhenNoWarnings() throws Exception {
-        RuntimeException ex = new RuntimeException("foo");
-        Failure failure = new Failure(Description.EMPTY, ex);
-
-        //when
-        hacker.appendWarnings(failure, "");
-
-        //then
-        assertEquals(ex, failure.getException());
-    }
-
-    @Test
-    public void shouldNotAppendWhenNullWarnings() throws Exception {
-        RuntimeException ex = new RuntimeException("foo");
-        Failure failure = new Failure(Description.EMPTY, ex);
-
-        //when
-        hacker.appendWarnings(failure, null);
-
-        //then
-        assertEquals(ex, failure.getException());
-    }
-
-    @Test
-    public void shouldPrintTheWarningSoICanSeeIt() throws Exception {
-        Failure failure = new Failure(Description.EMPTY, new RuntimeException("foo"));
-
-        //when
-        hacker.appendWarnings(failure, "unused stubbing blah");
-
-        //then
-        System.out.println(failure.getException());
-    }
-}
diff --git a/src/test/java/org/mockito/internal/listeners/StubbingLookupNotifierTest.java b/src/test/java/org/mockito/internal/listeners/StubbingLookupNotifierTest.java
index ac963c4..6b2c77c 100644
--- a/src/test/java/org/mockito/internal/listeners/StubbingLookupNotifierTest.java
+++ b/src/test/java/org/mockito/internal/listeners/StubbingLookupNotifierTest.java
@@ -4,24 +4,25 @@
  */
 package org.mockito.internal.listeners;
 
+import static org.assertj.core.util.Lists.emptyList;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.internal.listeners.StubbingLookupNotifier.notifyStubbedAnswerLookup;
+
+import java.util.Collection;
+import java.util.List;
+
 import org.assertj.core.util.Lists;
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.invocation.Invocation;
+import org.mockito.listeners.StubbingLookupListener;
 import org.mockito.stubbing.Stubbing;
 import org.mockitoutil.TestBase;
 
-import java.util.Collection;
-import java.util.List;
-
-import static org.assertj.core.util.Lists.emptyList;
-import static org.mockito.ArgumentMatchers.argThat;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.internal.listeners.StubbingLookupNotifier.notifyStubbedAnswerLookup;
-
 public class StubbingLookupNotifierTest extends TestBase {
 
     Invocation invocation = mock(Invocation.class);
@@ -60,10 +61,10 @@ public class StubbingLookupNotifierTest extends TestBase {
 
         @Override
         public boolean matches(StubbingLookupNotifier.Event argument) {
-            return invocation == argument.getInvocation() &&
-                stubbingFound == argument.getStubbingFound() &&
-                allStubbings == argument.getAllStubbings() &&
-                creationSettings == argument.getMockSettings();
+            return invocation == argument.getInvocation()
+                    && stubbingFound == argument.getStubbingFound()
+                    && allStubbings == argument.getAllStubbings()
+                    && creationSettings == argument.getMockSettings();
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/listeners/VerificationStartedNotifierTest.java b/src/test/java/org/mockito/internal/listeners/VerificationStartedNotifierTest.java
index 59e99c6..419fa7c 100644
--- a/src/test/java/org/mockito/internal/listeners/VerificationStartedNotifierTest.java
+++ b/src/test/java/org/mockito/internal/listeners/VerificationStartedNotifierTest.java
@@ -4,109 +4,127 @@
  */
 package org.mockito.internal.listeners;
 
-import org.junit.Test;
-import org.mockito.MockingDetails;
-import org.mockitoutil.TestBase;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 import static java.util.Collections.emptyList;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.mockingDetails;
 import static org.mockito.Mockito.withSettings;
 
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.junit.Test;
+import org.mockito.MockingDetails;
+import org.mockitoutil.TestBase;
+
 public class VerificationStartedNotifierTest extends TestBase {
 
     MockingDetails mockingDetails = mockingDetails(mock(List.class));
 
     @Test
     public void does_not_do_anything_when_list_is_empty() throws Exception {
-        //expect nothing to happen
+        // expect nothing to happen
         VerificationStartedNotifier.notifyVerificationStarted((List) emptyList(), mockingDetails);
     }
 
     @Test
     public void decent_exception_when_setting_non_mock() throws Exception {
-        VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
+        VerificationStartedNotifier.Event event =
+                new VerificationStartedNotifier.Event(mockingDetails);
 
         try {
-            //when
+            // when
             event.setMock("not a mock");
             fail();
         } catch (Exception e) {
-            //then
-            assertEquals("VerificationStartedEvent.setMock() does not accept parameter which is not a Mockito mock.\n" +
-                "  Received parameter: \"not a mock\".\n" +
-                "  See the Javadoc.", e.getMessage());
+            // then
+            assertEquals(
+                    "VerificationStartedEvent.setMock() does not accept parameter which is not a Mockito mock.\n"
+                            + "  Received parameter: \"not a mock\".\n"
+                            + "  See the Javadoc.",
+                    e.getMessage());
         }
     }
 
     @Test
     public void shows_clean_exception_message_when_illegal_null_arg_is_used() throws Exception {
-        VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
+        VerificationStartedNotifier.Event event =
+                new VerificationStartedNotifier.Event(mockingDetails);
 
         try {
-            //when
+            // when
             event.setMock(null);
             fail();
         } catch (Exception e) {
-            //then
-            assertEquals("VerificationStartedEvent.setMock() does not accept null parameter. See the Javadoc.", e.getMessage());
+            // then
+            assertEquals(
+                    "VerificationStartedEvent.setMock() does not accept null parameter. See the Javadoc.",
+                    e.getMessage());
         }
     }
 
     @Test
     public void decent_exception_when_setting_mock_of_wrong_type() throws Exception {
         final Set differentTypeMock = mock(Set.class);
-        VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
+        VerificationStartedNotifier.Event event =
+                new VerificationStartedNotifier.Event(mockingDetails);
 
         try {
-            //when
+            // when
             event.setMock(differentTypeMock);
             fail();
         } catch (Exception e) {
-            //then
-            assertEquals(filterHashCode("VerificationStartedEvent.setMock() does not accept parameter which is not the same type as the original mock.\n" +
-                "  Required type: java.util.List\n" +
-                "  Received parameter: Mock for Set, hashCode: xxx.\n" +
-                "  See the Javadoc."), filterHashCode(e.getMessage()));
+            // then
+            assertEquals(
+                    filterHashCode(
+                            "VerificationStartedEvent.setMock() does not accept parameter which is not the same type as the original mock.\n"
+                                    + "  Required type: java.util.List\n"
+                                    + "  Received parameter: Mock for Set, hashCode: xxx.\n"
+                                    + "  See the Javadoc."),
+                    filterHashCode(e.getMessage()));
         }
     }
 
     @Test
-    public void decent_exception_when_setting_mock_that_does_not_implement_all_desired_interfaces() throws Exception {
+    public void decent_exception_when_setting_mock_that_does_not_implement_all_desired_interfaces()
+            throws Exception {
         final Set mock = mock(Set.class, withSettings().extraInterfaces(List.class));
         final Set missingExtraInterface = mock(Set.class);
-        VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails(mock));
+        VerificationStartedNotifier.Event event =
+                new VerificationStartedNotifier.Event(mockingDetails(mock));
 
         try {
-            //when setting mock that does not have all necessary interfaces
+            // when setting mock that does not have all necessary interfaces
             event.setMock(missingExtraInterface);
             fail();
         } catch (Exception e) {
-            //then
-            assertEquals(filterHashCode("VerificationStartedEvent.setMock() does not accept parameter which does not implement all extra interfaces of the original mock.\n" +
-                "  Required type: java.util.Set\n" +
-                "  Required extra interface: java.util.List\n" +
-                "  Received parameter: Mock for Set, hashCode: xxx.\n" +
-                "  See the Javadoc."), filterHashCode(e.getMessage()));
+            // then
+            assertEquals(
+                    filterHashCode(
+                            "VerificationStartedEvent.setMock() does not accept parameter which does not implement all extra interfaces of the original mock.\n"
+                                    + "  Required type: java.util.Set\n"
+                                    + "  Required extra interface: java.util.List\n"
+                                    + "  Received parameter: Mock for Set, hashCode: xxx.\n"
+                                    + "  See the Javadoc."),
+                    filterHashCode(e.getMessage()));
         }
     }
 
     @Test
     public void accepts_replacement_mock_if_all_types_are_compatible() throws Exception {
         final Set mock = mock(Set.class, withSettings().extraInterfaces(List.class, Map.class));
-        final Set compatibleMock = mock(Set.class, withSettings().extraInterfaces(List.class, Map.class));
-        VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails(mock));
+        final Set compatibleMock =
+                mock(Set.class, withSettings().extraInterfaces(List.class, Map.class));
+        VerificationStartedNotifier.Event event =
+                new VerificationStartedNotifier.Event(mockingDetails(mock));
 
-        //when
+        // when
         event.setMock(compatibleMock);
 
-        //then
+        // then
         assertEquals(compatibleMock, event.getMock());
     }
 }
diff --git a/src/test/java/org/mockito/internal/matchers/CapturingMatcherTest.java b/src/test/java/org/mockito/internal/matchers/CapturingMatcherTest.java
index be2b369..a4c6b59 100644
--- a/src/test/java/org/mockito/internal/matchers/CapturingMatcherTest.java
+++ b/src/test/java/org/mockito/internal/matchers/CapturingMatcherTest.java
@@ -4,70 +4,71 @@
  */
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockitoutil.TestBase;
-
-import java.util.Iterator;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import java.util.Iterator;
+
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockitoutil.TestBase;
+
 public class CapturingMatcherTest extends TestBase {
 
     @Test
     public void should_capture_arguments() throws Exception {
-        //given
+        // given
         CapturingMatcher<String> m = new CapturingMatcher<String>();
 
-        //when
+        // when
         m.captureFrom("foo");
         m.captureFrom("bar");
 
-        //then
+        // then
         assertThat(m.getAllValues()).containsSequence("foo", "bar");
     }
 
     @Test
     public void should_know_last_captured_value() throws Exception {
-        //given
+        // given
         CapturingMatcher<String> m = new CapturingMatcher<String>();
 
-        //when
+        // when
         m.captureFrom("foo");
         m.captureFrom("bar");
 
-        //then
+        // then
         assertEquals("bar", m.getLastValue());
     }
 
     @Test
     public void should_scream_when_nothing_yet_captured() throws Exception {
-        //given
+        // given
         CapturingMatcher<String> m = new CapturingMatcher<String>();
 
         try {
-            //when
+            // when
             m.getLastValue();
-            //then
+            // then
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 
     @Test
     public void should_not_fail_when_used_in_concurrent_tests() throws Exception {
-        //given
+        // given
         final CapturingMatcher<String> m = new CapturingMatcher<String>();
 
-        //when
+        // when
         m.captureFrom("concurrent access");
         Iterator<String> iterator = m.getAllValues().iterator();
         m.captureFrom("concurrent access");
 
-        //then
+        // then
         assertThat(iterator.hasNext()).isTrue();
-        assertThat(iterator.next()).isEqualTo("concurrent access"); // Potential ConcurrentModificationException
+        assertThat(iterator.next())
+                .isEqualTo("concurrent access"); // Potential ConcurrentModificationException
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/matchers/ComparableMatchersTest.java b/src/test/java/org/mockito/internal/matchers/ComparableMatchersTest.java
index ac8d8d1..583a848 100644
--- a/src/test/java/org/mockito/internal/matchers/ComparableMatchersTest.java
+++ b/src/test/java/org/mockito/internal/matchers/ComparableMatchersTest.java
@@ -2,16 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import java.math.BigDecimal;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class ComparableMatchersTest extends TestBase {
 
@@ -44,8 +43,12 @@ public class ComparableMatchersTest extends TestBase {
         assertTrue(cmpEq.matches(new BigDecimal("5")));
     }
 
-    private void test(CompareTo<String> compareTo, boolean lower, boolean higher,
-            boolean equals, String name) {
+    private void test(
+            CompareTo<String> compareTo,
+            boolean lower,
+            boolean higher,
+            boolean equals,
+            String name) {
 
         assertEquals(lower, compareTo.matches("a"));
         assertEquals(equals, compareTo.matches("b"));
diff --git a/src/test/java/org/mockito/internal/matchers/EqualityTest.java b/src/test/java/org/mockito/internal/matchers/EqualityTest.java
index 4c4ad4f..81f1f68 100644
--- a/src/test/java/org/mockito/internal/matchers/EqualityTest.java
+++ b/src/test/java/org/mockito/internal/matchers/EqualityTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.internal.matchers.Equality.areEqual;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class EqualityTest extends TestBase {
 
     @Test
@@ -23,14 +23,15 @@ public class EqualityTest extends TestBase {
         assertTrue(areEqual(new Object[10], new Object[10]));
         assertTrue(areEqual(new int[] {1}, new Integer[] {1}));
         assertTrue(areEqual(new Object[] {"1"}, new String[] {"1"}));
-        Object badequals=new BadEquals();
-        assertTrue(areEqual(badequals,badequals));
+        Object badequals = new BadEquals();
+        assertTrue(areEqual(badequals, badequals));
 
         assertFalse(areEqual(new Object[9], new Object[10]));
         assertFalse(areEqual(new int[] {1, 2}, new int[] {1}));
         assertFalse(areEqual(new int[] {1}, new double[] {1.0}));
     }
 
+    @SuppressWarnings("EqualsHashCode")
     private final class BadEquals {
         @Override
         public boolean equals(Object oth) {
diff --git a/src/test/java/org/mockito/internal/matchers/EqualsTest.java b/src/test/java/org/mockito/internal/matchers/EqualsTest.java
index 6a1f321..ba5c578 100644
--- a/src/test/java/org/mockito/internal/matchers/EqualsTest.java
+++ b/src/test/java/org/mockito/internal/matchers/EqualsTest.java
@@ -2,14 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.*;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class EqualsTest extends TestBase {
 
@@ -30,21 +28,21 @@ public class EqualsTest extends TestBase {
 
     @Test
     public void shouldDescribeWithExtraTypeInfo() throws Exception {
-        String descStr = new Equals(100).toStringWithType();
+        String descStr = new Equals(100).toStringWithType(Integer.class.getSimpleName());
 
         assertEquals("(Integer) 100", descStr);
     }
 
     @Test
     public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {
-        String descStr = new Equals(100L).toStringWithType();
+        String descStr = new Equals(100L).toStringWithType(Long.class.getSimpleName());
 
         assertEquals("(Long) 100L", descStr);
     }
 
     @Test
     public void shouldDescribeWithTypeOfString() throws Exception {
-        String descStr = new Equals("x").toStringWithType();
+        String descStr = new Equals("x").toStringWithType(String.class.getSimpleName());
 
         assertEquals("(String) \"x\"", descStr);
     }
@@ -79,29 +77,29 @@ public class EqualsTest extends TestBase {
 
     @Test
     public void shouldMatchTypes() throws Exception {
-        //when
+        // when
         ContainsExtraTypeInfo equals = new Equals(10);
 
-        //then
+        // then
         assertTrue(equals.typeMatches(10));
         assertFalse(equals.typeMatches(10L));
     }
 
     @Test
     public void shouldMatchTypesSafelyWhenActualIsNull() throws Exception {
-        //when
+        // when
         ContainsExtraTypeInfo equals = new Equals(null);
 
-        //then
+        // then
         assertFalse(equals.typeMatches(10));
     }
 
     @Test
     public void shouldMatchTypesSafelyWhenGivenIsNull() throws Exception {
-        //when
+        // when
         ContainsExtraTypeInfo equals = new Equals(10);
 
-        //then
+        // then
         assertFalse(equals.typeMatches(null));
     }
 }
diff --git a/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java b/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
index 127fd57..8addef8 100644
--- a/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
+++ b/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
@@ -4,22 +4,21 @@
  */
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
 
 public class InstanceOfTest {
 
     @Test
     public void should_describe_the_matcher() {
-        assertThat(new InstanceOf(Object.class).toString()).contains("isA")
-                                                           .contains("Object");
-        assertThat(new InstanceOf(Object[].class).toString()).contains("isA")
-                                                           .contains("Object[]");
-        assertThat(new InstanceOf(Object.class, "matches something").toString()).isEqualTo("matches something");
+        assertThat(new InstanceOf(Object.class).toString()).contains("isA").contains("Object");
+        assertThat(new InstanceOf(Object[].class).toString()).contains("isA").contains("Object[]");
+        assertThat(new InstanceOf(Object.class, "matches something").toString())
+                .isEqualTo("matches something");
     }
 
     @Test
diff --git a/src/test/java/org/mockito/internal/matchers/MatchersPrinterTest.java b/src/test/java/org/mockito/internal/matchers/MatchersPrinterTest.java
index b2d9215..74cfd9d 100644
--- a/src/test/java/org/mockito/internal/matchers/MatchersPrinterTest.java
+++ b/src/test/java/org/mockito/internal/matchers/MatchersPrinterTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-import org.mockito.internal.matchers.text.MatchersPrinter;
-import org.mockito.internal.reporting.PrintSettings;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
 
 import java.util.Arrays;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
+import org.junit.Test;
+import org.mockito.internal.matchers.text.MatchersPrinter;
+import org.mockito.internal.reporting.PrintSettings;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class MatchersPrinterTest extends TestBase {
@@ -21,45 +21,61 @@ public class MatchersPrinterTest extends TestBase {
 
     @Test
     public void shouldGetArgumentsLine() {
-        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
+        String line =
+                printer.getArgumentsLine(
+                        (List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
         assertEquals("(1, 2);", line);
     }
 
     @Test
     public void shouldGetArgumentsBlock() {
-        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
+        String line =
+                printer.getArgumentsBlock(
+                        (List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
         assertEquals("(\n    1,\n    2\n);", line);
     }
 
     @Test
     public void shouldDescribeTypeInfoOnlyMarkedMatchers() {
-        //when
-        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));
-        //then
+        // when
+        String line =
+                printer.getArgumentsLine(
+                        (List) Arrays.asList(new Equals(1L), new Equals(2)),
+                        PrintSettings.verboseMatchers(1));
+        // then
         assertEquals("(1L, (Integer) 2);", line);
     }
 
     @Test
     public void shouldDescribeStringMatcher() {
-        //when
-        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals("x")), PrintSettings.verboseMatchers(1));
-        //then
+        // when
+        String line =
+                printer.getArgumentsLine(
+                        (List) Arrays.asList(new Equals(1L), new Equals("x")),
+                        PrintSettings.verboseMatchers(1));
+        // then
         assertEquals("(1L, (String) \"x\");", line);
     }
 
     @Test
     public void shouldGetVerboseArgumentsInBlock() {
-        //when
-        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(0, 1));
-        //then
+        // when
+        String line =
+                printer.getArgumentsBlock(
+                        (List) Arrays.asList(new Equals(1L), new Equals(2)),
+                        PrintSettings.verboseMatchers(0, 1));
+        // then
         assertEquals("(\n    (Long) 1L,\n    (Integer) 2\n);", line);
     }
 
     @Test
     public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {
-        //when
-        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseMatchers(0));
-        //then
+        // when
+        String line =
+                printer.getArgumentsLine(
+                        (List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL),
+                        PrintSettings.verboseMatchers(0));
+        // then
         assertEquals("((Long) 1L, notNull());", line);
     }
 }
diff --git a/src/test/java/org/mockito/internal/matchers/MatchersToStringTest.java b/src/test/java/org/mockito/internal/matchers/MatchersToStringTest.java
index e0a1241..6d243a0 100644
--- a/src/test/java/org/mockito/internal/matchers/MatchersToStringTest.java
+++ b/src/test/java/org/mockito/internal/matchers/MatchersToStringTest.java
@@ -2,16 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.matchers;
 
+import static org.junit.Assert.assertEquals;
+
 import java.util.regex.Pattern;
+
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class MatchersToStringTest extends TestBase {
 
     @Test
@@ -41,19 +41,19 @@ public class MatchersToStringTest extends TestBase {
 
     @Test
     public void sameToStringWithObject() {
-        Object o = new Object() {
-            @Override
-            public String toString() {
-                return "X";
-            }
-        };
+        Object o =
+                new Object() {
+                    @Override
+                    public String toString() {
+                        return "X";
+                    }
+                };
         assertEquals("same(X)", new Same(o).toString());
     }
 
     @Test
     public void equalsToStringWithString() {
         assertEquals("\"X\"", new Equals("X").toString());
-
     }
 
     @Test
@@ -63,20 +63,21 @@ public class MatchersToStringTest extends TestBase {
 
     @Test
     public void equalsToStringWithObject() {
-        Object o = new Object() {
-            @Override
-            public String toString() {
-                return "X";
-            }
-        };
+        Object o =
+                new Object() {
+                    @Override
+                    public String toString() {
+                        return "X";
+                    }
+                };
         assertEquals("X", new Equals(o).toString());
     }
 
     @Test
     public void orToString() {
-        ArgumentMatcher<?> m1=new Equals(1);
-        ArgumentMatcher<?> m2=new Equals(2);
-        assertEquals("or(1, 2)", new Or(m1,m2).toString());
+        ArgumentMatcher<?> m1 = new Equals(1);
+        ArgumentMatcher<?> m2 = new Equals(2);
+        assertEquals("or(1, 2)", new Or(m1, m2).toString());
     }
 
     @Test
@@ -86,9 +87,9 @@ public class MatchersToStringTest extends TestBase {
 
     @Test
     public void andToString() {
-        ArgumentMatcher<?> m1=new Equals(1);
-        ArgumentMatcher<?> m2=new Equals(2);
-        assertEquals("and(1, 2)", new And(m1,m2).toString());
+        ArgumentMatcher<?> m1 = new Equals(1);
+        ArgumentMatcher<?> m2 = new Equals(2);
+        assertEquals("and(1, 2)", new And(m1, m2).toString());
     }
 
     @Test
@@ -116,5 +117,4 @@ public class MatchersToStringTest extends TestBase {
         assertEquals("matches(\"\\\\s+\")", new Matches("\\s+").toString());
         assertEquals("matches(\"\\\\s+\")", new Matches(Pattern.compile("\\s+")).toString());
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java b/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
index a810b8a..f3bd2ae 100644
--- a/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
+++ b/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
@@ -4,74 +4,73 @@
  */
 package org.mockito.internal.matchers;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Test;
+
 /**
  * Tests for the Matchers that operate over strings
  */
 public class StringMatchersTest {
-	@Test
-	public void startsWithString() {
-		assertTrue(new StartsWith("mockito").matches("mockito is here"));
-	}
-
-	@Test
-	public void doesNotStartWithString() {
-		assertFalse(new StartsWith("junit").matches("mockito is here"));
-	}
+    @Test
+    public void startsWithString() {
+        assertTrue(new StartsWith("mockito").matches("mockito is here"));
+    }
 
-	@Test
-	public void nullStartsWith() {
-		assertFalse(new StartsWith("java").matches(null));
-	}
+    @Test
+    public void doesNotStartWithString() {
+        assertFalse(new StartsWith("junit").matches("mockito is here"));
+    }
 
-	@Test
-	public void endsWithString() {
-		assertTrue(new EndsWith("mockito").matches("here is mockito"));
-	}
+    @Test
+    public void nullStartsWith() {
+        assertFalse(new StartsWith("java").matches(null));
+    }
 
-	@Test
-	public void doesNotEndWithString() {
-		assertFalse(new EndsWith("junit").matches("here is mockito"));
-	}
+    @Test
+    public void endsWithString() {
+        assertTrue(new EndsWith("mockito").matches("here is mockito"));
+    }
 
-	@Test
-	public void nullEndsWith() {
-		assertFalse(new EndsWith("java").matches(null));
-	}
+    @Test
+    public void doesNotEndWithString() {
+        assertFalse(new EndsWith("junit").matches("here is mockito"));
+    }
 
-	@Test
-	public void containsString() {
-		assertTrue(new Contains("mockito").matches("****mockito****"));
-	}
+    @Test
+    public void nullEndsWith() {
+        assertFalse(new EndsWith("java").matches(null));
+    }
 
-	@Test
-	public void stringDoesNotContain() {
-		assertFalse(new Contains("junit").matches("****mockito****"));
-	}
+    @Test
+    public void containsString() {
+        assertTrue(new Contains("mockito").matches("****mockito****"));
+    }
 
-	@Test
-	public void nullContainsNothing() {
-		assertFalse(new Contains("mockito").matches(null));
-	}
+    @Test
+    public void stringDoesNotContain() {
+        assertFalse(new Contains("junit").matches("****mockito****"));
+    }
 
-	@Test
-	public void matchesRegex() {
-		assertTrue(new Find("eleph.nt").matches("the elephant in the room"));
-		assertTrue(new Find("eleph.nt").matches("the elephInt in the room"));
-	}
+    @Test
+    public void nullContainsNothing() {
+        assertFalse(new Contains("mockito").matches(null));
+    }
 
-	@Test
-	public void doesNotMatchRegex() {
-		assertFalse(new Find("eleph.nt").matches("the otter in the room"));
-	}
+    @Test
+    public void matchesRegex() {
+        assertTrue(new Find("eleph.nt").matches("the elephant in the room"));
+        assertTrue(new Find("eleph.nt").matches("the elephInt in the room"));
+    }
 
-	@Test
-	public void nullDoesNotMatchRegex() {
-		assertFalse(new Find("eleph.nt").matches(null));
-	}
+    @Test
+    public void doesNotMatchRegex() {
+        assertFalse(new Find("eleph.nt").matches("the otter in the room"));
+    }
 
+    @Test
+    public void nullDoesNotMatchRegex() {
+        assertFalse(new Find("eleph.nt").matches(null));
+    }
 }
diff --git a/src/test/java/org/mockito/internal/matchers/apachecommons/EqualsBuilderTest.java b/src/test/java/org/mockito/internal/matchers/apachecommons/EqualsBuilderTest.java
index 7baecfa..53f3410 100644
--- a/src/test/java/org/mockito/internal/matchers/apachecommons/EqualsBuilderTest.java
+++ b/src/test/java/org/mockito/internal/matchers/apachecommons/EqualsBuilderTest.java
@@ -2,18 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
-//Class comes from Apache Commons Lang, added some tiny changes
 package org.mockito.internal.matchers.apachecommons;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.*;
 
 import java.math.BigDecimal;
 import java.util.Arrays;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
+// Class comes from Apache Commons Lang, added some tiny changes
 /**
  * @author <a href="mailto:sdowney@panix.com">Steve Downey</a>
  * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
@@ -24,20 +23,24 @@ import static org.junit.Assert.*;
 public class EqualsBuilderTest extends TestBase {
 
     @Test
-    public void testname() throws Exception {
-
-    }
+    public void testname() throws Exception {}
 
     static class TestObject {
         private int a;
-        public TestObject() {
-        }
+
+        public TestObject() {}
+
         public TestObject(int a) {
             this.a = a;
         }
+
         public boolean equals(Object o) {
-            if (o == null) { return false; }
-            if (o == this) { return true; }
+            if (o == null) {
+                return false;
+            }
+            if (o == this) {
+                return true;
+            }
             if (o.getClass() != getClass()) {
                 return false;
             }
@@ -45,6 +48,7 @@ public class EqualsBuilderTest extends TestBase {
             TestObject rhs = (TestObject) o;
             return (a == rhs.a);
         }
+
         public int hashCode() {
             return super.hashCode();
         }
@@ -60,16 +64,23 @@ public class EqualsBuilderTest extends TestBase {
 
     static class TestSubObject extends TestObject {
         private int b;
+
         public TestSubObject() {
             super(0);
         }
+
         public TestSubObject(int a, int b) {
             super(a);
             this.b = b;
         }
+
         public boolean equals(Object o) {
-            if (o == null) { return false; }
-            if (o == this) { return true; }
+            if (o == null) {
+                return false;
+            }
+            if (o == this) {
+                return true;
+            }
             if (o.getClass() != getClass()) {
                 return false;
             }
@@ -77,6 +88,7 @@ public class EqualsBuilderTest extends TestBase {
             TestSubObject rhs = (TestSubObject) o;
             return super.equals(o) && (b == rhs.b);
         }
+
         public int hashCode() {
             return 1;
         }
@@ -99,6 +111,7 @@ public class EqualsBuilderTest extends TestBase {
     @SuppressWarnings("unused")
     static class TestTSubObject extends TestObject {
         private transient int t;
+
         public TestTSubObject(int a, int t) {
             super(a);
             this.t = t;
@@ -108,6 +121,7 @@ public class EqualsBuilderTest extends TestBase {
     @SuppressWarnings("unused")
     static class TestTTSubObject extends TestTSubObject {
         private transient int tt;
+
         public TestTTSubObject(int a, int t, int tt) {
             super(a, t);
             this.tt = tt;
@@ -117,6 +131,7 @@ public class EqualsBuilderTest extends TestBase {
     @SuppressWarnings("unused")
     static class TestTTLeafObject extends TestTTSubObject {
         private int leafValue;
+
         public TestTTLeafObject(int a, int t, int tt, int leafValue) {
             super(a, t, tt);
             this.leafValue = leafValue;
@@ -125,18 +140,22 @@ public class EqualsBuilderTest extends TestBase {
 
     static class TestTSubObject2 extends TestObject {
         private transient int t;
+
         public TestTSubObject2(int a, int t) {
             super(a);
         }
+
         public int getT() {
             return t;
         }
+
         public void setT(int t) {
             this.t = t;
         }
     }
 
-    @Test public void testReflectionEquals() {
+    @Test
+    public void testReflectionEquals() {
         TestObject o1 = new TestObject(4);
         TestObject o2 = new TestObject(5);
         assertTrue(EqualsBuilder.reflectionEquals(o1, o1));
@@ -151,18 +170,29 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));
     }
 
-    @Test public void testReflectionHierarchyEquals() {
+    @Test
+    public void testReflectionHierarchyEquals() {
         testReflectionHierarchyEquals(false);
         testReflectionHierarchyEquals(true);
         // Transients
-        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));
-        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));
     }
 
-  private void testReflectionHierarchyEquals(boolean testTransients) {
+    private void testReflectionHierarchyEquals(boolean testTransients) {
         TestObject to1 = new TestObject(4);
         TestObject to1Bis = new TestObject(4);
         TestObject to1Ter = new TestObject(4);
@@ -176,43 +206,79 @@ public class EqualsBuilderTest extends TestBase {
         TestSubObject tso1ter = new TestSubObject(1, 4);
         TestSubObject tso2 = new TestSubObject(2, 5);
 
-        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);
-        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);
+        testReflectionEqualsEquivalenceRelationship(
+                to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);
+        testReflectionEqualsEquivalenceRelationship(
+                tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);
 
         // More sanity checks:
 
         // same values
         assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));
-        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));
         // same super values, diff sub values
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));
         // diff super values, same sub values
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));
 
         // mix super and sub types: equals
         assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));
         assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));
 
-        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert
-        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        to1, ttso, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        ttso, to1, false)); // Force testTransients = false for this assert
 
-        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert
-        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        to1, tttso, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        tttso, to1, false)); // Force testTransients = false for this assert
 
-        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert
-        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        ttso, tttso, false)); // Force testTransients = false for this assert
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        tttso, ttso, false)); // Force testTransients = false for this assert
 
         // mix super and sub types: NOT equals
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestObject(0), new TestEmptySubObject(1), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestEmptySubObject(1), new TestObject(0), testTransients));
 
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestObject(0), new TestTSubObject(1, 1), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestTSubObject(1, 1), new TestObject(0), testTransients));
 
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));
-        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestObject(1), new TestSubObject(0, 10), testTransients));
+        assertTrue(
+                !EqualsBuilder.reflectionEquals(
+                        new TestSubObject(0, 10), new TestObject(1), testTransients));
 
         assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));
         assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));
@@ -234,25 +300,27 @@ public class EqualsBuilderTest extends TestBase {
      * @param oToChange a TestObject that will be changed
      */
     private void testReflectionEqualsEquivalenceRelationship(
-        TestObject to,
-        TestObject toBis,
-        TestObject toTer,
-        TestObject to2,
-        TestObject oToChange,
-        boolean testTransients) {
+            TestObject to,
+            TestObject toBis,
+            TestObject toTer,
+            TestObject to2,
+            TestObject oToChange,
+            boolean testTransients) {
 
         // reflection test
         assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));
         assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));
 
         // symmetry test
-        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));
+        assertTrue(
+                EqualsBuilder.reflectionEquals(to, toBis, testTransients)
+                        && EqualsBuilder.reflectionEquals(toBis, to, testTransients));
 
         // transitive test
         assertTrue(
-            EqualsBuilder.reflectionEquals(to, toBis, testTransients)
-                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)
-                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));
+                EqualsBuilder.reflectionEquals(to, toBis, testTransients)
+                        && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)
+                        && EqualsBuilder.reflectionEquals(to, toTer, testTransients));
 
         // consistency test
         oToChange.setA(to.getA());
@@ -276,7 +344,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));
     }
 
-    @Test public void testSuper() {
+    @Test
+    public void testSuper() {
         TestObject o1 = new TestObject(4);
         TestObject o2 = new TestObject(5);
         assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());
@@ -285,7 +354,8 @@ public class EqualsBuilderTest extends TestBase {
         assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());
     }
 
-    @Test public void testObject() {
+    @Test
+    public void testObject() {
         TestObject o1 = new TestObject(4);
         TestObject o2 = new TestObject(5);
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
@@ -300,70 +370,85 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());
     }
 
-    @Test public void testLong() {
+    @Test
+    public void testLong() {
         long o1 = 1L;
         long o2 = 2L;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testInt() {
+    @Test
+    public void testInt() {
         int o1 = 1;
         int o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testShort() {
+    @Test
+    public void testShort() {
         short o1 = 1;
         short o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testChar() {
+    @Test
+    public void testChar() {
         char o1 = 1;
         char o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testByte() {
+    @Test
+    public void testByte() {
         byte o1 = 1;
         byte o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testDouble() {
+    @Test
+    public void testDouble() {
         double o1 = 1;
         double o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());
         assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());
-        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());
+        assertTrue(
+                new EqualsBuilder()
+                        .append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)
+                        .isEquals());
     }
 
-    @Test public void testFloat() {
+    @Test
+    public void testFloat() {
         float o1 = 1;
         float o2 = 2;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());
         assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());
-        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());
+        assertTrue(
+                new EqualsBuilder()
+                        .append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY)
+                        .isEquals());
     }
 
     // https://issues.apache.org/jira/browse/LANG-393
-    @Test public void testBigDecimal() {
+    @Test
+    public void testBigDecimal() {
         BigDecimal o1 = new BigDecimal("2.0");
         BigDecimal o2 = new BigDecimal("2.00");
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testAccessors() {
+    @Test
+    public void testAccessors() {
         EqualsBuilder equalsBuilder = new EqualsBuilder();
         assertTrue(equalsBuilder.isEquals());
         equalsBuilder.setEquals(true);
@@ -372,14 +457,16 @@ public class EqualsBuilderTest extends TestBase {
         assertFalse(equalsBuilder.isEquals());
     }
 
-    @Test public void testBoolean() {
+    @Test
+    public void testBoolean() {
         boolean o1 = true;
         boolean o2 = false;
         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());
         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());
     }
 
-    @Test public void testObjectArray() {
+    @Test
+    public void testObjectArray() {
         TestObject[] obj1 = new TestObject[3];
         obj1[0] = new TestObject(4);
         obj1[1] = new TestObject(5);
@@ -407,7 +494,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testLongArray() {
+    @Test
+    public void testLongArray() {
         long[] obj1 = new long[2];
         obj1[0] = 5L;
         obj1[1] = 6L;
@@ -425,7 +513,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testIntArray() {
+    @Test
+    public void testIntArray() {
         int[] obj1 = new int[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -443,7 +532,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testShortArray() {
+    @Test
+    public void testShortArray() {
         short[] obj1 = new short[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -461,7 +551,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testCharArray() {
+    @Test
+    public void testCharArray() {
         char[] obj1 = new char[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -479,7 +570,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testByteArray() {
+    @Test
+    public void testByteArray() {
         byte[] obj1 = new byte[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -497,7 +589,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testDoubleArray() {
+    @Test
+    public void testDoubleArray() {
         double[] obj1 = new double[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -515,7 +608,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testFloatArray() {
+    @Test
+    public void testFloatArray() {
         float[] obj1 = new float[2];
         obj1[0] = 5;
         obj1[1] = 6;
@@ -533,7 +627,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testBooleanArray() {
+    @Test
+    public void testBooleanArray() {
         boolean[] obj1 = new boolean[2];
         obj1[0] = true;
         obj1[1] = false;
@@ -551,7 +646,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testMultiLongArray() {
+    @Test
+    public void testMultiLongArray() {
         long[][] array1 = new long[2][2];
         long[][] array2 = new long[2][2];
         for (int i = 0; i < array1.length; ++i) {
@@ -566,7 +662,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiIntArray() {
+    @Test
+    public void testMultiIntArray() {
         int[][] array1 = new int[2][2];
         int[][] array2 = new int[2][2];
         for (int i = 0; i < array1.length; ++i) {
@@ -581,7 +678,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiShortArray() {
+    @Test
+    public void testMultiShortArray() {
         short[][] array1 = new short[2][2];
         short[][] array2 = new short[2][2];
         for (short i = 0; i < array1.length; ++i) {
@@ -596,7 +694,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiCharArray() {
+    @Test
+    public void testMultiCharArray() {
         char[][] array1 = new char[2][2];
         char[][] array2 = new char[2][2];
         for (char i = 0; i < array1.length; ++i) {
@@ -611,7 +710,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiByteArray() {
+    @Test
+    public void testMultiByteArray() {
         byte[][] array1 = new byte[2][2];
         byte[][] array2 = new byte[2][2];
         for (byte i = 0; i < array1.length; ++i) {
@@ -625,7 +725,9 @@ public class EqualsBuilderTest extends TestBase {
         array1[1][1] = 0;
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
-    @Test public void testMultiFloatArray() {
+
+    @Test
+    public void testMultiFloatArray() {
         float[][] array1 = new float[2][2];
         float[][] array2 = new float[2][2];
         for (int i = 0; i < array1.length; ++i) {
@@ -640,7 +742,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiDoubleArray() {
+    @Test
+    public void testMultiDoubleArray() {
         double[][] array1 = new double[2][2];
         double[][] array2 = new double[2][2];
         for (int i = 0; i < array1.length; ++i) {
@@ -655,7 +758,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMultiBooleanArray() {
+    @Test
+    public void testMultiBooleanArray() {
         boolean[][] array1 = new boolean[2][2];
         boolean[][] array2 = new boolean[2][2];
         for (int i = 0; i < array1.length; ++i) {
@@ -670,14 +774,15 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
 
         // compare 1 dim to 2.
-        boolean[] array3 = new boolean[]{true, true};
+        boolean[] array3 = new boolean[] {true, true};
         assertFalse(new EqualsBuilder().append(array1, array3).isEquals());
         assertFalse(new EqualsBuilder().append(array3, array1).isEquals());
         assertFalse(new EqualsBuilder().append(array2, array3).isEquals());
         assertFalse(new EqualsBuilder().append(array3, array2).isEquals());
     }
 
-    @Test public void testRaggedArray() {
+    @Test
+    public void testRaggedArray() {
         long[][] array1 = new long[2][];
         long[][] array2 = new long[2][];
         for (int i = 0; i < array1.length; ++i) {
@@ -694,7 +799,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testMixedArray() {
+    @Test
+    public void testMixedArray() {
         Object[] array1 = new Object[2];
         Object[] array2 = new Object[2];
         for (int i = 0; i < array1.length; ++i) {
@@ -711,7 +817,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());
     }
 
-    @Test public void testObjectArrayHiddenByObject() {
+    @Test
+    public void testObjectArrayHiddenByObject() {
         TestObject[] array1 = new TestObject[2];
         array1[0] = new TestObject(4);
         array1[1] = new TestObject(5);
@@ -728,7 +835,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testLongArrayHiddenByObject() {
+    @Test
+    public void testLongArrayHiddenByObject() {
         long[] array1 = new long[2];
         array1[0] = 5L;
         array1[1] = 6L;
@@ -745,7 +853,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testIntArrayHiddenByObject() {
+    @Test
+    public void testIntArrayHiddenByObject() {
         int[] array1 = new int[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -762,7 +871,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testShortArrayHiddenByObject() {
+    @Test
+    public void testShortArrayHiddenByObject() {
         short[] array1 = new short[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -779,7 +889,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testCharArrayHiddenByObject() {
+    @Test
+    public void testCharArrayHiddenByObject() {
         char[] array1 = new char[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -796,7 +907,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testByteArrayHiddenByObject() {
+    @Test
+    public void testByteArrayHiddenByObject() {
         byte[] array1 = new byte[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -813,7 +925,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testDoubleArrayHiddenByObject() {
+    @Test
+    public void testDoubleArrayHiddenByObject() {
         double[] array1 = new double[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -830,7 +943,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testFloatArrayHiddenByObject() {
+    @Test
+    public void testFloatArrayHiddenByObject() {
         float[] array1 = new float[2];
         array1[0] = 5;
         array1[1] = 6;
@@ -847,7 +961,8 @@ public class EqualsBuilderTest extends TestBase {
         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());
     }
 
-    @Test public void testBooleanArrayHiddenByObject() {
+    @Test
+    public void testBooleanArrayHiddenByObject() {
         boolean[] array1 = new boolean[2];
         array1[0] = true;
         array1[1] = false;
@@ -883,6 +998,7 @@ public class EqualsBuilderTest extends TestBase {
             }
             return false;
         }
+
         public int hashCode() {
             return 1;
         }
@@ -911,6 +1027,7 @@ public class EqualsBuilderTest extends TestBase {
             }
             return false;
         }
+
         public int hashCode() {
             return 1;
         }
@@ -925,9 +1042,10 @@ public class EqualsBuilderTest extends TestBase {
      * of each other and do not share a parent aside from Object.
      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069
      */
-    @Test public void testUnrelatedClasses() {
-        Object[] x = new Object[]{new TestACanEqualB(1)};
-        Object[] y = new Object[]{new TestBCanEqualA(1)};
+    @Test
+    public void testUnrelatedClasses() {
+        Object[] x = new Object[] {new TestACanEqualB(1)};
+        Object[] y = new Object[] {new TestBCanEqualA(1)};
 
         // sanity checks:
         assertTrue(Arrays.equals(x, x));
@@ -946,18 +1064,20 @@ public class EqualsBuilderTest extends TestBase {
     }
 
     /**
-     * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067
+     * Test from https://issues.apache.org/jira/browse/LANG-42
      */
-    @Test public void testNpeForNullElement() {
-        Object[] x1 = new Object[] { new Integer(1), null, new Integer(3) };
-        Object[] x2 = new Object[] { new Integer(1), new Integer(2), new Integer(3) };
+    @Test
+    public void testNpeForNullElement() {
+        Object[] x1 = new Object[] {new Integer(1), null, new Integer(3)};
+        Object[] x2 = new Object[] {new Integer(1), new Integer(2), new Integer(3)};
 
         // causes an NPE in 2.0 according to:
-        // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067
+        // https://issues.apache.org/jira/browse/LANG-42
         new EqualsBuilder().append(x1, x2);
     }
 
-    @Test public void testReflectionEqualsExcludeFields() throws Exception {
+    @Test
+    public void testReflectionEqualsExcludeFields() throws Exception {
         TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);
         TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);
 
@@ -978,7 +1098,9 @@ public class EqualsBuilderTest extends TestBase {
 
         // still equal as long as both differing fields are among excluded
         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three"}));
-        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three", "xxx"}));
+        assertTrue(
+                EqualsBuilder.reflectionEquals(
+                        x1, x2, new String[] {"one", "two", "three", "xxx"}));
     }
 
     @SuppressWarnings("unused")
diff --git a/src/test/java/org/mockito/internal/matchers/text/MatcherToStringTest.java b/src/test/java/org/mockito/internal/matchers/text/MatcherToStringTest.java
index 23eb71a..746ee69 100644
--- a/src/test/java/org/mockito/internal/matchers/text/MatcherToStringTest.java
+++ b/src/test/java/org/mockito/internal/matchers/text/MatcherToStringTest.java
@@ -4,30 +4,35 @@
  */
 package org.mockito.internal.matchers.text;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class MatcherToStringTest extends TestBase {
 
     static class MatcherWithoutDescription implements ArgumentMatcher<Object> {
+        @Override
         public boolean matches(Object argument) {
             return false;
         }
     }
 
     static class MatcherWithDescription implements ArgumentMatcher<Object> {
+        @Override
         public boolean matches(Object argument) {
             return false;
         }
+
+        @Override
         public String toString() {
             return "*my custom description*";
         }
     }
 
     static class MatcherWithInheritedDescription extends MatcherWithDescription {
+        @Override
         public boolean matches(Object argument) {
             return false;
         }
@@ -35,8 +40,44 @@ public class MatcherToStringTest extends TestBase {
 
     @Test
     public void better_toString_for_matchers() {
-        assertEquals("<Matcher without description>", MatcherToString.toString(new MatcherWithoutDescription()));
-        assertEquals("*my custom description*", MatcherToString.toString(new MatcherWithDescription()));
-        assertEquals("*my custom description*", MatcherToString.toString(new MatcherWithInheritedDescription()));
+        assertEquals(
+                "<Matcher without description>",
+                MatcherToString.toString(new MatcherWithoutDescription()));
+        assertEquals(
+                "*my custom description*", MatcherToString.toString(new MatcherWithDescription()));
+        assertEquals(
+                "*my custom description*",
+                MatcherToString.toString(new MatcherWithInheritedDescription()));
+    }
+
+    @Test
+    public void default_name_for_anonymous_matchers() {
+        ArgumentMatcher<Object> anonymousMatcher =
+                new ArgumentMatcher<Object>() {
+                    @Override
+                    public boolean matches(Object argument) {
+                        return false;
+                    }
+                };
+        assertEquals("<custom argument matcher>", MatcherToString.toString(anonymousMatcher));
+
+        ArgumentMatcher<Object> anonymousDescriptiveMatcher =
+                new MatcherWithDescription() {
+                    @Override
+                    public boolean matches(Object argument) {
+                        return false;
+                    }
+                };
+        assertEquals(
+                "*my custom description*", MatcherToString.toString(anonymousDescriptiveMatcher));
+    }
+
+    @Test
+    public void default_name_for_synthetic_matchers() {
+        ArgumentMatcher<Object> lambdaMatcher = argument -> true;
+        assertEquals("<custom argument matcher>", MatcherToString.toString(lambdaMatcher));
+
+        ArgumentMatcher<Object> methodRefMatcher = lambdaMatcher::matches;
+        assertEquals("<custom argument matcher>", MatcherToString.toString(methodRefMatcher));
     }
 }
diff --git a/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java b/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
index 42559f5..1ece06c 100644
--- a/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
+++ b/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.matchers.text;
 
-
-import java.util.LinkedHashMap;
-import org.junit.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.internal.matchers.text.ValuePrinter.print;
 
+import java.util.LinkedHashMap;
+
+import org.junit.Test;
+
 public class ValuePrinterTest {
 
     @Test
@@ -23,19 +23,30 @@ public class ValuePrinterTest {
         assertThat(print(3L)).isEqualTo("3L");
         assertThat(print(3.14d)).isEqualTo("3.14d");
         assertThat(print(3.14f)).isEqualTo("3.14f");
-        assertThat(print(new int[]{1, 2})).isEqualTo("[1, 2]");
-        assertThat(print(new LinkedHashMap<String, Object>() {{
-            put("foo", 2L);
-        }})).isEqualTo("{\"foo\" = 2L}");
-        assertThat(print(new LinkedHashMap<String, Object>() {{
-            put("int passed as hex", 0x01);
-            put("byte", (byte) 0x01);
-            put("short", (short) 2);
-            put("int", 3);
-            put("long", 4L);
-            put("float", 2.71f);
-            put("double", 3.14d);
-        }})).isEqualTo("{\"int passed as hex\" = 1, \"byte\" = (byte) 0x01, \"short\" = (short) 2, \"int\" = 3, \"long\" = 4L, \"float\" = 2.71f, \"double\" = 3.14d}");
+        assertThat(print(new int[] {1, 2})).isEqualTo("[1, 2]");
+        assertThat(
+                        print(
+                                new LinkedHashMap<String, Object>() {
+                                    {
+                                        put("foo", 2L);
+                                    }
+                                }))
+                .isEqualTo("{\"foo\" = 2L}");
+        assertThat(
+                        print(
+                                new LinkedHashMap<String, Object>() {
+                                    {
+                                        put("int passed as hex", 0x01);
+                                        put("byte", (byte) 0x01);
+                                        put("short", (short) 2);
+                                        put("int", 3);
+                                        put("long", 4L);
+                                        put("float", 2.71f);
+                                        put("double", 3.14d);
+                                    }
+                                }))
+                .isEqualTo(
+                        "{\"int passed as hex\" = 1, \"byte\" = (byte) 0x01, \"short\" = (short) 2, \"int\" = 3, \"long\" = 4L, \"float\" = 2.71f, \"double\" = 3.14d}");
         assertTrue(print(new UnsafeToString()).contains("UnsafeToString"));
         assertThat(print(new ToString())).isEqualTo("ToString");
         assertThat(print(new FormattedText("formatted"))).isEqualTo("formatted");
@@ -53,12 +64,11 @@ public class ValuePrinterTest {
         public String toString() {
             return "ToString";
         }
-
     }
+
     static class UnsafeToString {
         public String toString() {
             throw new RuntimeException("ka-boom!");
         }
-
     }
 }
diff --git a/src/test/java/org/mockito/internal/progress/AtLeastTest.java b/src/test/java/org/mockito/internal/progress/AtLeastTest.java
index e8cc8f8..8e2762b 100644
--- a/src/test/java/org/mockito/internal/progress/AtLeastTest.java
+++ b/src/test/java/org/mockito/internal/progress/AtLeastTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockito.internal.progress;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 public class AtLeastTest extends TestBase {
 
     @Test
diff --git a/src/test/java/org/mockito/internal/progress/MockingProgressImplTest.java b/src/test/java/org/mockito/internal/progress/MockingProgressImplTest.java
index 7ef0334..4b812de 100644
--- a/src/test/java/org/mockito/internal/progress/MockingProgressImplTest.java
+++ b/src/test/java/org/mockito/internal/progress/MockingProgressImplTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Before;
@@ -17,15 +25,6 @@ import org.mockito.listeners.MockitoListener;
 import org.mockito.verification.VerificationMode;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 public class MockingProgressImplTest extends TestBase {
 
     private MockingProgress mockingProgress;
@@ -54,15 +53,16 @@ public class MockingProgressImplTest extends TestBase {
         try {
             mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 
     @Test
     public void shouldNotifyListenerSafely() throws Exception {
-        //when
+        // when
         mockingProgress.addListener(null);
 
-        //then no exception is thrown:
+        // then no exception is thrown:
         mockingProgress.mockingStarted(null, null);
     }
 
@@ -73,36 +73,39 @@ public class MockingProgressImplTest extends TestBase {
 
         final Set<MockitoListener> listeners = new LinkedHashSet<MockitoListener>();
 
-        //when
+        // when
         MockingProgressImpl.addListener(listener1, listeners);
 
-        //then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                MockingProgressImpl.addListener(listener2, listeners);
-            }
-        }).isInstanceOf(RedundantListenerException.class);
+        // then
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                MockingProgressImpl.addListener(listener2, listeners);
+                            }
+                        })
+                .isInstanceOf(RedundantListenerException.class);
     }
 
     @Test
     public void should_clean_up_listeners_automatically() {
         MockitoListener someListener = mock(MockitoListener.class);
         MyListener cleanListener = mock(MyListener.class);
-        MyListener dirtyListener = when(mock(MyListener.class).isListenerDirty()).thenReturn(true).getMock();
+        MyListener dirtyListener =
+                when(mock(MyListener.class).isListenerDirty()).thenReturn(true).getMock();
 
         Set<MockitoListener> listeners = new LinkedHashSet<MockitoListener>();
 
-        //when
+        // when
         MockingProgressImpl.addListener(someListener, listeners);
         MockingProgressImpl.addListener(dirtyListener, listeners);
 
-        //then
+        // then
         Assertions.assertThat(listeners).containsExactlyInAnyOrder(someListener, dirtyListener);
 
-        //when
+        // when
         MockingProgressImpl.addListener(cleanListener, listeners);
 
-        //then dirty listener was removed automatically
+        // then dirty listener was removed automatically
         Assertions.assertThat(listeners).containsExactlyInAnyOrder(someListener, cleanListener);
     }
 
diff --git a/src/test/java/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java b/src/test/java/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java
index 673ca10..26ba187 100644
--- a/src/test/java/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java
+++ b/src/test/java/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java
@@ -4,18 +4,18 @@
  */
 package org.mockito.internal.progress;
 
-import org.junit.After;
-import org.junit.Test;
-import org.mockito.internal.verification.DummyVerificationMode;
-import org.mockitoutil.TestBase;
-
-import java.util.List;
-
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 
+import java.util.List;
+
+import org.junit.After;
+import org.junit.Test;
+import org.mockito.internal.verification.DummyVerificationMode;
+import org.mockitoutil.TestBase;
+
 public class ThreadSafeMockingProgressTest extends TestBase {
 
     @After
@@ -25,11 +25,11 @@ public class ThreadSafeMockingProgressTest extends TestBase {
 
     @Test
     public void shouldShareState() throws Exception {
-        //given
+        // given
         MockingProgress p = mockingProgress();
         p.verificationStarted(new DummyVerificationMode());
 
-        //then
+        // then
         p = mockingProgress();
         assertNotNull(p.pullVerificationMode());
     }
@@ -37,11 +37,11 @@ public class ThreadSafeMockingProgressTest extends TestBase {
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void shouldKnowWhenVerificationHasStarted() throws Exception {
-        //given
+        // given
         verify(mock(List.class));
         MockingProgress p = mockingProgress();
 
-        //then
+        // then
         assertNotNull(p.pullVerificationMode());
     }
 }
diff --git a/src/test/java/org/mockito/internal/progress/TimesTest.java b/src/test/java/org/mockito/internal/progress/TimesTest.java
index d0095bd..1605d60 100644
--- a/src/test/java/org/mockito/internal/progress/TimesTest.java
+++ b/src/test/java/org/mockito/internal/progress/TimesTest.java
@@ -2,26 +2,23 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
-import org.junit.Rule;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.VerificationModeFactory;
 
-
-public class TimesTest  {
-	@Rule
-	public ExpectedException exception = ExpectedException.none();
+public class TimesTest {
 
     @Test
-    public void shouldNotAllowNegativeNumberOfInvocations() throws Exception {
-
-    	exception.expect(MockitoException.class);
-    	exception.expectMessage("Negative value is not allowed here");
-
-    	VerificationModeFactory.times(-50);
+    public void shouldNotAllowNegativeNumberOfInvocations() {
+        assertThatThrownBy(
+                        () -> {
+                            VerificationModeFactory.times(-50);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage("Negative value is not allowed here");
     }
 }
diff --git a/src/test/java/org/mockito/internal/progress/VerificationModeBuilder.java b/src/test/java/org/mockito/internal/progress/VerificationModeBuilder.java
index a22fabd..07fedac 100644
--- a/src/test/java/org/mockito/internal/progress/VerificationModeBuilder.java
+++ b/src/test/java/org/mockito/internal/progress/VerificationModeBuilder.java
@@ -2,10 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.progress;
 
-
 import org.mockito.internal.verification.Times;
 import org.mockito.internal.verification.VerificationModeFactory;
 
diff --git a/src/test/java/org/mockito/internal/reporting/PluralizerTest.java b/src/test/java/org/mockito/internal/reporting/PluralizerTest.java
index e559581..c1be438 100644
--- a/src/test/java/org/mockito/internal/reporting/PluralizerTest.java
+++ b/src/test/java/org/mockito/internal/reporting/PluralizerTest.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.reporting;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class PluralizerTest extends TestBase {
 
     @Test
diff --git a/src/test/java/org/mockito/internal/runners/DefaultInternalRunnerTest.java b/src/test/java/org/mockito/internal/runners/DefaultInternalRunnerTest.java
index cca74bc..c8912ec 100644
--- a/src/test/java/org/mockito/internal/runners/DefaultInternalRunnerTest.java
+++ b/src/test/java/org/mockito/internal/runners/DefaultInternalRunnerTest.java
@@ -4,55 +4,67 @@
  */
 package org.mockito.internal.runners;
 
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.*;
+
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunListener;
 import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.model.Statement;
 import org.mockito.Mock;
 import org.mockito.internal.junit.MockitoTestListener;
 import org.mockito.internal.junit.TestFinishedEvent;
 import org.mockito.internal.util.Supplier;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.*;
-
 public class DefaultInternalRunnerTest {
 
     private final RunListener runListener = mock(RunListener.class);
     private final MockitoTestListener mockitoTestListener = mock(MockitoTestListener.class);
-    private final Supplier<MockitoTestListener> supplier = new Supplier<MockitoTestListener>() {
-        public MockitoTestListener get() {
-            return mockitoTestListener;
-        }
-    };
+    private final Supplier<MockitoTestListener> supplier =
+            new Supplier<MockitoTestListener>() {
+                public MockitoTestListener get() {
+                    return mockitoTestListener;
+                }
+            };
 
     @Test
     public void does_not_fail_when_tests_succeeds() throws Exception {
-        new DefaultInternalRunner(SuccessTest.class, supplier)
-            .run(newNotifier(runListener));
+        new DefaultInternalRunner(SuccessTest.class, supplier).run(newNotifier(runListener));
 
-        verify(runListener, never()).testFailure(any(Failure.class));
-        verify(runListener, times(1)).testFinished(any(Description.class));
-        verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
+        verifyTestFinishedSuccessfully();
     }
 
     @Test
     public void does_not_fail_second_test_when_first_test_fail() throws Exception {
         new DefaultInternalRunner(TestFailOnInitialization.class, supplier)
-            .run(newNotifier(runListener));
+                .run(newNotifier(runListener));
 
         verify(runListener, times(1)).testFailure(any(Failure.class));
-        verify(runListener, never()).testFinished(any(Description.class));
-        verify(mockitoTestListener, never()).testFinished(any(TestFinishedEvent.class));
+        verify(runListener, times(1)).testFinished(any(Description.class));
+        verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
+
+        reset(runListener, mockitoTestListener);
+
+        new DefaultInternalRunner(SuccessTest.class, supplier).run(newNotifier(runListener));
 
-        reset(runListener);
+        verifyTestFinishedSuccessfully();
+    }
+
+    @Test
+    public void does_not_fail_when_rule_invokes_statement_multiple_times() throws Exception {
+        new DefaultInternalRunner(TestWithRepeatingRule.class, supplier)
+                .run(newNotifier(runListener));
 
-        new DefaultInternalRunner(SuccessTest.class, supplier)
-            .run(newNotifier(runListener));
+        verifyTestFinishedSuccessfully();
+    }
 
+    private void verifyTestFinishedSuccessfully() throws Exception {
         verify(runListener, never()).testFailure(any(Failure.class));
         verify(runListener, times(1)).testFinished(any(Description.class));
         verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
@@ -64,22 +76,35 @@ public class DefaultInternalRunnerTest {
         return notifier;
     }
 
-    public static final class SuccessTest {
+    public static class SuccessTest {
 
         @Test
-        public void test() {
+        public void this_test_is_NOT_supposed_to_fail() {
             assertTrue(true);
         }
     }
 
     public static final class TestFailOnInitialization {
 
-        @Mock
-        private System system;
+        @Mock private System system;
 
         @Test
-        public void test() {
+        public void this_test_is_supposed_to_fail() {
             assertNotNull(system);
         }
     }
+
+    public static final class TestWithRepeatingRule extends SuccessTest {
+
+        @Rule
+        public TestRule rule =
+                (base, description) ->
+                        new Statement() {
+                            @Override
+                            public void evaluate() throws Throwable {
+                                base.evaluate();
+                                base.evaluate();
+                            }
+                        };
+    }
 }
diff --git a/src/test/java/org/mockito/internal/runners/util/RunnerProviderTest.java b/src/test/java/org/mockito/internal/runners/util/RunnerProviderTest.java
index 7693c57..da77bdc 100644
--- a/src/test/java/org/mockito/internal/runners/util/RunnerProviderTest.java
+++ b/src/test/java/org/mockito/internal/runners/util/RunnerProviderTest.java
@@ -4,22 +4,23 @@
  */
 package org.mockito.internal.runners.util;
 
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Test;
 import org.mockito.internal.runners.DefaultInternalRunner;
 import org.mockito.internal.runners.InternalRunner;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertNotNull;
-
 public class RunnerProviderTest extends TestBase {
 
     @Test
     public void shouldCreateRunnerInstance() throws Throwable {
-        //given
+        // given
         RunnerProvider provider = new RunnerProvider();
-        //when
-        InternalRunner runner = provider.newInstance(DefaultInternalRunner.class.getName(), this.getClass(), null);
-        //then
+        // when
+        InternalRunner runner =
+                provider.newInstance(DefaultInternalRunner.class.getName(), this.getClass(), null);
+        // then
         assertNotNull(runner);
     }
 }
diff --git a/src/test/java/org/mockito/internal/runners/util/TestMethodsFinderTest.java b/src/test/java/org/mockito/internal/runners/util/TestMethodsFinderTest.java
index 57c34b5..18c5f6a 100644
--- a/src/test/java/org/mockito/internal/runners/util/TestMethodsFinderTest.java
+++ b/src/test/java/org/mockito/internal/runners/util/TestMethodsFinderTest.java
@@ -4,16 +4,17 @@
  */
 package org.mockito.internal.runners.util;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class TestMethodsFinderTest extends TestBase {
 
     public static class HasTests {
-        @Test public void someTest() {}
+        @Test
+        public void someTest() {}
     }
 
     static class DoesNotHaveTests {
diff --git a/src/test/java/org/mockito/internal/session/DefaultMockitoSessionBuilderTest.java b/src/test/java/org/mockito/internal/session/DefaultMockitoSessionBuilderTest.java
index a65ae21..19f9f31 100644
--- a/src/test/java/org/mockito/internal/session/DefaultMockitoSessionBuilderTest.java
+++ b/src/test/java/org/mockito/internal/session/DefaultMockitoSessionBuilderTest.java
@@ -4,6 +4,15 @@
  */
 package org.mockito.internal.session;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.when;
+import static org.mockito.quality.Strictness.WARN;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -14,71 +23,86 @@ import org.mockito.quality.Strictness;
 import org.mockito.session.MockitoSessionLogger;
 import org.mockitoutil.ThrowableAssert;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Mockito.when;
-import static org.mockito.quality.Strictness.WARN;
-
 public class DefaultMockitoSessionBuilderTest {
 
-    @After public void after() {
+    @After
+    public void after() {
         new StateMaster().clearMockitoListeners();
     }
 
-    @Test public void creates_sessions() {
-        //no configuration is legal
+    @Test
+    public void creates_sessions() {
+        // no configuration is legal
         new DefaultMockitoSessionBuilder().startMocking().finishMocking();
 
-        //passing null to configuration is legal, default value will be used
+        // passing null to configuration is legal, default value will be used
         new DefaultMockitoSessionBuilder().initMocks((Object) null).startMocking().finishMocking();
-        new DefaultMockitoSessionBuilder().initMocks((Object[]) null).startMocking().finishMocking();
-        new DefaultMockitoSessionBuilder().initMocks(null, null).strictness(null).startMocking().finishMocking();
+        new DefaultMockitoSessionBuilder()
+                .initMocks((Object[]) null)
+                .startMocking()
+                .finishMocking();
+        new DefaultMockitoSessionBuilder()
+                .initMocks(null, null)
+                .strictness(null)
+                .startMocking()
+                .finishMocking();
         new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
 
-        //happy path
+        // happy path
         new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
         new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
-        new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
+        new DefaultMockitoSessionBuilder()
+                .strictness(Strictness.LENIENT)
+                .startMocking()
+                .finishMocking();
     }
 
-    @Test public void creates_sessions_for_multiple_test_class_instances_for_repeated_calls() {
+    @Test
+    public void creates_sessions_for_multiple_test_class_instances_for_repeated_calls() {
         TestClass testClass = new TestClass();
         TestClass.NestedTestClass nestedTestClass = testClass.new NestedTestClass();
 
-        new DefaultMockitoSessionBuilder().initMocks(testClass).initMocks(nestedTestClass).startMocking().finishMocking();
+        new DefaultMockitoSessionBuilder()
+                .initMocks(testClass)
+                .initMocks(nestedTestClass)
+                .startMocking()
+                .finishMocking();
 
         assertNotNull(testClass.set);
         assertNotNull(nestedTestClass.list);
     }
 
-    @Test public void creates_sessions_for_multiple_test_class_instances_for_varargs_call() {
+    @Test
+    public void creates_sessions_for_multiple_test_class_instances_for_varargs_call() {
         TestClass testClass = new TestClass();
         TestClass.NestedTestClass nestedTestClass = testClass.new NestedTestClass();
 
-        new DefaultMockitoSessionBuilder().initMocks(testClass, nestedTestClass).startMocking().finishMocking();
+        new DefaultMockitoSessionBuilder()
+                .initMocks(testClass, nestedTestClass)
+                .startMocking()
+                .finishMocking();
 
         assertNotNull(testClass.set);
         assertNotNull(nestedTestClass.list);
     }
 
-    @Test public void uses_logger_and_strictness() {
+    @Test
+    public void uses_logger_and_strictness() {
         TestClass testClass = new TestClass();
 
         final List<String> hints = new ArrayList<String>();
-        MockitoSession session = new DefaultMockitoSessionBuilder()
-            .initMocks(testClass)
-            .strictness(WARN)
-            .logger(new MockitoSessionLogger() {
-                @Override
-                public void log(String hint) {
-                    hints.add(hint);
-                }
-            })
-            .startMocking();
+        MockitoSession session =
+                new DefaultMockitoSessionBuilder()
+                        .initMocks(testClass)
+                        .strictness(WARN)
+                        .logger(
+                                new MockitoSessionLogger() {
+                                    @Override
+                                    public void log(String hint) {
+                                        hints.add(hint);
+                                    }
+                                })
+                        .startMocking();
 
         when(testClass.set.add(1)).thenReturn(true);
 
@@ -87,24 +111,30 @@ public class DefaultMockitoSessionBuilderTest {
         assertFalse(hints.isEmpty());
     }
 
-    @Test public void requires_finish_mocking() {
+    @Test
+    public void requires_finish_mocking() {
         new DefaultMockitoSessionBuilder().startMocking();
 
-        ThrowableAssert.assertThat(new Runnable() {
-            public void run() {
-                new DefaultMockitoSessionBuilder().startMocking();
-            }
-        }).throwsException(UnfinishedMockingSessionException.class);
+        ThrowableAssert.assertThat(
+                        new Runnable() {
+                            public void run() {
+                                new DefaultMockitoSessionBuilder().startMocking();
+                            }
+                        })
+                .throwsException(UnfinishedMockingSessionException.class);
     }
 
-    @Test public void auto_cleans_dirty_listeners() {
+    @Test
+    public void auto_cleans_dirty_listeners() {
         new DefaultMockitoSessionBuilder().startMocking();
 
-        ThrowableAssert.assertThat(new Runnable() {
-            public void run() {
-                new DefaultMockitoSessionBuilder().startMocking();
-            }
-        }).throwsException(UnfinishedMockingSessionException.class);
+        ThrowableAssert.assertThat(
+                        new Runnable() {
+                            public void run() {
+                                new DefaultMockitoSessionBuilder().startMocking();
+                            }
+                        })
+                .throwsException(UnfinishedMockingSessionException.class);
     }
 
     class TestClass {
diff --git a/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java b/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java
index 52e481d..fafff65 100644
--- a/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.stubbing;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
@@ -17,10 +20,6 @@ import org.mockito.internal.stubbing.answers.ThrowsException;
 import org.mockito.invocation.Invocation;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-
 public class InvocationContainerImplStubbingTest extends TestBase {
 
     private InvocationContainerImpl invocationContainerImpl;
@@ -33,11 +32,13 @@ public class InvocationContainerImplStubbingTest extends TestBase {
         state = mockingProgress();
 
         invocationContainerImpl = new InvocationContainerImpl(new MockSettingsImpl());
-        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());
+        invocationContainerImpl.setInvocationForPotentialStubbing(
+                new InvocationBuilder().toInvocationMatcher());
 
         invocationContainerImplStubOnly =
-          new InvocationContainerImpl( new MockSettingsImpl().stubOnly());
-        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());
+                new InvocationContainerImpl(new MockSettingsImpl().stubOnly());
+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(
+                new InvocationBuilder().toInvocationMatcher());
 
         simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();
     }
@@ -62,11 +63,13 @@ public class InvocationContainerImplStubbingTest extends TestBase {
 
     @Test
     public void should_get_results_for_methods() throws Throwable {
-        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));
+        invocationContainerImpl.setInvocationForPotentialStubbing(
+                new InvocationMatcher(simpleMethod));
         invocationContainerImpl.addAnswer(new Returns("simpleMethod"), null);
 
         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();
-        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));
+        invocationContainerImpl.setInvocationForPotentialStubbing(
+                new InvocationMatcher(differentMethod));
         invocationContainerImpl.addAnswer(new ThrowsException(new MyException()), null);
 
         assertEquals("simpleMethod", invocationContainerImpl.answerTo(simpleMethod));
@@ -74,16 +77,19 @@ public class InvocationContainerImplStubbingTest extends TestBase {
         try {
             invocationContainerImpl.answerTo(differentMethod);
             fail();
-        } catch (MyException e) {}
+        } catch (MyException e) {
+        }
     }
 
     @Test
     public void should_get_results_for_methods_stub_only() throws Throwable {
-        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));
+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(
+                new InvocationMatcher(simpleMethod));
         invocationContainerImplStubOnly.addAnswer(new Returns("simpleMethod"), null);
 
         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();
-        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));
+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(
+                new InvocationMatcher(differentMethod));
         invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()), null);
 
         assertEquals("simpleMethod", invocationContainerImplStubOnly.answerTo(simpleMethod));
@@ -91,7 +97,8 @@ public class InvocationContainerImplStubbingTest extends TestBase {
         try {
             invocationContainerImplStubOnly.answerTo(differentMethod);
             fail();
-        } catch (MyException e) {}
+        } catch (MyException e) {
+        }
     }
 
     @Test
@@ -99,7 +106,8 @@ public class InvocationContainerImplStubbingTest extends TestBase {
         try {
             invocationContainerImpl.addAnswer(new ThrowsException(null), null);
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 
     @SuppressWarnings("serial")
diff --git a/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplTest.java b/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplTest.java
index c63d6e9..aef75ee 100644
--- a/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/InvocationContainerImplTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockito.internal.stubbing;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.util.LinkedList;
+import java.util.concurrent.CountDownLatch;
+
 import org.junit.Test;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.InvocationBuilder;
@@ -13,21 +20,14 @@ import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
 import org.mockito.invocation.Invocation;
 import org.mockito.mock.MockCreationSettings;
 
-import java.util.LinkedList;
-import java.util.concurrent.CountDownLatch;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 /**
  * Author: Szczepan Faber
  */
 public class InvocationContainerImplTest {
 
-    InvocationContainerImpl container = new InvocationContainerImpl( new MockSettingsImpl());
+    InvocationContainerImpl container = new InvocationContainerImpl(new MockSettingsImpl());
     InvocationContainerImpl containerStubOnly =
-      new InvocationContainerImpl( (MockCreationSettings) new MockSettingsImpl().stubOnly());
+            new InvocationContainerImpl((MockCreationSettings) new MockSettingsImpl().stubOnly());
     Invocation invocation = new InvocationBuilder().toInvocation();
     LinkedList<Throwable> exceptions = new LinkedList<Throwable>();
 
@@ -41,40 +41,42 @@ public class InvocationContainerImplTest {
         doShouldBeThreadSafe(containerStubOnly);
     }
 
-    //works 50% of the time
+    // works 50% of the time
     private void doShouldBeThreadSafe(final InvocationContainerImpl c) throws Throwable {
-        //given
+        // given
         Thread[] t = new Thread[200];
         final CountDownLatch starter = new CountDownLatch(200);
-        for (int i = 0; i < t.length; i++ ) {
-            t[i] = new Thread() {
-                public void run() {
-                    try {
-                        starter.await(); //NOPMD
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException(e);
-                    }
-                    c.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));
-                    c.addAnswer(new Returns("foo"), null);
-                    c.findAnswerFor(invocation);
-                }
-            };
-            t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-                public void uncaughtException(Thread t, Throwable e) {
-                    exceptions.add(e);
-                }
-            });
+        for (int i = 0; i < t.length; i++) {
+            t[i] =
+                    new Thread() {
+                        public void run() {
+                            try {
+                                starter.await(); // NOPMD
+                            } catch (InterruptedException e) {
+                                throw new RuntimeException(e);
+                            }
+                            c.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));
+                            c.addAnswer(new Returns("foo"), null);
+                            c.findAnswerFor(invocation);
+                        }
+                    };
+            t[i].setUncaughtExceptionHandler(
+                    new Thread.UncaughtExceptionHandler() {
+                        public void uncaughtException(Thread t, Throwable e) {
+                            exceptions.add(e);
+                        }
+                    });
             t[i].start();
 
             starter.countDown();
         }
 
-        //when
+        // when
         for (Thread aT : t) {
             aT.join();
         }
 
-        //then
+        // then
         if (exceptions.size() != 0) {
             throw exceptions.getFirst();
         }
@@ -105,7 +107,8 @@ public class InvocationContainerImplTest {
 
     @Test
     public void should_tell_if_has_invocation_for_potential_stubbing_stub_only() throws Exception {
-        containerStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());
+        containerStubOnly.setInvocationForPotentialStubbing(
+                new InvocationBuilder().toInvocationMatcher());
         assertTrue(containerStubOnly.hasInvocationForPotentialStubbing());
 
         containerStubOnly.addAnswer(new ReturnsEmptyValues(), null);
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java b/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java
new file mode 100644
index 0000000..c4fa7a1
--- /dev/null
+++ b/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.answers;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.mockito.Mockito.mock;
+import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
+import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
+
+import java.io.IOException;
+import java.nio.charset.CharacterCodingException;
+
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.invocation.InvocationBuilder;
+import org.mockito.invocation.Invocation;
+
+public class AbstractThrowsExceptionTest {
+
+    @Test
+    public void should_raise_wanted_throwable() {
+        Throwable expected = new Exception();
+        AbstractThrowsException ate = instantiateFixture(expected);
+
+        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
+        assertNotNull("Should have raised an exception.", throwable);
+        assertSame(expected, throwable);
+    }
+
+    @Test
+    public void should_throw_mock_exception_without_stacktrace() {
+        AbstractThrowsException ate = instantiateFixture(mock(Exception.class));
+
+        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
+        assertNotNull("Should have raised an exception.", throwable);
+        assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
+    }
+
+    @Test
+    public void should_fill_in_exception_stacktrace() {
+        AbstractThrowsException ate = instantiateFixture(new Exception());
+
+        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
+        assertNotNull("Should have raised an exception.", throwable);
+        assertThat(throwable.getStackTrace()[0].getClassName())
+                .isEqualTo(AbstractThrowsException.class.getName());
+        assertThat(throwable.getStackTrace()[0].getMethodName()).isEqualTo("answer");
+    }
+
+    @Test
+    public void should_invalidate_null_throwable() {
+        AbstractThrowsException ate = instantiateFixture(null);
+
+        Throwable throwable =
+                Assertions.catchThrowableOfType(
+                        () -> ate.validateFor(createMethodInvocation()), MockitoException.class);
+        assertNotNull("Should have raised a MockitoException.", throwable);
+        assertEquals(cannotStubWithNullThrowable().getMessage(), throwable.getMessage());
+    }
+
+    @Test
+    public void should_throw_illegal_state_exception_if_null_answer() {
+        AbstractThrowsException ate = instantiateFixture(null);
+
+        Throwable throwable =
+                Assertions.catchThrowableOfType(
+                        () -> ate.answer(createMethodInvocation()), IllegalStateException.class);
+        assertNotNull("Should have raised a IllegalStateException.", throwable);
+        assertEquals(
+                "throwable is null: you shall not call #answer if #validateFor fails!",
+                throwable.getMessage());
+    }
+
+    @Test
+    public void should_pass_proper_checked_exception() {
+        instantiateFixture(new CharacterCodingException()).validateFor(createMethodInvocation());
+    }
+
+    @Test
+    public void should_fail_invalid_checked_exception() {
+        AbstractThrowsException ate = instantiateFixture(new IOException());
+        Throwable comparison = ate.getThrowable();
+
+        Throwable throwable =
+                Assertions.catchThrowableOfType(
+                        () -> ate.validateFor(createMethodInvocation()), MockitoException.class);
+        assertNotNull("Should have raised a MockitoException.", throwable);
+        assertEquals(checkedExceptionInvalid(comparison).getMessage(), throwable.getMessage());
+    }
+
+    @Test
+    public void should_pass_RuntimeException() {
+        instantiateFixture(new RuntimeException()).validateFor(createMethodInvocation());
+    }
+
+    @Test
+    public void should_pass_Error() {
+        instantiateFixture(new Error()).validateFor(createMethodInvocation());
+    }
+
+    /** Creates a fixture for AbstractThrowsException that returns the given Throwable. */
+    private static AbstractThrowsException instantiateFixture(Throwable throwable) {
+        return new AbstractThrowsException() {
+            @Override
+            protected Throwable getThrowable() {
+                return throwable;
+            }
+        };
+    }
+
+    /** Creates Invocation of a "canThrowException" method call. */
+    private static Invocation createMethodInvocation() {
+        return new InvocationBuilder().method("canThrowException").toInvocation();
+    }
+
+    @Test
+    public void fixture_should_return_expected_throwable() {
+        Throwable expected = new RuntimeException();
+        AbstractThrowsException ate = instantiateFixture(expected);
+
+        assertSame(expected, ate.getThrowable());
+    }
+}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/AnswersWithDelayTest.java b/src/test/java/org/mockito/internal/stubbing/answers/AnswersWithDelayTest.java
index 35c5265..e507f2f 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/AnswersWithDelayTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/AnswersWithDelayTest.java
@@ -4,29 +4,53 @@
  */
 package org.mockito.internal.stubbing.answers;
 
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.invocation.InvocationBuilder;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.assertj.core.api.Assertions.within;
 
 import java.util.Date;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.within;
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.invocation.InvocationBuilder;
 
 public class AnswersWithDelayTest {
     @Test
     public void should_return_value() throws Throwable {
-        assertThat(new AnswersWithDelay(1, new Returns("value")).answer(new InvocationBuilder().method("oneArg").arg("A").toInvocation())).isEqualTo("value");
+        assertThat(
+                        new AnswersWithDelay(1, new Returns("value"))
+                                .answer(
+                                        new InvocationBuilder()
+                                                .method("oneArg")
+                                                .arg("A")
+                                                .toInvocation()))
+                .isEqualTo("value");
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_when_contained_answer_should_fail() throws Throwable {
-        new AnswersWithDelay(1, new Returns("one")).validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
+    @Test
+    public void should_fail_when_contained_answer_should_fail() {
+        assertThatThrownBy(
+                        () -> {
+                            new AnswersWithDelay(1, new Returns("one"))
+                                    .validateFor(
+                                            new InvocationBuilder()
+                                                    .method("voidMethod")
+                                                    .toInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "'voidMethod' is a *void method* and it *cannot* be stubbed with a *return value*!",
+                        "Voids are usually stubbed with Throwables:",
+                        "    doThrow(exception).when(mock).someVoidMethod();",
+                        "If you need to set the void method to do nothing you can use:",
+                        "    doNothing().when(mock).someVoidMethod();",
+                        "For more information, check out the javadocs for Mockito.doNothing().");
     }
 
     @Test
-    public void should_succeed_when_contained_answer_should_succeed() throws Throwable {
-        new AnswersWithDelay(1, new Returns("one")).validateFor(new InvocationBuilder().simpleMethod().toInvocation());
+    public void should_succeed_when_contained_answer_should_succeed() {
+        new AnswersWithDelay(1, new Returns("one"))
+                .validateFor(new InvocationBuilder().simpleMethod().toInvocation());
     }
 
     @Test
@@ -43,4 +67,3 @@ public class AnswersWithDelayTest {
         assertThat(timePassed).isCloseTo(sleepyTime, within(15L));
     }
 }
-
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/CallsRealMethodsTest.java b/src/test/java/org/mockito/internal/stubbing/answers/CallsRealMethodsTest.java
index 63118e5..f8d904f 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/CallsRealMethodsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/CallsRealMethodsTest.java
@@ -1,14 +1,15 @@
-/*
- * Copyright (c) 2017 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.RETURNS_DEFAULTS;
+import static org.mockito.Mockito.mock;
+
+import java.util.ArrayList;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
@@ -16,40 +17,38 @@ import org.mockito.internal.MockitoCore;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 
-import java.util.ArrayList;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.RETURNS_DEFAULTS;
-import static org.mockito.Mockito.mock;
-
 public class CallsRealMethodsTest {
 
     @Test
     public void should_delegate_to_returns_default_when_abstract_method() throws Throwable {
-        Invocation abstractMethod = new InvocationBuilder().method("booleanReturningMethod").toInvocation();
-        assertThat(new CallsRealMethods().answer(abstractMethod)).isEqualTo(RETURNS_DEFAULTS.answer(abstractMethod));
+        Invocation abstractMethod =
+                new InvocationBuilder().method("booleanReturningMethod").toInvocation();
+        assertThat(new CallsRealMethods().answer(abstractMethod))
+                .isEqualTo(RETURNS_DEFAULTS.answer(abstractMethod));
     }
 
     @Test
     public void should_fail_when_calling_real_method_on_interface() throws Throwable {
-        //given
-        Invocation invocationOnInterface = new InvocationBuilder().method("simpleMethod").toInvocation();
+        // given
+        Invocation invocationOnInterface =
+                new InvocationBuilder().method("simpleMethod").toInvocation();
         try {
-            //when
+            // when
             new CallsRealMethods().validateFor(invocationOnInterface);
-            //then
+            // then
             Assertions.fail("can not invoke interface");
-        } catch (MockitoException expected) {}
+        } catch (MockitoException expected) {
+        }
     }
 
     @Test
     public void should_be_OK_when_calling_real_method_on_concrete_class() throws Throwable {
-        //given
+        // given
         ArrayList<?> mock = mock(ArrayList.class);
         mock.clear();
         Invocation invocationOnClass = new MockitoCore().getLastInvocation();
-        //when
+        // when
         new CallsRealMethods().validateFor(invocationOnClass);
-        //then no exception is thrown
+        // then no exception is thrown
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidatorTest.java b/src/test/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidatorTest.java
index 9caed65..df78604 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidatorTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/DefaultAnswerValidatorTest.java
@@ -4,24 +4,24 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
 import org.junit.Test;
 import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
 import org.mockito.internal.invocation.InvocationBuilder;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-
 public class DefaultAnswerValidatorTest {
 
     @Test
-    public void should_fail_if_returned_value_of_answer_is_incompatible_with_return_type() throws Throwable {
+    public void should_fail_if_returned_value_of_answer_is_incompatible_with_return_type()
+            throws Throwable {
         // given
-        class AWrongType {
-        }
+        class AWrongType {}
         try {
             // when
-            DefaultAnswerValidator.validateReturnValueFor(new InvocationBuilder().method("toString").toInvocation(),
-                                                          new AWrongType());
+            DefaultAnswerValidator.validateReturnValueFor(
+                    new InvocationBuilder().method("toString").toInvocation(), new AWrongType());
             fail("expected validation to fail");
         } catch (WrongTypeOfReturnValue e) {
             // then
@@ -34,7 +34,7 @@ public class DefaultAnswerValidatorTest {
 
     @Test
     public void should_not_fail_if_returned_value_of_answer_is_null() throws Throwable {
-        DefaultAnswerValidator.validateReturnValueFor(new InvocationBuilder().method("toString").toInvocation(),
-                                                      null);
+        DefaultAnswerValidator.validateReturnValueFor(
+                new InvocationBuilder().method("toString").toInvocation(), null);
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/DoesNothingTest.java b/src/test/java/org/mockito/internal/stubbing/answers/DoesNothingTest.java
index f3c83ff..ecdd6cb 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/DoesNothingTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/DoesNothingTest.java
@@ -5,6 +5,8 @@
 package org.mockito.internal.stubbing.answers;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.mock;
 import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
 import static org.mockitoutil.TestBase.getLastInvocation;
@@ -15,7 +17,7 @@ import org.mockito.exceptions.base.MockitoException;
 import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 
-public class DoesNothingTest   {
+public class DoesNothingTest {
 
     private IMethods mock;
     private Invocation invocation_Void;
@@ -23,7 +25,7 @@ public class DoesNothingTest   {
     private Invocation invocation_String;
 
     @Before
-    public void init(){
+    public void init() {
         mock = mock(IMethods.class);
 
         mock.voidMethod();
@@ -37,26 +39,43 @@ public class DoesNothingTest   {
     }
 
     @Test
-    public void answer_returnsNull() throws Throwable {
+    public void answer_returnsNull() {
         assertThat(doesNothing().answer(invocation_Void)).isNull();
         assertThat(doesNothing().answer(invocation_void)).isNull();
         assertThat(doesNothing().answer(invocation_String)).isNull();
     }
 
-    @Test(expected = MockitoException.class)
-    public void validateFor_nonVoidReturnType_shouldFail()   {
-        doesNothing().validateFor(invocation_String);
+    @Test
+    public void validateFor_nonVoidReturnType_shouldFail() {
+        assertThatThrownBy(
+                        () -> {
+                            doesNothing().validateFor(invocation_String);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Only void methods can doNothing()!");
     }
 
     @Test
-    public void validateFor_voidReturnType_shouldPass()   {
+    public void validateFor_voidReturnType_shouldPass() {
         doesNothing().validateFor(invocation_void);
     }
 
     @Test
-    public void validateFor_voidObjectReturnType() throws Throwable {
+    public void validateFor_voidObjectReturnType() {
         doesNothing().validateFor(invocation_Void);
     }
 
+    @Test
+    public void answer_returns_null_for_generic_parameter() {
+        SubclassWithGenericParameter mock = mock(SubclassWithGenericParameter.class);
+        doNothing().when(mock).methodReturningT();
+    }
+
+    static class SuperClassWithGenericParameter<T> {
+        T methodReturningT() {
+            return null;
+        }
+    }
 
+    static class SubclassWithGenericParameter extends SuperClassWithGenericParameter<Void> {}
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
index 13e61cc..3c9d969 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
@@ -4,77 +4,172 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockitoutil.TestBase.getLastInvocation;
+
 import java.lang.reflect.Method;
 import java.nio.charset.CharacterCodingException;
+
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockitoutil.TestBase.getLastInvocation;
-
 public class InvocationInfoTest {
 
     @Test
     public void should_know_valid_throwables() throws Exception {
-        //when
+        // when
         Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();
         InvocationInfo info = new InvocationInfo(invocation);
 
-        //then
+        // then
         assertThat(info.isValidException(new Exception())).isFalse();
         assertThat(info.isValidException(new CharacterCodingException())).isTrue();
     }
 
     @Test
     public void should_know_valid_return_types() throws Exception {
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).isValidReturnType(Integer.class)).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).isValidReturnType(int.class)).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("intReturningMethod").toInvocation()).isValidReturnType(Integer.class)).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("intReturningMethod").toInvocation()).isValidReturnType(int.class)).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).isValidReturnType(String.class)).isFalse();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .isValidReturnType(Integer.class))
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .isValidReturnType(int.class))
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("intReturningMethod")
+                                                .toInvocation())
+                                .isValidReturnType(Integer.class))
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("intReturningMethod")
+                                                .toInvocation())
+                                .isValidReturnType(int.class))
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .isValidReturnType(String.class))
+                .isFalse();
     }
 
     @Test
     public void should_know_when_invocation_returns_primitive() {
-        assertThat(new InvocationInfo(new InvocationBuilder().method("intReturningMethod").toInvocation()).returnsPrimitive()).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).returnsPrimitive()).isFalse();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("intReturningMethod")
+                                                .toInvocation())
+                                .returnsPrimitive())
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .returnsPrimitive())
+                .isFalse();
     }
 
     @Test
     public void should_know_when_invocation_returns_void() {
-        assertThat(new InvocationInfo(new InvocationBuilder().method("voidMethod").toInvocation()).isVoid()).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).isVoid()).isFalse();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder().method("voidMethod").toInvocation())
+                                .isVoid())
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .isVoid())
+                .isFalse();
     }
 
     @Test
     public void should_read_the_method_name() {
-        assertThat(new InvocationInfo(new InvocationBuilder().method("voidMethod").toInvocation()).getMethodName()).isEqualTo("voidMethod");
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder().method("voidMethod").toInvocation())
+                                .getMethodName())
+                .isEqualTo("voidMethod");
     }
 
     @Test
     public void should_read_the_method_return_name() {
-        assertThat(new InvocationInfo(new InvocationBuilder().method("voidMethod").toInvocation()).printMethodReturnType()).isEqualTo("void");
-        assertThat(new InvocationInfo(new InvocationBuilder().method("integerReturningMethod").toInvocation()).printMethodReturnType()).isEqualTo("Integer");
-        assertThat(new InvocationInfo(new InvocationBuilder().method("intReturningMethod").toInvocation()).printMethodReturnType()).isEqualTo("int");
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder().method("voidMethod").toInvocation())
+                                .printMethodReturnType())
+                .isEqualTo("void");
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("integerReturningMethod")
+                                                .toInvocation())
+                                .printMethodReturnType())
+                .isEqualTo("Integer");
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method("intReturningMethod")
+                                                .toInvocation())
+                                .printMethodReturnType())
+                .isEqualTo("int");
     }
 
     @Test
     public void should_know_abstract_method() throws Exception { // To be extended with Java 8
-        assertThat(new InvocationInfo(new InvocationBuilder().method(iAmAbstract()).toInvocation()).isAbstract()).isTrue();
-        assertThat(new InvocationInfo(new InvocationBuilder().method(iAmNotAbstract()).toInvocation()).isAbstract()).isFalse();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method(iAmAbstract())
+                                                .toInvocation())
+                                .isAbstract())
+                .isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method(iAmNotAbstract())
+                                                .toInvocation())
+                                .isAbstract())
+                .isFalse();
     }
 
     @Test
     public void should_know_method_is_declared_on_interface() throws Exception {
-        assertThat(new InvocationInfo(new InvocationBuilder().method(iAmAbstract()).toInvocation()).isDeclaredOnInterface()).isFalse();
-        assertThat(new InvocationInfo(new InvocationBuilder().method("voidMethod").toInvocation()).isDeclaredOnInterface()).isTrue();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder()
+                                                .method(iAmAbstract())
+                                                .toInvocation())
+                                .isDeclaredOnInterface())
+                .isFalse();
+        assertThat(
+                        new InvocationInfo(
+                                        new InvocationBuilder().method("voidMethod").toInvocation())
+                                .isDeclaredOnInterface())
+                .isTrue();
     }
 
     @Test
-    public void isVoid_invocationOnVoidMethod_returnTrue(){
+    public void isVoid_invocationOnVoidMethod_returnTrue() {
         mock(IMethods.class).voidMethod();
 
         InvocationInfo voidMethod = new InvocationInfo(getLastInvocation());
@@ -83,7 +178,7 @@ public class InvocationInfoTest {
     }
 
     @Test
-    public void isVoid_invocationOnVoidReturningMethod_returnTrue(){
+    public void isVoid_invocationOnVoidReturningMethod_returnTrue() {
         mock(IMethods.class).voidReturningMethod();
 
         InvocationInfo voidRetuningMethod = new InvocationInfo(getLastInvocation());
@@ -92,7 +187,7 @@ public class InvocationInfoTest {
     }
 
     @Test
-    public void isVoid_invocationNonVoidMethod_returnFalse(){
+    public void isVoid_invocationNonVoidMethod_returnFalse() {
         mock(IMethods.class).simpleMethod();
 
         InvocationInfo stringReturningMethod = new InvocationInfo(getLastInvocation());
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java
index 3a817cb..be8b315 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
@@ -12,9 +15,6 @@ import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
 public class ReturnsArgumentAtTest {
     @Test
     public void should_be_able_to_return_the_first_parameter() throws Throwable {
@@ -22,8 +22,7 @@ public class ReturnsArgumentAtTest {
     }
 
     @Test
-    public void should_be_able_to_return_the_second_parameter()
-            throws Throwable {
+    public void should_be_able_to_return_the_second_parameter() throws Throwable {
         assertThat(new ReturnsArgumentAt(1).answer(invocationWith("A", "B", "C"))).isEqualTo("B");
     }
 
@@ -43,100 +42,127 @@ public class ReturnsArgumentAtTest {
     @Test
     public void should_identify_bad_parameter_type_for_invocation() throws Exception {
         try {
-            new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
-                                                                        .argTypes(Object[].class)
-                                                                        .args(new Object(), new Object(), new Object())
-                                                                        .toInvocation());
+            new ReturnsArgumentAt(1)
+                    .validateFor(
+                            new InvocationBuilder()
+                                    .method("varargsReturningString")
+                                    .argTypes(Object[].class)
+                                    .args(new Object(), new Object(), new Object())
+                                    .toInvocation());
             Assertions.fail("should scream");
-        } catch (WrongTypeOfReturnValue ignored) { }
+        } catch (WrongTypeOfReturnValue ignored) {
+        }
         try {
-            new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
-                                                                        .argTypes(boolean[].class)
-                                                                        .args(true, false, false)
-                                                                        .toInvocation());
+            new ReturnsArgumentAt(0)
+                    .validateFor(
+                            new InvocationBuilder()
+                                    .method("oneArray")
+                                    .argTypes(boolean[].class)
+                                    .args(true, false, false)
+                                    .toInvocation());
             Assertions.fail("should scream");
-        } catch (WrongTypeOfReturnValue ignored) { }
+        } catch (WrongTypeOfReturnValue ignored) {
+        }
         try {
-            new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
-                                                                        .argTypes(Object.class, String[].class)
-                                                                        .args(new Object(), new String[]{"A", "B", "C"})
-                                                                        .toInvocation());
+            new ReturnsArgumentAt(0)
+                    .validateFor(
+                            new InvocationBuilder()
+                                    .method("mixedVarargsReturningString")
+                                    .argTypes(Object.class, String[].class)
+                                    .args(new Object(), new String[] {"A", "B", "C"})
+                                    .toInvocation());
             Assertions.fail("should scream");
-        } catch (WrongTypeOfReturnValue ignored) { }
+        } catch (WrongTypeOfReturnValue ignored) {
+        }
     }
 
     @Test
-    public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
-        new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
-                                                                    .argTypes(Object.class, String[].class)
-                                                                    .args(new Object(), new String[]{"A", "B", "C"})
-                                                                    .toInvocation());
+    public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation()
+            throws Exception {
+        new ReturnsArgumentAt(1)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("mixedVarargsReturningString")
+                                .argTypes(Object.class, String[].class)
+                                .args(new Object(), new String[] {"A", "B", "C"})
+                                .toInvocation());
     }
 
-        @Test
+    @Test
     public void should_handle_returning_vararg_as_array() throws Throwable {
-        Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
-                                                                             .argTypes(Object.class, String[].class)
-                                                                             .args(new Object(), new String[]{"A", "B", "C"})
-                                                                             .toInvocation();
+        Invocation mixedVarargsReturningStringArray =
+                new InvocationBuilder()
+                        .method("mixedVarargsReturningStringArray")
+                        .argTypes(Object.class, String[].class)
+                        .args(new Object(), new String[] {"A", "B", "C"})
+                        .toInvocation();
         new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
-        assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
-
-        Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
-                                                                             .argTypes(Object.class, String[].class)
-                                                                             .args(new Object(), new String[]{"A", "B", "C"})
-                                                                             .toInvocation();
+        assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray))
+                .isEqualTo(new String[] {"A", "B", "C"});
+
+        Invocation mixedVarargsReturningObjectArray =
+                new InvocationBuilder()
+                        .method("mixedVarargsReturningStringArray")
+                        .argTypes(Object.class, String[].class)
+                        .args(new Object(), new String[] {"A", "B", "C"})
+                        .toInvocation();
         new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
-        assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
+        assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray))
+                .isEqualTo(new String[] {"A", "B", "C"});
     }
 
     @Test
-    public void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time() throws Throwable {
+    public void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time()
+            throws Throwable {
         try {
             new ReturnsArgumentAt(-30);
             fail();
         } catch (Exception e) {
-            assertThat(e.getMessage()).containsIgnoringCase("argument index")
-                                      .containsIgnoringCase("positive number")
-                                      .contains("1")
-                                      .containsIgnoringCase("last argument");
+            assertThat(e.getMessage())
+                    .containsIgnoringCase("argument index")
+                    .containsIgnoringCase("positive number")
+                    .contains("1")
+                    .containsIgnoringCase("last argument");
         }
     }
 
     @Test
     public void should_allow_possible_argument_types() throws Exception {
-        new ReturnsArgumentAt(0).validateFor(
-                new InvocationBuilder().method("intArgumentReturningInt")
-                                       .argTypes(int.class)
-                                       .arg(1000)
-                                       .toInvocation()
-        );
-        new ReturnsArgumentAt(0).validateFor(
-                new InvocationBuilder().method("toString")
-                                       .argTypes(String.class)
-                                       .arg("whatever")
-                                       .toInvocation()
-        );
-        new ReturnsArgumentAt(2).validateFor(
-                new InvocationBuilder().method("varargsObject")
-                                       .argTypes(int.class, Object[].class)
-                                       .args(1000, "Object", "Object")
-                                       .toInvocation()
-        );
-        new ReturnsArgumentAt(1).validateFor(
-                new InvocationBuilder().method("threeArgumentMethod")
-                                       .argTypes(int.class, Object.class, String.class)
-                                       .args(1000, "Object", "String")
-                                       .toInvocation()
-        );
+        new ReturnsArgumentAt(0)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("intArgumentReturningInt")
+                                .argTypes(int.class)
+                                .arg(1000)
+                                .toInvocation());
+        new ReturnsArgumentAt(0)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("toString")
+                                .argTypes(String.class)
+                                .arg("whatever")
+                                .toInvocation());
+        new ReturnsArgumentAt(2)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("varargsObject")
+                                .argTypes(int.class, Object[].class)
+                                .args(1000, "Object", "Object")
+                                .toInvocation());
+        new ReturnsArgumentAt(1)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("threeArgumentMethod")
+                                .argTypes(int.class, Object.class, String.class)
+                                .args(1000, "Object", "String")
+                                .toInvocation());
     }
 
     @Test
     public void should_fail_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {
         try {
-            new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
-                                                                         .arg("A")
-                                                                         .toInvocation());
+            new ReturnsArgumentAt(30)
+                    .validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
             fail();
         } catch (MockitoException e) {
             assertThat(e.getMessage())
@@ -149,11 +175,11 @@ public class ReturnsArgumentAtTest {
     }
 
     @Test
-    public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation() throws Throwable {
+    public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation()
+            throws Throwable {
         try {
-            new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT).validateFor(
-                    new InvocationBuilder().simpleMethod().toInvocation()
-            );
+            new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT)
+                    .validateFor(new InvocationBuilder().simpleMethod().toInvocation());
             fail();
         } catch (MockitoException e) {
             assertThat(e.getMessage())
@@ -165,14 +191,16 @@ public class ReturnsArgumentAtTest {
     }
 
     @Test
-    public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type() throws Throwable {
+    public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type()
+            throws Throwable {
         try {
-            new ReturnsArgumentAt(2).validateFor(
-                    new InvocationBuilder().method("varargsReturningString")
-                                           .argTypes(Object[].class)
-                                           .args("anyString", new Object(), "anyString")
-                                           .toInvocation()
-            );
+            new ReturnsArgumentAt(2)
+                    .validateFor(
+                            new InvocationBuilder()
+                                    .method("varargsReturningString")
+                                    .argTypes(Object[].class)
+                                    .args("anyString", new Object(), "anyString")
+                                    .toInvocation());
             fail();
         } catch (WrongTypeOfReturnValue e) {
             assertThat(e.getMessage())
@@ -187,19 +215,20 @@ public class ReturnsArgumentAtTest {
 
     @Test
     public void shouldNotFailWhenArgumentIsGenericAndCompatibleWithReturnType() throws Exception {
-        new ReturnsArgumentAt(0 ).validateFor(
-                new InvocationBuilder().method("genericToString")
-                                       .argTypes(Object.class)
-                                       .args("anyString")
-                                       .toInvocation()
-        );
+        new ReturnsArgumentAt(0)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("genericToString")
+                                .argTypes(Object.class)
+                                .args("anyString")
+                                .toInvocation());
     }
 
-
     private static InvocationOnMock invocationWith(Object... parameters) {
-        return new InvocationBuilder().method("varargsReturningString")
-                                      .argTypes(Object[].class)
-                                      .args(new Object[] { parameters }).toInvocation(); // one vararg param (sic!)
+        return new InvocationBuilder()
+                .method("varargsReturningString")
+                .argTypes(Object[].class)
+                .args(new Object[] {parameters})
+                .toInvocation(); // one vararg param (sic!)
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ReturnsTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ReturnsTest.java
index b4d6b43..b18bf5a 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/ReturnsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/ReturnsTest.java
@@ -4,48 +4,118 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static java.lang.Boolean.TRUE;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.invocation.InvocationBuilder;
 
-import static java.lang.Boolean.TRUE;
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class ReturnsTest {
     @Test
     public void should_return_value() throws Throwable {
-        assertThat(new Returns("value").answer(new InvocationBuilder().method("oneArg").arg("A").toInvocation())).isEqualTo("value");
+        assertThat(
+                        new Returns("value")
+                                .answer(
+                                        new InvocationBuilder()
+                                                .method("oneArg")
+                                                .arg("A")
+                                                .toInvocation()))
+                .isEqualTo("value");
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_when_return_Value_is_set_for_void_method() throws Throwable {
-        new Returns("one").validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
+    @Test
+    public void should_fail_when_return_Value_is_set_for_void_method() {
+        assertThatThrownBy(
+                        () -> {
+                            new Returns("one")
+                                    .validateFor(
+                                            new InvocationBuilder()
+                                                    .method("voidMethod")
+                                                    .toInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "'voidMethod' is a *void method* and it *cannot* be stubbed with a *return value*!");
     }
 
     @Test
-    public void should_allow_correct_type_of_return_value() throws Throwable {
+    public void should_allow_correct_type_of_return_value() {
         new Returns("one").validateFor(new InvocationBuilder().simpleMethod().toInvocation());
-        new Returns(false).validateFor(new InvocationBuilder().method("booleanReturningMethod").toInvocation());
-        new Returns(TRUE).validateFor(new InvocationBuilder().method("booleanObjectReturningMethod").toInvocation());
-        new Returns(1).validateFor(new InvocationBuilder().method("integerReturningMethod").toInvocation());
-        new Returns(1L).validateFor(new InvocationBuilder().method("longReturningMethod").toInvocation());
-        new Returns(1L).validateFor(new InvocationBuilder().method("longObjectReturningMethod").toInvocation());
-        new Returns(null).validateFor(new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());
-        new Returns(1).validateFor(new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());
+        new Returns(false)
+                .validateFor(
+                        new InvocationBuilder().method("booleanReturningMethod").toInvocation());
+        new Returns(TRUE)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("booleanObjectReturningMethod")
+                                .toInvocation());
+        new Returns(1)
+                .validateFor(
+                        new InvocationBuilder().method("integerReturningMethod").toInvocation());
+        new Returns(1L)
+                .validateFor(new InvocationBuilder().method("longReturningMethod").toInvocation());
+        new Returns(1L)
+                .validateFor(
+                        new InvocationBuilder().method("longObjectReturningMethod").toInvocation());
+        new Returns(null)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("objectReturningMethodNoArgs")
+                                .toInvocation());
+        new Returns(1)
+                .validateFor(
+                        new InvocationBuilder()
+                                .method("objectReturningMethodNoArgs")
+                                .toInvocation());
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_on_return_type_mismatch() throws Throwable {
-        new Returns("String").validateFor(new InvocationBuilder().method("booleanReturningMethod").toInvocation());
+    @Test
+    public void should_fail_on_return_type_mismatch() {
+        assertThatThrownBy(
+                        () -> {
+                            new Returns("String")
+                                    .validateFor(
+                                            new InvocationBuilder()
+                                                    .method("booleanReturningMethod")
+                                                    .toInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "String cannot be returned by booleanReturningMethod()",
+                        "booleanReturningMethod() should return boolean");
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_on_wrong_primitive() throws Throwable {
-        new Returns(1).validateFor(new InvocationBuilder().method("doubleReturningMethod").toInvocation());
+    @Test
+    public void should_fail_on_wrong_primitive() {
+        assertThatThrownBy(
+                        () -> {
+                            new Returns(1)
+                                    .validateFor(
+                                            new InvocationBuilder()
+                                                    .method("doubleReturningMethod")
+                                                    .toInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Integer cannot be returned by doubleReturningMethod()",
+                        "doubleReturningMethod() should return double");
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_on_null_with_primitive() throws Throwable {
-        new Returns(null).validateFor(new InvocationBuilder().method("booleanReturningMethod").toInvocation());
+    @Test
+    public void should_fail_on_null_with_primitive() {
+        assertThatThrownBy(
+                        () -> {
+                            new Returns(null)
+                                    .validateFor(
+                                            new InvocationBuilder()
+                                                    .method("booleanReturningMethod")
+                                                    .toInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "null cannot be returned by booleanReturningMethod()",
+                        "booleanReturningMethod() should return boolean");
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java
new file mode 100644
index 0000000..ae1b880
--- /dev/null
+++ b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.answers;
+
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+
+import org.junit.Test;
+
+public class ThrowsExceptionForClassTypeTest {
+    @Test
+    public void should_return_throwable_of_expected_class() {
+        ThrowsExceptionForClassType throwsExceptionForClassType =
+                new ThrowsExceptionForClassType(Exception.class);
+
+        assertSame(Exception.class, throwsExceptionForClassType.getThrowable().getClass());
+    }
+
+    @Test
+    public void should_return_different_throwables() {
+        ThrowsExceptionForClassType throwsExceptionForClassType =
+                new ThrowsExceptionForClassType(Exception.class);
+
+        Throwable first = throwsExceptionForClassType.getThrowable();
+        Throwable second = throwsExceptionForClassType.getThrowable();
+        assertNotSame(first, second);
+    }
+}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
index 2e71102..2810181 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
@@ -4,32 +4,37 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertSame;
+import static org.mockito.Mockito.mock;
+
 import java.io.IOException;
 import java.nio.charset.CharacterCodingException;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 
-import static junit.framework.TestCase.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-
 public class ThrowsExceptionTest {
     @Test
-    public void should_raise_wanted_throwable() throws Throwable {
+    public void should_raise_wanted_throwable() {
         try {
-            new ThrowsException(new IllegalStateException("my dear throwable")).answer(createMethodInvocation());
+            new ThrowsException(new IllegalStateException("my dear throwable"))
+                    .answer(createMethodInvocation());
             Assertions.fail("should have raised wanted exception");
         } catch (Throwable throwable) {
-            assertThat(throwable).isInstanceOf(IllegalStateException.class).hasMessage("my dear throwable");
+            assertThat(throwable)
+                    .isInstanceOf(IllegalStateException.class)
+                    .hasMessage("my dear throwable");
         }
     }
 
     @Test
-    public void should_throw_mock_exception_without_stacktrace() throws Exception {
+    public void should_throw_mock_exception_without_stacktrace() {
         try {
             new ThrowsException(mock(Exception.class)).answer(createMethodInvocation());
             Assertions.fail("should have raised wanted exception");
@@ -39,12 +44,14 @@ public class ThrowsExceptionTest {
     }
 
     @Test
-    public void should_fill_in_exception_stacktrace() throws Exception {
+    public void should_fill_in_exception_stacktrace() {
         // given
         Exception throwableToRaise = new Exception();
         throwableToRaise.fillInStackTrace();
-        assertThat(throwableToRaise.getStackTrace()[0].getClassName()).isEqualTo(this.getClass().getName());
-        assertThat(throwableToRaise.getStackTrace()[0].getMethodName()).isEqualTo("should_fill_in_exception_stacktrace");
+        assertThat(throwableToRaise.getStackTrace()[0].getClassName())
+                .isEqualTo(this.getClass().getName());
+        assertThat(throwableToRaise.getStackTrace()[0].getMethodName())
+                .isEqualTo("should_fill_in_exception_stacktrace");
         try {
 
             // when
@@ -53,18 +60,20 @@ public class ThrowsExceptionTest {
         } catch (Throwable throwable) {
             // then
             throwable.printStackTrace();
-            assertThat(throwableToRaise.getStackTrace()[0].getClassName()).isEqualTo(ThrowsException.class.getName());
+            assertThat(throwableToRaise.getStackTrace()[0].getClassName())
+                    .isEqualTo(AbstractThrowsException.class.getName());
             assertThat(throwableToRaise.getStackTrace()[0].getMethodName()).isEqualTo("answer");
         }
     }
 
     @Test
-    public void should_invalidate_null_throwable() throws Throwable {
+    public void should_invalidate_null_throwable() {
         try {
             Invocation invocation = createMethodInvocation();
             new ThrowsException(null).validateFor(invocation);
             Assertions.fail("should have raised a MockitoException");
-        } catch (MockitoException expected) {}
+        } catch (MockitoException expected) {
+        }
     }
 
     @Test
@@ -78,25 +87,48 @@ public class ThrowsExceptionTest {
     }
 
     @Test
-    public void should_pass_proper_checked_exception() throws Throwable {
+    public void should_pass_proper_checked_exception() {
         new ThrowsException(new CharacterCodingException()).validateFor(createMethodInvocation());
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_invalid_checked_exception() throws Throwable {
-        new ThrowsException(new IOException()).validateFor(createMethodInvocation());
+    @Test
+    public void should_fail_invalid_checked_exception() {
+        assertThatThrownBy(
+                        () -> {
+                            new ThrowsException(new IOException())
+                                    .validateFor(createMethodInvocation());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Checked exception is invalid for this method!",
+                        "Invalid: java.io.IOException");
     }
 
     @Test
-    public void should_pass_RuntimeExceptions() throws Throwable {
+    public void should_pass_RuntimeExceptions() {
         new ThrowsException(new Error()).validateFor(createMethodInvocation());
         new ThrowsException(new RuntimeException()).validateFor(createMethodInvocation());
     }
 
+    @Test
+    public void should_return_expected_throwable() {
+        Throwable expected = new Exception();
+        ThrowsException throwsException = new ThrowsException(expected);
+
+        assertSame(expected, throwsException.getThrowable());
+    }
+
+    @Test
+    public void should_return_same_throwable() {
+        ThrowsException throwsException = new ThrowsException(new Exception());
+
+        Throwable first = throwsException.getThrowable();
+        Throwable second = throwsException.getThrowable();
+        assertSame(first, second);
+    }
+
     /** Creates Invocation of a "canThrowException" method call. */
     private static Invocation createMethodInvocation() {
-        return new InvocationBuilder()
-            .method("canThrowException")
-            .toInvocation();
+        return new InvocationBuilder().method("canThrowException").toInvocation();
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocationsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocationsTest.java
index 6da2a10..a2a28ef 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocationsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocationsTest.java
@@ -4,11 +4,11 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class ForwardsInvocationsTest extends TestBase {
 
     interface Foo {
@@ -25,12 +25,17 @@ public class ForwardsInvocationsTest extends TestBase {
     @Test
     public void should_call_method_with_varargs() throws Throwable {
         ForwardsInvocations forwardsInvocations = new ForwardsInvocations(new FooImpl());
-        assertEquals(4, forwardsInvocations.answer(invocationOf(Foo.class, "bar", "b", new Object[] {12, "3", 4.5})));
+        assertEquals(
+                4,
+                forwardsInvocations.answer(
+                        invocationOf(Foo.class, "bar", "b", new Object[] {12, "3", 4.5})));
     }
 
     @Test
     public void should_call_method_with_empty_varargs() throws Throwable {
         ForwardsInvocations forwardsInvocations = new ForwardsInvocations(new FooImpl());
-        assertEquals(1, forwardsInvocations.answer(invocationOf(Foo.class, "bar", "b", new Object[] {})));
+        assertEquals(
+                1,
+                forwardsInvocations.answer(invocationOf(Foo.class, "bar", "b", new Object[] {})));
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java
index 9aaea02..77f3b64 100755
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java
@@ -7,11 +7,18 @@ package org.mockito.internal.stubbing.defaultanswers;
 @SuppressWarnings("unused")
 interface HasPrimitiveMethods {
     boolean booleanMethod();
+
     char charMethod();
+
     byte byteMethod();
+
     short shortMethod();
+
     int intMethod();
+
     long longMethod();
+
     float floatMethod();
+
     double doubleMethod();
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsConcurrentTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsConcurrentTest.java
new file mode 100644
index 0000000..b365834
--- /dev/null
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsConcurrentTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.defaultanswers;
+
+import static org.mockito.Mockito.mock;
+
+import java.util.List;
+import java.util.stream.IntStream;
+
+import org.junit.Test;
+import org.mockito.Answers;
+
+public class ReturnsDeepStubsConcurrentTest {
+
+    @Test
+    public void
+            given_mock_with_returns_deep_stubs__when_called_concurrently__then_does_not_throw_concurrent_modification_exception() {
+        for (int i = 0; i < 1000; i++) {
+            Service mock = mock(Service.class, Answers.RETURNS_DEEP_STUBS);
+            IntStream.range(1, 100).parallel().forEach(index -> mock.doSomething());
+        }
+    }
+
+    interface Service {
+        List<String> doSomething();
+    }
+}
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java
index 68fbaf5..c80c746 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.stubbing.defaultanswers;
 
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.mock;
+
+import java.util.*;
+
 import org.junit.Assume;
 import org.junit.Test;
 import org.mockito.invocation.Invocation;
 import org.mockitoutil.TestBase;
 
-import java.util.*;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.mock;
-
 public class ReturnsEmptyValuesTest extends TestBase {
 
     private final ReturnsEmptyValues values = new ReturnsEmptyValues();
@@ -67,25 +66,25 @@ public class ReturnsEmptyValuesTest extends TestBase {
         d.compareTo(new Date());
         Invocation compareTo = this.getLastInvocation();
 
-        //when
+        // when
         Object result = values.answer(compareTo);
 
-        //then
+        // then
         assertTrue(result != (Object) 0);
     }
 
     @SuppressWarnings("SelfComparison")
     @Test
     public void should_return_zero_if_mock_is_compared_to_itself() {
-        //given
+        // given
         Date d = mock(Date.class);
         d.compareTo(d);
         Invocation compareTo = this.getLastInvocation();
 
-        //when
+        // when
         Object result = values.answer(compareTo);
 
-        //then
+        // then
         assertEquals(0, result);
     }
 
@@ -96,7 +95,8 @@ public class ReturnsEmptyValuesTest extends TestBase {
 
     @Test
     public void should_return_empty_OptionalDouble() throws Exception {
-        verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
+        verify_empty_Optional_is_returned(
+                "java.util.stream.DoubleStream", "java.util.OptionalDouble");
     }
 
     @Test
@@ -109,10 +109,11 @@ public class ReturnsEmptyValuesTest extends TestBase {
         verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
     }
 
-    private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
+    private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn)
+            throws Exception {
         Class<?> streamType = getClassOrSkipTest(streamFqcn);
 
-        //given
+        // given
         Object stream = mock(streamType);
         Object optional = streamType.getMethod("findAny").invoke(stream);
         assertNotNull(optional);
@@ -120,10 +121,10 @@ public class ReturnsEmptyValuesTest extends TestBase {
 
         Invocation findAny = this.getLastInvocation();
 
-        //when
+        // when
         Object result = values.answer(findAny);
 
-        //then
+        // then
         assertEquals(optional, result);
     }
 
@@ -159,6 +160,22 @@ public class ReturnsEmptyValuesTest extends TestBase {
         assertEquals("count of empty " + streamFqcn, 0L, count);
     }
 
+    @Test
+    public void should_return_empty_duration() throws Exception {
+        // given
+        final String fqcn = "java.time.Duration";
+        final Class<?> durationClass = getClassOrSkipTest(fqcn);
+
+        // when
+        final Object duration = values.returnValueFor(durationClass);
+        final int nano = (Integer) durationClass.getMethod("getNano").invoke(duration);
+        final long seconds = (Long) durationClass.getMethod("getSeconds").invoke(duration);
+
+        // then
+        assertEquals("nano of empty " + fqcn, 0, nano);
+        assertEquals("seconds of empty " + fqcn, 0L, seconds);
+    }
+
     /**
      * Tries to load the given class. If the class is not found, the complete test is skipped.
      */
@@ -170,5 +187,4 @@ public class ReturnsEmptyValuesTest extends TestBase {
             return null;
         }
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
index d91df8c..21f2e3e 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
@@ -4,16 +4,21 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
+import java.io.Closeable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Callable;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
-import static org.mockito.Mockito.mock;
+import org.junit.Test;
+import org.mockitousage.examples.use.Article;
 
 @SuppressWarnings("unused")
 public class ReturnsGenericDeepStubsTest {
@@ -23,21 +28,29 @@ public class ReturnsGenericDeepStubsTest {
 
     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
         Set<Number> remove(Object key); // override with fixed ParameterizedType
+
         List<? super Number> returningWildcard();
+
         Map<String, K> returningNonMockableNestedGeneric();
+
         K returningK();
+
         <O extends K> List<O> paramTypeWithTypeParams();
+
         <S extends Appendable, T extends S> T twoTypeParams(S s);
+
         <O extends K> O typeVarWithTypeParams();
+
         Number returnsNormalType();
     }
 
     @Test
-    public void generic_deep_mock_frenzy__look_at_these_chained_calls() throws Exception {
+    public void generic_deep_mock_frenzy__look_at_these_chained_calls() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
         Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();
-        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();
+        Iterator<? extends Map.Entry<? extends Cloneable, Set<Number>>> entriesIterator =
+                mock.entrySet().iterator();
         Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();
 
         Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();
@@ -49,17 +62,21 @@ public class ReturnsGenericDeepStubsTest {
     }
 
     @Test
-    public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class() throws Exception {
+    public void
+            can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedType_that_is_referencing_a_typeVar_on_class() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
-        Cloneable cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =
-                mock.paramTypeWithTypeParams().get(0);
-        Comparable<?> comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =
-                mock.paramTypeWithTypeParams().get(0);
+        Cloneable
+                cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =
+                        mock.paramTypeWithTypeParams().get(0);
+        Comparable<?>
+                comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =
+                        mock.paramTypeWithTypeParams().get(0);
     }
 
     @Test
-    public void can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class() throws Exception {
+    public void
+            can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typeVar_on_class() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
         Cloneable cloneable_bound_of_typevar_K = mock.returningK();
@@ -67,24 +84,28 @@ public class ReturnsGenericDeepStubsTest {
     }
 
     @Test
-    public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class() throws Exception {
+    public void
+            can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typeVar_that_is_referencing_a_typeVar_on_class() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
-        Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O = (Cloneable) mock.typeVarWithTypeParams();
-        Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O = (Comparable<?>) mock.typeVarWithTypeParams();
+        Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O =
+                (Cloneable) mock.typeVarWithTypeParams();
+        Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O =
+                (Comparable<?>) mock.typeVarWithTypeParams();
     }
 
     @Test
-    public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard() throws Exception {
+    public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
         List<? super Integer> objects = mock.returningWildcard();
-        Number type_that_is_the_upper_bound_of_the_wildcard = (Number) mock.returningWildcard().get(45);
+        Number type_that_is_the_upper_bound_of_the_wildcard =
+                (Number) mock.returningWildcard().get(45);
         type_that_is_the_upper_bound_of_the_wildcard.floatValue();
     }
 
     @Test
-    public void can_still_work_with_raw_type_in_the_return_type() throws Exception {
+    public void can_still_work_with_raw_type_in_the_return_type() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
         Number the_raw_type_that_should_be_returned = mock.returnsNormalType();
@@ -92,22 +113,99 @@ public class ReturnsGenericDeepStubsTest {
     }
 
     @Test
-    public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {
+    public void will_return_default_value_on_non_mockable_nested_generic() {
         GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
         ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);
-        AnotherListOfInteger anotherListOfInteger = mock(AnotherListOfInteger.class, RETURNS_DEEP_STUBS);
+        AnotherListOfInteger anotherListOfInteger =
+                mock(AnotherListOfInteger.class, RETURNS_DEEP_STUBS);
 
-        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();
+        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next())
+                .isNull();
         assertThat(listOfInteger.get(25)).isEqualTo(0);
         assertThat(anotherListOfInteger.get(25)).isEqualTo(0);
     }
 
-    @Test(expected = ClassCastException.class)
-    public void as_expected_fail_with_a_CCE_on_callsite_when_erasure_takes_place_for_example___StringBuilder_is_subject_to_erasure() throws Exception {
+    @Test
+    public void
+            as_expected_fail_with_a_CCE_on_call_site_when_erasure_takes_place_for_example___StringBuilder_is_subject_to_erasure() {
         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
 
-        // following assignment needed to create a ClassCastException on the call site (i.e. : here)
-        StringBuilder stringBuilder_assignment_that_should_throw_a_CCE =
-                mock.twoTypeParams(new StringBuilder()).append(2).append(3);
+        assertThatThrownBy(
+                        () -> {
+                            mock.twoTypeParams(new StringBuilder()).append(2).append(3);
+                        })
+                .isInstanceOf(ClassCastException.class);
+    }
+
+    class WithGenerics<T> {
+        T execute() {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    class SubClass<S> extends WithGenerics<S> {}
+
+    class UserOfSubClass {
+        SubClass<String> generate() {
+            return null;
+        }
+    }
+
+    @Test
+    public void can_handle_deep_stubs_with_generics_at_end_of_deep_invocation() {
+        UserOfSubClass mock = mock(UserOfSubClass.class, RETURNS_DEEP_STUBS);
+
+        when(mock.generate().execute()).thenReturn("sub");
+
+        assertThat(mock.generate().execute()).isEqualTo("sub");
+    }
+
+    public interface TopInterface<T> {
+        T generic();
+    }
+
+    public interface MiddleInterface<T> extends TopInterface<T> {}
+
+    public class OwningClassWithDeclaredUpperBounds<
+            T extends Iterable<Article> & Callable<Article> & Closeable> {
+        public abstract class AbstractInner implements MiddleInterface<T> {}
+    }
+
+    @Test
+    public void
+            cannot_handle_deep_stubs_with_generics_declared_upper_bounds_at_end_of_deep_invocation()
+                    throws Exception {
+        OwningClassWithDeclaredUpperBounds.AbstractInner mock =
+                mock(OwningClassWithDeclaredUpperBounds.AbstractInner.class, RETURNS_DEEP_STUBS);
+
+        // It seems that while the syntax used on OwningClassWithDeclaredUpperBounds.AbstractInner
+        // appear to be legal, the javac compiler does not follow through
+        // hence we need casting, this may also explain why GenericMetadataSupport has trouble to
+        // extract matching data as well.
+
+        assertThat(mock.generic())
+                .describedAs("mock should implement first bound : 'Iterable'")
+                .isInstanceOf(Iterable.class);
+        assertThat(((Iterable<Article>) mock.generic()).iterator())
+                .describedAs("Iterable returns Iterator")
+                .isInstanceOf(Iterator.class);
+        assertThat(((Iterable<Article>) mock.generic()).iterator().next())
+                .describedAs(
+                        "Cannot yet extract Type argument 'Article' so return null instead of a mock "
+                                + "of type Object (which would raise CCE on the call-site)")
+                .isNull();
+
+        assertThat(mock.generic())
+                .describedAs("mock should implement second interface bound : 'Callable'")
+                .isInstanceOf(Callable.class);
+        assertThat(((Callable<Article>) mock.generic()).call())
+                .describedAs(
+                        "Cannot yet extract Type argument 'Article' so return null instead of a mock "
+                                + "of type Object (which would raise CCE on the call-site)")
+                .isNull();
+
+        assertThat(mock.generic())
+                .describedAs("mock should implement third interface bound : 'Closeable'")
+                .isInstanceOf(Closeable.class);
     }
 }
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java
index 7de160c..3691412 100755
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java
@@ -4,51 +4,75 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import static org.junit.Assert.*;
+import static org.junit.Assume.assumeFalse;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest.WithGenerics;
 import org.mockito.internal.util.MockUtil;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.junit.Assume.assumeFalse;
-
 public class ReturnsMocksTest extends TestBase {
     private ReturnsMocks values = new ReturnsMocks();
 
-    interface FooInterface {
-    }
+    interface AllInterface {
+        FooInterface getInterface();
 
-    class BarClass {
-    }
+        BarClass getNormalClass();
+
+        Baz getFinalClass();
 
-    final class Baz {
+        WithGenerics<String> withGenerics();
     }
 
+    interface FooInterface {}
+
+    class BarClass {}
+
+    final class Baz {}
+
     @Test
-    public void should_return_mock_value_for_interface() throws Exception {
-        Object interfaceMock = values.returnValueFor(FooInterface.class);
+    public void should_return_mock_value_for_interface() throws Throwable {
+        Object interfaceMock = values.answer(invocationOf(AllInterface.class, "getInterface"));
         assertTrue(MockUtil.isMock(interfaceMock));
     }
 
     @Test
-    public void should_return_mock_value_for_class() throws Exception {
-        Object classMock = values.returnValueFor(BarClass.class);
+    public void should_return_mock_value_for_class() throws Throwable {
+        Object classMock = values.answer(invocationOf(AllInterface.class, "getNormalClass"));
+        assertTrue(MockUtil.isMock(classMock));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void should_return_mock_value_for_generic_class() throws Throwable {
+        WithGenerics<String> classMock =
+                (WithGenerics<String>)
+                        values.answer(invocationOf(AllInterface.class, "withGenerics"));
         assertTrue(MockUtil.isMock(classMock));
+        when(classMock.execute()).thenReturn("return");
+        assertEquals("return", classMock.execute());
     }
 
     @Test
-    public void should_return_null_for_final_class_if_unsupported() throws Exception {
+    public void should_return_null_for_final_class_if_unsupported() throws Throwable {
         assumeFalse(Plugins.getMockMaker().isTypeMockable(Baz.class).mockable());
-        assertNull(values.returnValueFor(Baz.class));
+        assertNull(values.answer(invocationOf(AllInterface.class, "getFinalClass")));
     }
 
     @Test
     public void should_return_the_usual_default_values_for_primitives() throws Throwable {
         ReturnsMocks answer = new ReturnsMocks();
-        assertEquals(false, answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
-        assertEquals((char) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
-        assertEquals((byte) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));
-        assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));
+        assertEquals(
+                false, answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
+        assertEquals(
+                (char) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
+        assertEquals(
+                (byte) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));
+        assertEquals(
+                (short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));
         assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));
         assertEquals(0L, answer.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));
         assertEquals(0f, answer.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));
@@ -58,12 +82,14 @@ public class ReturnsMocksTest extends TestBase {
     @SuppressWarnings("unused")
     interface StringMethods {
         String stringMethod();
+
         String[] stringArrayMethod();
     }
 
     @Test
     public void should_return_empty_array() throws Throwable {
-        String[] ret = (String[]) values.answer(invocationOf(StringMethods.class, "stringArrayMethod"));
+        String[] ret =
+                (String[]) values.answer(invocationOf(StringMethods.class, "stringArrayMethod"));
 
         assertTrue(ret.getClass().isArray());
         assertTrue(ret.length == 0);
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValuesTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValuesTest.java
index 4eac8cb..15ba0cd 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValuesTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValuesTest.java
@@ -4,12 +4,12 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class ReturnsMoreEmptyValuesTest extends TestBase {
 
     private ReturnsMoreEmptyValues rv = new ReturnsMoreEmptyValues();
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
index 228c56a..870f0ce 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
@@ -5,38 +5,58 @@
 package org.mockito.internal.stubbing.defaultanswers;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
 import org.mockito.exceptions.verification.SmartNullPointerException;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.InterceptedInvocation;
+import org.mockito.internal.invocation.SerializableMethod;
+import org.mockito.internal.invocation.mockref.MockStrongReference;
 import org.mockito.stubbing.Answer;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 public class ReturnsSmartNullsTest extends TestBase {
 
     @Test
     public void should_return_the_usual_default_values_for_primitives() throws Throwable {
         Answer<Object> answer = new ReturnsSmartNulls();
-        assertEquals(false  ,   answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
-        assertEquals((char) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
-        assertEquals((byte) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));
-        assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));
-        assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));
-        assertEquals(0L,        answer.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));
-        assertEquals(0f,        answer.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));
-        assertEquals(0d,        answer.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));
+        assertEquals(
+                false, answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
+        assertEquals(
+                (char) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
+        assertEquals(
+                (byte) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));
+        assertEquals(
+                (short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));
+        assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));
+        assertEquals(0L, answer.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));
+        assertEquals(0f, answer.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));
+        assertEquals(0d, answer.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));
     }
 
     @SuppressWarnings("unused")
     interface Foo {
         Foo get();
+
         Foo withArgs(String oneArg, String otherArg);
     }
 
     @Test
-    public void should_return_an_object_that_fails_on_any_method_invocation_for_non_primitives() throws Throwable {
+    public void should_return_an_object_that_fails_on_any_method_invocation_for_non_primitives()
+            throws Throwable {
         Answer<Object> answer = new ReturnsSmartNulls();
 
         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "get"));
@@ -44,7 +64,8 @@ public class ReturnsSmartNullsTest extends TestBase {
         try {
             smartNull.get();
             fail();
-        } catch (SmartNullPointerException expected) {}
+        } catch (SmartNullPointerException expected) {
+        }
     }
 
     @Test
@@ -53,9 +74,7 @@ public class ReturnsSmartNullsTest extends TestBase {
 
         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "get"));
 
-        assertThat(smartNull.toString())
-            .contains("SmartNull returned by")
-            .contains("foo.get()");
+        assertThat(smartNull.toString()).contains("SmartNull returned by").contains("foo.get()");
     }
 
     @Test
@@ -65,13 +84,14 @@ public class ReturnsSmartNullsTest extends TestBase {
         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa"));
 
         assertThat(smartNull.toString())
-            .contains("foo.withArgs")
-            .contains("oompa")
-            .contains("lumpa");
+                .contains("foo.withArgs")
+                .contains("oompa")
+                .contains("lumpa");
     }
 
     @Test
-    public void should_print_the_parameters_on_SmartNullPointerException_message() throws Throwable {
+    public void should_print_the_parameters_on_SmartNullPointerException_message()
+            throws Throwable {
         Answer<Object> answer = new ReturnsSmartNulls();
 
         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa"));
@@ -80,9 +100,281 @@ public class ReturnsSmartNullsTest extends TestBase {
             smartNull.get();
             fail();
         } catch (SmartNullPointerException e) {
-            assertThat(e)
-                .hasMessageContaining("oompa")
-                .hasMessageContaining("lumpa");
+            assertThat(e).hasMessageContaining("oompa").hasMessageContaining("lumpa");
         }
     }
+
+    interface GenericFoo<T> {
+        T get();
+    }
+
+    interface GenericFooBar extends GenericFoo<Foo> {
+        <I> I method();
+
+        <I> I methodWithArgs(int firstArg, I secondArg);
+
+        <I> I methodWithVarArgs(int firstArg, I... secondArg);
+    }
+
+    @Test
+    public void should_return_an_object_that_has_been_defined_with_class_generic()
+            throws Throwable {
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Foo smartNull = (Foo) answer.answer(invocationOf(GenericFooBar.class, "get"));
+
+        assertThat(smartNull.toString())
+                .contains("SmartNull returned by")
+                .contains("genericFooBar.get()");
+    }
+
+    @Test
+    public void should_return_an_object_that_has_been_defined_with_method_generic()
+            throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        String smartNull = (String) answer.answer(invocationOf(GenericFooBar.class, "method"));
+
+        assertThat(smartNull).isNull();
+    }
+
+    private static <T> InterceptedInvocation invocationMethodWithArgs(final T obj)
+            throws NoSuchMethodException {
+        return new InterceptedInvocation(
+                new MockStrongReference<Object>(mock(GenericFooBar.class), false),
+                new SerializableMethod(
+                        GenericFooBar.class.getMethod("methodWithArgs", int.class, Object.class)),
+                new Object[] {1, obj},
+                InterceptedInvocation.NO_OP,
+                new LocationImpl(),
+                1);
+    }
+
+    @Test
+    public void
+            should_return_a_String_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs("secondArg"));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(String.class).asString().isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_list_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        final List<String> list = Collections.singletonList("String");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(list));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(List.class);
+        assertThat((List) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_map_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        final Map<String, String> map = new HashMap<String, String>();
+        map.put("key-1", "value-1");
+        map.put("key-2", "value-2");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(map));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(Map.class);
+        assertThat((Map) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_set_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull =
+                answer.answer(
+                        invocationMethodWithArgs(
+                                new HashSet<String>(Arrays.asList("set-1", "set-2"))));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(Set.class);
+        assertThat((Set) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_new_mock_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock = mock(Foo.class);
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(mock));
+
+        assertThat(smartNull).isNotNull().isNotSameAs(mock);
+        assertThat(smartNull.toString())
+                .contains("SmartNull returned by")
+                .contains("genericFooBar.methodWithArgs(");
+    }
+
+    @Test
+    public void
+            should_return_an_Object_that_has_been_defined_with_method_generic_and_provided_in_argument()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(new Object() {}));
+
+        assertThat(smartNull.toString())
+                .contains("SmartNull returned by")
+                .contains("genericFooBar.methodWithArgs(");
+    }
+
+    @Test
+    public void should_throw_a_error_on_invocation_of_returned_mock() throws Throwable {
+
+        final Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock = mock(Foo.class);
+
+        final Throwable throwable =
+                Assertions.catchThrowable(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                ((Foo) answer.answer(invocationMethodWithArgs(mock))).get();
+                            }
+                        });
+
+        Assertions.assertThat(throwable)
+                .isInstanceOf(SmartNullPointerException.class)
+                .hasMessageContaining("genericFooBar.methodWithArgs(")
+                .hasMessageContaining("1")
+                .hasMessageContaining(mock.toString());
+    }
+
+    private static <T> InterceptedInvocation invocationMethodWithVarArgs(final T[] obj)
+            throws NoSuchMethodException {
+        return new InterceptedInvocation(
+                new MockStrongReference<Object>(mock(GenericFooBar.class), false),
+                new SerializableMethod(
+                        GenericFooBar.class.getMethod(
+                                "methodWithVarArgs", int.class, Object[].class)),
+                new Object[] {1, obj},
+                InterceptedInvocation.NO_OP,
+                new LocationImpl(),
+                1);
+    }
+
+    @Test
+    public void
+            should_return_a_String_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull =
+                answer.answer(invocationMethodWithVarArgs(new String[] {"varArg-1", "varArg-2"}));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(String.class).asString().isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_list_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        final List<String> arg1 = Collections.singletonList("String");
+        final List<String> arg2 = Arrays.asList("str-1", "str-2");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new List[] {arg1, arg2}));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(List.class);
+        assertThat((List) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_map_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        final Map<String, String> map1 =
+                new HashMap<String, String>() {
+                    {
+                        put("key-1", "value-1");
+                        put("key-2", "value-2");
+                    }
+                };
+        final Map<String, String> map2 =
+                new HashMap<String, String>() {
+                    {
+                        put("key-3", "value-1");
+                        put("key-4", "value-2");
+                    }
+                };
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new Map[] {map1, map2}));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(Map.class);
+        assertThat((Map) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_empty_set_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        final HashSet<String> set1 = new HashSet<String>(Arrays.asList("set-1", "set-2"));
+        final HashSet<String> set2 = new HashSet<String>(Arrays.asList("set-1", "set-2"));
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new HashSet[] {set1, set2}));
+
+        assertThat(smartNull).isNotNull().isInstanceOf(Set.class);
+        assertThat((Set) smartNull).isEmpty();
+    }
+
+    @Test
+    public void
+            should_return_a_new_mock_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock1 = mock(Foo.class);
+        final Foo mock2 = mock(Foo.class);
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new Foo[] {mock1, mock2}));
+
+        assertThat(smartNull).isNotNull().isNotSameAs(mock1).isNotSameAs(mock2);
+        assertThat(smartNull.toString())
+                .contains("SmartNull returned by")
+                .contains("genericFooBar.methodWithVarArgs(");
+    }
+
+    @Test
+    public void
+            should_return_an_Object_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+                    throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull =
+                answer.answer(
+                        invocationMethodWithVarArgs(
+                                new Object[] {new Object() {}, new Object() {}}));
+
+        assertThat(smartNull.toString())
+                .contains("SmartNull returned by")
+                .contains("genericFooBar.methodWithVarArgs(");
+    }
 }
diff --git a/src/test/java/org/mockito/internal/util/ChecksTest.java b/src/test/java/org/mockito/internal/util/ChecksTest.java
index d2c75b5..6b640db 100644
--- a/src/test/java/org/mockito/internal/util/ChecksTest.java
+++ b/src/test/java/org/mockito/internal/util/ChecksTest.java
@@ -2,40 +2,42 @@
  * Copyright (c) 2017 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 
 public class ChecksTest {
-    @Rule
-    public ExpectedException expectedException = ExpectedException.none();
 
     @Test
-    public void checkNotNull_not_null() throws Exception {
+    public void checkNotNull_not_null() {
         assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
     }
 
     @Test
-    public void checkNotNull_not_null_additional_message() throws Exception {
+    public void checkNotNull_not_null_additional_message() {
         assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
     }
 
     @Test
-    public void checkNotNull_null() throws Exception {
-        expectedException.expect(IllegalArgumentException.class);
-        expectedException.expectMessage("someValue should not be null");
-        Checks.checkNotNull(null, "someValue");
+    public void checkNotNull_null() {
+        assertThatThrownBy(
+                        () -> {
+                            Checks.checkNotNull(null, "someValue");
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessageContaining("someValue should not be null");
     }
 
     @Test
-    public void checkNotNull_null_additonal_message() throws Exception {
-        expectedException.expect(IllegalArgumentException.class);
-        expectedException.expectMessage("someValue should not be null. Oh no!");
-        Checks.checkNotNull(null, "someValue", "Oh no!");
+    public void checkNotNull_null_additonal_message() {
+        assertThatThrownBy(
+                        () -> {
+                            Checks.checkNotNull(null, "someValue", "Oh no!");
+                        })
+                .isInstanceOf(IllegalArgumentException.class)
+                .hasMessageContaining("someValue should not be null. Oh no!");
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/DefaultMockingDetailsTest.java b/src/test/java/org/mockito/internal/util/DefaultMockingDetailsTest.java
index ae2ef25..1a126d6 100644
--- a/src/test/java/org/mockito/internal/util/DefaultMockingDetailsTest.java
+++ b/src/test/java/org/mockito/internal/util/DefaultMockingDetailsTest.java
@@ -4,23 +4,12 @@
  */
 package org.mockito.internal.util;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.Spy;
-import org.mockito.exceptions.misusing.NotAMockException;
-import org.mockito.stubbing.Stubbing;
-import org.mockitousage.IMethods;
-
-import java.util.Collection;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.fail;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.mockingDetails;
@@ -28,6 +17,18 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 
+import java.util.Collection;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.mockito.Spy;
+import org.mockito.exceptions.misusing.NotAMockException;
+import org.mockito.stubbing.Stubbing;
+import org.mockitousage.IMethods;
+
 @SuppressWarnings("unchecked")
 public class DefaultMockingDetailsTest {
 
@@ -36,27 +37,33 @@ public class DefaultMockingDetailsTest {
     @Mock private IMethods mock;
     @Spy private Gork gork;
 
-    @Before public void before() {
-        MockitoAnnotations.initMocks(this);
+    @Before
+    public void before() {
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test
     public void should_provide_original_mock() throws Exception {
-        //expect
+        // expect
         assertEquals(mockingDetails(foo).getMock(), foo);
         assertEquals(mockingDetails(null).getMock(), null);
     }
 
     @Test
-    public void should_know_spy(){
+    public void should_know_spy() {
         assertTrue(mockingDetails(gork).isMock());
-        assertTrue(mockingDetails(spy( new Gork())).isMock());
+        assertTrue(mockingDetails(spy(new Gork())).isMock());
         assertTrue(mockingDetails(spy(Gork.class)).isMock());
-        assertTrue(mockingDetails(mock(Gork.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isMock());
+        assertTrue(
+                mockingDetails(
+                                mock(
+                                        Gork.class,
+                                        withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS)))
+                        .isMock());
     }
 
     @Test
-    public void should_know_mock(){
+    public void should_know_mock() {
         assertTrue(mockingDetails(foo).isMock());
         assertTrue(mockingDetails(mock(Foo.class)).isMock());
         assertFalse(mockingDetails(foo).isSpy());
@@ -79,72 +86,86 @@ public class DefaultMockingDetailsTest {
 
     @Test
     public void provides_invocations() {
-        //when
+        // when
         mock.simpleMethod(10);
         mock.otherMethod();
 
-        //then
+        // then
         assertEquals(0, mockingDetails(foo).getInvocations().size());
-        assertEquals("[mock.simpleMethod(10);, mock.otherMethod();]", mockingDetails(mock).getInvocations().toString());
+        assertEquals(
+                "[mock.simpleMethod(10);, mock.otherMethod();]",
+                mockingDetails(mock).getInvocations().toString());
     }
 
     @Test
     public void manipulating_invocations_is_safe() {
         mock.simpleMethod();
 
-        //when we manipulate the invocations
+        // when we manipulate the invocations
         mockingDetails(mock).getInvocations().clear();
 
-        //then we didn't actually changed the invocations
+        // then we didn't actually changed the invocations
         assertEquals(1, mockingDetails(mock).getInvocations().size());
     }
 
     @Test
     public void provides_mock_creation_settings() {
-        //smoke test some creation settings
+        // smoke test some creation settings
         assertEquals(Foo.class, mockingDetails(foo).getMockCreationSettings().getTypeToMock());
         assertEquals(Bar.class, mockingDetails(bar).getMockCreationSettings().getTypeToMock());
         assertEquals(0, mockingDetails(mock).getMockCreationSettings().getExtraInterfaces().size());
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void fails_when_getting_creation_settings_for_incorrect_input() {
-        mockingDetails(null).getMockCreationSettings();
+        assertThatThrownBy(
+                        () -> {
+                            mockingDetails(null).getMockCreationSettings();
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage(
+                        "Argument passed to Mockito.mockingDetails() should be a mock, but is null!");
     }
 
     @Test
     public void fails_when_getting_invocations_when_null() {
         try {
-            //when
+            // when
             mockingDetails(null).getInvocations();
-            //then
+            // then
             fail();
         } catch (NotAMockException e) {
-            assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is null!", e.getMessage());
+            assertEquals(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is null!",
+                    e.getMessage());
         }
     }
 
     @Test
     public void fails_when_getting_invocations_when_not_mock() {
         try {
-            //when
+            // when
             mockingDetails(new Object()).getInvocations();
-            //then
+            // then
             fail();
         } catch (NotAMockException e) {
-            assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
+            assertEquals(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!",
+                    e.getMessage());
         }
     }
 
     @Test
     public void fails_when_getting_stubbings_from_non_mock() {
         try {
-            //when
+            // when
             mockingDetails(new Object()).getStubbings();
-            //then
+            // then
             fail();
         } catch (NotAMockException e) {
-            assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
+            assertEquals(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!",
+                    e.getMessage());
         }
     }
 
@@ -158,35 +179,37 @@ public class DefaultMockingDetailsTest {
         when(mock.simpleMethod(1)).thenReturn("1");
         when(mock.otherMethod()).thenReturn("2");
 
-        //when
+        // when
         Collection<Stubbing> stubbings = mockingDetails(mock).getStubbings();
 
-        //then
+        // then
         assertEquals(2, stubbings.size());
-        assertEquals("[mock.simpleMethod(1); stubbed with: [Returns: 1], mock.otherMethod(); stubbed with: [Returns: 2]]", stubbings.toString());
+        assertEquals(
+                "[mock.simpleMethod(1); stubbed with: [Returns: 1], mock.otherMethod(); stubbed with: [Returns: 2]]",
+                stubbings.toString());
     }
 
     @Test
     public void manipulating_stubbings_explicitly_is_safe() {
         when(mock.simpleMethod(1)).thenReturn("1");
 
-        //when somebody manipulates stubbings directly
+        // when somebody manipulates stubbings directly
         mockingDetails(mock).getStubbings().clear();
 
-        //then it does not affect stubbings of the mock
+        // then it does not affect stubbings of the mock
         assertEquals(1, mockingDetails(mock).getStubbings().size());
     }
 
     @Test
     public void prints_invocations() throws Exception {
-        //given
+        // given
         given(mock.simpleMethod("different arg")).willReturn("foo");
         mock.simpleMethod("arg");
 
-        //when
+        // when
         String log = Mockito.mockingDetails(mock).printInvocations();
 
-        //then
+        // then
         assertThat(log).containsIgnoringCase("unused");
         assertThat(log).containsIgnoringCase("mock.simpleMethod(\"arg\")");
         assertThat(log).containsIgnoringCase("mock.simpleMethod(\"different arg\")");
@@ -195,16 +218,20 @@ public class DefaultMockingDetailsTest {
     @Test
     public void fails_when_printin_invocations_from_non_mock() {
         try {
-            //when
+            // when
             mockingDetails(new Object()).printInvocations();
-            //then
+            // then
             fail();
         } catch (NotAMockException e) {
-            assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
+            assertEquals(
+                    "Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!",
+                    e.getMessage());
         }
     }
 
-    public class Foo { }
-    public interface Bar { }
-    public static class Gork { }
+    public class Foo {}
+
+    public interface Bar {}
+
+    public static class Gork {}
 }
diff --git a/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java b/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
index 1a9b109..7efffcf 100644
--- a/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
+++ b/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
@@ -4,17 +4,18 @@
  */
 package org.mockito.internal.util;
 
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockitousage.IMethods;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockitousage.IMethods;
 
 @SuppressWarnings("unchecked")
 public class MockCreationValidatorTest {
@@ -22,42 +23,48 @@ public class MockCreationValidatorTest {
     MockCreationValidator validator = new MockCreationValidator();
 
     @Test
-    public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type() throws Exception {
+    public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type() {
         try {
-            //when
+            // when
             validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));
             fail();
         } catch (MockitoException e) {
-            //then
+            // then
             assertThat(e.getMessage()).contains("You mocked following type: IMethods");
         }
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_not_allow_inconsistent_types() throws Exception {
-        //when
-        validator.validateMockedType(List.class, new ArrayList());
-        //then
+    @Test
+    public void should_not_allow_inconsistent_types() {
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            validator.validateMockedType(List.class, new ArrayList());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Mocked type must be the same as the type of your spied instance.",
+                        "Mocked type must be: ArrayList, but is: List");
     }
 
     @Test
-    public void should_allow_only_consistent_types() throws Exception {
-        //when
+    public void should_allow_only_consistent_types() {
+        // when
         validator.validateMockedType(ArrayList.class, new ArrayList());
-        //then no exception is thrown
+        // then no exception is thrown
     }
 
     @Test
-    public void should_validation_be_safe_when_nulls_passed() throws Exception {
-        //when
+    public void should_validation_be_safe_when_nulls_passed() {
+        // when
         validator.validateMockedType(null, new ArrayList());
-        //or
+        // or
         validator.validateMockedType(ArrayList.class, null);
-        //then no exception is thrown
+        // then no exception is thrown
     }
 
     @Test
-    public void should_fail_when_type_not_mockable() throws Exception {
+    public void should_fail_when_type_not_mockable() {
         try {
             validator.validateType(long.class);
         } catch (MockitoException ex) {
diff --git a/src/test/java/org/mockito/internal/util/MockNameImplTest.java b/src/test/java/org/mockito/internal/util/MockNameImplTest.java
index 071594b..583bd7a 100644
--- a/src/test/java/org/mockito/internal/util/MockNameImplTest.java
+++ b/src/test/java/org/mockito/internal/util/MockNameImplTest.java
@@ -4,39 +4,66 @@
  */
 package org.mockito.internal.util;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class MockNameImplTest extends TestBase {
 
     @Test
     public void shouldProvideTheNameForClass() throws Exception {
-        //when
-        String name = new MockNameImpl(null, SomeClass.class).toString();
-        //then
+        // when
+        String name = new MockNameImpl(null, SomeClass.class, false).toString();
+        // then
         assertEquals("someClass", name);
     }
 
+    @Test
+    public void shouldProvideTheNameForClassOnStaticMock() throws Exception {
+        // when
+        String name = new MockNameImpl(null, SomeClass.class, true).toString();
+        // then
+        assertEquals("SomeClass.class", name);
+    }
+
     @Test
     public void shouldProvideTheNameForAnonymousClass() throws Exception {
-        //given
+        // given
         SomeInterface anonymousInstance = new SomeInterface() {};
-        //when
-        String name = new MockNameImpl(null, anonymousInstance.getClass()).toString();
-        //then
+        // when
+        String name = new MockNameImpl(null, anonymousInstance.getClass(), false).toString();
+        // then
         assertEquals("someInterface", name);
     }
 
+    @Test
+    public void shouldProvideTheNameForAnonymousClassOnStatic() throws Exception {
+        // given
+        SomeInterface anonymousInstance = new SomeInterface() {};
+        // when
+        String name = new MockNameImpl(null, anonymousInstance.getClass(), true).toString();
+        // then
+        assertEquals("SomeInterface$.class", name);
+    }
+
     @Test
     public void shouldProvideTheGivenName() throws Exception {
-        //when
-        String name = new MockNameImpl("The Hulk", SomeClass.class).toString();
-        //then
+        // when
+        String name = new MockNameImpl("The Hulk", SomeClass.class, false).toString();
+        // then
+        assertEquals("The Hulk", name);
+    }
+
+    @Test
+    public void shouldProvideTheGivenNameOnStatic() throws Exception {
+        // when
+        String name = new MockNameImpl("The Hulk", SomeClass.class, true).toString();
+        // then
         assertEquals("The Hulk", name);
     }
 
     private class SomeClass {}
+
     private class SomeInterface {}
 }
diff --git a/src/test/java/org/mockito/internal/util/MockSettingsTest.java b/src/test/java/org/mockito/internal/util/MockSettingsTest.java
index 01df499..ab39828 100644
--- a/src/test/java/org/mockito/internal/util/MockSettingsTest.java
+++ b/src/test/java/org/mockito/internal/util/MockSettingsTest.java
@@ -4,36 +4,35 @@
  */
 package org.mockito.internal.util;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.mock.MockCreationSettings;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 public class MockSettingsTest extends TestBase {
     @Test
     public void public_api_for_creating_settings() throws Exception {
-        //when
-        MockCreationSettings<List> settings = Mockito.withSettings()
-            .name("dummy")
-            .build(List.class);
+        // when
+        MockCreationSettings<List> settings =
+                Mockito.withSettings().name("dummy").build(List.class);
 
-        //then
+        // then
         assertEquals(List.class, settings.getTypeToMock());
         assertEquals("dummy", settings.getMockName().toString());
     }
+
     @Test
     public void test_without_annotations() throws Exception {
-        MockCreationSettings<List> settings = Mockito.withSettings()
-            .withoutAnnotations()
-            .build(List.class);
+        MockCreationSettings<List> settings =
+                Mockito.withSettings().withoutAnnotations().build(List.class);
 
-        CreationSettings copy = new CreationSettings((CreationSettings)settings);
+        CreationSettings copy = new CreationSettings((CreationSettings) settings);
 
         assertEquals(List.class, settings.getTypeToMock());
         assertEquals(List.class, copy.getTypeToMock());
diff --git a/src/test/java/org/mockito/internal/util/MockUtilTest.java b/src/test/java/org/mockito/internal/util/MockUtilTest.java
index dee6413..50cadb4 100644
--- a/src/test/java/org/mockito/internal/util/MockUtilTest.java
+++ b/src/test/java/org/mockito/internal/util/MockUtilTest.java
@@ -2,23 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.withSettings;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockitoutil.TestBase;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.withSettings;
-
 @SuppressWarnings("unchecked")
 public class MockUtilTest extends TestBase {
 
@@ -28,14 +29,24 @@ public class MockUtilTest extends TestBase {
         assertNotNull(MockUtil.getMockHandler(mock));
     }
 
-    @Test (expected=NotAMockException.class)
+    @Test
     public void should_scream_when_not_a_mock_passed() {
-        MockUtil.getMockHandler("");
+        assertThatThrownBy(
+                        () -> {
+                            MockUtil.getMockHandler("");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is: class java.lang.String");
     }
 
-    @Test (expected=MockitoException.class)
+    @Test
     public void should_scream_when_null_passed() {
-        MockUtil.getMockHandler(null);
+        assertThatThrownBy(
+                        () -> {
+                            MockUtil.getMockHandler(null);
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is null!");
     }
 
     @Test
@@ -58,7 +69,11 @@ public class MockUtilTest extends TestBase {
 
         assertTrue(MockUtil.isSpy(Mockito.spy(new ArrayList())));
         assertTrue(MockUtil.isSpy(Mockito.spy(ArrayList.class)));
-        assertTrue(MockUtil.isSpy(Mockito.mock(ArrayList.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))));
+        assertTrue(
+                MockUtil.isSpy(
+                        Mockito.mock(
+                                ArrayList.class,
+                                withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))));
     }
 
     @Test
@@ -78,7 +93,9 @@ public class MockUtilTest extends TestBase {
     }
 
     final class FinalClass {}
+
     class SomeClass {}
+
     interface SomeInterface {}
 
     @Test
diff --git a/src/test/java/org/mockito/internal/util/ObjectMethodsGuruTest.java b/src/test/java/org/mockito/internal/util/ObjectMethodsGuruTest.java
index 1a93c3b..3f9c594 100644
--- a/src/test/java/org/mockito/internal/util/ObjectMethodsGuruTest.java
+++ b/src/test/java/org/mockito/internal/util/ObjectMethodsGuruTest.java
@@ -4,45 +4,60 @@
  */
 package org.mockito.internal.util;
 
-import org.junit.Test;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import java.util.Date;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 public class ObjectMethodsGuruTest extends TestBase {
 
-
     private interface HasCompareToButDoesNotImplementComparable {
         int compareTo(HasCompareToButDoesNotImplementComparable other);
     }
 
     private interface HasCompare extends Comparable<HasCompare> {
         int foo(HasCompare other);
+
         int compareTo(HasCompare other, String redHerring);
+
         int compareTo(String redHerring);
+
         int compareTo(HasCompare redHerring);
     }
 
     @Test
     public void shouldKnowToStringMethod() throws Exception {
-        assertFalse(ObjectMethodsGuru.isToStringMethod(Object.class.getMethod("equals", Object.class)));
-        assertFalse(ObjectMethodsGuru.isToStringMethod(IMethods.class.getMethod("toString", String.class)));
+        assertFalse(
+                ObjectMethodsGuru.isToStringMethod(Object.class.getMethod("equals", Object.class)));
+        assertFalse(
+                ObjectMethodsGuru.isToStringMethod(
+                        IMethods.class.getMethod("toString", String.class)));
         assertTrue(ObjectMethodsGuru.isToStringMethod(IMethods.class.getMethod("toString")));
     }
 
-
     @Test
     public void shouldKnowCompareToMethod() throws Exception {
         assertFalse(ObjectMethodsGuru.isCompareToMethod(Date.class.getMethod("toString")));
-        assertFalse(ObjectMethodsGuru.isCompareToMethod(HasCompare.class.getMethod("foo", HasCompare.class)));
-        assertFalse(ObjectMethodsGuru.isCompareToMethod(HasCompare.class.getMethod("compareTo", HasCompare.class, String.class)));
-        assertFalse(ObjectMethodsGuru.isCompareToMethod(HasCompare.class.getMethod("compareTo", String.class)));
-        assertFalse(ObjectMethodsGuru.isCompareToMethod(HasCompareToButDoesNotImplementComparable.class.getDeclaredMethod("compareTo", HasCompareToButDoesNotImplementComparable.class)));
-
-        assertTrue(ObjectMethodsGuru.isCompareToMethod(HasCompare.class.getMethod("compareTo", HasCompare.class)));
+        assertFalse(
+                ObjectMethodsGuru.isCompareToMethod(
+                        HasCompare.class.getMethod("foo", HasCompare.class)));
+        assertFalse(
+                ObjectMethodsGuru.isCompareToMethod(
+                        HasCompare.class.getMethod("compareTo", HasCompare.class, String.class)));
+        assertFalse(
+                ObjectMethodsGuru.isCompareToMethod(
+                        HasCompare.class.getMethod("compareTo", String.class)));
+        assertFalse(
+                ObjectMethodsGuru.isCompareToMethod(
+                        HasCompareToButDoesNotImplementComparable.class.getDeclaredMethod(
+                                "compareTo", HasCompareToButDoesNotImplementComparable.class)));
+
+        assertTrue(
+                ObjectMethodsGuru.isCompareToMethod(
+                        HasCompare.class.getMethod("compareTo", HasCompare.class)));
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/PlatformTest.java b/src/test/java/org/mockito/internal/util/PlatformTest.java
index bf07977..b72c71d 100644
--- a/src/test/java/org/mockito/internal/util/PlatformTest.java
+++ b/src/test/java/org/mockito/internal/util/PlatformTest.java
@@ -4,11 +4,12 @@
  */
 package org.mockito.internal.util;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.util.HashMap;
 import java.util.Map;
-import org.junit.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
 
 // Possible description on a IBM J9 VM (see #801)
 //
@@ -41,17 +42,25 @@ public class PlatformTest {
 
     @Test
     public void should_warn_for_jvm() throws Exception {
-        assertThat(Platform.warnForVM("Java HotSpot(TM) 64-Bit Server VM",
-                                      "HotSpot", "hotspot warning",
-                                      "IBM", "ibm warning"))
+        assertThat(
+                        Platform.warnForVM(
+                                "Java HotSpot(TM) 64-Bit Server VM",
+                                "HotSpot",
+                                "hotspot warning",
+                                "IBM",
+                                "ibm warning"))
                 .isEqualTo("hotspot warning");
-        assertThat(Platform.warnForVM("IBM J9 VM",
-                                      "HotSpot", "hotspot warning",
-                                      "IBM", "ibm warning"))
+        assertThat(
+                        Platform.warnForVM(
+                                "IBM J9 VM", "HotSpot", "hotspot warning", "IBM", "ibm warning"))
                 .isEqualTo("ibm warning");
-        assertThat(Platform.warnForVM("whatever",
-                                      null, "should not be returned",
-                                      null, "should not be returned"))
+        assertThat(
+                        Platform.warnForVM(
+                                "whatever",
+                                null,
+                                "should not be returned",
+                                null,
+                                "should not be returned"))
                 .isEqualTo("");
     }
 
@@ -59,36 +68,42 @@ public class PlatformTest {
     public void should_parse_open_jdk_string_and_report_wether_below_or_nut_update_45() {
         // Given
         // Sources :
-        //  - http://www.oracle.com/technetwork/java/javase/versioning-naming-139433.html
-        //  - http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html
-        //  - http://www.oracle.com/technetwork/java/javase/jdk8-naming-2157130.html
-        //  - http://stackoverflow.com/questions/35844985/how-do-we-get-sr-and-fp-of-ibm-jre-using-java
-        //  - http://www.ibm.com/support/knowledgecenter/SSYKE2_6.0.0/com.ibm.java.doc.user.win32.60/user/java_version_check.html
-        Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
-            put("1.8.0_92-b14", false);
-            put("1.8.0-b24", true);
-            put("1.8.0_5", true);
-            put("1.8.0b5_u44", true);
-            put("1.8.0b5_u92", false);
-            put("1.7.0_4", false);
-            put("1.4.0_03-b04", false);
-            put("1.4.0_03-ea-b01", false);
-            put("pxi3270_27sr4-20160303_03 (SR4)", false);
-            put("pwi3260sr11-20120412_01 (SR11)", false);
-            put("pwa6480sr1fp10-20150711_01 (SR1 FP10)", false);
-            put("null", false);
-        }};
+        //  - https://www.oracle.com/java/technologies/javase/versioning-naming.html
+        //  - https://www.oracle.com/java/technologies/javase/jdk7-naming.html
+        //  - https://www.oracle.com/java/technologies/javase/jdk8-naming.html
+        //  -
+        // https://stackoverflow.com/questions/35844985/how-do-we-get-sr-and-fp-of-ibm-jre-using-java
+        //  -
+        // https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.80.doc/user/build_number.html
+        Map<String, Boolean> versions =
+                new HashMap<String, Boolean>() {
+                    {
+                        put("1.8.0_92-b14", false);
+                        put("1.8.0-b24", true);
+                        put("1.8.0_5", true);
+                        put("1.8.0b5_u44", true);
+                        put("1.8.0b5_u92", false);
+                        put("1.7.0_4", false);
+                        put("1.4.0_03-b04", false);
+                        put("1.4.0_03-ea-b01", false);
+                        put("pxi3270_27sr4-20160303_03 (SR4)", false);
+                        put("pwi3260sr11-20120412_01 (SR11)", false);
+                        put("pwa6480sr1fp10-20150711_01 (SR1 FP10)", false);
+                        put("null", false);
+                    }
+                };
 
         assertPlatformParsesCorrectlyVariousVersionScheme(versions);
     }
 
     @Test
     public void should_parse_open_jdk9_string() {
-        // The tested method targets Java 8 but should be able to parse other Java version numbers including Java 9
+        // The tested method targets Java 8 but should be able to parse other Java version numbers
+        // including Java 9
 
         // Given
         // Sources :
-        //  - http://openjdk.java.net/jeps/223 (Java 9)
+        //  - https://openjdk.java.net/jeps/223 (Java 9)
         //
         // System Property                 Existing      Proposed
         // ------------------------------- ------------  --------
@@ -119,21 +134,24 @@ public class PlatformTest {
         // java.specification.version      1.9           9
         // java.vm.specification.version   1.9           9
         //
-        Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
-            put("9-ea+73", false);
-            put("9+100", false);
-            put("9.1.2+62", false);
-            put("9.0.1+20", false);
-        }};
+        Map<String, Boolean> versions =
+                new HashMap<String, Boolean>() {
+                    {
+                        put("9-ea+73", false);
+                        put("9+100", false);
+                        put("9.1.2+62", false);
+                        put("9.0.1+20", false);
+                    }
+                };
 
         assertPlatformParsesCorrectlyVariousVersionScheme(versions);
     }
 
-
     private void assertPlatformParsesCorrectlyVariousVersionScheme(Map<String, Boolean> versions) {
         for (Map.Entry<String, Boolean> version : versions.entrySet()) {
-            assertThat(Platform.isJava8BelowUpdate45(version.getKey())).describedAs(version.getKey())
-                                                                       .isEqualTo(version.getValue());
+            assertThat(Platform.isJava8BelowUpdate45(version.getKey()))
+                    .describedAs(version.getKey())
+                    .isEqualTo(version.getValue());
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/PrimitivesTest.java b/src/test/java/org/mockito/internal/util/PrimitivesTest.java
index 34dd362..214a7ec 100644
--- a/src/test/java/org/mockito/internal/util/PrimitivesTest.java
+++ b/src/test/java/org/mockito/internal/util/PrimitivesTest.java
@@ -4,12 +4,11 @@
  */
 package org.mockito.internal.util;
 
-import org.junit.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
+import org.junit.Test;
 
 public class PrimitivesTest {
     @Test
diff --git a/src/test/java/org/mockito/internal/util/SimpleMockitoLogger.java b/src/test/java/org/mockito/internal/util/SimpleMockitoLogger.java
index 129547f..2c735fb 100644
--- a/src/test/java/org/mockito/internal/util/SimpleMockitoLogger.java
+++ b/src/test/java/org/mockito/internal/util/SimpleMockitoLogger.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.internal.util;
 
+import org.mockito.plugins.MockitoLogger;
+
 public class SimpleMockitoLogger implements MockitoLogger {
 
     private StringBuilder loggedInfo = new StringBuilder();
@@ -27,7 +29,8 @@ public class SimpleMockitoLogger implements MockitoLogger {
 
     public void assertEmpty() {
         if (loggedInfo.length() != 0) {
-            throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
+            throw new AssertionError(
+                    "Expected the logger to be empty but it has:\n" + loggedInfo.toString());
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/SimpleMockitoLoggerTest.java b/src/test/java/org/mockito/internal/util/SimpleMockitoLoggerTest.java
index 123502a..a12d4da 100644
--- a/src/test/java/org/mockito/internal/util/SimpleMockitoLoggerTest.java
+++ b/src/test/java/org/mockito/internal/util/SimpleMockitoLoggerTest.java
@@ -4,20 +4,20 @@
  */
 package org.mockito.internal.util;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class SimpleMockitoLoggerTest extends TestBase {
 
     @Test
     public void shouldLog() throws Exception {
-        //given
+        // given
         SimpleMockitoLogger logger = new SimpleMockitoLogger();
-        //when
+        // when
         logger.log("foo");
-        //then
+        // then
         assertEquals("foo", logger.getLoggedInfo());
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/StringUtilTest.java b/src/test/java/org/mockito/internal/util/StringUtilTest.java
index 1858fe0..526d399 100644
--- a/src/test/java/org/mockito/internal/util/StringUtilTest.java
+++ b/src/test/java/org/mockito/internal/util/StringUtilTest.java
@@ -2,25 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util;
 
-import org.junit.Test;
-
 import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
-import static org.junit.Assert.assertEquals;
+
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
 
-public class StringUtilTest  {
+public class StringUtilTest {
 
     @Test
-    public void decamelizes_matcher() throws Exception {
-        assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
-        assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
-        assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
-        assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
-        assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
+    public void decamelizes_matcher_name() throws Exception {
+        assertEquals(
+                "<Sentence with strong language>",
+                StringUtil.decamelizeMatcherName("SentenceWithStrongLanguage"));
+        assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcherName("WEIRDO1"));
+        assertEquals("<_>", StringUtil.decamelizeMatcherName("_"));
+        assertEquals(
+                "<Has exactly 3 elements>",
+                StringUtil.decamelizeMatcherName("HasExactly3Elements"));
+        assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcherName(""));
     }
 
     @Test
@@ -36,11 +40,11 @@ public class StringUtilTest  {
 
     @Test
     public void joins_two_lines() throws Exception {
-        assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
+        assertThat(StringUtil.join("line1", "line2")).hasLineCount(3);
     }
 
     @Test
-    public void join_has_preceeding_linebreak() throws Exception {
+    public void join_has_preceding_linebreak() throws Exception {
         assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
     }
 
@@ -51,8 +55,7 @@ public class StringUtilTest  {
 
     @Test
     public void joins_with_line_prefix() throws Exception {
-        assertEquals("Hey!\n" +
-            " - a\n" +
-            " - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
+        assertEquals(
+                "Hey!\n" + " - a\n" + " - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/TimerTest.java b/src/test/java/org/mockito/internal/util/TimerTest.java
index 8a4a173..b0da7cd 100644
--- a/src/test/java/org/mockito/internal/util/TimerTest.java
+++ b/src/test/java/org/mockito/internal/util/TimerTest.java
@@ -4,48 +4,49 @@
  */
 package org.mockito.internal.util;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import org.assertj.core.api.Assertions;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.exceptions.misusing.FriendlyReminderException;
 import org.mockitoutil.TestBase;
 
 public class TimerTest extends TestBase {
-    @Rule
-    public ExpectedException expectedException = ExpectedException.none();
 
     @Test
     public void should_return_true_if_task_is_in_acceptable_time_bounds() {
-        //given
+        // given
         long duration = 10000L;
         Timer timer = new Timer(duration);
 
-        //when
+        // when
         timer.start();
 
-        //then
+        // then
         Assertions.assertThat(timer.isCounting()).isTrue();
     }
 
     @Test
     public void should_return_false_when_time_run_out() throws Exception {
-        //given
+        // given
         Timer timer = new Timer(0);
         timer.start();
 
-        //when
+        // when
         oneMillisecondPasses();
 
-        //then
+        // then
         Assertions.assertThat(timer.isCounting()).isFalse();
     }
 
     @Test
     public void should_throw_friendly_reminder_exception_when_duration_is_negative() {
-        expectedException.expect(FriendlyReminderException.class);
-        expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
-        new Timer(-1);
+        assertThatThrownBy(
+                        () -> {
+                            new Timer(-1);
+                        })
+                .isInstanceOf(FriendlyReminderException.class)
+                .hasMessageContaining("Don't panic! I'm just a friendly reminder!");
     }
 
     private void oneMillisecondPasses() throws InterruptedException {
diff --git a/src/test/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java b/src/test/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java
index 031a654..0012a59 100644
--- a/src/test/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java
+++ b/src/test/java/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java
@@ -5,6 +5,7 @@
 package org.mockito.internal.util.collections;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.Mockito.mock;
 
 import java.util.HashSet;
@@ -21,10 +22,8 @@ import org.mockito.junit.MockitoRule;
 
 public class HashCodeAndEqualsSafeSetTest {
 
-    @Rule
-    public MockitoRule r = MockitoJUnit.rule();
-    @Mock
-    private UnmockableHashCodeAndEquals mock1;
+    @Rule public MockitoRule r = MockitoJUnit.rule();
+    @Mock private UnmockableHashCodeAndEquals mock1;
 
     @Test
     public void can_add_mock_that_have_failing_hashCode_method() throws Exception {
@@ -57,12 +56,9 @@ public class HashCodeAndEqualsSafeSetTest {
         assertThat(mocks.isEmpty()).isTrue();
     }
 
-
     @Test
     public void can_add_a_collection() throws Exception {
-        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(
-                mock1,
-                mock(Observer.class));
+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1, mock(Observer.class));
 
         HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();
 
@@ -73,9 +69,7 @@ public class HashCodeAndEqualsSafeSetTest {
 
     @Test
     public void can_retain_a_collection() throws Exception {
-        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(
-                mock1,
-                mock(Observer.class));
+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1, mock(Observer.class));
 
         HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();
 
@@ -88,9 +82,7 @@ public class HashCodeAndEqualsSafeSetTest {
 
     @Test
     public void can_remove_a_collection() throws Exception {
-        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(
-                mock1,
-                mock(Observer.class));
+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1, mock(Observer.class));
 
         HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();
 
@@ -103,9 +95,7 @@ public class HashCodeAndEqualsSafeSetTest {
 
     @Test
     public void can_iterate() throws Exception {
-        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(
-                mock1,
-                mock(Observer.class));
+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1, mock(Observer.class));
 
         LinkedList<Object> accumulator = new LinkedList<Object>();
         for (Object mock : mocks) {
@@ -123,13 +113,17 @@ public class HashCodeAndEqualsSafeSetTest {
         assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);
     }
 
-    @Test(expected=CloneNotSupportedException.class)
-    public void cloneIsNotSupported() throws CloneNotSupportedException{
-        HashCodeAndEqualsSafeSet.of().clone();
+    @Test
+    public void cloneIsNotSupported() {
+        assertThatThrownBy(
+                        () -> {
+                            HashCodeAndEqualsSafeSet.of().clone();
+                        })
+                .isInstanceOf(CloneNotSupportedException.class);
     }
 
     @Test
-    public void isEmptyAfterClear() throws Exception {
+    public void isEmptyAfterClear() {
         HashCodeAndEqualsSafeSet set = HashCodeAndEqualsSafeSet.of(mock1);
         set.clear();
 
@@ -137,26 +131,26 @@ public class HashCodeAndEqualsSafeSetTest {
     }
 
     @Test
-    public void isEqualToItself(){
+    public void isEqualToItself() {
         HashCodeAndEqualsSafeSet set = HashCodeAndEqualsSafeSet.of(mock1);
         assertThat(set).isEqualTo(set);
     }
 
     @Test
-    public void isNotEqualToAnOtherTypeOfSetWithSameContent(){
+    public void isNotEqualToAnOtherTypeOfSetWithSameContent() {
         HashCodeAndEqualsSafeSet set = HashCodeAndEqualsSafeSet.of();
         assertThat(set).isNotEqualTo(new HashSet<Object>());
     }
 
     @Test
-    public void isNotEqualWhenContentIsDifferent(){
+    public void isNotEqualWhenContentIsDifferent() {
 
         HashCodeAndEqualsSafeSet set = HashCodeAndEqualsSafeSet.of(mock1);
         assertThat(set).isNotEqualTo(HashCodeAndEqualsSafeSet.of());
     }
 
     @Test
-    public void hashCodeIsEqualIfContentIsEqual(){
+    public void hashCodeIsEqualIfContentIsEqual() {
         HashCodeAndEqualsSafeSet set = HashCodeAndEqualsSafeSet.of(mock1);
         assertThat(set.hashCode()).isEqualTo(HashCodeAndEqualsSafeSet.of(mock1).hashCode());
     }
@@ -178,11 +172,13 @@ public class HashCodeAndEqualsSafeSetTest {
     }
 
     private static class UnmockableHashCodeAndEquals {
-        @Override public final int hashCode() {
+        @Override
+        public final int hashCode() {
             throw new NullPointerException("I'm failing on hashCode and I don't care");
         }
 
-        @Override public final boolean equals(Object obj) {
+        @Override
+        public final boolean equals(Object obj) {
             throw new NullPointerException("I'm failing on equals and I don't care");
         }
     }
diff --git a/src/test/java/org/mockito/internal/util/collections/IdentitySetTest.java b/src/test/java/org/mockito/internal/util/collections/IdentitySetTest.java
index da62926..1a44ba6 100644
--- a/src/test/java/org/mockito/internal/util/collections/IdentitySetTest.java
+++ b/src/test/java/org/mockito/internal/util/collections/IdentitySetTest.java
@@ -4,10 +4,9 @@
  */
 package org.mockito.internal.util.collections;
 
-import org.junit.Test;
-
 import static org.junit.Assert.*;
 
+import org.junit.Test;
 
 public class IdentitySetTest {
 
@@ -15,15 +14,16 @@ public class IdentitySetTest {
 
     @Test
     public void shouldWork() throws Exception {
-        //when
+        // when
         Object o = new Object();
         set.add(o);
 
-        //then
+        // then
         assertTrue(set.contains(o));
         assertFalse(set.contains(new Object()));
     }
 
+    @SuppressWarnings("EqualsHashCode")
     class Fake {
         @Override
         public boolean equals(Object obj) {
@@ -33,16 +33,15 @@ public class IdentitySetTest {
 
     @Test
     public void shouldWorkEvenIfEqualsTheSame() throws Exception {
-        //given
+        // given
         assertEquals(new Fake(), new Fake());
         Fake fake = new Fake();
 
-        //when
+        // when
         set.add(fake);
 
-        //then
+        // then
         assertTrue(set.contains(fake));
         assertFalse(set.contains(new Fake()));
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java b/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java
index 71c8bb1..6f47fe2 100644
--- a/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java
+++ b/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java
@@ -2,30 +2,33 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util.collections;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-import org.mockitoutil.TestBase;
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.assertTrue;
 
 import java.util.LinkedList;
 import java.util.List;
 
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertTrue;
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.internal.util.collections.ListUtil.Filter;
+import org.mockitoutil.TestBase;
 
 public class ListUtilTest extends TestBase {
 
     @Test
     public void shouldFilterList() throws Exception {
         List<String> list = asList("one", "x", "two", "x", "three");
-        List<String> filtered = ListUtil.filter(list, new Filter<String>() {
-            public boolean isOut(String object) {
-                return object == "x";
-            }
-        });
+        List<String> filtered =
+                ListUtil.filter(
+                        list,
+                        new Filter<String>() {
+                            public boolean isOut(String object) {
+                                return object == "x";
+                            }
+                        });
 
         Assertions.assertThat(filtered).containsSequence("one", "two", "three");
     }
diff --git a/src/test/java/org/mockito/internal/util/io/IOUtilTest.java b/src/test/java/org/mockito/internal/util/io/IOUtilTest.java
index 0aa16a1..24099f6 100644
--- a/src/test/java/org/mockito/internal/util/io/IOUtilTest.java
+++ b/src/test/java/org/mockito/internal/util/io/IOUtilTest.java
@@ -4,16 +4,17 @@
  */
 package org.mockito.internal.util.io;
 
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.assertEquals;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertEquals;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 public class IOUtilTest {
 
diff --git a/src/test/java/org/mockito/internal/util/reflection/AccessibilityChangerTest.java b/src/test/java/org/mockito/internal/util/reflection/AccessibilityChangerTest.java
deleted file mode 100644
index 88bf1cf..0000000
--- a/src/test/java/org/mockito/internal/util/reflection/AccessibilityChangerTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.internal.util.reflection;
-
-import org.junit.Test;
-
-import java.lang.reflect.Field;
-import java.util.Observable;
-
-import static org.mockitoutil.VmArgAssumptions.assumeVmArgPresent;
-
-public class AccessibilityChangerTest {
-
-    @SuppressWarnings("unused")
-    private Observable whatever;
-
-    @Test
-    public void should_enable_and_safely_disable() throws Exception {
-        AccessibilityChanger changer = new AccessibilityChanger();
-        changer.enableAccess(field("whatever"));
-        changer.safelyDisableAccess(field("whatever"));
-    }
-
-    @Test(expected = java.lang.AssertionError.class)
-    public void safelyDisableAccess_should_fail_when_enableAccess_not_called() throws Exception {
-        assumeVmArgPresent("-ea");
-        new AccessibilityChanger().safelyDisableAccess(field("whatever"));
-    }
-
-
-    private Field field(String fieldName) throws NoSuchFieldException {
-        return this.getClass().getDeclaredField(fieldName);
-    }
-
-}
diff --git a/src/test/java/org/mockito/internal/util/reflection/BeanPropertySetterTest.java b/src/test/java/org/mockito/internal/util/reflection/BeanPropertySetterTest.java
index a0b6119..66d25c2 100644
--- a/src/test/java/org/mockito/internal/util/reflection/BeanPropertySetterTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/BeanPropertySetterTest.java
@@ -4,16 +4,15 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.lang.reflect.Field;
 import java.util.UUID;
 
-import static org.junit.Assert.*;
-
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
 
 public class BeanPropertySetterTest {
 
@@ -34,7 +33,8 @@ public class BeanPropertySetterTest {
     }
 
     @Test
-    public void use_the_setter_on_the_target_when_field_name_begins_by_at_least_2_caps() throws Exception {
+    public void use_the_setter_on_the_target_when_field_name_begins_by_at_least_2_caps()
+            throws Exception {
         // given
         BeanWithWeirdFields someBean = new BeanWithWeirdFields();
         Field theField = someBean.getClass().getDeclaredField("UUID");
@@ -50,7 +50,8 @@ public class BeanPropertySetterTest {
     }
 
     @Test
-    public void should_not_fail_if_bean_class_declares_only_the_setter_for_the_property() throws Exception {
+    public void should_not_fail_if_bean_class_declares_only_the_setter_for_the_property()
+            throws Exception {
         // given
         SomeBeanWithJustASetter someBean = new SomeBeanWithJustASetter();
         Field theField = someBean.getClass().getDeclaredField("theField");
@@ -65,7 +66,8 @@ public class BeanPropertySetterTest {
     }
 
     @Test
-    public void should_fail_if_matching_setter_cannot_be_found_and_if_report_failure_is_true() throws Exception {
+    public void should_fail_if_matching_setter_cannot_be_found_and_if_report_failure_is_true()
+            throws Exception {
         // given
         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();
         Field theField = bean.getClass().getDeclaredField("theField");
@@ -96,7 +98,8 @@ public class BeanPropertySetterTest {
     }
 
     @Test
-    public void return_false_if_no_setter_was_found_and_if_reportNoSetterFound_is_false() throws Exception {
+    public void return_false_if_no_setter_was_found_and_if_reportNoSetterFound_is_false()
+            throws Exception {
         // given
         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();
         Field theField = bean.getClass().getDeclaredField("theField");
@@ -132,6 +135,7 @@ public class BeanPropertySetterTest {
             this.theField = theField;
         }
     }
+
     static class SomeBeanWithJustAGetter {
         private File theField;
 
@@ -158,5 +162,4 @@ public class BeanPropertySetterTest {
             this.UUID = UUID;
         }
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/DummyClassForTests.java b/src/test/java/org/mockito/internal/util/reflection/DummyClassForTests.java
index 17d71ad..51cb5f9 100644
--- a/src/test/java/org/mockito/internal/util/reflection/DummyClassForTests.java
+++ b/src/test/java/org/mockito/internal/util/reflection/DummyClassForTests.java
@@ -4,6 +4,4 @@
  */
 package org.mockito.internal.util.reflection;
 
-public class DummyClassForTests extends DummyParentClassForTests {
-
-}
+public class DummyClassForTests extends DummyParentClassForTests {}
diff --git a/src/test/java/org/mockito/internal/util/reflection/DummyParentClassForTests.java b/src/test/java/org/mockito/internal/util/reflection/DummyParentClassForTests.java
index 6967c02..a701dc9 100644
--- a/src/test/java/org/mockito/internal/util/reflection/DummyParentClassForTests.java
+++ b/src/test/java/org/mockito/internal/util/reflection/DummyParentClassForTests.java
@@ -6,6 +6,6 @@ package org.mockito.internal.util.reflection;
 
 public class DummyParentClassForTests {
 
-    @SuppressWarnings("unused")//I know, I know. We're doing nasty reflection hacks here...
+    @SuppressWarnings("unused") // I know, I know. We're doing nasty reflection hacks here...
     private String somePrivateField;
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/FieldInitializerTest.java b/src/test/java/org/mockito/internal/util/reflection/FieldInitializerTest.java
index 5d19011..3c9e489 100644
--- a/src/test/java/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -4,20 +4,24 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
-import org.mockito.InjectMocks;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-
-import static org.junit.Assert.*;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 
+import org.junit.Test;
+import org.mockito.InjectMocks;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 
 public class FieldInitializerTest {
 
@@ -31,13 +35,14 @@ public class FieldInitializerTest {
     private Interface interfaceType;
     private InnerClassType innerClassType;
     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
-    private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
+    private Interface instantiatedInterfaceType = new ConcreteStaticClass();
     private InnerClassType instantiatedInnerClassType = new InnerClassType();
 
     @Test
     public void should_keep_same_instance_if_field_initialized() throws Exception {
         final StaticClass backupInstance = alreadyInstantiated;
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
+        FieldInitializer fieldInitializer =
+                new FieldInitializer(this, field("alreadyInstantiated"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertSame(backupInstance, report.fieldInstance());
@@ -67,7 +72,8 @@ public class FieldInitializerTest {
 
     @Test
     public void should_instantiate_field_with_private_default_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
+        FieldInitializer fieldInitializer =
+                new FieldInitializer(this, field("privateDefaultConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
@@ -75,15 +81,25 @@ public class FieldInitializerTest {
         assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
-    @Test(expected = MockitoException.class)
+    @Test
     public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
-        fieldInitializer.initialize();
+        FieldInitializer fieldInitializer =
+                new FieldInitializer(this, field("noDefaultConstructor"));
+
+        assertThatThrownBy(
+                        () -> {
+                            fieldInitializer.initialize();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "the type 'StaticClassWithoutDefaultConstructor' has no default constructor");
     }
 
     @Test
-    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
+    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception()
+            throws Exception {
+        FieldInitializer fieldInitializer =
+                new FieldInitializer(this, field("throwingExDefaultConstructor"));
         try {
             fieldInitializer.initialize();
             fail();
@@ -94,9 +110,14 @@ public class FieldInitializerTest {
         }
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_abstract_field() throws Exception {
-        new FieldInitializer(this, field("abstractType"));
+    @Test
+    public void should_fail_for_abstract_field() {
+        assertThatThrownBy(
+                        () -> {
+                            new FieldInitializer(this, field("abstractType"));
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage("the type 'AbstractStaticClass' is an abstract class.");
     }
 
     @Test
@@ -104,9 +125,14 @@ public class FieldInitializerTest {
         new FieldInitializer(this, field("instantiatedAbstractType"));
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_interface_field() throws Exception {
-        new FieldInitializer(this, field("interfaceType"));
+    @Test
+    public void should_fail_for_interface_field() {
+        assertThatThrownBy(
+                        () -> {
+                            new FieldInitializer(this, field("interfaceType"));
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage("the type 'Interface' is an interface.");
     }
 
     @Test
@@ -114,10 +140,10 @@ public class FieldInitializerTest {
         new FieldInitializer(this, field("instantiatedInterfaceType"));
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_local_type_field() throws Exception {
-        // when
-        class LocalType { }
+    @Test
+    public void should_fail_for_local_type_field() {
+        // given
+        class LocalType {}
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field;
@@ -125,14 +151,21 @@ public class FieldInitializerTest {
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
-        // when
-        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            new FieldInitializer(
+                                    testWithLocalType,
+                                    testWithLocalType.getClass().getDeclaredField("field"));
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage("the type 'LocalType' is a local class.");
     }
 
     @Test
     public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
         // when
-        class LocalType { }
+        class LocalType {}
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field = new LocalType();
@@ -141,12 +174,18 @@ public class FieldInitializerTest {
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
-        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
+        new FieldInitializer(
+                testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_inner_class_field() throws Exception {
-        new FieldInitializer(this, field("innerClassType"));
+    @Test
+    public void should_fail_for_inner_class_field() {
+        assertThatThrownBy(
+                        () -> {
+                            new FieldInitializer(this, field("innerClassType"));
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage("the type 'InnerClassType' is an inner non static class.");
     }
 
     @Test
@@ -156,8 +195,12 @@ public class FieldInitializerTest {
 
     @Test
     public void can_instantiate_class_with_parameterized_constructor() throws Exception {
-        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class.class)))
-                        .willReturn(new Object[]{null}).getMock();
+        ConstructorArgumentResolver resolver =
+                given(
+                                mock(ConstructorArgumentResolver.class)
+                                        .resolveTypeInstances(any(Class.class)))
+                        .willReturn(new Object[] {null})
+                        .getMock();
 
         new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
 
@@ -168,40 +211,35 @@ public class FieldInitializerTest {
         return this.getClass().getDeclaredField(fieldName);
     }
 
-    static class StaticClass {
-    }
+    static class StaticClass {}
 
     static class StaticClassWithDefaultConstructor {
-        StaticClassWithDefaultConstructor() { }
+        StaticClassWithDefaultConstructor() {}
     }
 
     static class StaticClassWithPrivateDefaultConstructor {
-        private StaticClassWithPrivateDefaultConstructor() { }
+        private StaticClassWithPrivateDefaultConstructor() {}
     }
 
     static class StaticClassWithoutDefaultConstructor {
-        private StaticClassWithoutDefaultConstructor(String param) { }
+        private StaticClassWithoutDefaultConstructor(String param) {}
     }
 
     static class StaticClassThrowingExceptionDefaultConstructor {
-        StaticClassThrowingExceptionDefaultConstructor() throws Exception {
+        StaticClassThrowingExceptionDefaultConstructor() {
             throw new NullPointerException("business logic failed");
         }
     }
 
-    static abstract class AbstractStaticClass {
+    abstract static class AbstractStaticClass {
         public AbstractStaticClass() {}
     }
 
-    interface Interface {
-
-    }
+    interface Interface {}
 
-    static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
-    }
+    static class ConcreteStaticClass extends AbstractStaticClass implements Interface {}
 
     class InnerClassType {
-        InnerClassType() { }
+        InnerClassType() {}
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/FieldReaderTest.java b/src/test/java/org/mockito/internal/util/reflection/FieldReaderTest.java
index a7fa76e..2e9aeb8 100644
--- a/src/test/java/org/mockito/internal/util/reflection/FieldReaderTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/FieldReaderTest.java
@@ -4,12 +4,12 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 @SuppressWarnings("unused")
 public class FieldReaderTest extends TestBase {
 
@@ -20,17 +20,17 @@ public class FieldReaderTest extends TestBase {
 
     @Test
     public void shouldKnowWhenNull() throws Exception {
-        //when
+        // when
         FieldReader reader = new FieldReader(new Foo(), Foo.class.getDeclaredField("isNull"));
-        //then
+        // then
         assertTrue(reader.isNull());
     }
 
     @Test
     public void shouldKnowWhenNotNull() throws Exception {
-        //when
+        // when
         FieldReader reader = new FieldReader(new Foo(), Foo.class.getDeclaredField("notNull"));
-        //then
+        // then
         assertFalse(reader.isNull());
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java b/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java
index d86fb30..270cfae 100644
--- a/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java
@@ -4,69 +4,80 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.internal.util.reflection.Fields.syntheticField;
 
 import java.lang.reflect.Field;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.internal.util.reflection.Fields.syntheticField;
+import org.junit.Test;
 
 public class FieldsTest {
 
     @Test
     public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {
-        assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).filter(syntheticField()).names())
+        assertThat(
+                        Fields.allDeclaredFieldsOf(new HierarchyOfClasses())
+                                .filter(syntheticField())
+                                .names())
                 .containsOnly("a", "b", "static_a", "static_b");
     }
 
     @Test
     public void fields_should_return_declared_fields() throws Exception {
-        assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).filter(syntheticField()).names())
+        assertThat(
+                        Fields.declaredFieldsOf(new HierarchyOfClasses())
+                                .filter(syntheticField())
+                                .names())
                 .containsOnly("b", "static_b");
     }
 
     @Test
     public void can_filter_not_null_fields() throws Exception {
-        assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().filter(syntheticField()).names())
+        assertThat(
+                        Fields.declaredFieldsOf(new NullOrNotNullFields())
+                                .notNull()
+                                .filter(syntheticField())
+                                .names())
                 .containsOnly("c");
     }
 
     @Test
     public void can_get_values_of_instance_fields() throws Exception {
-        assertThat(Fields.declaredFieldsOf(new ValuedFields()).filter(syntheticField()).assignedValues())
+        assertThat(
+                        Fields.declaredFieldsOf(new ValuedFields())
+                                .filter(syntheticField())
+                                .assignedValues())
                 .containsOnly("a", "b");
     }
 
-
     @Test
     public void can_get_list_of_InstanceField() throws Exception {
         ValuedFields instance = new ValuedFields();
 
         assertThat(Fields.declaredFieldsOf(instance).filter(syntheticField()).instanceFields())
-                .containsOnly(new InstanceField(field("a", instance), instance),
-                              new InstanceField(field("b", instance), instance)
-                );
+                .containsOnly(
+                        new InstanceField(field("a", instance), instance),
+                        new InstanceField(field("b", instance), instance));
     }
 
     private Field field(String name, Object instance) throws NoSuchFieldException {
         return instance.getClass().getDeclaredField(name);
     }
 
-
     interface AnInterface {
         int someStaticInInterface = 0;
-
     }
+
     public static class ParentClass implements AnInterface {
         static int static_a;
         int a;
-
     }
+
     public static class HierarchyOfClasses extends ParentClass {
         static int static_b;
         int b = 1;
-
     }
+
     public static class NullOrNotNullFields {
         static Object static_b;
         Object b;
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericArrayReturnTypeTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericArrayReturnTypeTest.java
index 452536a..d5a7459 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericArrayReturnTypeTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericArrayReturnTypeTest.java
@@ -4,19 +4,19 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
-import org.mockito.Answers;
+import static org.mockito.Mockito.mock;
 
 import java.util.Set;
 
-import static org.mockito.Mockito.mock;
+import org.junit.Test;
+import org.mockito.Answers;
 
 public class GenericArrayReturnTypeTest {
 
     @Test
     public void toArrayTypedDoesNotWork() throws Exception {
         Container container = mock(Container.class, Answers.RETURNS_DEEP_STUBS);
-        container.getInnerContainer().getTheProblem().toArray(new String[]{});
+        container.getInnerContainer().getTheProblem().toArray(new String[] {});
     }
 
     class Container {
@@ -36,5 +36,4 @@ public class GenericArrayReturnTypeTest {
             return theProblem;
         }
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericMasterTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericMasterTest.java
index 4125e09..2e77d58 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericMasterTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericMasterTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 import java.util.*;
 
-import static org.junit.Assert.assertEquals;
+import org.junit.Test;
 
 public class GenericMasterTest {
 
@@ -24,16 +24,27 @@ public class GenericMasterTest {
     List<Set<Collection<String>>> multiNested;
 
     public interface ListSet extends List<Set<?>> {}
+
     public interface MapNumberString extends Map<Number, String> {}
+
     public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}
 
-    public List<Number> numberList() { return null; }
-    public Comparable<Number> numberComparable() { return null; }
-    @SuppressWarnings("rawtypes")
-    public List rawList() { return null; }
-    public List<? extends Type> typeList() { return null; }
+    public List<Number> numberList() {
+        return null;
+    }
 
+    public Comparable<Number> numberComparable() {
+        return null;
+    }
 
+    @SuppressWarnings("rawtypes")
+    public List rawList() {
+        return null;
+    }
+
+    public List<? extends Type> typeList() {
+        return null;
+    }
 
     @Test
     public void should_find_generic_class() throws Exception {
@@ -56,5 +67,4 @@ public class GenericMasterTest {
     private Field field(String fieldName) throws SecurityException, NoSuchFieldException {
         return this.getClass().getDeclaredField(fieldName);
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
index 323efbf..cb1d73a 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
@@ -4,59 +4,96 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;
+import org.junit.Test;
 
 public class GenericMetadataSupportTest {
 
     interface GenericsSelfReference<T extends GenericsSelfReference<T>> {
         T self();
     }
+
     interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {
         E get();
     }
+
     interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {
         E get();
     }
+
     interface ListOfNumbers extends List<Number> {}
+
     interface AnotherListOfNumbers extends ListOfNumbers {}
 
     abstract class ListOfNumbersImpl implements ListOfNumbers {}
+
     abstract class AnotherListOfNumbersImpl extends ListOfNumbersImpl {}
 
     interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
 
     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
         Set<Number> remove(Object key); // override with fixed ParameterizedType
+
         List<? super Integer> returning_wildcard_with_class_lower_bound();
+
         List<? super K> returning_wildcard_with_typeVar_lower_bound();
+
         List<? extends K> returning_wildcard_with_typeVar_upper_bound();
+
         K returningK();
+
         <O extends K> List<O> paramType_with_type_params();
+
         <S, T extends S> T two_type_params();
+
         <O extends K> O typeVar_with_type_params();
     }
 
-    static class StringList extends ArrayList<String> { }
+    static class StringList extends ArrayList<String> {}
+
+    public interface TopInterface<T> {
+        T generic();
+    }
+
+    public interface MiddleInterface<T> extends TopInterface<T> {}
+
+    public class OwningClassWithDeclaredUpperBounds<
+            T extends List<String> & Comparable<String> & Cloneable> {
+        public abstract class AbstractInner implements MiddleInterface<T> {}
+    }
+
+    public class OwningClassWithNoDeclaredUpperBounds<T> {
+        public abstract class AbstractInner implements MiddleInterface<T> {}
+    }
 
     @Test
     public void typeVariable_of_self_type() {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod("self", GenericsSelfReference.class));
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsSelfReference.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod("self", GenericsSelfReference.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);
     }
 
     @Test
-    public void can_get_raw_type_from_Class() throws Exception {
+    public void can_get_raw_type_from_Class() {
         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);
         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);
         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);
@@ -64,19 +101,32 @@ public class GenericMetadataSupportTest {
     }
 
     @Test
-    public void can_get_raw_type_from_ParameterizedType() throws Exception {
-        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);
-        assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);
-        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);
-        assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);
+    public void can_get_raw_type_from_ParameterizedType() {
+        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType())
+                .isEqualTo(List.class);
+        assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType())
+                .isEqualTo(List.class);
+        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType())
+                .isEqualTo(Map.class);
+        assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType())
+                .isEqualTo(ArrayList.class);
     }
 
     @Test
-    public void can_get_type_variables_from_Class() throws Exception {
-        assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
+    public void can_get_type_variables_from_Class() {
+        assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet())
+                .hasSize(1)
+                .extracting(TypeVariable::getName)
+                .contains("K");
         assertThat(inferFrom(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();
-        assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
-        assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
+        assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet())
+                .hasSize(1)
+                .extracting(TypeVariable::getName)
+                .contains("N");
+        assertThat(inferFrom(Map.class).actualTypeArguments().keySet())
+                .hasSize(2)
+                .extracting(TypeVariable::getName)
+                .contains("K", "V");
         assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();
         assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();
     }
@@ -84,122 +134,306 @@ public class GenericMetadataSupportTest {
     @Test
     public void can_resolve_type_variables_from_ancestors() throws Exception {
         Method listGet = List.class.getMethod("get", int.class);
-        assertThat(inferFrom(AnotherListOfNumbers.class).resolveGenericReturnType(listGet).rawType()).isEqualTo(Number.class);
-        assertThat(inferFrom(AnotherListOfNumbersImpl.class).resolveGenericReturnType(listGet).rawType()).isEqualTo(Number.class);
+        assertThat(
+                        inferFrom(AnotherListOfNumbers.class)
+                                .resolveGenericReturnType(listGet)
+                                .rawType())
+                .isEqualTo(Number.class);
+        assertThat(
+                        inferFrom(AnotherListOfNumbersImpl.class)
+                                .resolveGenericReturnType(listGet)
+                                .rawType())
+                .isEqualTo(Number.class);
     }
 
     @Test
-    public void can_get_type_variables_from_ParameterizedType() throws Exception {
-        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
-        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
-        assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
-        assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();
+    public void can_get_type_variables_from_ParameterizedType() {
+        assertThat(
+                        inferFrom(GenericsNest.class.getGenericInterfaces()[0])
+                                .actualTypeArguments()
+                                .keySet())
+                .hasSize(2)
+                .extracting(TypeVariable::getName)
+                .contains("K", "V");
+        assertThat(
+                        inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0])
+                                .actualTypeArguments()
+                                .keySet())
+                .hasSize(1)
+                .extracting(TypeVariable::getName)
+                .contains("E");
+        assertThat(
+                        inferFrom(Integer.class.getGenericInterfaces()[0])
+                                .actualTypeArguments()
+                                .keySet())
+                .hasSize(1)
+                .extracting(TypeVariable::getName)
+                .contains("T");
+        assertThat(
+                        inferFrom(StringBuilder.class.getGenericInterfaces()[0])
+                                .actualTypeArguments()
+                                .keySet())
+                .isEmpty();
         assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();
     }
 
     @Test
-    public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod("iterator", StringList.class));
+    public void
+            typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(StringList.class)
+                        .resolveGenericReturnType(firstNamedMethod("iterator", StringList.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);
         assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);
     }
 
     @Test
-    public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("get", GenericsNest.class));
+    public void
+            typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(firstNamedMethod("get", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);
         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);
     }
 
     @Test
-    public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returningK", GenericsNest.class));
+    public void
+            bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod("returningK", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);
-        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));
+        GenericMetadataSupport extraInterface_0 =
+                inferFrom(genericMetadata.extraInterfaces().get(0));
         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);
     }
 
     @Test
-    public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("remove", GenericsNest.class));
+    public void
+            fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(firstNamedMethod("remove", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);
         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);
     }
 
     @Test
-    public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("values", GenericsNest.class));
+    public void
+            paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(firstNamedMethod("values", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);
-        GenericMetadataSupport fromTypeVariableE = inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(), "E"));
+        GenericMetadataSupport fromTypeVariableE =
+                inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(), "E"));
         assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);
         assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);
     }
 
     @Test
-    public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("paramType_with_type_params", GenericsNest.class));
+    public void
+            paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod("paramType_with_type_params", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(List.class);
-        Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E")).firstBound();
+        Type firstBoundOfE =
+                ((GenericMetadataSupport.TypeVarBoundedType)
+                                typeVariableValue(genericMetadata.actualTypeArguments(), "E"))
+                        .firstBound();
         assertThat(inferFrom(firstBoundOfE).rawType()).isEqualTo(Comparable.class);
     }
 
     @Test
-    public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("typeVar_with_type_params", GenericsNest.class));
+    public void
+            typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod("typeVar_with_type_params", GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);
-        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));
+        GenericMetadataSupport extraInterface_0 =
+                inferFrom(genericMetadata.extraInterfaces().get(0));
         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);
     }
 
     @Test
-    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(StringBuilder.class).resolveGenericReturnType(firstNamedMethod("append", StringBuilder.class));
+    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(StringBuilder.class)
+                        .resolveGenericReturnType(firstNamedMethod("append", StringBuilder.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);
         assertThat(genericMetadata.actualTypeArguments()).isEmpty();
     }
 
-
-
     @Test
-    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound", GenericsNest.class));
+    public void
+            paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod(
+                                        "returning_wildcard_with_class_lower_bound",
+                                        GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(List.class);
-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
+        GenericMetadataSupport.BoundedType boundedType =
+                (GenericMetadataSupport.BoundedType)
+                        typeVariableValue(genericMetadata.actualTypeArguments(), "E");
         assertThat(boundedType.firstBound()).isEqualTo(Integer.class);
         assertThat(boundedType.interfaceBounds()).isEmpty();
     }
 
     @Test
-    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_lower_bound", GenericsNest.class));
+    public void
+            paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod(
+                                        "returning_wildcard_with_typeVar_lower_bound",
+                                        GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(List.class);
-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
+        GenericMetadataSupport.BoundedType boundedType =
+                (GenericMetadataSupport.BoundedType)
+                        typeVariableValue(genericMetadata.actualTypeArguments(), "E");
 
         assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);
-        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }
+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);
+    }
 
     @Test
-    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_upper_bound", GenericsNest.class));
+    public void
+            paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() {
+        GenericMetadataSupport genericMetadata =
+                inferFrom(GenericsNest.class)
+                        .resolveGenericReturnType(
+                                firstNamedMethod(
+                                        "returning_wildcard_with_typeVar_upper_bound",
+                                        GenericsNest.class));
 
         assertThat(genericMetadata.rawType()).isEqualTo(List.class);
-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
+        GenericMetadataSupport.BoundedType boundedType =
+                (GenericMetadataSupport.BoundedType)
+                        typeVariableValue(genericMetadata.actualTypeArguments(), "E");
 
         assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);
         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);
     }
 
-    private Type typeVariableValue(Map<TypeVariable<?>, Type> typeVariables, String typeVariableName) {
+    @Test
+    public void can_extract_raw_type_from_bounds_on_terminal_typeVariable() {
+        assertThat(
+                        inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                                .resolveGenericReturnType(
+                                        firstNamedMethod(
+                                                "generic",
+                                                OwningClassWithDeclaredUpperBounds.AbstractInner
+                                                        .class))
+                                .rawType())
+                .isEqualTo(List.class);
+        assertThat(
+                        inferFrom(OwningClassWithNoDeclaredUpperBounds.AbstractInner.class)
+                                .resolveGenericReturnType(
+                                        firstNamedMethod(
+                                                "generic",
+                                                OwningClassWithNoDeclaredUpperBounds.AbstractInner
+                                                        .class))
+                                .rawType())
+                .isEqualTo(Object.class);
+    }
+
+    @Test
+    public void can_extract_interface_type_from_bounds_on_terminal_typeVariable() {
+
+        assertThat(
+                        inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                                .resolveGenericReturnType(
+                                        firstNamedMethod(
+                                                "generic",
+                                                OwningClassWithDeclaredUpperBounds.AbstractInner
+                                                        .class))
+                                .rawExtraInterfaces())
+                .containsExactly(Comparable.class, Cloneable.class);
+        assertThat(
+                        inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                                .resolveGenericReturnType(
+                                        firstNamedMethod(
+                                                "generic",
+                                                OwningClassWithDeclaredUpperBounds.AbstractInner
+                                                        .class))
+                                .extraInterfaces())
+                .containsExactly(
+                        parameterizedTypeOf(Comparable.class, null, String.class), Cloneable.class);
+
+        assertThat(
+                        inferFrom(OwningClassWithNoDeclaredUpperBounds.AbstractInner.class)
+                                .resolveGenericReturnType(
+                                        firstNamedMethod(
+                                                "generic",
+                                                OwningClassWithNoDeclaredUpperBounds.AbstractInner
+                                                        .class))
+                                .extraInterfaces())
+                .isEmpty();
+    }
+
+    private ParameterizedType parameterizedTypeOf(
+            final Class<?> rawType, final Class<?> ownerType, final Type... actualTypeArguments) {
+        return new ParameterizedType() {
+            @Override
+            public Type[] getActualTypeArguments() {
+                return actualTypeArguments;
+            }
+
+            @Override
+            public Type getRawType() {
+                return rawType;
+            }
+
+            @Override
+            public Type getOwnerType() {
+                return ownerType;
+            }
+
+            @SuppressWarnings("EqualsHashCode")
+            public boolean equals(Object other) {
+                if (other instanceof ParameterizedType) {
+                    ParameterizedType otherParamType = (ParameterizedType) other;
+                    if (this == otherParamType) {
+                        return true;
+                    } else {
+                        return equals(ownerType, otherParamType.getOwnerType())
+                                && equals(rawType, otherParamType.getRawType())
+                                && Arrays.equals(
+                                        actualTypeArguments,
+                                        otherParamType.getActualTypeArguments());
+                    }
+                } else {
+                    return false;
+                }
+            }
+
+            private boolean equals(Object a, Object b) {
+                return (a == b) || (a != null && a.equals(b));
+            }
+        };
+    }
+
+    private Type typeVariableValue(
+            Map<TypeVariable<?>, Type> typeVariables, String typeVariableName) {
         for (Map.Entry<TypeVariable<?>, Type> typeVariableTypeEntry : typeVariables.entrySet()) {
             if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {
                 return typeVariableTypeEntry.getValue();
@@ -212,11 +446,18 @@ public class GenericMetadataSupportTest {
 
     private Method firstNamedMethod(String methodName, Class<?> clazz) {
         for (Method method : clazz.getMethods()) {
-            boolean protect_against_different_jdk_ordering_avoiding_bridge_methods = !method.isBridge();
-            if (method.getName().contains(methodName) && protect_against_different_jdk_ordering_avoiding_bridge_methods) {
+            boolean protect_against_different_jdk_ordering_avoiding_bridge_methods =
+                    !method.isBridge();
+            if (method.getName().contains(methodName)
+                    && protect_against_different_jdk_ordering_avoiding_bridge_methods) {
                 return method;
             }
         }
-        throw new IllegalStateException("The method : '" + methodName + "' do not exist in '" + clazz.getSimpleName() + "'");
+        throw new IllegalStateException(
+                "The method : '"
+                        + methodName
+                        + "' do not exist in '"
+                        + clazz.getSimpleName()
+                        + "'");
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericTypeExtractorTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericTypeExtractorTest.java
index c4e941c..94abf86 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericTypeExtractorTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericTypeExtractorTest.java
@@ -4,59 +4,87 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.internal.util.reflection.GenericTypeExtractor.genericTypeOf;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.internal.util.reflection.GenericTypeExtractor.genericTypeOf;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class GenericTypeExtractorTest extends TestBase {
 
     class Base<T> {}
+
     static class StaticBase<T> {}
+
     interface IBase<T> {}
+
     interface StaticIBase<T> {}
 
     class IntImpl extends Base<Integer> {}
+
     static class StaticIntImpl extends StaticBase<Integer> {}
+
     class NestedImpl extends Base<Base<String>> {}
+
     class NonGeneric extends Base {}
 
-    class IIntImpl implements IBase<Integer>{}
-    class INestedImpl implements IBase<IBase<String>>{}
+    class IIntImpl implements IBase<Integer> {}
+
+    class INestedImpl implements IBase<IBase<String>> {}
+
     class INonGeneric implements IBase {}
+
     class Mixed extends Base<Integer> implements IBase<String> {}
 
     class Deeper extends IntImpl implements Serializable {}
+
     class EvenDeeper extends Deeper implements Cloneable {}
+
     interface Iface extends IBase<Integer> {}
+
     interface IDeeper extends Serializable, Iface, Cloneable {}
 
     interface Crazy extends Serializable, IDeeper, Cloneable {}
+
     class Crazier extends EvenDeeper implements Crazy {}
 
-    @Test public void finds_generic_type() {
+    class SecondGeneric implements Serializable, IBase<Integer> {}
+
+    @Test
+    public void finds_generic_type() {
         assertEquals(Integer.class, genericTypeOf(IntImpl.class, Base.class, IBase.class));
-        assertEquals(Integer.class, genericTypeOf(StaticIntImpl.class, StaticBase.class, IBase.class));
+        assertEquals(
+                Integer.class, genericTypeOf(StaticIntImpl.class, StaticBase.class, IBase.class));
 
         assertEquals(Object.class, genericTypeOf(NestedImpl.class, Base.class, IBase.class));
         assertEquals(Object.class, genericTypeOf(NonGeneric.class, Base.class, IBase.class));
         assertEquals(Object.class, genericTypeOf(String.class, Base.class, IBase.class));
         assertEquals(Object.class, genericTypeOf(String.class, List.class, Map.class));
 
-        assertEquals(String.class, genericTypeOf(new Base<String>() {}.getClass(), Base.class, IBase.class));
-        assertEquals(String.class, genericTypeOf(new IBase<String>() {}.getClass(), Base.class, IBase.class));
-        assertEquals(String.class, genericTypeOf(new StaticBase<String>() {}.getClass(), StaticBase.class, IBase.class));
-        assertEquals(String.class, genericTypeOf(new StaticIBase<String>() {}.getClass(), Base.class, StaticIBase.class));
+        assertEquals(
+                String.class,
+                genericTypeOf(new Base<String>() {}.getClass(), Base.class, IBase.class));
+        assertEquals(
+                String.class,
+                genericTypeOf(new IBase<String>() {}.getClass(), Base.class, IBase.class));
+        assertEquals(
+                String.class,
+                genericTypeOf(
+                        new StaticBase<String>() {}.getClass(), StaticBase.class, IBase.class));
+        assertEquals(
+                String.class,
+                genericTypeOf(
+                        new StaticIBase<String>() {}.getClass(), Base.class, StaticIBase.class));
 
         assertEquals(Integer.class, genericTypeOf(Mixed.class, Base.class, IBase.class));
         assertEquals(Integer.class, genericTypeOf(IIntImpl.class, Base.class, IBase.class));
         assertEquals(Object.class, genericTypeOf(INestedImpl.class, Base.class, IBase.class));
-        assertEquals(Object.class, genericTypeOf(INonGeneric.class, IBase.class, INonGeneric.class));
+        assertEquals(
+                Object.class, genericTypeOf(INonGeneric.class, IBase.class, INonGeneric.class));
 
         assertEquals(Integer.class, genericTypeOf(Deeper.class, Base.class, IBase.class));
         assertEquals(Integer.class, genericTypeOf(EvenDeeper.class, Base.class, IBase.class));
@@ -64,5 +92,7 @@ public class GenericTypeExtractorTest extends TestBase {
         assertEquals(Integer.class, genericTypeOf(IDeeper.class, Base.class, IBase.class));
         assertEquals(Integer.class, genericTypeOf(Crazy.class, Base.class, IBase.class));
         assertEquals(Integer.class, genericTypeOf(Crazier.class, Base.class, IBase.class));
+
+        assertEquals(Integer.class, genericTypeOf(SecondGeneric.class, Base.class, IBase.class));
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/LenientCopyToolTest.java b/src/test/java/org/mockito/internal/util/reflection/LenientCopyToolTest.java
index 6a52161..310218a 100644
--- a/src/test/java/org/mockito/internal/util/reflection/LenientCopyToolTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/LenientCopyToolTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
 
 import java.lang.reflect.Field;
 import java.util.LinkedList;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
+import org.junit.Test;
+import org.mockito.plugins.MemberAccessor;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class LenientCopyToolTest extends TestBase {
@@ -29,6 +29,7 @@ public class LenientCopyToolTest extends TestBase {
         @SuppressWarnings("unused")
         // required because static fields needs to be excluded from copying
         private static int staticField = -100;
+
         private int privateField = -100;
         private transient int privateTransientField = -100;
         String defaultField = "-100";
@@ -41,8 +42,7 @@ public class LenientCopyToolTest extends TestBase {
         }
     }
 
-    public static class SomeOtherObject {
-    }
+    public static class SomeOtherObject {}
 
     private SomeObject from = new SomeObject(100);
     private SomeObject to = mock(SomeObject.class);
@@ -113,49 +113,37 @@ public class LenientCopyToolTest extends TestBase {
 
     @Test
     public void shouldCopyValuesOfInheritedFields() throws Exception {
-        //given
+        // given
         ((InheritMe) from).privateInherited = "foo";
         ((InheritMe) from).protectedInherited = "bar";
 
-        assertThat(((InheritMe) to).privateInherited).isNotEqualTo(((InheritMe) from).privateInherited);
+        assertThat(((InheritMe) to).privateInherited)
+                .isNotEqualTo(((InheritMe) from).privateInherited);
 
-        //when
+        // when
         tool.copyToMock(from, to);
 
-        //then
+        // then
         assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);
     }
 
-    @Test
-    public void shouldEnableAndThenDisableAccessibility() throws Exception {
-        //given
-        Field privateField = SomeObject.class.getDeclaredField("privateField");
-        assertFalse(privateField.isAccessible());
-
-        //when
-        tool.copyToMock(from, to);
-
-        //then
-        privateField = SomeObject.class.getDeclaredField("privateField");
-        assertFalse(privateField.isAccessible());
-    }
-
     @Test
     public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue() throws Exception {
-        //given
-        tool.fieldCopier = mock(FieldCopier.class);
+        // given
+        tool.accessor = mock(MemberAccessor.class);
 
-        doNothing().
-        doThrow(new IllegalAccessException()).
-        doNothing().
-        when(tool.fieldCopier).
-        copyValue(anyObject(), anyObject(), any(Field.class));
+        doNothing()
+                .doThrow(new IllegalStateException())
+                .doNothing()
+                .when(tool.accessor)
+                .set(any(Field.class), any(), any());
 
-        //when
+        // when
         tool.copyToMock(from, to);
 
-        //then
-        verify(tool.fieldCopier, atLeast(3)).copyValue(any(), any(), any(Field.class));
+        // then
+        verify(tool.accessor, atLeast(3)).get(any(Field.class), any());
+        verify(tool.accessor, atLeast(3)).set(any(Field.class), any(), any());
     }
 
     @Test
@@ -180,6 +168,5 @@ public class LenientCopyToolTest extends TestBase {
         assertEquals(from.privateTransientField, to.privateTransientField);
         assertEquals(from.protectedField, to.protectedField);
         assertEquals(from.protectedInherited, to.protectedInherited);
-
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/MemberAccessorTest.java b/src/test/java/org/mockito/internal/util/reflection/MemberAccessorTest.java
new file mode 100644
index 0000000..ee39031
--- /dev/null
+++ b/src/test/java/org/mockito/internal/util/reflection/MemberAccessorTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.reflection;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.mockito.plugins.MemberAccessor;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+@RunWith(Parameterized.class)
+public class MemberAccessorTest {
+
+    @Parameterized.Parameters
+    public static Collection<Object[]> data() {
+        List<Object[]> data = new ArrayList<>();
+        data.add(new Object[] {new ReflectionMemberAccessor()});
+        data.add(new Object[] {new ModuleMemberAccessor()});
+        return data;
+    }
+
+    private final MemberAccessor accessor;
+
+    public MemberAccessorTest(MemberAccessor accessor) {
+        this.accessor = accessor;
+    }
+
+    @Test
+    public void test_read_field() throws Exception {
+        assertThat(accessor.get(Sample.class.getDeclaredField("field"), new Sample("foo")))
+                .isEqualTo("foo");
+    }
+
+    @Test
+    public void test_read_static_field() throws Exception {
+        Sample.staticField = "foo";
+        assertThat(accessor.get(Sample.class.getDeclaredField("staticField"), null))
+                .isEqualTo("foo");
+    }
+
+    @Test
+    public void test_write_field() throws Exception {
+        Sample sample = new Sample("foo");
+        accessor.set(Sample.class.getDeclaredField("field"), sample, "bar");
+        assertThat(sample.field).isEqualTo("bar");
+    }
+
+    @Test
+    public void test_write_static_field() throws Exception {
+        Sample.staticField = "foo";
+        accessor.set(Sample.class.getDeclaredField("staticField"), null, "bar");
+        assertThat(Sample.staticField).isEqualTo("bar");
+    }
+
+    @Test
+    public void test_invoke() throws Exception {
+        assertThat(
+                        accessor.invoke(
+                                Sample.class.getDeclaredMethod("test", String.class),
+                                new Sample(null),
+                                "foo"))
+                .isEqualTo("foo");
+    }
+
+    @Test
+    public void test_invoke_invocation_exception() {
+        assertThatThrownBy(
+                        () ->
+                                accessor.invoke(
+                                        Sample.class.getDeclaredMethod("test", String.class),
+                                        new Sample(null),
+                                        "exception"))
+                .isInstanceOf(InvocationTargetException.class);
+    }
+
+    @Test
+    public void test_invoke_illegal_arguments() {
+        assertThatThrownBy(
+                        () ->
+                                accessor.invoke(
+                                        Sample.class.getDeclaredMethod("test", String.class),
+                                        new Sample(null),
+                                        42))
+                .isInstanceOf(IllegalArgumentException.class);
+    }
+
+    @Test
+    public void test_new_instance() throws Exception {
+        assertThat(accessor.newInstance(Sample.class.getDeclaredConstructor(String.class), "foo"))
+                .isInstanceOf(Sample.class);
+    }
+
+    @Test
+    public void test_new_instance_illegal_arguments() {
+        assertThatThrownBy(
+                        () ->
+                                accessor.newInstance(
+                                        Sample.class.getDeclaredConstructor(String.class), 42))
+                .isInstanceOf(IllegalArgumentException.class);
+    }
+
+    @Test
+    public void test_new_instance_invocation_exception() {
+        assertThatThrownBy(
+                        () ->
+                                accessor.newInstance(
+                                        Sample.class.getDeclaredConstructor(String.class),
+                                        "exception"))
+                .isInstanceOf(InvocationTargetException.class);
+    }
+
+    @Test
+    public void test_new_instance_instantiation_exception() {
+        assertThatThrownBy(
+                        () -> accessor.newInstance(AbstractSample.class.getDeclaredConstructor()))
+                .isInstanceOf(InstantiationException.class);
+    }
+
+    @Test
+    public void test_set_final_field() throws Exception {
+        Sample sample = new Sample("foo");
+        accessor.set(Sample.class.getDeclaredField("finalField"), sample, "foo");
+        assertThat(sample.finalField).isEqualTo("foo");
+    }
+
+    private static class Sample {
+
+        private String field;
+
+        private final String finalField = null;
+
+        private static String staticField = "foo";
+
+        public Sample(String field) {
+            if ("exception".equals(field)) {
+                throw new RuntimeException();
+            }
+            this.field = field;
+        }
+
+        private String test(String value) {
+            if ("exception".equals(value)) {
+                throw new RuntimeException();
+            }
+            return value;
+        }
+    }
+
+    private abstract static class AbstractSample {}
+}
diff --git a/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java b/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
index 6f3677a..9e63e8d 100644
--- a/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
@@ -2,33 +2,30 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.util.reflection;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.Map;
+import java.util.Observer;
+import java.util.Set;
 
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Matchers;
+import org.mockito.ArgumentMatchers;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 import org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.util.Map;
-import java.util.Observer;
-import java.util.Set;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
-
 @SuppressWarnings("unchecked")
 @RunWith(MockitoJUnitRunner.class)
 public class ParameterizedConstructorInstantiatorTest {
@@ -57,12 +54,18 @@ public class ParameterizedConstructorInstantiatorTest {
     }
 
     @Test
-    public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types() throws Exception {
+    public void
+            should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types()
+                    throws Exception {
         try {
-            new ParameterizedConstructorInstantiator(this, field("withNoArgConstructor"), resolver).instantiate();
+            new ParameterizedConstructorInstantiator(this, field("withNoArgConstructor"), resolver)
+                    .instantiate();
             fail();
         } catch (MockitoException me) {
-            assertThat(me.getMessage()).contains("no parameterized constructor").contains("withNoArgConstructor").contains("NoArgConstructor");
+            assertThat(me.getMessage())
+                    .contains("no parameterized constructor")
+                    .contains("withNoArgConstructor")
+                    .contains("NoArgConstructor");
         }
     }
 
@@ -70,9 +73,11 @@ public class ParameterizedConstructorInstantiatorTest {
     public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {
         Observer observer = mock(Observer.class);
         Map map = mock(Map.class);
-        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
+                .willReturn(new Object[] {observer, map});
 
-        new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver).instantiate();
+        new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver)
+                .instantiate();
 
         assertNotNull(withMultipleConstructor);
         assertNotNull(withMultipleConstructor.observer);
@@ -80,13 +85,17 @@ public class ParameterizedConstructorInstantiatorTest {
     }
 
     @Test
-    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {
+    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type()
+            throws Exception {
         Observer observer = mock(Observer.class);
         Set<?> wrongArg = mock(Set.class);
-        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
+                .willReturn(new Object[] {observer, wrongArg});
 
         try {
-            new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver).instantiate();
+            new ParameterizedConstructorInstantiator(
+                            this, field("withMultipleConstructor"), resolver)
+                    .instantiate();
             fail();
         } catch (MockitoException e) {
             assertThat(e.getMessage()).contains("argResolver").contains("incorrect types");
@@ -95,10 +104,13 @@ public class ParameterizedConstructorInstantiatorTest {
 
     @Test
     public void should_report_failure_if_constructor_throws_exception() throws Exception {
-        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
+                .willReturn(new Object[] {null});
 
         try {
-            new ParameterizedConstructorInstantiator(this, field("withThrowingConstructor"), resolver).instantiate();
+            new ParameterizedConstructorInstantiator(
+                            this, field("withThrowingConstructor"), resolver)
+                    .instantiate();
             fail();
         } catch (MockitoException e) {
             assertThat(e.getMessage()).contains("constructor").contains("raised an exception");
@@ -107,10 +119,12 @@ public class ParameterizedConstructorInstantiatorTest {
 
     @Test
     public void should_instantiate_type_with_vararg_constructor() throws Exception {
-        Observer[] vararg = new Observer[] {  };
-        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ "", vararg});
+        Observer[] vararg = new Observer[] {};
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
+                .willReturn(new Object[] {"", vararg});
 
-        new ParameterizedConstructorInstantiator(this, field("withVarargConstructor"), resolver).instantiate();
+        new ParameterizedConstructorInstantiator(this, field("withVarargConstructor"), resolver)
+                .instantiate();
 
         assertNotNull(withVarargConstructor);
     }
@@ -122,22 +136,27 @@ public class ParameterizedConstructorInstantiatorTest {
     }
 
     private static class NoArgConstructor {
-        NoArgConstructor() { }
+        NoArgConstructor() {}
     }
 
     private static class OneConstructor {
-        public OneConstructor(Observer observer) { }
+        public OneConstructor(Observer observer) {}
     }
 
     private static class ThrowingConstructor {
-        public ThrowingConstructor(Observer observer) throws IOException { throw new IOException(); }
+        public ThrowingConstructor(Observer observer) throws IOException {
+            throw new IOException();
+        }
     }
 
     private static class MultipleConstructor extends OneConstructor {
         Observer observer;
         Map map;
 
-        public MultipleConstructor(Observer observer) { this(observer, null); }
+        public MultipleConstructor(Observer observer) {
+            this(observer, null);
+        }
+
         public MultipleConstructor(Observer observer, Map map) {
             super(observer);
             this.observer = observer;
@@ -146,6 +165,6 @@ public class ParameterizedConstructorInstantiatorTest {
     }
 
     private static class VarargConstructor {
-        VarargConstructor(String whatever, Observer... observers) { }
+        VarargConstructor(String whatever, Observer... observers) {}
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/SuperTypesLastSorterTest.java b/src/test/java/org/mockito/internal/util/reflection/SuperTypesLastSorterTest.java
index e610cdf..ea50b4e 100644
--- a/src/test/java/org/mockito/internal/util/reflection/SuperTypesLastSorterTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/SuperTypesLastSorterTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockito.internal.util.reflection;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.internal.util.reflection.SuperTypesLastSorter.sortSuperTypesLast;
 
 import java.lang.reflect.Field;
 import java.util.*;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.internal.util.reflection.SuperTypesLastSorter.sortSuperTypesLast;
+import org.junit.Test;
 
 @SuppressWarnings("unused")
 public class SuperTypesLastSorterTest {
@@ -18,21 +18,22 @@ public class SuperTypesLastSorterTest {
      * A Comparator that behaves like the old one, so the existing tests
      * continue to work.
      */
-    private static Comparator<Field> cmp = new Comparator<Field>() {
-        public int compare(Field o1, Field o2) {
-            if (o1.equals(o2)) {
-                return 0;
-            }
-
-            List<Field> l = sortSuperTypesLast(Arrays.asList(o1, o2));
-
-            if (l.get(0) == o1) {
-                return -1;
-            } else {
-                return 1;
-            }
-        }
-    };
+    private static Comparator<Field> cmp =
+            new Comparator<Field>() {
+                public int compare(Field o1, Field o2) {
+                    if (o1.equals(o2)) {
+                        return 0;
+                    }
+
+                    List<Field> l = sortSuperTypesLast(Arrays.asList(o1, o2));
+
+                    if (l.get(0) == o1) {
+                        return -1;
+                    } else {
+                        return 1;
+                    }
+                }
+            };
 
     private Object objectA;
     private Object objectB;
@@ -49,7 +50,6 @@ public class SuperTypesLastSorterTest {
     private Iterable<?> yIterable;
     private Integer zInteger;
 
-
     @Test
     public void when_same_type_the_order_is_based_on_field_name() throws Exception {
         assertThat(cmp.compare(field("objectA"), field("objectB"))).isEqualTo(-1);
@@ -65,50 +65,45 @@ public class SuperTypesLastSorterTest {
 
     @Test
     public void using_Collections_dot_sort() throws Exception {
-        List<Field> unsortedFields = Arrays.asList(
-                field("objectB"),
-                field("integerB"),
-                field("numberA"),
-                field("numberB"),
-                field("objectA"),
-                field("integerA")
-        );
-
-        List<Field> sortedFields =  sortSuperTypesLast(unsortedFields);
-
-        assertThat(sortedFields).containsSequence(
-                field("integerA"),
-                field("integerB"),
-                field("numberA"),
-                field("numberB"),
-                field("objectA"),
-                field("objectB")
-        );
+        List<Field> unsortedFields =
+                Arrays.asList(
+                        field("objectB"),
+                        field("integerB"),
+                        field("numberA"),
+                        field("numberB"),
+                        field("objectA"),
+                        field("integerA"));
+
+        List<Field> sortedFields = sortSuperTypesLast(unsortedFields);
+
+        assertThat(sortedFields)
+                .containsSequence(
+                        field("integerA"),
+                        field("integerB"),
+                        field("numberA"),
+                        field("numberB"),
+                        field("objectA"),
+                        field("objectB"));
     }
 
-
     @Test
     public void issue_352_order_was_different_between_JDK6_and_JDK7() throws Exception {
-        List<Field> unsortedFields = Arrays.asList(
-                field("objectB"),
-                field("objectA")
-        );
+        List<Field> unsortedFields = Arrays.asList(field("objectB"), field("objectA"));
 
         Collections.sort(unsortedFields, cmp);
 
-        assertThat(unsortedFields).containsSequence(
-                field("objectA"),
-                field("objectB")
-        );
+        assertThat(unsortedFields).containsSequence(field("objectA"), field("objectB"));
     }
 
     @Test
-    public void fields_sort_consistently_when_interfaces_are_included() throws NoSuchFieldException {
+    public void fields_sort_consistently_when_interfaces_are_included()
+            throws NoSuchFieldException {
         assertSortConsistently(field("iterableA"), field("numberA"), field("integerA"));
     }
 
     @Test
-    public void fields_sort_consistently_when_names_and_type_indicate_different_order() throws NoSuchFieldException {
+    public void fields_sort_consistently_when_names_and_type_indicate_different_order()
+            throws NoSuchFieldException {
         assertSortConsistently(field("xNumber"), field("yIterable"), field("zInteger"));
     }
 
@@ -118,12 +113,12 @@ public class SuperTypesLastSorterTest {
      */
     private static void assertSortConsistently(Field a, Field b, Field c) {
         Field[][] initialOrderings = {
-                {a, b, c},
-                {a, c, b},
-                {b, a, c},
-                {b, c, a},
-                {c, a, b},
-                {c, b, a}
+            {a, b, c},
+            {a, c, b},
+            {b, a, c},
+            {b, c, a},
+            {c, a, b},
+            {c, b, a}
         };
 
         Set<List<Field>> results = new HashSet<List<Field>>();
diff --git a/src/test/java/org/mockito/internal/verification/DefaultRegisteredInvocationsTest.java b/src/test/java/org/mockito/internal/verification/DefaultRegisteredInvocationsTest.java
index b5738d5..a870245 100644
--- a/src/test/java/org/mockito/internal/verification/DefaultRegisteredInvocationsTest.java
+++ b/src/test/java/org/mockito/internal/verification/DefaultRegisteredInvocationsTest.java
@@ -2,18 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.invocation.Invocation;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 public class DefaultRegisteredInvocationsTest extends TestBase {
 
     private DefaultRegisteredInvocations invocations;
diff --git a/src/test/java/org/mockito/internal/verification/DescriptionTest.java b/src/test/java/org/mockito/internal/verification/DescriptionTest.java
index 3c0fa78..abf81cb 100644
--- a/src/test/java/org/mockito/internal/verification/DescriptionTest.java
+++ b/src/test/java/org/mockito/internal/verification/DescriptionTest.java
@@ -4,6 +4,12 @@
  */
 package org.mockito.internal.verification;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.openMocks;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -11,23 +17,15 @@ import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.verification.VerificationMode;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.verify;
-import static org.mockito.MockitoAnnotations.initMocks;
-
 public class DescriptionTest {
 
-    @Mock
-    private VerificationMode mockVerificationMode;
+    @Mock private VerificationMode mockVerificationMode;
 
-    @Mock
-    private VerificationData mockVerificationData;
+    @Mock private VerificationData mockVerificationData;
 
     @Before
     public void setUp() {
-        initMocks(this);
+        openMocks(this);
     }
 
     /**
@@ -53,4 +51,28 @@ public class DescriptionTest {
             assertEquals(expectedResult, e.getMessage());
         }
     }
+
+    /**
+     * Test of verify method, of class Description. This test validates that the custom message is prepended to the
+     * error message when verification fails and throws a Throwable which is not a MockitoAssertionError.
+     */
+    @Test
+    public void verification_failure_throwing_AssertionError_should_prepend_expected_message() {
+        String failureMessage = "message should be prepended to the original message";
+        String exceptionMessage = "original error message";
+        String expectedResult = failureMessage + "\n" + exceptionMessage;
+        AssertionError error = new AssertionError(exceptionMessage);
+        doThrow(error).when(mockVerificationMode).verify(mockVerificationData);
+
+        Description instance = new Description(mockVerificationMode, failureMessage);
+
+        try {
+            instance.verify(mockVerificationData);
+            verify(mockVerificationMode).verify(mockVerificationData);
+            fail("Should not have made it this far");
+
+        } catch (MockitoAssertionError e) {
+            assertEquals(expectedResult, e.getMessage());
+        }
+    }
 }
diff --git a/src/test/java/org/mockito/internal/verification/DummyVerificationMode.java b/src/test/java/org/mockito/internal/verification/DummyVerificationMode.java
index db86511..6b5f4c0 100644
--- a/src/test/java/org/mockito/internal/verification/DummyVerificationMode.java
+++ b/src/test/java/org/mockito/internal/verification/DummyVerificationMode.java
@@ -8,10 +8,14 @@ import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.verification.VerificationMode;
 
 public class DummyVerificationMode implements VerificationMode {
-    public void verify(VerificationData data) {
-    }
+    public void verify(VerificationData data) {}
 
     public VerificationMode description(String description) {
         return new DummyVerificationMode();
     }
+
+    @Override
+    public String toString() {
+        return "Dummy verification mode";
+    }
 }
diff --git a/src/test/java/org/mockito/internal/verification/NoInteractionsTest.java b/src/test/java/org/mockito/internal/verification/NoInteractionsTest.java
new file mode 100644
index 0000000..7c628cd
--- /dev/null
+++ b/src/test/java/org/mockito/internal/verification/NoInteractionsTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.verification;
+
+import static junit.framework.TestCase.fail;
+import static org.mockito.Mockito.mock;
+
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.internal.creation.MockSettingsImpl;
+import org.mockito.internal.invocation.InvocationBuilder;
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.internal.stubbing.InvocationContainerImpl;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
+public class NoInteractionsTest extends TestBase {
+
+    @Test
+    public void noInteractionsExceptionMessageShouldDescribeMock() {
+        // given
+        NoInteractions n = new NoInteractions();
+        IMethods mock = mock(IMethods.class, "a mock");
+        InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
+
+        InvocationContainerImpl invocations = new InvocationContainerImpl(new MockSettingsImpl());
+        invocations.setInvocationForPotentialStubbing(i);
+
+        try {
+            // when
+            n.verify(new VerificationDataImpl(invocations, null));
+            // then
+            fail();
+        } catch (NoInteractionsWanted e) {
+            Assertions.assertThat(e.toString()).contains(mock.toString());
+        }
+    }
+}
diff --git a/src/test/java/org/mockito/internal/verification/NoMoreInteractionsTest.java b/src/test/java/org/mockito/internal/verification/NoMoreInteractionsTest.java
index 19455de..e75898f 100644
--- a/src/test/java/org/mockito/internal/verification/NoMoreInteractionsTest.java
+++ b/src/test/java/org/mockito/internal/verification/NoMoreInteractionsTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal.verification;
 
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.mock;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
@@ -17,85 +22,82 @@ import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static java.util.Arrays.asList;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.mock;
-
 public class NoMoreInteractionsTest extends TestBase {
 
     InOrderContextImpl context = new InOrderContextImpl();
 
     @Test
     public void shouldVerifyInOrder() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         Invocation i = new InvocationBuilder().toInvocation();
         assertFalse(context.isVerified(i));
 
         try {
-            //when
+            // when
             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
-            //then
+            // then
             fail();
-        } catch(VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
     public void shouldVerifyInOrderAndPass() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         Invocation i = new InvocationBuilder().toInvocation();
         context.markVerified(i);
         assertTrue(context.isVerified(i));
 
-        //when
+        // when
         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
-        //then no exception is thrown
+        // then no exception is thrown
     }
 
     @Test
     public void shouldVerifyInOrderMultipleInvoctions() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         Invocation i = new InvocationBuilder().seq(1).toInvocation();
         Invocation i2 = new InvocationBuilder().seq(2).toInvocation();
 
-        //when
+        // when
         context.markVerified(i2);
 
-        //then no exception is thrown
+        // then no exception is thrown
         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));
     }
 
     @Test
     public void shouldVerifyInOrderMultipleInvoctionsAndThrow() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         Invocation i = new InvocationBuilder().seq(1).toInvocation();
         Invocation i2 = new InvocationBuilder().seq(2).toInvocation();
 
         try {
-            //when
+            // when
             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
     public void noMoreInteractionsExceptionMessageShouldDescribeMock() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         IMethods mock = mock(IMethods.class, "a mock");
         InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
 
-        InvocationContainerImpl invocations =
-            new InvocationContainerImpl( new MockSettingsImpl());
+        InvocationContainerImpl invocations = new InvocationContainerImpl(new MockSettingsImpl());
         invocations.setInvocationForPotentialStubbing(i);
 
         try {
-            //when
+            // when
             n.verify(new VerificationDataImpl(invocations, null));
-            //then
+            // then
             fail();
         } catch (NoInteractionsWanted e) {
             Assertions.assertThat(e.toString()).contains(mock.toString());
@@ -104,15 +106,15 @@ public class NoMoreInteractionsTest extends TestBase {
 
     @Test
     public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock() {
-        //given
+        // given
         NoMoreInteractions n = new NoMoreInteractions();
         IMethods mock = mock(IMethods.class, "a mock");
         Invocation i = new InvocationBuilder().mock(mock).toInvocation();
 
         try {
-            //when
+            // when
             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
-            //then
+            // then
             fail();
         } catch (VerificationInOrderFailure e) {
             Assertions.assertThat(e.toString()).contains(mock.toString());
diff --git a/src/test/java/org/mockito/internal/verification/OnlyTest.java b/src/test/java/org/mockito/internal/verification/OnlyTest.java
index 13df278..c269e3b 100644
--- a/src/test/java/org/mockito/internal/verification/OnlyTest.java
+++ b/src/test/java/org/mockito/internal/verification/OnlyTest.java
@@ -4,18 +4,18 @@
  */
 package org.mockito.internal.verification;
 
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.invocation.Invocation;
-
-import java.util.Arrays;
-import java.util.List;
-
-import static org.junit.Assert.*;
+import org.mockito.invocation.MatchableInvocation;
 
 public class OnlyTest {
 
@@ -46,30 +46,33 @@ public class OnlyTest {
 
     @Test
     public void shouldMarkAsVerified() {
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().toInvocation();
         assertFalse(invocation.isVerified());
 
-        //when
+        // when
         only.verify(new VerificationDataStub(new InvocationMatcher(invocation), invocation));
 
-        //then
+        // then
         assertTrue(invocation.isVerified());
     }
 
     @Test
     public void shouldNotMarkAsVerifiedWhenAssertionFailed() {
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().toInvocation();
         assertFalse(invocation.isVerified());
 
-        //when
+        // when
         try {
-            only.verify(new VerificationDataStub(new InvocationBuilder().toInvocationMatcher(), invocation));
+            only.verify(
+                    new VerificationDataStub(
+                            new InvocationBuilder().toInvocationMatcher(), invocation));
             fail();
-        } catch (MockitoAssertionError e) {}
+        } catch (MockitoAssertionError e) {
+        }
 
-        //then
+        // then
         assertFalse(invocation.isVerified());
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/SmartPrinterTest.java b/src/test/java/org/mockito/internal/verification/SmartPrinterTest.java
index 4918991..645cb29 100644
--- a/src/test/java/org/mockito/internal/verification/SmartPrinterTest.java
+++ b/src/test/java/org/mockito/internal/verification/SmartPrinterTest.java
@@ -22,7 +22,10 @@ public class SmartPrinterTest extends TestBase {
 
     @Before
     public void setup() throws Exception {
-        mock.varargs("first very long argument", "second very long argument", "another very long argument");
+        mock.varargs(
+                "first very long argument",
+                "second very long argument",
+                "another very long argument");
         multi = new InvocationMatcher(getLastInvocation());
 
         mock.varargs("short arg");
@@ -31,41 +34,49 @@ public class SmartPrinterTest extends TestBase {
 
     @Test
     public void shouldPrintBothInMultilinesWhenFirstIsMulti() {
-        //when
+        // when
         SmartPrinter printer = new SmartPrinter(multi, shortie.getInvocation());
 
-        //then
+        // then
         assertThat(printer.getWanted()).contains("\n");
-        assertThat(printer.getActual()).contains("\n");
+        for (String actual : printer.getActuals()) {
+            assertThat(actual).contains("\n");
+        }
     }
 
     @Test
     public void shouldPrintBothInMultilinesWhenSecondIsMulti() {
-        //when
+        // when
         SmartPrinter printer = new SmartPrinter(shortie, multi.getInvocation());
 
-        //then
+        // then
         assertThat(printer.getWanted()).contains("\n");
-        assertThat(printer.getActual()).contains("\n");
+        for (String actual : printer.getActuals()) {
+            assertThat(actual).contains("\n");
+        }
     }
 
     @Test
     public void shouldPrintBothInMultilinesWhenBothAreMulti() {
-        //when
+        // when
         SmartPrinter printer = new SmartPrinter(multi, multi.getInvocation());
 
-        //then
+        // then
         assertThat(printer.getWanted()).contains("\n");
-        assertThat(printer.getActual()).contains("\n");
+        for (String actual : printer.getActuals()) {
+            assertThat(actual).contains("\n");
+        }
     }
 
     @Test
     public void shouldPrintBothInSingleLineWhenBothAreShort() {
-        //when
+        // when
         SmartPrinter printer = new SmartPrinter(shortie, shortie.getInvocation());
 
-        //then
+        // then
         assertThat(printer.getWanted()).doesNotContain("\n");
-        assertThat(printer.getActual()).doesNotContain("\n");
+        for (String actual : printer.getActuals()) {
+            assertThat(actual).doesNotContain("\n");
+        }
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/VerificationDataImplTest.java b/src/test/java/org/mockito/internal/verification/VerificationDataImplTest.java
index 9d4ee1f..2364102 100644
--- a/src/test/java/org/mockito/internal/verification/VerificationDataImplTest.java
+++ b/src/test/java/org/mockito/internal/verification/VerificationDataImplTest.java
@@ -4,22 +4,24 @@
  */
 package org.mockito.internal.verification;
 
+import static org.junit.Assert.fail;
+
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-
 public class VerificationDataImplTest extends TestBase {
 
     @Test
     public void shouldToStringBeNotVerifiable() throws Exception {
-        InvocationMatcher toString = new InvocationBuilder().method("toString").toInvocationMatcher();
+        InvocationMatcher toString =
+                new InvocationBuilder().method("toString").toInvocationMatcher();
         try {
             new VerificationDataImpl(null, toString);
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/VerificationOverTimeImplTest.java b/src/test/java/org/mockito/internal/verification/VerificationOverTimeImplTest.java
index e846216..cc214b7 100644
--- a/src/test/java/org/mockito/internal/verification/VerificationOverTimeImplTest.java
+++ b/src/test/java/org/mockito/internal/verification/VerificationOverTimeImplTest.java
@@ -4,31 +4,25 @@
  */
 package org.mockito.internal.verification;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.openMocks;
+
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoAssertionError;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockito.verification.VerificationMode;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.verify;
-import static org.mockito.MockitoAnnotations.initMocks;
-
 public class VerificationOverTimeImplTest {
-    @Mock
-    private VerificationMode delegate;
+    @Mock private VerificationMode delegate;
     private VerificationOverTimeImpl impl;
 
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
     @Before
     public void setUp() {
-        initMocks(this);
+        openMocks(this);
         impl = new VerificationOverTimeImpl(10, 1000, delegate, true);
     }
 
@@ -41,28 +35,36 @@ public class VerificationOverTimeImplTest {
     @Test
     public void should_throw_mockito_assertion_error() {
         MockitoAssertionError toBeThrown = new MockitoAssertionError("message");
-        exception.expect(is(toBeThrown));
 
         doThrow(toBeThrown).when(delegate).verify(null);
-        impl.verify(null);
+        assertThatThrownBy(
+                        () -> {
+                            impl.verify(null);
+                        })
+                .isEqualTo(toBeThrown);
     }
 
     @Test
     public void should_deal_with_junit_assertion_error() {
         ArgumentsAreDifferent toBeThrown = new ArgumentsAreDifferent("message", "wanted", "actual");
-        exception.expect(is(toBeThrown));
-        exception.expectMessage("message");
 
         doThrow(toBeThrown).when(delegate).verify(null);
-        impl.verify(null);
+        assertThatThrownBy(
+                        () -> {
+                            impl.verify(null);
+                        })
+                .isEqualTo(toBeThrown);
     }
 
     @Test
     public void should_not_wrap_other_exceptions() {
         RuntimeException toBeThrown = new RuntimeException();
-        exception.expect(is(toBeThrown));
 
         doThrow(toBeThrown).when(delegate).verify(null);
-        impl.verify(null);
+        assertThatThrownBy(
+                        () -> {
+                            impl.verify(null);
+                        })
+                .isEqualTo(toBeThrown);
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/VerificationWithDescriptionTest.java b/src/test/java/org/mockito/internal/verification/VerificationWithDescriptionTest.java
index 0d206aa..36c7aac 100644
--- a/src/test/java/org/mockito/internal/verification/VerificationWithDescriptionTest.java
+++ b/src/test/java/org/mockito/internal/verification/VerificationWithDescriptionTest.java
@@ -4,27 +4,26 @@
  */
 package org.mockito.internal.verification;
 
+import static org.assertj.core.api.Assertions.fail;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.description;
+import static org.mockito.Mockito.verify;
+
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.mockito.exceptions.base.MockitoAssertionError;
 
-import java.util.List;
-
-import static org.junit.Assert.assertTrue;
-import static org.assertj.core.api.Assertions.fail;
-import static org.mockito.Mockito.description;
-import static org.mockito.Mockito.verify;
-
 public class VerificationWithDescriptionTest {
 
-    @Mock
-    private List<?> mock;
+    @Mock private List<?> mock;
 
     @Before
     public void setUp() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test
diff --git a/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java b/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
index 33bfbde..5f55faf 100644
--- a/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
+++ b/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
@@ -4,19 +4,20 @@
  */
 package org.mockito.internal.verification.argumentmatching;
 
+import static java.util.Collections.singletonList;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.Arrays;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.ContainsExtraTypeInfo;
 import org.mockito.internal.matchers.Equals;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-import java.util.List;
-
-import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
-
-@SuppressWarnings({ "unchecked", "serial" })
+@SuppressWarnings({"unchecked", "serial"})
 public class ArgumentMatchingToolTest extends TestBase {
 
     @Test
@@ -25,7 +26,9 @@ public class ArgumentMatchingToolTest extends TestBase {
         List<ArgumentMatcher> matchers = (List) Arrays.asList(new Equals(1));
 
         // when
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, 20 });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        matchers, new Object[] {10, 20});
 
         // then
         assertEquals(0, suspicious.length);
@@ -37,7 +40,9 @@ public class ArgumentMatchingToolTest extends TestBase {
         List<ArgumentMatcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));
 
         // when
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, 20 });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        matchers, new Object[] {10, 20});
 
         // then
         assertEquals(0, suspicious.length);
@@ -51,7 +56,9 @@ public class ArgumentMatchingToolTest extends TestBase {
 
         // when
         List<ArgumentMatcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, longPretendingAnInt });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        matchers, new Object[] {10, longPretendingAnInt});
 
         // then
         assertEquals(1, suspicious.length);
@@ -61,15 +68,18 @@ public class ArgumentMatchingToolTest extends TestBase {
     @Test
     public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame() {
         // given
-        Equals matcherWithBadDescription = new Equals(20) {
-            public String toString() {
-                return "10";
-            }
-        };
+        Equals matcherWithBadDescription =
+                new Equals(20) {
+                    public String toString() {
+                        return "10";
+                    }
+                };
         Integer argument = 10;
 
         // when
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(matcherWithBadDescription), new Object[] { argument });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        (List) Arrays.asList(matcherWithBadDescription), new Object[] {argument});
 
         // then
         assertEquals(0, suspicious.length);
@@ -78,7 +88,9 @@ public class ArgumentMatchingToolTest extends TestBase {
     @Test
     public void shouldWorkFineWhenGivenArgIsNull() {
         // when
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] { null });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        (List) Arrays.asList(new Equals(20)), new Object[] {null});
 
         // then
         assertEquals(0, suspicious.length);
@@ -87,8 +99,10 @@ public class ArgumentMatchingToolTest extends TestBase {
     @Test
     @SuppressWarnings("rawtypes")
     public void shouldUseMatchersSafely() {
-        // This matcher is evil cause typeMatches(Object) returns true for every passed type but matches(T)
-        // method accepts only Strings. When a Integer is passed (thru the matches(Object) bridge method )  a
+        // This matcher is evil cause typeMatches(Object) returns true for every passed type but
+        // matches(T)
+        // method accepts only Strings. When a Integer is passed (thru the matches(Object) bridge
+        // method )  a
         // ClassCastException will be thrown.
         class StringMatcher implements ArgumentMatcher<String>, ContainsExtraTypeInfo {
             @Override
@@ -97,7 +111,7 @@ public class ArgumentMatchingToolTest extends TestBase {
             }
 
             @Override
-            public String toStringWithType() {
+            public String toStringWithType(String className) {
                 return "";
             }
 
@@ -105,16 +119,22 @@ public class ArgumentMatchingToolTest extends TestBase {
             public boolean typeMatches(Object target) {
                 return true;
             }
+
+            @Override
+            public Object getWanted() {
+                return "";
+            }
         }
 
         // given
         List<ArgumentMatcher> matchers = (List) singletonList(new StringMatcher());
 
         // when
-        Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10 });
+        Integer[] suspicious =
+                ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(
+                        matchers, new Object[] {10});
 
         // then
         assertEquals(0, suspicious.length);
     }
-
 }
diff --git a/src/test/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java
index c4a54c4..3087003 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java
@@ -4,10 +4,13 @@
  */
 package org.mockito.internal.verification.checkers;
 
-import org.junit.Rule;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker.checkAtLeastNumberOfInvocations;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
@@ -15,72 +18,73 @@ import org.mockito.internal.verification.InOrderContextImpl;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker.checkAtLeastNumberOfInvocations;
-
-public class AtLeastXNumberOfInvocationsCheckerTest   {
-
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
+public class AtLeastXNumberOfInvocationsCheckerTest {
 
     @Test
     public void shouldMarkActualInvocationsAsVerifiedInOrder() {
         InOrderContext context = new InOrderContextImpl();
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
         Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
 
-        //when
-        checkAtLeastNumberOfInvocations(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1, context);
+        // when
+        checkAtLeastNumberOfInvocations(
+                asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1, context);
 
-        //then
+        // then
         assertThat(invocation.isVerified()).isTrue();
     }
 
     @Test
-    public void shouldReportTooLittleInvocationsInOrder() {
+    public void shouldReportTooFewInvocationsInOrder() {
         InOrderContext context = new InOrderContextImpl();
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
         Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
 
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("iMethods.simpleMethod()");
-        exception.expectMessage("Wanted *at least* 2 times");
-        exception.expectMessage("But was 1 time");
-
-        //when
-        checkAtLeastNumberOfInvocations(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 2, context);
-
-
+        // when
+        assertThatThrownBy(
+                        () ->
+                                checkAtLeastNumberOfInvocations(
+                                        asList(invocation, invocationTwo),
+                                        new InvocationMatcher(invocation),
+                                        2,
+                                        context))
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "iMethods.simpleMethod();", "Wanted *at least* 2 times", "But was 1 time");
     }
 
     @Test
     public void shouldMarkActualInvocationsAsVerified() {
-        //given
+        // given
         Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
         Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
 
-        //when
-        checkAtLeastNumberOfInvocations(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);
+        // when
+        checkAtLeastNumberOfInvocations(
+                asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);
 
-        //then
+        // then
         assertThat(invocation.isVerified()).isTrue();
     }
 
     @Test
-    public void shouldReportTooLittleInvocations() {
-        //given
+    public void shouldReportTooFewInvocations() {
+        // given
         Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
         Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
 
-        exception.expect(TooLittleActualInvocations.class);
-        exception.expectMessage("iMethods.simpleMethod()");
-        exception.expectMessage("Wanted *at least* 2 times");
-        exception.expectMessage("But was 1 time");
-
-        //when
-        checkAtLeastNumberOfInvocations(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 2);
+        // when
+        assertThatThrownBy(
+                        () -> {
+                            checkAtLeastNumberOfInvocations(
+                                    asList(invocation, invocationTwo),
+                                    new InvocationMatcher(invocation),
+                                    2);
+                        })
+                .isInstanceOf(TooFewActualInvocations.class)
+                .hasMessageContainingAll(
+                        "iMethods.simpleMethod();", "Wanted *at least* 2 times", "But was 1 time");
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
index 4ce557e..911a9a5 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
@@ -2,81 +2,142 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
 import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
+import java.util.ArrayList;
 import java.util.List;
-import org.junit.Rule;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
+import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+import org.mockito.internal.invocation.InterceptedInvocation;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.internal.invocation.MockitoMethod;
+import org.mockito.internal.invocation.RealMethod;
+import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
 public class MissingInvocationCheckerTest extends TestBase {
 
-	private InvocationMatcher wanted;
-	private List<Invocation> invocations;
-
-	@Mock
-	private IMethods mock;
-
-	@Rule
-	public ExpectedException exception = ExpectedException.none();
-
-	@Test
-	public void shouldPassBecauseActualInvocationFound() {
-		wanted = buildSimpleMethod().toInvocationMatcher();
-		invocations = asList(buildSimpleMethod().toInvocation());
-
-		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-	}
-
-	@Test
-	public void shouldReportWantedButNotInvoked() {
-		wanted = buildSimpleMethod().toInvocationMatcher();
-		invocations = asList(buildDifferentMethod().toInvocation());
-
-		exception.expect(WantedButNotInvoked.class);
-		exception.expectMessage("Wanted but not invoked:");
-		exception.expectMessage("mock.simpleMethod()");
-		exception.expectMessage("However, there was exactly 1 interaction with this mock:");
-		exception.expectMessage("mock.differentMethod();");
-
-		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-	}
-
-	@Test
-	public void shouldReportWantedInvocationDiffersFromActual() {
-		wanted = buildIntArgMethod().arg(2222).toInvocationMatcher();
-		invocations = asList(buildIntArgMethod().arg(1111).toInvocation());
-
-		exception.expect(ArgumentsAreDifferent.class);
-
-		exception.expectMessage("Argument(s) are different! Wanted:");
-		exception.expectMessage("mock.intArgumentMethod(2222);");
-		exception.expectMessage("Actual invocation has different arguments:");
-		exception.expectMessage("mock.intArgumentMethod(1111);");
-
-		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-	}
-
-	private InvocationBuilder buildIntArgMethod() {
-		return new InvocationBuilder().mock(mock).method("intArgumentMethod").argTypes(int.class);
-	}
-
-	private InvocationBuilder buildSimpleMethod() {
-		return new InvocationBuilder().mock(mock).simpleMethod();
-	}
-
-	private InvocationBuilder buildDifferentMethod() {
-		return new InvocationBuilder().mock(mock).differentMethod();
-	}
+    private InvocationMatcher wanted;
+    private List<Invocation> invocations;
+
+    @Mock private IMethods mock;
+
+    @Test
+    public void shouldPassBecauseActualInvocationFound() {
+        wanted = buildSimpleMethod().toInvocationMatcher();
+        invocations = asList(buildSimpleMethod().toInvocation());
+
+        MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+    }
+
+    @Test
+    public void shouldReportWantedButNotInvoked() {
+        wanted = buildSimpleMethod().toInvocationMatcher();
+        invocations = asList(buildDifferentMethod().toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:",
+                        "mock.simpleMethod()",
+                        "However, there was exactly 1 interaction with this mock:",
+                        "mock.differentMethod();");
+    }
+
+    @Test
+    public void shouldReportWantedInvocationDiffersFromActual() {
+        wanted = buildIntArgMethod(new InvocationBuilder()).arg(2222).toInvocationMatcher();
+        invocations = asList(buildIntArgMethod(new InvocationBuilder()).arg(1111).toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mock.intArgumentMethod(2222);",
+                        "Actual invocations have different arguments:",
+                        "mock.intArgumentMethod(1111);");
+    }
+
+    @Test
+    public void shouldReportUsingInvocationDescription() {
+        wanted = buildIntArgMethod(new CustomInvocationBuilder()).arg(2222).toInvocationMatcher();
+        invocations =
+                singletonList(
+                        buildIntArgMethod(new CustomInvocationBuilder()).arg(1111).toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mock.intArgumentMethod(MyCoolPrint(2222));",
+                        "Actual invocations have different arguments:",
+                        "mock.intArgumentMethod(MyCoolPrint(1111));");
+    }
+
+    private InvocationBuilder buildIntArgMethod(InvocationBuilder invocationBuilder) {
+        return invocationBuilder.mock(mock).method("intArgumentMethod").argTypes(int.class);
+    }
+
+    private InvocationBuilder buildSimpleMethod() {
+        return new InvocationBuilder().mock(mock).simpleMethod();
+    }
+
+    private InvocationBuilder buildDifferentMethod() {
+        return new InvocationBuilder().mock(mock).differentMethod();
+    }
+
+    static class CustomInvocationBuilder extends InvocationBuilder {
+        @Override
+        protected Invocation createInvocation(
+                MockReference<Object> mockRef,
+                MockitoMethod mockitoMethod,
+                final Object[] arguments,
+                RealMethod realMethod,
+                Location location,
+                int sequenceNumber) {
+            return new InterceptedInvocation(
+                    mockRef, mockitoMethod, arguments, realMethod, location, sequenceNumber) {
+                @Override
+                public List<ArgumentMatcher> getArgumentsAsMatchers() {
+                    List<ArgumentMatcher> matchers = new ArrayList<>();
+                    for (final Object argument : getRawArguments()) {
+                        matchers.add(
+                                new ArgumentMatcher() {
+                                    @Override
+                                    public boolean matches(Object a) {
+                                        return a == argument;
+                                    }
+
+                                    @Override
+                                    public String toString() {
+                                        return "MyCoolPrint(" + argument + ")";
+                                    }
+                                });
+                    }
+                    return matchers;
+                }
+            };
+        }
+    }
 }
diff --git a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java
index 7f37b12..899d0d3 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java
@@ -2,17 +2,22 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
+import static java.util.Arrays.asList;
+
+import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.verification.InOrderContextImpl;
@@ -22,35 +27,24 @@ import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.mockitousage.IMethods;
 
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
+public class MissingInvocationInOrderCheckerTest {
 
-public class MissingInvocationInOrderCheckerTest  {
+    private InvocationMatcher wanted;
+    private List<Invocation> invocations;
 
-	private InvocationMatcher wanted;
-	private List<Invocation> invocations;
+    @Mock private IMethods mock;
 
-	@Mock
-	private IMethods mock;
-
-	@Rule
-	public ExpectedException exception = ExpectedException.none();
-
-	@Rule
-	public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
 
     private InOrderContext context = new InOrderContextImpl();
 
     @Before
-    public void setup() {
-    }
+    public void setup() {}
 
     @Test
     public void shouldPassWhenMatchingInteractionFound() throws Exception {
 
-    	invocations = asList(buildSimpleMethod().toInvocation());
+        invocations = asList(buildSimpleMethod().toInvocation());
         wanted = buildSimpleMethod().toInvocationMatcher();
 
         checkMissingInvocation(invocations, wanted, context);
@@ -58,64 +52,66 @@ public class MissingInvocationInOrderCheckerTest  {
 
     @Test
     public void shouldReportWantedButNotInvoked() throws Exception {
-    	invocations = asList(buildDifferentMethod().toInvocation());
+        invocations = asList(buildDifferentMethod().toInvocation());
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(WantedButNotInvoked.class);
-		exception.expectMessage("Wanted but not invoked:");
-		exception.expectMessage("mock.simpleMethod()");
-
-        checkMissingInvocation(invocations, wanted, context);
+        assertThatThrownBy(
+                        () -> {
+                            checkMissingInvocation(invocations, wanted, context);
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll("Wanted but not invoked:", "mock.simpleMethod()");
     }
 
     @Test
     public void shouldReportArgumentsAreDifferent() throws Exception {
-    	invocations = asList(buildIntArgMethod().arg(1111).toInvocation());
+        invocations = asList(buildIntArgMethod().arg(1111).toInvocation());
         wanted = buildIntArgMethod().arg(2222).toInvocationMatcher();
 
-        exception.expect(ArgumentsAreDifferent.class);
-
-		exception.expectMessage("Argument(s) are different! Wanted:");
-		exception.expectMessage("mock.intArgumentMethod(2222);");
-		exception.expectMessage("Actual invocation has different arguments:");
-		exception.expectMessage("mock.intArgumentMethod(1111);");
-
-    	checkMissingInvocation(invocations, wanted, context);
-
-     }
+        assertThatThrownBy(
+                        () -> {
+                            checkMissingInvocation(invocations, wanted, context);
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mock.intArgumentMethod(2222);",
+                        "Actual invocations have different arguments:",
+                        "mock.intArgumentMethod(1111);");
+    }
 
     @Test
     public void shouldReportWantedDiffersFromActual() throws Exception {
 
-    	Invocation invocation1 = buildIntArgMethod().arg(1111).toInvocation();
-    	Invocation invocation2 = buildIntArgMethod().arg(2222).toInvocation();
+        Invocation invocation1 = buildIntArgMethod().arg(1111).toInvocation();
+        Invocation invocation2 = buildIntArgMethod().arg(2222).toInvocation();
 
-    	context.markVerified(invocation2);
-		invocations = asList(invocation1,invocation2);
+        context.markVerified(invocation2);
+        invocations = asList(invocation1, invocation2);
         wanted = buildIntArgMethod().arg(2222).toInvocationMatcher();
 
-        exception.expect(VerificationInOrderFailure.class);
-
-		exception.expectMessage("Verification in order failure");
-		exception.expectMessage("Wanted but not invoked:");
-		exception.expectMessage("mock.intArgumentMethod(2222);");
-		exception.expectMessage("Wanted anywhere AFTER following interaction:");
-		exception.expectMessage("mock.intArgumentMethod(2222);");
-
-        checkMissingInvocation(invocations, wanted, context);
+        assertThatThrownBy(
+                        () -> {
+                            checkMissingInvocation(invocations, wanted, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "Wanted but not invoked:",
+                        "mock.intArgumentMethod(2222);",
+                        "Wanted anywhere AFTER following interaction:",
+                        "mock.intArgumentMethod(2222);");
     }
 
     private InvocationBuilder buildIntArgMethod() {
-		return new InvocationBuilder().mock(mock).method("intArgumentMethod").argTypes(int.class);
-	}
-
-	private InvocationBuilder buildSimpleMethod() {
-		return new InvocationBuilder().mock(mock).simpleMethod();
-	}
-
-	private InvocationBuilder buildDifferentMethod() {
-		return new InvocationBuilder().mock(mock).differentMethod();
-	}
+        return new InvocationBuilder().mock(mock).method("intArgumentMethod").argTypes(int.class);
+    }
 
+    private InvocationBuilder buildSimpleMethod() {
+        return new InvocationBuilder().mock(mock).simpleMethod();
+    }
 
+    private InvocationBuilder buildDifferentMethod() {
+        return new InvocationBuilder().mock(mock).differentMethod();
+    }
 }
diff --git a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
index 61b2f2e..1c9bc6d 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
@@ -2,21 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.Collections;
 import java.util.List;
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.hamcrest.TypeSafeMatcher;
+
+import org.assertj.core.api.Condition;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.rules.TestName;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.NeverWantedButInvoked;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.TooManyActualInvocations;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
@@ -24,10 +27,6 @@ import org.mockito.invocation.Invocation;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 
-import static java.util.Arrays.asList;
-import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
-
 @RunWith(MockitoJUnitRunner.class)
 public class NumberOfInvocationsCheckerTest {
 
@@ -35,58 +34,61 @@ public class NumberOfInvocationsCheckerTest {
 
     private List<Invocation> invocations;
 
-    @Mock
-    private IMethods mock;
-
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
+    @Mock private IMethods mock;
 
-    @Rule
-    public TestName testName = new TestName();
+    @Rule public TestName testName = new TestName();
 
     @Test
-    public void shouldReportTooLittleActual() throws Exception {
+    public void shouldReportTooFewActual() {
         wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
-
-        exception.expect(TooLittleActualInvocations.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 2 times");
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        invocations =
+                asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100);
+                        })
+                .isInstanceOf(TooFewActualInvocations.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 2 times");
     }
 
     @Test
-    public void shouldReportAllInvocationsStackTrace() throws Exception {
+    public void shouldReportAllInvocationsStackTrace() {
         wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
-
-        exception.expect(TooLittleActualInvocations.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 2 times");
-        exception.expectMessage(containsTimes("-> at", 3));
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        invocations =
+                asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100);
+                        })
+                .isInstanceOf(TooFewActualInvocations.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 2 times")
+                .has(messageContaining("-> at", 3));
     }
 
     @Test
-    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {
+    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() {
         invocations = emptyList();
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(TooLittleActualInvocations.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 0 times");
-        exception.expectMessage(containsTimes("-> at", 1));
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100);
+                        })
+                .isInstanceOf(TooFewActualInvocations.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 0 times")
+                .has(messageContaining("-> at", 1));
     }
 
     @Test
-    public void shouldReportWithAllInvocationsStackTrace() throws Exception {
+    public void shouldReportWithAllInvocationsStackTrace() {
         Invocation first = buildSimpleMethod().toInvocation();
         Invocation second = buildSimpleMethod().toInvocation();
         Invocation third = buildSimpleMethod().toInvocation();
@@ -94,88 +96,122 @@ public class NumberOfInvocationsCheckerTest {
         invocations = asList(first, second, third);
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(TooManyActualInvocations.class);
-        exception.expectMessage("" + first.getLocation());
-        exception.expectMessage("" + second.getLocation());
-        exception.expectMessage("" + third.getLocation());
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 2);
+                        })
+                .isInstanceOf(TooManyActualInvocations.class)
+                .hasMessageContainingAll(
+                        "" + first.getLocation(),
+                        "" + second.getLocation(),
+                        "" + third.getLocation());
     }
 
     @Test
-    public void shouldReportTooManyActual() throws Exception {
+    public void shouldReportTooManyActual() {
         Invocation first = buildSimpleMethod().toInvocation();
         Invocation second = buildSimpleMethod().toInvocation();
 
         invocations = asList(first, second);
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expectMessage("Wanted 1 time");
-        exception.expectMessage("But was 2 times");
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 1);
+                        })
+                .hasMessageContainingAll("Wanted 1 time", "But was 2 times");
     }
 
     @Test
-    public void shouldReportNeverWantedButInvoked() throws Exception {
-        Invocation first = buildSimpleMethod().toInvocation();
-
-        invocations = asList(first);
-        wanted = buildSimpleMethod().toInvocationMatcher();
+    public void shouldReportNeverWantedButInvokedWithArgs() {
+        Invocation invocation = buildSimpleMethodWithArgs("arg1").toInvocation();
+
+        invocations = Collections.singletonList(invocation);
+        wanted = buildSimpleMethodWithArgs("arg1").toInvocationMatcher();
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 0);
+                        })
+                .isInstanceOf(NeverWantedButInvoked.class)
+                .hasMessageContainingAll(
+                        "Never wanted here",
+                        "But invoked here",
+                        "" + invocation.getLocation() + " with arguments: [arg1]");
+    }
 
-        exception.expect(NeverWantedButInvoked.class);
-        exception.expectMessage("Never wanted here");
-        exception.expectMessage("But invoked here");
-        exception.expectMessage("" + first.getLocation());
+    @Test
+    public void shouldReportNeverWantedButInvokedWithArgs_multipleInvocations() {
+        Invocation first = buildSimpleMethodWithArgs("arg1").toInvocation();
+        Invocation second = buildSimpleMethodWithArgs("arg1").toInvocation();
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
+        invocations = asList(first, second);
+        wanted = buildSimpleMethodWithArgs("arg1").toInvocationMatcher();
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 0);
+                        })
+                .isInstanceOf(NeverWantedButInvoked.class)
+                .hasMessageContainingAll(
+                        "Never wanted here",
+                        "But invoked here",
+                        "" + first.getLocation() + " with arguments: [arg1]",
+                        "" + second.getLocation() + " with arguments: [arg1]");
     }
 
-	@Test
-	public void shouldMarkInvocationsAsVerified() throws Exception {
-		Invocation invocation = buildSimpleMethod().toInvocation();
-		assertThat(invocation.isVerified()).isFalse();
+    @Test
+    public void shouldMarkInvocationsAsVerified() {
+        Invocation invocation = buildSimpleMethod().toInvocation();
+        assertThat(invocation.isVerified()).isFalse();
 
-		invocations = asList(invocation);
-		wanted = buildSimpleMethod().toInvocationMatcher();
-		NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
-		assertThat(invocation.isVerified()).isTrue();
-	}
+        invocations = asList(invocation);
+        wanted = buildSimpleMethod().toInvocationMatcher();
+        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
+        assertThat(invocation.isVerified()).isTrue();
+    }
 
     private InvocationBuilder buildSimpleMethod() {
         return new InvocationBuilder().mock(mock).simpleMethod();
     }
 
-    private static BaseMatcher<String> containsTimes(String value, int amount) {
-        return new StringContainsNumberMatcher(value, amount);
+    private InvocationBuilder buildSimpleMethodWithArgs(String arg) {
+        return new InvocationBuilder().mock(mock).simpleMethod().args(arg);
+    }
+
+    private static Condition<? super Throwable> messageContaining(
+            String value, int amountOfOccurrences) {
+        return new ThrowableMessageContainsOccurrencesCondition(value, amountOfOccurrences);
     }
 
-    private static class StringContainsNumberMatcher extends TypeSafeMatcher<String> {
+    private static class ThrowableMessageContainsOccurrencesCondition extends Condition<Throwable> {
 
-        private final String expected;
+        private final String value;
+        private final int expectedOccurrences;
 
-        private final int amount;
+        public ThrowableMessageContainsOccurrencesCondition(String value, int expectedOccurrences) {
+            this.value = value;
+            this.expectedOccurrences = expectedOccurrences;
 
-        StringContainsNumberMatcher(String expected, int amount) {
-            this.expected = expected;
-            this.amount = amount;
+            as("exactly %s occurrences of \"%s\"", expectedOccurrences, value);
         }
 
-        public boolean matchesSafely(String text) {
+        @Override
+        public boolean matches(Throwable ex) {
             int lastIndex = 0;
             int count = 0;
             while (lastIndex != -1) {
-                lastIndex = text.indexOf(expected, lastIndex);
+                lastIndex = ex.getMessage().indexOf(value, lastIndex);
                 if (lastIndex != -1) {
                     count++;
-                    lastIndex += expected.length();
+                    lastIndex += value.length();
                 }
             }
-            return count == amount;
-        }
-
-        public void describeTo(Description description) {
-            description.appendText("containing '" + expected + "' exactly " + amount + " times");
+            return count == expectedOccurrences;
         }
-
     }
 }
diff --git a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
index bc031ac..06b36c4 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
@@ -2,18 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockito.internal.verification.checkers;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+
 import java.util.List;
 
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.hamcrest.TypeSafeMatcher;
+import org.assertj.core.api.Condition;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
@@ -22,11 +23,6 @@ import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 
-import static java.util.Arrays.asList;
-import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
 public class NumberOfInvocationsInOrderCheckerTest {
 
     private InvocationMatcher wanted;
@@ -35,14 +31,10 @@ public class NumberOfInvocationsInOrderCheckerTest {
 
     private IMethods mock;
 
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
     @Before
     public void setup() {
         context = new InOrderContextImpl();
         mock = mock(IMethods.class, "mock");
-
     }
 
     @Test
@@ -54,30 +46,32 @@ public class NumberOfInvocationsInOrderCheckerTest {
     }
 
     @Test
-    public void shouldPassIfChunkMatches() throws Exception {
+    public void shouldPassIfChunkMatches() {
         wanted = buildSimpleMethod().toInvocationMatcher();
         invocations = asList(buildSimpleMethod().toInvocation());
         NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
     }
 
     @Test
-    public void shouldReportTooLittleInvocations() throws Exception {
+    public void shouldReportTooFewInvocations() {
         Invocation first = buildSimpleMethod().toInvocation();
         Invocation second = buildSimpleMethod().toInvocation();
 
         wanted = buildSimpleMethod().toInvocationMatcher();
         invocations = asList(first, second);
 
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 4 times");
-        exception.expectMessage("But was 2 times");
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 4, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 4 times", "But was 2 times");
     }
 
     @Test
-    public void shouldMarkAsVerifiedInOrder() throws Exception {
+    public void shouldMarkAsVerifiedInOrder() {
         Invocation invocation = buildSimpleMethod().toInvocation();
 
         invocations = asList(invocation);
@@ -89,49 +83,56 @@ public class NumberOfInvocationsInOrderCheckerTest {
     }
 
     @Test
-    public void shouldReportTooLittleActual() throws Exception {
+    public void shouldReportTooFewActual() {
         wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
-
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 2 times");
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
+        invocations =
+                asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 2 times");
     }
 
     @Test
-    public void shouldReportWithAllInvocationsStackTrace() throws Exception {
+    public void shouldReportWithAllInvocationsStackTrace() {
         wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
-
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 2 times");
-        exception.expectMessage(containsTimes("-> at", 3));
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
-
+        invocations =
+                asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
+
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 2 times")
+                .has(messageContaining("-> at", 3));
     }
 
     @Test
-    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {
+    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() {
         invocations = emptyList();
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 100 times");
-        exception.expectMessage("But was 0 times");
-        exception.expectMessage(containsTimes("-> at", 1));
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 100, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()", "Wanted 100 times", "But was 0 times")
+                .has(messageContaining("-> at", 1));
     }
 
     @Test
-    public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {
+    public void shouldReportWithFirstUndesiredInvocationStackTrace() {
         Invocation first = buildSimpleMethod().toInvocation();
         Invocation second = buildSimpleMethod().toInvocation();
         Invocation third = buildSimpleMethod().toInvocation();
@@ -139,43 +140,54 @@ public class NumberOfInvocationsInOrderCheckerTest {
         invocations = asList(first, second, third);
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("" + third.getLocation());
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 2, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("" + third.getLocation());
     }
 
     @Test
-    public void shouldReportTooManyActual() throws Exception {
+    public void shouldReportTooManyActual() {
         Invocation first = buildSimpleMethod().toInvocation();
         Invocation second = buildSimpleMethod().toInvocation();
 
         invocations = asList(first, second);
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expectMessage("Wanted 1 time");
-        exception.expectMessage("But was 2 times");
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 1, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll("Wanted 1 time", "But was 2 times");
     }
 
     @Test
-    public void shouldReportNeverWantedButInvoked() throws Exception {
+    public void shouldReportNeverWantedButInvoked() {
         Invocation first = buildSimpleMethod().toInvocation();
 
         invocations = asList(first);
         wanted = buildSimpleMethod().toInvocationMatcher();
 
-        exception.expect(VerificationInOrderFailure.class);
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("Wanted 0 times");
-        exception.expectMessage("But was 1 time:");
-        exception.expectMessage("" + first.getLocation());
-
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
+        assertThatThrownBy(
+                        () -> {
+                            NumberOfInvocationsChecker.checkNumberOfInvocations(
+                                    invocations, wanted, 0, context);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "mock.simpleMethod()",
+                        "Wanted 0 times",
+                        "But was 1 time:",
+                        "" + first.getLocation());
     }
 
     @Test
-    public void shouldMarkInvocationsAsVerified() throws Exception {
+    public void shouldMarkInvocationsAsVerified() {
         Invocation invocation = buildSimpleMethod().toInvocation();
         assertThat(invocation.isVerified()).isFalse();
 
@@ -185,40 +197,36 @@ public class NumberOfInvocationsInOrderCheckerTest {
         assertThat(invocation.isVerified()).isTrue();
     }
 
-    private static BaseMatcher<String> containsTimes(String value, int amount) {
-        return new StringContainsNumberMatcher(value, amount);
+    private static Condition<? super Throwable> messageContaining(
+            String value, int amountOfOccurrences) {
+        return new ThrowableMessageContainsOccurrencesCondition(value, amountOfOccurrences);
     }
 
-    private static class StringContainsNumberMatcher extends TypeSafeMatcher<String> {
+    private static class ThrowableMessageContainsOccurrencesCondition extends Condition<Throwable> {
 
-        private final String expected;
+        private final String value;
+        private final int expectedOccurrences;
 
-        private final int amount;
+        public ThrowableMessageContainsOccurrencesCondition(String value, int expectedOccurrences) {
+            this.value = value;
+            this.expectedOccurrences = expectedOccurrences;
 
-        StringContainsNumberMatcher(String expected, int amount) {
-            this.expected = expected;
-            this.amount = amount;
+            as("exactly %s occurrences of \"%s\"", expectedOccurrences, value);
         }
 
         @Override
-        public boolean matchesSafely(String text) {
+        public boolean matches(Throwable ex) {
             int lastIndex = 0;
             int count = 0;
             while (lastIndex != -1) {
-                lastIndex = text.indexOf(expected, lastIndex);
+                lastIndex = ex.getMessage().indexOf(value, lastIndex);
                 if (lastIndex != -1) {
                     count++;
-                    lastIndex += expected.length();
+                    lastIndex += value.length();
                 }
             }
-            return count == amount;
+            return count == expectedOccurrences;
         }
-
-        @Override
-        public void describeTo(Description description) {
-            description.appendText("containing '" + expected + "' exactly " + amount + " times");
-        }
-
     }
 
     private InvocationBuilder buildSimpleMethod() {
diff --git a/src/test/java/org/mockito/junit/TestableJUnitRunner.java b/src/test/java/org/mockito/junit/TestableJUnitRunner.java
index 149e2bf..a8b04f0 100644
--- a/src/test/java/org/mockito/junit/TestableJUnitRunner.java
+++ b/src/test/java/org/mockito/junit/TestableJUnitRunner.java
@@ -4,6 +4,8 @@
  */
 package org.mockito.junit;
 
+import java.lang.reflect.InvocationTargetException;
+
 import org.junit.runners.model.InitializationError;
 import org.mockito.internal.junit.MismatchReportingTestListener;
 import org.mockito.internal.junit.MockitoTestListener;
@@ -12,22 +14,29 @@ import org.mockito.internal.runners.StrictRunner;
 import org.mockito.internal.util.SimpleMockitoLogger;
 import org.mockito.internal.util.Supplier;
 
-import java.lang.reflect.InvocationTargetException;
-
 public class TestableJUnitRunner extends MockitoJUnitRunner {
 
-    private final static ThreadLocal<SimpleMockitoLogger> LOGGER = new ThreadLocal<SimpleMockitoLogger>() {
-        protected SimpleMockitoLogger initialValue() {
-            return new SimpleMockitoLogger();
-        }
-    };
+    private static final ThreadLocal<SimpleMockitoLogger> LOGGER =
+            new ThreadLocal<SimpleMockitoLogger>() {
+                protected SimpleMockitoLogger initialValue() {
+                    return new SimpleMockitoLogger();
+                }
+            };
 
-    public TestableJUnitRunner(Class<?> klass) throws InvocationTargetException, InitializationError {
-        super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
-            public MockitoTestListener get() {
-                return new MismatchReportingTestListener(LOGGER.get());
-            }
-        }), klass));
+    public TestableJUnitRunner(Class<?> klass)
+            throws InvocationTargetException, InitializationError {
+        super(
+                new StrictRunner(
+                        new RunnerFactory()
+                                .create(
+                                        klass,
+                                        new Supplier<MockitoTestListener>() {
+                                            public MockitoTestListener get() {
+                                                return new MismatchReportingTestListener(
+                                                        LOGGER.get());
+                                            }
+                                        }),
+                        klass));
     }
 
     public static SimpleMockitoLogger refreshedLogger() {
diff --git a/src/test/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunnerTest.java b/src/test/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunnerTest.java
deleted file mode 100644
index e72fa09..0000000
--- a/src/test/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunnerTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.runners;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.Description;
-import org.junit.runner.manipulation.Filter;
-import org.junit.runner.manipulation.NoTestsRemainException;
-import org.junit.runner.notification.RunNotifier;
-import org.junit.runners.model.InitializationError;
-import org.mockito.internal.runners.InternalRunner;
-import org.mockito.internal.util.ConsoleMockitoLogger;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.assertEquals;
-
-public class ConsoleSpammingMockitoJUnitRunnerTest extends TestBase {
-
-    private ConsoleSpammingMockitoJUnitRunner runner;
-
-    private MockitoLoggerStub loggerStub;
-
-    private RunNotifier notifier;
-
-    @Before
-    public void setup() throws InitializationError {
-        loggerStub = new MockitoLoggerStub();
-        notifier = new RunNotifier();
-    }
-
-    //TODO add sensible tests
-
-    @Test
-    public void shouldDelegateToGetDescription() throws Exception {
-        //given
-        final Description expectedDescription = Description.createSuiteDescription(this.getClass());
-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new InternalRunnerStub() {
-            public Description getDescription() {
-                return expectedDescription;
-            }
-        });
-
-        //when
-        Description description = runner.getDescription();
-
-        //then
-        assertEquals(expectedDescription, description);
-    }
-
-    public class MockitoLoggerStub extends ConsoleMockitoLogger {
-
-        StringBuilder loggedInfo = new StringBuilder();
-
-        public void log(Object what) {
-            super.log(what);
-            loggedInfo.append(what);
-        }
-
-        public String getLoggedInfo() {
-            return loggedInfo.toString();
-        }
-    }
-
-    static class InternalRunnerStub implements InternalRunner {
-
-        public Description getDescription() {
-            return null;
-        }
-
-        public void run(RunNotifier notifier) {
-        }
-
-        public void filter(Filter filter) throws NoTestsRemainException {
-        }
-
-    }
-}
diff --git a/src/test/java/org/mockito/verification/NegativeDurationTest.java b/src/test/java/org/mockito/verification/NegativeDurationTest.java
index ddfe31a..06b3cb4 100644
--- a/src/test/java/org/mockito/verification/NegativeDurationTest.java
+++ b/src/test/java/org/mockito/verification/NegativeDurationTest.java
@@ -4,27 +4,31 @@
  */
 package org.mockito.verification;
 
-import org.junit.Rule;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.Mockito;
 import org.mockito.exceptions.misusing.FriendlyReminderException;
 
 public class NegativeDurationTest {
-    @Rule
-    public ExpectedException expectedException = ExpectedException.none();
 
     @Test
     public void should_throw_exception_when_duration_is_negative_for_timeout_method() {
-        expectedException.expect(FriendlyReminderException.class);
-        expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
-        Mockito.timeout(-1);
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.timeout(-1);
+                        })
+                .isInstanceOf(FriendlyReminderException.class)
+                .hasMessageContaining("Don't panic! I'm just a friendly reminder!");
     }
 
     @Test
     public void should_throw_exception_when_duration_is_negative_for_after_method() {
-        expectedException.expect(FriendlyReminderException.class);
-        expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
-        Mockito.after(-1);
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.after(-1);
+                        })
+                .isInstanceOf(FriendlyReminderException.class)
+                .hasMessageContaining("Don't panic! I'm just a friendly reminder!");
     }
 }
diff --git a/src/test/java/org/mockito/verification/TimeoutTest.java b/src/test/java/org/mockito/verification/TimeoutTest.java
index 241b39b..b4c1ada 100644
--- a/src/test/java/org/mockito/verification/TimeoutTest.java
+++ b/src/test/java/org/mockito/verification/TimeoutTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.verification;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mock;
@@ -12,17 +15,11 @@ import org.mockito.internal.util.Timer;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class TimeoutTest extends TestBase {
 
-    @Mock
-    VerificationMode mode;
-    @Mock
-    VerificationDataImpl data;
-    @Mock
-    Timer timer;
+    @Mock VerificationMode mode;
+    @Mock VerificationDataImpl data;
+    @Mock Timer timer;
 
     private final MockitoAssertionError error = new MockitoAssertionError("");
 
@@ -45,15 +42,13 @@ public class TimeoutTest extends TestBase {
         Timeout t = new Timeout(1, mode, timer);
 
         when(timer.isCounting()).thenReturn(true, true, true, false);
-        doThrow(error).
-        doThrow(error).
-        doThrow(error).
-        when(mode).verify(data);
+        doThrow(error).doThrow(error).doThrow(error).when(mode).verify(data);
 
         try {
             t.verify(data);
             fail();
-        } catch (MockitoAssertionError e) {}
+        } catch (MockitoAssertionError e) {
+        }
 
         verify(timer, times(4)).isCounting();
     }
@@ -63,10 +58,7 @@ public class TimeoutTest extends TestBase {
         Timeout t = new Timeout(1, mode, timer);
 
         when(timer.isCounting()).thenReturn(true, true, true, false);
-        doThrow(error).
-        doThrow(error).
-        doNothing().
-        when(mode).verify(data);
+        doThrow(error).doThrow(error).doNothing().when(mode).verify(data);
 
         t.verify(data);
         verify(timer, times(3)).isCounting();
@@ -82,9 +74,9 @@ public class TimeoutTest extends TestBase {
         try {
             t.verify(data);
             fail();
-        } catch (MockitoAssertionError e) {}
+        } catch (MockitoAssertionError e) {
+        }
 
         verify(mode, times(5)).verify(data);
     }
-
 }
diff --git a/src/test/java/org/mockitointegration/NoByteCodeDependenciesTest.java b/src/test/java/org/mockitointegration/NoByteCodeDependenciesTest.java
new file mode 100644
index 0000000..2363fe6
--- /dev/null
+++ b/src/test/java/org/mockitointegration/NoByteCodeDependenciesTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitointegration;
+
+import static org.mockitoutil.ClassLoaders.coverageTool;
+
+import java.util.Set;
+
+import org.hamcrest.Matcher;
+import org.junit.*;
+import org.mockito.Mockito;
+import org.mockitoutil.ClassLoaders;
+
+public class NoByteCodeDependenciesTest {
+
+    private ClassLoader contextClassLoader;
+
+    @Test
+    public void pure_mockito_should_not_depend_bytecode_libraries() throws Exception {
+
+        ClassLoader classLoader_without_bytecode_libraries =
+                ClassLoaders.excludingClassLoader()
+                        .withCodeSourceUrlOf(Mockito.class, Matcher.class)
+                        .withCodeSourceUrlOf(coverageTool())
+                        .without("net.bytebuddy", "org.objenesis")
+                        .build();
+
+        Set<String> pureMockitoAPIClasses =
+                ClassLoaders.in(classLoader_without_bytecode_libraries)
+                        .omit("bytebuddy", "runners", "junit", "JUnit", "opentest4j")
+                        .listOwnedClasses();
+        pureMockitoAPIClasses.remove(
+                "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
+        pureMockitoAPIClasses.remove(
+                "org.mockito.internal.creation.instance.ObjenesisInstantiator");
+
+        // Remove classes that trigger plugin-loading, since bytebuddy plugins are the default.
+        pureMockitoAPIClasses.remove("org.mockito.internal.debugging.LocationImpl");
+        pureMockitoAPIClasses.remove("org.mockito.internal.exceptions.stacktrace.StackTraceFilter");
+        pureMockitoAPIClasses.remove("org.mockito.internal.util.MockUtil");
+
+        // Remove instrumentation-based member accessor which is optional.
+        pureMockitoAPIClasses.remove(
+                "org.mockito.internal.util.reflection.InstrumentationMemberAccessor");
+
+        for (String pureMockitoAPIClass : pureMockitoAPIClasses) {
+            checkDependency(classLoader_without_bytecode_libraries, pureMockitoAPIClass);
+        }
+    }
+
+    private void checkDependency(ClassLoader classLoader, String pureMockitoAPIClass)
+            throws ClassNotFoundException {
+        try {
+            Class.forName(pureMockitoAPIClass, true, classLoader);
+        } catch (Throwable e) {
+            e.printStackTrace();
+            throw new AssertionError(
+                    String.format(
+                            "'%s' has some dependency to Byte Buddy or Objenesis",
+                            pureMockitoAPIClass));
+        }
+    }
+}
diff --git a/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java b/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
index 90569a8..7b156f0 100644
--- a/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
+++ b/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockitointegration;
 
+import static org.mockitoutil.ClassLoaders.coverageTool;
+
+import java.util.Set;
+
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.agent.ByteBuddyAgent;
 import org.hamcrest.Matcher;
@@ -14,45 +18,51 @@ import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockitoutil.ClassLoaders;
 import org.objenesis.Objenesis;
 
-import java.util.Set;
-
-import static org.mockitoutil.ClassLoaders.coverageTool;
-
 public class NoJUnitDependenciesTest {
 
     @Test
     public void pure_mockito_should_not_depend_JUnit___ByteBuddy() throws Exception {
-        Assume.assumeTrue("ByteBuddyMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));
-
-        ClassLoader classLoader_without_JUnit = ClassLoaders.excludingClassLoader()
-                .withCodeSourceUrlOf(
-                        Mockito.class,
-                        Matcher.class,
-                        ByteBuddy.class,
-                        ByteBuddyAgent.class,
-                        Objenesis.class
-                )
-                .withCodeSourceUrlOf(coverageTool())
-                .without("junit", "org.junit")
-                .build();
-
-        Set<String> pureMockitoAPIClasses = ClassLoaders.in(classLoader_without_JUnit).omit("runners", "junit", "JUnit").listOwnedClasses();
-
-        // The later class is required to be initialized before any inline mock maker classes can be loaded.
-        checkDependency(classLoader_without_JUnit, "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
-        pureMockitoAPIClasses.remove("org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
+        Assume.assumeTrue(
+                "ByteBuddyMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));
+
+        ClassLoader classLoader_without_JUnit =
+                ClassLoaders.excludingClassLoader()
+                        .withCodeSourceUrlOf(
+                                Mockito.class,
+                                Matcher.class,
+                                ByteBuddy.class,
+                                ByteBuddyAgent.class,
+                                Objenesis.class)
+                        .withCodeSourceUrlOf(coverageTool())
+                        .without("junit", "org.junit", "org.opentest4j")
+                        .build();
+
+        Set<String> pureMockitoAPIClasses =
+                ClassLoaders.in(classLoader_without_JUnit)
+                        .omit("runners", "junit", "JUnit", "opentest4j")
+                        .listOwnedClasses();
+
+        // The later class is required to be initialized before any inline mock maker classes can be
+        // loaded.
+        checkDependency(
+                classLoader_without_JUnit,
+                "org.mockito.internal.creation.bytebuddy.InlineDelegateByteBuddyMockMaker");
+        pureMockitoAPIClasses.remove(
+                "org.mockito.internal.creation.bytebuddy.InlineDelegateByteBuddyMockMaker");
 
         for (String pureMockitoAPIClass : pureMockitoAPIClasses) {
             checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);
         }
     }
 
-    private void checkDependency(ClassLoader classLoader_without_JUnit, String pureMockitoAPIClass) throws ClassNotFoundException {
+    private void checkDependency(ClassLoader classLoader_without_JUnit, String pureMockitoAPIClass)
+            throws ClassNotFoundException {
         try {
             Class.forName(pureMockitoAPIClass, true, classLoader_without_JUnit);
         } catch (Throwable e) {
             e.printStackTrace();
-            throw new AssertionError(String.format("'%s' has some dependency to JUnit", pureMockitoAPIClass));
+            throw new AssertionError(
+                    String.format("'%s' has some dependency to JUnit", pureMockitoAPIClass));
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/CompilationWarningsTest.java b/src/test/java/org/mockitousage/CompilationWarningsTest.java
index 408d5f6..faf019f 100644
--- a/src/test/java/org/mockitousage/CompilationWarningsTest.java
+++ b/src/test/java/org/mockitousage/CompilationWarningsTest.java
@@ -4,101 +4,187 @@
  */
 package org.mockitousage;
 
+import static org.mockito.BDDMockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import static org.mockito.BDDMockito.*;
-
-
 public class CompilationWarningsTest {
 
     @Before
-    public void pay_attention_to_compilation_warnings_and_JDK_version() {
-    }
+    public void pay_attention_to_compilation_warnings_and_JDK_version() {}
 
     @Test
     public void no_warnings_for_most_common_api() throws Exception {
         doReturn(null).when(mock(IMethods.class)).objectReturningMethodNoArgs();
         doReturn("a", 12).when(mock(IMethods.class)).objectReturningMethodNoArgs();
         doReturn(1000).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doThrow(new NullPointerException()).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doThrow(new NullPointerException(), new IllegalArgumentException()).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doThrow(NullPointerException.class).when(mock(IMethods.class)).objectReturningMethodNoArgs();
+        doThrow(new NullPointerException())
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        doThrow(new NullPointerException(), new IllegalArgumentException())
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        doThrow(NullPointerException.class)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
 
         doAnswer(ignore()).doReturn(null).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doAnswer(ignore()).doReturn("a", 12).when(mock(IMethods.class)).objectReturningMethodNoArgs();
+        doAnswer(ignore())
+                .doReturn("a", 12)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
         doAnswer(ignore()).doReturn(1000).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doAnswer(ignore()).doThrow(new NullPointerException()).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doAnswer(ignore()).doThrow(new NullPointerException(), new IllegalArgumentException()).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doAnswer(ignore()).doThrow(NullPointerException.class).when(mock(IMethods.class)).objectReturningMethodNoArgs();
+        doAnswer(ignore())
+                .doThrow(new NullPointerException())
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        doAnswer(ignore())
+                .doThrow(new NullPointerException(), new IllegalArgumentException())
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        doAnswer(ignore())
+                .doThrow(NullPointerException.class)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
 
         when(mock(IMethods.class).objectReturningMethodNoArgs()).thenReturn(null);
         when(mock(IMethods.class).objectReturningMethodNoArgs()).thenReturn("a", 12L);
         when(mock(IMethods.class).objectReturningMethodNoArgs()).thenReturn(1000);
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).thenThrow(new NullPointerException());
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).thenThrow(new NullPointerException(), new IllegalArgumentException());
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).thenThrow(NullPointerException.class);
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .thenThrow(new NullPointerException());
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .thenThrow(new NullPointerException(), new IllegalArgumentException());
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .thenThrow(NullPointerException.class);
 
         when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenReturn(null);
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenReturn("a", 12L);
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .then(ignore())
+                .thenReturn("a", 12L);
         when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenReturn(1000);
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenThrow(new NullPointerException());
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenThrow(new NullPointerException(), new IllegalArgumentException());
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenThrow(NullPointerException.class);
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .then(ignore())
+                .thenThrow(new NullPointerException());
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .then(ignore())
+                .thenThrow(new NullPointerException(), new IllegalArgumentException());
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .then(ignore())
+                .thenThrow(NullPointerException.class);
 
         willReturn(null).given(mock(IMethods.class)).objectReturningMethodNoArgs();
         willReturn("a", 12).given(mock(IMethods.class)).objectReturningMethodNoArgs();
         willReturn(1000).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willThrow(new NullPointerException()).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willThrow(new NullPointerException(), new IllegalArgumentException()).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willThrow(NullPointerException.class).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-
-        willAnswer(ignore()).willReturn(null).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willAnswer(ignore()).willReturn("a", 12).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willAnswer(ignore()).willReturn(1000).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willAnswer(ignore()).willThrow(new NullPointerException()).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willAnswer(ignore()).willThrow(new NullPointerException(), new IllegalArgumentException()).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        willAnswer(ignore()).willThrow(NullPointerException.class).given(mock(IMethods.class)).objectReturningMethodNoArgs();
+        willThrow(new NullPointerException())
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willThrow(new NullPointerException(), new IllegalArgumentException())
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willThrow(NullPointerException.class)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+
+        willAnswer(ignore())
+                .willReturn(null)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willAnswer(ignore())
+                .willReturn("a", 12)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willAnswer(ignore())
+                .willReturn(1000)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willAnswer(ignore())
+                .willThrow(new NullPointerException())
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willAnswer(ignore())
+                .willThrow(new NullPointerException(), new IllegalArgumentException())
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        willAnswer(ignore())
+                .willThrow(NullPointerException.class)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
 
         given(mock(IMethods.class).objectReturningMethodNoArgs()).willReturn(null);
         given(mock(IMethods.class).objectReturningMethodNoArgs()).willReturn("a", 12L);
         given(mock(IMethods.class).objectReturningMethodNoArgs()).willReturn(1000);
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).willThrow(new NullPointerException());
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).willThrow(new NullPointerException(), new IllegalArgumentException());
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).willThrow(NullPointerException.class);
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .willThrow(new NullPointerException());
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .willThrow(new NullPointerException(), new IllegalArgumentException());
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .willThrow(NullPointerException.class);
 
         given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willReturn(null);
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willReturn("a", 12L);
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .will(ignore())
+                .willReturn("a", 12L);
         given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willReturn(1000);
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willThrow(new NullPointerException());
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willThrow(new NullPointerException(), new IllegalArgumentException());
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willThrow(NullPointerException.class);
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .will(ignore())
+                .willThrow(new NullPointerException());
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .will(ignore())
+                .willThrow(new NullPointerException(), new IllegalArgumentException());
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .will(ignore())
+                .willThrow(NullPointerException.class);
     }
 
     @Test
     @SuppressWarnings("unchecked")
-    public void heap_pollution_JDK7plus_warning_avoided_BUT_now_unchecked_generic_array_creation_warnings_ON_JDK5plus_environment() throws Exception {
-        doThrow(NullPointerException.class, IllegalArgumentException.class).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).thenThrow(NullPointerException.class, IllegalArgumentException.class);
-        doAnswer(ignore()).doThrow(NullPointerException.class, IllegalArgumentException.class).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-
-        willThrow(NullPointerException.class, IllegalArgumentException.class).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).willThrow(NullPointerException.class, IllegalArgumentException.class);
-        willAnswer(ignore()).willThrow(NullPointerException.class, IllegalArgumentException.class).given(mock(IMethods.class)).objectReturningMethodNoArgs();
+    public void
+            heap_pollution_JDK7plus_warning_avoided_BUT_now_unchecked_generic_array_creation_warnings_ON_JDK5plus_environment()
+                    throws Exception {
+        doThrow(NullPointerException.class, IllegalArgumentException.class)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .thenThrow(NullPointerException.class, IllegalArgumentException.class);
+        doAnswer(ignore())
+                .doThrow(NullPointerException.class, IllegalArgumentException.class)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+
+        willThrow(NullPointerException.class, IllegalArgumentException.class)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .willThrow(NullPointerException.class, IllegalArgumentException.class);
+        willAnswer(ignore())
+                .willThrow(NullPointerException.class, IllegalArgumentException.class)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
     }
 
     @Test
     public void unchecked_confusing_null_argument_warnings() throws Exception {
         doReturn(null, (Object[]) null).when(mock(IMethods.class)).objectReturningMethodNoArgs();
-        doAnswer(ignore()).doReturn(null, (Object[]) null).when(mock(IMethods.class)).objectReturningMethodNoArgs();
+        doAnswer(ignore())
+                .doReturn(null, (Object[]) null)
+                .when(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
         when(mock(IMethods.class).objectReturningMethodNoArgs()).thenReturn(null, (Object[]) null);
-        when(mock(IMethods.class).objectReturningMethodNoArgs()).then(ignore()).thenReturn(null, (Object[]) null);
+        when(mock(IMethods.class).objectReturningMethodNoArgs())
+                .then(ignore())
+                .thenReturn(null, (Object[]) null);
         willReturn(null, (Object[]) null).given(mock(IMethods.class)).objectReturningMethodNoArgs();
         given(mock(IMethods.class).objectReturningMethodNoArgs()).willReturn(null, (Object[]) null);
-        willAnswer(ignore()).willReturn(null, (Object[]) null).given(mock(IMethods.class)).objectReturningMethodNoArgs();
-        given(mock(IMethods.class).objectReturningMethodNoArgs()).will(ignore()).willReturn(null, (Object[]) null);
+        willAnswer(ignore())
+                .willReturn(null, (Object[]) null)
+                .given(mock(IMethods.class))
+                .objectReturningMethodNoArgs();
+        given(mock(IMethods.class).objectReturningMethodNoArgs())
+                .will(ignore())
+                .willReturn(null, (Object[]) null);
     }
 
     private static Answer<?> ignore() {
diff --git a/src/test/java/org/mockitousage/IMethods.java b/src/test/java/org/mockitousage/IMethods.java
index 7ec3750..1289742 100644
--- a/src/test/java/org/mockitousage/IMethods.java
+++ b/src/test/java/org/mockitousage/IMethods.java
@@ -42,7 +42,7 @@ public interface IMethods {
 
     Double doubleObjectReturningMethod();
 
-    Object objectReturningMethod(Object ... objects);
+    Object objectReturningMethod(Object... objects);
 
     Object objectReturningMethodNoArgs();
 
@@ -124,6 +124,9 @@ public interface IMethods {
 
     String simpleMethod(String one, Integer two, Integer three, Integer four, Integer five);
 
+    String simpleMethod(
+            String one, Integer two, Integer three, Integer four, Integer five, Integer six);
+
     String simpleMethod(String one, String[] two);
 
     Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);
@@ -164,21 +167,21 @@ public interface IMethods {
 
     void varargsbyte(byte... bytes);
 
-    int varargs(Object ... object);
+    int varargs(Object... object);
 
-    String varargsReturningString(Object ... object);
+    String varargsReturningString(Object... object);
 
-    int varargs(String ... string);
+    int varargs(String... string);
 
-    void mixedVarargs(Object i, String ... string);
+    void mixedVarargs(Object i, String... string);
 
-    String mixedVarargsReturningString(Object i, String ... string);
+    String mixedVarargsReturningString(Object i, String... string);
 
-    String[] mixedVarargsReturningStringArray(Object i, String ... string);
+    String[] mixedVarargsReturningStringArray(Object i, String... string);
 
-    Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
+    Object[] mixedVarargsReturningObjectArray(Object i, String... string);
 
-    List<String> listReturningMethod(Object ... objects);
+    List<String> listReturningMethod(Object... objects);
 
     LinkedList<String> linkedListReturningMethod();
 
@@ -235,4 +238,52 @@ public interface IMethods {
     String forObject(Object object);
 
     <T> String genericToString(T arg);
+
+    void overloadedMethodWithSameClassNameArguments(java.sql.Date javaDate, Date date);
+
+    void overloadedMethodWithSameClassNameArguments(Date date, java.sql.Date javaDate);
+
+    void overloadedMethodWithDifferentClassNameArguments(String String, Integer i);
+
+    void overloadedMethodWithDifferentClassNameArguments(Integer i, String string);
+
+    void overloadedMethodWithSameClassNameArguments(
+            java.sql.Date javaDate, String string, Date date);
+
+    void overloadedMethodWithSameClassNameArguments(
+            Date date, String string, java.sql.Date javaDate);
+
+    /**
+     * Using this class to test cases where two classes have same simple name
+     */
+    public static class Date {
+
+        private int value;
+
+        public Date(int value) {
+            this.value = value;
+        }
+
+        @Override
+        public String toString() {
+            return String.valueOf(value);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+            Date date = (Date) o;
+            return value == date.value;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(value);
+        }
+    }
 }
diff --git a/src/test/java/org/mockitousage/MethodsImpl.java b/src/test/java/org/mockitousage/MethodsImpl.java
index 9417cbe..bb69656 100644
--- a/src/test/java/org/mockitousage/MethodsImpl.java
+++ b/src/test/java/org/mockitousage/MethodsImpl.java
@@ -237,6 +237,11 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
+    public String simpleMethod(
+            String one, Integer two, Integer three, Integer four, Integer five, Integer six) {
+        return null;
+    }
+
     public String simpleMethod(String one, String[] two) {
         return null;
     }
@@ -249,17 +254,14 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
-    public String fourArgumentMethod(int valueOne, String valueTwo, String valueThree, boolean[] array) {
+    public String fourArgumentMethod(
+            int valueOne, String valueTwo, String valueThree, boolean[] array) {
         return null;
     }
 
-    public void twoArgumentMethod(int one, int two) {
-
-    }
-
-    public void arrayMethod(String[] strings) {
+    public void twoArgumentMethod(int one, int two) {}
 
-    }
+    public void arrayMethod(String[] strings) {}
 
     public String oneArray(boolean[] array) {
         return null;
@@ -305,9 +307,7 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
-    public void varargsString(int i, String... string) {
-
-    }
+    public void varargsString(int i, String... string) {}
 
     public Object varargsObject(int i, Object... object) {
         return null;
@@ -325,8 +325,7 @@ public class MethodsImpl implements IMethods {
         return -1;
     }
 
-    public void mixedVarargs(Object i, String... string) {
-    }
+    public void mixedVarargs(Object i, String... string) {}
 
     public String mixedVarargsReturningString(Object i, String... string) {
         return null;
@@ -340,8 +339,7 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
-    public void varargsbyte(byte... bytes) {
-    }
+    public void varargsbyte(byte... bytes) {}
 
     public List<String> listReturningMethod(Object... objects) {
         return null;
@@ -355,9 +353,7 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
-    public void voidMethod() {
-
-    }
+    public void voidMethod() {}
 
     public String forList(List<String> list) {
         return null;
@@ -411,13 +407,9 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
-    public void longArg(long longArg) {
-
-    }
+    public void longArg(long longArg) {}
 
-    public void intArgumentMethod(int i) {
-
-    }
+    public void intArgumentMethod(int i) {}
 
     public int intArgumentReturningInt(int i) {
         return 0;
@@ -456,4 +448,24 @@ public class MethodsImpl implements IMethods {
     public <T> String genericToString(T arg) {
         return null;
     }
+
+    @Override
+    public void overloadedMethodWithSameClassNameArguments(java.sql.Date javaDate, Date date) {}
+
+    @Override
+    public void overloadedMethodWithSameClassNameArguments(Date date, java.sql.Date javaDate) {}
+
+    @Override
+    public void overloadedMethodWithDifferentClassNameArguments(String string, Integer i) {}
+
+    @Override
+    public void overloadedMethodWithDifferentClassNameArguments(Integer i, String string) {}
+
+    @Override
+    public void overloadedMethodWithSameClassNameArguments(
+            java.sql.Date javaDate, String string, Date date) {}
+
+    @Override
+    public void overloadedMethodWithSameClassNameArguments(
+            Date date, String string, java.sql.Date javaDate) {}
 }
diff --git a/src/test/java/org/mockitousage/PlaygroundTest.java b/src/test/java/org/mockitousage/PlaygroundTest.java
index d3f5777..33c2036 100644
--- a/src/test/java/org/mockitousage/PlaygroundTest.java
+++ b/src/test/java/org/mockitousage/PlaygroundTest.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage;
 
 import org.junit.Test;
@@ -22,12 +21,12 @@ public class PlaygroundTest extends TestBase {
     }
 
     class Boo {
-        final public Object withLong(long y) {
-                         return "";
+        public final Object withLong(long y) {
+            return "";
         }
 
         public Object foo() {
-                   return "";
+            return "";
         }
     }
 
@@ -35,70 +34,68 @@ public class PlaygroundTest extends TestBase {
     @Mock IMethods mockTwo;
 
     @Test
-    public void spyInAction() {
-
-    }
+    public void spyInAction() {}
 
     @Test
     public void partialMockInAction() {
-//        mock = mock(Foo.class, withSettings()
-//            .defaultBehavior(CALLS_REAL_METHODS);
-
-//        mock = mock(Foo.class, withSettings()
-//            .defaultMockAnswer(CALLS_REAL_METHODS);
-
-//        mock = mock(Foo.class, withSettings()
-//            .defaultAnswer(CALLS_REAL_METHODS);
-
-//        mock = mock(Foo.class, CALLS_REAL_METHODS);
-
-//        mock = mock(Foo.class, withSettings()
-//            .defaultBehavior(CALLS_REAL_METHODS)
-//            .createUsingDefaultConstructor();
-//
-//        mock = mock(Foo.class, withSettings()
-//            .defaultBehavior(CALLS_REAL_METHODS)
-//            .createPassingArguments("some arg", 1);
-//
-//        spy = spy(Foo.class, "some arg", 1);
-//
-//            .withName("foo")
-//            .withDefaultBehavior(RETURNS_SMART_NULLS)
-//            .withInterfaces(Bar.class);
-//
-//        mock = mock(Foo.class)
-//            .name("foo")
-//            .defaultBehavior(RETURNS_SMART_NULLS)
-//            .interfaces(Bar.class);
-//
-//        mock = mock(Foo.class)
-//            .named("foo")
-//            .byDefault(RETURNS_SMART_NULLS)
-//            .alsoImplements(Bar.class, Bar2.class);
-//
-//        mock = mock(Foo.class)
-//            hasName("foo");
-
-//        when(mock.getStuff()).thenReturn("aha!");
-//        when(mock.doSomeThing()).thenCallRealMethod();
-//
-
-//        mock.doSomeThing();
+        //        mock = mock(Foo.class, withSettings()
+        //            .defaultBehavior(CALLS_REAL_METHODS);
+
+        //        mock = mock(Foo.class, withSettings()
+        //            .defaultMockAnswer(CALLS_REAL_METHODS);
+
+        //        mock = mock(Foo.class, withSettings()
+        //            .defaultAnswer(CALLS_REAL_METHODS);
+
+        //        mock = mock(Foo.class, CALLS_REAL_METHODS);
+
+        //        mock = mock(Foo.class, withSettings()
+        //            .defaultBehavior(CALLS_REAL_METHODS)
+        //            .createUsingDefaultConstructor();
+        //
+        //        mock = mock(Foo.class, withSettings()
+        //            .defaultBehavior(CALLS_REAL_METHODS)
+        //            .createPassingArguments("some arg", 1);
+        //
+        //        spy = spy(Foo.class, "some arg", 1);
+        //
+        //            .withName("foo")
+        //            .withDefaultBehavior(RETURNS_SMART_NULLS)
+        //            .withInterfaces(Bar.class);
+        //
+        //        mock = mock(Foo.class)
+        //            .name("foo")
+        //            .defaultBehavior(RETURNS_SMART_NULLS)
+        //            .interfaces(Bar.class);
+        //
+        //        mock = mock(Foo.class)
+        //            .named("foo")
+        //            .byDefault(RETURNS_SMART_NULLS)
+        //            .alsoImplements(Bar.class, Bar2.class);
+        //
+        //        mock = mock(Foo.class)
+        //            hasName("foo");
+
+        //        when(mock.getStuff()).thenReturn("aha!");
+        //        when(mock.doSomeThing()).thenCallRealMethod();
+        //
+
+        //        mock.doSomeThing();
     }
 
-//    interface Colored {
-//
-//    }
-//
-//    interface Bar {
-//        <T extends Foo & Colored> T getColoredPoint();
-//    }
-//
-//    @Test
-//    public void testname() throws Exception {
-//        when(mock.get()).then(returnArgument());
-//
-//        Bar mock = mock(Bar.class);
-//        when(mock.getColoredPoint()).thenReturn(new Foo());
-//    }
+    //    interface Colored {
+    //
+    //    }
+    //
+    //    interface Bar {
+    //        <T extends Foo & Colored> T getColoredPoint();
+    //    }
+    //
+    //    @Test
+    //    public void testname() throws Exception {
+    //        when(mock.get()).then(returnArgument());
+    //
+    //        Bar mock = mock(Bar.class);
+    //        when(mock.getColoredPoint()).thenReturn(new Foo());
+    //    }
 }
diff --git a/src/test/java/org/mockitousage/PlaygroundWithDemoOfUnclonedParametersProblemTest.java b/src/test/java/org/mockitousage/PlaygroundWithDemoOfUnclonedParametersProblemTest.java
index c740c7a..3ff4379 100644
--- a/src/test/java/org/mockitousage/PlaygroundWithDemoOfUnclonedParametersProblemTest.java
+++ b/src/test/java/org/mockitousage/PlaygroundWithDemoOfUnclonedParametersProblemTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.willAnswer;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.GregorianCalendar;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
@@ -12,15 +20,6 @@ import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitoutil.TestBase;
 
-import java.util.Date;
-import java.util.GregorianCalendar;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willAnswer;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.verify;
-
 public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase {
 
     ImportManager importManager;
@@ -36,46 +35,52 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
 
     @Test
     public void shouldIncludeInitialLog() {
-        //given
+        // given
         int importType = 0;
         Date currentDate = new GregorianCalendar(2009, 10, 12).getTime();
 
         ImportLogBean initialLog = new ImportLogBean(currentDate, importType);
         initialLog.setStatus(1);
 
-        given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate)).willReturn(false);
-        willAnswer(byCheckingLogEquals(initialLog)).given(importLogDao).include(any(ImportLogBean.class));
+        given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate))
+                .willReturn(false);
+        willAnswer(byCheckingLogEquals(initialLog))
+                .given(importLogDao)
+                .include(any(ImportLogBean.class));
 
-        //when
+        // when
         importManager.startImportProcess(importType, currentDate);
 
-        //then
+        // then
         verify(importLogDao).include(any(ImportLogBean.class));
     }
 
     @Test
     public void shouldAlterFinalLog() {
-        //given
+        // given
         int importType = 0;
         Date currentDate = new GregorianCalendar(2009, 10, 12).getTime();
 
         ImportLogBean finalLog = new ImportLogBean(currentDate, importType);
         finalLog.setStatus(9);
 
-        given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate)).willReturn(false);
-        willAnswer(byCheckingLogEquals(finalLog)).given(importLogDao).alter(any(ImportLogBean.class));
+        given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate))
+                .willReturn(false);
+        willAnswer(byCheckingLogEquals(finalLog))
+                .given(importLogDao)
+                .alter(any(ImportLogBean.class));
 
-        //when
+        // when
         importManager.startImportProcess(importType, currentDate);
 
-        //then
+        // then
         verify(importLogDao).alter(any(ImportLogBean.class));
     }
 
     private Answer<Object> byCheckingLogEquals(final ImportLogBean status) {
         return new Answer<Object>() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
-                ImportLogBean bean =  invocation.getArgument(0);
+                ImportLogBean bean = invocation.getArgument(0);
                 assertEquals(status, bean);
                 return null;
             }
@@ -98,7 +103,8 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
                 importLogBean = createResume(importType, date);
                 if (isOkToImport(importType, date)) {
                     // get the right handler
-                    //importLogBean = ImportHandlerFactory.singleton().getImportHandler(importType).processImport(importLogBean);
+                    // importLogBean =
+                    // ImportHandlerFactory.singleton().getImportHandler(importType).processImport(importLogBean);
                     // 2 = ok
                     importLogBean.setStatus(2);
                 } else {
@@ -107,11 +113,9 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
                 }
             } catch (Exception e) {
                 // 9 = failed - exception
-                if (importLogBean != null)
-                    importLogBean.setStatus(9);
+                if (importLogBean != null) importLogBean.setStatus(9);
             } finally {
-                if (importLogBean != null)
-                    finalizeResume(importLogBean);
+                if (importLogBean != null) finalizeResume(importLogBean);
             }
         }
 
@@ -120,8 +124,7 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
         }
 
         private ImportLogBean createResume(int importType, Date date) {
-            ImportLogBean importLogBean = new ImportLogBean(date,
-                    importType);
+            ImportLogBean importLogBean = new ImportLogBean(date, importType);
             // 1 = running
             importLogBean.setStatus(1);
             importLogDao.include(importLogBean);
@@ -141,8 +144,7 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
         void alter(ImportLogBean importLogBean);
     }
 
-    private class IImportHandler {
-    }
+    private class IImportHandler {}
 
     private class ImportLogBean {
         private Date currentDate;
@@ -167,7 +169,9 @@ public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase
 
             if (importType != that.importType) return false;
             if (status != that.status) return false;
-            if (currentDate != null ? !currentDate.equals(that.currentDate) : that.currentDate != null) return false;
+            if (currentDate != null
+                    ? !currentDate.equals(that.currentDate)
+                    : that.currentDate != null) return false;
 
             return true;
         }
diff --git a/src/test/java/org/mockitousage/annotation/AnnotationsTest.java b/src/test/java/org/mockitousage/annotation/AnnotationsTest.java
index 3daf8b1..1a33f93 100644
--- a/src/test/java/org/mockitousage/annotation/AnnotationsTest.java
+++ b/src/test/java/org/mockitousage/annotation/AnnotationsTest.java
@@ -2,9 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.verify;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Answers;
@@ -15,16 +24,6 @@ import org.mockito.exceptions.base.MockitoException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.verify;
-
 public class AnnotationsTest extends TestBase {
 
     @Retention(RetentionPolicy.RUNTIME)
@@ -39,7 +38,7 @@ public class AnnotationsTest extends TestBase {
 
     @Before
     public void setup() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test
@@ -56,10 +55,11 @@ public class AnnotationsTest extends TestBase {
     @Test
     public void shouldScreamWhenInitializingMocksForNullClass() throws Exception {
         try {
-            MockitoAnnotations.initMocks(null);
+            MockitoAnnotations.openMocks(null);
             fail();
         } catch (MockitoException e) {
-            assertEquals("testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class",
+            assertEquals(
+                    "testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class",
                     e.getMessage());
         }
     }
@@ -67,18 +67,26 @@ public class AnnotationsTest extends TestBase {
     @Test
     public void shouldLookForAnnotatedMocksInSuperClasses() throws Exception {
         Sub sub = new Sub();
-        MockitoAnnotations.initMocks(sub);
+        MockitoAnnotations.openMocks(sub);
 
         assertNotNull(sub.getMock());
         assertNotNull(sub.getBaseMock());
         assertNotNull(sub.getSuperBaseMock());
     }
 
-    @Mock(answer = Answers.RETURNS_MOCKS, name = "i have a name") IMethods namedAndReturningMocks;
-    @Mock(answer = Answers.RETURNS_DEFAULTS) IMethods returningDefaults;
-    @Mock(extraInterfaces = {List.class}) IMethods hasExtraInterfaces;
+    @Mock(answer = Answers.RETURNS_MOCKS, name = "i have a name")
+    IMethods namedAndReturningMocks;
+
+    @Mock(answer = Answers.RETURNS_DEFAULTS)
+    IMethods returningDefaults;
+
+    @Mock(extraInterfaces = {List.class})
+    IMethods hasExtraInterfaces;
+
     @Mock() IMethods noExtraConfig;
-    @Mock(stubOnly=true) IMethods stubOnly;
+
+    @Mock(stubOnly = true)
+    IMethods stubOnly;
 
     @Test
     public void shouldInitMocksWithGivenSettings() throws Exception {
diff --git a/src/test/java/org/mockitousage/annotation/CaptorAnnotationBasicTest.java b/src/test/java/org/mockitousage/annotation/CaptorAnnotationBasicTest.java
index 3876f86..6f8dc66 100644
--- a/src/test/java/org/mockitousage/annotation/CaptorAnnotationBasicTest.java
+++ b/src/test/java/org/mockitousage/annotation/CaptorAnnotationBasicTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.mockito.Mockito.verify;
+
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
@@ -12,13 +18,6 @@ import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.mockito.Mockito.verify;
-
 @SuppressWarnings("unchecked")
 public class CaptorAnnotationBasicTest extends TestBase {
 
@@ -52,10 +51,10 @@ public class CaptorAnnotationBasicTest extends TestBase {
 
     @Test
     public void shouldUseCaptorInOrdinaryWay() {
-        //when
+        // when
         createPerson("Wes", "Williams");
 
-        //then
+        // then
         ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);
         verify(peopleRepository).save(captor.capture());
         assertEquals("Wes", captor.getValue().getName());
@@ -66,24 +65,25 @@ public class CaptorAnnotationBasicTest extends TestBase {
 
     @Test
     public void shouldUseAnnotatedCaptor() {
-        //when
+        // when
         createPerson("Wes", "Williams");
 
-        //then
+        // then
         verify(peopleRepository).save(captor.capture());
         assertEquals("Wes", captor.getValue().getName());
         assertEquals("Williams", captor.getValue().getSurname());
     }
 
     @SuppressWarnings("rawtypes")
-    @Captor ArgumentCaptor genericLessCaptor;
+    @Captor
+    ArgumentCaptor genericLessCaptor;
 
     @Test
     public void shouldUseGenericlessAnnotatedCaptor() {
-        //when
+        // when
         createPerson("Wes", "Williams");
 
-        //then
+        // then
         verify(peopleRepository).save((Person) genericLessCaptor.capture());
         assertEquals("Wes", ((Person) genericLessCaptor.getValue()).getName());
         assertEquals("Williams", ((Person) genericLessCaptor.getValue()).getSurname());
@@ -94,14 +94,14 @@ public class CaptorAnnotationBasicTest extends TestBase {
 
     @Test
     public void shouldCaptureGenericList() {
-        //given
+        // given
         List<String> list = new LinkedList<String>();
         mock.listArgMethod(list);
 
-        //when
+        // when
         verify(mock).listArgMethod(genericListCaptor.capture());
 
-        //then
+        // then
         assertSame(list, genericListCaptor.getValue());
     }
 }
diff --git a/src/test/java/org/mockitousage/annotation/CaptorAnnotationTest.java b/src/test/java/org/mockitousage/annotation/CaptorAnnotationTest.java
index baca220..f015f1b 100644
--- a/src/test/java/org/mockitousage/annotation/CaptorAnnotationTest.java
+++ b/src/test/java/org/mockitousage/annotation/CaptorAnnotationTest.java
@@ -2,14 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
-import org.junit.Test;
-import org.mockito.*;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.*;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -17,30 +13,28 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
+import org.mockito.*;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 public class CaptorAnnotationTest extends TestBase {
 
     @Retention(RetentionPolicy.RUNTIME)
-    public @interface NotAMock {
-    }
+    public @interface NotAMock {}
 
-    @Captor
-    final ArgumentCaptor<String> finalCaptor = ArgumentCaptor.forClass(String.class);
+    @Captor final ArgumentCaptor<String> finalCaptor = ArgumentCaptor.forClass(String.class);
 
-    @Captor
-    ArgumentCaptor<List<List<String>>> genericsCaptor;
+    @Captor ArgumentCaptor<List<List<String>>> genericsCaptor;
 
     @SuppressWarnings("rawtypes")
     @Captor
     ArgumentCaptor nonGenericCaptorIsAllowed;
 
-    @Mock
-    MockInterface mockInterface;
+    @Mock MockInterface mockInterface;
 
-    @NotAMock
-    Set<?> notAMock;
+    @NotAMock Set<?> notAMock;
 
     public interface MockInterface {
         void testMe(String simple, List<List<String>> genericList);
@@ -49,7 +43,7 @@ public class CaptorAnnotationTest extends TestBase {
     @Test
     public void testNormalUsage() {
 
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
 
         // check if assigned correctly
         assertNotNull(finalCaptor);
@@ -67,44 +61,41 @@ public class CaptorAnnotationTest extends TestBase {
 
         assertEquals(argForFinalCaptor, finalCaptor.getValue());
         assertEquals(argForGenericsCaptor, genericsCaptor.getValue());
-
     }
 
     public static class WrongType {
-        @Captor
-        List<?> wrongType;
+        @Captor List<?> wrongType;
     }
 
     @Test
     public void shouldScreamWhenWrongTypeForCaptor() {
         try {
-            MockitoAnnotations.initMocks(new WrongType());
+            MockitoAnnotations.openMocks(new WrongType());
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 
     public static class ToManyAnnotations {
-        @Captor
-        @Mock
-        ArgumentCaptor<List> missingGenericsField;
+        @Captor @Mock ArgumentCaptor<List> missingGenericsField;
     }
 
     @Test
     public void shouldScreamWhenMoreThanOneMockitoAnnotation() {
         try {
-            MockitoAnnotations.initMocks(new ToManyAnnotations());
+            MockitoAnnotations.openMocks(new ToManyAnnotations());
             fail();
         } catch (MockitoException e) {
             assertThat(e)
-                .hasMessageContaining("missingGenericsField")
-                .hasMessageContaining("multiple Mockito annotations");
+                    .hasMessageContaining("missingGenericsField")
+                    .hasMessageContaining("multiple Mockito annotations");
         }
     }
 
     @Test
     public void shouldScreamWhenInitializingCaptorsForNullClass() throws Exception {
         try {
-            MockitoAnnotations.initMocks(null);
+            MockitoAnnotations.openMocks(null);
             fail();
         } catch (MockitoException e) {
         }
@@ -113,7 +104,7 @@ public class CaptorAnnotationTest extends TestBase {
     @Test
     public void shouldLookForAnnotatedCaptorsInSuperClasses() throws Exception {
         Sub sub = new Sub();
-        MockitoAnnotations.initMocks(sub);
+        MockitoAnnotations.openMocks(sub);
 
         assertNotNull(sub.getCaptor());
         assertNotNull(sub.getBaseCaptor());
@@ -121,8 +112,7 @@ public class CaptorAnnotationTest extends TestBase {
     }
 
     class SuperBase {
-        @Captor
-        private ArgumentCaptor<IMethods> mock;
+        @Captor private ArgumentCaptor<IMethods> mock;
 
         public ArgumentCaptor<IMethods> getSuperBaseCaptor() {
             return mock;
@@ -130,8 +120,7 @@ public class CaptorAnnotationTest extends TestBase {
     }
 
     class Base extends SuperBase {
-        @Captor
-        private ArgumentCaptor<IMethods> mock;
+        @Captor private ArgumentCaptor<IMethods> mock;
 
         public ArgumentCaptor<IMethods> getBaseCaptor() {
             return mock;
@@ -139,8 +128,7 @@ public class CaptorAnnotationTest extends TestBase {
     }
 
     class Sub extends Base {
-        @Captor
-        private ArgumentCaptor<IMethods> mock;
+        @Captor private ArgumentCaptor<IMethods> mock;
 
         public ArgumentCaptor<IMethods> getCaptor() {
             return mock;
diff --git a/src/test/java/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java b/src/test/java/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java
index 5f96a28..f49de96 100644
--- a/src/test/java/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java
+++ b/src/test/java/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Captor;
@@ -12,11 +16,6 @@ import org.mockito.MockitoAnnotations;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class CaptorAnnotationUnhappyPathTest extends TestBase {
 
     @Captor List<?> notACaptorField;
@@ -24,20 +23,20 @@ public class CaptorAnnotationUnhappyPathTest extends TestBase {
     @Before
     @Override
     public void init() {
-        //we need to get rid of parent implementation this time
+        // we need to get rid of parent implementation this time
     }
 
     @Test
     public void shouldFailIfCaptorHasWrongType() throws Exception {
         try {
-            //when
-            MockitoAnnotations.initMocks(this);
+            // when
+            MockitoAnnotations.openMocks(this);
             fail();
         } catch (MockitoException e) {
-            //then
+            // then
             assertThat(e)
-                .hasMessageContaining("notACaptorField")
-                .hasMessageContaining("wrong type");
+                    .hasMessageContaining("notACaptorField")
+                    .hasMessageContaining("wrong type");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java b/src/test/java/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java
deleted file mode 100644
index 43b8e63..0000000
--- a/src/test/java/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockitousage.annotation;
-
-import org.junit.After;
-import org.junit.Test;
-import org.mockito.InjectMocks;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.configuration.AnnotationEngine;
-import org.mockito.configuration.DefaultMockitoConfiguration;
-import org.mockito.internal.configuration.ConfigurationAccess;
-import org.mockito.internal.configuration.IndependentAnnotationEngine;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.*;
-
-public class DeprecatedAnnotationEngineApiTest extends TestBase {
-
-    @After
-    public void goBackToDefaultConfiguration() {
-        ConfigurationAccess.getConfig().overrideAnnotationEngine(null);
-    }
-
-    class SimpleTestCase {
-        @InjectMocks Tested tested = new Tested();
-        @Mock Dependency mock;
-    }
-
-    class Tested {
-        Dependency dependency;
-        public void setDependency(Dependency dependency) {
-            this.dependency = dependency;
-        }
-    }
-
-    class Dependency {}
-
-    @Test
-    public void shouldInjectMocksIfThereIsNoUserDefinedEngine() throws Exception {
-        //given
-        AnnotationEngine defaultEngine = new DefaultMockitoConfiguration().getAnnotationEngine();
-        ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);
-        SimpleTestCase test = new SimpleTestCase();
-
-        //when
-        MockitoAnnotations.initMocks(test);
-
-        //then
-        assertNotNull(test.mock);
-        assertNotNull(test.tested.dependency);
-        assertSame(test.mock, test.tested.dependency);
-    }
-
-    @Test
-    public void shouldRespectUsersEngine() throws Exception {
-        //given
-        AnnotationEngine customizedEngine = new IndependentAnnotationEngine() { /**/ };
-        ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);
-        SimpleTestCase test = new SimpleTestCase();
-
-        //when
-        MockitoAnnotations.initMocks(test);
-
-        //then
-        assertNotNull(test.mock);
-        assertNull(test.tested.dependency);
-    }
-}
diff --git a/src/test/java/org/mockitousage/annotation/DoNotMockTest.java b/src/test/java/org/mockitousage/annotation/DoNotMockTest.java
new file mode 100644
index 0000000..9364345
--- /dev/null
+++ b/src/test/java/org/mockitousage/annotation/DoNotMockTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.annotation;
+
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Test;
+import org.mockito.DoNotMock;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.exceptions.misusing.DoNotMockException;
+
+public class DoNotMockTest {
+
+    @Test
+    public void can_not_mock_class_annotated_with_donotmock() {
+        assertThatThrownBy(
+                        () -> {
+                            NotMockable notMockable = mock(NotMockable.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void can_not_mock_class_via_mock_annotation() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(new TestClass());
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void can_not_mock_class_with_interface_annotated_with_donotmock() {
+        assertThatThrownBy(
+                        () -> {
+                            SubclassOfNotMockableInterface notMockable =
+                                    mock(SubclassOfNotMockableInterface.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void can_not_mock_subclass_with_unmockable_interface() {
+        assertThatThrownBy(
+                        () -> {
+                            DoubleSubclassOfInterface notMockable =
+                                    mock(DoubleSubclassOfInterface.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void can_not_mock_subclass_with_unmockable_superclass() {
+        assertThatThrownBy(
+                        () -> {
+                            SubclassOfNotMockableSuperclass notMockable =
+                                    mock(SubclassOfNotMockableSuperclass.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void
+            can_not_mock_subclass_with_unmockable_interface_that_extends_non_mockable_interface() {
+        assertThatThrownBy(
+                        () -> {
+                            SubclassOfSubInterfaceOfNotMockableInterface notMockable =
+                                    mock(SubclassOfSubInterfaceOfNotMockableInterface.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @Test
+    public void thrown_exception_includes_non_mockable_reason() {
+        assertThatThrownBy(
+                        () -> {
+                            NotMockable notMockable = mock(NotMockable.class);
+                        })
+                .isInstanceOf(DoNotMockException.class)
+                .hasMessageContaining("Create a real instance instead");
+    }
+
+    @Test
+    public void thrown_exception_includes_special_non_mockable_reason() {
+        assertThatThrownBy(
+                        () -> {
+                            NotMockableWithReason notMockable = mock(NotMockableWithReason.class);
+                        })
+                .isInstanceOf(DoNotMockException.class)
+                .hasMessageContaining("Special reason");
+    }
+
+    @Test
+    public void can_not_mock_class_with_custom_donotmock_annotation() {
+        assertThatThrownBy(
+                        () -> {
+                            NotMockableWithDifferentAnnotation notMockable =
+                                    mock(NotMockableWithDifferentAnnotation.class);
+                        })
+                .isInstanceOf(DoNotMockException.class);
+    }
+
+    @DoNotMock
+    private static class NotMockable {}
+
+    @DoNotMock
+    private interface NotMockableInterface {}
+
+    @org.mockitousage.annotation.org.mockito.DoNotMock
+    private static class NotMockableWithDifferentAnnotation {}
+
+    @DoNotMock(reason = "Special reason")
+    private interface NotMockableWithReason {}
+
+    static class SubclassOfNotMockableInterface implements NotMockableInterface {}
+
+    private static class DoubleSubclassOfInterface extends SubclassOfNotMockableInterface {}
+
+    private static class SubclassOfNotMockableSuperclass extends NotMockable {}
+
+    private interface SubInterfaceOfNotMockableInterface extends NotMockableInterface {}
+
+    private static class SubclassOfSubInterfaceOfNotMockableInterface
+            implements SubInterfaceOfNotMockableInterface {}
+
+    private static class TestClass {
+        @Mock private NotMockable notMockable;
+    }
+}
diff --git a/src/test/java/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java b/src/test/java/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java
index 39ef5f3..defb88a 100644
--- a/src/test/java/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java
+++ b/src/test/java/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockitousage.annotation;
 
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InjectMocks;
-import org.mockito.junit.MockitoJUnitRunner;
-
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InjectMocks;
+import org.mockito.junit.MockitoJUnitRunner;
+
 @RunWith(MockitoJUnitRunner.class)
 public class InjectionOfInlinedMockDeclarationTest {
 
@@ -44,7 +44,6 @@ public class InjectionOfInlinedMockDeclarationTest {
         assertSame(antenna, receiver.dvbtAntenna);
     }
 
-
     @Test
     public void inject_mocks_even_in_declared_spy() throws Exception {
         assertNotNull(spiedReceiver.oldAntenna);
@@ -58,10 +57,12 @@ public class InjectionOfInlinedMockDeclarationTest {
         Antenna dvbtAntenna;
         Tuner tuner;
 
-        public boolean tune() { return true; }
+        public boolean tune() {
+            return true;
+        }
     }
 
-    private static class Antenna { }
-    private static class Tuner { }
+    private static class Antenna {}
 
+    private static class Tuner {}
 }
diff --git a/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorIssue421Test.java b/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorIssue421Test.java
index eb3e99f..0e5c67f 100644
--- a/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorIssue421Test.java
+++ b/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorIssue421Test.java
@@ -2,9 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
@@ -13,8 +14,6 @@ import org.mockito.internal.util.MockUtil;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.examples.use.ArticleCalculator;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 @RunWith(MockitoJUnitRunner.class)
 public class MockInjectionUsingConstructorIssue421Test {
 
@@ -31,16 +30,14 @@ public class MockInjectionUsingConstructorIssue421Test {
 
         private ArticleCalculator calculator;
 
-        public Issue421(int a) {
-        }
+        public Issue421(int a) {}
 
         public Issue421(ArticleCalculator calculator) {
             this.calculator = calculator;
         }
 
-        public void checkIfMockIsInjected(){
+        public void checkIfMockIsInjected() {
             assertThat(MockUtil.isMock(calculator)).isTrue();
         }
     }
-
 }
diff --git a/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java b/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java
index 38879dc..c45c90a 100644
--- a/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java
+++ b/src/test/java/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java
@@ -2,15 +2,26 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.annotation;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.openMocks;
+
+import java.util.AbstractCollection;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
 import org.junit.Before;
 import org.junit.Ignore;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.internal.TextListener;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
@@ -25,16 +36,6 @@ import org.mockitousage.examples.use.ArticleCalculator;
 import org.mockitousage.examples.use.ArticleDatabase;
 import org.mockitousage.examples.use.ArticleManager;
 
-import java.util.AbstractCollection;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.when;
-import static org.mockito.MockitoAnnotations.initMocks;
-
 public class MockInjectionUsingConstructorTest {
 
     @Mock private ArticleCalculator calculator;
@@ -43,11 +44,9 @@ public class MockInjectionUsingConstructorTest {
     @InjectMocks private ArticleManager articleManager;
     @Spy @InjectMocks private ArticleManager spiedArticleManager;
 
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
-    @Before public void before() {
-        MockitoAnnotations.initMocks(this);
+    @Before
+    public void before() {
+        MockitoAnnotations.openMocks(this);
     }
 
     @Test
@@ -55,11 +54,15 @@ public class MockInjectionUsingConstructorTest {
         assertNotNull(articleManager);
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
     public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {
         when(calculator.countArticles("new")).thenThrow(new IllegalArgumentException());
 
-        articleManager.updateArticleCounters("new");
+        assertThatThrownBy(
+                        () -> {
+                            articleManager.updateArticleCounters("new");
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
     }
 
     @Test
@@ -88,18 +91,21 @@ public class MockInjectionUsingConstructorTest {
     }
 
     @Test
-    public void should_report_failure_only_when_object_initialization_throws_exception() throws Exception {
+    public void should_report_failure_only_when_object_initialization_throws_exception()
+            throws Exception {
 
         try {
-            MockitoAnnotations.initMocks(new ATest());
+            MockitoAnnotations.openMocks(new ATest());
             fail();
         } catch (MockitoException e) {
-            assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");
+            assertThat(e.getMessage())
+                    .contains("failingConstructor")
+                    .contains("constructor")
+                    .contains("threw an exception");
             assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);
         }
     }
 
-
     @RunWith(MockitoJUnitRunner.class)
     public static class junit_test_with_3_tests_methods {
         private static int constructor_instantiation = 0;
@@ -107,9 +113,14 @@ public class MockInjectionUsingConstructorTest {
         @Mock List<?> some_collaborator;
         @InjectMocks some_class_with_parametered_constructor should_be_initialized_3_times;
 
-        @Test public void test_1() { }
-        @Test public void test_2() { }
-        @Test public void test_3() { }
+        @Test
+        public void test_1() {}
+
+        @Test
+        public void test_2() {}
+
+        @Test
+        public void test_3() {}
 
         private static class some_class_with_parametered_constructor {
             public some_class_with_parametered_constructor(List<?> collaborator) {
@@ -130,91 +141,92 @@ public class MockInjectionUsingConstructorTest {
         @InjectMocks FailingConstructor failingConstructor;
     }
 
-
     @Test
-    public void injectMocksMustFailWithInterface() throws Exception {
+    public void injectMocksMustFailWithInterface() {
         class TestCase {
-            @InjectMocks
-            IMethods f;
+            @InjectMocks IMethods f;
         }
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'IMethods' is an interface");
-
-
-        initMocks(new TestCase());
+        assertThatThrownBy(
+                        () -> {
+                            openMocks(new TestCase());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'IMethods' is an interface");
     }
 
     @Test
     public void injectMocksMustFailWithEnum() throws Exception {
         class TestCase {
-            @InjectMocks
-            TimeUnit f;
+            @InjectMocks TimeUnit f;
         }
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'TimeUnit' is an enum");
-
-        initMocks(new TestCase());
+        assertThatThrownBy(
+                        () -> {
+                            openMocks(new TestCase());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'TimeUnit' is an enum");
     }
 
     @Test
-    public void injectMocksMustFailWithAbstractClass() throws Exception {
+    public void injectMocksMustFailWithAbstractClass() {
         class TestCase {
-            @InjectMocks
-            AbstractCollection<?> f;
+            @InjectMocks AbstractCollection<?> f;
         }
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'AbstractCollection' is an abstract class");
-
-        initMocks(new TestCase());
+        assertThatThrownBy(
+                        () -> {
+                            openMocks(new TestCase());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'AbstractCollection' is an abstract class");
     }
 
     @Test
-    public void injectMocksMustFailWithNonStaticInnerClass() throws Exception {
+    public void injectMocksMustFailWithNonStaticInnerClass() {
         class TestCase {
             class InnerClass {}
-            @InjectMocks
-            InnerClass f;
-        }
-
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'InnerClass' is an inner non static class");
+            @InjectMocks InnerClass f;
+        }
 
-        initMocks(new TestCase());
+        assertThatThrownBy(
+                        () -> {
+                            openMocks(new TestCase());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining(
+                        "Cannot instantiate @InjectMocks field named 'f'! Cause: the type 'InnerClass' is an inner non static class");
     }
 
-    static class  StaticInnerClass {}
+    static class StaticInnerClass {}
+
     @Test
-    public void injectMocksMustSucceedWithStaticInnerClass() throws Exception {
+    public void injectMocksMustSucceedWithStaticInnerClass() {
         class TestCase {
-            @InjectMocks
-            StaticInnerClass f;
+            @InjectMocks StaticInnerClass f;
         }
 
         TestCase testClass = new TestCase();
-        initMocks(testClass);
+        openMocks(testClass);
 
         assertThat(testClass.f).isInstanceOf(StaticInnerClass.class);
     }
 
     @Test
-    public void injectMocksMustSucceedWithInstance() throws Exception {
+    public void injectMocksMustSucceedWithInstance() {
         class TestCase {
-            @InjectMocks
-            StaticInnerClass f = new StaticInnerClass();
+            @InjectMocks StaticInnerClass f = new StaticInnerClass();
         }
 
         TestCase testClass = new TestCase();
         StaticInnerClass original = testClass.f;
-        initMocks(testClass);
+        openMocks(testClass);
 
         assertThat(testClass.f).isSameAs(original);
     }
-
-
-
-
 }
diff --git a/src/test/java/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java b/src/test/java/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java
index c23345a..0d2af98 100644
--- a/src/test/java/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java
+++ b/src/test/java/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java
@@ -4,7 +4,15 @@
  */
 package org.mockitousage.annotation;
 
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
 import org.assertj.core.api.Assertions;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InjectMocks;
@@ -16,13 +24,6 @@ import org.mockito.internal.util.MockUtil;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-
-import static org.junit.Assert.*;
-
 @SuppressWarnings({"unchecked", "unused"})
 public class MockInjectionUsingSetterOrPropertyTest extends TestBase {
 
@@ -31,7 +32,9 @@ public class MockInjectionUsingSetterOrPropertyTest extends TestBase {
     @InjectMocks private BaseUnderTesting baseUnderTest = new BaseUnderTesting();
     @InjectMocks private SubUnderTesting subUnderTest = new SubUnderTesting();
     @InjectMocks private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();
-    @InjectMocks private HasTwoFieldsWithSameType hasTwoFieldsWithSameType = new HasTwoFieldsWithSameType();
+
+    @InjectMocks
+    private HasTwoFieldsWithSameType hasTwoFieldsWithSameType = new HasTwoFieldsWithSameType();
 
     private BaseUnderTesting baseUnderTestingInstance = new BaseUnderTesting();
     @InjectMocks private BaseUnderTesting initializedBase = baseUnderTestingInstance;
@@ -48,10 +51,19 @@ public class MockInjectionUsingSetterOrPropertyTest extends TestBase {
 
     @Spy private TreeSet<String> searchTree = new TreeSet<String>();
 
+    private AutoCloseable session;
+
     @Before
     public void enforces_new_instances() {
-        // initMocks called in TestBase Before method, so instances are not the same
-        MockitoAnnotations.initMocks(this);
+        // openMocks called in TestBase Before method, so instances are not the same
+        session = MockitoAnnotations.openMocks(this);
+    }
+
+    @After
+    public void close_new_instances() throws Exception {
+        if (session != null) {
+            session.close();
+        }
     }
 
     @Test
@@ -79,41 +91,43 @@ public class MockInjectionUsingSetterOrPropertyTest extends TestBase {
 
     @Test
     public void should_inject_mocks_if_annotated() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
         assertSame(list, superUnderTest.getAList());
     }
 
     @Test
     public void should_not_inject_if_not_annotated() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
         assertNull(superUnderTestWithoutInjection.getAList());
     }
 
     @Test
     public void should_inject_mocks_for_class_hierarchy_if_annotated() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
         assertSame(list, baseUnderTest.getAList());
         assertSame(map, baseUnderTest.getAMap());
     }
 
     @Test
     public void should_inject_mocks_by_name() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
         assertSame(histogram1, subUnderTest.getHistogram1());
         assertSame(histogram2, subUnderTest.getHistogram2());
     }
 
     @Test
     public void should_inject_spies() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
         assertSame(searchTree, otherBaseUnderTest.getSearchTree());
     }
 
     @Test
-    public void should_insert_into_field_with_matching_name_when_multiple_fields_of_same_type_exists_in_injectee() {
-        MockitoAnnotations.initMocks(this);
+    public void
+            should_insert_into_field_with_matching_name_when_multiple_fields_of_same_type_exists_in_injectee() {
+        MockitoAnnotations.openMocks(this);
         assertNull("not injected, no mock named 'candidate1'", hasTwoFieldsWithSameType.candidate1);
-        assertNotNull("injected, there's a mock named 'candidate2'", hasTwoFieldsWithSameType.candidate2);
+        assertNotNull(
+                "injected, there's a mock named 'candidate2'", hasTwoFieldsWithSameType.candidate2);
     }
 
     @Test
@@ -128,46 +142,63 @@ public class MockInjectionUsingSetterOrPropertyTest extends TestBase {
 
     @Test
     public void should_report_nicely() throws Exception {
-        Object failing = new Object() {
-            @InjectMocks ThrowingConstructor failingConstructor;
-        };
+        Object failing =
+                new Object() {
+                    @InjectMocks ThrowingConstructor failingConstructor;
+                };
         try {
-            MockitoAnnotations.initMocks(failing);
+            MockitoAnnotations.openMocks(failing);
             fail();
         } catch (MockitoException e) {
-            Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");
+            Assertions.assertThat(e.getMessage())
+                    .contains("failingConstructor")
+                    .contains("constructor")
+                    .contains("threw an exception");
             Assertions.assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
         }
     }
 
     static class ThrowingConstructor {
-        ThrowingConstructor() { throw new RuntimeException("aha"); }
+        ThrowingConstructor() {
+            throw new RuntimeException("aha");
+        }
     }
 
     static class SuperUnderTesting {
         private List<?> aList;
 
-        public List<?> getAList() { return aList; }
+        public List<?> getAList() {
+            return aList;
+        }
     }
 
     static class BaseUnderTesting extends SuperUnderTesting {
         private Map<?, ?> aMap;
 
-        public Map<?, ?> getAMap() { return aMap; }
+        public Map<?, ?> getAMap() {
+            return aMap;
+        }
     }
 
     static class OtherBaseUnderTesting extends SuperUnderTesting {
         private TreeSet<?> searchTree;
 
-        public TreeSet<?> getSearchTree() { return searchTree; }
+        public TreeSet<?> getSearchTree() {
+            return searchTree;
+        }
     }
 
     static class SubUnderTesting extends BaseUnderTesting {
         private Set<?> histogram1;
         private Set<?> histogram2;
 
-        public Set<?> getHistogram1() { return histogram1; }
-        public Set<?> getHistogram2() { return histogram2; }
+        public Set<?> getHistogram1() {
+            return histogram1;
+        }
+
+        public Set<?> getHistogram2() {
+            return histogram2;
+        }
     }
 
     static class HasTwoFieldsWithSameType {
diff --git a/src/test/java/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java b/src/test/java/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java
index 5d3b5e6..60f8791 100644
--- a/src/test/java/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java
+++ b/src/test/java/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java
@@ -4,6 +4,12 @@
  */
 package org.mockitousage.annotation;
 
+import static org.junit.Assert.assertTrue;
+import static org.mockito.internal.util.MockUtil.isMock;
+
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.MockitoAnnotations;
@@ -11,53 +17,42 @@ import org.mockito.Spy;
 import org.mockito.internal.util.MockUtil;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.junit.Assert.assertTrue;
-import static org.mockito.internal.util.MockUtil.isMock;
-
 @SuppressWarnings("unchecked")
 public class SpyAnnotationInitializedInBaseClassTest extends TestBase {
 
     class BaseClass {
 
-        @Spy
-        List list = new LinkedList();
+        @Spy List list = new LinkedList();
     }
 
-    class SubClass extends BaseClass {
-
-    }
+    class SubClass extends BaseClass {}
 
     @Test
     public void shouldInitSpiesInBaseClass() throws Exception {
-        //given
+        // given
         SubClass subClass = new SubClass();
-        //when
-        MockitoAnnotations.initMocks(subClass);
-        //then
+        // when
+        MockitoAnnotations.openMocks(subClass);
+        // then
         assertTrue(MockUtil.isMock(subClass.list));
     }
 
     @Before
     @Override
     public void init() {
-        //we need to get rid of parent implementation this time
+        // we need to get rid of parent implementation this time
     }
 
     @Before
     public void before() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
-    @Spy
-    List spyInBaseclass = new LinkedList();
+    @Spy List spyInBaseclass = new LinkedList();
 
     public static class SubTest extends SpyAnnotationInitializedInBaseClassTest {
 
-        @Spy
-        List spyInSubclass = new LinkedList();
+        @Spy List spyInSubclass = new LinkedList();
 
         @Test
         public void shouldInitSpiesInHierarchy() throws Exception {
diff --git a/src/test/java/org/mockitousage/annotation/SpyAnnotationTest.java b/src/test/java/org/mockitousage/annotation/SpyAnnotationTest.java
index 8fbbe18..01edd3c 100644
--- a/src/test/java/org/mockitousage/annotation/SpyAnnotationTest.java
+++ b/src/test/java/org/mockitousage/annotation/SpyAnnotationTest.java
@@ -4,11 +4,24 @@
  */
 package org.mockitousage.annotation;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -19,34 +32,18 @@ import org.mockito.Spy;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("unused")
 public class SpyAnnotationTest extends TestBase {
 
-    @Spy
-    final List<String> spiedList = new ArrayList<String>();
+    @Spy final List<String> spiedList = new ArrayList<String>();
 
-    @Spy
-    InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
+    @Spy InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
 
-    @Spy
-    InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
+    @Spy InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
 
-    @Spy
-    MockTranslator translator;
+    @Spy MockTranslator translator;
 
-    @Rule
-    public final ExpectedException shouldThrow = ExpectedException.none();
+    @Rule public final ExpectedException shouldThrow = ExpectedException.none();
 
     @Test
     public void should_init_spy_by_instance() throws Exception {
@@ -66,12 +63,11 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_allow_spying_on_interfaces() throws Exception {
         class WithSpy {
-            @Spy
-            List<String> list;
+            @Spy List<String> list;
         }
 
         WithSpy withSpy = new WithSpy();
-        MockitoAnnotations.initMocks(withSpy);
+        MockitoAnnotations.openMocks(withSpy);
         when(withSpy.list.size()).thenReturn(3);
         assertEquals(3, withSpy.list.size());
     }
@@ -79,30 +75,29 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_allow_spying_on_interfaces_when_instance_is_concrete() throws Exception {
         class WithSpy {
-            @Spy
-            List<String> list = new LinkedList<String>();
+            @Spy List<String> list = new LinkedList<String>();
         }
         WithSpy withSpy = new WithSpy();
 
-        //when
-        MockitoAnnotations.initMocks(withSpy);
+        // when
+        MockitoAnnotations.openMocks(withSpy);
 
-        //then
+        // then
         verify(withSpy.list, never()).clear();
     }
 
     @Test
     public void should_report_when_no_arg_less_constructor() throws Exception {
         class FailingSpy {
-            @Spy
-            NoValidConstructor noValidConstructor;
+            @Spy NoValidConstructor noValidConstructor;
         }
 
         try {
-            MockitoAnnotations.initMocks(new FailingSpy());
+            MockitoAnnotations.openMocks(new FailingSpy());
             fail();
         } catch (MockitoException e) {
-            assertThat(e.getMessage()).contains("Please ensure that the type")
+            assertThat(e.getMessage())
+                    .contains("Please ensure that the type")
                     .contains(NoValidConstructor.class.getSimpleName())
                     .contains("has a no-arg constructor");
         }
@@ -111,12 +106,11 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_report_when_constructor_is_explosive() throws Exception {
         class FailingSpy {
-            @Spy
-            ThrowingConstructor throwingConstructor;
+            @Spy ThrowingConstructor throwingConstructor;
         }
 
         try {
-            MockitoAnnotations.initMocks(new FailingSpy());
+            MockitoAnnotations.openMocks(new FailingSpy());
             fail();
         } catch (MockitoException e) {
             assertThat(e.getMessage()).contains("Unable to create mock instance");
@@ -126,8 +120,7 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_spy_abstract_class() throws Exception {
         class SpyAbstractClass {
-            @Spy
-            AbstractList<String> list;
+            @Spy AbstractList<String> list;
 
             List<String> asSingletonList(String s) {
                 when(list.size()).thenReturn(1);
@@ -136,7 +129,7 @@ public class SpyAnnotationTest extends TestBase {
             }
         }
         SpyAbstractClass withSpy = new SpyAbstractClass();
-        MockitoAnnotations.initMocks(withSpy);
+        MockitoAnnotations.openMocks(withSpy);
         assertEquals(Arrays.asList("a"), withSpy.asSingletonList("a"));
     }
 
@@ -144,10 +137,8 @@ public class SpyAnnotationTest extends TestBase {
     public void should_spy_inner_class() throws Exception {
 
         class WithMockAndSpy {
-            @Spy
-            private InnerStrength strength;
-            @Mock
-            private List<String> list;
+            @Spy private InnerStrength strength;
+            @Mock private List<String> list;
 
             abstract class InnerStrength {
                 private final String name;
@@ -167,28 +158,30 @@ public class SpyAnnotationTest extends TestBase {
             }
         }
         WithMockAndSpy outer = new WithMockAndSpy();
-        MockitoAnnotations.initMocks(outer);
+        MockitoAnnotations.openMocks(outer);
         when(outer.strength.strength()).thenReturn("strength");
         assertEquals("inner strength", outer.strength.fullStrength());
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test
     public void should_reset_spy() throws Exception {
-        spiedList.get(10); // see shouldInitSpy
+        assertThatThrownBy(
+                        () -> {
+                            spiedList.get(10); // see shouldInitSpy
+                        })
+                .isInstanceOf(IndexOutOfBoundsException.class);
     }
 
     @Test
     public void should_report_when_enclosing_instance_is_needed() throws Exception {
         class Outer {
-            class Inner {
-            }
+            class Inner {}
         }
         class WithSpy {
-            @Spy
-            private Outer.Inner inner;
+            @Spy private Outer.Inner inner;
         }
         try {
-            MockitoAnnotations.initMocks(new WithSpy());
+            MockitoAnnotations.openMocks(new WithSpy());
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessageContaining("@Spy annotation can only initialize inner classes");
@@ -198,13 +191,14 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_report_private_inner_not_supported() throws Exception {
         try {
-            MockitoAnnotations.initMocks(new WithInnerPrivate());
+            MockitoAnnotations.openMocks(new WithInnerPrivate());
             fail();
         } catch (MockitoException e) {
             // Currently fails at instantiation time, because the mock subclass don't have the
             // 1-arg constructor expected for the outerclass.
             // org.mockito.internal.creation.instance.ConstructorInstantiator.withParams()
-            assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
+            assertThat(e)
+                    .hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
                     .hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
         }
     }
@@ -212,12 +206,15 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_report_private_abstract_inner_not_supported() throws Exception {
         try {
-            MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
+            MockitoAnnotations.openMocks(new WithInnerPrivateAbstract());
             fail();
         } catch (MockitoException e) {
-            assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
+            assertThat(e)
+                    .hasMessageContaining(
+                            "@Spy annotation can't initialize private abstract inner classes")
                     .hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
-                    .hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
+                    .hasMessageContaining(
+                            WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
                     .hasMessageContaining("You should augment the visibility of this inner class");
         }
     }
@@ -225,90 +222,86 @@ public class SpyAnnotationTest extends TestBase {
     @Test
     public void should_report_private_static_abstract_inner_not_supported() throws Exception {
         try {
-            MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
+            MockitoAnnotations.openMocks(new WithInnerPrivateStaticAbstract());
             fail();
         } catch (MockitoException e) {
-            assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
+            assertThat(e)
+                    .hasMessageContaining(
+                            "@Spy annotation can't initialize private abstract inner classes")
                     .hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
-                    .hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
+                    .hasMessageContaining(
+                            WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class
+                                    .getSimpleName())
                     .hasMessageContaining("You should augment the visibility of this inner class");
         }
     }
 
     @Test
     public void should_be_able_to_stub_and_verify_via_varargs_for_list_params() throws Exception {
-      // You can stub with varargs.
-      when(translator.translate("hello", "mockito")).thenReturn(Arrays.asList("you", "too"));
+        // You can stub with varargs.
+        when(translator.translate("hello", "mockito")).thenReturn(Arrays.asList("you", "too"));
 
-      // Pretend the prod code will call translate(List<String>) with these elements.
-      assertThat(translator.translate(Arrays.asList("hello", "mockito"))).containsExactly("you", "too");
-      assertThat(translator.translate(Arrays.asList("not stubbed"))).isEmpty();
+        // Pretend the prod code will call translate(List<String>) with these elements.
+        assertThat(translator.translate(Arrays.asList("hello", "mockito")))
+                .containsExactly("you", "too");
+        assertThat(translator.translate(Arrays.asList("not stubbed"))).isEmpty();
 
-      // You can verify with varargs.
-      verify(translator).translate("hello", "mockito");
+        // You can verify with varargs.
+        verify(translator).translate("hello", "mockito");
     }
 
     @Test
-    public void should_be_able_to_stub_and_verify_via_varargs_of_matchers_for_list_params() throws Exception {
-      // You can stub with varargs of matchers.
-      when(translator.translate(Mockito.anyString())).thenReturn(Arrays.asList("huh?"));
-      when(translator.translate(eq("hello"))).thenReturn(Arrays.asList("hi"));
-
-      // Pretend the prod code will call translate(List<String>) with these elements.
-      assertThat(translator.translate(Arrays.asList("hello"))).containsExactly("hi");
-      assertThat(translator.translate(Arrays.asList("not explicitly stubbed"))).containsExactly("huh?");
-
-      // You can verify with varargs of matchers.
-      verify(translator).translate(eq("hello"));
+    public void should_be_able_to_stub_and_verify_via_varargs_of_matchers_for_list_params()
+            throws Exception {
+        // You can stub with varargs of matchers.
+        when(translator.translate(Mockito.anyString())).thenReturn(Arrays.asList("huh?"));
+        when(translator.translate(eq("hello"))).thenReturn(Arrays.asList("hi"));
+
+        // Pretend the prod code will call translate(List<String>) with these elements.
+        assertThat(translator.translate(Arrays.asList("hello"))).containsExactly("hi");
+        assertThat(translator.translate(Arrays.asList("not explicitly stubbed")))
+                .containsExactly("huh?");
+
+        // You can verify with varargs of matchers.
+        verify(translator).translate(eq("hello"));
     }
 
     static class WithInnerPrivateStaticAbstract {
-        @Spy
-        private InnerPrivateStaticAbstract spy_field;
+        @Spy private InnerPrivateStaticAbstract spy_field;
 
-        private static abstract class InnerPrivateStaticAbstract {
-        }
+        private abstract static class InnerPrivateStaticAbstract {}
     }
+
     static class WithInnerPrivateAbstract {
-        @Spy
-        private InnerPrivateAbstract spy_field;
+        @Spy private InnerPrivateAbstract spy_field;
 
         public void some_method() {
             new InnerPrivateConcrete();
         }
 
-        private abstract class InnerPrivateAbstract {
-        }
-
-        private class InnerPrivateConcrete extends InnerPrivateAbstract {
+        private abstract class InnerPrivateAbstract {}
 
-        }
+        private class InnerPrivateConcrete extends InnerPrivateAbstract {}
     }
 
     static class WithInnerPrivate {
-        @Spy
-        private InnerPrivate spy_field;
+        @Spy private InnerPrivate spy_field;
 
-        private class InnerPrivate {
-        }
+        private class InnerPrivate {}
 
         private class InnerPrivateSub extends InnerPrivate {}
     }
 
-    static class InnerStaticClassWithoutDefinedConstructor {
-    }
+    static class InnerStaticClassWithoutDefinedConstructor {}
 
     static class InnerStaticClassWithNoArgConstructor {
-        InnerStaticClassWithNoArgConstructor() {
-        }
+        InnerStaticClassWithNoArgConstructor() {}
 
-        InnerStaticClassWithNoArgConstructor(String f) {
-        }
+        InnerStaticClassWithNoArgConstructor(String f) {}
     }
 
     static class NoValidConstructor {
-        NoValidConstructor(String f) {
-        }
+        NoValidConstructor(String f) {}
     }
 
     static class ThrowingConstructor {
@@ -318,14 +311,15 @@ public class SpyAnnotationTest extends TestBase {
     }
 
     interface Translator {
-      List<String> translate(List<String> messages);
+        List<String> translate(List<String> messages);
     }
 
-    static abstract class MockTranslator implements Translator {
-      @Override public final List<String> translate(List<String> messages) {
-        return translate(messages.toArray(new String[0]));
-      }
+    abstract static class MockTranslator implements Translator {
+        @Override
+        public final List<String> translate(List<String> messages) {
+            return translate(messages.toArray(new String[0]));
+        }
 
-      abstract List<String> translate(String... messages);
+        abstract List<String> translate(String... messages);
     }
 }
diff --git a/src/test/java/org/mockitousage/annotation/SpyInjectionTest.java b/src/test/java/org/mockitousage/annotation/SpyInjectionTest.java
index 32b37fd..9961e6e 100644
--- a/src/test/java/org/mockitousage/annotation/SpyInjectionTest.java
+++ b/src/test/java/org/mockitousage/annotation/SpyInjectionTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockitousage.annotation;
 
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.Spy;
 import org.mockito.internal.util.MockUtil;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-import java.util.List;
-
 public class SpyInjectionTest extends TestBase {
 
     @Spy List<Object> spy = new LinkedList<Object>();
@@ -20,6 +20,7 @@ public class SpyInjectionTest extends TestBase {
 
     static class HasSpy {
         private List<?> spy;
+
         public void setSpy(List<?> spy) {
             this.spy = spy;
         }
diff --git a/src/test/java/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java b/src/test/java/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java
index 05cf4f8..a2b1560 100644
--- a/src/test/java/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java
+++ b/src/test/java/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java
@@ -4,29 +4,41 @@
  */
 package org.mockitousage.annotation;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+
+import java.util.List;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.*;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-
 public class WrongSetOfAnnotationsTest extends TestBase {
 
-    @Test(expected=MockitoException.class)
-    public void should_not_allow_Mock_and_Spy() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @Mock @Spy List<?> mock;
-        });
+    @Test
+    public void should_not_allow_Mock_and_Spy() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(
+                                    new Object() {
+                                        @Mock @Spy List<?> mock;
+                                    });
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "This combination of annotations is not permitted on a single field:\n"
+                                + "@Spy and @Mock");
     }
 
     @Test
-    public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
+    public void should_not_allow_Spy_and_InjectMocks_on_interfaces() {
         try {
-            MockitoAnnotations.initMocks(new Object() { @InjectMocks @Spy List<?> mock; });
+            MockitoAnnotations.openMocks(
+                    new Object() {
+                        @InjectMocks @Spy List<?> mock;
+                    });
             fail();
         } catch (MockitoException me) {
             Assertions.assertThat(me.getMessage()).contains("'List' is an interface");
@@ -34,40 +46,75 @@ public class WrongSetOfAnnotationsTest extends TestBase {
     }
 
     @Test
-    public void should_allow_Spy_and_InjectMocks() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @InjectMocks
-            @Spy
-            WithDependency mock;
-        });
+    public void should_allow_Spy_and_InjectMocks() {
+        MockitoAnnotations.openMocks(
+                new Object() {
+                    @InjectMocks @Spy WithDependency mock;
+                });
     }
-    static class WithDependency { List<?> list; }
 
-    @Test(expected=MockitoException.class)
-    public void should_not_allow_Mock_and_InjectMocks() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @InjectMocks @Mock List<?> mock;
-        });
+    static class WithDependency {
+        List<?> list;
     }
 
-    @Test(expected=MockitoException.class)
-    public void should_not_allow_Captor_and_Mock() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @Mock @Captor ArgumentCaptor<?> captor;
-        });
+    @Test
+    public void should_not_allow_Mock_and_InjectMocks() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(
+                                    new Object() {
+                                        @InjectMocks @Mock List<?> mock;
+                                    });
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "This combination of annotations is not permitted on a single field:\n"
+                                + "@Mock and @InjectMocks");
     }
 
-    @Test(expected=MockitoException.class)
-    public void should_not_allow_Captor_and_Spy() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @Spy @Captor ArgumentCaptor<?> captor;
-        });
+    @Test
+    public void should_not_allow_Captor_and_Mock() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(
+                                    new Object() {
+                                        @Mock @Captor ArgumentCaptor<?> captor;
+                                    });
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "You cannot have more than one Mockito annotation on a field!",
+                        "The field 'captor' has multiple Mockito annotations.",
+                        "For info how to use annotations see examples in javadoc for MockitoAnnotations class.");
     }
 
-    @Test(expected=MockitoException.class)
-    public void should_not_allow_Captor_and_InjectMocks() throws Exception {
-        MockitoAnnotations.initMocks(new Object() {
-            @InjectMocks @Captor ArgumentCaptor<?> captor;
-        });
+    @Test
+    public void should_not_allow_Captor_and_Spy() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(
+                                    new Object() {
+                                        @Spy @Captor ArgumentCaptor<?> captor;
+                                    });
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "This combination of annotations is not permitted on a single field:\n"
+                                + "@Spy and @Captor");
+    }
+
+    @Test
+    public void should_not_allow_Captor_and_InjectMocks() {
+        assertThatThrownBy(
+                        () -> {
+                            MockitoAnnotations.openMocks(
+                                    new Object() {
+                                        @InjectMocks @Captor ArgumentCaptor<?> captor;
+                                    });
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessage(
+                        "This combination of annotations is not permitted on a single field:\n"
+                                + "@Captor and @InjectMocks");
     }
 }
diff --git a/src/test/java/org/mockitousage/annotation/org/mockito/DoNotMock.java b/src/test/java/org/mockitousage/annotation/org/mockito/DoNotMock.java
new file mode 100644
index 0000000..1dc4245
--- /dev/null
+++ b/src/test/java/org/mockitousage/annotation/org/mockito/DoNotMock.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.annotation.org.mockito;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Test to make sure that we are matching on name rather than only {@link org.mockito.DoNotMock}
+ * type equality.
+ */
+@Target({TYPE})
+@Retention(RUNTIME)
+public @interface DoNotMock {}
diff --git a/src/test/java/org/mockitousage/basicapi/MockAccessTest.java b/src/test/java/org/mockitousage/basicapi/MockAccessTest.java
index 84d45e7..13c0c74 100644
--- a/src/test/java/org/mockitousage/basicapi/MockAccessTest.java
+++ b/src/test/java/org/mockitousage/basicapi/MockAccessTest.java
@@ -4,15 +4,14 @@
  */
 package org.mockitousage.basicapi;
 
-
-import org.junit.Test;
-
-import java.util.Set;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import java.util.Set;
+
+import org.junit.Test;
+
 public class MockAccessTest {
 
     @Test
diff --git a/src/test/java/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java b/src/test/java/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java
index ae5edd5..f7c3b00 100644
--- a/src/test/java/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java
+++ b/src/test/java/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java
@@ -2,13 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockitousage.IMethods;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
@@ -16,19 +11,25 @@ import static org.mockito.Mockito.withSettings;
 import static org.mockitoutil.ClassLoaders.inMemoryClassLoader;
 import static org.mockitoutil.SimpleClassGenerator.makeMarkerInterface;
 
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockitousage.IMethods;
+
 // See issue 453
 public class MockingMultipleInterfacesTest {
 
     class Foo {}
+
     interface IFoo {}
+
     interface IBar {}
 
     @Test
     public void should_allow_multiple_interfaces() {
-        //when
+        // when
         Foo mock = mock(Foo.class, withSettings().extraInterfaces(IFoo.class, IBar.class));
 
-        //then
+        // then
         assertThat(mock).isInstanceOf(IFoo.class);
         assertThat(mock).isInstanceOf(IBar.class);
     }
@@ -36,47 +37,50 @@ public class MockingMultipleInterfacesTest {
     @Test
     public void should_scream_when_null_passed_instead_of_an_interface() {
         try {
-            //when
+            // when
             mock(Foo.class, withSettings().extraInterfaces(IFoo.class, null));
             fail();
         } catch (MockitoException e) {
-            //then
-            assertThat(e.getMessage()).contains("extraInterfaces() does not accept null parameters");
+            // then
+            assertThat(e.getMessage())
+                    .contains("extraInterfaces() does not accept null parameters");
         }
     }
 
     @Test
     public void should_scream_when_no_args_passed() {
         try {
-            //when
+            // when
             mock(Foo.class, withSettings().extraInterfaces());
             fail();
         } catch (MockitoException e) {
-            //then
-            assertThat(e.getMessage()).contains("extraInterfaces() requires at least one interface");
+            // then
+            assertThat(e.getMessage())
+                    .contains("extraInterfaces() requires at least one interface");
         }
     }
 
     @Test
     public void should_scream_when_null_passed_instead_of_an_array() {
         try {
-            //when
+            // when
             mock(Foo.class, withSettings().extraInterfaces((Class[]) null));
             fail();
         } catch (MockitoException e) {
-            //then
-            assertThat(e.getMessage()).contains("extraInterfaces() requires at least one interface");
+            // then
+            assertThat(e.getMessage())
+                    .contains("extraInterfaces() requires at least one interface");
         }
     }
 
     @Test
     public void should_scream_when_non_interface_passed() {
         try {
-            //when
+            // when
             mock(Foo.class, withSettings().extraInterfaces(Foo.class));
             fail();
         } catch (MockitoException e) {
-            //then
+            // then
             assertThat(e.getMessage()).contains("Foo which is not an interface");
         }
     }
@@ -84,29 +88,37 @@ public class MockingMultipleInterfacesTest {
     @Test
     public void should_scream_when_the_same_interfaces_passed() {
         try {
-            //when
+            // when
             mock(IMethods.class, withSettings().extraInterfaces(IMethods.class));
             fail();
         } catch (MockitoException e) {
-            //then
+            // then
             assertThat(e.getMessage()).contains("You mocked following type: IMethods");
         }
     }
 
-
     @Test
-    public void should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths() throws ClassNotFoundException {
-        // Note : if classes are in the same classpath, SearchingClassLoader can find the class/classes and load them in the first matching classloader
-        Class<?> interface1 = inMemoryClassLoader()
-                .withClassDefinition("test.Interface1", makeMarkerInterface("test.Interface1"))
-                .build()
-                .loadClass("test.Interface1");
-        Class<?> interface2 = inMemoryClassLoader()
-                .withClassDefinition("test.Interface2", makeMarkerInterface("test.Interface2"))
-                .build()
-                .loadClass("test.Interface2");
+    public void
+            should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths()
+                    throws ClassNotFoundException {
+        // Note : if classes are in the same classpath, SearchingClassLoader can find the
+        // class/classes and load them in the first matching classloader
+        Class<?> interface1 =
+                inMemoryClassLoader()
+                        .withClassDefinition(
+                                "test.Interface1", makeMarkerInterface("test.Interface1"))
+                        .build()
+                        .loadClass("test.Interface1");
+        Class<?> interface2 =
+                inMemoryClassLoader()
+                        .withClassDefinition(
+                                "test.Interface2", makeMarkerInterface("test.Interface2"))
+                        .build()
+                        .loadClass("test.Interface2");
 
         Object mocked = mock(interface1, withSettings().extraInterfaces(interface2));
-        assertThat(interface2.isInstance(mocked)).describedAs("mock should be assignable from interface2 type").isTrue();
+        assertThat(interface2.isInstance(mocked))
+                .describedAs("mock should be assignable from interface2 type")
+                .isTrue();
     }
 }
diff --git a/src/test/java/org/mockitousage/basicapi/MocksCreationTest.java b/src/test/java/org/mockitousage/basicapi/MocksCreationTest.java
index b5892ef..241c775 100644
--- a/src/test/java/org/mockitousage/basicapi/MocksCreationTest.java
+++ b/src/test/java/org/mockitousage/basicapi/MocksCreationTest.java
@@ -2,22 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.verification.SmartNullPointerException;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -28,6 +14,19 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.SmartNullPointerException;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
 @SuppressWarnings("unchecked")
 public class MocksCreationTest extends TestBase {
 
@@ -40,62 +39,66 @@ public class MocksCreationTest extends TestBase {
 
     @Test
     public void should_combine_mock_name_and_smart_nulls() {
-        //given
-        IMethods mock = mock(IMethods.class, withSettings()
-            .defaultAnswer(RETURNS_SMART_NULLS)
-            .name("great mockie"));
+        // given
+        IMethods mock =
+                mock(
+                        IMethods.class,
+                        withSettings().defaultAnswer(RETURNS_SMART_NULLS).name("great mockie"));
 
-        //when
+        // when
         IMethods smartNull = mock.iMethodsReturningMethod();
         String name = mock.toString();
 
-        //then
+        // then
         assertThat(name).contains("great mockie");
-        //and
+        // and
         try {
             smartNull.simpleMethod();
             fail();
-        } catch(SmartNullPointerException e) {}
+        } catch (SmartNullPointerException e) {
+        }
     }
 
     @Test
     public void should_combine_mock_name_and_extra_interfaces() {
-        //given
-        IMethods mock = mock(IMethods.class, withSettings()
-                .extraInterfaces(List.class)
-                .name("great mockie"));
+        // given
+        IMethods mock =
+                mock(
+                        IMethods.class,
+                        withSettings().extraInterfaces(List.class).name("great mockie"));
 
-        //when
+        // when
         String name = mock.toString();
 
-        //then
+        // then
         assertThat(name).contains("great mockie");
-        //and
+        // and
         assertTrue(mock instanceof List);
     }
 
     @Test
     public void should_specify_mock_name_via_settings() {
-        //given
+        // given
         IMethods mock = mock(IMethods.class, withSettings().name("great mockie"));
 
-        //when
+        // when
         String name = mock.toString();
 
-        //then
+        // then
         assertThat(name).contains("great mockie");
     }
 
     @Test
     public void should_scream_when_spy_created_with_wrong_type() {
-        //given
+        // given
         List list = new LinkedList();
         try {
-            //when
+            // when
             mock(List.class, withSettings().spiedInstance(list));
             fail();
-            //then
-        } catch (MockitoException e) {}
+            // then
+        } catch (MockitoException e) {
+        }
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
@@ -113,14 +116,15 @@ public class MocksCreationTest extends TestBase {
     @Retention(RetentionPolicy.RUNTIME)
     @interface SomeAnnotation {}
 
-    @SomeAnnotation static class Foo {}
+    @SomeAnnotation
+    static class Foo {}
 
     @Test
     public void should_strip_annotations() {
         Foo withAnnotations = mock(Foo.class);
         Foo withoutAnnotations = mock(Foo.class, withSettings().withoutAnnotations());
 
-        //expect:
+        // expect:
         assertTrue(withAnnotations.getClass().isAnnotationPresent(SomeAnnotation.class));
         assertFalse(withoutAnnotations.getClass().isAnnotationPresent(SomeAnnotation.class));
     }
diff --git a/src/test/java/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java b/src/test/java/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java
index 31cdd04..736de4e 100644
--- a/src/test/java/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java
+++ b/src/test/java/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java
@@ -2,9 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+import static org.mockitoutil.SimpleSerializationUtil.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Serializable;
+import java.util.Collections;
+import java.util.List;
+import java.util.Observable;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -17,35 +26,39 @@ import org.mockito.stubbing.Answer;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.io.ByteArrayOutputStream;
-import java.io.Serializable;
-import java.util.Collections;
-import java.util.List;
-import java.util.Observable;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-import static org.mockitoutil.SimpleSerializationUtil.*;
-
 @SuppressWarnings({"unchecked", "serial"})
 public class MocksSerializationForAnnotationTest extends TestBase implements Serializable {
 
     private static final long serialVersionUID = 6160482220413048624L;
 
     @Mock Any any;
-    @Mock(serializable=true) Bar barMock;
-    @Mock(serializable=true) IMethods imethodsMock;
-    @Mock(serializable=true) IMethods imethodsMock2;
-    @Mock(serializable=true) Any anyMock;
-    @Mock(serializable=true) AlreadySerializable alreadySerializableMock;
-    @Mock(extraInterfaces={List.class},serializable=true) IMethods imethodsWithExtraInterfacesMock;
+
+    @Mock(serializable = true)
+    Bar barMock;
+
+    @Mock(serializable = true)
+    IMethods imethodsMock;
+
+    @Mock(serializable = true)
+    IMethods imethodsMock2;
+
+    @Mock(serializable = true)
+    Any anyMock;
+
+    @Mock(serializable = true)
+    AlreadySerializable alreadySerializableMock;
+
+    @Mock(
+            extraInterfaces = {List.class},
+            serializable = true)
+    IMethods imethodsWithExtraInterfacesMock;
 
     @Test
     public void should_allow_throws_exception_to_be_serializable() throws Exception {
         // given
         when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));
 
-        //when-serialize then-deserialize
+        // when-serialize then-deserialize
         serializeAndBack(barMock);
     }
 
@@ -97,7 +110,8 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
     }
 
     @Test
-    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {
+    public void should_serialize_method_call_with_parameters_that_are_serializable()
+            throws Exception {
         List<?> value = Collections.emptyList();
         when(imethodsMock.objectArgMethod(value)).thenReturn(value);
 
@@ -148,8 +162,9 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
         // then
         verify(readObject, times(2)).simpleMethod(1);
 
-        //this test is working because it seems that java serialization mechanism replaces all instances
-        //of serialized object in the object graph (if there are any)
+        // this test is working because it seems that java serialization mechanism replaces all
+        // instances
+        // of serialized object in the object graph (if there are any)
     }
 
     class Bar implements Serializable {
@@ -162,6 +177,7 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
 
     class Foo implements Serializable {
         Bar bar;
+
         Foo() {
             bar = new Bar();
             bar.foo = this;
@@ -170,17 +186,17 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
 
     @Test
     public void should_serialization_work() throws Exception {
-        //given
+        // given
         Foo foo = new Foo();
-        //when
+        // when
         foo = serializeAndBack(foo);
-        //then
+        // then
         assertSame(foo, foo.bar.foo);
     }
 
     @Test
     public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {
-        //given
+        // given
         // when
         when(imethodsMock.simpleMethod(1)).thenReturn("foo");
         ByteArrayOutputStream serialized = serializeMock(imethodsMock);
@@ -228,7 +244,7 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
 
         // given
         CustomAnswersMustImplementSerializableForSerializationToWork answer =
-            new CustomAnswersMustImplementSerializableForSerializationToWork();
+                new CustomAnswersMustImplementSerializableForSerializationToWork();
         answer.string = "return value";
         when(imethodsMock.objectArgMethod(anyString())).thenAnswer(answer);
 
@@ -241,8 +257,9 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
     }
 
     static class CustomAnswersMustImplementSerializableForSerializationToWork
-        implements Answer<Object>, Serializable {
+            implements Answer<Object>, Serializable {
         private String string;
+
         public Object answer(InvocationOnMock invocation) throws Throwable {
             invocation.getArguments();
             invocation.getMock();
@@ -254,10 +271,13 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
     public void should_serialize_with_real_object_spy() throws Exception {
         // given
         SerializableSample list = new SerializableSample();
-        SerializableSample spy = mock(SerializableSample.class, withSettings()
-                        .spiedInstance(list)
-                        .defaultAnswer(CALLS_REAL_METHODS)
-                        .serializable());
+        SerializableSample spy =
+                mock(
+                        SerializableSample.class,
+                        withSettings()
+                                .spiedInstance(list)
+                                .defaultAnswer(CALLS_REAL_METHODS)
+                                .serializable());
         when(spy.foo()).thenReturn("foo");
 
         // when
@@ -280,7 +300,7 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
     @Test
     public void should_serialize_real_partial_mock() throws Exception {
         // given
-        when(anyMock.matches(anyObject())).thenCallRealMethod();
+        when(anyMock.matches(any())).thenCallRealMethod();
 
         // when
         ByteArrayOutputStream serialized = serializeMock(anyMock);
@@ -306,29 +326,35 @@ public class MocksSerializationForAnnotationTest extends TestBase implements Ser
 
     @Test
     public void should_be_serialize_and_have_extra_interfaces() throws Exception {
-        //then
+        // then
         Assertions.assertThat((Object) serializeAndBack((List) imethodsWithExtraInterfacesMock))
                 .isInstanceOf(List.class)
                 .isInstanceOf(IMethods.class);
     }
 
     static class NotSerializableAndNoDefaultConstructor {
-        NotSerializableAndNoDefaultConstructor(Observable o) { super(); }
+        NotSerializableAndNoDefaultConstructor(Observable o) {
+            super();
+        }
     }
 
     static class SerializableAndNoDefaultConstructor implements Serializable {
-        SerializableAndNoDefaultConstructor(Observable o) { super(); }
+        SerializableAndNoDefaultConstructor(Observable o) {
+            super();
+        }
     }
 
     public static class TestClassThatHoldValidField {
-        @Mock(serializable=true)
+        @Mock(serializable = true)
         SerializableAndNoDefaultConstructor serializableAndNoDefaultConstructor;
     }
 
     @Test
-    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {
+    public void
+            should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor()
+                    throws Exception {
         TestClassThatHoldValidField testClass = new TestClassThatHoldValidField();
-        MockitoAnnotations.initMocks(testClass);
+        MockitoAnnotations.openMocks(testClass);
 
         serializeAndBack(testClass.serializableAndNoDefaultConstructor);
     }
diff --git a/src/test/java/org/mockitousage/basicapi/MocksSerializationTest.java b/src/test/java/org/mockitousage/basicapi/MocksSerializationTest.java
index 02bcc3d..0bd6d5b 100644
--- a/src/test/java/org/mockitousage/basicapi/MocksSerializationTest.java
+++ b/src/test/java/org/mockitousage/basicapi/MocksSerializationTest.java
@@ -2,9 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
+import static org.junit.Assert.*;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.*;
+import static org.mockitoutil.SimpleSerializationUtil.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.util.Collections;
+import java.util.List;
+import java.util.Observable;
+
 import net.bytebuddy.ClassFileVersion;
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
@@ -18,18 +29,6 @@ import org.mockitousage.IMethods;
 import org.mockitoutil.SimpleSerializationUtil;
 import org.mockitoutil.TestBase;
 
-import java.io.ByteArrayOutputStream;
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.util.Collections;
-import java.util.List;
-import java.util.Observable;
-
-import static org.junit.Assert.*;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.*;
-import static org.mockitoutil.SimpleSerializationUtil.*;
-
 @SuppressWarnings({"unchecked", "serial"})
 public class MocksSerializationTest extends TestBase implements Serializable {
 
@@ -50,7 +49,7 @@ public class MocksSerializationTest extends TestBase implements Serializable {
         Foo fooMock = mock(Foo.class);
         when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));
 
-        //when-serialize then-deserialize
+        // when-serialize then-deserialize
         serializeAndBack(barMock);
     }
 
@@ -108,7 +107,8 @@ public class MocksSerializationTest extends TestBase implements Serializable {
     }
 
     @Test
-    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {
+    public void should_serialize_method_call_with_parameters_that_are_serializable()
+            throws Exception {
         IMethods mock = mock(IMethods.class, withSettings().serializable());
         List<?> value = Collections.emptyList();
         when(mock.objectArgMethod(value)).thenReturn(value);
@@ -152,7 +152,7 @@ public class MocksSerializationTest extends TestBase implements Serializable {
 
     @Test
     public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {
-        //given
+        // given
         IMethods mock = mock(IMethods.class, withSettings().serializable());
 
         // when
@@ -164,8 +164,9 @@ public class MocksSerializationTest extends TestBase implements Serializable {
         // then
         verify(readObject, times(2)).simpleMethod(1);
 
-        //this test is working because it seems that java serialization mechanism replaces all instances
-        //of serialized object in the object graph (if there are any)
+        // this test is working because it seems that java serialization mechanism replaces all
+        // instances
+        // of serialized object in the object graph (if there are any)
     }
 
     class Bar implements Serializable {
@@ -178,6 +179,7 @@ public class MocksSerializationTest extends TestBase implements Serializable {
 
     class Foo implements Serializable {
         Bar bar;
+
         Foo() {
             bar = new Bar();
             bar.foo = this;
@@ -186,17 +188,17 @@ public class MocksSerializationTest extends TestBase implements Serializable {
 
     @Test
     public void should_serialization_work() throws Exception {
-        //given
+        // given
         Foo foo = new Foo();
-        //when
+        // when
         foo = serializeAndBack(foo);
-        //then
+        // then
         assertSame(foo, foo.bar.foo);
     }
 
     @Test
     public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {
-        //given
+        // given
         IMethods mock = mock(IMethods.class, withSettings().serializable());
 
         // when
@@ -265,6 +267,7 @@ public class MocksSerializationTest extends TestBase implements Serializable {
     class CustomAnswersMustImplementSerializableForSerializationToWork
             implements Answer<Object>, Serializable {
         private String string;
+
         public Object answer(InvocationOnMock invocation) throws Throwable {
             invocation.getArguments();
             invocation.getMock();
@@ -276,10 +279,13 @@ public class MocksSerializationTest extends TestBase implements Serializable {
     public void should_serialize_with_real_object_spy() throws Exception {
         // given
         SerializableClass sample = new SerializableClass();
-        SerializableClass spy = mock(SerializableClass.class, withSettings()
-                .spiedInstance(sample)
-                .defaultAnswer(CALLS_REAL_METHODS)
-                .serializable());
+        SerializableClass spy =
+                mock(
+                        SerializableClass.class,
+                        withSettings()
+                                .spiedInstance(sample)
+                                .defaultAnswer(CALLS_REAL_METHODS)
+                                .serializable());
         when(spy.foo()).thenReturn("foo");
 
         // when
@@ -306,7 +312,7 @@ public class MocksSerializationTest extends TestBase implements Serializable {
     public void should_serialize_real_partial_mock() throws Exception {
         // given
         Any mock = mock(Any.class, withSettings().serializable());
-        when(mock.matches(anyObject())).thenCallRealMethod();
+        when(mock.matches(any())).thenCallRealMethod();
 
         // when
         ByteArrayOutputStream serialized = serializeMock(mock);
@@ -333,11 +339,13 @@ public class MocksSerializationTest extends TestBase implements Serializable {
 
     @Test
     public void should_be_serialize_and_have_extra_interfaces() throws Exception {
-        //when
-        IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));
-        IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());
+        // when
+        IMethods mock =
+                mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));
+        IMethods mockTwo =
+                mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());
 
-        //then
+        // then
         Assertions.assertThat((Object) serializeAndBack((List) mock))
                 .isInstanceOf(List.class)
                 .isInstanceOf(IMethods.class);
@@ -347,28 +355,34 @@ public class MocksSerializationTest extends TestBase implements Serializable {
     }
 
     static class SerializableAndNoDefaultConstructor implements Serializable {
-        SerializableAndNoDefaultConstructor(Observable o) { super(); }
+        SerializableAndNoDefaultConstructor(Observable o) {
+            super();
+        }
     }
 
     @Test
-    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {
+    public void
+            should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor()
+                    throws Exception {
         serializeAndBack(mock(SerializableAndNoDefaultConstructor.class));
     }
 
-
-
     public static class AClassWithPrivateNoArgConstructor {
         private AClassWithPrivateNoArgConstructor() {}
-        List returningSomething() { return Collections.emptyList(); }
+
+        List returningSomething() {
+            return Collections.emptyList();
+        }
     }
 
     @Test
-    public void private_constructor_currently_not_supported_at_the_moment_at_deserialization_time() throws Exception {
+    public void private_constructor_currently_not_supported_at_the_moment_at_deserialization_time()
+            throws Exception {
         // given
-        AClassWithPrivateNoArgConstructor mockWithPrivateConstructor = Mockito.mock(
-                AClassWithPrivateNoArgConstructor.class,
-                Mockito.withSettings().serializable()
-        );
+        AClassWithPrivateNoArgConstructor mockWithPrivateConstructor =
+                Mockito.mock(
+                        AClassWithPrivateNoArgConstructor.class,
+                        Mockito.withSettings().serializable());
 
         try {
             // when
@@ -380,14 +394,17 @@ public class MocksSerializationTest extends TestBase implements Serializable {
         }
     }
 
-
     @Test
     public void BUG_ISSUE_399_try_some_mocks_with_current_answers() throws Exception {
         assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V7));
 
-        IMethods iMethods = mock(IMethods.class, withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));
+        IMethods iMethods =
+                mock(
+                        IMethods.class,
+                        withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));
 
-        when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString())).thenReturn(false);
+        when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString()))
+                .thenReturn(false);
 
         serializeAndBack(iMethods);
     }
diff --git a/src/test/java/org/mockitousage/basicapi/ObjectsSerializationTest.java b/src/test/java/org/mockitousage/basicapi/ObjectsSerializationTest.java
index 6ada79d..c3c668c 100644
--- a/src/test/java/org/mockitousage/basicapi/ObjectsSerializationTest.java
+++ b/src/test/java/org/mockitousage/basicapi/ObjectsSerializationTest.java
@@ -2,25 +2,27 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertSame;
+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
 
 import java.io.Serializable;
 
-import static org.junit.Assert.assertSame;
-import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("serial")
 public class ObjectsSerializationTest extends TestBase implements Serializable {
 
-    //Ok, this test has nothing to do with mocks but it shows fundamental feature of java serialization that
-    //plays important role in mocking:
-    //Serialization/deserialization actually replaces all instances of serialized object in the object graph (if there are any)
-    //thanks to that mechanizm, stubbing & verification can correctly match method invocations because
-    //one of the parts of invocation matching is checking if mock object is the same
+    // Ok, this test has nothing to do with mocks but it shows fundamental feature of java
+    // serialization that
+    // plays important role in mocking:
+    // Serialization/deserialization actually replaces all instances of serialized object in the
+    // object graph (if there are any)
+    // thanks to that mechanizm, stubbing & verification can correctly match method invocations
+    // because
+    // one of the parts of invocation matching is checking if mock object is the same
 
     class Bar implements Serializable {
         Foo foo;
@@ -28,6 +30,7 @@ public class ObjectsSerializationTest extends TestBase implements Serializable {
 
     class Foo implements Serializable {
         Bar bar;
+
         Foo() {
             bar = new Bar();
             bar.foo = this;
@@ -36,11 +39,11 @@ public class ObjectsSerializationTest extends TestBase implements Serializable {
 
     @Test
     public void shouldSerializationWork() throws Exception {
-        //given
+        // given
         Foo foo = new Foo();
-        //when
+        // when
         foo = serializeAndBack(foo);
-        //then
+        // then
         assertSame(foo, foo.bar.foo);
     }
 }
diff --git a/src/test/java/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java b/src/test/java/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java
index 52be3ff..72903f9 100644
--- a/src/test/java/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java
+++ b/src/test/java/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java
@@ -2,28 +2,30 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 public class ReplacingObjectMethodsTest extends TestBase {
 
     private interface DummyInterface {}
+
     private class DummyClass {}
 
     @Test
     public void shouldProvideMockyImplementationOfToString() {
         DummyClass dummyClass = Mockito.mock(DummyClass.class);
-        assertEquals("Mock for DummyClass, hashCode: " + dummyClass.hashCode(), dummyClass.toString());
+        assertEquals(
+                "Mock for DummyClass, hashCode: " + dummyClass.hashCode(), dummyClass.toString());
         DummyInterface dummyInterface = Mockito.mock(DummyInterface.class);
-        assertEquals("Mock for DummyInterface, hashCode: " + dummyInterface.hashCode(), dummyInterface.toString());
+        assertEquals(
+                "Mock for DummyInterface, hashCode: " + dummyInterface.hashCode(),
+                dummyInterface.toString());
     }
 
     @Test
@@ -52,16 +54,20 @@ public class ReplacingObjectMethodsTest extends TestBase {
 
     public static class ObjectMethodsOverridden {
         public boolean equals(Object o) {
-            throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");
+            throw new RuntimeException(
+                    "Should not be called. MethodInterceptorFilter provides implementation");
         }
+
         public int hashCode() {
-            throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");
+            throw new RuntimeException(
+                    "Should not be called. MethodInterceptorFilter provides implementation");
         }
+
         public String toString() {
-            throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");
+            throw new RuntimeException(
+                    "Should not be called. MethodInterceptorFilter provides implementation");
         }
     }
 
-    public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {
-    }
+    public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {}
 }
diff --git a/src/test/java/org/mockitousage/basicapi/ResetInvocationsTest.java b/src/test/java/org/mockitousage/basicapi/ResetInvocationsTest.java
index d9ad35d..580f055 100644
--- a/src/test/java/org/mockitousage/basicapi/ResetInvocationsTest.java
+++ b/src/test/java/org/mockitousage/basicapi/ResetInvocationsTest.java
@@ -4,22 +4,24 @@
  */
 package org.mockitousage.basicapi;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.clearInvocations;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
-
 public class ResetInvocationsTest extends TestBase {
 
-    @Mock
-    IMethods methods;
+    @Mock IMethods methods;
 
-    @Mock
-    IMethods moarMethods;
+    @Mock IMethods moarMethods;
 
     @Test
     public void reset_invocations_should_reset_only_invocations() {
@@ -44,13 +46,23 @@ public class ResetInvocationsTest extends TestBase {
         verifyNoMoreInteractions(methods, moarMethods);
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void resettingNonMockIsSafe() {
-        clearInvocations("");
+        assertThatThrownBy(
+                        () -> {
+                            clearInvocations("");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is: class java.lang.String");
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void resettingNullIsSafe() {
-        clearInvocations(new Object[]{null});
+        assertThatThrownBy(
+                        () -> {
+                            clearInvocations(new Object[] {null});
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is null!");
     }
 }
diff --git a/src/test/java/org/mockitousage/basicapi/ResetTest.java b/src/test/java/org/mockitousage/basicapi/ResetTest.java
index ef199a5..72db5c7 100644
--- a/src/test/java/org/mockitousage/basicapi/ResetTest.java
+++ b/src/test/java/org/mockitousage/basicapi/ResetTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockitousage.basicapi;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.misusing.MissingMethodInvocationException;
@@ -12,17 +17,11 @@ import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class ResetTest extends TestBase {
 
-    @Mock
-    private IMethods mock;
+    @Mock private IMethods mock;
 
-    @Mock
-    private IMethods mockTwo;
+    @Mock private IMethods mockTwo;
 
     @Test
     public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised() {
@@ -35,34 +34,52 @@ public class ResetTest extends TestBase {
         }
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void resettingNonMockIsSafe() {
-        reset("");
+        assertThatThrownBy(
+                        () -> {
+                            reset("");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is: class java.lang.String");
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void resettingNullIsSafe() {
-        reset(new Object[]{null});
+        assertThatThrownBy(
+                        () -> {
+                            reset(new Object[] {null});
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is null!");
     }
 
     @Test
-    public void shouldRemoveAllStubbing() throws Exception {
+    public void shouldRemoveAllStubbing() {
         when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);
         when(mock.objectReturningMethod(200)).thenReturn(200);
         reset(mock);
         assertNull(mock.objectReturningMethod(200));
-        assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));
+        assertEquals(
+                "default behavior should return null", null, mock.objectReturningMethod("blah"));
+    }
+
+    @Test
+    public void shouldRemoveAllInteractions() {
+        mock.simpleMethod(1);
+        reset(mock);
+        verifyNoInteractions(mock);
     }
 
     @Test
-    public void shouldRemoveAllInteractions() throws Exception {
+    public void shouldRemoveAllInteractionsVerifyNoInteractions() {
         mock.simpleMethod(1);
         reset(mock);
-        verifyZeroInteractions(mock);
+        verifyNoInteractions(mock);
     }
 
     @Test
-    public void shouldRemoveStubbingToString() throws Exception {
+    public void shouldRemoveStubbingToString() {
         IMethods mockTwo = mock(IMethods.class);
         when(mockTwo.toString()).thenReturn("test");
         reset(mockTwo);
@@ -70,11 +87,11 @@ public class ResetTest extends TestBase {
     }
 
     @Test
-    public void shouldStubbingNotBeTreatedAsInteraction() {
+    public void shouldStubbingNotBeTreatedAsInteractionVerifyNoInteractions() {
         when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
         doThrow(new RuntimeException()).when(mock).simpleMethod("two");
         reset(mock);
-        verifyZeroInteractions(mock);
+        verifyNoInteractions(mock);
     }
 
     @Test
@@ -97,7 +114,7 @@ public class ResetTest extends TestBase {
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
     @Test
     public void shouldValidateStateWhenResetting() {
-        //invalid verify:
+        // invalid verify:
         verify(mock);
 
         try {
@@ -109,11 +126,11 @@ public class ResetTest extends TestBase {
 
     @Test
     public void shouldMaintainPreviousDefaultAnswer() {
-        //given
+        // given
         mock = mock(IMethods.class, RETURNS_MOCKS);
-        //when
+        // when
         reset(mock);
-        //then
+        // then
         assertNotNull(mock.iMethodsReturningMethod());
     }
 }
diff --git a/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java b/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
index 3e4faaf..551c637 100644
--- a/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
+++ b/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
@@ -2,30 +2,33 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.basicapi;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
+import java.util.ArrayList;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitoutil.TestBase;
 
-import java.util.ArrayList;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class UsingVarargsTest extends TestBase {
 
     private interface IVarArgs {
         void withStringVarargs(int value, String... s);
+
         String withStringVarargsReturningString(int value, String... s);
+
         void withObjectVarargs(int value, Object... o);
+
         boolean withBooleanVarargs(int value, boolean... b);
-        int foo(Object ... objects);
+
+        int foo(Object... objects);
     }
 
     @Mock IVarArgs mock;
@@ -83,7 +86,8 @@ public class UsingVarargsTest extends TestBase {
         try {
             verify(mock).withStringVarargs(2, "1", "2", "79", "4");
             fail();
-        } catch (ArgumentsAreDifferent e) {}
+        } catch (ArgumentsAreDifferent e) {
+        }
     }
 
     @Test
@@ -97,7 +101,8 @@ public class UsingVarargsTest extends TestBase {
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -111,22 +116,23 @@ public class UsingVarargsTest extends TestBase {
         try {
             verify(mock).withBooleanVarargs(3, true, true, true, true);
             fail();
-        } catch (ArgumentsAreDifferent e) {}
+        } catch (ArgumentsAreDifferent e) {
+        }
     }
 
     @Test
-    public void shouldVerifyWithAnyObject() {
+    public void shouldVerifyWithAny() {
         Foo foo = Mockito.mock(Foo.class);
         foo.varArgs("");
-        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());
-        Mockito.verify(foo).varArgs((String) Mockito.anyObject());
+        Mockito.verify(foo).varArgs((String[]) Mockito.any());
+        Mockito.verify(foo).varArgs((String) Mockito.any());
     }
 
     @Test
     public void shouldVerifyWithNullVarArgArray() {
         Foo foo = Mockito.mock(Foo.class);
         foo.varArgs((String[]) null);
-        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());
+        Mockito.verify(foo).varArgs((String[]) Mockito.any());
         Mockito.verify(foo).varArgs((String[]) null);
     }
 
@@ -136,41 +142,42 @@ public class UsingVarargsTest extends TestBase {
 
     interface MixedVarargs {
         String doSomething(String one, String... varargs);
+
         String doSomething(String one, String two, String... varargs);
     }
 
     @SuppressWarnings("all")
     @Test
-    //See bug #31
+    // See bug #31
     public void shouldStubCorrectlyWhenMixedVarargsUsed() {
         MixedVarargs mixedVarargs = mock(MixedVarargs.class);
-        when(mixedVarargs.doSomething("hello", (String[])null)).thenReturn("hello");
-        when(mixedVarargs.doSomething("goodbye", (String[])null)).thenReturn("goodbye");
+        when(mixedVarargs.doSomething("hello", (String[]) null)).thenReturn("hello");
+        when(mixedVarargs.doSomething("goodbye", (String[]) null)).thenReturn("goodbye");
 
-        String result = mixedVarargs.doSomething("hello",(String[]) null);
+        String result = mixedVarargs.doSomething("hello", (String[]) null);
         assertEquals("hello", result);
 
-        verify(mixedVarargs).doSomething("hello", (String[])null);
+        verify(mixedVarargs).doSomething("hello", (String[]) null);
     }
 
     @SuppressWarnings("all")
     @Test
     public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {
         MixedVarargs mixedVarargs = mock(MixedVarargs.class);
-        when(mixedVarargs.doSomething("one", "two", (String[])null)).thenReturn("hello");
-        when(mixedVarargs.doSomething("1", "2", (String[])null)).thenReturn("goodbye");
+        when(mixedVarargs.doSomething("one", "two", (String[]) null)).thenReturn("hello");
+        when(mixedVarargs.doSomething("1", "2", (String[]) null)).thenReturn("goodbye");
 
-        String result = mixedVarargs.doSomething("one", "two", (String[])null);
+        String result = mixedVarargs.doSomething("one", "two", (String[]) null);
         assertEquals("hello", result);
     }
 
     @Test
-    //See bug #157
+    // See bug #157
     public void shouldMatchEasilyEmptyVararg() throws Exception {
-        //when
-        when(mock.foo(anyVararg())).thenReturn(-1);
+        // when
+        when(mock.foo(any())).thenReturn(-1);
 
-        //then
+        // then
         assertEquals(-1, mock.foo());
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/AIOOBExceptionWithAtLeastTest.java b/src/test/java/org/mockitousage/bugs/AIOOBExceptionWithAtLeastTest.java
index 58c83f5..f712724 100644
--- a/src/test/java/org/mockitousage/bugs/AIOOBExceptionWithAtLeastTest.java
+++ b/src/test/java/org/mockitousage/bugs/AIOOBExceptionWithAtLeastTest.java
@@ -2,20 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
-//see bug 116
+// see bug 116
 public class AIOOBExceptionWithAtLeastTest extends TestBase {
 
     interface IProgressMonitor {
         void beginTask(String s, int i);
+
         void worked(int i);
+
         void done();
     }
 
diff --git a/src/test/java/org/mockitousage/bugs/ActualInvocationHasNullArgumentNPEBugTest.java b/src/test/java/org/mockitousage/bugs/ActualInvocationHasNullArgumentNPEBugTest.java
index 632c8c9..ac46998 100644
--- a/src/test/java/org/mockitousage/bugs/ActualInvocationHasNullArgumentNPEBugTest.java
+++ b/src/test/java/org/mockitousage/bugs/ActualInvocationHasNullArgumentNPEBugTest.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.*;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class ActualInvocationHasNullArgumentNPEBugTest extends TestBase {
 
     public interface Fun {
@@ -19,18 +18,18 @@ public class ActualInvocationHasNullArgumentNPEBugTest extends TestBase {
 
     @Test
     public void shouldAllowPassingNullArgument() {
-        //given
+        // given
         Fun mockFun = mock(Fun.class);
-        when(mockFun.doFun((String) anyObject())).thenReturn("value");
+        when(mockFun.doFun((String) any())).thenReturn("value");
 
-        //when
+        // when
         mockFun.doFun(null);
 
-        //then
+        // then
         try {
             verify(mockFun).doFun("hello");
-        } catch(AssertionError r) {
-            //it's ok, we just want to reproduce the bug
+        } catch (AssertionError r) {
+            // it's ok, we just want to reproduce the bug
             return;
         }
         fail();
diff --git a/src/test/java/org/mockitousage/bugs/ArgumentCaptorDontCapturePreviouslyVerifiedTest.java b/src/test/java/org/mockitousage/bugs/ArgumentCaptorDontCapturePreviouslyVerifiedTest.java
index 78181b2..0e6fcb3 100644
--- a/src/test/java/org/mockitousage/bugs/ArgumentCaptorDontCapturePreviouslyVerifiedTest.java
+++ b/src/test/java/org/mockitousage/bugs/ArgumentCaptorDontCapturePreviouslyVerifiedTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockitousage.IMethods;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockitousage.IMethods;
+
 public class ArgumentCaptorDontCapturePreviouslyVerifiedTest {
     @Test
     public void previous_verified_invocation_should_still_capture_args() {
diff --git a/src/test/java/org/mockitousage/bugs/AtLeastMarksAllInvocationsVerified.java b/src/test/java/org/mockitousage/bugs/AtLeastMarksAllInvocationsVerified.java
index 5cefa01..2c231e0 100644
--- a/src/test/java/org/mockitousage/bugs/AtLeastMarksAllInvocationsVerified.java
+++ b/src/test/java/org/mockitousage/bugs/AtLeastMarksAllInvocationsVerified.java
@@ -4,29 +4,45 @@
  */
 package org.mockitousage.bugs;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.atLeast;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Test;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
 // see issue 112
 public class AtLeastMarksAllInvocationsVerified extends TestBase {
 
     public static class SomeMethods {
-        public void allowedMethod() {
-        }
-        public void disallowedMethod() {
-        }
+        public void allowedMethod() {}
+
+        public void disallowedMethod() {}
     }
 
-    @Test(expected = org.mockito.exceptions.verification.NoInteractionsWanted.class)
-    public void shouldFailBecauseDisallowedMethodWasCalled(){
+    @Test
+    public void shouldFailBecauseDisallowedMethodWasCalled() {
         SomeMethods someMethods = mock(SomeMethods.class);
 
         someMethods.allowedMethod();
         someMethods.disallowedMethod();
 
         verify(someMethods, atLeast(1)).allowedMethod();
-        verifyNoMoreInteractions(someMethods);
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(someMethods);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContainingAll(
+                        "No interactions wanted here:",
+                        "-> at ",
+                        "But found this interaction on mock 'someMethods':",
+                        "-> at ",
+                        "For your reference, here is the list of all invocations ([?] - means unverified).",
+                        "1. -> at ",
+                        "2. [?]-> at ");
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/BridgeMethodsHitAgainTest.java b/src/test/java/org/mockitousage/bugs/BridgeMethodsHitAgainTest.java
index 515758e..c5f1b63 100644
--- a/src/test/java/org/mockitousage/bugs/BridgeMethodsHitAgainTest.java
+++ b/src/test/java/org/mockitousage/bugs/BridgeMethodsHitAgainTest.java
@@ -2,59 +2,59 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.Serializable;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockitoutil.TestBase;
 
-import java.io.Serializable;
-
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-//see issue 101
+// see issue 101
 public class BridgeMethodsHitAgainTest extends TestBase {
 
-  public interface Factory {}
-  public interface ExtendedFactory extends Factory {}
+    public interface Factory {}
 
-  public interface SomeInterface {
-    Factory factory();
-  }
+    public interface ExtendedFactory extends Factory {}
 
-  public interface SomeSubInterface extends SomeInterface {
-    ExtendedFactory factory();
-  }
+    public interface SomeInterface {
+        Factory factory();
+    }
 
-  public interface Base<T extends Serializable> {
-    int test(T value);
-  }
+    public interface SomeSubInterface extends SomeInterface {
+        ExtendedFactory factory();
+    }
 
-  public interface Extended extends Base<String> {
-    @Override
-    int test(String value);
-  }
+    public interface Base<T extends Serializable> {
+        int test(T value);
+    }
 
-  @Mock SomeSubInterface someSubInterface;
-  @Mock ExtendedFactory extendedFactory;
+    public interface Extended extends Base<String> {
+        @Override
+        int test(String value);
+    }
 
-  @Test
-  public void basicCheck() {
-    Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);
-    SomeInterface si = someSubInterface;
-    assertTrue(si.factory() != null);
-  }
+    @Mock SomeSubInterface someSubInterface;
+    @Mock ExtendedFactory extendedFactory;
 
-  @Test
-  public void checkWithExtraCast() {
-    Mockito.when(((SomeInterface) someSubInterface).factory()).thenReturn(extendedFactory);
-    SomeInterface si = someSubInterface;
-    assertTrue(si.factory() != null);
-  }
+    @Test
+    public void basicCheck() {
+        Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);
+        SomeInterface si = someSubInterface;
+        assertTrue(si.factory() != null);
+    }
+
+    @Test
+    public void checkWithExtraCast() {
+        Mockito.when(((SomeInterface) someSubInterface).factory()).thenReturn(extendedFactory);
+        SomeInterface si = someSubInterface;
+        assertTrue(si.factory() != null);
+    }
 
     @Test
     public void testBridgeInvocationIsRecordedForInterceptedMethod() {
diff --git a/src/test/java/org/mockitousage/bugs/CaptorAnnotationAutoboxingTest.java b/src/test/java/org/mockitousage/bugs/CaptorAnnotationAutoboxingTest.java
index e5898a2..78c70e9 100644
--- a/src/test/java/org/mockitousage/bugs/CaptorAnnotationAutoboxingTest.java
+++ b/src/test/java/org/mockitousage/bugs/CaptorAnnotationAutoboxingTest.java
@@ -2,24 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-//see issue 188
+// see issue 188
 public class CaptorAnnotationAutoboxingTest extends TestBase {
 
     interface Fun {
         void doFun(double prmitive);
+
         void moreFun(int howMuch);
     }
 
@@ -28,10 +28,10 @@ public class CaptorAnnotationAutoboxingTest extends TestBase {
 
     @Test
     public void shouldAutoboxSafely() {
-        //given
+        // given
         fun.doFun(1.0);
 
-        //then
+        // then
         verify(fun).doFun(captor.capture());
         assertEquals(Double.valueOf(1.0), captor.getValue());
     }
diff --git a/src/test/java/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java b/src/test/java/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
index 46aa271..a22ae24 100644
--- a/src/test/java/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
+++ b/src/test/java/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
@@ -4,39 +4,49 @@
  */
 package org.mockitousage.bugs;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoInteractions;
+
 import org.junit.Test;
 import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
 public class ClassCastExOnVerifyZeroInteractionsTest {
     public interface TestMock {
         boolean m1();
     }
 
-    @Test(expected = NoInteractionsWanted.class)
+    @Test
     public void should_not_throw_ClassCastException_when_mock_verification_fails() {
-        TestMock test = mock(TestMock.class, new Answer<Object>() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return false;
-            }
-        });
+        TestMock test = mock(TestMock.class, (Answer<Object>) invocation -> false);
         test.m1();
-        verifyZeroInteractions(test);
+
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoInteractions(test);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContainingAll(
+                        "No interactions wanted here:",
+                        "But found these interactions on mock 'testMock':",
+                        "Actually, above is the only interaction with this mock.");
     }
 
-    @Test(expected = WrongTypeOfReturnValue.class)
-    public void should_report_bogus_default_answer() throws Exception {
-        TestMock test = mock(TestMock.class, new Answer<Object>() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return false;
-            }
-        });
+    @Test
+    public void should_report_bogus_default_answer() {
+        TestMock test = mock(TestMock.class, (Answer<Object>) invocation -> false);
 
-        test.toString();
+        assertThatThrownBy(
+                        () -> {
+                            String ignored = test.toString();
+                        })
+                .isInstanceOf(WrongTypeOfReturnValue.class)
+                .hasMessageContainingAll(
+                        "Default answer returned a result with the wrong type:",
+                        "Boolean cannot be returned by toString()",
+                        "toString() should return String",
+                        "The default answer of testMock that was configured on the mock is probably incorrectly implemented.");
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/CompareMatcherTest.java b/src/test/java/org/mockitousage/bugs/CompareMatcherTest.java
index bc80a56..dd6db3f 100644
--- a/src/test/java/org/mockitousage/bugs/CompareMatcherTest.java
+++ b/src/test/java/org/mockitousage/bugs/CompareMatcherTest.java
@@ -6,12 +6,13 @@ package org.mockitousage.bugs;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.AdditionalMatchers.leq;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.startsWith;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.startsWith;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import java.util.Date;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
@@ -23,11 +24,9 @@ import org.mockitousage.IMethods;
 public class CompareMatcherTest {
     private static final Object NOT_A_COMPARABLE = new Object();
 
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
 
-    @Mock
-    public IMethods mock;
+    @Mock public IMethods mock;
 
     /**
      * Should not throw an {@link NullPointerException}
@@ -40,7 +39,7 @@ public class CompareMatcherTest {
 
         when(mock.forInteger(leq(5))).thenReturn("");
 
-        assertThat(mock.forInteger(null)).isNull();// a default value must be returned
+        assertThat(mock.forInteger(null)).isNull(); // a default value must be returned
     }
 
     /**
@@ -50,7 +49,7 @@ public class CompareMatcherTest {
     public void compareToNonCompareable() {
         when(mock.forObject(leq(5))).thenReturn("");
 
-        assertThat(mock.forObject(NOT_A_COMPARABLE)).isNull();// a default value must be returned
+        assertThat(mock.forObject(NOT_A_COMPARABLE)).isNull(); // a default value must be returned
     }
 
     /**
@@ -60,7 +59,7 @@ public class CompareMatcherTest {
     public void compareToNull() {
         when(mock.forInteger(leq((Integer) null))).thenReturn("");
 
-        assertThat(mock.forInteger(null)).isNull();// a default value must be returned
+        assertThat(mock.forInteger(null)).isNull(); // a default value must be returned
     }
 
     /**
@@ -70,7 +69,7 @@ public class CompareMatcherTest {
     public void compareToStringVsInt() {
         when(mock.forObject(startsWith("Hello"))).thenReturn("");
 
-        assertThat(mock.forObject(123)).isNull();// a default value must be returned
+        assertThat(mock.forObject(123)).isNull(); // a default value must be returned
     }
 
     @Test
@@ -97,7 +96,6 @@ public class CompareMatcherTest {
             public boolean matches(Integer arg, Void v) {
                 throw new UnsupportedOperationException();
             }
-
         }
 
         when(mock.forObject(argThat(new TestMatcher()))).thenReturn("x");
@@ -131,5 +129,4 @@ public class CompareMatcherTest {
 
         assertThat(mock.forObject(123)).isNull();
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java b/src/test/java/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java
index bc52c41..46cbb95 100644
--- a/src/test/java/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java
+++ b/src/test/java/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
+import static org.mockito.Mockito.*;
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import static org.mockito.Mockito.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
 
 // issue 322
 // the only evidence of this failing test was shown on a RHEL with IBM J9 JVM 64bits
@@ -39,7 +39,8 @@ public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {
 
     @Test
     public void shouldSuccessfullyVerifyConcurrentInvocationsWithTimeout() throws Exception {
-        int potentialOverhead = 1000; // Leave 1000ms extra before timing out as leeway for test overheads
+        int potentialOverhead =
+                1000; // Leave 1000ms extra before timing out as leeway for test overheads
         int expectedMaxTestLength = TIMES * INTERVAL_MILLIS + potentialOverhead;
 
         reset(target);
@@ -49,13 +50,11 @@ public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {
         verifyNoMoreInteractions(target);
     }
 
-    private void startInvocations() throws InterruptedException,
-            ExecutionException {
+    private void startInvocations() throws InterruptedException, ExecutionException {
 
-        for(int i=0; i<nThreads; i++) {
+        for (int i = 0; i < nThreads; i++) {
             fixedThreadPool.submit(new TargetInvoker(i));
         }
-
     }
 
     public class TargetInvoker implements Callable<Object> {
@@ -75,11 +74,9 @@ public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {
             System.err.println("finished" + seq);
             return seq;
         }
-
     }
 
     public interface ITarget {
         String targetMethod(String arg);
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/ConfusedSignatureTest.java b/src/test/java/org/mockitousage/bugs/ConfusedSignatureTest.java
index 8d79b54..99c638c 100644
--- a/src/test/java/org/mockitousage/bugs/ConfusedSignatureTest.java
+++ b/src/test/java/org/mockitousage/bugs/ConfusedSignatureTest.java
@@ -13,7 +13,8 @@ import org.junit.Test;
 public class ConfusedSignatureTest {
 
     @Test
-    public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
+    public void
+            should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
         Sub mock = mock(Sub.class);
         // The following line resulted in
         // org.mockito.exceptions.misusing.MissingMethodInvocationException:
@@ -31,12 +32,12 @@ public class ConfusedSignatureTest {
             this.value = value;
         }
 
-        public T getFoo() { return value; }
+        public T getFoo() {
+            return value;
+        }
     }
 
-    public class Sub
-            extends Super<String>
-            implements iInterface {
+    public class Sub extends Super<String> implements iInterface {
 
         public Sub(String s) {
             super(s);
diff --git a/src/test/java/org/mockitousage/bugs/CovariantOverrideTest.java b/src/test/java/org/mockitousage/bugs/CovariantOverrideTest.java
index 56f68a9..91d2486 100644
--- a/src/test/java/org/mockitousage/bugs/CovariantOverrideTest.java
+++ b/src/test/java/org/mockitousage/bugs/CovariantOverrideTest.java
@@ -2,16 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.*;
 
-//see issue 101
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
+// see issue 101
 public class CovariantOverrideTest extends TestBase {
 
     public interface ReturnsObject {
diff --git a/src/test/java/org/mockitousage/bugs/DiamondInheritanceIsConfusingMockitoTest.java b/src/test/java/org/mockitousage/bugs/DiamondInheritanceIsConfusingMockitoTest.java
index 4861dd5..e678594 100644
--- a/src/test/java/org/mockitousage/bugs/DiamondInheritanceIsConfusingMockitoTest.java
+++ b/src/test/java/org/mockitousage/bugs/DiamondInheritanceIsConfusingMockitoTest.java
@@ -31,12 +31,12 @@ public class DiamondInheritanceIsConfusingMockitoTest {
             this.value = value;
         }
 
-        public T getFoo() { return value; }
+        public T getFoo() {
+            return value;
+        }
     }
 
-    public class Sub
-            extends Super<String>
-            implements iInterface {
+    public class Sub extends Super<String> implements iInterface {
 
         public Sub(String s) {
             super(s);
diff --git a/src/test/java/org/mockitousage/bugs/EqualsWithDeltaTest.java b/src/test/java/org/mockitousage/bugs/EqualsWithDeltaTest.java
index 172b337..c87df91 100644
--- a/src/test/java/org/mockitousage/bugs/EqualsWithDeltaTest.java
+++ b/src/test/java/org/mockitousage/bugs/EqualsWithDeltaTest.java
@@ -4,12 +4,12 @@
  */
 package org.mockitousage.bugs;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.EqualsWithDelta;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class EqualsWithDeltaTest {
 
     @Test
diff --git a/src/test/java/org/mockitousage/bugs/FillInStackTraceScenariosTest.java b/src/test/java/org/mockitousage/bugs/FillInStackTraceScenariosTest.java
index 5e3193e..e22505a 100644
--- a/src/test/java/org/mockitousage/bugs/FillInStackTraceScenariosTest.java
+++ b/src/test/java/org/mockitousage/bugs/FillInStackTraceScenariosTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.when;
-
 /**
  * These tests check that ThrowsException#answer throws an instance returned
  * by Throwable#fillInStackTrace of the provided throwable.
@@ -42,14 +42,15 @@ public class FillInStackTraceScenariosTest extends TestBase {
         }
     }
 
-    //issue 866
+    // issue 866
     @Test
     public void avoids_NPE() {
         when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
         try {
             mock.simpleMethod();
             fail();
-        } catch(NullStackTraceException e) {}
+        } catch (NullStackTraceException e) {
+        }
     }
 
     @Test
@@ -58,6 +59,7 @@ public class FillInStackTraceScenariosTest extends TestBase {
         try {
             mock.simpleMethod();
             fail();
-        } catch(SomeException e) {}
+        } catch (SomeException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java b/src/test/java/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java
index e6c82cf..a2569cc 100644
--- a/src/test/java/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java
+++ b/src/test/java/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockitousage.bugs;
 
+import java.nio.charset.Charset;
+
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.nio.charset.Charset;
-
 // issue 327
 public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {
     @Mock private Charset charset;
@@ -19,7 +19,7 @@ public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {
 
     @Test
     public void dont_raise_NullPointerException() throws Exception {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     private static class FieldCharsetHolder {
@@ -27,7 +27,6 @@ public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {
     }
 
     private static class ConstructorCharsetHolder {
-        public ConstructorCharsetHolder(Charset charset) {
-        }
+        public ConstructorCharsetHolder(Charset charset) {}
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/GenericsMockitoAnnotationsTest.java b/src/test/java/org/mockitousage/bugs/GenericsMockitoAnnotationsTest.java
index 51f2369..7c3f17e 100644
--- a/src/test/java/org/mockitousage/bugs/GenericsMockitoAnnotationsTest.java
+++ b/src/test/java/org/mockitousage/bugs/GenericsMockitoAnnotationsTest.java
@@ -4,27 +4,29 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.MockitoAnnotations.openMocks;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.MockitoAnnotations.initMocks;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.mockito.Mock;
 
 /**
  * This was an issue reported in #1174.
  */
 public class GenericsMockitoAnnotationsTest {
 
-    @Mock
-    private TestCollectionSourceProvider testCollectionSourceProvider;
+    @Mock private TestCollectionSourceProvider testCollectionSourceProvider;
 
+    @Ignore
     @Test
     public void should_not_throw_class_cast_exception() {
-        given(testCollectionSourceProvider.getCollection(new ArrayList<Integer>())).willReturn(new ArrayList<Integer>());
+        given(testCollectionSourceProvider.getCollection(new ArrayList<Integer>()))
+                .willReturn(new ArrayList<Integer>());
     }
 
     static class TestCollectionSourceProvider {
@@ -35,6 +37,6 @@ public class GenericsMockitoAnnotationsTest {
 
     @Before
     public void setUp() throws Exception {
-        initMocks(this);
+        openMocks(this);
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest.java b/src/test/java/org/mockitousage/bugs/IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest.java
index 7d47a64..4885d24 100644
--- a/src/test/java/org/mockitousage/bugs/IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest.java
+++ b/src/test/java/org/mockitousage/bugs/IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest.java
@@ -4,18 +4,18 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.stubbing.OngoingStubbing;
-
-import java.util.Map;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import java.util.Map;
+
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.stubbing.OngoingStubbing;
+
 public class IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest {
 
     @Test
diff --git a/src/test/java/org/mockitousage/bugs/ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest.java b/src/test/java/org/mockitousage/bugs/ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest.java
index ad22bda..8dccfcb 100644
--- a/src/test/java/org/mockitousage/bugs/ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest.java
+++ b/src/test/java/org/mockitousage/bugs/ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest.java
@@ -4,11 +4,11 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.spy;
 
+import org.junit.Test;
+
 public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
     public abstract class GenericAbstract<T> {
         protected abstract String method_to_implement(T value);
diff --git a/src/test/java/org/mockitousage/bugs/InheritedGenericsPolimorphicCallTest.java b/src/test/java/org/mockitousage/bugs/InheritedGenericsPolimorphicCallTest.java
index ca5d92c..69cde91 100644
--- a/src/test/java/org/mockitousage/bugs/InheritedGenericsPolimorphicCallTest.java
+++ b/src/test/java/org/mockitousage/bugs/InheritedGenericsPolimorphicCallTest.java
@@ -2,12 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.verify;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -16,12 +15,12 @@ import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Mockito.verify;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
-//see issue 200
+// see issue 200
 public class InheritedGenericsPolimorphicCallTest extends TestBase {
 
     protected interface MyIterable<T> extends Iterable<T> {
@@ -44,7 +43,7 @@ public class InheritedGenericsPolimorphicCallTest extends TestBase {
 
     @Test
     public void shouldVerificationWorks() {
-        iterable.iterator();
+        MyIterator<String> unused = iterable.iterator();
 
         verify(iterable).iterator();
         verify((Iterable<String>) iterable).iterator();
@@ -52,24 +51,29 @@ public class InheritedGenericsPolimorphicCallTest extends TestBase {
 
     @Test
     public void shouldWorkExactlyAsJavaProxyWould() {
-        //given
+        // given
         final List<Method> methods = new LinkedList<Method>();
-        InvocationHandler handler = new InvocationHandler() {
-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            methods.add(method);
-            return null;
-        }};
+        InvocationHandler handler =
+                new InvocationHandler() {
+                    public Object invoke(Object proxy, Method method, Object[] args)
+                            throws Throwable {
+                        methods.add(method);
+                        return null;
+                    }
+                };
 
-        iterable = (MyIterable<String>) Proxy.newProxyInstance(
-                this.getClass().getClassLoader(),
-                new Class<?>[] { MyIterable.class },
-                handler);
+        iterable =
+                (MyIterable<String>)
+                        Proxy.newProxyInstance(
+                                this.getClass().getClassLoader(),
+                                new Class<?>[] {MyIterable.class},
+                                handler);
 
-        //when
-        iterable.iterator();
-        ((Iterable<String>) iterable).iterator();
+        // when
+        MyIterator<String> unused = iterable.iterator();
+        Iterator<String> unused2 = ((Iterable<String>) iterable).iterator();
 
-        //then
+        // then
         assertEquals(2, methods.size());
         assertEquals(methods.get(0), methods.get(1));
     }
diff --git a/src/test/java/org/mockitousage/bugs/ListenersLostOnResetMockTest.java b/src/test/java/org/mockitousage/bugs/ListenersLostOnResetMockTest.java
index 61a5268..c9b2bcd 100644
--- a/src/test/java/org/mockitousage/bugs/ListenersLostOnResetMockTest.java
+++ b/src/test/java/org/mockitousage/bugs/ListenersLostOnResetMockTest.java
@@ -4,15 +4,14 @@
  */
 package org.mockitousage.bugs;
 
+import static org.mockito.Mockito.*;
+
+import java.util.List;
 
 import org.junit.Test;
 import org.mockito.listeners.InvocationListener;
 import org.mockito.listeners.MethodInvocationReport;
 
-import java.util.List;
-
-import static org.mockito.Mockito.*;
-
 public class ListenersLostOnResetMockTest {
 
     @Test
diff --git a/src/test/java/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java b/src/test/java/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java
index 9abb4f5..312984c 100644
--- a/src/test/java/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java
+++ b/src/test/java/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java
@@ -2,11 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import java.io.OutputStream;
 import java.io.PrintStream;
+
 import org.junit.Test;
 import org.junit.internal.TextListener;
 import org.junit.runner.JUnitCore;
@@ -16,18 +20,13 @@ import org.mockito.exceptions.base.MockitoException;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-
 // @Ignore("for demo only. this test cannot be enabled as it fails :)")
 public class MockitoRunnerBreaksWhenNoTestMethodsTest extends TestBase {
 
     @Test
     public void ensure_the_test_runner_breaks() throws Exception {
         JUnitCore runner = new JUnitCore();
-//        runner.addListener(new TextListener(System.out));
+        //        runner.addListener(new TextListener(System.out));
         runner.addListener(new TextListener(DevNull.out));
 
         Result result = runner.run(TestClassWithoutTestMethod.class);
@@ -39,17 +38,22 @@ public class MockitoRunnerBreaksWhenNoTestMethodsTest extends TestBase {
 
     @RunWith(MockitoJUnitRunner.class)
     static class TestClassWithoutTestMethod { // package visibility is important
-        public void notATestMethod() { }
+        public void notATestMethod() {}
     }
 
     public static final class DevNull {
-        public final static PrintStream out = new PrintStream(new OutputStream() {
-            public void close() {}
-            public void flush() {}
-            public void write(byte[] b) {}
-            public void write(byte[] b, int off, int len) {}
-            public void write(int b) {}
-
-        } );
+        public static final PrintStream out =
+                new PrintStream(
+                        new OutputStream() {
+                            public void close() {}
+
+                            public void flush() {}
+
+                            public void write(byte[] b) {}
+
+                            public void write(byte[] b, int off, int len) {}
+
+                            public void write(int b) {}
+                        });
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/MockitoStubbedCallInAnswerTest.java b/src/test/java/org/mockitousage/bugs/MockitoStubbedCallInAnswerTest.java
index d9720f9..1cf9268 100644
--- a/src/test/java/org/mockitousage/bugs/MockitoStubbedCallInAnswerTest.java
+++ b/src/test/java/org/mockitousage/bugs/MockitoStubbedCallInAnswerTest.java
@@ -4,15 +4,15 @@
  */
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.when;
-
 /**
  * @see <a href="https://github.com/mockito/mockito/issues/1279">Issue #1279</a>
  */
@@ -23,81 +23,92 @@ public class MockitoStubbedCallInAnswerTest extends TestBase {
 
     @Test
     public void stubbing_the_right_mock() throws Exception {
-        //stubbing on different mock should not be altered
+        // stubbing on different mock should not be altered
         when(bar.doInt()).thenReturn(0);
-        when(foo.doInt()).thenAnswer(new Answer<Integer>() {
-            @Override
-            public Integer answer(InvocationOnMock invocation) throws Throwable {
-                return bar.doInt();
-            }
-        });
+        when(foo.doInt())
+                .thenAnswer(
+                        new Answer<Integer>() {
+                            @Override
+                            public Integer answer(InvocationOnMock invocation) throws Throwable {
+                                return bar.doInt();
+                            }
+                        });
         assertEquals(0, foo.doInt());
         assertEquals(0, bar.doInt());
 
-        //when we override the stubbing
+        // when we override the stubbing
         when(foo.doInt()).thenReturn(1);
 
-        //we expect it to be reflected:
+        // we expect it to be reflected:
         assertEquals(1, foo.doInt());
 
-        //but the stubbing on a different mock should not be altered:
+        // but the stubbing on a different mock should not be altered:
         assertEquals(0, bar.doInt());
     }
 
     @Test
     public void return_type_validation() throws Exception {
-        when(foo.doString()).thenAnswer(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                //invoking a method on a different mock, with different return type
-                return String.valueOf(bar.doInt());
-            }
-        });
+        when(foo.doString())
+                .thenAnswer(
+                        new Answer<String>() {
+                            public String answer(InvocationOnMock invocation) throws Throwable {
+                                // invoking a method on a different mock, with different return type
+                                return String.valueOf(bar.doInt());
+                            }
+                        });
         assertEquals("0", foo.doString());
 
-        //we can override stubbing without misleading return type validation errors:
+        // we can override stubbing without misleading return type validation errors:
         when(foo.doString()).thenReturn("");
         assertEquals("", foo.doString());
     }
 
     @Test
     public void prevents_stack_overflow() throws Exception {
-        when(foo.doInt()).thenAnswer(new Answer<Integer>() {
-            public Integer answer(InvocationOnMock invocation) throws Throwable {
-                return bar.doInt();
-            }
-        });
+        when(foo.doInt())
+                .thenAnswer(
+                        new Answer<Integer>() {
+                            public Integer answer(InvocationOnMock invocation) throws Throwable {
+                                return bar.doInt();
+                            }
+                        });
         assertEquals(0, foo.doInt());
 
-        when(foo.doInt()).thenAnswer(new Answer<Integer>() {
-            public Integer answer(InvocationOnMock invocation) throws Throwable {
-                return bar.doInt() + 1;
-            }
-        });
+        when(foo.doInt())
+                .thenAnswer(
+                        new Answer<Integer>() {
+                            public Integer answer(InvocationOnMock invocation) throws Throwable {
+                                return bar.doInt() + 1;
+                            }
+                        });
 
-        //calling below used to cause SO error
+        // calling below used to cause SO error
         assertEquals(1, foo.doInt());
     }
 
     @Test
     public void overriding_stubbing() throws Exception {
         when(bar.doInt()).thenReturn(10);
-        when(foo.doInt()).thenAnswer(new Answer<Integer>() {
-            public Integer answer(InvocationOnMock invocation) throws Throwable {
-                return bar.doInt() + 1;
-            }
-        });
+        when(foo.doInt())
+                .thenAnswer(
+                        new Answer<Integer>() {
+                            public Integer answer(InvocationOnMock invocation) throws Throwable {
+                                return bar.doInt() + 1;
+                            }
+                        });
 
         assertEquals(11, foo.doInt());
 
-        //when we override the stubbing with a different one
+        // when we override the stubbing with a different one
         when(foo.doInt()).thenReturn(100);
 
-        //we expect it to be reflected:
+        // we expect it to be reflected:
         assertEquals(100, foo.doInt());
     }
 
     interface Foo {
         String doString();
+
         int doInt();
     }
 
diff --git a/src/test/java/org/mockitousage/bugs/MultipleInOrdersTest.java b/src/test/java/org/mockitousage/bugs/MultipleInOrdersTest.java
index 41bde29..65472ff 100644
--- a/src/test/java/org/mockitousage/bugs/MultipleInOrdersTest.java
+++ b/src/test/java/org/mockitousage/bugs/MultipleInOrdersTest.java
@@ -4,21 +4,21 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockito.InOrder;
-
-import java.util.List;
-
 import static org.junit.Assert.assertNotSame;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+
 @SuppressWarnings("unchecked")
 public class MultipleInOrdersTest {
 
     @Test
-    public void inOrderTest(){
-        List<String> list= mock(List.class);
+    public void inOrderTest() {
+        List<String> list = mock(List.class);
 
         list.add("a");
         list.add("x");
diff --git a/src/test/java/org/mockitousage/bugs/MultithreadedStubbingHalfManualTest.java b/src/test/java/org/mockitousage/bugs/MultithreadedStubbingHalfManualTest.java
index c0549b3..30a8eae 100644
--- a/src/test/java/org/mockitousage/bugs/MultithreadedStubbingHalfManualTest.java
+++ b/src/test/java/org/mockitousage/bugs/MultithreadedStubbingHalfManualTest.java
@@ -4,9 +4,11 @@
  */
 package org.mockitousage.bugs;
 
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
+import static java.util.Collections.synchronizedList;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.util.LinkedList;
 import java.util.List;
@@ -14,10 +16,9 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.RejectedExecutionException;
 
-import static java.util.Collections.synchronizedList;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
 
 @Ignore
 public class MultithreadedStubbingHalfManualTest {
@@ -66,9 +67,9 @@ public class MultithreadedStubbingHalfManualTest {
     }
 
     @Test
-    //this problem shows at 4 out of 5 executions
-    //it is not strictly a bug because Mockito does not support simultanous stubbing (see FAQ)
-    //however I decided to synchronize some calls in order to make the exceptions nicer
+    // this problem shows at 4 out of 5 executions
+    // it is not strictly a bug because Mockito does not support simultanous stubbing (see FAQ)
+    // however I decided to synchronize some calls in order to make the exceptions nicer
     public void tryToRevealTheProblem() {
         ToMock toMock = mock(ToMock.class);
         for (int i = 0; i < 100; i++) {
@@ -76,8 +77,8 @@ public class MultithreadedStubbingHalfManualTest {
 
             // Repeated mocking
             when(toMock.getValue(i)).thenReturn(j);
-            //TODO make it also showing errors for doReturn()
-//            doReturn(j).when(toMock).getValue(i);
+            // TODO make it also showing errors for doReturn()
+            //            doReturn(j).when(toMock).getValue(i);
 
             while (true) {
                 try {
@@ -90,7 +91,7 @@ public class MultithreadedStubbingHalfManualTest {
             }
 
             try {
-                Thread.sleep(10 / ((i % 10) + 1)); //NOPMD
+                Thread.sleep(10 / ((i % 10) + 1)); // NOPMD
             } catch (InterruptedException e) {
             }
         }
diff --git a/src/test/java/org/mockitousage/bugs/NPEOnAnyClassMatcherAutounboxTest.java b/src/test/java/org/mockitousage/bugs/NPEOnAnyClassMatcherAutounboxTest.java
index b047a08..daa61c7 100644
--- a/src/test/java/org/mockitousage/bugs/NPEOnAnyClassMatcherAutounboxTest.java
+++ b/src/test/java/org/mockitousage/bugs/NPEOnAnyClassMatcherAutounboxTest.java
@@ -2,15 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
-//see issue 221
+// see issue 221
 public class NPEOnAnyClassMatcherAutounboxTest extends TestBase {
 
     interface Foo {
diff --git a/src/test/java/org/mockitousage/bugs/NPEWhenMockingThrowablesTest.java b/src/test/java/org/mockitousage/bugs/NPEWhenMockingThrowablesTest.java
index 712ee9b..a266efd 100644
--- a/src/test/java/org/mockitousage/bugs/NPEWhenMockingThrowablesTest.java
+++ b/src/test/java/org/mockitousage/bugs/NPEWhenMockingThrowablesTest.java
@@ -2,17 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.when;
-
 public class NPEWhenMockingThrowablesTest extends TestBase {
 
     @Mock IMethods mock;
@@ -22,13 +21,14 @@ public class NPEWhenMockingThrowablesTest extends TestBase {
         private static final long serialVersionUID = 1L;
     }
 
-    //issue 70
+    // issue 70
     @Test
     public void shouldNotThrowNPE() {
         when(mock.simpleMethod()).thenThrow(mock2);
         try {
             mock.simpleMethod();
             fail();
-        } catch(DummyException e) {}
+        } catch (DummyException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/NPEWithCertainMatchersTest.java b/src/test/java/org/mockitousage/bugs/NPEWithCertainMatchersTest.java
index d1475d0..8070320 100644
--- a/src/test/java/org/mockitousage/bugs/NPEWithCertainMatchersTest.java
+++ b/src/test/java/org/mockitousage/bugs/NPEWithCertainMatchersTest.java
@@ -4,16 +4,17 @@
  */
 package org.mockitousage.bugs;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 public class NPEWithCertainMatchersTest extends TestBase {
 
     @Mock IMethods mock;
@@ -51,17 +52,35 @@ public class NPEWithCertainMatchersTest extends TestBase {
         verify(mock, never()).intArgumentMethod(same(new Integer(100)));
     }
 
-    @Test(expected = AssertionError.class)
+    @Test
     public void shouldNotThrowNPEWhenNullPassedToEq() {
         mock.objectArgMethod("not null");
 
-        verify(mock).objectArgMethod(eq(null));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).objectArgMethod(eq(null));
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mock.objectArgMethod(null);",
+                        "Actual invocations have different arguments:",
+                        "mock.objectArgMethod(\"not null\");");
     }
 
-    @Test(expected = AssertionError.class)
+    @Test
     public void shouldNotThrowNPEWhenNullPassedToSame() {
         mock.objectArgMethod("not null");
 
-        verify(mock).objectArgMethod(same(null));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).objectArgMethod(same(null));
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mock.objectArgMethod(same(null));",
+                        "Actual invocations have different arguments:",
+                        "mock.objectArgMethod(\"not null\");");
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java b/src/test/java/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java
index 085fffe..a695be9 100644
--- a/src/test/java/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java
+++ b/src/test/java/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java
@@ -2,72 +2,71 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
 
 import java.util.Date;
 import java.util.Set;
 import java.util.TreeSet;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
-//see issue 184
+// see issue 184
 public class ShouldMocksCompareToBeConsistentWithEqualsTest extends TestBase {
 
     @Test
     public void should_compare_to_be_consistent_with_equals() {
-        //given
-        Date today    = mock(Date.class);
+        // given
+        Date today = mock(Date.class);
         Date tomorrow = mock(Date.class);
 
-        //when
+        // when
         Set<Date> set = new TreeSet<Date>();
         set.add(today);
         set.add(tomorrow);
 
-        //then
+        // then
         assertEquals(2, set.size());
     }
 
     @Test
     public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference() {
-        //given
-        Date today    = mock(Date.class);
+        // given
+        Date today = mock(Date.class);
 
-        //when
+        // when
         Set<Date> set = new TreeSet<Date>();
         set.add(today);
         set.add(today);
 
-        //then
+        // then
         assertEquals(1, set.size());
     }
 
     @Test
     public void should_allow_stubbing_and_verifying_compare_to() {
-        //given
-        Date mock    = mock(Date.class);
+        // given
+        Date mock = mock(Date.class);
         when(mock.compareTo(any(Date.class))).thenReturn(10);
 
-        //when
+        // when
         mock.compareTo(new Date());
 
-        //then
+        // then
         assertEquals(10, mock.compareTo(new Date()));
         verify(mock, atLeastOnce()).compareTo(any(Date.class));
     }
 
     @Test
     public void should_reset_not_remove_default_stubbing() {
-        //given
-        Date mock    = mock(Date.class);
+        // given
+        Date mock = mock(Date.class);
         reset(mock);
 
-        //then
+        // then
         assertEquals(1, mock.compareTo(new Date()));
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java b/src/test/java/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java
index f0424f7..e1c8dbd 100644
--- a/src/test/java/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java
+++ b/src/test/java/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java
@@ -6,17 +6,17 @@ package org.mockitousage.bugs;
 
 import static org.junit.Assert.fail;
 
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-//see bug 190
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+// see bug 190
 public class ShouldNotDeadlockAnswerExecutionTest {
 
     @Test
@@ -91,7 +91,6 @@ public class ShouldNotDeadlockAnswerExecutionTest {
 
             return null;
         }
-
     }
 
     static class ServiceRunner implements Runnable {
@@ -105,14 +104,10 @@ public class ShouldNotDeadlockAnswerExecutionTest {
         public void run() {
             service.verySlowMethod();
         }
-
     }
 
     interface Service {
 
         String verySlowMethod();
-
     }
-
 }
-
diff --git a/src/test/java/org/mockitousage/bugs/ShouldOnlyModeAllowCapturingArgumentsTest.java b/src/test/java/org/mockitousage/bugs/ShouldOnlyModeAllowCapturingArgumentsTest.java
index d145f9d..7da4f7e 100644
--- a/src/test/java/org/mockitousage/bugs/ShouldOnlyModeAllowCapturingArgumentsTest.java
+++ b/src/test/java/org/mockitousage/bugs/ShouldOnlyModeAllowCapturingArgumentsTest.java
@@ -2,34 +2,33 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verify;
-
-//bug 197
+// bug 197
 public class ShouldOnlyModeAllowCapturingArgumentsTest extends TestBase {
 
     @Mock IMethods mock;
 
     @Test
     public void shouldAllowCapturingArguments() {
-        //given
+        // given
         mock.simpleMethod("o");
         ArgumentCaptor<String> arg = ArgumentCaptor.forClass(String.class);
 
-        //when
+        // when
         verify(mock, only()).simpleMethod(arg.capture());
 
-        //then
+        // then
         assertEquals("o", arg.getValue());
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/SpyShouldHaveNiceNameTest.java b/src/test/java/org/mockitousage/bugs/SpyShouldHaveNiceNameTest.java
index dbc3007..353b405 100644
--- a/src/test/java/org/mockitousage/bugs/SpyShouldHaveNiceNameTest.java
+++ b/src/test/java/org/mockitousage/bugs/SpyShouldHaveNiceNameTest.java
@@ -2,34 +2,33 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.Spy;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
 
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.Spy;
+import org.mockitoutil.TestBase;
 
-//see issue 216
+// see issue 216
 public class SpyShouldHaveNiceNameTest extends TestBase {
 
     @Spy List<Integer> veryCoolSpy = new LinkedList<Integer>();
 
     @Test
     public void shouldPrintNiceName() {
-        //when
+        // when
         veryCoolSpy.add(1);
 
         try {
             verify(veryCoolSpy).add(2);
             fail();
-        } catch(AssertionError e) {
+        } catch (AssertionError e) {
             Assertions.assertThat(e.getMessage()).contains("veryCoolSpy");
         }
     }
diff --git a/src/test/java/org/mockitousage/bugs/StubbingMocksThatAreConfiguredToReturnMocksTest.java b/src/test/java/org/mockitousage/bugs/StubbingMocksThatAreConfiguredToReturnMocksTest.java
index bc31297..19043e4 100644
--- a/src/test/java/org/mockitousage/bugs/StubbingMocksThatAreConfiguredToReturnMocksTest.java
+++ b/src/test/java/org/mockitousage/bugs/StubbingMocksThatAreConfiguredToReturnMocksTest.java
@@ -2,16 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
-//issue 151
+// issue 151
 public class StubbingMocksThatAreConfiguredToReturnMocksTest extends TestBase {
 
     @Test
diff --git a/src/test/java/org/mockitousage/bugs/VerifyingWithAnExtraCallToADifferentMockTest.java b/src/test/java/org/mockitousage/bugs/VerifyingWithAnExtraCallToADifferentMockTest.java
index a997cbc..eb64989 100644
--- a/src/test/java/org/mockitousage/bugs/VerifyingWithAnExtraCallToADifferentMockTest.java
+++ b/src/test/java/org/mockitousage/bugs/VerifyingWithAnExtraCallToADifferentMockTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.NeverWantedButInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
-//see bug 138
+// see bug 138
 public class VerifyingWithAnExtraCallToADifferentMockTest extends TestBase {
 
     @Mock IMethods mock;
@@ -22,17 +21,18 @@ public class VerifyingWithAnExtraCallToADifferentMockTest extends TestBase {
 
     @Test
     public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {
-        //given
+        // given
         when(mock.otherMethod()).thenReturn("foo");
 
-        //when
+        // when
         mockTwo.simpleMethod("foo");
 
-        //then
+        // then
         verify(mockTwo).simpleMethod(mock.otherMethod());
         try {
             verify(mockTwo, never()).simpleMethod(mock.otherMethod());
             fail();
-        } catch (NeverWantedButInvoked e) {}
+        } catch (NeverWantedButInvoked e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/creation/ConstructorInvokingMethodShouldNotRaiseExceptionTest.java b/src/test/java/org/mockitousage/bugs/creation/ConstructorInvokingMethodShouldNotRaiseExceptionTest.java
index 3f20c6a..ccd14d9 100644
--- a/src/test/java/org/mockitousage/bugs/creation/ConstructorInvokingMethodShouldNotRaiseExceptionTest.java
+++ b/src/test/java/org/mockitousage/bugs/creation/ConstructorInvokingMethodShouldNotRaiseExceptionTest.java
@@ -4,68 +4,73 @@
  */
 package org.mockitousage.bugs.creation;
 
+import java.util.Random;
+
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
 import org.mockito.MockitoAnnotations;
 import org.mockito.Spy;
 
-import java.util.Random;
-
 @RunWith(Enclosed.class)
 public class ConstructorInvokingMethodShouldNotRaiseExceptionTest {
 
     public static class WithDumbMethod {
-        @Spy
-        HasConstructorInvokingMethod hasConstructorInvokingMethod;
+        @Spy HasConstructorInvokingMethod hasConstructorInvokingMethod;
 
         @Test
         public void should_be_able_to_create_spy() throws Exception {
-            MockitoAnnotations.initMocks(this);
+            MockitoAnnotations.openMocks(this);
         }
 
         private static class HasConstructorInvokingMethod {
-            public HasConstructorInvokingMethod() { someMethod(); }
+            public HasConstructorInvokingMethod() {
+                someMethod();
+            }
 
-            void someMethod() { }
+            void someMethod() {}
         }
     }
 
     public static class UsingMethodObjectReferenceResult {
-        @Spy
-        HasConstructorInvokingMethod hasConstructorInvokingMethod;
+        @Spy HasConstructorInvokingMethod hasConstructorInvokingMethod;
 
         @Test
         public void should_be_able_to_create_spy() throws Exception {
-            MockitoAnnotations.initMocks(this);
+            MockitoAnnotations.openMocks(this);
         }
 
         private static class HasConstructorInvokingMethod {
             private final boolean doesIt;
+
             public HasConstructorInvokingMethod() {
                 doesIt = someMethod().contains("yup");
             }
 
-            String someMethod() { return "tada!"; }
+            String someMethod() {
+                return "tada!";
+            }
         }
     }
 
     public static class UsingMethodPrimitiveResult {
-        @Spy
-        HasConstructorInvokingMethod hasConstructorInvokingMethod;
+        @Spy HasConstructorInvokingMethod hasConstructorInvokingMethod;
 
         @Test
         public void should_be_able_to_create_spy() throws Exception {
-            MockitoAnnotations.initMocks(this);
+            MockitoAnnotations.openMocks(this);
         }
 
         private static class HasConstructorInvokingMethod {
             private final boolean doesIt;
+
             public HasConstructorInvokingMethod() {
                 doesIt = someMethod();
             }
 
-            boolean someMethod() { return new Random().nextBoolean(); }
+            boolean someMethod() {
+                return new Random().nextBoolean();
+            }
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java b/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java
new file mode 100644
index 0000000..95095f3
--- /dev/null
+++ b/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.bugs.creation;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+/** Regression tests for issue #2303*/
+public class PackagePrivateWithContextClassLoaderTest {
+
+    private ClassLoader oldContextClassloader;
+
+    public abstract static class PublicClass {
+        int packagePrivateMethod() {
+            return 0;
+        }
+
+        abstract void packagePrivateAbstractMethod();
+    }
+
+    public interface PublicInterfaceWithPackagePrivateMethodParam {
+        void doSomething(PackagePrivateInterface i);
+    }
+
+    public interface PublicInterfaceWithPackagePrivateMethodReturn {
+        PackagePrivateInterface doSomething();
+    }
+
+    public interface PublicInterfaceOverridesPackagePrivateMethodReturn {
+        PublicChildOfPackagePrivate doSomething();
+    }
+
+    public interface PublicInterface {}
+
+    interface PackagePrivateInterface {}
+
+    public interface PublicChildOfPackagePrivate extends PackagePrivateInterface {}
+
+    static class PackagePrivateClass {}
+
+    @Before
+    public void setUp() {
+        oldContextClassloader = Thread.currentThread().getContextClassLoader();
+        Thread.currentThread().setContextClassLoader(new ClassLoader(oldContextClassloader) {});
+    }
+
+    @After
+    public void teardown() {
+        Thread.currentThread().setContextClassLoader(oldContextClassloader);
+    }
+
+    @Test
+    public void should_be_able_to_mock_package_private_method() throws Exception {
+        PublicClass publicClass = mock(PublicClass.class);
+        when(publicClass.packagePrivateMethod()).thenReturn(3);
+        assertThat(publicClass.packagePrivateMethod()).isEqualTo(3);
+    }
+
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_param() throws Exception {
+        PublicInterfaceWithPackagePrivateMethodParam publicClass =
+                mock(PublicInterfaceWithPackagePrivateMethodParam.class);
+        publicClass.doSomething(null);
+    }
+
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_return() throws Exception {
+        PublicInterfaceWithPackagePrivateMethodReturn publicClass =
+                mock(PublicInterfaceWithPackagePrivateMethodReturn.class);
+        PackagePrivateInterface packagePrivateInterface = publicClass.doSomething();
+    }
+
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_return_override()
+            throws Exception {
+        PublicInterfaceOverridesPackagePrivateMethodReturn publicClass =
+                mock(PublicInterfaceOverridesPackagePrivateMethodReturn.class);
+        PackagePrivateInterface packagePrivateInterface = publicClass.doSomething();
+    }
+
+    @Test
+    public void should_be_able_to_mock_package_private_class() throws Exception {
+        PackagePrivateClass mock = mock(PackagePrivateClass.class);
+    }
+
+    @Test
+    public void should_be_able_to_mock_package_private_interface() throws Exception {
+        PackagePrivateInterface mock = mock(PackagePrivateInterface.class);
+    }
+
+    @Test
+    public void should_be_able_to_mock_package_private_extra_interface() throws Exception {
+        PackagePrivateInterface mock =
+                (PackagePrivateInterface)
+                        mock(
+                                PublicInterface.class,
+                                withSettings().extraInterfaces(PackagePrivateInterface.class));
+    }
+
+    /**
+     * In this test we have a class that delegates loading of mockito/JDK classes to its parent,
+     * but defines in its own for others. If mockito selects the defining classloader of the mock
+     * to the classloader of mockito, calling the abstract package-private method will fail - the
+     * defining classloader of the mocked type's package is different from the generated mock class
+     * package. Because the nonDelegatingLoader is a child of mockito's loader, it's more specific
+     * and should be preferred.
+     */
+    @Test
+    public void classloader_with_parent_but_does_not_delegate() throws Exception {
+        ClassLoader nonDelegatingLoader = new NotAlwaysDelegatingClassLoader();
+        Thread.currentThread().setContextClassLoader(nonDelegatingLoader);
+        Class<?> loaded =
+                Class.forName(LoadedByCustomLoader.class.getName(), false, nonDelegatingLoader);
+        Method attemptMock = loaded.getDeclaredMethod("attemptMock");
+        attemptMock.invoke(null);
+    }
+
+    public static class LoadedByCustomLoader {
+        public static void attemptMock() {
+            PublicClass mock = mock(PublicClass.class);
+            mock.packagePrivateAbstractMethod();
+        }
+    }
+
+    /**
+     * This classloader has a parent, but doesn't always delegate to it.
+     */
+    public static final class NotAlwaysDelegatingClassLoader extends ClassLoader {
+
+        /**
+         * Initial size of buffer used to read class data.
+         */
+        /*  Note: should be enough for most classes, and is not a hard limit. */
+        private static final int BUF_SIZE = 4096;
+
+        public NotAlwaysDelegatingClassLoader() {
+            super(NotAlwaysDelegatingClassLoader.class.getClassLoader());
+        }
+
+        @Override
+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+            // First, check if the class has already been loaded. If not, load it
+            // ourselves or delegate to the parent.
+            Class<?> result = findLoadedClass(name);
+            if (result == null) {
+                // All classes defined in this testsuite should be loaded by this classloader,
+                // but any other class (e.g. those coming from java.* or org.mockito.* packages)
+                // will be loaded by the parent.
+                if (name.startsWith("org.mockitousage.")) {
+                    result = findClass(name);
+                } else {
+                    return super.loadClass(name, resolve);
+                }
+            }
+            if (resolve) {
+                resolveClass(result);
+            }
+            return result;
+        }
+
+        @Override
+        public Class<?> findClass(String className) throws ClassNotFoundException {
+            try {
+                // Create a package for this class, unless it's in the default package.
+                int dotpos = className.lastIndexOf('.');
+                if (dotpos != -1) {
+                    String pkgname = className.substring(0, dotpos);
+                    if (getPackage(pkgname) == null) {
+                        definePackage(pkgname, null, null, null, null, null, null, null);
+                    }
+                }
+                String resourceName = className.replace('.', File.separatorChar) + ".class";
+                InputStream input = getSystemResourceAsStream(resourceName);
+                if (input == null) {
+                    throw new ClassNotFoundException("Couldn't find resource " + resourceName);
+                }
+                byte[] classData = loadClassData(input);
+                return defineClass(className, classData, 0, classData.length, null);
+            } catch (IOException e) {
+                throw new ClassNotFoundException("Cannot load " + className, e);
+            }
+        }
+
+        /**
+         * Load class data from a given input stream.
+         */
+        private byte[] loadClassData(InputStream input) throws IOException {
+            ByteArrayOutputStream output = new ByteArrayOutputStream(BUF_SIZE);
+            byte[] buffer = new byte[BUF_SIZE];
+            int readCount;
+            while ((readCount = input.read(buffer, 0, BUF_SIZE)) >= 0) {
+                output.write(buffer, 0, readCount);
+            }
+            return output.toByteArray();
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/bugs/creation/PublicMethodInParentWithNonPublicTypeInSignatureTest.java b/src/test/java/org/mockitousage/bugs/creation/PublicMethodInParentWithNonPublicTypeInSignatureTest.java
index 5a5e43d..93c77e4 100644
--- a/src/test/java/org/mockitousage/bugs/creation/PublicMethodInParentWithNonPublicTypeInSignatureTest.java
+++ b/src/test/java/org/mockitousage/bugs/creation/PublicMethodInParentWithNonPublicTypeInSignatureTest.java
@@ -4,7 +4,6 @@
  */
 package org.mockitousage.bugs.creation;
 
-
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockitousage.bugs.creation.api.PublicClass;
diff --git a/src/test/java/org/mockitousage/bugs/creation/ShouldAllowInlineMockCreationTest.java b/src/test/java/org/mockitousage/bugs/creation/ShouldAllowInlineMockCreationTest.java
index 9ed8f21..fab68e3 100644
--- a/src/test/java/org/mockitousage/bugs/creation/ShouldAllowInlineMockCreationTest.java
+++ b/src/test/java/org/mockitousage/bugs/creation/ShouldAllowInlineMockCreationTest.java
@@ -2,21 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs.creation;
 
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.util.List;
 import java.util.Set;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockitoutil.TestBase;
 
-//see issue 191
+// see issue 191
 public class ShouldAllowInlineMockCreationTest extends TestBase {
 
     @Mock List list;
diff --git a/src/test/java/org/mockitousage/bugs/creation/api/PublicClass.java b/src/test/java/org/mockitousage/bugs/creation/api/PublicClass.java
index 834ef86..048208c 100644
--- a/src/test/java/org/mockitousage/bugs/creation/api/PublicClass.java
+++ b/src/test/java/org/mockitousage/bugs/creation/api/PublicClass.java
@@ -6,5 +6,4 @@ package org.mockitousage.bugs.creation.api;
 
 import org.mockitousage.bugs.creation.otherpackage.PublicParentClass;
 
-public class PublicClass extends PublicParentClass {
-}
+public class PublicClass extends PublicParentClass {}
diff --git a/src/test/java/org/mockitousage/bugs/creation/otherpackage/PublicParentClass.java b/src/test/java/org/mockitousage/bugs/creation/otherpackage/PublicParentClass.java
index df7f79a..3de5f2c 100644
--- a/src/test/java/org/mockitousage/bugs/creation/otherpackage/PublicParentClass.java
+++ b/src/test/java/org/mockitousage/bugs/creation/otherpackage/PublicParentClass.java
@@ -5,6 +5,7 @@
 package org.mockitousage.bugs.creation.otherpackage;
 
 public class PublicParentClass {
-    public void method_with_non_public_argument(PackageLocalArg arg) { }
-    static class PackageLocalArg { }
+    public void method_with_non_public_argument(PackageLocalArg arg) {}
+
+    static class PackageLocalArg {}
 }
diff --git a/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubFailingWhenGenericNestedAsRawTypeTest.java b/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubFailingWhenGenericNestedAsRawTypeTest.java
index 8f3510a..ac9029c 100644
--- a/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubFailingWhenGenericNestedAsRawTypeTest.java
+++ b/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubFailingWhenGenericNestedAsRawTypeTest.java
@@ -4,27 +4,27 @@
  */
 package org.mockitousage.bugs.deepstubs;
 
-import org.junit.Test;
-
 import static org.mockito.Mockito.*;
 
+import org.junit.Test;
+
 public class DeepStubFailingWhenGenericNestedAsRawTypeTest {
 
-  interface MyClass1<MC2 extends MyClass2> {
-    MC2 getNested();
-  }
+    interface MyClass1<MC2 extends MyClass2> {
+        MC2 getNested();
+    }
 
-  interface MyClass2<MC3 extends MyClass3> {
-    MC3 getNested();
-  }
+    interface MyClass2<MC3 extends MyClass3> {
+        MC3 getNested();
+    }
 
-  interface MyClass3 {
-    String returnSomething();
-  }
+    interface MyClass3 {
+        String returnSomething();
+    }
 
-  @Test
-  public void discoverDeepMockingOfGenerics() {
-    MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);
-    when(myMock1.getNested().getNested().returnSomething()).thenReturn("Hello World.");
-  }
+    @Test
+    public void discoverDeepMockingOfGenerics() {
+        MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);
+        when(myMock1.getNested().getNested().returnSomething()).thenReturn("Hello World.");
+    }
 }
diff --git a/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubsWronglyReportsSerializationProblemsTest.java b/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubsWronglyReportsSerializationProblemsTest.java
index e26f00b..7f61dc6 100644
--- a/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubsWronglyReportsSerializationProblemsTest.java
+++ b/src/test/java/org/mockitousage/bugs/deepstubs/DeepStubsWronglyReportsSerializationProblemsTest.java
@@ -4,25 +4,27 @@
  */
 package org.mockitousage.bugs.deepstubs;
 
-import org.junit.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 import static org.mockito.Mockito.mock;
 
+import org.junit.Test;
+
 /**
  * In GH issue 99 : https://github.com/mockito/mockito/issues/99
  */
 public class DeepStubsWronglyReportsSerializationProblemsTest {
 
     @Test
-    public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {
-        NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();
+    public void
+            should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {
+        NotSerializableShouldBeMocked the_deep_stub =
+                mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();
         assertThat(the_deep_stub).isNotNull();
     }
 
     public static class ToBeDeepStubbed {
-        public ToBeDeepStubbed() { }
+        public ToBeDeepStubbed() {}
 
         public NotSerializableShouldBeMocked getSomething() {
             return null;
@@ -30,7 +32,6 @@ public class DeepStubsWronglyReportsSerializationProblemsTest {
     }
 
     public static class NotSerializableShouldBeMocked {
-        NotSerializableShouldBeMocked(String mandatory_param) { }
+        NotSerializableShouldBeMocked(String mandatory_param) {}
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/injection/ChildWithSameParentFieldInjectionTest.java b/src/test/java/org/mockitousage/bugs/injection/ChildWithSameParentFieldInjectionTest.java
index c7f02c3..8570db1 100644
--- a/src/test/java/org/mockitousage/bugs/injection/ChildWithSameParentFieldInjectionTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/ChildWithSameParentFieldInjectionTest.java
@@ -4,22 +4,20 @@
  */
 package org.mockitousage.bugs.injection;
 
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import static org.junit.Assert.assertNotNull;
-
 // issue 289
 @RunWith(MockitoJUnitRunner.class)
 public class ChildWithSameParentFieldInjectionTest {
-    @InjectMocks
-    private System system;
+    @InjectMocks private System system;
 
-    @Mock
-    private SomeService someService;
+    @Mock private SomeService someService;
 
     @Test
     public void parent_field_is_not_null() {
@@ -48,7 +46,6 @@ public class ChildWithSameParentFieldInjectionTest {
     }
 
     public static class SomeService {
-        public void doSomething() {
-        }
+        public void doSomething() {}
     }
 }
diff --git a/src/test/java/org/mockitousage/bugs/injection/InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java b/src/test/java/org/mockitousage/bugs/injection/InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java
index 10070c6..0869f58 100644
--- a/src/test/java/org/mockitousage/bugs/injection/InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java
@@ -4,17 +4,17 @@
  */
 package org.mockitousage.bugs.injection;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 /**
  * Issue 211 : @InjectMocks should carry out their work by the method (and not by field) if available
  */
@@ -44,5 +44,4 @@ public class InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest {
             propertySetterUsed = true;
         }
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/injection/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java b/src/test/java/org/mockitousage/bugs/injection/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java
index e4957d3..5a8b415 100644
--- a/src/test/java/org/mockitousage/bugs/injection/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockitousage.bugs.injection;
 
+import static org.junit.Assert.*;
+
+import java.lang.reflect.Field;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.lang.reflect.Field;
-
-import static org.junit.Assert.*;
-
 @RunWith(MockitoJUnitRunner.class)
 public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {
 
@@ -22,7 +22,10 @@ public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {
     @Mock private Bean mockedBean;
 
     @InjectMocks private Service illegalInjectionExample = new Service();
-    @InjectMocks private ServiceWithReversedOrder reversedOrderService = new ServiceWithReversedOrder();
+
+    @InjectMocks
+    private ServiceWithReversedOrder reversedOrderService = new ServiceWithReversedOrder();
+
     @InjectMocks private WithNullObjectField withNullObjectField = new WithNullObjectField();
 
     @Test
@@ -63,7 +66,7 @@ public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {
         public final Object mockShouldNotGoInHere = REFERENCE;
     }
 
-    class WithNullObjectField{
+    class WithNullObjectField {
         Bean injectMePlease;
         Object keepMeNull = null;
     }
diff --git a/src/test/java/org/mockitousage/bugs/injection/Issue353InjectionMightNotHappenInCertainConfigurationTest.java b/src/test/java/org/mockitousage/bugs/injection/Issue353InjectionMightNotHappenInCertainConfigurationTest.java
index 7d154fc..3023e32 100644
--- a/src/test/java/org/mockitousage/bugs/injection/Issue353InjectionMightNotHappenInCertainConfigurationTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/Issue353InjectionMightNotHappenInCertainConfigurationTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockitousage.bugs.injection;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertSame;
+
+import java.util.HashMap;
+import java.util.Map;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -11,12 +16,6 @@ import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertSame;
-
 @RunWith(MockitoJUnitRunner.class)
 public class Issue353InjectionMightNotHappenInCertainConfigurationTest {
     @Mock Map<String, String> stringString_that_matches_field;
@@ -24,8 +23,12 @@ public class Issue353InjectionMightNotHappenInCertainConfigurationTest {
     @InjectMocks FooService fooService;
 
     @Test
-    public void when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one() {
-        assertThat("stringString_that_matches_field".compareTo("mockStringInteger_was_not_injected")).isGreaterThanOrEqualTo(1);
+    public void
+            when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one() {
+        assertThat(
+                        "stringString_that_matches_field"
+                                .compareTo("mockStringInteger_was_not_injected"))
+                .isGreaterThanOrEqualTo(1);
 
         assertSame(stringString_that_matches_field, fooService.stringString_that_matches_field);
         assertSame(mockStringInteger_was_not_injected, fooService.stringInteger_field);
@@ -35,5 +38,4 @@ public class Issue353InjectionMightNotHappenInCertainConfigurationTest {
         Map<String, Integer> stringInteger_field = new HashMap<String, Integer>();
         Map<String, String> stringString_that_matches_field = new HashMap<String, String>();
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/injection/ParentTestMockInjectionTest.java b/src/test/java/org/mockitousage/bugs/injection/ParentTestMockInjectionTest.java
index 660883f..6c11880 100644
--- a/src/test/java/org/mockitousage/bugs/injection/ParentTestMockInjectionTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/ParentTestMockInjectionTest.java
@@ -4,6 +4,8 @@
  */
 package org.mockitousage.bugs.injection;
 
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -11,15 +13,13 @@ import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import static org.junit.Assert.assertNotNull;
-
 // issue 229 : @Mock fields in super test class are not injected on @InjectMocks fields
 public class ParentTestMockInjectionTest {
 
     @Test
     public void injectMocksShouldInjectMocksFromTestSuperClasses() {
         ImplicitTest it = new ImplicitTest();
-        MockitoAnnotations.initMocks(it);
+        MockitoAnnotations.openMocks(it);
 
         assertNotNull(it.daoFromParent);
         assertNotNull(it.daoFromSub);
@@ -28,7 +28,7 @@ public class ParentTestMockInjectionTest {
     }
 
     @Ignore
-    public static abstract class BaseTest {
+    public abstract static class BaseTest {
         @Mock protected DaoA daoFromParent;
     }
 
@@ -40,7 +40,7 @@ public class ParentTestMockInjectionTest {
 
         @Before
         public void setup() {
-            MockitoAnnotations.initMocks(this);
+            MockitoAnnotations.openMocks(this);
         }
 
         @Test
@@ -59,13 +59,11 @@ public class ParentTestMockInjectionTest {
         }
     }
 
-
     public static class DaoA {
-        public void doQuery() { }
+        public void doQuery() {}
     }
 
     public static class DaoB {
-        public void doQuery() { }
+        public void doQuery() {}
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/injection/ShouldNotTryToInjectInFinalOrStaticFieldsTest.java b/src/test/java/org/mockitousage/bugs/injection/ShouldNotTryToInjectInFinalOrStaticFieldsTest.java
index bbe5233..c98103d 100644
--- a/src/test/java/org/mockitousage/bugs/injection/ShouldNotTryToInjectInFinalOrStaticFieldsTest.java
+++ b/src/test/java/org/mockitousage/bugs/injection/ShouldNotTryToInjectInFinalOrStaticFieldsTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs.injection;
 
+import static org.junit.Assert.assertNotSame;
+
+import java.util.*;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
@@ -12,10 +15,6 @@ import org.mockito.Mock;
 import org.mockito.Spy;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.util.*;
-
-import static org.junit.Assert.assertNotSame;
-
 // issue 262
 @RunWith(MockitoJUnitRunner.class)
 public class ShouldNotTryToInjectInFinalOrStaticFieldsTest {
@@ -31,12 +30,10 @@ public class ShouldNotTryToInjectInFinalOrStaticFieldsTest {
     @InjectMocks private ExampleService exampleService = new ExampleService();
 
     @Test
-    public void dont_fail_with_CONSTANTS() throws Exception {
-    }
+    public void dont_fail_with_CONSTANTS() throws Exception {}
 
     @Test
     public void dont_inject_in_final() {
         assertNotSame(unrelatedSet, exampleService.aSet);
     }
-
 }
diff --git a/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyObjectPicksUpExtraInvocationsTest.java b/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
similarity index 72%
rename from src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyObjectPicksUpExtraInvocationsTest.java
rename to src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
index 7bf4271..f6f4417 100644
--- a/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyObjectPicksUpExtraInvocationsTest.java
+++ b/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
@@ -2,52 +2,50 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs.varargs;
 
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-public class VarargsAndAnyObjectPicksUpExtraInvocationsTest extends TestBase {
+public class VarargsAndAnyPicksUpExtraInvocationsTest extends TestBase {
     public interface TableBuilder {
         void newRow(String trAttributes, String... cells);
     }
 
-    @Mock
-    TableBuilder table;
+    @Mock TableBuilder table;
 
     @Test
-    public void shouldVerifyCorrectlyWithAnyVarargs() {
-        //when
+    public void shouldVerifyCorrectlyWithAny() {
+        // when
         table.newRow("qux", "foo", "bar", "baz");
         table.newRow("abc", "def");
 
-        //then
-        verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());
+        // then
+        verify(table, times(2)).newRow(anyString(), (String[]) any());
     }
 
     @Test
-    public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument() {
-        //when
+    public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyAndEqualArgument() {
+        // when
         table.newRow("x", "foo", "bar", "baz");
         table.newRow("x", "def");
 
-        //then
-        verify(table, times(2)).newRow(eq("x"), (String[]) anyVararg());
+        // then
+        verify(table, times(2)).newRow(eq("x"), (String[]) any());
     }
 
     @Test
     public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs() {
-        //when
+        // when
         table.newRow("qux", "foo", "bar", "baz");
         table.newRow("abc", "def");
 
-        //then
+        // then
         verify(table).newRow(anyString(), eq("foo"), anyString(), anyString());
         verify(table).newRow(anyString(), anyString());
     }
diff --git a/src/test/java/org/mockitousage/bugs/varargs/VarargsErrorWhenCallingRealMethodTest.java b/src/test/java/org/mockitousage/bugs/varargs/VarargsErrorWhenCallingRealMethodTest.java
index 2380c81..2238221 100644
--- a/src/test/java/org/mockitousage/bugs/varargs/VarargsErrorWhenCallingRealMethodTest.java
+++ b/src/test/java/org/mockitousage/bugs/varargs/VarargsErrorWhenCallingRealMethodTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs.varargs;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.*;
 
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 public class VarargsErrorWhenCallingRealMethodTest extends TestBase {
 
     class Foo {
-        int blah(String a, String b, Object ... c) {
+        int blah(String a, String b, Object... c) {
             return 1;
         }
     }
diff --git a/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyObjectTest.java b/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java
similarity index 62%
rename from src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyObjectTest.java
rename to src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java
index 2b0cbff..6e11a6a 100644
--- a/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyObjectTest.java
+++ b/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java
@@ -2,24 +2,22 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.bugs.varargs;
 
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyString;
-import static org.mockito.Mockito.anyVararg;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-//see issue 62
-public class VarargsNotPlayingWithAnyObjectTest extends TestBase {
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockitoutil.TestBase;
+
+// see issue 62
+public class VarargsNotPlayingWithAnyTest extends TestBase {
 
     interface VarargMethod {
         Object run(String... args);
@@ -28,27 +26,27 @@ public class VarargsNotPlayingWithAnyObjectTest extends TestBase {
     @Mock VarargMethod mock;
 
     @Test
-    public void shouldMatchAnyVararg() {
+    public void shouldMatchAny() {
         mock.run("a", "b");
 
         verify(mock).run(anyString(), anyString());
-        verify(mock).run((String) anyObject(), (String) anyObject());
+        verify(mock).run((String) any(), (String) any());
 
-        verify(mock).run((String[]) anyVararg());
+        verify(mock).run((String[]) any());
 
         verify(mock, never()).run();
         verify(mock, never()).run(anyString(), eq("f"));
     }
 
     @Test
-    public void shouldAllowUsingAnyObjectForVarArgs() {
+    public void shouldAllowUsinganyForVarArgs() {
         mock.run("a", "b");
-        verify(mock).run((String[]) anyObject());
+        verify(mock).run((String[]) any());
     }
 
     @Test
-    public void shouldStubUsingAnyVarargs() {
-        when(mock.run((String[]) anyVararg())).thenReturn("foo");
+    public void shouldStubUsingAny() {
+        when(mock.run((String[]) any())).thenReturn("foo");
 
         assertEquals("foo", mock.run("a", "b"));
     }
diff --git a/src/test/java/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java b/src/test/java/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java
index edc0a8b..7d9c950 100644
--- a/src/test/java/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java
+++ b/src/test/java/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java
@@ -4,50 +4,62 @@
  */
 package org.mockitousage.configuration;
 
+import static org.mockito.Mockito.mock;
+
+import java.util.concurrent.Callable;
 
 import org.junit.Test;
 import org.mockito.internal.configuration.ConfigurationAccess;
 import org.mockitoutil.SimplePerRealmReloadingClassLoader;
 
-import java.util.concurrent.Callable;
-
-import static org.mockito.Mockito.mock;
-
 public class ClassCacheVersusClassReloadingTest {
     // TODO refactor to use ClassLoaders
 
-    private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm = new SimplePerRealmReloadingClassLoader(reloadMockito());
+    private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm =
+            new SimplePerRealmReloadingClassLoader(reloadMockito());
 
     @Test
-    public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() throws Exception {
+    public void should_not_throw_ClassCastException_when_objenesis_cache_disabled()
+            throws Exception {
         prepareMockitoAndDisableObjenesisCache();
 
-        doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
-        doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
+        doInNewChildRealm(
+                testMethodClassLoaderRealm,
+                "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
+        doInNewChildRealm(
+                testMethodClassLoaderRealm,
+                "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
     }
 
     public static class DoTheMocking implements Callable<Object> {
         public Object call() throws Exception {
-            Class<?> clazz = this.getClass().getClassLoader().loadClass("org.mockitousage.configuration.ClassToBeMocked");
+            Class<?> clazz =
+                    this.getClass()
+                            .getClassLoader()
+                            .loadClass("org.mockitousage.configuration.ClassToBeMocked");
             return mock(clazz);
         }
     }
 
-    private static void doInNewChildRealm(ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {
-        new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope()).doInRealm(callableCalledInClassLoaderRealm);
+    private static void doInNewChildRealm(
+            ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {
+        new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope())
+                .doInRealm(callableCalledInClassLoaderRealm);
     }
 
     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {
         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {
             public boolean acceptReloadOf(String qualifiedName) {
-                return "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking".equals(qualifiedName)
-                    || "org.mockitousage.configuration.ClassToBeMocked".equals(qualifiedName);
+                return "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking"
+                                .equals(qualifiedName)
+                        || "org.mockitousage.configuration.ClassToBeMocked".equals(qualifiedName);
             }
         };
     }
 
     private void prepareMockitoAndDisableObjenesisCache() throws Exception {
-        testMethodClassLoaderRealm.doInRealm("org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito");
+        testMethodClassLoaderRealm.doInRealm(
+                "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito");
     }
 
     public static class PrepareMockito implements Callable<Boolean> {
@@ -61,9 +73,9 @@ public class ClassCacheVersusClassReloadingTest {
     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {
         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {
             public boolean acceptReloadOf(String qualifiedName) {
-                return (!qualifiedName.contains("net.bytebuddy") && qualifiedName.contains("org.mockito"));
+                return (!qualifiedName.contains("net.bytebuddy")
+                        && qualifiedName.contains("org.mockito"));
             }
         };
     }
-
 }
diff --git a/src/test/java/org/mockitousage/configuration/ClassToBeMocked.java b/src/test/java/org/mockitousage/configuration/ClassToBeMocked.java
index adc863d..fbb852d 100644
--- a/src/test/java/org/mockitousage/configuration/ClassToBeMocked.java
+++ b/src/test/java/org/mockitousage/configuration/ClassToBeMocked.java
@@ -7,4 +7,4 @@ package org.mockitousage.configuration;
 /**
  * Some class to mock that is created via Class.forClass
  */
-public class ClassToBeMocked { }
+public class ClassToBeMocked {}
diff --git a/src/test/java/org/mockitousage/configuration/CustomizedAnnotationForSmartMockTest.java b/src/test/java/org/mockitousage/configuration/CustomizedAnnotationForSmartMockTest.java
deleted file mode 100644
index c8a8bbf..0000000
--- a/src/test/java/org/mockitousage/configuration/CustomizedAnnotationForSmartMockTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitousage.configuration;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.Set;
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.configuration.MockitoConfiguration;
-import org.mockito.internal.configuration.InjectingAnnotationEngine;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.verify;
-
-
-/**
- * @see MockitoConfiguration#getAnnotationEngine() for the custom smartmock injection engine
- */
-public class CustomizedAnnotationForSmartMockTest extends TestBase {
-
-    @SmartMock IMethods smartMock;
-
-    @Test
-    public void shouldUseCustomAnnotation() {
-        assertEquals("SmartMock should return empty String by default", "", smartMock.simpleMethod(1));
-        verify(smartMock).simpleMethod(1);
-    }
-
-    @Target({FIELD })
-    @Retention(RetentionPolicy.RUNTIME)
-    public @interface SmartMock {}
-
-    public static class CustomInjectingAnnotationEngine extends InjectingAnnotationEngine {
-        @Override
-        protected void onInjection(Object testClassInstance, Class<?> clazz, Set<Field> mockDependentFields, Set<Object> mocks) {
-            for (Field field : clazz.getDeclaredFields()) {
-                if (field.isAnnotationPresent(SmartMock.class)) {
-                    field.setAccessible(true);
-                    try {
-                        field.set(Modifier.isStatic(field.getModifiers()) ? null : testClassInstance, Mockito.mock(field.getType(), Mockito.RETURNS_SMART_NULLS));
-                    } catch (Exception exception) {
-                        throw new AssertionError(exception.getMessage());
-                    }
-                }
-            }
-        }
-    }
-}
diff --git a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
index fe626b0..a70b5b2 100644
--- a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
+++ b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
@@ -4,54 +4,66 @@
  */
 package org.mockitousage.constructor;
 
-import java.util.List;
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.mock.SerializableMode;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.CALLS_REAL_METHODS;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.mock.SerializableMode;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
 public class CreatingMocksWithConstructorTest extends TestBase {
 
-    static abstract class AbstractMessage {
+    abstract static class AbstractMessage {
         private final String message;
+
         AbstractMessage() {
             this.message = "hey!";
         }
+
         AbstractMessage(String message) {
             this.message = message;
         }
+
         AbstractMessage(int i) {
             this.message = String.valueOf(i);
         }
+
         String getMessage() {
             return message;
         }
     }
 
     static class Message extends AbstractMessage {}
+
     class InnerClass extends AbstractMessage {}
 
     @Test
     public void can_create_mock_with_constructor() {
-        Message mock = mock(Message.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
-        //the message is a part of state of the mocked type that gets initialized in constructor
+        Message mock =
+                mock(
+                        Message.class,
+                        withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
+        // the message is a part of state of the mocked type that gets initialized in constructor
         assertEquals("hey!", mock.getMessage());
     }
 
     @Test
     public void can_mock_abstract_classes() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
+        AbstractMessage mock =
+                mock(
+                        AbstractMessage.class,
+                        withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("hey!", mock.getMessage());
     }
 
@@ -63,46 +75,72 @@ public class CreatingMocksWithConstructorTest extends TestBase {
 
     @Test
     public void can_spy_abstract_classes_with_constructor_args() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
+        AbstractMessage mock =
+                mock(
+                        AbstractMessage.class,
+                        withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("hello!", mock.getMessage());
     }
 
     @Test
     public void can_spy_abstract_classes_with_constructor_primitive_args() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
+        AbstractMessage mock =
+                mock(
+                        AbstractMessage.class,
+                        withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("7", mock.getMessage());
     }
 
     @Test
     public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
+        AbstractMessage mock =
+                mock(
+                        AbstractMessage.class,
+                        withSettings()
+                                .useConstructor(new Object[] {null})
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertNull(mock.getMessage());
     }
 
     @Test
     public void can_spy_abstract_classes_with_casted_null() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
+        AbstractMessage mock =
+                mock(
+                        AbstractMessage.class,
+                        withSettings()
+                                .useConstructor((String) null)
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertNull(mock.getMessage());
     }
 
     @Test
     public void can_spy_abstract_classes_with_null_varargs() {
         try {
-            mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
+            mock(
+                    AbstractMessage.class,
+                    withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
             fail();
         } catch (IllegalArgumentException e) {
-            assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
-                "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
+            assertThat(e)
+                    .hasMessageContaining(
+                            "constructorArgs should not be null. "
+                                    + "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
         }
     }
 
     @Test
     public void can_mock_inner_classes() {
-        InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));
+        InnerClass mock =
+                mock(
+                        InnerClass.class,
+                        withSettings()
+                                .useConstructor()
+                                .outerInstance(this)
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("hey!", mock.getMessage());
     }
 
-    public static class ThrowingConstructorClass{
+    public static class ThrowingConstructorClass {
         public ThrowingConstructorClass() {
             throw new RuntimeException();
         }
@@ -111,11 +149,15 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     @Test
     public void explains_constructor_exceptions() {
         try {
-            mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
+            mock(
+                    ThrowingConstructorClass.class,
+                    withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
-            assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
+            assertThat(e.getCause())
+                    .hasMessageContaining(
+                            "Please ensure the target class has a 0-arg constructor and executes cleanly.");
         }
     }
 
@@ -126,29 +168,35 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     @Test
     public void exception_message_when_constructor_not_found() {
         try {
-            //when
+            // when
             spy(HasConstructor.class);
-            //then
+            // then
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'HasConstructor'");
-            assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
+            assertThat(e.getCause())
+                    .hasMessageContaining(
+                            "Please ensure that the target class has a 0-arg constructor.");
         }
     }
 
     static class Base {}
+
     static class ExtendsBase extends Base {}
+
     static class ExtendsExtendsBase extends ExtendsBase {}
 
     static class UsesBase {
         public UsesBase(Base b) {
             constructorUsed = "Base";
         }
+
         public UsesBase(ExtendsBase b) {
             constructorUsed = "ExtendsBase";
         }
 
         private String constructorUsed = null;
+
         String getConstructorUsed() {
             return constructorUsed;
         }
@@ -156,19 +204,34 @@ public class CreatingMocksWithConstructorTest extends TestBase {
 
     @Test
     public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
-        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
+        UsesBase u =
+                mock(
+                        UsesBase.class,
+                        withSettings()
+                                .useConstructor(new Base())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("Base", u.getConstructorUsed());
     }
 
     @Test
     public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
-        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+        UsesBase u =
+                mock(
+                        UsesBase.class,
+                        withSettings()
+                                .useConstructor(new ExtendsBase())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("ExtendsBase", u.getConstructorUsed());
     }
 
     @Test
     public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
-        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+        UsesBase u =
+                mock(
+                        UsesBase.class,
+                        withSettings()
+                                .useConstructor(new ExtendsExtendsBase())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("ExtendsBase", u.getConstructorUsed());
     }
 
@@ -176,14 +239,17 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         public UsesTwoBases(Base b1, Base b2) {
             constructorUsed = "Base,Base";
         }
+
         public UsesTwoBases(ExtendsBase b1, Base b2) {
             constructorUsed = "ExtendsBase,Base";
         }
+
         public UsesTwoBases(Base b1, ExtendsBase b2) {
             constructorUsed = "Base,ExtendsBase";
         }
 
         private String constructorUsed = null;
+
         String getConstructorUsed() {
             return constructorUsed;
         }
@@ -192,67 +258,93 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     @Test
     public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
         UsesTwoBases u =
-            mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
+                mock(
+                        UsesTwoBases.class,
+                        withSettings()
+                                .useConstructor(new Base(), new Base())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("Base,Base", u.getConstructorUsed());
     }
 
     @Test
-    public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
+    public void
+            can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
         UsesTwoBases u =
-            mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
+                mock(
+                        UsesTwoBases.class,
+                        withSettings()
+                                .useConstructor(new ExtendsBase(), new Base())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("ExtendsBase,Base", u.getConstructorUsed());
     }
 
     @Test
-    public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
+    public void
+            can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
         UsesTwoBases u =
-            mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+                mock(
+                        UsesTwoBases.class,
+                        withSettings()
+                                .useConstructor(new Base(), new ExtendsBase())
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("Base,ExtendsBase", u.getConstructorUsed());
     }
 
     @Test
     public void fail_when_multiple_matching_constructors_with_inheritence() {
         try {
-            //when
-            mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
-            //then
+            // when
+            mock(
+                    UsesTwoBases.class,
+                    withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
+            // then
             fail();
         } catch (MockitoException e) {
-            //TODO the exception message includes Mockito internals like the name of the generated class name.
-            //I suspect that we could make this exception message nicer.
+            // TODO the exception message includes Mockito internals like the name of the generated
+            // class name.
+            // I suspect that we could make this exception message nicer.
             assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
             assertThat(e.getCause())
-                .hasMessageContaining("Multiple constructors could be matched to arguments of types "
-                    + "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
-                    + "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
-                .hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
-                    "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
-                    "See https://github.com/mockito/mockito/issues/685");
+                    .hasMessageContaining(
+                            "Multiple constructors could be matched to arguments of types "
+                                    + "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+                                    + "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
+                    .hasMessageContaining(
+                            "If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n"
+                                    + "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n"
+                                    + "See https://github.com/mockito/mockito/issues/685");
         }
     }
 
     @Test
     public void mocking_inner_classes_with_wrong_outer_instance() {
         try {
-            //when
-            mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
-            //then
+            // when
+            mock(
+                    InnerClass.class,
+                    withSettings()
+                            .useConstructor()
+                            .outerInstance(123)
+                            .defaultAnswer(CALLS_REAL_METHODS));
+            // then
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'InnerClass'");
-            //TODO it would be nice if all useful information was in the top level exception, instead of in the exception's cause
-            //also applies to other scenarios in this test
-            assertThat(e.getCause()).hasMessageContaining(
-                "Please ensure that the target class has a 0-arg constructor"
-                    + " and provided outer instance is correct.");
+            // TODO it would be nice if all useful information was in the top level exception,
+            // instead of in the exception's cause
+            // also applies to other scenarios in this test
+            assertThat(e.getCause())
+                    .hasMessageContaining(
+                            "Please ensure that the target class has a 0-arg constructor"
+                                    + " and provided outer instance is correct.");
         }
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
     @Test
     public void mocking_interfaces_with_constructor() {
-        //at the moment this is allowed however we can be more strict if needed
-        //there is not much sense in creating a spy of an interface
+        // at the moment this is allowed however we can be more strict if needed
+        // there is not much sense in creating a spy of an interface
         mock(IMethods.class, withSettings().useConstructor());
         spy(IMethods.class);
     }
@@ -260,17 +352,26 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     @Test
     public void prevents_across_jvm_serialization_with_constructor() {
         try {
-            //when
-            mock(AbstractMessage.class, withSettings().useConstructor().serializable(SerializableMode.ACROSS_CLASSLOADERS));
-            //then
+            // when
+            mock(
+                    AbstractMessage.class,
+                    withSettings()
+                            .useConstructor()
+                            .serializable(SerializableMode.ACROSS_CLASSLOADERS));
+            // then
             fail();
         } catch (MockitoException e) {
-            assertEquals("Mocks instantiated with constructor cannot be combined with " + SerializableMode.ACROSS_CLASSLOADERS + " serialization mode.", e.getMessage());
+            assertEquals(
+                    "Mocks instantiated with constructor cannot be combined with "
+                            + SerializableMode.ACROSS_CLASSLOADERS
+                            + " serialization mode.",
+                    e.getMessage());
         }
     }
 
-    static abstract class AbstractThing {
+    abstract static class AbstractThing {
         abstract String name();
+
         String fullName() {
             return "abstract " + name();
         }
@@ -329,11 +430,13 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         public AmbiguousWithPrimitive(String s, int i) {
             data = s;
         }
+
         public AmbiguousWithPrimitive(Object o, int i) {
             data = "just an object";
         }
 
         private String data;
+
         public String getData() {
             return data;
         }
@@ -341,7 +444,12 @@ public class CreatingMocksWithConstructorTest extends TestBase {
 
     @Test
     public void can_spy_ambiguius_constructor_with_primitive() {
-        AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
+        AmbiguousWithPrimitive mock =
+                mock(
+                        AmbiguousWithPrimitive.class,
+                        withSettings()
+                                .useConstructor("String", 7)
+                                .defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("String", mock.getData());
     }
 }
diff --git a/src/test/java/org/mockitousage/customization/BDDMockitoTest.java b/src/test/java/org/mockitousage/customization/BDDMockitoTest.java
index 518c071..89f85fb 100644
--- a/src/test/java/org/mockitousage/customization/BDDMockitoTest.java
+++ b/src/test/java/org/mockitousage/customization/BDDMockitoTest.java
@@ -4,7 +4,23 @@
  */
 package org.mockitousage.customization;
 
-import org.assertj.core.api.Assertions;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.BDDMockito.anyString;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.inOrder;
+import static org.mockito.BDDMockito.mock;
+import static org.mockito.BDDMockito.then;
+import static org.mockito.BDDMockito.times;
+import static org.mockito.BDDMockito.willAnswer;
+import static org.mockito.BDDMockito.willCallRealMethod;
+import static org.mockito.BDDMockito.willDoNothing;
+import static org.mockito.BDDMockito.willReturn;
+import static org.mockito.BDDMockito.willThrow;
+
+import java.util.Set;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mock;
@@ -12,47 +28,40 @@ import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitousage.IMethods;
 import org.mockitousage.MethodsImpl;
 import org.mockitoutil.TestBase;
 
-import java.util.Set;
-
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.*;
-
 public class BDDMockitoTest extends TestBase {
 
-    @Mock
-    IMethods mock;
+    @Mock IMethods mock;
 
     @Test
-    public void should_stub() throws Exception {
+    public void should_stub() {
         given(mock.simpleMethod("foo")).willReturn("bar");
 
-        Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("bar");
-        Assertions.assertThat(mock.simpleMethod("whatever")).isEqualTo(null);
+        assertThat(mock.simpleMethod("foo")).isEqualTo("bar");
+        assertThat(mock.simpleMethod("whatever")).isNull();
     }
 
     @Test
-    public void should_stub_with_throwable() throws Exception {
+    public void should_stub_with_throwable() {
         given(mock.simpleMethod("foo")).willThrow(new SomethingWasWrong());
 
         try {
-            Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+            assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
             fail();
         } catch (SomethingWasWrong expected) {
         }
     }
 
     @Test
-    public void should_stub_with_throwable_class() throws Exception {
+    public void should_stub_with_throwable_class() {
         given(mock.simpleMethod("foo")).willThrow(SomethingWasWrong.class);
 
         try {
-            Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+            assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
             fail();
         } catch (SomethingWasWrong expected) {
         }
@@ -60,72 +69,71 @@ public class BDDMockitoTest extends TestBase {
 
     @Test
     @SuppressWarnings("unchecked")
-    public void should_stub_with_throwable_classes() throws Exception {
+    public void should_stub_with_throwable_classes() {
         // unavoidable 'unchecked generic array creation' warning (from JDK7 onward)
-        given(mock.simpleMethod("foo")).willThrow(SomethingWasWrong.class, AnotherThingWasWrong.class);
+        given(mock.simpleMethod("foo"))
+                .willThrow(SomethingWasWrong.class, AnotherThingWasWrong.class);
 
         try {
-            Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+            assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
             fail();
         } catch (SomethingWasWrong expected) {
         }
     }
 
     @Test
-    public void should_stub_with_answer() throws Exception {
-        given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                return invocation.getArgument(0);
-            }
-        });
+    public void should_stub_with_answer() {
+        given(mock.simpleMethod(anyString()))
+                .willAnswer(
+                        (Answer<String>)
+                                invocation -> {
+                                    return invocation.getArgument(0);
+                                });
 
-        Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
     }
 
     @Test
-    public void should_stub_with_will_answer_alias() throws Exception {
-        given(mock.simpleMethod(anyString())).will(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                return invocation.getArgument(0);
-            }
-        });
+    public void should_stub_with_will_answer_alias() {
+        given(mock.simpleMethod(anyString()))
+                .will(
+                        (Answer<String>)
+                                invocation -> {
+                                    return invocation.getArgument(0);
+                                });
 
-        Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
     }
 
     @Test
-    public void should_stub_consecutively() throws Exception {
-        given(mock.simpleMethod(anyString()))
-                .willReturn("foo")
-                .willReturn("bar");
+    public void should_stub_consecutively() {
+        given(mock.simpleMethod(anyString())).willReturn("foo").willReturn("bar");
 
-        Assertions.assertThat(mock.simpleMethod("whatever")).isEqualTo("foo");
-        Assertions.assertThat(mock.simpleMethod("whatever")).isEqualTo("bar");
+        assertThat(mock.simpleMethod("whatever")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("whatever")).isEqualTo("bar");
     }
 
     @Test
-    public void should_return_consecutively() throws Exception {
-        given(mock.objectReturningMethodNoArgs())
-                .willReturn("foo", "bar", 12L, new byte[0]);
+    public void should_return_consecutively() {
+        given(mock.objectReturningMethodNoArgs()).willReturn("foo", "bar", 12L, new byte[0]);
 
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("foo");
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("bar");
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(12L);
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("foo");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("bar");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(12L);
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
     }
 
     @Test
-    public void should_stub_consecutively_with_call_real_method() throws Exception {
+    public void should_stub_consecutively_with_call_real_method() {
         MethodsImpl mock = mock(MethodsImpl.class);
-        willReturn("foo").willCallRealMethod()
-                .given(mock).simpleMethod();
+        willReturn("foo").willCallRealMethod().given(mock).simpleMethod();
 
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("foo");
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo(null);
+        assertThat(mock.simpleMethod()).isEqualTo("foo");
+        assertThat(mock.simpleMethod()).isNull();
     }
 
     @Test
-    public void should_stub_void() throws Exception {
+    public void should_stub_void() {
         willThrow(new SomethingWasWrong()).given(mock).voidMethod();
 
         try {
@@ -136,7 +144,7 @@ public class BDDMockitoTest extends TestBase {
     }
 
     @Test
-    public void should_stub_void_with_exception_class() throws Exception {
+    public void should_stub_void_with_exception_class() {
         willThrow(SomethingWasWrong.class).given(mock).voidMethod();
 
         try {
@@ -148,7 +156,7 @@ public class BDDMockitoTest extends TestBase {
 
     @Test
     @SuppressWarnings("unchecked")
-    public void should_stub_void_with_exception_classes() throws Exception {
+    public void should_stub_void_with_exception_classes() {
         willThrow(SomethingWasWrong.class, AnotherThingWasWrong.class).given(mock).voidMethod();
 
         try {
@@ -159,10 +167,8 @@ public class BDDMockitoTest extends TestBase {
     }
 
     @Test
-    public void should_stub_void_consecutively() throws Exception {
-        willDoNothing()
-                .willThrow(new SomethingWasWrong())
-                .given(mock).voidMethod();
+    public void should_stub_void_consecutively() {
+        willDoNothing().willThrow(new SomethingWasWrong()).given(mock).voidMethod();
 
         mock.voidMethod();
         try {
@@ -173,10 +179,8 @@ public class BDDMockitoTest extends TestBase {
     }
 
     @Test
-    public void should_stub_void_consecutively_with_exception_class() throws Exception {
-        willDoNothing()
-                .willThrow(SomethingWasWrong.class)
-                .given(mock).voidMethod();
+    public void should_stub_void_consecutively_with_exception_class() {
+        willDoNothing().willThrow(SomethingWasWrong.class).given(mock).voidMethod();
 
         mock.voidMethod();
         try {
@@ -187,72 +191,110 @@ public class BDDMockitoTest extends TestBase {
     }
 
     @Test
-    public void should_stub_using_do_return_style() throws Exception {
+    public void should_stub_using_do_return_style() {
         willReturn("foo").given(mock).simpleMethod("bar");
 
-        Assertions.assertThat(mock.simpleMethod("boooo")).isEqualTo(null);
-        Assertions.assertThat(mock.simpleMethod("bar")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("boooo")).isEqualTo(null);
+        assertThat(mock.simpleMethod("bar")).isEqualTo("foo");
     }
 
     @Test
-    public void should_stub_using_do_answer_style() throws Exception {
-        willAnswer(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                return invocation.getArgument(0);
-            }
-        })
-                .given(mock).simpleMethod(anyString());
+    public void should_stub_using_do_answer_style() {
+        willAnswer(
+                        (Answer<String>)
+                                invocation -> {
+                                    return invocation.getArgument(0);
+                                })
+                .given(mock)
+                .simpleMethod(anyString());
 
-        Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
     }
 
     @Test
-    public void should_stub_by_delegating_to_real_method() throws Exception {
-        //given
+    public void should_stub_by_delegating_to_real_method() {
+        // given
         Dog dog = mock(Dog.class);
-        //when
+        // when
         willCallRealMethod().given(dog).bark();
-        //then
-        Assertions.assertThat(dog.bark()).isEqualTo("woof");
+        // then
+        assertThat(dog.bark()).isEqualTo("woof");
     }
 
     @Test
-    public void should_stub_by_delegating_to_real_method_using_typical_stubbing_syntax() throws Exception {
-        //given
+    public void should_stub_by_delegating_to_real_method_using_typical_stubbing_syntax() {
+        // given
         Dog dog = mock(Dog.class);
-        //when
+        // when
         given(dog.bark()).willCallRealMethod();
-        //then
-        Assertions.assertThat(dog.bark()).isEqualTo("woof");
+        // then
+        assertThat(dog.bark()).isEqualTo("woof");
     }
 
     @Test
-    public void should_all_stubbed_mock_reference_access() throws Exception {
+    public void should_all_stubbed_mock_reference_access() {
         Set<?> expectedMock = mock(Set.class);
 
         Set<?> returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();
 
-        Assertions.assertThat(returnedMock).isEqualTo(expectedMock);
+        assertThat(returnedMock).isEqualTo(expectedMock);
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void should_validate_mock_when_verifying() {
-        then("notMock").should();
+        assertThatThrownBy(
+                        () -> {
+                            then("notMock").should();
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument passed to verify() is of type String and is not a mock!",
+                        "Make sure you place the parenthesis correctly!",
+                        "See the examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();");
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void should_validate_mock_when_verifying_with_expected_number_of_invocations() {
-        then("notMock").should(times(19));
+        assertThatThrownBy(
+                        () -> {
+                            then("notMock").should(times(19));
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument passed to verify() is of type String and is not a mock!",
+                        "Make sure you place the parenthesis correctly!",
+                        "See the examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();");
     }
 
-    @Test(expected = NotAMockException.class)
+    @Test
     public void should_validate_mock_when_verifying_no_more_interactions() {
-        then("notMock").should();
+        assertThatThrownBy(
+                        () -> {
+                            then("notMock").shouldHaveNoMoreInteractions();
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument(s) passed is not a mock!",
+                        "Examples of correct verifications:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 
-    @Test(expected = WantedButNotInvoked.class)
+    @Test
     public void should_fail_for_expected_behavior_that_did_not_happen() {
-        then(mock).should().booleanObjectReturningMethod();
+        assertThatThrownBy(
+                        () -> {
+                            then(mock).should().booleanObjectReturningMethod();
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:", "mock.booleanObjectReturningMethod();");
     }
 
     @Test
@@ -264,19 +306,8 @@ public class BDDMockitoTest extends TestBase {
     }
 
     @Test
-    public void should_validate_that_mock_did_not_have_any_interactions() {
-        then(mock).shouldHaveZeroInteractions();
-    }
-
-    @Test
-    public void should_fail_when_mock_had_unwanted_interactions() {
-        mock.booleanObjectReturningMethod();
-
-        try {
-            then(mock).shouldHaveZeroInteractions();
-            fail("should have reported this interaction wasn't wanted");
-        } catch (NoInteractionsWanted expected) {
-        }
+    public void should_validate_that_mock_had_no_interactions() {
+        then(mock).shouldHaveNoInteractions();
     }
 
     @Test
@@ -317,9 +348,17 @@ public class BDDMockitoTest extends TestBase {
         }
     }
 
-    @Test(expected = WantedButNotInvoked.class)
+    @Test
     public void should_fail_when_checking_order_of_interactions_that_did_not_happen() {
-        then(mock).should(inOrder(mock)).booleanObjectReturningMethod();
+        assertThatThrownBy(
+                        () -> {
+                            then(mock).should(inOrder(mock)).booleanObjectReturningMethod();
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:",
+                        "mock.booleanObjectReturningMethod();",
+                        "Actually, there were zero interactions with this mock.");
     }
 
     @Test
@@ -332,7 +371,7 @@ public class BDDMockitoTest extends TestBase {
         person.ride(bike);
 
         then(person).should(times(2)).ride(bike);
-        then(police).shouldHaveZeroInteractions();
+        then(police).shouldHaveNoInteractions();
     }
 
     @Test
@@ -367,25 +406,18 @@ public class BDDMockitoTest extends TestBase {
 
     static class Person {
 
-        void ride(Bike bike) {
-        }
-
-        void drive(Car car) {
-        }
-    }
-
-    static class Bike {
+        void ride(Bike bike) {}
 
+        void drive(Car car) {}
     }
 
-    static class Car {
+    static class Bike {}
 
-    }
+    static class Car {}
 
     static class Police {
 
-        void chase(Car car) {
-        }
+        void chase(Car car) {}
     }
 
     class Dog {
@@ -395,11 +427,7 @@ public class BDDMockitoTest extends TestBase {
         }
     }
 
-    private class SomethingWasWrong extends RuntimeException {
+    private class SomethingWasWrong extends RuntimeException {}
 
-    }
-
-    private class AnotherThingWasWrong extends RuntimeException {
-
-    }
+    private class AnotherThingWasWrong extends RuntimeException {}
 }
diff --git a/src/test/java/org/mockitousage/debugging/Foo.java b/src/test/java/org/mockitousage/debugging/Foo.java
index be52a98..6a3c747 100644
--- a/src/test/java/org/mockitousage/debugging/Foo.java
+++ b/src/test/java/org/mockitousage/debugging/Foo.java
@@ -6,5 +6,6 @@ package org.mockitousage.debugging;
 
 interface Foo {
     String giveMeSomeString(String param);
+
     void doSomething(String param);
 }
diff --git a/src/test/java/org/mockitousage/debugging/InvocationListenerCallbackTest.java b/src/test/java/org/mockitousage/debugging/InvocationListenerCallbackTest.java
index e263047..be69b70 100644
--- a/src/test/java/org/mockitousage/debugging/InvocationListenerCallbackTest.java
+++ b/src/test/java/org/mockitousage/debugging/InvocationListenerCallbackTest.java
@@ -4,16 +4,6 @@
  */
 package org.mockitousage.debugging;
 
-import org.assertj.core.api.Condition;
-import org.junit.Test;
-import org.mockito.InOrder;
-import org.mockito.invocation.DescribedInvocation;
-import org.mockito.listeners.InvocationListener;
-import org.mockito.listeners.MethodInvocationReport;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.BDDMockito.given;
@@ -24,6 +14,15 @@ import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.withSettings;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.api.Condition;
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.invocation.DescribedInvocation;
+import org.mockito.listeners.InvocationListener;
+import org.mockito.listeners.MethodInvocationReport;
 
 /**
  * Ensures that custom listeners can be registered and will be called every time
@@ -113,7 +112,8 @@ public class InvocationListenerCallbackTest {
         }
     }
 
-    private static Condition<RememberingListener> notifiedFor(final Object returned, final String location) {
+    private static Condition<RememberingListener> notifiedFor(
+            final Object returned, final String location) {
         return new Condition<RememberingListener>() {
             public boolean matches(RememberingListener toBeAsserted) {
                 assertThat(toBeAsserted.returnValue).isEqualTo(returned);
@@ -142,9 +142,9 @@ public class InvocationListenerCallbackTest {
             this.invocation = mcr.getInvocation();
             this.returnValue = mcr.getReturnedValue();
             this.locationOfStubbing = mcr.getLocationOfStubbing();
-            listenerContainer.add(this); //so that we can assert on order
+            listenerContainer.add(this); // so that we can assert on order
         }
     }
 
-    private static class OvenNotWorking extends RuntimeException { }
+    private static class OvenNotWorking extends RuntimeException {}
 }
diff --git a/src/test/java/org/mockitousage/debugging/InvocationsPrinterTest.java b/src/test/java/org/mockitousage/debugging/InvocationsPrinterTest.java
index 6c44403..41761ef 100644
--- a/src/test/java/org/mockitousage/debugging/InvocationsPrinterTest.java
+++ b/src/test/java/org/mockitousage/debugging/InvocationsPrinterTest.java
@@ -4,74 +4,88 @@
  */
 package org.mockitousage.debugging;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.internal.debugging.InvocationsPrinter;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.when;
-
 public class InvocationsPrinterTest extends TestBase {
 
     @Mock IMethods mock;
 
-    @Test public void no_invocations() {
-        assertThat(new InvocationsPrinter().printInvocations(mock)).isEqualTo("No interactions and stubbings found for mock: mock");
+    @Test
+    public void no_invocations() {
+        assertThat(new InvocationsPrinter().printInvocations(mock))
+                .isEqualTo("No interactions and stubbings found for mock: mock");
     }
 
-    @Test public void prints_invocations() {
+    @Test
+    public void prints_invocations() {
         mock.simpleMethod(100);
         triggerInteraction();
 
         assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
-                .isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
-                        " 1. mock.simpleMethod(100);\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations(InvocationsPrinterTest.java:0)\n" +
-                        " 2. mock.otherMethod();\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:0)\n"));
+                .isEqualTo(
+                        filterLineNo(
+                                "[Mockito] Interactions of: mock\n"
+                                        + " 1. mock.simpleMethod(100);\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations(InvocationsPrinterTest.java:0)\n"
+                                        + " 2. mock.otherMethod();\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:0)\n"));
     }
 
-    @Test public void prints_stubbings() {
+    @Test
+    public void prints_stubbings() {
         triggerStubbing();
 
         assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
-                .isEqualTo(filterLineNo("[Mockito] Unused stubbings of: mock\n" +
-                        " 1. mock.simpleMethod(\"a\");\n" +
-                        "  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:70)\n"));
+                .isEqualTo(
+                        filterLineNo(
+                                "[Mockito] Unused stubbings of: mock\n"
+                                        + " 1. mock.simpleMethod(\"a\");\n"
+                                        + "  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:70)\n"));
     }
 
-    @Test public void prints_invocations_and_stubbings() {
+    @Test
+    public void prints_invocations_and_stubbings() {
         triggerStubbing();
 
         mock.simpleMethod("a");
         triggerInteraction();
 
         assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
-                .isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
-                        " 1. mock.simpleMethod(\"a\");\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_stubbings(InvocationsPrinterTest.java:49)\n" +
-                        "   - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:73)\n" +
-                        " 2. mock.otherMethod();\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n"));
+                .isEqualTo(
+                        filterLineNo(
+                                "[Mockito] Interactions of: mock\n"
+                                        + " 1. mock.simpleMethod(\"a\");\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_stubbings(InvocationsPrinterTest.java:49)\n"
+                                        + "   - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:73)\n"
+                                        + " 2. mock.otherMethod();\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n"));
     }
 
-    @Test public void prints_invocations_and_unused_stubbings() {
+    @Test
+    public void prints_invocations_and_unused_stubbings() {
         triggerStubbing();
 
         mock.simpleMethod("b");
         triggerInteraction();
 
         assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
-                .isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
-                        " 1. mock.simpleMethod(\"b\");\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_unused_stubbings(InvocationsPrinterTest.java:55)\n" +
-                        " 2. mock.otherMethod();\n" +
-                        "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n" +
-                        "[Mockito] Unused stubbings of: mock\n" +
-                        " 1. mock.simpleMethod(\"a\");\n" +
-                        "  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:62)\n"));
+                .isEqualTo(
+                        filterLineNo(
+                                "[Mockito] Interactions of: mock\n"
+                                        + " 1. mock.simpleMethod(\"b\");\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_unused_stubbings(InvocationsPrinterTest.java:55)\n"
+                                        + " 2. mock.otherMethod();\n"
+                                        + "  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n"
+                                        + "[Mockito] Unused stubbings of: mock\n"
+                                        + " 1. mock.simpleMethod(\"a\");\n"
+                                        + "  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:62)\n"));
     }
 
     private void triggerInteraction() {
diff --git a/src/test/java/org/mockitousage/debugging/NewMockito.java b/src/test/java/org/mockitousage/debugging/NewMockito.java
deleted file mode 100644
index e8cf272..0000000
--- a/src/test/java/org/mockitousage/debugging/NewMockito.java
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitousage.debugging;
-
-import org.mockito.Mockito;
-import org.mockito.MockitoDebugger;
-import org.mockito.internal.debugging.MockitoDebuggerImpl;
-
-//TODO get rid when debug() finally is out
-public class NewMockito extends Mockito {
-
-    public static MockitoDebugger debug() {
-        return new MockitoDebuggerImpl();
-    }
-}
diff --git a/src/test/java/org/mockitousage/debugging/StubbingLookupListenerCallbackTest.java b/src/test/java/org/mockitousage/debugging/StubbingLookupListenerCallbackTest.java
new file mode 100644
index 0000000..aa22e53
--- /dev/null
+++ b/src/test/java/org/mockitousage/debugging/StubbingLookupListenerCallbackTest.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.debugging;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.ArgumentMatcher;
+import org.mockito.InOrder;
+import org.mockito.listeners.StubbingLookupEvent;
+import org.mockito.listeners.StubbingLookupListener;
+import org.mockito.mock.MockCreationSettings;
+import org.mockitousage.IMethods;
+import org.mockitoutil.ConcurrentTesting;
+import org.mockitoutil.TestBase;
+
+public class StubbingLookupListenerCallbackTest extends TestBase {
+
+    StubbingLookupListener listener = mock(StubbingLookupListener.class);
+    StubbingLookupListener listener2 = mock(StubbingLookupListener.class);
+    Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener));
+
+    @Test
+    public void should_call_listener_when_mock_return_normally_with_stubbed_answer() {
+        // given
+        doReturn("coke").when(mock).giveMeSomeString("soda");
+        doReturn("java").when(mock).giveMeSomeString("coffee");
+
+        // when
+        mock.giveMeSomeString("soda");
+
+        // then
+        verify(listener)
+                .onStubbingLookup(
+                        argThat(
+                                new ArgumentMatcher<StubbingLookupEvent>() {
+                                    @Override
+                                    public boolean matches(StubbingLookupEvent argument) {
+                                        assertEquals(
+                                                "soda", argument.getInvocation().getArgument(0));
+                                        assertEquals(
+                                                "mock",
+                                                argument.getMockSettings()
+                                                        .getMockName()
+                                                        .toString());
+                                        assertEquals(2, argument.getAllStubbings().size());
+                                        assertNotNull(argument.getStubbingFound());
+                                        return true;
+                                    }
+                                }));
+    }
+
+    @Test
+    public void should_call_listener_when_mock_return_normally_with_default_answer() {
+        // given
+        doReturn("java").when(mock).giveMeSomeString("coffee");
+
+        // when
+        mock.giveMeSomeString("soda");
+
+        // then
+        verify(listener)
+                .onStubbingLookup(
+                        argThat(
+                                new ArgumentMatcher<StubbingLookupEvent>() {
+                                    @Override
+                                    public boolean matches(StubbingLookupEvent argument) {
+                                        assertEquals(
+                                                "soda", argument.getInvocation().getArgument(0));
+                                        assertEquals(
+                                                "mock",
+                                                argument.getMockSettings()
+                                                        .getMockName()
+                                                        .toString());
+                                        assertEquals(1, argument.getAllStubbings().size());
+                                        assertNull(argument.getStubbingFound());
+                                        return true;
+                                    }
+                                }));
+    }
+
+    @Test
+    public void should_not_call_listener_when_mock_is_not_called() {
+        // when stubbing is recorded
+        doReturn("java").when(mock).giveMeSomeString("coffee");
+
+        // then
+        verifyNoInteractions(listener);
+    }
+
+    @Test
+    public void should_allow_same_listener() {
+        // given
+        Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener, listener));
+
+        // when
+        mock.giveMeSomeString("tea");
+        mock.giveMeSomeString("coke");
+
+        // then each listener was notified 2 times (notified 4 times in total)
+        verify(listener, times(4)).onStubbingLookup(any(StubbingLookupEvent.class));
+    }
+
+    @Test
+    public void should_call_all_listeners_in_order() {
+        // given
+        Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener, listener2));
+        doReturn("sprite").when(mock).giveMeSomeString("soda");
+
+        // when
+        mock.giveMeSomeString("soda");
+
+        // then
+        InOrder inOrder = inOrder(listener, listener2);
+        inOrder.verify(listener).onStubbingLookup(any(StubbingLookupEvent.class));
+        inOrder.verify(listener2).onStubbingLookup(any(StubbingLookupEvent.class));
+    }
+
+    @Test
+    public void should_call_all_listeners_when_mock_throws_exception() {
+        // given
+        Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener, listener2));
+        doThrow(new NoWater()).when(mock).giveMeSomeString("tea");
+
+        // when
+        try {
+            mock.giveMeSomeString("tea");
+            fail();
+        } catch (NoWater e) {
+            // then
+            verify(listener).onStubbingLookup(any(StubbingLookupEvent.class));
+            verify(listener2).onStubbingLookup(any(StubbingLookupEvent.class));
+        }
+    }
+
+    @Test
+    public void should_delete_listener() {
+        // given
+        Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener, listener2));
+
+        // when
+        mock.doSomething("1");
+        mockingDetails(mock)
+                .getMockCreationSettings()
+                .getStubbingLookupListeners()
+                .remove(listener2);
+        mock.doSomething("2");
+
+        // then
+        verify(listener, times(2)).onStubbingLookup(any(StubbingLookupEvent.class));
+        verify(listener2, times(1)).onStubbingLookup(any(StubbingLookupEvent.class));
+    }
+
+    @Test
+    public void should_clear_listeners() {
+        // given
+        Foo mock = mock(Foo.class, withSettings().stubbingLookupListeners(listener, listener2));
+
+        // when
+        mockingDetails(mock).getMockCreationSettings().getStubbingLookupListeners().clear();
+        mock.doSomething("foo");
+
+        // then
+        verifyNoInteractions(listener, listener2);
+    }
+
+    @Test
+    public void add_listeners_concurrently_sanity_check() throws Exception {
+        // given
+        final IMethods mock = mock(IMethods.class);
+        final MockCreationSettings<?> settings = mockingDetails(mock).getMockCreationSettings();
+
+        List<Runnable> runnables = new LinkedList<Runnable>();
+        for (int i = 0; i < 50; i++) {
+            runnables.add(
+                    new Runnable() {
+                        public void run() {
+                            StubbingLookupListener listener1 = mock(StubbingLookupListener.class);
+                            StubbingLookupListener listener2 = mock(StubbingLookupListener.class);
+                            settings.getStubbingLookupListeners().add(listener1);
+                            settings.getStubbingLookupListeners().add(listener2);
+                            settings.getStubbingLookupListeners().remove(listener1);
+                        }
+                    });
+        }
+
+        // when
+        ConcurrentTesting.concurrently(runnables.toArray(new Runnable[runnables.size()]));
+
+        // then
+        // This assertion may be flaky. If it is let's fix it or remove the test. For now, I'm
+        // keeping the test.
+        assertEquals(50, settings.getStubbingLookupListeners().size());
+    }
+
+    private static class NoWater extends RuntimeException {}
+}
diff --git a/src/test/java/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java b/src/test/java/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java
index df985ce..6696c12 100644
--- a/src/test/java/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java
+++ b/src/test/java/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockitousage.debugging;
 
+import static org.junit.Assert.fail;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+
 import org.assertj.core.api.Assertions;
 import org.junit.After;
 import org.junit.Before;
@@ -13,13 +20,6 @@ import org.mockito.Mock;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.io.ByteArrayOutputStream;
-import java.io.PrintStream;
-
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.*;
-
 /**
  * Tests the verbose logging of invocation on mock methods.
  *
@@ -123,8 +123,8 @@ public class VerboseLoggingOfInvocationsOnMockTest {
     @Test
     public void shouldPrintRealInvocationOnSpyToStdOut() {
         // given
-        FooImpl fooSpy = mock(FooImpl.class,
-                withSettings().spiedInstance(new FooImpl()).verboseLogging());
+        FooImpl fooSpy =
+                mock(FooImpl.class, withSettings().spiedInstance(new FooImpl()).verboseLogging());
         doCallRealMethod().when(fooSpy).doSomething("Klipsch");
 
         // when
@@ -142,8 +142,7 @@ public class VerboseLoggingOfInvocationsOnMockTest {
     public void usage() {
         // given
         Foo foo = mock(Foo.class, withSettings().verboseLogging());
-        given(foo.giveMeSomeString("Apple")).willReturn(
-                "earbuds");
+        given(foo.giveMeSomeString("Apple")).willReturn("earbuds");
 
         // when
         foo.giveMeSomeString("Shure");
@@ -160,8 +159,7 @@ public class VerboseLoggingOfInvocationsOnMockTest {
     }
 
     private static class UnrelatedClass {
-        void unrelatedMethod(String anotherStringValue) {
-        }
+        void unrelatedMethod(String anotherStringValue) {}
     }
 
     /**
@@ -177,7 +175,6 @@ public class VerboseLoggingOfInvocationsOnMockTest {
             return null;
         }
 
-        public void doSomething(String param) {
-        }
+        public void doSomething(String param) {}
     }
 }
diff --git a/src/test/java/org/mockitousage/debugging/VerificationListenerCallBackTest.java b/src/test/java/org/mockitousage/debugging/VerificationListenerCallBackTest.java
index 37537a6..7ce75f1 100644
--- a/src/test/java/org/mockitousage/debugging/VerificationListenerCallBackTest.java
+++ b/src/test/java/org/mockitousage/debugging/VerificationListenerCallBackTest.java
@@ -4,6 +4,12 @@
  */
 package org.mockitousage.debugging;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
+import java.lang.reflect.Method;
+
 import org.assertj.core.api.Condition;
 import org.junit.After;
 import org.junit.Test;
@@ -18,12 +24,6 @@ import org.mockito.verification.VerificationEvent;
 import org.mockito.verification.VerificationMode;
 import org.mockitoutil.TestBase;
 
-import java.lang.reflect.Method;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class VerificationListenerCallBackTest extends TestBase {
 
     @After
@@ -33,7 +33,7 @@ public class VerificationListenerCallBackTest extends TestBase {
 
     @Test
     public void should_call_single_listener_on_verify() throws NoSuchMethodException {
-        //given
+        // given
         RememberingListener listener = new RememberingListener();
         MockitoFramework mockitoFramework = Mockito.framework();
         mockitoFramework.addListener(listener);
@@ -41,17 +41,17 @@ public class VerificationListenerCallBackTest extends TestBase {
         Method invocationWanted = Foo.class.getDeclaredMethod("doSomething", String.class);
         Foo foo = mock(Foo.class);
 
-        //when
+        // when
         VerificationMode never = never();
         verify(foo, never).doSomething("");
 
-        //then
+        // then
         assertThat(listener).is(notifiedFor(foo, never, invocationWanted));
     }
 
     @Test
     public void should_call_all_listeners_on_verify() throws NoSuchMethodException {
-        //given
+        // given
         RememberingListener listener1 = new RememberingListener();
         RememberingListener2 listener2 = new RememberingListener2();
         Mockito.framework().addListener(listener1).addListener(listener2);
@@ -59,18 +59,18 @@ public class VerificationListenerCallBackTest extends TestBase {
         Method invocationWanted = Foo.class.getDeclaredMethod("doSomething", String.class);
         Foo foo = mock(Foo.class);
 
-        //when
+        // when
         VerificationMode never = never();
         verify(foo, never).doSomething("");
 
-        //then
+        // then
         assertThat(listener1).is(notifiedFor(foo, never, invocationWanted));
         assertThat(listener2).is(notifiedFor(foo, never, invocationWanted));
     }
 
     @Test
     public void should_not_call_listener_when_verify_was_called_incorrectly() {
-        //when
+        // when
         VerificationListener listener = mock(VerificationListener.class);
         framework().addListener(listener);
         Foo foo = null;
@@ -79,59 +79,59 @@ public class VerificationListenerCallBackTest extends TestBase {
             verify(foo).doSomething("");
             fail("Exception expected.");
         } catch (Exception e) {
-            //then
+            // then
             verify(listener, never()).onVerification(any(VerificationEvent.class));
         }
     }
 
     @Test
     public void should_notify_when_verification_throws_type_error() {
-        //given
+        // given
         RememberingListener listener = new RememberingListener();
         MockitoFramework mockitoFramework = Mockito.framework();
         mockitoFramework.addListener(listener);
         Foo foo = mock(Foo.class);
 
-        //when
+        // when
         try {
             verify(foo).doSomething("");
             fail("Exception expected.");
         } catch (Throwable e) {
-            //then
+            // then
             assertThat(listener.cause).isInstanceOf(MockitoAssertionError.class);
         }
     }
 
     @Test
     public void should_notify_when_verification_throws_runtime_exception() {
-        //given
+        // given
         RememberingListener listener = new RememberingListener();
         MockitoFramework mockitoFramework = Mockito.framework();
         mockitoFramework.addListener(listener);
         Foo foo = mock(Foo.class);
 
-        //when
+        // when
         try {
             verify(foo, new RuntimeExceptionVerificationMode()).doSomething("");
             fail("Exception expected.");
         } catch (Throwable e) {
-            //then
+            // then
             assertThat(listener.cause).isInstanceOf(RuntimeException.class);
         }
     }
 
     @Test
     public void should_call_verification_listeners() {
-        //given
+        // given
         RememberingListener listener = new RememberingListener();
         MockitoFramework mockitoFramework = Mockito.framework();
         mockitoFramework.addListener(listener);
         JUnitCore runner = new JUnitCore();
 
-        //when
+        // when
         runner.run(VerificationListenerSample.class);
 
-        //then
+        // then
         assertThat(listener.mock).isNotNull();
         assertThat(listener.mode).isEqualToComparingFieldByField(times(1));
     }
@@ -160,16 +160,16 @@ public class VerificationListenerCallBackTest extends TestBase {
         }
     }
 
-    private static class RememberingListener2 extends RememberingListener {
-
-    }
+    private static class RememberingListener2 extends RememberingListener {}
 
-    private static Condition<RememberingListener> notifiedFor(final Object mock, final VerificationMode mode, final Method wantedMethod) {
+    private static Condition<RememberingListener> notifiedFor(
+            final Object mock, final VerificationMode mode, final Method wantedMethod) {
         return new Condition<RememberingListener>() {
             public boolean matches(RememberingListener listener) {
                 assertThat(listener.mock).isEqualTo(mock);
                 assertThat(listener.mode).isEqualTo(mode);
-                assertThat(listener.data.getTarget().getInvocation().getMethod()).isEqualTo(wantedMethod);
+                assertThat(listener.data.getTarget().getInvocation().getMethod())
+                        .isEqualTo(wantedMethod);
 
                 return true;
             }
diff --git a/src/test/java/org/mockitousage/examples/use/Article.java b/src/test/java/org/mockitousage/examples/use/Article.java
index 6c0d360..f5aef64 100644
--- a/src/test/java/org/mockitousage/examples/use/Article.java
+++ b/src/test/java/org/mockitousage/examples/use/Article.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.examples.use;
 
 public class Article {
diff --git a/src/test/java/org/mockitousage/examples/use/ArticleCalculator.java b/src/test/java/org/mockitousage/examples/use/ArticleCalculator.java
index 8a96f36..b3b5412 100644
--- a/src/test/java/org/mockitousage/examples/use/ArticleCalculator.java
+++ b/src/test/java/org/mockitousage/examples/use/ArticleCalculator.java
@@ -2,12 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.examples.use;
 
 public interface ArticleCalculator {
     int countArticles(String newspaper);
+
     int countArticlesInPolish(String newspaper);
+
     int countNumberOfRelatedArticles(Article article);
-    int countAllArticles(String ... publications);
+
+    int countAllArticles(String... publications);
 }
diff --git a/src/test/java/org/mockitousage/examples/use/ArticleDatabase.java b/src/test/java/org/mockitousage/examples/use/ArticleDatabase.java
index 7041f54..f459902 100644
--- a/src/test/java/org/mockitousage/examples/use/ArticleDatabase.java
+++ b/src/test/java/org/mockitousage/examples/use/ArticleDatabase.java
@@ -2,26 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.examples.use;
 
 import java.util.List;
 
 public class ArticleDatabase {
 
-    public void updateNumberOfArticles(String newspaper, int articles) {
-    }
+    public void updateNumberOfArticles(String newspaper, int articles) {}
 
-    public void updateNumberOfPolishArticles(String newspaper, int polishArticles) {
-    }
+    public void updateNumberOfPolishArticles(String newspaper, int polishArticles) {}
 
-    public void updateNumberOfEnglishArticles(String newspaper, int i) {
-    }
+    public void updateNumberOfEnglishArticles(String newspaper, int i) {}
 
     public List<Article> getArticlesFor(String string) {
         return null;
     }
 
-    public void save(Article article) {
-    }
+    public void save(Article article) {}
 }
diff --git a/src/test/java/org/mockitousage/examples/use/ArticleManager.java b/src/test/java/org/mockitousage/examples/use/ArticleManager.java
index 6b6acd9..0468662 100644
--- a/src/test/java/org/mockitousage/examples/use/ArticleManager.java
+++ b/src/test/java/org/mockitousage/examples/use/ArticleManager.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.examples.use;
 
 import java.util.List;
diff --git a/src/test/java/org/mockitousage/examples/use/ExampleTest.java b/src/test/java/org/mockitousage/examples/use/ExampleTest.java
index 87b400c..4a068e3 100644
--- a/src/test/java/org/mockitousage/examples/use/ExampleTest.java
+++ b/src/test/java/org/mockitousage/examples/use/ExampleTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.examples.use;
 
+import static org.mockito.Mockito.*;
+
+import java.util.Arrays;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -13,10 +16,6 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import java.util.Arrays;
-
-import static org.mockito.Mockito.*;
-
 public class ExampleTest {
 
     @Rule public MockitoRule rule = MockitoJUnit.rule();
@@ -65,7 +64,8 @@ public class ExampleTest {
         when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);
         when(mockCalculator.countNumberOfRelatedArticles(articleThree)).thenReturn(0);
 
-        when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree));
+        when(mockDatabase.getArticlesFor("Guardian"))
+                .thenReturn(Arrays.asList(articleOne, articleTwo, articleThree));
 
         articleManager.updateRelatedArticlesCounters("Guardian");
 
@@ -82,13 +82,14 @@ public class ExampleTest {
         when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);
         when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);
 
-        when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo));
+        when(mockDatabase.getArticlesFor("Guardian"))
+                .thenReturn(Arrays.asList(articleOne, articleTwo));
 
         articleManager.updateRelatedArticlesCounters("Guardian");
 
         InOrder inOrder = inOrder(mockDatabase, mockCalculator);
 
-        inOrder.verify(mockCalculator).countNumberOfRelatedArticles((Article) anyObject());
-        inOrder.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());
+        inOrder.verify(mockCalculator).countNumberOfRelatedArticles(any());
+        inOrder.verify(mockDatabase, atLeastOnce()).save(any());
     }
 }
diff --git a/src/test/java/org/mockitousage/internal/debugging/LocationImplTest.java b/src/test/java/org/mockitousage/internal/debugging/LocationImplTest.java
index 1cd495c..d20bfce 100644
--- a/src/test/java/org/mockitousage/internal/debugging/LocationImplTest.java
+++ b/src/test/java/org/mockitousage/internal/debugging/LocationImplTest.java
@@ -5,36 +5,59 @@
 package org.mockitousage.internal.debugging;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.List;
 
 import org.junit.Test;
 import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.exceptions.stacktrace.StackTraceFilter;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-
 @SuppressWarnings("serial")
 public class LocationImplTest extends TestBase {
 
     @Test
     public void shouldLocationNotContainGetStackTraceMethod() {
-        assertThat(new LocationImpl().toString()).contains("shouldLocationNotContainGetStackTraceMethod");
+        assertThat(new LocationImpl().toString())
+                .contains("shouldLocationNotContainGetStackTraceMethod");
     }
 
     @Test
     public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty() {
-        //given
-        StackTraceFilter filterReturningEmptyArray = new StackTraceFilter() {
-            @Override
-            public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {
-                return new StackTraceElement[0];
-            }
-        };
-
-        //when
+        // given
+        StackTraceFilter filterReturningEmptyArray =
+                new StackTraceFilter() {
+                    @Override
+                    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {
+                        return new StackTraceElement[0];
+                    }
+
+                    @Override
+                    public StackTraceElement filterFirst(Throwable target, boolean isInline) {
+                        return null;
+                    }
+                };
+
+        // when
         String loc = new LocationImpl(filterReturningEmptyArray).toString();
 
-        //then
+        // then
         assertEquals("-> at <<unknown line>>", loc);
     }
+
+    @Test
+    public void provides_location_class() {
+        // when
+        final List<String> files = new ArrayList<String>();
+        new Runnable() { // anonymous inner class adds stress to the check
+            public void run() {
+                files.add(new LocationImpl().getSourceFile());
+            }
+        }.run();
+
+        // then
+        assertEquals("LocationImplTest.java", files.get(0));
+    }
 }
diff --git a/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java b/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
index 0eb3d7d..38db251 100644
--- a/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
+++ b/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
@@ -4,6 +4,15 @@
  */
 package org.mockitousage.internal.junit;
 
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.when;
+
+import java.util.Collection;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.internal.junit.UnusedStubbings;
@@ -11,14 +20,6 @@ import org.mockito.internal.junit.UnusedStubbingsFinder;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.Collection;
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.when;
-
 /**
  * This unit test lives in 'org.mockitousage' package for a reason.
  * It makes it easy to write tests that depend on the stack trace filtering logic.
@@ -33,38 +34,38 @@ public class UnusedStubbingsFinderTest extends TestBase {
 
     @Test
     public void no_interactions() throws Exception {
-        //expect
+        // expect
         assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
         assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
     }
 
     @Test
     public void no_stubbings() throws Exception {
-        //when
+        // when
         mock1.simpleMethod();
 
-        //then
+        // then
         assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
         assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
     }
 
     @Test
     public void no_unused_stubbings() throws Exception {
-        //when
+        // when
         when(mock1.simpleMethod()).thenReturn("1");
         mock1.simpleMethod();
 
-        //then
+        // then
         assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
         assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
     }
 
     @Test
     public void unused_stubbings() throws Exception {
-        //when
+        // when
         when(mock1.simpleMethod()).thenReturn("1");
 
-        //then
+        // then
         assertEquals(1, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
         assertEquals(1, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
     }
@@ -77,12 +78,13 @@ public class UnusedStubbingsFinderTest extends TestBase {
 
         mock2.simpleMethod(2);
 
-        //when
+        // when
         UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(2, stubbings.size());
-        assertEquals("[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
+        assertEquals(
+                "[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
                 stubbings.toString());
     }
 
@@ -94,13 +96,12 @@ public class UnusedStubbingsFinderTest extends TestBase {
 
         mock1.simpleMethod(1);
 
-        //when
+        // when
         UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(1, stubbings.size());
-        assertEquals("[mock1.simpleMethod(2); stubbed with: [Returns: 2]]",
-                stubbings.toString());
+        assertEquals("[mock1.simpleMethod(2); stubbed with: [Returns: 2]]", stubbings.toString());
     }
 
     @Test
@@ -108,43 +109,43 @@ public class UnusedStubbingsFinderTest extends TestBase {
         when(mock1.simpleMethod(1)).thenReturn("1");
         when(mock2.simpleMethod(2)).thenReturn("2");
         when(mock2.simpleMethod(3)).thenReturn("3");
-        lenient().when(mock2.differentMethod()).thenReturn("4"); //will not be included in results
+        lenient().when(mock2.differentMethod()).thenReturn("4"); // will not be included in results
 
         mock2.simpleMethod(2);
 
-        //when
+        // when
         Collection stubbings = finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(2, stubbings.size());
         assertEquals("[mock1.simpleMethod(1);, mock2.simpleMethod(3);]", stubbings.toString());
     }
 
     @Test
     public void stubbing_used_by_location() throws Exception {
-        //when
-        //Emulating stubbing in the same location by putting stubbing in the same line:
+        // when
+        // Emulating stubbing in the same location by putting stubbing in the same line:
         when(mock1.simpleMethod(1)).thenReturn("1"); when(mock2.simpleMethod(1)).thenReturn("1");
-        //End of emulation
+        // End of emulation
         mock1.simpleMethod(1);
 
-        //then technically unused stubbings exist
+        // then technically unused stubbings exist
         assertEquals(1, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
-        //however if we consider stubbings in the same location as the same stubbing, all is used:
+        // however if we consider stubbings in the same location as the same stubbing, all is used:
         assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
     }
 
     @Test
     public void deduplicates_stubbings_by_location() throws Exception {
-        //when
-        //Emulating stubbing in the same location by putting stubbing in the same line:
+        // when
+        // Emulating stubbing in the same location by putting stubbing in the same line:
         when(mock1.simpleMethod(1)).thenReturn("1"); when(mock2.simpleMethod(1)).thenReturn("1");
-        //End of emulation
+        // End of emulation
 
-        //when
+        // when
         Collection stubbings = finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2));
 
-        //then
+        // then
         assertEquals(1, stubbings.size());
     }
 }
diff --git a/src/test/java/org/mockitousage/jls/JLS_15_12_2_5Test.java b/src/test/java/org/mockitousage/jls/JLS_15_12_2_5Test.java
index b427b30..1c3dcb5 100644
--- a/src/test/java/org/mockitousage/jls/JLS_15_12_2_5Test.java
+++ b/src/test/java/org/mockitousage/jls/JLS_15_12_2_5Test.java
@@ -4,13 +4,6 @@
  */
 package org.mockitousage.jls;
 
-import net.bytebuddy.ClassFileVersion;
-import org.junit.Assume;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.experimental.runners.Enclosed;
-import org.junit.runner.RunWith;
-
 import static net.bytebuddy.ClassFileVersion.JAVA_V6;
 import static net.bytebuddy.ClassFileVersion.JAVA_V7;
 import static net.bytebuddy.ClassFileVersion.JAVA_V8;
@@ -19,6 +12,12 @@ import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import net.bytebuddy.ClassFileVersion;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
+import org.junit.runner.RunWith;
 
 /**
  * Illustrate differences in the JLS depending on the Java version.
@@ -46,8 +45,10 @@ public class JLS_15_12_2_5Test {
     public static class JLS_15_12_2_5_Java6_Java7_Test {
         @Before
         public void setUp() throws Exception {
-            Assume.assumeTrue(ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class).equals(JAVA_V6)
-                              || ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class).equals(JAVA_V7));
+            Assume.assumeTrue(
+                    ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class).equals(JAVA_V6)
+                            || ClassFileVersion.of(JLS_15_12_2_5_Java6_Java7_Test.class)
+                                    .equals(JAVA_V7));
         }
 
         @Test
@@ -56,10 +57,12 @@ public class JLS_15_12_2_5Test {
 
             when(mock.oneArg(isNull())).thenReturn("ok");
 
-            assertThat(mock.oneArg(null)).describedAs("Most generic method chosen for matcher " +
-                                                      "(isNull generic upper bound is Object), but null applies " +
-                                                      "to select most specific method")
-                                         .isEqualTo(null);
+            assertThat(mock.oneArg(null))
+                    .describedAs(
+                            "Most generic method chosen for matcher "
+                                    + "(isNull generic upper bound is Object), but null applies "
+                                    + "to select most specific method")
+                    .isEqualTo(null);
         }
 
         @Test
@@ -68,7 +71,9 @@ public class JLS_15_12_2_5Test {
 
             when(mock.oneArg((String) isNull())).thenReturn("ok");
 
-            assertThat(mock.oneArg(null)).describedAs("Most specific method enforced for matcher via cast").isEqualTo("ok");
+            assertThat(mock.oneArg(null))
+                    .describedAs("Most specific method enforced for matcher via cast")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -78,7 +83,9 @@ public class JLS_15_12_2_5Test {
             when(mock.oneArg(isNull())).thenReturn("ok");
 
             Object arg = null;
-            assertThat(mock.oneArg(arg)).describedAs("Most generic method chosen for matcher").isEqualTo("ok");
+            assertThat(mock.oneArg(arg))
+                    .describedAs("Most generic method chosen for matcher")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -87,10 +94,12 @@ public class JLS_15_12_2_5Test {
 
             when(mock.varargs(isNull())).thenReturn("ok");
 
-            assertThat(mock.varargs(null)).describedAs("Most generic method chosen for matcher " +
-                                                       "(isNull generic upper bound is Object), but null applies " +
-                                                       "to select most specific method")
-                                          .isEqualTo(null);
+            assertThat(mock.varargs(null))
+                    .describedAs(
+                            "Most generic method chosen for matcher "
+                                    + "(isNull generic upper bound is Object), but null applies "
+                                    + "to select most specific method")
+                    .isEqualTo(null);
         }
 
         @Test
@@ -99,7 +108,9 @@ public class JLS_15_12_2_5Test {
 
             when(mock.varargs((String) isNull())).thenReturn("ok");
 
-            assertThat(mock.varargs(null)).describedAs("Most specific method enforced for matcher via String cast").isEqualTo("ok");
+            assertThat(mock.varargs(null))
+                    .describedAs("Most specific method enforced for matcher via String cast")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -108,7 +119,9 @@ public class JLS_15_12_2_5Test {
 
             when(mock.varargs((String[]) isNull())).thenReturn("ok");
 
-            assertThat(mock.varargs(null)).describedAs("Most specific method enforced for matcher via String[] cast").isEqualTo("ok");
+            assertThat(mock.varargs(null))
+                    .describedAs("Most specific method enforced for matcher via String[] cast")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -118,7 +131,9 @@ public class JLS_15_12_2_5Test {
             when(mock.varargs(isNull())).thenReturn("ok");
 
             Object[] args = null;
-            assertThat(mock.varargs(args)).describedAs("isNull matcher generic upper bound is Object").isEqualTo("ok");
+            assertThat(mock.varargs(args))
+                    .describedAs("isNull matcher generic upper bound is Object")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -128,7 +143,9 @@ public class JLS_15_12_2_5Test {
             when(mock.varargs(isNull())).thenReturn("ok");
 
             Object arg = null;
-            assertThat(mock.varargs(arg)).describedAs("isNull matcher generic upper bound is Object").isEqualTo("ok");
+            assertThat(mock.varargs(arg))
+                    .describedAs("isNull matcher generic upper bound is Object")
+                    .isEqualTo("ok");
         }
     }
 
@@ -181,7 +198,8 @@ public class JLS_15_12_2_5Test {
     public static class JLS_15_12_2_5_Java8_Test {
         @Before
         public void setUp() throws Exception {
-            Assume.assumeTrue(ClassFileVersion.of(JLS_15_12_2_5_Java8_Test.class).isAtLeast(JAVA_V8));
+            Assume.assumeTrue(
+                    ClassFileVersion.of(JLS_15_12_2_5_Java8_Test.class).isAtLeast(JAVA_V8));
         }
 
         @Test
@@ -190,7 +208,9 @@ public class JLS_15_12_2_5Test {
 
             when(mock.oneArg(isNull())).thenReturn("ok");
 
-            assertThat(mock.oneArg(null)).describedAs("Most specific method chosen for matcher and for null").isEqualTo("ok");
+            assertThat(mock.oneArg(null))
+                    .describedAs("Most specific method chosen for matcher and for null")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -209,7 +229,9 @@ public class JLS_15_12_2_5Test {
 
             when(mock.varargs(isNull())).thenReturn("ok");
 
-            assertThat(mock.varargs(null)).describedAs("Most specific method chosen for matcher and for null").isEqualTo("ok");
+            assertThat(mock.varargs(null))
+                    .describedAs("Most specific method chosen for matcher and for null")
+                    .isEqualTo("ok");
         }
 
         @Test
@@ -219,7 +241,9 @@ public class JLS_15_12_2_5Test {
             when(mock.varargs(isNull())).thenReturn("ok");
 
             Object[] args = null;
-            assertThat(mock.varargs(args)).describedAs("Most specific method chosen for matcher").isEqualTo(null);
+            assertThat(mock.varargs(args))
+                    .describedAs("Most specific method chosen for matcher")
+                    .isEqualTo(null);
         }
 
         @Test
@@ -229,16 +253,19 @@ public class JLS_15_12_2_5Test {
             when(mock.varargs(isNull())).thenReturn("ok");
 
             Object arg = null;
-            assertThat(mock.varargs(arg)).describedAs("Most specific method chosen for matcher").isEqualTo(null);
+            assertThat(mock.varargs(arg))
+                    .describedAs("Most specific method chosen for matcher")
+                    .isEqualTo(null);
         }
-
     }
 
     interface SingleOverload {
         String oneArg(Object arg);
+
         String oneArg(String arg);
+
         String varargs(Object... args);
+
         String varargs(String... args);
     }
-
 }
diff --git a/src/test/java/org/mockitousage/junitrule/InvalidTargetMockitoJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/InvalidTargetMockitoJUnitRuleTest.java
index ce0eb07..b206151 100644
--- a/src/test/java/org/mockitousage/junitrule/InvalidTargetMockitoJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/InvalidTargetMockitoJUnitRuleTest.java
@@ -4,6 +4,8 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.InjectMocks;
@@ -11,18 +13,13 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static org.junit.Assert.assertNotNull;
-
 public class InvalidTargetMockitoJUnitRuleTest {
 
-    @Rule
-    public MockitoRule mockitoJUnitRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoJUnitRule = MockitoJUnit.rule();
 
-    @Mock
-    private Injected injected;
+    @Mock private Injected injected;
 
-    @InjectMocks
-    private InjectInto injectInto;
+    @InjectMocks private InjectInto injectInto;
 
     @Test
     public void shouldInjectWithInvalidReference() throws Exception {
@@ -30,7 +27,7 @@ public class InvalidTargetMockitoJUnitRuleTest {
         assertNotNull("Test object created", injectInto);
     }
 
-    public static class Injected { }
+    public static class Injected {}
 
     public static class InjectInto {
         private Injected injected;
diff --git a/src/test/java/org/mockitousage/junitrule/JUnitTestRuleIntegratesWithRuleChainTest.java b/src/test/java/org/mockitousage/junitrule/JUnitTestRuleIntegratesWithRuleChainTest.java
new file mode 100644
index 0000000..498d2bc
--- /dev/null
+++ b/src/test/java/org/mockitousage/junitrule/JUnitTestRuleIntegratesWithRuleChainTest.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.junitrule;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runners.model.Statement;
+import org.mockito.Mock;
+import org.mockito.internal.util.MockUtil;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.quality.Strictness;
+import org.mockitousage.IMethods;
+import org.mockitoutil.JUnitResultAssert;
+
+public class JUnitTestRuleIntegratesWithRuleChainTest {
+
+    JUnitCore runner = new JUnitCore();
+
+    @Test
+    public void rule_can_be_changed_to_strict() {
+        // when
+        Result result = runner.run(StrictByDefault.class);
+
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(1).fails(1, RuntimeException.class);
+    }
+
+    @Test
+    public void rule_can_be_changed_to_lenient() {
+        // when
+        Result result = runner.run(LenientByDefault.class);
+
+        // then
+        JUnitResultAssert.assertThat(result).isSuccessful();
+    }
+
+    public static class LenientByDefault {
+        @Rule
+        public final RuleChain chain =
+                RuleChain.outerRule(MockitoJUnit.testRule(this))
+                        .around(
+                                (base, description) ->
+                                        new Statement() {
+                                            @Override
+                                            public void evaluate() throws Throwable {
+                                                assertThat(MockUtil.isMock(mock)).isTrue();
+                                                called.set(true);
+                                                base.evaluate();
+                                            }
+                                        });
+
+        @Mock public IMethods mock;
+
+        private AtomicBoolean called = new AtomicBoolean(false);
+
+        @Test
+        public void creates_mocks_in_correct_rulechain_ordering() {
+            assertThat(MockUtil.isMock(mock)).isTrue();
+            assertThat(called.get()).isTrue();
+        }
+    }
+
+    public static class StrictByDefault {
+        @Rule
+        public final RuleChain chain =
+                RuleChain.outerRule(MockitoJUnit.testRule(this).strictness(Strictness.STRICT_STUBS))
+                        .around(
+                                (base, description) ->
+                                        new Statement() {
+                                            @Override
+                                            public void evaluate() throws Throwable {
+                                                assertThat(MockUtil.isMock(mock)).isTrue();
+                                                called.set(true);
+                                                base.evaluate();
+                                            }
+                                        });
+
+        @Mock public IMethods mock;
+
+        private AtomicBoolean called = new AtomicBoolean(false);
+
+        @Test
+        public void creates_mocks_in_correct_rulechain_ordering() {
+            assertThat(MockUtil.isMock(mock)).isTrue();
+            assertThat(called.get()).isTrue();
+        }
+
+        @Test
+        public void unused_stub() throws Throwable {
+            when(mock.simpleMethod()).thenReturn("1");
+            assertThat(called.get()).isTrue();
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/junitrule/LenientJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/LenientJUnitRuleTest.java
index 2e13171..617090a 100644
--- a/src/test/java/org/mockitousage/junitrule/LenientJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/LenientJUnitRuleTest.java
@@ -4,40 +4,41 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.mockito.Mockito.when;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.quality.Strictness;
 import org.mockito.internal.junit.JUnitRule;
-import org.mockito.internal.util.MockitoLogger;
 import org.mockito.junit.MockitoRule;
+import org.mockito.plugins.MockitoLogger;
+import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 
-import static org.mockito.Mockito.when;
-
 public class LenientJUnitRuleTest {
 
-    private MockitoLogger explosiveLogger = new MockitoLogger() {
-        public void log(Object what) {
-            throw new RuntimeException("Silent rule should not write anything to the logger");
-        }
-    };
+    private MockitoLogger explosiveLogger =
+            what -> {
+                throw new RuntimeException("Silent rule should not write anything to the logger");
+            };
     @Mock private IMethods mock;
 
     @Rule public MockitoRule mockitoRule = new JUnitRule(explosiveLogger, Strictness.LENIENT);
 
-    @Test public void no_warning_for_unused_stubbing() throws Exception {
+    @Test
+    public void no_warning_for_unused_stubbing() {
         when(mock.simpleMethod(1)).thenReturn("1");
     }
 
-    @Test public void no_warning_for_stubbing_arg_mismatch() throws Exception {
+    @Test
+    public void no_warning_for_stubbing_arg_mismatch() {
         when(mock.simpleMethod(1)).thenReturn("1");
         mock.simpleMethod(2);
     }
 
-    @Test(expected = IllegalStateException.class) public void no_warning_for_stubbing_arg_mismatch_on_failure() throws Exception {
+    @Test
+    public void no_warning_for_stubbing_arg_mismatch_on_failure() {
         when(mock.simpleMethod(1)).thenReturn("1");
         mock.simpleMethod(2);
-        throw new IllegalStateException("hey!");
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrule/MockitoJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/MockitoJUnitRuleTest.java
index dfec883..1c6930e 100644
--- a/src/test/java/org/mockitousage/junitrule/MockitoJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/MockitoJUnitRuleTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.InjectMocks;
@@ -11,19 +14,16 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
 public class MockitoJUnitRuleTest {
 
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
+
+    // Fixes #1578: Protect against multiple execution.
+    @Rule public MockitoRule mockitoRule2 = mockitoRule;
 
-    @Mock
-    private Injected injected;
+    @Mock private Injected injected;
 
-    @InjectMocks
-    private InjectInto injectInto;
+    @InjectMocks private InjectInto injectInto;
 
     @Test
     public void testInjectMocks() throws Exception {
@@ -32,7 +32,7 @@ public class MockitoJUnitRuleTest {
         assertEquals("A injected into B", injected, injectInto.getInjected());
     }
 
-    public static class Injected { }
+    public static class Injected {}
 
     public static class InjectInto {
         private Injected injected;
diff --git a/src/test/java/org/mockitousage/junitrule/MockitoJUnitTestRuleTest.java b/src/test/java/org/mockitousage/junitrule/MockitoJUnitTestRuleTest.java
new file mode 100644
index 0000000..122b3c1
--- /dev/null
+++ b/src/test/java/org/mockitousage/junitrule/MockitoJUnitTestRuleTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.junitrule;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoTestRule;
+
+public class MockitoJUnitTestRuleTest {
+
+    @Rule public MockitoTestRule mockitoRule = MockitoJUnit.testRule(this);
+
+    // Fixes #1578: Protect against multiple execution.
+    @Rule public MockitoTestRule mockitoRule2 = mockitoRule;
+
+    @Mock private Injected injected;
+
+    @InjectMocks private InjectInto injectInto;
+
+    @Test
+    public void testInjectMocks() throws Exception {
+        assertNotNull("Mock created", injected);
+        assertNotNull("Object created", injectInto);
+        assertEquals("A injected into B", injected, injectInto.getInjected());
+    }
+
+    public static class Injected {}
+
+    public static class InjectInto {
+        private Injected injected;
+
+        public Injected getInjected() {
+            return injected;
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitRuleTest.java
index b9208e5..b0efc2c 100644
--- a/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitRuleTest.java
@@ -4,6 +4,8 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.mockito.Mockito.when;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
@@ -15,42 +17,40 @@ import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 import org.mockitoutil.JUnitResultAssert;
 
-import static org.mockito.Mockito.when;
-
 public class MutableStrictJUnitRuleTest {
 
     JUnitCore runner = new JUnitCore();
 
-    @Test public void rule_can_be_changed_to_strict() throws Throwable {
-        //when
+    @Test
+    public void rule_can_be_changed_to_strict() throws Throwable {
+        // when
         Result result = runner.run(LenientByDefault.class);
 
-        //then
-        JUnitResultAssert.assertThat(result)
-                .succeeds(1)
-                .fails(1, RuntimeException.class);
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(1).fails(1, RuntimeException.class);
     }
 
-    @Test public void rule_can_be_changed_to_lenient() throws Throwable {
-        //when
+    @Test
+    public void rule_can_be_changed_to_lenient() throws Throwable {
+        // when
         Result result = runner.run(StrictByDefault.class);
 
-        //then
-        JUnitResultAssert.assertThat(result)
-                .succeeds(1)
-                .fails(1, RuntimeException.class);
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(1).fails(1, RuntimeException.class);
     }
 
     public static class LenientByDefault {
         @Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.LENIENT);
         @Mock IMethods mock;
 
-        @Test public void unused_stub() throws Throwable {
+        @Test
+        public void unused_stub() throws Throwable {
             when(mock.simpleMethod()).thenReturn("1");
         }
 
-        @Test public void unused_stub_with_strictness() throws Throwable {
-            //making Mockito strict only for this test method
+        @Test
+        public void unused_stub_with_strictness() throws Throwable {
+            // making Mockito strict only for this test method
             mockito.strictness(Strictness.STRICT_STUBS);
 
             when(mock.simpleMethod()).thenReturn("1");
@@ -61,12 +61,14 @@ public class MutableStrictJUnitRuleTest {
         @Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
         @Mock IMethods mock;
 
-        @Test public void unused_stub() throws Throwable {
+        @Test
+        public void unused_stub() throws Throwable {
             when(mock.simpleMethod()).thenReturn("1");
         }
 
-        @Test public void unused_stub_with_lenient() throws Throwable {
-            //making Mockito lenient only for this test method
+        @Test
+        public void unused_stub_with_lenient() throws Throwable {
+            // making Mockito lenient only for this test method
             mockito.strictness(Strictness.LENIENT);
 
             when(mock.simpleMethod()).thenReturn("1");
diff --git a/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitTestRuleTest.java b/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitTestRuleTest.java
new file mode 100644
index 0000000..1e2faac
--- /dev/null
+++ b/src/test/java/org/mockitousage/junitrule/MutableStrictJUnitTestRuleTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.junitrule;
+
+import static org.mockito.Mockito.when;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoTestRule;
+import org.mockito.quality.Strictness;
+import org.mockitousage.IMethods;
+import org.mockitoutil.JUnitResultAssert;
+
+public class MutableStrictJUnitTestRuleTest {
+
+    JUnitCore runner = new JUnitCore();
+
+    @Test
+    public void rule_can_be_changed_to_strict() throws Throwable {
+        // when
+        Result result = runner.run(LenientByDefault.class);
+
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(1).fails(1, RuntimeException.class);
+    }
+
+    @Test
+    public void rule_can_be_changed_to_lenient() throws Throwable {
+        // when
+        Result result = runner.run(StrictByDefault.class);
+
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(1).fails(1, RuntimeException.class);
+    }
+
+    public static class LenientByDefault {
+        @Rule
+        public MockitoTestRule mockito = MockitoJUnit.testRule(this).strictness(Strictness.LENIENT);
+
+        @Mock IMethods mock;
+
+        @Test
+        public void unused_stub() throws Throwable {
+            when(mock.simpleMethod()).thenReturn("1");
+        }
+
+        @Test
+        public void unused_stub_with_strictness() throws Throwable {
+            // making Mockito strict only for this test method
+            mockito.strictness(Strictness.STRICT_STUBS);
+
+            when(mock.simpleMethod()).thenReturn("1");
+        }
+    }
+
+    public static class StrictByDefault {
+        @Rule
+        public MockitoTestRule mockito =
+                MockitoJUnit.testRule(this).strictness(Strictness.STRICT_STUBS);
+
+        @Mock IMethods mock;
+
+        @Test
+        public void unused_stub() throws Throwable {
+            when(mock.simpleMethod()).thenReturn("1");
+        }
+
+        @Test
+        public void unused_stub_with_lenient() throws Throwable {
+            // making Mockito lenient only for this test method
+            mockito.strictness(Strictness.LENIENT);
+
+            when(mock.simpleMethod()).thenReturn("1");
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/junitrule/RuleTestWithFactoryMethodTest.java b/src/test/java/org/mockitousage/junitrule/RuleTestWithFactoryMethodTest.java
index 626e581..e7d6130 100644
--- a/src/test/java/org/mockitousage/junitrule/RuleTestWithFactoryMethodTest.java
+++ b/src/test/java/org/mockitousage/junitrule/RuleTestWithFactoryMethodTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.InjectMocks;
@@ -11,30 +14,22 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
 public class RuleTestWithFactoryMethodTest {
 
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
 
-    @Mock
-    private Injected injected;
+    @Mock private Injected injected;
 
-    @InjectMocks
-    private InjectInto injectInto;
+    @InjectMocks private InjectInto injectInto;
 
     @Test
     public void testInjectMocks() throws Exception {
         assertNotNull("Mock created", injected);
         assertNotNull("Object created", injectInto);
         assertEquals("A injected into B", injected, injectInto.getInjected());
-
     }
 
-    public static class Injected {
-    }
+    public static class Injected {}
 
     public static class InjectInto {
 
diff --git a/src/test/java/org/mockitousage/junitrule/RuleTestWithParameterConstructorTest.java b/src/test/java/org/mockitousage/junitrule/RuleTestWithParameterConstructorTest.java
index 78196f6..be56e87 100644
--- a/src/test/java/org/mockitousage/junitrule/RuleTestWithParameterConstructorTest.java
+++ b/src/test/java/org/mockitousage/junitrule/RuleTestWithParameterConstructorTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.InjectMocks;
@@ -11,30 +14,22 @@ import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
 public class RuleTestWithParameterConstructorTest {
 
-	 @Rule
-	 public MockitoRule mockitoJUnitRule = MockitoJUnit.rule();
+    @Rule public MockitoRule mockitoJUnitRule = MockitoJUnit.rule();
 
-    @Mock
-    private Injected injected;
+    @Mock private Injected injected;
 
-    @InjectMocks
-    private InjectInto injectInto;
+    @InjectMocks private InjectInto injectInto;
 
     @Test
     public void testInjectMocks() throws Exception {
         assertNotNull("Mock created", injected);
         assertNotNull("Object created", injectInto);
         assertEquals("A injected into B", injected, injectInto.getInjected());
-
     }
 
-    public static class Injected {
-    }
+    public static class Injected {}
 
     public static class InjectInto {
 
diff --git a/src/test/java/org/mockitousage/junitrule/StrictJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/StrictJUnitRuleTest.java
index b802013..6c6d1ac 100644
--- a/src/test/java/org/mockitousage/junitrule/StrictJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/StrictJUnitRuleTest.java
@@ -4,6 +4,14 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.willReturn;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+import static org.mockitoutil.TestBase.filterLineNo;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Rule;
 import org.junit.Test;
@@ -14,155 +22,167 @@ import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
+import org.mockitousage.strictness.ProductionCode;
 import org.mockitoutil.SafeJUnitRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willReturn;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-import static org.mockitoutil.TestBase.filterLineNo;
-
 public class StrictJUnitRuleTest {
 
-    @Rule public SafeJUnitRule rule = new SafeJUnitRule(MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS));
+    @Rule
+    public SafeJUnitRule rule =
+            new SafeJUnitRule(MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS));
 
     @Mock IMethods mock;
     @Mock IMethods mock2;
 
-    @Test public void ok_when_no_stubbings() throws Throwable {
+    @Test
+    public void ok_when_no_stubbings() throws Throwable {
         mock.simpleMethod();
         verify(mock).simpleMethod();
     }
 
-    @Test public void ok_when_all_stubbings_used() throws Throwable {
+    @Test
+    public void ok_when_all_stubbings_used() throws Throwable {
         given(mock.simpleMethod(10)).willReturn("foo");
         mock.simpleMethod(10);
     }
 
-    @Test public void ok_when_used_and_mismatched_argument() throws Throwable {
+    @Test
+    public void ok_when_used_and_mismatched_argument() throws Throwable {
         given(mock.simpleMethod(10)).willReturn("foo");
         mock.simpleMethod(10);
         mock.simpleMethod(15);
     }
 
-    @Test public void fails_when_unused_stubbings() throws Throwable {
-        //expect
+    @Test
+    public void fails_when_unused_stubbings() throws Throwable {
+        // expect
         rule.expectFailure(UnnecessaryStubbingException.class);
 
-        //when
+        // when
         given(mock.simpleMethod(10)).willReturn("foo");
         mock2.simpleMethod(10);
     }
 
-    @Test public void test_failure_trumps_unused_stubbings() throws Throwable {
-        //expect
+    @Test
+    public void test_failure_trumps_unused_stubbings() throws Throwable {
+        // expect
         rule.expectFailure(AssertionError.class, "x");
 
-        //when
+        // when
         given(mock.simpleMethod(10)).willReturn("foo");
         mock.otherMethod();
 
         throw new AssertionError("x");
     }
 
-    @Test public void why_do_return_syntax_is_useful() throws Throwable {
-        //Trade-off of Mockito strictness documented in test
+    @Test
+    public void why_do_return_syntax_is_useful() throws Throwable {
+        // Trade-off of Mockito strictness documented in test
 
-        //expect
+        // expect
         rule.expectFailure(PotentialStubbingProblem.class);
 
-        //when
+        // when
         when(mock.simpleMethod(10)).thenReturn("10");
-        when(mock.simpleMethod(20)).thenReturn("20");
+        ProductionCode.simpleMethod(mock, 20);
     }
 
-    @Test public void fails_fast_when_stubbing_invoked_with_different_argument() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                Assertions.assertThat(t).isInstanceOf(PotentialStubbingProblem.class);
-                assertEquals(filterLineNo("\n" +
-                                "Strict stubbing argument mismatch. Please check:\n" +
-                                " - this invocation of 'simpleMethod' method:\n" +
-                                "    mock.simpleMethod(15);\n" +
-                                "    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
-                                " - has following stubbing(s) with different arguments:\n" +
-                                "    1. mock.simpleMethod(20);\n" +
-                                "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
-                                "    2. mock.simpleMethod(30);\n" +
-                                "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
-                                "Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
-                                "Mockito fails early so that you can debug potential problem easily.\n" +
-                                "However, there are legit scenarios when this exception generates false negative signal:\n" +
-                                "  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
-                                "    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
-                                "  - stubbed method is intentionally invoked with different arguments by code under test\n" +
-                                "    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).\n" +
-                                "For more information see javadoc for PotentialStubbingProblem class."),
-                        filterLineNo(t.getMessage()));
-            }
-        });
-
-        //when stubbings in the test code:
-        willReturn("10").given(mock).simpleMethod(10) ;  //used
-        willReturn("20").given(mock).simpleMethod(20) ;  //unused
-        willReturn("30").given(mock).simpleMethod(30) ;  //unused
-
-        //then
-        mock.otherMethod(); //ok, different method
-        mock.simpleMethod(10); //ok, stubbed with this argument
-
-        //invocation in the code under test uses different argument and should fail immediately
-        //this helps with debugging and is essential for Mockito strictness
-        mock.simpleMethod(15);
+    @Test
+    public void fails_fast_when_stubbing_invoked_with_different_argument() throws Throwable {
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        Assertions.assertThat(t).isInstanceOf(PotentialStubbingProblem.class);
+                        assertEquals(
+                                filterLineNo(
+                                        "\n"
+                                                + "Strict stubbing argument mismatch. Please check:\n"
+                                                + " - this invocation of 'simpleMethod' method:\n"
+                                                + "    mock.simpleMethod(15);\n"
+                                                + "    -> at org.mockitousage.strictness.ProductionCode.simpleMethod(ProductionCode.java:0)\n"
+                                                + " - has following stubbing(s) with different arguments:\n"
+                                                + "    1. mock.simpleMethod(20);\n"
+                                                + "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n"
+                                                + "    2. mock.simpleMethod(30);\n"
+                                                + "      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n"
+                                                + "Typically, stubbing argument mismatch indicates user mistake when writing tests.\n"
+                                                + "Mockito fails early so that you can debug potential problem easily.\n"
+                                                + "However, there are legit scenarios when this exception generates false negative signal:\n"
+                                                + "  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n"
+                                                + "    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n"
+                                                + "  - stubbed method is intentionally invoked with different arguments by code under test\n"
+                                                + "    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).\n"
+                                                + "For more information see javadoc for PotentialStubbingProblem class."),
+                                filterLineNo(t.getMessage()));
+                    }
+                });
+
+        // when stubbings in the test code:
+        willReturn("10").given(mock).simpleMethod(10); // used
+        willReturn("20").given(mock).simpleMethod(20); // unused
+        willReturn("30").given(mock).simpleMethod(30); // unused
+
+        // then
+        mock.otherMethod(); // ok, different method
+        mock.simpleMethod(10); // ok, stubbed with this argument
+
+        // invocation in the code under test uses different argument and should fail immediately
+        // this helps with debugging and is essential for Mockito strictness
+        ProductionCode.simpleMethod(mock, 15);
     }
 
-    @Test public void verify_no_more_interactions_ignores_stubs() throws Throwable {
-        //when stubbing in test:
+    @Test
+    public void verify_no_more_interactions_ignores_stubs() throws Throwable {
+        // when stubbing in test:
         given(mock.simpleMethod(10)).willReturn("foo");
 
-        //and code under test does:
-        mock.simpleMethod(10); //implicitly verifies the stubbing
+        // and code under test does:
+        mock.simpleMethod(10); // implicitly verifies the stubbing
         mock.otherMethod();
 
-        //and in test we:
+        // and in test we:
         verify(mock).otherMethod();
         verifyNoMoreInteractions(mock);
     }
 
-    @Test public void unused_stubs_with_multiple_mocks() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals(filterLineNo("\n" +
-                        "Unnecessary stubbings detected.\n" +
-                        "Clean & maintainable test code requires zero unnecessary code.\n" +
-                        "Following stubbings are unnecessary (click to navigate to relevant line of code):\n" +
-                        "  1. -> at org.mockitousage.junitrule.StrictJUnitRuleTest.unused_stubs_with_multiple_mocks(StrictJUnitRuleTest.java:0)\n" +
-                        "  2. -> at org.mockitousage.junitrule.StrictJUnitRuleTest.unused_stubs_with_multiple_mocks(StrictJUnitRuleTest.java:0)\n" +
-                        "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class."), filterLineNo(t.getMessage()));
-            }
-        });
-
-        //when test has
+    @Test
+    public void unused_stubs_with_multiple_mocks() throws Throwable {
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals(
+                                filterLineNo(
+                                        "\n"
+                                                + "Unnecessary stubbings detected.\n"
+                                                + "Clean & maintainable test code requires zero unnecessary code.\n"
+                                                + "Following stubbings are unnecessary (click to navigate to relevant line of code):\n"
+                                                + "  1. -> at org.mockitousage.junitrule.StrictJUnitRuleTest.unused_stubs_with_multiple_mocks(StrictJUnitRuleTest.java:0)\n"
+                                                + "  2. -> at org.mockitousage.junitrule.StrictJUnitRuleTest.unused_stubs_with_multiple_mocks(StrictJUnitRuleTest.java:0)\n"
+                                                + "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class."),
+                                filterLineNo(t.getMessage()));
+                    }
+                });
+
+        // when test has
         given(mock.simpleMethod(10)).willReturn("foo");
         given(mock2.simpleMethod(20)).willReturn("foo");
 
-        given(mock.otherMethod()).willReturn("foo"); //used and should not be reported
+        given(mock.otherMethod()).willReturn("foo"); // used and should not be reported
 
-        //and code has
+        // and code has
         mock.otherMethod();
         mock2.booleanObjectReturningMethod();
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-    @Test public void rule_validates_mockito_usage() throws Throwable {
-        //expect
+    @Test
+    public void rule_validates_mockito_usage() throws Throwable {
+        // expect
         rule.expectFailure(UnfinishedVerificationException.class);
 
-        //when test contains unfinished verification
+        // when test contains unfinished verification
         verify(mock);
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrule/StubbingWarningsJUnitRuleTest.java b/src/test/java/org/mockitousage/junitrule/StubbingWarningsJUnitRuleTest.java
index c851a6b..7f77eeb 100644
--- a/src/test/java/org/mockitousage/junitrule/StubbingWarningsJUnitRuleTest.java
+++ b/src/test/java/org/mockitousage/junitrule/StubbingWarningsJUnitRuleTest.java
@@ -4,20 +4,20 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
+import static org.mockitoutil.TestBase.filterLineNo;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.quality.Strictness;
 import org.mockito.internal.junit.JUnitRule;
 import org.mockito.internal.util.SimpleMockitoLogger;
+import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 import org.mockitoutil.SafeJUnitRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.when;
-import static org.mockitoutil.TestBase.filterLineNo;
-
 public class StubbingWarningsJUnitRuleTest {
 
     private SimpleMockitoLogger logger = new SimpleMockitoLogger();
@@ -26,49 +26,53 @@ public class StubbingWarningsJUnitRuleTest {
 
     @Test
     public void no_unused_stubs_reported_on_failure() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals("x", t.getMessage());
-                assertTrue(logger.getLoggedInfo().isEmpty());
-            }
-        });
-
-        //when
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertTrue(logger.getLoggedInfo().isEmpty());
+                    }
+                });
+
+        // when
         declareStubbing(mock);
         throw new AssertionError("x");
     }
 
     @Test
     public void stubbing_arg_mismatch_on_failure() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals("x", t.getMessage());
-                assertEquals(
-                    "[MockitoHint] StubbingWarningsJUnitRuleTest.stubbing_arg_mismatch_on_failure (see javadoc for MockitoHint):\n" +
-                    "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
-                        filterLineNo(logger.getLoggedInfo()));
-            }
-        });
-
-        //when
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsJUnitRuleTest.stubbing_arg_mismatch_on_failure (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
         useStubbingWithArg(mock, "b");
         throw new AssertionError("x");
     }
 
-    @Test public void no_stubbing_arg_mismatch_when_no_mismatch_on_fail() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals("x", t.getMessage());
-                assertTrue(logger.getLoggedInfo().isEmpty());
-            }
-        });
-
-        //when
+    @Test
+    public void no_stubbing_arg_mismatch_when_no_mismatch_on_fail() throws Throwable {
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertTrue(logger.getLoggedInfo().isEmpty());
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
         useStubbingWithArg(mock, "a");
         throw new AssertionError("x");
@@ -76,37 +80,39 @@ public class StubbingWarningsJUnitRuleTest {
 
     @Test
     public void no_stubbing_warning_on_pass() throws Throwable {
-        //expect
-        rule.expectSuccess(new Runnable() {
-            public void run() {
-                assertTrue(logger.isEmpty());
-            }
-        });
-
-        //when
+        // expect
+        rule.expectSuccess(
+                new Runnable() {
+                    public void run() {
+                        assertTrue(logger.isEmpty());
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
         useStubbingWithArg(mock, "a");
     }
 
     @Test
     public void multiple_stubbing_arg_mismatch_on_failure() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals("x", t.getMessage());
-                assertEquals(
-                    "[MockitoHint] StubbingWarningsJUnitRuleTest.multiple_stubbing_arg_mismatch_on_failure (see javadoc for MockitoHint):\n" +
-                    "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint] 2. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                    "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
-                        filterLineNo(logger.getLoggedInfo()));
-            }
-        });
-
-        //when
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsJUnitRuleTest.multiple_stubbing_arg_mismatch_on_failure (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint] 2. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
         declareStubbingWithArg(mock, "b");
 
@@ -118,19 +124,20 @@ public class StubbingWarningsJUnitRuleTest {
 
     @Test
     public void reports_only_mismatching_stubs() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-            assertEquals("x", t.getMessage());
-            assertEquals(
-                "[MockitoHint] StubbingWarningsJUnitRuleTest.reports_only_mismatching_stubs (see javadoc for MockitoHint):\n" +
-                "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
-                "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
-                    filterLineNo(logger.getLoggedInfo()));
-            }
-        });
-
-        //when
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsJUnitRuleTest.reports_only_mismatching_stubs (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n"
+                                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a"); // <-- used
         declareStubbingWithArg(mock, "b"); // <-- unused
 
@@ -142,15 +149,16 @@ public class StubbingWarningsJUnitRuleTest {
 
     @Test
     public void no_mismatch_when_stub_was_used() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertEquals("x", t.getMessage());
-                assertTrue(logger.getLoggedInfo().isEmpty());
-            }
-        });
-
-        //when
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertEquals("x", t.getMessage());
+                        assertTrue(logger.getLoggedInfo().isEmpty());
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
 
         useStubbingWithArg(mock, "a");
@@ -161,35 +169,36 @@ public class StubbingWarningsJUnitRuleTest {
 
     @Test
     public void no_stubbing_arg_mismatch_on_pass() throws Throwable {
-        //expect
-        rule.expectSuccess(new Runnable() {
-            public void run() {
-                assertEquals(
-                    "[MockitoHint] StubbingWarningsJUnitRuleTest.no_stubbing_arg_mismatch_on_pass (see javadoc for MockitoHint):\n" +
-                    "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
-                        filterLineNo(logger.getLoggedInfo()));
-            }
-        });
-
-        //when
+        // expect
+        rule.expectSuccess(
+                new Runnable() {
+                    public void run() {
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsJUnitRuleTest.no_stubbing_arg_mismatch_on_pass (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
+
+        // when
         declareStubbingWithArg(mock, "a");
         useStubbingWithArg(mock, "b");
     }
 
     @Test
     public void warns_about_unused_stubs_when_passed() throws Throwable {
-        //expect
-        rule.expectSuccess(new Runnable() {
-            public void run() {
-                assertEquals(
-                    "[MockitoHint] StubbingWarningsJUnitRuleTest.warns_about_unused_stubs_when_passed (see javadoc for MockitoHint):\n" +
-                    "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbing(StubbingWarningsJUnitRuleTest.java:0)\n",
-                        filterLineNo(logger.getLoggedInfo()));
-
-            }
-        });
-
-        //when
+        // expect
+        rule.expectSuccess(
+                new Runnable() {
+                    public void run() {
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsJUnitRuleTest.warns_about_unused_stubs_when_passed (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbing(StubbingWarningsJUnitRuleTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
+
+        // when
         declareStubbing(mock);
     }
 
diff --git a/src/test/java/org/mockitousage/junitrule/StubbingWarningsMultiThreadingTest.java b/src/test/java/org/mockitousage/junitrule/StubbingWarningsMultiThreadingTest.java
index 5bd4008..683a9e8 100644
--- a/src/test/java/org/mockitousage/junitrule/StubbingWarningsMultiThreadingTest.java
+++ b/src/test/java/org/mockitousage/junitrule/StubbingWarningsMultiThreadingTest.java
@@ -4,66 +4,71 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
+import static org.mockitoutil.TestBase.filterLineNo;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.quality.Strictness;
 import org.mockito.internal.junit.JUnitRule;
 import org.mockito.internal.util.SimpleMockitoLogger;
+import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 import org.mockitoutil.ConcurrentTesting;
 import org.mockitoutil.SafeJUnitRule;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.when;
-import static org.mockitoutil.TestBase.filterLineNo;
-
 public class StubbingWarningsMultiThreadingTest {
 
     private SimpleMockitoLogger logger = new SimpleMockitoLogger();
     @Rule public SafeJUnitRule rule = new SafeJUnitRule(new JUnitRule(logger, Strictness.WARN));
     @Mock IMethods mock;
 
-    @Test public void using_stubbing_from_different_thread() throws Throwable {
-        //expect no warnings
-        rule.expectSuccess(new Runnable() {
-            public void run() {
-                assertTrue(logger.getLoggedInfo().isEmpty());
-            }
-        });
+    @Test
+    public void using_stubbing_from_different_thread() throws Throwable {
+        // expect no warnings
+        rule.expectSuccess(
+                new Runnable() {
+                    public void run() {
+                        assertTrue(logger.getLoggedInfo().isEmpty());
+                    }
+                });
 
-        //when stubbing is declared
+        // when stubbing is declared
         when(mock.simpleMethod()).thenReturn("1");
-        //and used from a different thread
-        ConcurrentTesting.inThread(new Runnable() {
+        // and used from a different thread
+        ConcurrentTesting.inThread(
+                new Runnable() {
                     public void run() {
                         mock.simpleMethod();
                     }
                 });
     }
 
-    @Test public void unused_stub_from_different_thread() throws Throwable {
-        //expect warnings
-        rule.expectSuccess(new Runnable() {
-            public void run() {
-                assertEquals(
-                    "[MockitoHint] StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread (see javadoc for MockitoHint):\n" +
-                    "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread(StubbingWarningsMultiThreadingTest.java:0)\n",
-                        filterLineNo(logger.getLoggedInfo()));
-            }
-        });
+    @Test
+    public void unused_stub_from_different_thread() throws Throwable {
+        // expect warnings
+        rule.expectSuccess(
+                new Runnable() {
+                    public void run() {
+                        assertEquals(
+                                "[MockitoHint] StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread (see javadoc for MockitoHint):\n"
+                                        + "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread(StubbingWarningsMultiThreadingTest.java:0)\n",
+                                filterLineNo(logger.getLoggedInfo()));
+                    }
+                });
 
-        //when stubbings are declared
+        // when stubbings are declared
         when(mock.simpleMethod(1)).thenReturn("1");
         when(mock.simpleMethod(2)).thenReturn("2");
 
-        //and one of the stubbings is used from a different thread
-        ConcurrentTesting.inThread(new Runnable() {
-            public void run() {
-                mock.simpleMethod(1);
-            }
-        });
+        // and one of the stubbings is used from a different thread
+        ConcurrentTesting.inThread(
+                new Runnable() {
+                    public void run() {
+                        mock.simpleMethod(1);
+                    }
+                });
     }
-
 }
diff --git a/src/test/java/org/mockitousage/junitrule/VerificationCollectorImplTest.java b/src/test/java/org/mockitousage/junitrule/VerificationCollectorImplTest.java
index 8f4c420..271c213 100644
--- a/src/test/java/org/mockitousage/junitrule/VerificationCollectorImplTest.java
+++ b/src/test/java/org/mockitousage/junitrule/VerificationCollectorImplTest.java
@@ -4,6 +4,15 @@
  */
 package org.mockitousage.junitrule;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.mockito.Mockito.longThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.shortThat;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
@@ -13,10 +22,6 @@ import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.VerificationCollector;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class VerificationCollectorImplTest {
 
     @Test
@@ -30,14 +35,23 @@ public class VerificationCollectorImplTest {
         collector.collectAndReport();
     }
 
-    @Test(expected = MockitoAssertionError.class)
+    @Test
     public void should_collect_verification_failures() {
         VerificationCollector collector = MockitoJUnit.collector().assertLazily();
 
         IMethods methods = mock(IMethods.class);
 
         verify(methods).simpleMethod();
-        collector.collectAndReport();
+        assertThatThrownBy(
+                        () -> {
+                            collector.collectAndReport();
+                        })
+                .isInstanceOf(MockitoAssertionError.class)
+                .hasMessageContainingAll(
+                        "There were multiple verification failures:",
+                        "1. Wanted but not invoked:",
+                        "iMethods.simpleMethod();",
+                        "Actually, there were zero interactions with this mock.");
     }
 
     @Test
@@ -46,14 +60,49 @@ public class VerificationCollectorImplTest {
 
         IMethods methods = mock(IMethods.class);
 
+        methods.intArgumentMethod(6);
+
         verify(methods).simpleMethod();
         verify(methods).byteReturningMethod();
+        verify(methods).intArgumentMethod(8);
+        verify(methods).longArg(8L);
         try {
             collector.collectAndReport();
-            fail();
+            failBecauseExceptionWasNotThrown(MockitoAssertionError.class);
         } catch (MockitoAssertionError error) {
             assertThat(error).hasMessageContaining("1. Wanted but not invoked:");
             assertThat(error).hasMessageContaining("2. Wanted but not invoked:");
+            assertThat(error).hasMessageContaining("3. Argument(s) are different! Wanted:");
+            assertThat(error).hasMessageContaining("4. Wanted but not invoked:");
+        }
+    }
+
+    @Test
+    public void should_collect_matching_error_from_non_matching_arguments() {
+        VerificationCollector collector = MockitoJUnit.collector().assertLazily();
+
+        IMethods methods = mock(IMethods.class);
+
+        methods.intArgumentMethod(6);
+        methods.longArg(8L);
+        methods.forShort((short) 6);
+
+        verify(methods).intArgumentMethod(8);
+        verify(methods)
+                .longArg(
+                        longThat(
+                                argument -> {
+                                    throw new AssertionError("custom error message");
+                                }));
+        verify(methods).forShort(shortThat(argument -> false));
+
+        try {
+            collector.collectAndReport();
+            failBecauseExceptionWasNotThrown(MockitoAssertionError.class);
+        } catch (MockitoAssertionError error) {
+            assertThat(error).hasMessageContaining("1. Argument(s) are different! Wanted:");
+            assertThat(error).hasMessageContaining("2. custom error message");
+            assertThat(error).hasMessageContaining("3. Argument(s) are different! Wanted:");
         }
     }
 
@@ -66,7 +115,7 @@ public class VerificationCollectorImplTest {
         verify(methods, never()).simpleMethod();
         verify(methods).byteReturningMethod();
 
-        this.assertAtLeastOneFailure(collector);
+        this.assertExactlyOneFailure(collector);
     }
 
     @Test
@@ -79,13 +128,13 @@ public class VerificationCollectorImplTest {
         verify(methods).byteReturningMethod();
         verify(methods).simpleMethod();
 
-        this.assertAtLeastOneFailure(collector);
+        this.assertExactlyOneFailure(collector);
     }
 
-    private void assertAtLeastOneFailure(VerificationCollector collector) {
+    private void assertExactlyOneFailure(VerificationCollector collector) {
         try {
             collector.collectAndReport();
-            fail();
+            failBecauseExceptionWasNotThrown(MockitoAssertionError.class);
         } catch (MockitoAssertionError error) {
             assertThat(error).hasMessageContaining("1. Wanted but not invoked:");
             assertThat(error.getMessage()).doesNotContain("2.");
@@ -97,15 +146,20 @@ public class VerificationCollectorImplTest {
         JUnitCore runner = new JUnitCore();
         Result result = runner.run(VerificationCollectorRuleInner.class);
 
-        assertThat(result.getFailureCount()).isEqualTo(1);
-        assertThat(result.getFailures().get(0).getMessage()).contains("1. Wanted but not invoked:");
+        assertThat(result.getFailureCount()).as("failureCount").isEqualTo(2);
+        assertThat(result.getFailures().get(0).getMessage())
+                .as("failure1")
+                .contains("1. Wanted but not invoked:");
+        assertThat(result.getFailures().get(1).getMessage())
+                .as("failure2")
+                .contains("1. Argument(s) are different! Wanted:")
+                .contains("2. Wanted but not invoked:");
     }
 
     // This class is picked up when running a test suite using an IDE. It fails on purpose.
     public static class VerificationCollectorRuleInner {
 
-        @Rule
-        public VerificationCollector collector = MockitoJUnit.collector();
+        @Rule public VerificationCollector collector = MockitoJUnit.collector();
 
         @Test
         public void should_fail() {
@@ -121,5 +175,14 @@ public class VerificationCollectorImplTest {
 
             verify(methods).simpleMethod();
         }
+
+        @Test
+        public void should_fail_with_args() {
+            IMethods methods = mock(IMethods.class);
+            methods.intArgumentMethod(8);
+
+            verify(methods).intArgumentMethod(9);
+            verify(methods).byteReturningMethod();
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/DeepStubbingWithJUnitRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/DeepStubbingWithJUnitRunnerTest.java
index be42213..7236f1b 100644
--- a/src/test/java/org/mockitousage/junitrunner/DeepStubbingWithJUnitRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/DeepStubbingWithJUnitRunnerTest.java
@@ -15,14 +15,15 @@ public class DeepStubbingWithJUnitRunnerTest {
 
     private final SomeClass someClass = new SomeClass();
 
-    @Mock(answer = Answers.RETURNS_DEEP_STUBS) private Root root;
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private Root root;
 
     @Test
     public void deep_stubs_dont_trigger_unnecessary_stubbing_exception() {
-        //when
+        // when
         someClass.someMethod(root);
 
-        //then unnecessary stubbing exception is not thrown
+        // then unnecessary stubbing exception is not thrown
     }
 
     public static class SomeClass {
@@ -39,7 +40,5 @@ public class DeepStubbingWithJUnitRunnerTest {
         Bar getBar();
     }
 
-    interface Bar {
-
-    }
+    interface Bar {}
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/JUnit45RunnerTest.java b/src/test/java/org/mockitousage/junitrunner/JUnit45RunnerTest.java
index fe942e6..bd9b485 100644
--- a/src/test/java/org/mockitousage/junitrunner/JUnit45RunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/JUnit45RunnerTest.java
@@ -4,18 +4,18 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.verify;
+import static org.mockitousage.junitrunner.Filters.methodNameContains;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
-import java.util.List;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.verify;
-import static org.mockitousage.junitrunner.Filters.methodNameContains;
-
 @RunWith(MockitoJUnitRunner.class)
 public class JUnit45RunnerTest {
 
@@ -35,7 +35,7 @@ public class JUnit45RunnerTest {
     }
 
     @Test
-    public void shouldFilterTestMethodsCorrectly() throws Exception{
+    public void shouldFilterTestMethodsCorrectly() throws Exception {
         MockitoJUnitRunner runner = new MockitoJUnitRunner(this.getClass());
 
         runner.filter(methodNameContains("shouldInitMocksUsingRunner"));
diff --git a/src/test/java/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java b/src/test/java/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java
index adb8b66..193a30b 100644
--- a/src/test/java/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -13,12 +18,7 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-//@RunWith(ConsoleSpammingMockitoJUnitRunner.class)
+// @RunWith(ConsoleSpammingMockitoJUnitRunner.class)
 @RunWith(MockitoJUnitRunner.class)
 @Ignore
 public class ModellingVerboseMockitoTest extends TestBase {
@@ -36,22 +36,23 @@ public class ModellingVerboseMockitoTest extends TestBase {
         when(mock.otherMethod()).thenReturn("foo");
         when(mock.booleanObjectReturningMethod()).thenReturn(false);
 
-        //TODO: stubbed with those args here -> stubbed with certain args here
+        // TODO: stubbed with those args here -> stubbed with certain args here
         String ret = mock.simpleMethod(2);
 
         assertEquals("foo", ret);
-        //TODO: should show message from actual failure not at the bottom but at least below 'the actual failure is ...'
+        // TODO: should show message from actual failure not at the bottom but at least below 'the
+        // actual failure is ...'
     }
 
     @Test
     public void shouldNotLogAnythingWhenNoWarnings() throws Exception {
-        //stub
+        // stub
         when(mock.simpleMethod()).thenReturn("foo");
-        //use stub:
+        // use stub:
         mock.simpleMethod();
-        //verify:
+        // verify:
         verify(mock).simpleMethod();
-        //should be no warnings:
+        // should be no warnings:
         fail();
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
index f22d7ac..afb375d 100644
--- a/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
@@ -4,78 +4,78 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import java.util.List;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.exceptions.misusing.UnfinishedStubbingException;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.JUnitResultAssert;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 public class SilentRunnerTest extends TestBase {
 
     JUnitCore runner = new JUnitCore();
 
-    @Test public void passing_test() {
-        //when
-        Result result = runner.run(
-                SomeFeature.class
-        );
-        //then
+    @Test
+    public void passing_test() {
+        // when
+        Result result = runner.run(SomeFeature.class);
+        // then
         JUnitResultAssert.assertThat(result).isSuccessful();
     }
 
-    @Test public void failing_test() {
-        //when
-        Result result = runner.run(
-                SomeFailingFeature.class
-        );
-        //then
-        JUnitResultAssert.assertThat(result).fails(1, TooLittleActualInvocations.class);
+    @Test
+    public void failing_test() {
+        // when
+        Result result = runner.run(SomeFailingFeature.class);
+        // then
+        JUnitResultAssert.assertThat(result).fails(1, TooFewActualInvocations.class);
     }
 
-    @Test public void failing_test_in_constructor() {
-        //when
-        Result result = runner.run(
-                FailsInConstructor.class
-        );
-        //then
+    @Test
+    public void failing_test_in_constructor() {
+        // when
+        Result result = runner.run(FailsInConstructor.class);
+        // then
         JUnitResultAssert.assertThat(result).fails(1, IllegalArgumentException.class);
     }
 
-    @Test public void validates_framework_usage() {
-        //when
-        Result result = runner.run(
-                UsesFrameworkIncorrectly.class
-        );
-        //then
-        JUnitResultAssert.assertThat(result).fails(1, "unfinished_stubbing_test_method", UnfinishedStubbingException.class);
+    @Test
+    public void validates_framework_usage() {
+        // when
+        Result result = runner.run(UsesFrameworkIncorrectly.class);
+        // then
+        JUnitResultAssert.assertThat(result)
+                .fails(1, "unfinished_stubbing_test_method", UnfinishedStubbingException.class);
     }
 
     @Test
     public void ignores_unused_stubs() {
         JUnitCore runner = new JUnitCore();
-        //when
+        // when
         Result result = runner.run(HasUnnecessaryStubs.class);
-        //then
+        // then
         JUnitResultAssert.assertThat(result).isSuccessful();
     }
 
     @RunWith(MockitoJUnitRunner.Silent.class)
     public static class SomeFeature {
         @Mock List<String> list;
-        @Test public void some_behavior() {
+
+        @Test
+        public void some_behavior() {
             when(list.get(0)).thenReturn("0");
             assertEquals("0", list.get(0));
         }
@@ -84,7 +84,9 @@ public class SilentRunnerTest extends TestBase {
     @RunWith(MockitoJUnitRunner.Silent.class)
     public static class SomeFailingFeature {
         @Mock List<String> list;
-        @Test public void some_failing_behavior() {
+
+        @Test
+        public void some_failing_behavior() {
             list.clear();
             verify(list, times(2)).clear();
         }
@@ -97,8 +99,11 @@ public class SilentRunnerTest extends TestBase {
                 throw new IllegalArgumentException("Boo!");
             }
         }
+
         @Mock List<String> list;
-        @Test public void some_behavior() {}
+
+        @Test
+        public void some_behavior() {}
     }
 
     @RunWith(MockitoJUnitRunner.Silent.class)
@@ -106,8 +111,9 @@ public class SilentRunnerTest extends TestBase {
         @Mock List<?> list;
 
         @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-        @Test public void unfinished_stubbing_test_method() {
-            when(list.get(0)); //unfinished stubbing
+        @Test
+        public void unfinished_stubbing_test_method() {
+            when(list.get(0)); // unfinished stubbing
         }
     }
 
diff --git a/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
index e627749..47ed688 100644
--- a/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -13,87 +17,93 @@ import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
 import org.mockito.junit.MockitoJUnitRunner;
+import org.mockito.junit.MockitoRule;
 import org.mockitousage.IMethods;
 import org.mockitoutil.JUnitResultAssert;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-
 public class StrictRunnerTest extends TestBase {
 
     JUnitCore runner = new JUnitCore();
 
-    @Test public void succeeds_when_all_stubs_were_used() {
-        //when
-        Result result = runner.run(
-                StubbingInConstructorUsed.class,
-                StubbingInBeforeUsed.class,
-                StubbingInTestUsed.class
-        );
-        //then
+    @Test
+    public void succeeds_when_all_stubs_were_used() {
+        // when
+        Result result =
+                runner.run(
+                        StubbingInConstructorUsed.class,
+                        StubbingInBeforeUsed.class,
+                        StubbingInTestUsed.class);
+        // then
         JUnitResultAssert.assertThat(result).isSuccessful();
     }
 
-    @Test public void fails_when_stubs_were_not_used() {
-        Class[] tests = {StubbingInConstructorUnused.class,
-                StubbingInBeforeUnused.class,
-                StubbingInTestUnused.class};
+    @Test
+    public void fails_when_stubs_were_not_used() {
+        Class[] tests = {
+            StubbingInConstructorUnused.class,
+            StubbingInBeforeUnused.class,
+            StubbingInTestUnused.class
+        };
 
-        //when
+        // when
         Result result = runner.run(tests);
 
-        //then
+        // then
         JUnitResultAssert.assertThat(result).fails(3, UnnecessaryStubbingException.class);
     }
 
-    @Test public void does_not_report_unused_stubs_when_different_failure_is_present() {
-        //when
+    @Test
+    public void does_not_report_unused_stubs_when_different_failure_is_present() {
+        // when
         Result result = runner.run(WithUnrelatedAssertionFailure.class);
 
-        //then
+        // then
         JUnitResultAssert.assertThat(result).fails(1, MyAssertionError.class);
     }
 
-    @Test public void runner_can_coexist_with_rule() {
-        //I don't believe that this scenario is useful
-        //I only wish that Mockito does not break awkwardly when both: runner & rule is used
+    @Test
+    public void runner_can_coexist_with_rule() {
+        // I don't believe that this scenario is useful
+        // I only wish that Mockito does not break awkwardly when both: runner & rule is used
 
-        //when
+        // when
         Result result = runner.run(RunnerAndRule.class);
 
-        //then
+        // then
         JUnitResultAssert.assertThat(result).fails(1, UnnecessaryStubbingException.class);
     }
 
-    @Test public void runner_in_multi_threaded_tests() {
-        //when
+    @Test
+    public void runner_in_multi_threaded_tests() {
+        // when
         Result result = runner.run(StubUsedFromDifferentThread.class);
 
-        //then
+        // then
         JUnitResultAssert.assertThat(result).isSuccessful();
     }
 
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInConstructorUsed extends StubbingInConstructorUnused {
-        @Test public void test() {
+        @Test
+        public void test() {
             assertEquals("1", mock.simpleMethod(1));
         }
     }
 
-    @RunWith(MockitoJUnitRunner.Strict.class) //using Strict to make sure it does the right thing
+    @RunWith(MockitoJUnitRunner.Strict.class) // using Strict to make sure it does the right thing
     public static class StubbingInConstructorUnused {
         IMethods mock = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
-        @Test public void dummy() {}
+
+        @Test
+        public void dummy() {}
     }
 
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInBeforeUsed extends StubbingInBeforeUnused {
-        @Test public void test() {
+        @Test
+        public void test() {
             assertEquals("1", mock.simpleMethod(1));
         }
     }
@@ -101,15 +111,20 @@ public class StrictRunnerTest extends TestBase {
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInBeforeUnused {
         @Mock IMethods mock;
-        @Before public void before() {
+
+        @Before
+        public void before() {
             when(mock.simpleMethod(1)).thenReturn("1");
         }
-        @Test public void dummy() {}
+
+        @Test
+        public void dummy() {}
     }
 
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInTestUsed {
-        @Test public void test() {
+        @Test
+        public void test() {
             IMethods mock = mock(IMethods.class);
             when(mock.simpleMethod(1)).thenReturn("1");
             assertEquals("1", mock.simpleMethod(1));
@@ -118,10 +133,11 @@ public class StrictRunnerTest extends TestBase {
 
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInTestUnused {
-        @Test public void test() {
+        @Test
+        public void test() {
             IMethods mock = mock(IMethods.class);
             when(mock.simpleMethod(1)).thenReturn("1");
-            mock.simpleMethod(2); //different arg
+            mock.simpleMethod(2); // different arg
         }
     }
 
@@ -133,16 +149,19 @@ public class StrictRunnerTest extends TestBase {
         IMethods mock = mock(IMethods.class);
         IMethods mock2 = mock(IMethods.class);
 
-        @Before public void before() {
+        @Before
+        public void before() {
             when(mock2.simpleMethod("unused stubbing")).thenReturn("");
         }
 
-        @Test public void passing_test() {
+        @Test
+        public void passing_test() {
             when(mock.simpleMethod(1)).thenReturn("1");
             assertEquals("1", mock.simpleMethod(1));
         }
 
-        @Test public void failing_test() {
+        @Test
+        public void failing_test() {
             throw new MyAssertionError();
         }
     }
@@ -153,7 +172,8 @@ public class StrictRunnerTest extends TestBase {
         public @Rule MockitoRule rule = MockitoJUnit.rule();
         IMethods mock = mock(IMethods.class);
 
-        @Test public void passing_test() {
+        @Test
+        public void passing_test() {
             when(mock.simpleMethod(1)).thenReturn("1");
             mock.simpleMethod(2);
         }
@@ -164,17 +184,19 @@ public class StrictRunnerTest extends TestBase {
 
         IMethods mock = mock(IMethods.class);
 
-        @Test public void passing_test() throws Exception {
-            //stubbing is done in main thread:
+        @Test
+        public void passing_test() throws Exception {
+            // stubbing is done in main thread:
             when(mock.simpleMethod(1)).thenReturn("1");
 
-            //stubbing is used in a different thread
-            //stubbing should not be reported as unused by the runner
-            Thread t = new Thread() {
-                public void run() {
-                    mock.simpleMethod(1);
-                }
-            };
+            // stubbing is used in a different thread
+            // stubbing should not be reported as unused by the runner
+            Thread t =
+                    new Thread() {
+                        public void run() {
+                            mock.simpleMethod(1);
+                        }
+                    };
             t.start();
             t.join();
         }
diff --git a/src/test/java/org/mockitousage/junitrunner/StrictStubsRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/StrictStubsRunnerTest.java
index f61572b..efe2f74 100644
--- a/src/test/java/org/mockitousage/junitrunner/StrictStubsRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/StrictStubsRunnerTest.java
@@ -4,6 +4,8 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -13,43 +15,48 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
+import org.mockitousage.strictness.ProductionCode;
 import org.mockitoutil.JUnitResultAssert;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.when;
-
 public class StrictStubsRunnerTest extends TestBase {
 
     JUnitCore runner = new JUnitCore();
 
-    @Test public void detects_unnecessary_stubbings() {
-        //when
+    @Test
+    public void detects_unnecessary_stubbings() {
+        // when
         Result result = runner.run(UnnecessaryStubbing.class);
-        //then
+        // then
         JUnitResultAssert.assertThat(result)
                 .fails(1, UnnecessaryStubbingException.class)
                 .succeeds(2);
     }
 
-    @Test public void fails_fast_on_argument_mismatch() {
-        //when
+    @Test
+    public void fails_fast_on_argument_mismatch() {
+        // when
         Result result = runner.run(StubbingArgMismatch.class);
-        //then
-        JUnitResultAssert.assertThat(result)
-                .succeeds(2)
-                .fails(1, PotentialStubbingProblem.class);
+        // then
+        JUnitResultAssert.assertThat(result).succeeds(2).fails(1, PotentialStubbingProblem.class);
     }
 
     @RunWith(MockitoJUnitRunner.StrictStubs.class)
     public static class UnnecessaryStubbing {
         @Mock IMethods mock;
-        @Test public void unused_stubbing_1() {
+
+        @Test
+        public void unused_stubbing_1() {
             when(mock.simpleMethod()).thenReturn("");
         }
-        @Test public void unused_stubbing_2() {
+
+        @Test
+        public void unused_stubbing_2() {
             when(mock.simpleMethod()).thenReturn("");
         }
-        @Test public void correct_stubbing() {
+
+        @Test
+        public void correct_stubbing() {
             when(mock.simpleMethod()).thenReturn("");
             mock.simpleMethod();
         }
@@ -58,14 +65,20 @@ public class StrictStubsRunnerTest extends TestBase {
     @RunWith(MockitoJUnitRunner.StrictStubs.class)
     public static class StubbingArgMismatch {
         @Mock IMethods mock;
-        @Test public void passing1() {}
-        @Test public void passing2() {
+
+        @Test
+        public void passing1() {}
+
+        @Test
+        public void passing2() {
             when(mock.simpleMethod()).thenReturn("");
             mock.simpleMethod();
         }
-        @Test public void argument_mismatch() {
+
+        @Test
+        public void argument_mismatch() {
             when(mock.simpleMethod(10)).thenReturn("");
-            mock.simpleMethod(20);
+            ProductionCode.simpleMethod(mock, 20);
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/StubbingWarningsJUnitRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/StubbingWarningsJUnitRunnerTest.java
index 7d8d537..05be05d 100644
--- a/src/test/java/org/mockitousage/junitrunner/StubbingWarningsJUnitRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/StubbingWarningsJUnitRunnerTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockitoutil.JUnitResultAssert.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -15,56 +20,64 @@ import org.mockito.junit.TestableJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.mockitoutil.JUnitResultAssert.assertThat;
-
 public class StubbingWarningsJUnitRunnerTest extends TestBase {
 
     JUnitCore runner = new JUnitCore();
     SimpleMockitoLogger logger = TestableJUnitRunner.refreshedLogger();
 
-    @Test public void no_arg_mismatch_warnings() {
-        //when
-        runner.run(PassingArgMismatch.class, FailingWithMatchingArgs.class, MismatchButStubAlreadyUsed.class);
+    @Test
+    public void no_arg_mismatch_warnings() {
+        // when
+        runner.run(
+                PassingArgMismatch.class,
+                FailingWithMatchingArgs.class,
+                MismatchButStubAlreadyUsed.class);
 
-        //then
+        // then
         assertEquals("", filterLineNo(logger.getLoggedInfo()));
     }
 
-    @Test public void shows_arg_mismatch_warnings_when_test_fails() {
-        //when
+    @Test
+    public void shows_arg_mismatch_warnings_when_test_fails() {
+        // when
         runner.run(FailingWithArgMismatch.class);
 
-        //then
-        assertEquals("[MockitoHint] FailingWithArgMismatch.test (see javadoc for MockitoHint):\n" +
-                "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithArgMismatch.test(StubbingWarningsJUnitRunnerTest.java:0)\n" +
-                "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithArgMismatch.test(StubbingWarningsJUnitRunnerTest.java:0)\n", filterLineNo(logger.getLoggedInfo()));
+        // then
+        assertEquals(
+                "[MockitoHint] FailingWithArgMismatch.test (see javadoc for MockitoHint):\n"
+                        + "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithArgMismatch.test(StubbingWarningsJUnitRunnerTest.java:0)\n"
+                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithArgMismatch.test(StubbingWarningsJUnitRunnerTest.java:0)\n",
+                filterLineNo(logger.getLoggedInfo()));
     }
 
-    @Test public void shows_arg_mismatch_warnings_only_for_mismatches() {
-        //when
+    @Test
+    public void shows_arg_mismatch_warnings_only_for_mismatches() {
+        // when
         runner.run(FailingWithSomeStubMismatches.class);
 
-        //then
-        assertEquals("[MockitoHint] FailingWithSomeStubMismatches.test (see javadoc for MockitoHint):\n" +
-                "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithSomeStubMismatches.test(StubbingWarningsJUnitRunnerTest.java:0)\n" +
-                "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithSomeStubMismatches.test(StubbingWarningsJUnitRunnerTest.java:0)\n", filterLineNo(logger.getLoggedInfo()));
+        // then
+        assertEquals(
+                "[MockitoHint] FailingWithSomeStubMismatches.test (see javadoc for MockitoHint):\n"
+                        + "[MockitoHint] 1. Unused... -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithSomeStubMismatches.test(StubbingWarningsJUnitRunnerTest.java:0)\n"
+                        + "[MockitoHint]  ...args ok? -> at org.mockitousage.junitrunner.StubbingWarningsJUnitRunnerTest$FailingWithSomeStubMismatches.test(StubbingWarningsJUnitRunnerTest.java:0)\n",
+                filterLineNo(logger.getLoggedInfo()));
     }
 
-    @Test public void validates_mockito_usage() {
-        //when
+    @Test
+    public void validates_mockito_usage() {
+        // when
         Result result = runner.run(InvalidMockitoUsage.class);
 
-        //then
+        // then
         assertThat(result).fails(1, UnfinishedStubbingException.class);
     }
 
     @RunWith(TestableJUnitRunner.class)
     public static class PassingArgMismatch {
         IMethods mock = mock(IMethods.class);
-        @Test public void test() throws Exception {
+
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod(1)).thenReturn("1");
             mock.simpleMethod(2);
         }
@@ -73,7 +86,9 @@ public class StubbingWarningsJUnitRunnerTest extends TestBase {
     @RunWith(TestableJUnitRunner.class)
     public static class FailingWithArgMismatch {
         @Mock IMethods mock;
-        @Test public void test() throws Exception {
+
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod(1)).thenReturn("1");
             mock.simpleMethod(2);
             throw new RuntimeException("x");
@@ -83,7 +98,9 @@ public class StubbingWarningsJUnitRunnerTest extends TestBase {
     @RunWith(TestableJUnitRunner.class)
     public static class FailingWithMatchingArgs {
         @Mock IMethods mock;
-        @Test public void test() throws Exception {
+
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod(1)).thenReturn("1");
             mock.simpleMethod(1);
             throw new RuntimeException("x");
@@ -93,7 +110,9 @@ public class StubbingWarningsJUnitRunnerTest extends TestBase {
     @RunWith(TestableJUnitRunner.class)
     public static class FailingWithSomeStubMismatches {
         @Mock IMethods mock;
-        @Test public void test() throws Exception {
+
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod(1)).thenReturn("1"); // <- used
             when(mock.simpleMethod(2)).thenReturn("2"); // <- unused
 
@@ -107,7 +126,9 @@ public class StubbingWarningsJUnitRunnerTest extends TestBase {
     @RunWith(TestableJUnitRunner.class)
     public static class MismatchButStubAlreadyUsed {
         @Mock IMethods mock;
-        @Test public void test() throws Exception {
+
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod(1)).thenReturn("1");
             mock.simpleMethod(1); // <-- used
             mock.simpleMethod(2); // <-- arg mismatch, but the stub was already used
@@ -119,8 +140,10 @@ public class StubbingWarningsJUnitRunnerTest extends TestBase {
     @RunWith(TestableJUnitRunner.class)
     public static class InvalidMockitoUsage {
         @Mock IMethods mock;
+
         @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-        @Test public void test() throws Exception {
+        @Test
+        public void test() throws Exception {
             when(mock.simpleMethod()); // <-- unfinished stubbing
         }
     }
diff --git a/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java b/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
index 6b6017a..db804f8 100644
--- a/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
@@ -4,6 +4,10 @@
  */
 package org.mockitousage.junitrunner;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -13,15 +17,12 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 public class UnusedStubsExceptionMessageTest extends TestBase {
 
-    //Moving the code around this class is tricky and may cause the test to fail
-    //We're asserting on full exception message which contains line numbers
-    //Let's leave it for now, updating the test is cheap and if it turns out hindrance we can make the assertion smarter.
+    // Moving the code around this class is tricky and may cause the test to fail
+    // We're asserting on full exception message which contains line numbers
+    // Let's leave it for now, updating the test is cheap and if it turns out hindrance we can make
+    // the assertion smarter.
     @RunWith(MockitoJUnitRunner.class)
     public static class HasUnnecessaryStubs {
         IMethods mock1 = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
@@ -43,17 +44,18 @@ public class UnusedStubsExceptionMessageTest extends TestBase {
     @Test
     public void lists_all_unused_stubs_cleanly() {
         JUnitCore runner = new JUnitCore();
-        //when
+        // when
         Result result = runner.run(HasUnnecessaryStubs.class);
-        //then
+        // then
         Failure failure = result.getFailures().get(0);
-        assertEquals("\n" +
-                        "Unnecessary stubbings detected in test class: HasUnnecessaryStubs\n" +
-                        "Clean & maintainable test code requires zero unnecessary code.\n" +
-                        "Following stubbings are unnecessary (click to navigate to relevant line of code):\n" +
-                        "  1. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:0)\n" +
-                        "  2. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:0)\n" +
-                        "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.",
-            filterLineNo(failure.getException().getMessage()));
+        assertEquals(
+                "\n"
+                        + "Unnecessary stubbings detected in test class: HasUnnecessaryStubs\n"
+                        + "Clean & maintainable test code requires zero unnecessary code.\n"
+                        + "Following stubbings are unnecessary (click to navigate to relevant line of code):\n"
+                        + "  1. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:0)\n"
+                        + "  2. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:0)\n"
+                        + "Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.",
+                filterLineNo(failure.getException().getMessage()));
     }
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/VerboseMockitoRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/VerboseMockitoRunnerTest.java
deleted file mode 100644
index 37010b0..0000000
--- a/src/test/java/org/mockitousage/junitrunner/VerboseMockitoRunnerTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitousage.junitrunner;
-
-import junit.framework.TestCase;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.JUnitCore;
-import org.junit.runner.Result;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;
-import org.mockito.runners.VerboseMockitoJUnitRunner;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.*;
-
-//@RunWith(ConsoleSpammingMockitoJUnitRunner.class)
-@RunWith(VerboseMockitoJUnitRunner.class)
-//TODO
-public class VerboseMockitoRunnerTest extends TestBase {
-
-    @Mock private IMethods mock;
-
-    public static class NoWarnings {
-
-        @Test
-        @Ignore
-        public void test() {
-            IMethods mock = mock(IMethods.class);
-            mock.simpleMethod(1);
-            mock.otherMethod();
-
-            verify(mock).simpleMethod(1);
-            throw new RuntimeException("boo");
-        }
-    }
-
-    public static class ContainsWarnings extends TestCase {
-
-        public ContainsWarnings() {
-            super("test");
-        }
-
-        public void testIgnored() {}
-
-        public void _test() {
-            IMethods mock = mock(IMethods.class);
-
-            //some stubbing
-            when(mock.simpleMethod(1)).thenReturn("foo");
-            when(mock.otherMethod()).thenReturn("foo");
-            when(mock.booleanObjectReturningMethod()).thenReturn(false);
-
-            //stub called with different args:
-            String ret = mock.simpleMethod(2);
-
-            //assertion fails due to stub called with different args
-            assertEquals("foo", ret);
-        }
-    }
-
-    public void cleanStackTraces() {
-        makeStackTracesClean();
-    }
-
-    @Test
-    @Ignore
-    public void shouldContainWarnings() throws Exception {
-        //when
-        Result result = new JUnitCore().run(new ContainsWarnings());
-        //then
-        assertEquals(1, result.getFailures().size());
-        Throwable exception = result.getFailures().get(0).getException();
-        assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);
-    }
-
-    @Test
-    @Ignore
-    public void shouldNotContainWarnings() throws Exception {
-        Result result = new JUnitCore().run(NoWarnings.class);
-        assertEquals(1, result.getFailures().size());
-        assertEquals("boo", result.getFailures().get(0).getException().getMessage());
-    }
-}
diff --git a/src/test/java/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java b/src/test/java/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java
index 0f6ea2d..2f93ea1 100644
--- a/src/test/java/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java
+++ b/src/test/java/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockitousage.matchers;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.when;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("unchecked")
 public class AnyXMatchersAcceptNullsTest extends TestBase {
 
@@ -31,29 +31,6 @@ public class AnyXMatchersAcceptNullsTest extends TestBase {
         assertEquals(null, mock.forObject(null));
     }
 
-    @Test
-    public void shouldAcceptNullsInAnyObjectMatcher() {
-        when(mock.oneArg((Object) anyObject())).thenReturn("matched");
-
-        assertEquals(null, mock.forObject(null));
-    }
-
-    @Test
-    public void shouldNotAcceptNullInAnyXMatchers() {
-        when(mock.oneArg(anyString())).thenReturn("0");
-        when(mock.forList(anyListOf(String.class))).thenReturn("1");
-        when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn("2");
-        when(mock.forCollection(anyCollectionOf(String.class))).thenReturn("3");
-        when(mock.forSet(anySetOf(String.class))).thenReturn("4");
-
-        assertEquals(null, mock.oneArg((Object) null));
-        assertEquals(null, mock.oneArg((String) null));
-        assertEquals(null, mock.forList(null));
-        assertEquals(null, mock.forMap(null));
-        assertEquals(null, mock.forCollection(null));
-        assertEquals(null, mock.forSet(null));
-    }
-
     @Test
     public void shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers() {
         when(mock.forInteger(anyInt())).thenReturn("0");
diff --git a/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java b/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
index b7aa78b..b4b6e1a 100644
--- a/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
+++ b/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
@@ -13,13 +19,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class CapturingArgumentsTest extends TestBase {
 
     class Person {
@@ -43,7 +42,7 @@ public class CapturingArgumentsTest extends TestBase {
             this.service = service;
         }
 
-        public void email(Integer ... personId) {
+        public void email(Integer... personId) {
             for (Integer i : personId) {
                 Person person = new Person(i);
                 service.sendEmailTo(person);
@@ -62,26 +61,26 @@ public class CapturingArgumentsTest extends TestBase {
     @SuppressWarnings("deprecation")
     @Test
     public void should_allow_assertions_on_captured_argument() {
-        //given
+        // given
         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
 
-        //when
+        // when
         bulkEmailService.email(12);
 
-        //then
+        // then
         verify(emailService).sendEmailTo(argument.capture());
         assertEquals(12, argument.getValue().getAge());
     }
 
     @Test
     public void should_allow_assertions_on_all_captured_arguments() {
-        //given
+        // given
         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
 
-        //when
+        // when
         bulkEmailService.email(11, 12);
 
-        //then
+        // then
         verify(emailService, times(2)).sendEmailTo(argument.capture());
         assertEquals(11, argument.getAllValues().get(0).getAge());
         assertEquals(12, argument.getAllValues().get(1).getAge());
@@ -89,84 +88,84 @@ public class CapturingArgumentsTest extends TestBase {
 
     @Test
     public void should_allow_assertions_on_last_argument() {
-        //given
+        // given
         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
 
-        //when
+        // when
         bulkEmailService.email(11, 12, 13);
 
-        //then
+        // then
         verify(emailService, times(3)).sendEmailTo(argument.capture());
         assertEquals(13, argument.getValue().getAge());
     }
 
     @Test
     public void should_print_captor_matcher() {
-        //given
+        // given
         ArgumentCaptor<Person> person = ArgumentCaptor.forClass(Person.class);
 
         try {
-            //when
+            // when
             verify(emailService).sendEmailTo(person.capture());
             fail();
-        } catch(WantedButNotInvoked e) {
-            //then
+        } catch (WantedButNotInvoked e) {
+            // then
             assertThat(e).hasMessageContaining("<Capturing argument>");
         }
     }
 
     @Test
     public void should_allow_assertions_on_captured_null() {
-        //given
+        // given
         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
 
-        //when
+        // when
         emailService.sendEmailTo(null);
 
-        //then
+        // then
         verify(emailService).sendEmailTo(argument.capture());
         assertEquals(null, argument.getValue());
     }
 
     @Test
-    public void should_allow_construction_of_captor_for_parameterized_type_in_a_convenient_way()  {
-        //the test passes if this expression compiles
+    public void should_allow_construction_of_captor_for_parameterized_type_in_a_convenient_way() {
+        // the test passes if this expression compiles
         @SuppressWarnings("unchecked")
         ArgumentCaptor<List<Person>> argument = ArgumentCaptor.forClass(List.class);
         assertNotNull(argument);
     }
 
     @Test
-    public void should_allow_construction_of_captor_for_a_more_specific_type()  {
-        //the test passes if this expression compiles
+    public void should_allow_construction_of_captor_for_a_more_specific_type() {
+        // the test passes if this expression compiles
         ArgumentCaptor<List<?>> argument = ArgumentCaptor.forClass(ArrayList.class);
         assertNotNull(argument);
     }
 
     @Test
     public void should_allow_capturing_for_stubbing() {
-        //given
+        // given
         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
         when(emailService.sendEmailTo(argument.capture())).thenReturn(false);
 
-        //when
+        // when
         emailService.sendEmailTo(new Person(10));
 
-        //then
+        // then
         assertEquals(10, argument.getValue().getAge());
     }
 
     @Test
     public void should_capture_when_stubbing_only_when_entire_invocation_matches() {
-        //given
+        // given
         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);
         when(mock.simpleMethod(argument.capture(), eq(2))).thenReturn("blah");
 
-        //when
+        // when
         mock.simpleMethod("foo", 200);
         mock.simpleMethod("bar", 2);
 
-        //then
+        // then
         Assertions.assertThat(argument.getAllValues()).containsOnly("bar");
     }
 
@@ -176,19 +175,20 @@ public class CapturingArgumentsTest extends TestBase {
         try {
             argument.getValue();
             fail();
-        } catch (MockitoException expected) { }
+        } catch (MockitoException expected) {
+        }
     }
 
     @Test
     public void should_capture_when_full_arg_list_matches() throws Exception {
-        //given
+        // given
         ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
 
-        //when
+        // when
         mock.simpleMethod("foo", 1);
         mock.simpleMethod("bar", 2);
 
-        //then
+        // then
         verify(mock).simpleMethod(captor.capture(), eq(1));
         assertEquals(1, captor.getAllValues().size());
         assertEquals("foo", captor.getValue());
@@ -196,26 +196,26 @@ public class CapturingArgumentsTest extends TestBase {
 
     @Test
     public void should_capture_int_by_creating_captor_with_primitive_wrapper() {
-        //given
+        // given
         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(Integer.class);
 
-        //when
+        // when
         mock.intArgumentMethod(10);
 
-        //then
+        // then
         verify(mock).intArgumentMethod(argument.capture());
         assertEquals(10, (int) argument.getValue());
     }
 
     @Test
     public void should_capture_int_by_creating_captor_with_primitive() throws Exception {
-        //given
+        // given
         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(int.class);
 
-        //when
+        // when
         mock.intArgumentMethod(10);
 
-        //then
+        // then
         verify(mock).intArgumentMethod(argument.capture());
         assertEquals(10, (int) argument.getValue());
     }
@@ -235,7 +235,8 @@ public class CapturingArgumentsTest extends TestBase {
     }
 
     @Test
-    public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper() throws Exception {
+    public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper()
+            throws Exception {
         // given
         ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(Byte.class);
 
@@ -273,11 +274,13 @@ public class CapturingArgumentsTest extends TestBase {
         // then
         verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.capture());
 
-        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c", "again ?!");
+        Assertions.assertThat(argumentCaptor.getAllValues())
+                .containsExactly("a", "b", "c", "again ?!");
     }
 
     @Test
-    public void should_capture_one_arg_even_when_using_vararg_captor_on_nonvararg_method() throws Exception {
+    public void should_capture_one_arg_even_when_using_vararg_captor_on_nonvararg_method()
+            throws Exception {
         // given
         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
 
@@ -299,7 +302,12 @@ public class CapturingArgumentsTest extends TestBase {
 
         // then
         // this is only for backwards compatibility. It does not make sense in real to do so.
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture(), argumentCaptor.capture());
+        verify(mock)
+                .mixedVarargs(
+                        any(),
+                        argumentCaptor.capture(),
+                        argumentCaptor.capture(),
+                        argumentCaptor.capture());
         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c");
     }
 
diff --git a/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java b/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
index 3114834..66e6a20 100644
--- a/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
+++ b/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
@@ -4,21 +4,20 @@
  */
 package org.mockitousage.matchers;
 
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Mockito.verify;
-
 public class CustomMatcherDoesYieldCCETest extends TestBase {
 
-    @Mock
-    private IMethods mock;
+    @Mock private IMethods mock;
 
     @Test
     public void shouldNotThrowCCE() {
diff --git a/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java b/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
index 90bb44c..c8dc40d 100644
--- a/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
@@ -12,13 +18,6 @@ import org.mockito.Mockito;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 public class CustomMatchersTest extends TestBase {
 
     private final class ContainsFoo implements ArgumentMatcher<String> {
@@ -146,15 +145,20 @@ public class CustomMatchersTest extends TestBase {
         mock.simpleMethod("foo");
 
         try {
-            verify(mock).simpleMethod((String) argThat(new ArgumentMatcher<Object>() {
-                public boolean matches(Object argument) {
-                    return false;
-                }}));
+            verify(mock)
+                    .simpleMethod(
+                            (String)
+                                    argThat(
+                                            new ArgumentMatcher<Object>() {
+                                                public boolean matches(Object argument) {
+                                                    return false;
+                                                }
+                                            }));
             fail();
         } catch (AssertionError e) {
             assertThat(e)
-                .hasMessageContaining("<custom argument matcher>")
-                .hasMessageContaining("foo");
+                    .hasMessageContaining("<custom argument matcher>")
+                    .hasMessageContaining("foo");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/GenericMatchersTest.java b/src/test/java/org/mockitousage/matchers/GenericMatchersTest.java
index 89387c3..c779c5b 100644
--- a/src/test/java/org/mockitousage/matchers/GenericMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/GenericMatchersTest.java
@@ -2,24 +2,24 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
-import org.junit.Test;
-import org.mockito.ArgumentMatchers;
-import org.mockito.Mock;
-import org.mockitoutil.TestBase;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.when;
 
 import java.util.Date;
 import java.util.List;
 
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.when;
+import org.junit.Test;
+import org.mockito.ArgumentMatchers;
+import org.mockito.Mock;
+import org.mockitoutil.TestBase;
 
 public class GenericMatchersTest extends TestBase {
 
     private interface Foo {
         List<String> sort(List<String> otherList);
+
         String convertDate(Date date);
     }
 
@@ -29,9 +29,9 @@ public class GenericMatchersTest extends TestBase {
     @Test
     public void shouldCompile() {
         when(sorter.convertDate(new Date())).thenReturn("one");
-        when(sorter.convertDate((Date) anyObject())).thenReturn("two");
+        when(sorter.convertDate((Date) any())).thenReturn("two");
 
-        //following requires warning suppression but allows setting anyList()
+        // following requires warning suppression but allows setting anyList()
         when(sorter.sort(ArgumentMatchers.<String>anyList())).thenReturn(null);
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
index bee9569..3f16618 100644
--- a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
@@ -2,26 +2,25 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.hamcrest.MockitoHamcrest.*;
+
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
 import org.junit.Test;
 import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
 import org.mockito.Mockito;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.hamcrest.CoreMatchers.is;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.mockito.hamcrest.MockitoHamcrest.*;
-
 public class HamcrestMatchersTest extends TestBase {
 
     private final class ContainsX extends BaseMatcher<String> {
@@ -34,8 +33,7 @@ public class HamcrestMatchersTest extends TestBase {
         }
     }
 
-    @Mock
-    private IMethods mock;
+    @Mock private IMethods mock;
 
     @Test
     public void stubs_with_hamcrest_matcher() {
@@ -60,6 +58,7 @@ public class HamcrestMatchersTest extends TestBase {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
@@ -93,6 +92,7 @@ public class HamcrestMatchersTest extends TestBase {
         public boolean matches(Object o) {
             return true;
         }
+
         public void describeTo(Description description) {}
     }
 
@@ -110,11 +110,14 @@ public class HamcrestMatchersTest extends TestBase {
 
     @Test
     public void coexists_with_mockito_matcher() {
-        when(mock.simpleMethod(Mockito.argThat(new ArgumentMatcher<String>() {
-            public boolean matches(String argument) {
-                return true;
-            }
-        }))).thenReturn("x");
+        when(mock.simpleMethod(
+                        Mockito.argThat(
+                                new ArgumentMatcher<String>() {
+                                    public boolean matches(String argument) {
+                                        return true;
+                                    }
+                                })))
+                .thenReturn("x");
 
         assertEquals("x", mock.simpleMethod("x"));
     }
diff --git a/src/test/java/org/mockitousage/matchers/InvalidUseOfMatchersTest.java b/src/test/java/org/mockitousage/matchers/InvalidUseOfMatchersTest.java
index a562f1f..ecd77ca 100644
--- a/src/test/java/org/mockitousage/matchers/InvalidUseOfMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/InvalidUseOfMatchersTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
 import org.junit.runner.Result;
@@ -16,13 +22,6 @@ import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.when;
-
 @RunWith(MockitoJUnitRunner.Silent.class)
 public class InvalidUseOfMatchersTest {
 
@@ -35,17 +34,15 @@ public class InvalidUseOfMatchersTest {
             when(mock.threeArgumentMethod(1, eq("2"), "3")).thenReturn(null);
             fail();
         } catch (InvalidUseOfMatchersException e) {
-            assertThat(e.getMessage())
-                    .contains("3 matchers expected")
-                    .contains("1 recorded");
+            assertThat(e.getMessage()).contains("3 matchers expected").contains("1 recorded");
         }
     }
 
     @Test
     public void should_detect_stupid_use_of_matchers_when_verifying() {
         mock.oneArg(true);
-        eq("that's the stupid way");
-        eq("of using matchers");
+        Object ignored = eq("that's the stupid way");
+        ignored = eq("of using matchers");
         try {
             Mockito.verify(mock).oneArg(true);
             fail();
@@ -75,7 +72,7 @@ public class InvalidUseOfMatchersTest {
     }
 
     @Test
-    public void should_scream_when_not_enough_matchers_inside_or_AddtionalMatcher() {
+    public void should_scream_when_not_enough_matchers_inside_or_AdditionalMatcher() {
         try {
             mock.simpleMethod(AdditionalMatchers.or(eq("jkl"), "asd"));
             fail();
@@ -93,9 +90,7 @@ public class InvalidUseOfMatchersTest {
             mock.threeArgumentMethod(1, "asd", eq("asd"));
             fail();
         } catch (InvalidUseOfMatchersException e) {
-            assertThat(e.getMessage())
-                    .contains("3 matchers expected")
-                    .contains("1 recorded");
+            assertThat(e.getMessage()).contains("3 matchers expected").contains("1 recorded");
         }
     }
 
@@ -103,19 +98,18 @@ public class InvalidUseOfMatchersTest {
     public void should_mention_matcher_when_misuse_detected() {
         // Given
 
-
         // When
         Result run = new JUnitCore().run(ObjectMatcherMisuseOnPrimitiveSite.class);
 
         // Then
 
         assertThat(run.getFailures()).hasSize(2);
-        assertThat(run.getFailures().get(0).getException()).isInstanceOf(NullPointerException.class)
-                                                           .hasMessage(null);
-        assertThat(run.getFailures().get(1).getException()).isInstanceOf(InvalidUseOfMatchersException.class)
-                                                           .hasMessageContaining("primitive alternatives");
+        assertThat(run.getFailures().get(0).getException())
+                .isInstanceOf(NullPointerException.class);
+        assertThat(run.getFailures().get(1).getException())
+                .isInstanceOf(InvalidUseOfMatchersException.class)
+                .hasMessageContaining("primitive alternatives");
         new StateMaster().reset();
-
     }
 
     @RunWith(MockitoJUnitRunner.class)
@@ -123,10 +117,9 @@ public class InvalidUseOfMatchersTest {
         @Test
         public void fails_with_NPE() {
             IMethods mock = Mockito.mock(IMethods.class);
-            doNothing().when(mock)
-                       .twoArgumentMethod(eq(73),
-                                          (Integer) any()); // <= Raise NPE on this call site
+            doNothing()
+                    .when(mock)
+                    .twoArgumentMethod(eq(73), (Integer) any()); // <= Raise NPE on this call site
         }
-
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java b/src/test/java/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java
index 99cf81b..b90b547 100644
--- a/src/test/java/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java
+++ b/src/test/java/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java
@@ -2,37 +2,37 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.verify;
-
 public class MatchersMixedWithRawArgumentsTest extends TestBase {
 
     @Mock private IMethods mock;
 
-    //description of an idea:
-    //types of arguments and descriptor value that identifies matcher:
-    //Object: objenesis instance to check for identity
-    //boolean: false
-    //byte: max-1
-    //short: max-1
-    //int: max-1
-    //long: max-1
-    //char: 'x'
-    //double: max-1
-    //float: max-1
-
-    //1. how objenesis deal with primitive arrays (like byte[])?
-    //2. Analisys of all matchers used by R2 project finished before anyObject() and so far proves it's a good idea.
+    // description of an idea:
+    // types of arguments and descriptor value that identifies matcher:
+    // Object: objenesis instance to check for identity
+    // boolean: false
+    // byte: max-1
+    // short: max-1
+    // int: max-1
+    // long: max-1
+    // char: 'x'
+    // double: max-1
+    // float: max-1
+
+    // 1. how objenesis deal with primitive arrays (like byte[])?
+    // 2. Analisys of all matchers used by R2 project finished before any() and so far proves
+    // it's a good idea.
 
     @Ignore("prototyping new feature that allows to avoid eq() matchers when raw args passed")
     @Test
diff --git a/src/test/java/org/mockitousage/matchers/MatchersTest.java b/src/test/java/org/mockitousage/matchers/MatchersTest.java
index 9c4dcb0..777c49a 100644
--- a/src/test/java/org/mockitousage/matchers/MatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/MatchersTest.java
@@ -2,26 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
-import java.math.BigDecimal;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.RandomAccess;
-import java.util.regex.Pattern;
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.AdditionalMatchers.and;
 import static org.mockito.AdditionalMatchers.aryEq;
 import static org.mockito.AdditionalMatchers.cmpEq;
@@ -33,8 +20,8 @@ import static org.mockito.AdditionalMatchers.leq;
 import static org.mockito.AdditionalMatchers.lt;
 import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.AdditionalMatchers.or;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.nullable;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyByte;
@@ -43,7 +30,6 @@ import static org.mockito.Mockito.anyDouble;
 import static org.mockito.Mockito.anyFloat;
 import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.anyLong;
-import static org.mockito.Mockito.anyObject;
 import static org.mockito.Mockito.anyShort;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.contains;
@@ -60,6 +46,19 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.RandomAccess;
+import java.util.regex.Pattern;
+
+import org.junit.Test;
+import org.mockito.ArgumentMatchers;
+import org.mockito.Mockito;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class MatchersTest extends TestBase {
@@ -285,9 +284,7 @@ public class MatchersTest extends TestBase {
         when(mock.oneArg(anyInt())).thenReturn("5");
         when(mock.oneArg(anyLong())).thenReturn("6");
         when(mock.oneArg(anyShort())).thenReturn("7");
-        when(mock.oneArg((String) anyObject())).thenReturn("8");
-        when(mock.oneArg(anyObject())).thenReturn("9");
-        when(mock.oneArg(any(RandomAccess.class))).thenReturn("10");
+        when(mock.oneArg(any(RandomAccess.class))).thenReturn("8");
 
         assertEquals("0", mock.oneArg(true));
         assertEquals("0", mock.oneArg(false));
@@ -299,12 +296,8 @@ public class MatchersTest extends TestBase {
         assertEquals("5", mock.oneArg(1));
         assertEquals("6", mock.oneArg(1L));
         assertEquals("7", mock.oneArg((short) 1));
-        assertEquals("8", mock.oneArg("Test"));
-
-        assertEquals("9", mock.oneArg(new Object()));
-        assertEquals("9", mock.oneArg(new HashMap()));
 
-        assertEquals("10", mock.oneArg(new ArrayList()));
+        assertEquals("8", mock.oneArg(new ArrayList()));
     }
 
     @Test
@@ -326,59 +319,70 @@ public class MatchersTest extends TestBase {
 
     @Test
     public void should_use_smart_equals_for_arrays() throws Exception {
-        //issue 143
-        mock.arrayMethod(new String[]{"one"});
-        verify(mock).arrayMethod(eq(new String[]{"one"}));
-        verify(mock).arrayMethod(new String[]{"one"});
+        // issue 143
+        mock.arrayMethod(new String[] {"one"});
+        verify(mock).arrayMethod(eq(new String[] {"one"}));
+        verify(mock).arrayMethod(new String[] {"one"});
     }
 
     @Test
     public void should_use_smart_equals_for_primitive_arrays() throws Exception {
-        //issue 143
-        mock.objectArgMethod(new int[]{1, 2});
-        verify(mock).objectArgMethod(eq(new int[]{1, 2}));
-        verify(mock).objectArgMethod(new int[]{1, 2});
+        // issue 143
+        mock.objectArgMethod(new int[] {1, 2});
+        verify(mock).objectArgMethod(eq(new int[] {1, 2}));
+        verify(mock).objectArgMethod(new int[] {1, 2});
     }
 
-    @Test(expected = ArgumentsAreDifferent.class)
-    public void array_equals_should_throw_ArgumentsAreDifferentException_for_non_matching_arguments() {
+    @SuppressWarnings("ReturnValueIgnored")
+    @Test
+    public void
+            array_equals_should_throw_ArgumentsAreDifferentException_for_non_matching_arguments() {
         List<Object> list = Mockito.mock(List.class);
 
         list.add("test"); // testing fix for issue 20
-        list.contains(new Object[]{"1"});
+        list.contains(new Object[] {"1"});
 
-        Mockito.verify(list).contains(new Object[]{"1", "2", "3"});
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.verify(list).contains(new Object[] {"1", "2", "3"});
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "list.contains([\"1\", \"2\", \"3\"]);",
+                        "Actual invocations have different arguments:",
+                        "list.add(\"test\");");
     }
 
     @Test
     public void array_equals_matcher() {
-        when(mock.oneArray(aryEq(new boolean[]{true, false, false}))).thenReturn("0");
-        when(mock.oneArray(aryEq(new byte[]{1}))).thenReturn("1");
-        when(mock.oneArray(aryEq(new char[]{1}))).thenReturn("2");
-        when(mock.oneArray(aryEq(new double[]{1}))).thenReturn("3");
-        when(mock.oneArray(aryEq(new float[]{1}))).thenReturn("4");
-        when(mock.oneArray(aryEq(new int[]{1}))).thenReturn("5");
-        when(mock.oneArray(aryEq(new long[]{1}))).thenReturn("6");
-        when(mock.oneArray(aryEq(new short[]{1}))).thenReturn("7");
-        when(mock.oneArray(aryEq(new String[]{"Test"}))).thenReturn("8");
-        when(mock.oneArray(aryEq(new Object[]{"Test", new Integer(4)}))).thenReturn("9");
-
-        assertEquals("0", mock.oneArray(new boolean[]{true, false, false}));
-        assertEquals("1", mock.oneArray(new byte[]{1}));
-        assertEquals("2", mock.oneArray(new char[]{1}));
-        assertEquals("3", mock.oneArray(new double[]{1}));
-        assertEquals("4", mock.oneArray(new float[]{1}));
-        assertEquals("5", mock.oneArray(new int[]{1}));
-        assertEquals("6", mock.oneArray(new long[]{1}));
-        assertEquals("7", mock.oneArray(new short[]{1}));
-        assertEquals("8", mock.oneArray(new String[]{"Test"}));
-        assertEquals("9", mock.oneArray(new Object[]{"Test", new Integer(4)}));
-
-        assertEquals(null, mock.oneArray(new Object[]{"Test", new Integer(999)}));
-        assertEquals(null, mock.oneArray(new Object[]{"Test", new Integer(4), "x"}));
-
-        assertEquals(null, mock.oneArray(new boolean[]{true, false}));
-        assertEquals(null, mock.oneArray(new boolean[]{true, true, false}));
+        when(mock.oneArray(aryEq(new boolean[] {true, false, false}))).thenReturn("0");
+        when(mock.oneArray(aryEq(new byte[] {1}))).thenReturn("1");
+        when(mock.oneArray(aryEq(new char[] {1}))).thenReturn("2");
+        when(mock.oneArray(aryEq(new double[] {1}))).thenReturn("3");
+        when(mock.oneArray(aryEq(new float[] {1}))).thenReturn("4");
+        when(mock.oneArray(aryEq(new int[] {1}))).thenReturn("5");
+        when(mock.oneArray(aryEq(new long[] {1}))).thenReturn("6");
+        when(mock.oneArray(aryEq(new short[] {1}))).thenReturn("7");
+        when(mock.oneArray(aryEq(new String[] {"Test"}))).thenReturn("8");
+        when(mock.oneArray(aryEq(new Object[] {"Test", new Integer(4)}))).thenReturn("9");
+
+        assertEquals("0", mock.oneArray(new boolean[] {true, false, false}));
+        assertEquals("1", mock.oneArray(new byte[] {1}));
+        assertEquals("2", mock.oneArray(new char[] {1}));
+        assertEquals("3", mock.oneArray(new double[] {1}));
+        assertEquals("4", mock.oneArray(new float[] {1}));
+        assertEquals("5", mock.oneArray(new int[] {1}));
+        assertEquals("6", mock.oneArray(new long[] {1}));
+        assertEquals("7", mock.oneArray(new short[] {1}));
+        assertEquals("8", mock.oneArray(new String[] {"Test"}));
+        assertEquals("9", mock.oneArray(new Object[] {"Test", new Integer(4)}));
+
+        assertEquals(null, mock.oneArray(new Object[] {"Test", new Integer(999)}));
+        assertEquals(null, mock.oneArray(new Object[] {"Test", new Integer(4), "x"}));
+
+        assertEquals(null, mock.oneArray(new boolean[] {true, false}));
+        assertEquals(null, mock.oneArray(new boolean[] {true, true, false}));
     }
 
     @Test
@@ -454,14 +458,14 @@ public class MatchersTest extends TestBase {
 
     @Test
     public void null_matcher_for_primitive_wrappers() {
-        when(mock.forBoolean(isNull(Boolean.class))).thenReturn("ok");
-        when(mock.forInteger(isNull(Integer.class))).thenReturn("ok");
-        when(mock.forLong(isNull(Long.class))).thenReturn("ok");
-        when(mock.forByte(isNull(Byte.class))).thenReturn("ok");
-        when(mock.forShort(isNull(Short.class))).thenReturn("ok");
-        when(mock.forCharacter(isNull(Character.class))).thenReturn("ok");
-        when(mock.forDouble(isNull(Double.class))).thenReturn("ok");
-        when(mock.forFloat(isNull(Float.class))).thenReturn("ok");
+        when(mock.forBoolean(ArgumentMatchers.<Boolean>isNull())).thenReturn("ok");
+        when(mock.forInteger(ArgumentMatchers.<Integer>isNull())).thenReturn("ok");
+        when(mock.forLong(ArgumentMatchers.<Long>isNull())).thenReturn("ok");
+        when(mock.forByte(ArgumentMatchers.<Byte>isNull())).thenReturn("ok");
+        when(mock.forShort(ArgumentMatchers.<Short>isNull())).thenReturn("ok");
+        when(mock.forCharacter(ArgumentMatchers.<Character>isNull())).thenReturn("ok");
+        when(mock.forDouble(ArgumentMatchers.<Double>isNull())).thenReturn("ok");
+        when(mock.forFloat(ArgumentMatchers.<Float>isNull())).thenReturn("ok");
 
         assertEquals("ok", mock.forBoolean(null));
         assertEquals("ok", mock.forInteger(null));
@@ -511,6 +515,14 @@ public class MatchersTest extends TestBase {
         assertEquals(null, mock.oneArg("blah"));
     }
 
+    @Test
+    public void matches_Pattern_matcher_in_subregion() {
+        when(mock.oneArg(matches(Pattern.compile("[a-z]")))).thenReturn("1");
+
+        assertEquals("1", mock.oneArg("3a45"));
+        assertEquals(null, mock.oneArg("3445"));
+    }
+
     @Test
     public void contains_matcher() {
         when(mock.oneArg(contains("ell"))).thenReturn("1");
@@ -594,21 +606,21 @@ public class MatchersTest extends TestBase {
     public void eq_matcher_and_nulls() {
         mock.simpleMethod((Object) null);
 
-        verify(mock).simpleMethod(eq(null));
+        verify(mock).simpleMethod(Mockito.<Object>eq(null));
     }
 
     @Test
     public void same_matcher_and_nulls() {
         mock.simpleMethod((Object) null);
 
-        verify(mock).simpleMethod(same(null));
+        verify(mock).simpleMethod(Mockito.<Object>same(null));
     }
 
     @Test
     public void nullable_matcher() throws Exception {
         // imagine a Stream.of(...).map(c -> mock.oneArg(c))...
         mock.oneArg((Character) null);
-        mock.oneArg(Character.valueOf(''));
+        mock.oneArg(Character.valueOf('\u20AC'));
 
         verify(mock, times(2)).oneArg(nullable(Character.class));
     }
diff --git a/src/test/java/org/mockitousage/matchers/MoreMatchersTest.java b/src/test/java/org/mockitousage/matchers/MoreMatchersTest.java
index 46773b8..c68d548 100644
--- a/src/test/java/org/mockitousage/matchers/MoreMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/MoreMatchersTest.java
@@ -2,23 +2,23 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.*;
+
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.*;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 public class MoreMatchersTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -30,14 +30,6 @@ public class MoreMatchersTest extends TestBase {
         assertEquals("string", mock.objectArgMethod("foo"));
     }
 
-    @Test
-    public void any_should_be_actual_alias_to_anyObject() {
-        mock.simpleMethod((Object) null);
-
-        verify(mock).simpleMethod(any());
-        verify(mock).simpleMethod(anyObject());
-    }
-
     @Test
     public void any_class_should_be_actual_alias_to_isA() {
         mock.simpleMethod(new ArrayList());
@@ -47,80 +39,22 @@ public class MoreMatchersTest extends TestBase {
 
         mock.simpleMethod((String) null);
 
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock).simpleMethod(isA(String.class));
-            }
-        }).isInstanceOf(ArgumentsAreDifferent.class);
-
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock).simpleMethod(any(String.class));
-            }
-        }).isInstanceOf(ArgumentsAreDifferent.class);
-    }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_lists() {
-        //Below yields compiler warning:
-        //when(mock.listArgMethod(anyList())).thenReturn("list");
-        when(mock.listArgMethod(anyListOf(String.class))).thenReturn("list");
-
-        assertEquals("list", mock.listArgMethod(new LinkedList<String>()));
-        assertEquals("list", mock.listArgMethod(Collections.<String>emptyList()));
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock).simpleMethod(isA(String.class));
+                            }
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
+
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock).simpleMethod(any(String.class));
+                            }
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
     }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_sets() {
-        //Below yields compiler warning:
-        //when(mock.setArgMethod(anySet())).thenReturn("set");
-        when(mock.setArgMethod(anySetOf(String.class))).thenReturn("set");
-
-        assertEquals("set", mock.setArgMethod(new HashSet<String>()));
-        assertEquals("set", mock.setArgMethod(Collections.<String>emptySet()));
-    }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_maps() {
-        //Below yields compiler warning:
-        //when(mock.setArgMethod(anySet())).thenReturn("set");
-        when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn("map");
-
-        assertEquals("map", mock.forMap(new HashMap<String, String>()));
-        assertEquals("map", mock.forMap(Collections.<String, String>emptyMap()));
-    }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_collections() {
-        //Below yields compiler warning:
-        //when(mock.setArgMethod(anySet())).thenReturn("set");
-        when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn("collection");
-
-        assertEquals("collection", mock.collectionArgMethod(new ArrayList<String>()));
-        assertEquals("collection", mock.collectionArgMethod(Collections.<String>emptyList()));
-    }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_iterables() {
-        //Below yields compiler warning:
-        //when(mock.setArgMethod(anySet())).thenReturn("set");
-        when(mock.iterableArgMethod(anyIterableOf(String.class))).thenReturn("iterable");
-
-        assertEquals("iterable", mock.iterableArgMethod(new ArrayList<String>()));
-        assertEquals("iterable", mock.iterableArgMethod(Collections.<String>emptyList()));
-    }
-
-    @Test
-    public void should_help_out_with_unnecessary_casting_of_nullity_checks() {
-        when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn("string");
-        when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn("string");
-        when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn("string");
-
-        assertEquals("string", mock.objectArgMethod(null));
-        assertEquals("string", mock.objectArgMethod("foo"));
-        assertEquals("string", mock.objectArgMethod("foo"));
-    }
-
 }
diff --git a/src/test/java/org/mockitousage/matchers/NewMatchersTest.java b/src/test/java/org/mockitousage/matchers/NewMatchersTest.java
index 2f6cbc3..69ff3c4 100644
--- a/src/test/java/org/mockitousage/matchers/NewMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/NewMatchersTest.java
@@ -4,18 +4,18 @@
  */
 package org.mockitousage.matchers;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
 
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class NewMatchersTest extends TestBase {
@@ -29,51 +29,51 @@ public class NewMatchersTest extends TestBase {
 
     @Test
     public void shouldAllowAnyList() {
-        when(mock.forList(anyListOf(String.class))).thenReturn("matched");
+        when(mock.forList(anyList())).thenReturn("matched");
 
         assertEquals("matched", mock.forList(Arrays.asList("x", "y")));
         assertEquals(null, mock.forList(null));
 
-        verify(mock, times(1)).forList(anyListOf(String.class));
+        verify(mock, times(1)).forList(anyList());
     }
 
     @Test
     public void shouldAllowAnyCollection() {
-        when(mock.forCollection(anyCollectionOf(String.class))).thenReturn("matched");
+        when(mock.forCollection(anyCollection())).thenReturn("matched");
 
         assertEquals("matched", mock.forCollection(Arrays.asList("x", "y")));
         assertEquals(null, mock.forCollection(null));
 
-        verify(mock, times(1)).forCollection(anyCollectionOf(String.class));
+        verify(mock, times(1)).forCollection(anyCollection());
     }
 
     @Test
     public void shouldAllowAnyMap() {
-        when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn("matched");
+        when(mock.forMap(anyMap())).thenReturn("matched");
 
         assertEquals("matched", mock.forMap(new HashMap<String, String>()));
         assertEquals(null, mock.forMap(null));
 
-        verify(mock, times(1)).forMap(anyMapOf(String.class, String.class));
+        verify(mock, times(1)).forMap(anyMap());
     }
 
     @Test
     public void shouldAllowAnySet() {
-        when(mock.forSet(anySetOf(String.class))).thenReturn("matched");
+        when(mock.forSet(anySet())).thenReturn("matched");
 
         assertEquals("matched", mock.forSet(new HashSet<String>()));
         assertEquals(null, mock.forSet(null));
 
-        verify(mock, times(1)).forSet(anySetOf(String.class));
+        verify(mock, times(1)).forSet(anySet());
     }
 
     @Test
     public void shouldAllowAnyIterable() {
-        when(mock.forIterable(anyIterableOf(String.class))).thenReturn("matched");
+        when(mock.forIterable(anyIterable())).thenReturn("matched");
 
         assertEquals("matched", mock.forIterable(new HashSet<String>()));
         assertEquals(null, mock.forIterable(null));
 
-        verify(mock, times(1)).forIterable(anyIterableOf(String.class));
+        verify(mock, times(1)).forIterable(anyIterable());
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/ReflectionMatchersTest.java b/src/test/java/org/mockitousage/matchers/ReflectionMatchersTest.java
index 84ad482..5afd360 100644
--- a/src/test/java/org/mockitousage/matchers/ReflectionMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/ReflectionMatchersTest.java
@@ -2,24 +2,25 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.ArgumentMatchers.refEq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Before;
 import org.junit.Test;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Matchers.refEq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 @SuppressWarnings("all")
 public class ReflectionMatchersTest extends TestBase {
 
     class Parent {
         private int parentField;
         protected String protectedParentField;
+
         public Parent(int parentField, String protectedParentField) {
             this.parentField = parentField;
             this.protectedParentField = protectedParentField;
@@ -29,7 +30,12 @@ public class ReflectionMatchersTest extends TestBase {
     class Child extends Parent {
         private int childFieldOne;
         private Object childFieldTwo;
-        public Child(int parentField, String protectedParentField, int childFieldOne, Object childFieldTwo) {
+
+        public Child(
+                int parentField,
+                String protectedParentField,
+                int childFieldOne,
+                Object childFieldTwo) {
             super(parentField, protectedParentField);
             this.childFieldOne = childFieldOne;
             this.childFieldTwo = childFieldTwo;
@@ -56,28 +62,72 @@ public class ReflectionMatchersTest extends TestBase {
         verify(mock).run(refEq(wanted));
     }
 
-    @Test(expected=ArgumentsAreDifferent.class)
+    @Test
     public void shouldNotMatchWhenFieldValuesDiffer() throws Exception {
         Child wanted = new Child(1, "foo", 2, "bar XXX");
-        verify(mock).run(refEq(wanted));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).run(refEq(wanted));
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mockMe.run(",
+                        "    refEq(org.mockitousage.matchers.ReflectionMatchersTest",
+                        "Actual invocations have different arguments:",
+                        "mockMe.run(",
+                        "    org.mockitousage.matchers.ReflectionMatchersTest");
     }
 
-    @Test(expected=ArgumentsAreDifferent.class)
+    @Test
     public void shouldNotMatchAgain() throws Exception {
         Child wanted = new Child(1, "foo", 999, "bar");
-        verify(mock).run(refEq(wanted));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).run(refEq(wanted));
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mockMe.run(",
+                        "    refEq(org.mockitousage.matchers.ReflectionMatchersTest",
+                        "Actual invocations have different arguments:",
+                        "mockMe.run(",
+                        "    org.mockitousage.matchers.ReflectionMatchersTest");
     }
 
-    @Test(expected=ArgumentsAreDifferent.class)
+    @Test
     public void shouldNotMatchYetAgain() throws Exception {
         Child wanted = new Child(1, "XXXXX", 2, "bar");
-        verify(mock).run(refEq(wanted));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).run(refEq(wanted));
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mockMe.run(",
+                        "    refEq(org.mockitousage.matchers.ReflectionMatchersTest",
+                        "Actual invocations have different arguments:",
+                        "mockMe.run(",
+                        "    org.mockitousage.matchers.ReflectionMatchersTest");
     }
 
-    @Test(expected=ArgumentsAreDifferent.class)
+    @Test
     public void shouldNotMatch() throws Exception {
         Child wanted = new Child(234234, "foo", 2, "bar");
-        verify(mock).run(refEq(wanted));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).run(refEq(wanted));
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mockMe.run(",
+                        "    refEq(org.mockitousage.matchers.ReflectionMatchersTest",
+                        "Actual invocations have different arguments:",
+                        "mockMe.run(",
+                        "    org.mockitousage.matchers.ReflectionMatchersTest");
     }
 
     @Test
@@ -93,9 +143,20 @@ public class ReflectionMatchersTest extends TestBase {
         verify(mock).run(refEq(wanted, "parentField", "childFieldTwo"));
     }
 
-    @Test(expected=ArgumentsAreDifferent.class)
+    @Test
     public void shouldNotMatchWithFieldsExclusion() throws Exception {
         Child wanted = new Child(234234, "foo", 2, "excluded");
-        verify(mock).run(refEq(wanted, "childFieldTwo"));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).run(refEq(wanted, "childFieldTwo"));
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "mockMe.run(",
+                        "    refEq(org.mockitousage.matchers.ReflectionMatchersTest",
+                        "Actual invocations have different arguments:",
+                        "mockMe.run(",
+                        "    org.mockitousage.matchers.ReflectionMatchersTest");
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/VarargsTest.java b/src/test/java/org/mockitousage/matchers/VarargsTest.java
index 685c918..dfb7269 100644
--- a/src/test/java/org/mockitousage/matchers/VarargsTest.java
+++ b/src/test/java/org/mockitousage/matchers/VarargsTest.java
@@ -4,6 +4,7 @@
  */
 package org.mockitousage.matchers;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
@@ -19,33 +20,29 @@ import org.assertj.core.api.ObjectAssert;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.ArgumentCaptor;
+import org.mockito.ArgumentMatchers;
 import org.mockito.Captor;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.mockitousage.IMethods;
 
 public class VarargsTest {
 
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-    @Captor
-    private ArgumentCaptor<String> captor;
-    @Mock
-    private IMethods mock;
+    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
+    @Captor private ArgumentCaptor<String> captor;
+    @Mock private IMethods mock;
 
-    private static final Condition<Object> NULL = new Condition<Object>() {
+    private static final Condition<Object> NULL =
+            new Condition<Object>() {
 
-        @Override
-        public boolean matches(Object value) {
-            return value == null;
-        }
-    };
+                @Override
+                public boolean matches(Object value) {
+                    return value == null;
+                }
+            };
 
     @Test
     public void shouldMatchVarArgs_noArgs() {
@@ -83,7 +80,7 @@ public class VarargsTest {
         Object arg = null;
         mock.varargs(arg);
 
-        verify(mock).varargs(eq(null));
+        verify(mock).varargs(ArgumentMatchers.<Object[]>eq(null));
     }
 
     @Test
@@ -91,7 +88,7 @@ public class VarargsTest {
         Object arg = null;
         mock.varargs(arg);
 
-        verify(mock).varargs(isNull());
+        verify(mock).varargs(ArgumentMatchers.<Object[]>isNull());
     }
 
     @Test
@@ -99,53 +96,57 @@ public class VarargsTest {
         Object[] argArray = null;
         mock.varargs(argArray);
 
-        verify(mock).varargs(isNull());
+        verify(mock).varargs(ArgumentMatchers.<Object[]>isNull());
     }
 
     @Test
     public void shouldnotMatchVarArgs_twoArgsOneMatcher() {
         mock.varargs("1", "1");
 
-        exception.expectMessage("Argument(s) are different");
-
-        verify(mock).varargs(eq("1"));
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).varargs(eq("1"));
+                        })
+                .hasMessageContaining("Argument(s) are different");
     }
 
     @Test
     public void shouldMatchVarArgs_emptyVarArgsOneAnyMatcher() {
         mock.varargs();
 
-        verify(mock).varargs((String[])any()); // any() -> VarargMatcher
+        verify(mock).varargs((String[]) any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_oneArgsOneAnyMatcher() {
         mock.varargs(1);
 
-        verify(mock).varargs(any()); // any() -> VarargMatcher
+        verify(mock).varargs(ArgumentMatchers.<Object[]>any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_twoArgsOneAnyMatcher() {
         mock.varargs(1, 2);
 
-        verify(mock).varargs(any()); // any() -> VarargMatcher
+        verify(mock).varargs(ArgumentMatchers.<Object[]>any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_twoArgsTwoAnyMatcher() {
         mock.varargs(1, 2);
 
-        verify(mock).varargs(any(), any()); // any() -> VarargMatcher
+        verify(mock).varargs(any(), ArgumentMatchers.<Object>any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_twoArgsThreeAnyMatcher() {
         mock.varargs(1, 2);
 
-        exception.expectMessage("Argument(s) are different");
-
-        verify(mock).varargs(any(), any(), any()); //any() -> VarargMatcher
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).varargs(any(), any(), any()); // any() -> VarargMatcher
+                        })
+                .hasMessageContaining("Argument(s) are different");
     }
 
     @Test
@@ -263,10 +264,11 @@ public class VarargsTest {
     public void shouldNotCaptureVarArgs_3args2captures() {
         mock.varargs("1", "2", "3");
 
-        exception.expect(ArgumentsAreDifferent.class);
-
-        verify(mock).varargs(captor.capture(), captor.capture());
-
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).varargs(captor.capture(), captor.capture());
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
     }
 
     @Test
@@ -276,7 +278,6 @@ public class VarargsTest {
         verify(mock).varargs(captor.capture(), eq("2"), captor.capture());
 
         assertThat(captor).containsExactly("1", "3");
-
     }
 
     @Test
@@ -290,17 +291,17 @@ public class VarargsTest {
         }
 
         assertThat(captor).isEmpty();
-
     }
 
     @Test
     public void shouldNotCaptureVarArgs_1args2captures() {
         mock.varargs("1");
 
-        exception.expect(ArgumentsAreDifferent.class);
-
-        verify(mock).varargs(captor.capture(), captor.capture());
-
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).varargs(captor.capture(), captor.capture());
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
     }
 
     /**
@@ -320,25 +321,29 @@ public class VarargsTest {
 
         verify(mock).varargs(varargCaptor.capture());
 
-        assertThat(varargCaptor).containsExactly(new String[] { "1", "2" });
+        assertThat(varargCaptor).containsExactly(new String[] {"1", "2"});
     }
 
     @Test
-    public void shouldNotMatchRegualrAndVaraArgs()   {
-        mock.varargsString(1, "a","b");
-
-        exception.expect(ArgumentsAreDifferent.class);
+    public void shouldNotMatchRegualrAndVaraArgs() {
+        mock.varargsString(1, "a", "b");
 
-        verify(mock).varargsString(1);
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).varargsString(1);
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
     }
+
     @Test
-    public void shouldNotMatchVaraArgs()   {
-        when(mock.varargsObject(1, "a","b")).thenReturn("OK");
+    public void shouldNotMatchVaraArgs() {
+        when(mock.varargsObject(1, "a", "b")).thenReturn("OK");
 
         Assertions.assertThat(mock.varargsObject(1)).isNull();
     }
 
-    private static <T> AbstractListAssert<?, ?, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
+    private static <T> AbstractListAssert<?, ?, T, ObjectAssert<T>> assertThat(
+            ArgumentCaptor<T> captor) {
         return Assertions.assertThat(captor.getAllValues());
     }
 }
diff --git a/src/test/java/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java b/src/test/java/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java
index eea1111..d0d9cf9 100644
--- a/src/test/java/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.matchers;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class VerificationAndStubbingUsingMatchersTest extends TestBase {
     private IMethods one;
     private IMethods two;
@@ -45,7 +44,8 @@ public class VerificationAndStubbingUsingMatchersTest extends TestBase {
         try {
             three.simpleMethod("test three again");
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
     }
 
     @Test
@@ -56,7 +56,8 @@ public class VerificationAndStubbingUsingMatchersTest extends TestBase {
         try {
             one.oneArg(true);
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
 
         one.simpleMethod(100);
         two.simpleMethod("test Mockito");
@@ -75,6 +76,7 @@ public class VerificationAndStubbingUsingMatchersTest extends TestBase {
         try {
             verify(three).varargsObject(eq(10), eq("first arg"), startsWith("third"));
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/CleaningUpPotentialStubbingTest.java b/src/test/java/org/mockitousage/misuse/CleaningUpPotentialStubbingTest.java
index 7e8a658..7a67d7b 100644
--- a/src/test/java/org/mockitousage/misuse/CleaningUpPotentialStubbingTest.java
+++ b/src/test/java/org/mockitousage/misuse/CleaningUpPotentialStubbingTest.java
@@ -4,6 +4,9 @@
  */
 package org.mockitousage.misuse;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mock;
@@ -11,9 +14,6 @@ import org.mockito.exceptions.misusing.MissingMethodInvocationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class CleaningUpPotentialStubbingTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -45,10 +45,11 @@ public class CleaningUpPotentialStubbingTest extends TestBase {
 
     private void assertOngoingStubbingIsReset() {
         try {
-            //In real, there might be a call to real object or a final method call
-            //I'm modelling it with null
+            // In real, there might be a call to real object or a final method call
+            // I'm modelling it with null
             when(null).thenReturn("anything");
             fail();
-        } catch (MissingMethodInvocationException e) {}
+        } catch (MissingMethodInvocationException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java b/src/test/java/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java
index 41e4a16..3cd9485 100644
--- a/src/test/java/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java
+++ b/src/test/java/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java
@@ -2,9 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.misuse;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
@@ -13,8 +18,6 @@ import org.mockito.exceptions.misusing.NullInsteadOfMockException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
 public class DescriptiveMessagesOnMisuseTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -30,74 +33,139 @@ public class DescriptiveMessagesOnMisuseTest extends TestBase {
     public void tryDescriptiveMessagesOnMisuse() {
         Foo foo = mock(Foo.class);
 
-//        when(foo.finalMethod()).thenReturn("foo");
-//        doReturn("foo").when(foo).finalMethod();
-//        verify(foo).finalMethod();
+        //        when(foo.finalMethod()).thenReturn("foo");
+        //        doReturn("foo").when(foo).finalMethod();
+        //        verify(foo).finalMethod();
 
-//        doReturn("foo");
-//        doReturn("bar");
+        //        doReturn("foo");
+        //        doReturn("bar");
 
-//        verifyNoMoreInteractions();
-//        verifyNoMoreInteractions(null);
-//        verifyNoMoreInteractions("");
-//        verifyZeroInteractions();
-//        verifyZeroInteractions(null);
-//        verifyZeroInteractions("");
-//
-//        inOrder();
-//        inOrder(null);
-//        inOrder("test");
-//        InOrder inOrder = inOrder(mock(List.class));
-//        inOrder.verify(mock).simpleMethod();
+        //        verifyNoMoreInteractions();
+        //        verifyNoMoreInteractions(null);
+        //        verifyNoMoreInteractions("");
+        //
+        //        inOrder();
+        //        inOrder(null);
+        //        inOrder("test");
+        //        InOrder inOrder = inOrder(mock(List.class));
+        //        inOrder.verify(mock).simpleMethod();
 
-//        verify(null);
-//        verify(mock.booleanReturningMethod());
+        //        verify(null);
+        //        verify(mock.booleanReturningMethod());
 
-//        verify(mock).varargs("test", anyString());
+        //        verify(mock).varargs("test", anyString());
 
-//        when("x").thenReturn("x");
+        //        when("x").thenReturn("x");
 
-//        when(mock.simpleMethod());
-//        when(mock.differentMethod()).thenReturn("");
+        //        when(mock.simpleMethod());
+        //        when(mock.differentMethod()).thenReturn("");
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldScreamWhenWholeMethodPassedToVerify() {
-        verify(mock.booleanReturningMethod());
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock.booleanReturningMethod());
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument passed to verify() is of type Boolean and is not a mock!",
+                        "Make sure you place the parenthesis correctly!",
+                        "See the examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();");
     }
 
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions() {
-        verifyNoMoreInteractions(mock.byteReturningMethod());
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(mock.byteReturningMethod());
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument(s) passed is not a mock!",
+                        "Examples of correct verifications:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=NotAMockException.class)
+    @Test
     public void shouldScreamWhenInOrderCreatedWithDodgyMock() {
-        inOrder("not a mock");
+        assertThatThrownBy(
+                        () -> {
+                            inOrder("not a mock");
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessageContainingAll(
+                        "Argument(s) passed is not a mock!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=NullInsteadOfMockException.class)
+    @Test
     public void shouldScreamWhenInOrderCreatedWithNulls() {
-        inOrder(mock, null);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder(mock, null);
+                        })
+                .isInstanceOf(NullInsteadOfMockException.class)
+                .hasMessageContainingAll(
+                        "Argument(s) passed is null!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);");
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-    @Test(expected=NullInsteadOfMockException.class)
+    @Test
     public void shouldScreamNullPassedToVerify() {
-        verify(null);
+        assertThatThrownBy(
+                        () -> {
+                            verify(null);
+                        })
+                .isInstanceOf(NullInsteadOfMockException.class)
+                .hasMessageContainingAll(
+                        "Argument passed to verify() should be a mock but is null!",
+                        "Examples of correct verifications:",
+                        "    verify(mock).someMethod();",
+                        "    verify(mock, times(10)).someMethod();",
+                        "    verify(mock, atLeastOnce()).someMethod();",
+                        "    not: verify(mock.someMethod());",
+                        "Also, if you use @Mock annotation don't miss openMocks()");
     }
 
-    @Test(expected=NullInsteadOfMockException.class)
+    @Test
     public void shouldScreamWhenNotMockPassedToVerifyNoMoreInteractions() {
-        verifyNoMoreInteractions(null, "blah");
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(null, "blah");
+                        })
+                .isInstanceOf(NullInsteadOfMockException.class)
+                .hasMessageContainingAll(
+                        "Argument(s) passed is null!",
+                        "Examples of correct verifications:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 
     @SuppressWarnings("all")
-    @Test(expected=MockitoException.class)
+    @Test
     public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions() {
-        verifyNoMoreInteractions((Object[])null);
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions((Object[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that should be verified, e.g:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/DetectingFinalMethodsTest.java b/src/test/java/org/mockitousage/misuse/DetectingFinalMethodsTest.java
index a351c09..71b507b 100644
--- a/src/test/java/org/mockitousage/misuse/DetectingFinalMethodsTest.java
+++ b/src/test/java/org/mockitousage/misuse/DetectingFinalMethodsTest.java
@@ -4,16 +4,16 @@
  */
 package org.mockitousage.misuse;
 
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.misusing.MissingMethodInvocationException;
 import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.*;
-
 public class DetectingFinalMethodsTest extends TestBase {
 
     class WithFinal {
@@ -31,7 +31,8 @@ public class DetectingFinalMethodsTest extends TestBase {
         try {
             verify(withFinal).foo();
             fail();
-        } catch (UnfinishedVerificationException e) {}
+        } catch (UnfinishedVerificationException e) {
+        }
     }
 
     @Test
@@ -41,6 +42,7 @@ public class DetectingFinalMethodsTest extends TestBase {
         try {
             when(withFinal.foo()).thenReturn(null);
             fail();
-        } catch (MissingMethodInvocationException e) {}
+        } catch (MissingMethodInvocationException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/DetectingMisusedMatchersTest.java b/src/test/java/org/mockitousage/misuse/DetectingMisusedMatchersTest.java
index 267e93c..a4b7294 100644
--- a/src/test/java/org/mockitousage/misuse/DetectingMisusedMatchersTest.java
+++ b/src/test/java/org/mockitousage/misuse/DetectingMisusedMatchersTest.java
@@ -4,7 +4,18 @@
  */
 package org.mockitousage.misuse;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.validateMockitoUsage;
+import static org.mockito.Mockito.verify;
+
 import java.util.Observer;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -13,16 +24,6 @@ import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.anyBoolean;
-import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyObject;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.validateMockitoUsage;
-import static org.mockito.Mockito.verify;
-
 public class DetectingMisusedMatchersTest extends TestBase {
 
     class WithFinal {
@@ -38,21 +39,21 @@ public class DetectingMisusedMatchersTest extends TestBase {
         super.resetState();
     }
 
-    private void misplaced_anyObject_argument_matcher() {
-        anyObject();
+    private void misplaced_any_argument_matcher() {
+        Object ignored = any();
     }
 
     private void misplaced_anyInt_argument_matcher() {
-        anyInt();
+        int ignored = anyInt();
     }
 
     private void misplaced_anyBoolean_argument_matcher() {
-        anyBoolean();
+        boolean ignored = anyBoolean();
     }
 
     @Test
     public void should_fail_fast_when_argument_matchers_are_abused() {
-        misplaced_anyObject_argument_matcher();
+        misplaced_any_argument_matcher();
         try {
             mock(IMethods.class);
             fail();
@@ -67,7 +68,7 @@ public class DetectingMisusedMatchersTest extends TestBase {
             Observer observer = mock(Observer.class);
 
             misplaced_anyInt_argument_matcher();
-            misplaced_anyObject_argument_matcher();
+            misplaced_any_argument_matcher();
             misplaced_anyBoolean_argument_matcher();
 
             observer.update(null, null);
@@ -76,21 +77,24 @@ public class DetectingMisusedMatchersTest extends TestBase {
             fail();
         } catch (InvalidUseOfMatchersException e) {
             assertThat(e)
-                .hasMessageContaining("DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher")
-                .hasMessageContaining("DetectingMisusedMatchersTest.misplaced_anyObject_argument_matcher")
-                .hasMessageContaining("DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher");
+                    .hasMessageContaining(
+                            "DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher")
+                    .hasMessageContaining(
+                            "DetectingMisusedMatchersTest.misplaced_any_argument_matcher")
+                    .hasMessageContaining(
+                            "DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher");
         }
     }
 
-
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
     @Test
     public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers() {
         assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
-        verify(withFinal).finalMethod(anyObject());
+        verify(withFinal).finalMethod(any());
         try {
             verify(withFinal);
             fail();
-        } catch (UnfinishedVerificationException e) {}
+        } catch (UnfinishedVerificationException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/ExplicitFrameworkValidationTest.java b/src/test/java/org/mockitousage/misuse/ExplicitFrameworkValidationTest.java
index 9ebc690..8e9e759 100644
--- a/src/test/java/org/mockitousage/misuse/ExplicitFrameworkValidationTest.java
+++ b/src/test/java/org/mockitousage/misuse/ExplicitFrameworkValidationTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.misuse;
 
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.Mockito;
@@ -14,11 +18,6 @@ import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 public class ExplicitFrameworkValidationTest extends TestBase {
 
     @Mock IMethods mock;
@@ -30,7 +29,8 @@ public class ExplicitFrameworkValidationTest extends TestBase {
         try {
             Mockito.validateMockitoUsage();
             fail();
-        } catch (UnfinishedVerificationException e) {}
+        } catch (UnfinishedVerificationException e) {
+        }
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
@@ -40,15 +40,17 @@ public class ExplicitFrameworkValidationTest extends TestBase {
         try {
             Mockito.validateMockitoUsage();
             fail();
-        } catch (UnfinishedStubbingException e) {}
+        } catch (UnfinishedStubbingException e) {
+        }
     }
 
     @Test
     public void shouldDetectMisplacedArgumentMatcher() {
-        anyObject();
+        Object ignored = any();
         try {
             Mockito.validateMockitoUsage();
             fail();
-        } catch (InvalidUseOfMatchersException e) {}
+        } catch (InvalidUseOfMatchersException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/InvalidUsageTest.java b/src/test/java/org/mockitousage/misuse/InvalidUsageTest.java
index 2197300..35c135a 100644
--- a/src/test/java/org/mockitousage/misuse/InvalidUsageTest.java
+++ b/src/test/java/org/mockitousage/misuse/InvalidUsageTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.misuse;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -14,9 +20,6 @@ import org.mockito.exceptions.misusing.MissingMethodInvocationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assume.assumeFalse;
-import static org.mockito.Mockito.*;
-
 public class InvalidUsageTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -27,93 +30,183 @@ public class InvalidUsageTest extends TestBase {
         super.resetState();
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions() {
-        verifyNoMoreInteractions();
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that should be verified, e.g:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 
-    @Test(expected=MockitoException.class)
-    public void shouldRequireArgumentsWhenVerifyingZeroInteractions() {
-        verifyZeroInteractions();
+    @Test
+    public void shouldRequireArgumentsWhenVerifyingNoInteractions() {
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoInteractions();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that should be verified, e.g:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=MockitoException.class)
+    @Test
     public void shouldNotCreateInOrderObjectWithoutMocks() {
-        inOrder();
+        assertThatThrownBy(
+                        () -> {
+                            inOrder();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);");
     }
 
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowVerifyingInOrderUnfamilarMocks() {
+    @Test
+    public void shouldNotAllowVerifyingInOrderUnfamiliarMocks() {
         InOrder inOrder = inOrder(mock);
-        inOrder.verify(mockTwo).simpleMethod();
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockTwo).simpleMethod();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "InOrder can only verify mocks that were passed in during creation of InOrder.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne);",
+                        "    inOrder.verify(mockOne).doStuff();");
     }
 
-    @Test(expected=MissingMethodInvocationException.class)
+    @Test
     public void shouldReportMissingMethodInvocationWhenStubbing() {
-        when(mock.simpleMethod()).thenReturn("this stubbing is required to make sure Stubbable is pulled");
-        when("".toString()).thenReturn("x");
+        when(mock.simpleMethod())
+                .thenReturn("this stubbing is required to make sure Stubbable is pulled");
+        assertThatThrownBy(
+                        () -> {
+                            when("".toString()).thenReturn("x");
+                        })
+                .isInstanceOf(MissingMethodInvocationException.class)
+                .hasMessageContainingAll(
+                        "when() requires an argument which has to be 'a method call on a mock'.",
+                        "For example:",
+                        "    when(mock.getArticles()).thenReturn(articles);",
+                        "Also, this error might show up because:",
+                        "1. you stub either of: final/private/equals()/hashCode() methods.",
+                        "   Those methods *cannot* be stubbed/verified.",
+                        "   Mocking methods declared on non-public parent classes is not supported.",
+                        "2. inside when() you don't call method on mock but on some other object.");
     }
 
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowSettingInvalidCheckedException() throws Exception {
-        when(mock.simpleMethod()).thenThrow(new Exception());
+    @Test
+    public void shouldNotAllowSettingInvalidCheckedException() {
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.simpleMethod()).thenThrow(new Exception());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Checked exception is invalid for this method!",
+                        "Invalid: java.lang.Exception");
     }
 
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowSettingNullThrowable() throws Exception {
-        when(mock.simpleMethod()).thenThrow(new Throwable[] {null});
+    @Test
+    public void shouldNotAllowSettingNullThrowable() {
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.simpleMethod()).thenThrow(new Throwable[] {null});
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable!");
     }
 
     @SuppressWarnings("all")
-    @Test(expected=MockitoException.class)
+    @Test
     public void shouldNotAllowSettingNullThrowableVararg() throws Exception {
-        when(mock.simpleMethod()).thenThrow((Throwable) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.simpleMethod()).thenThrow((Throwable) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable!");
     }
 
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowSettingNullConsecutiveThrowable() throws Exception {
-        when(mock.simpleMethod()).thenThrow(new RuntimeException(), null);
+    @Test
+    public void shouldNotAllowSettingNullConsecutiveThrowable() {
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.simpleMethod()).thenThrow(new RuntimeException(), null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable!");
     }
 
     final class FinalClass {}
 
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowMockingFinalClassesIfDisabled() throws Exception {
-        assumeFalse("Inlining mock allows mocking final classes", mock(FinalClass.class).getClass() == FinalClass.class);
+    @Test
+    public void shouldNotAllowMockingFinalClassesIfDisabled() {
+        assertThatThrownBy(
+                        () -> {
+                            mock(FinalClass.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Cannot mock/spy class org.mockitousage.misuse.InvalidUsageTest$FinalClass",
+                        "Mockito cannot mock/spy because :",
+                        " - final class");
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
-    @Test(expected=MockitoException.class)
-    public void shouldNotAllowMockingPrimitives() throws Exception {
-        mock(Integer.TYPE);
+    @Test
+    public void shouldNotAllowMockingPrimitives() {
+        assertThatThrownBy(
+                        () -> {
+                            mock(Integer.TYPE);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Cannot mock/spy int",
+                        "Mockito cannot mock/spy because :",
+                        " - primitive type");
     }
 
     interface ObjectLikeInterface {
         boolean equals(Object o);
+
         String toString();
+
         int hashCode();
     }
 
     @Test
-    public void shouldNotMockObjectMethodsOnInterface() throws Exception {
+    public void shouldNotMockObjectMethodsOnInterfaceVerifyNoInteractions() {
         ObjectLikeInterface inter = mock(ObjectLikeInterface.class);
 
-        inter.equals(null);
-        inter.toString();
-        inter.hashCode();
+        Object ignored = inter.equals(null);
+        ignored = inter.toString();
+        ignored = inter.hashCode();
 
-        verifyZeroInteractions(inter);
+        verifyNoInteractions(inter);
     }
 
     @Test
-    public void shouldNotMockObjectMethodsOnClass() throws Exception {
+    public void shouldNotMockObjectMethodsOnClassVerifyNoInteractions() {
         Object clazz = mock(ObjectLikeInterface.class);
 
-        clazz.equals(null);
-        clazz.toString();
-        clazz.hashCode();
+        Object ignored = clazz.equals(null);
+        ignored = clazz.toString();
+        ignored = clazz.hashCode();
 
-        verifyZeroInteractions(clazz);
+        verifyNoInteractions(clazz);
     }
 }
diff --git a/src/test/java/org/mockitousage/misuse/RestrictedObjectMethodsTest.java b/src/test/java/org/mockitousage/misuse/RestrictedObjectMethodsTest.java
index da5df23..0132340 100644
--- a/src/test/java/org/mockitousage/misuse/RestrictedObjectMethodsTest.java
+++ b/src/test/java/org/mockitousage/misuse/RestrictedObjectMethodsTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.misuse;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+
+import java.util.List;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -12,13 +18,6 @@ import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verify;
-
 public class RestrictedObjectMethodsTest extends TestBase {
 
     @Mock List<?> mock;
@@ -40,24 +39,24 @@ public class RestrictedObjectMethodsTest extends TestBase {
 
     @Test
     public void shouldBeSilentWhenVerifyHashCode() {
-        //because it leads to really weird behavior sometimes
-        //it's because cglib & my code can occasionelly call those methods
+        // because it leads to really weird behavior sometimes
+        // it's because cglib & my code can occasionelly call those methods
         // and when user has verification started at that time there will be a mess
         verify(mock).hashCode();
     }
 
     @Test
     public void shouldBeSilentWhenVerifyEquals() {
-        //because it leads to really weird behavior sometimes
-        //it's because cglib & my code can occasionelly call those methods
+        // because it leads to really weird behavior sometimes
+        // it's because cglib & my code can occasionelly call those methods
         // and when user has verification started at that time there will be a mess
         verify(mock).equals(null);
     }
 
     @Test
     public void shouldBeSilentWhenVerifyEqualsInOrder() {
-        //because it leads to really weird behavior sometimes
-        //it's because cglib & my code can occasionelly call those methods
+        // because it leads to really weird behavior sometimes
+        // it's because cglib & my code can occasionelly call those methods
         // and when user has verification started at that time there will be a mess
         InOrder inOrder = inOrder(mock);
         inOrder.verify(mock).equals(null);
diff --git a/src/test/java/org/mockitousage/misuse/SpyStubbingMisuseTest.java b/src/test/java/org/mockitousage/misuse/SpyStubbingMisuseTest.java
index a36c66a..9f0acfe 100644
--- a/src/test/java/org/mockitousage/misuse/SpyStubbingMisuseTest.java
+++ b/src/test/java/org/mockitousage/misuse/SpyStubbingMisuseTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockitousage.misuse;
 
-import org.junit.Test;
-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.*;
 
+import org.junit.Test;
+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
+
 public class SpyStubbingMisuseTest {
 
     @Test
@@ -23,11 +23,14 @@ public class SpyStubbingMisuseTest {
             when(out.produce()).thenReturn(mpoo);
             fail();
         } catch (WrongTypeOfReturnValue e) {
-            assertThat(e.getMessage()).contains("spy").contains("syntax").contains("doReturn|Throw");
+            assertThat(e.getMessage())
+                    .contains("spy")
+                    .contains("syntax")
+                    .contains("doReturn|Throw");
         }
     }
 
-    public class Sample { }
+    public class Sample {}
 
     public class Strategy {
         Sample getSample() {
@@ -37,6 +40,7 @@ public class SpyStubbingMisuseTest {
 
     public class Sampler {
         Sample sample;
+
         Sampler(Strategy f) {
             sample = f.getSample();
         }
@@ -44,9 +48,11 @@ public class SpyStubbingMisuseTest {
 
     public class Producer {
         Strategy strategy;
+
         Producer(Strategy f) {
             strategy = f;
         }
+
         Sampler produce() {
             return new Sampler(strategy);
         }
diff --git a/src/test/java/org/mockitousage/packageprotected/MockingPackageProtectedTest.java b/src/test/java/org/mockitousage/packageprotected/MockingPackageProtectedTest.java
index b740508..b72ce39 100644
--- a/src/test/java/org/mockitousage/packageprotected/MockingPackageProtectedTest.java
+++ b/src/test/java/org/mockitousage/packageprotected/MockingPackageProtectedTest.java
@@ -2,14 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.packageprotected;
 
+import static org.mockito.Mockito.mock;
+
 import org.junit.Test;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.mock;
-
 public class MockingPackageProtectedTest extends TestBase {
 
     static class Foo {}
diff --git a/src/test/java/org/mockitousage/packageprotected/PackageProtected.java b/src/test/java/org/mockitousage/packageprotected/PackageProtected.java
index 0c1ed91..627b0de 100644
--- a/src/test/java/org/mockitousage/packageprotected/PackageProtected.java
+++ b/src/test/java/org/mockitousage/packageprotected/PackageProtected.java
@@ -4,6 +4,4 @@
  */
 package org.mockitousage.packageprotected;
 
-class PackageProtected {
-
-}
+class PackageProtected {}
diff --git a/src/test/java/org/mockitousage/performance/LoadsOfMocksTest.java b/src/test/java/org/mockitousage/performance/LoadsOfMocksTest.java
index 1b9c24d..c03aa70 100644
--- a/src/test/java/org/mockitousage/performance/LoadsOfMocksTest.java
+++ b/src/test/java/org/mockitousage/performance/LoadsOfMocksTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.performance;
 
-import org.junit.Ignore;
-import org.junit.Test;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
 
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 public class LoadsOfMocksTest extends TestBase {
 
diff --git a/src/test/java/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java b/src/test/java/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java
index 4f02fb0..60a08f2 100644
--- a/src/test/java/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java
+++ b/src/test/java/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java
@@ -4,11 +4,11 @@
  */
 package org.mockitousage.performance;
 
+import static org.mockito.Mockito.*;
+
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.mockito.Mockito.*;
-
 public class StubOnlyAvoidMemoryConsumptionTest {
 
     @Test
@@ -17,7 +17,7 @@ public class StubOnlyAvoidMemoryConsumptionTest {
         when(obj.toString()).thenReturn("asdf");
 
         for (int i = 0; i < 1000000; i++) {
-            obj.toString();
+            String ignored = obj.toString();
         }
     }
 
@@ -28,7 +28,7 @@ public class StubOnlyAvoidMemoryConsumptionTest {
         when(obj.toString()).thenReturn("asdf");
 
         for (int i = 0; i < 1000000; i++) {
-            obj.toString();
+            String ignored = obj.toString();
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/plugins/MockitoPluginsTest.java b/src/test/java/org/mockitousage/plugins/MockitoPluginsTest.java
index a1a3500..dd5f390 100644
--- a/src/test/java/org/mockitousage/plugins/MockitoPluginsTest.java
+++ b/src/test/java/org/mockitousage/plugins/MockitoPluginsTest.java
@@ -4,21 +4,19 @@
  */
 package org.mockitousage.plugins;
 
+import static org.junit.Assert.assertNotNull;
+
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.mockito.internal.creation.instance.Instantiator;
 import org.mockito.plugins.AnnotationEngine;
-import org.mockito.plugins.InstantiatorProvider;
 import org.mockito.plugins.InstantiatorProvider2;
 import org.mockito.plugins.MockMaker;
+import org.mockito.plugins.MockitoLogger;
 import org.mockito.plugins.MockitoPlugins;
 import org.mockito.plugins.PluginSwitch;
 import org.mockito.plugins.StackTraceCleanerProvider;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Mockito.withSettings;
-
 public class MockitoPluginsTest extends TestBase {
 
     private final MockitoPlugins plugins = Mockito.framework().getPlugins();
@@ -29,17 +27,8 @@ public class MockitoPluginsTest extends TestBase {
         assertNotNull(plugins.getDefaultPlugin(MockMaker.class));
         assertNotNull(plugins.getDefaultPlugin(StackTraceCleanerProvider.class));
         assertNotNull(plugins.getDefaultPlugin(PluginSwitch.class));
-        assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider.class));
         assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider2.class));
         assertNotNull(plugins.getDefaultPlugin(AnnotationEngine.class));
-    }
-
-    @SuppressWarnings("deprecation")
-    @Test
-    public void instantiator_provider_backwards_compatibility() {
-        InstantiatorProvider provider = plugins.getDefaultPlugin(InstantiatorProvider.class);
-        Instantiator instantiator = provider.getInstantiator(withSettings().build(MockitoPluginsTest.class));
-
-        assertNotNull(instantiator.newInstance(MockitoPluginsTest.class));
+        assertNotNull(plugins.getDefaultPlugin(MockitoLogger.class));
     }
 }
diff --git a/src/test/java/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java b/src/test/java/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java
index a4805c4..849a16a 100644
--- a/src/test/java/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java
+++ b/src/test/java/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java
@@ -2,18 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.puzzlers;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockitoutil.Conditions.bridgeMethod;
 
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 /**
  * Bridge method is generated by compiler when erasure in parent class is
  * different. When is different then it means that in runtime we will have
@@ -32,7 +31,7 @@ public class BridgeMethodPuzzleTest extends TestBase {
 
     private class Sub extends Super<String> {
         @Override
-        public String say(String t)  {
+        public String say(String t) {
             return "Dummy says: " + t;
         }
     }
@@ -49,8 +48,8 @@ public class BridgeMethodPuzzleTest extends TestBase {
 
     @Test
     public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {
-        //Super has following erasure: say(Object) which differs from Dummy.say(String)
-        //mock has to detect it and do the super.say()
+        // Super has following erasure: say(Object) which differs from Dummy.say(String)
+        // mock has to detect it and do the super.say()
         Sub s = mock(Sub.class);
         Super<String> s_down = s;
         s_down.say("Hello");
@@ -60,8 +59,8 @@ public class BridgeMethodPuzzleTest extends TestBase {
 
     @Test
     public void shouldVerifyCorrectlyWhenBridgeMethodVerified() throws Exception {
-        //Super has following erasure: say(Object) which differs from Dummy.say(String)
-        //mock has to detect it and do the super.say()
+        // Super has following erasure: say(Object) which differs from Dummy.say(String)
+        // mock has to detect it and do the super.say()
         Sub s = mock(Sub.class);
         Super<String> s_down = s;
         s.say("Hello");
diff --git a/src/test/java/org/mockitousage/puzzlers/OverloadingPuzzleTest.java b/src/test/java/org/mockitousage/puzzlers/OverloadingPuzzleTest.java
index 03441b9..981dee5 100644
--- a/src/test/java/org/mockitousage/puzzlers/OverloadingPuzzleTest.java
+++ b/src/test/java/org/mockitousage/puzzlers/OverloadingPuzzleTest.java
@@ -4,14 +4,14 @@
  */
 package org.mockitousage.puzzlers;
 
-import org.junit.Test;
-import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
+import org.junit.Test;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
+import org.mockitoutil.TestBase;
+
 public class OverloadingPuzzleTest extends TestBase {
 
     private Super mock;
@@ -40,6 +40,7 @@ public class OverloadingPuzzleTest extends TestBase {
         try {
             verify(sub).say("Hello");
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java b/src/test/java/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java
index 3c6601b..e79895b 100644
--- a/src/test/java/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java
+++ b/src/test/java/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.serialization;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.ByteArrayInputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+import net.bytebuddy.ClassFileVersion;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
@@ -13,12 +20,6 @@ import org.mockitousage.IMethods;
 import org.mockitoutil.SimplePerRealmReloadingClassLoader;
 import org.mockitoutil.SimpleSerializationUtil;
 
-import java.io.ByteArrayInputStream;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.Callable;
-
-
 public class AcrossClassLoaderSerializationTest {
 
     public IMethods mock;
@@ -29,45 +30,53 @@ public class AcrossClassLoaderSerializationTest {
     }
 
     @Test
-    public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another() throws Exception {
+    public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another()
+            throws Exception {
+        // No longer supported starting with JDK 16+
+        if (!ClassFileVersion.ofThisVm().isAtMost(ClassFileVersion.JAVA_V16)) {
+            return;
+        }
         byte[] bytes = create_mock_and_serialize_it_in_class_loader_A();
 
         Object the_deserialized_mock = read_stream_and_deserialize_it_in_class_loader_B(bytes);
+        assertThat(the_deserialized_mock.getClass().getName())
+                .startsWith("org.mockito.codegen.AClassToBeMockedInThisTestOnlyAndInCallablesOnly");
     }
 
     private Object read_stream_and_deserialize_it_in_class_loader_B(byte[] bytes) throws Exception {
-        return new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())
+        return new SimplePerRealmReloadingClassLoader(
+                        this.getClass().getClassLoader(), isolating_test_classes())
                 .doInRealm(
                         "org.mockitousage.serialization.AcrossClassLoaderSerializationTest$ReadStreamAndDeserializeIt",
-                        new Class<?>[]{ byte[].class },
-                        new Object[]{ bytes }
-                );
+                        new Class<?>[] {byte[].class},
+                        new Object[] {bytes});
     }
 
     private byte[] create_mock_and_serialize_it_in_class_loader_A() throws Exception {
-        return (byte[]) new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())
-                .doInRealm("org.mockitousage.serialization.AcrossClassLoaderSerializationTest$CreateMockAndSerializeIt");
+        return (byte[])
+                new SimplePerRealmReloadingClassLoader(
+                                this.getClass().getClassLoader(), isolating_test_classes())
+                        .doInRealm(
+                                "org.mockitousage.serialization.AcrossClassLoaderSerializationTest$CreateMockAndSerializeIt");
     }
 
-
     private SimplePerRealmReloadingClassLoader.ReloadClassPredicate isolating_test_classes() {
         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {
             public boolean acceptReloadOf(String qualifiedName) {
                 return qualifiedName.contains("org.mockitousage")
-                        || qualifiedName.contains("org.mockitoutil")
-                        ;
+                        || qualifiedName.contains("org.mockitoutil");
             }
         };
     }
 
-
     // see create_mock_and_serialize_it_in_class_loader_A
     public static class CreateMockAndSerializeIt implements Callable<byte[]> {
         public byte[] call() throws Exception {
-            AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito.mock(
-                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class,
-                    Mockito.withSettings().serializable(SerializableMode.ACROSS_CLASSLOADERS)
-            );
+            AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock =
+                    Mockito.mock(
+                            AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class,
+                            Mockito.withSettings()
+                                    .serializable(SerializableMode.ACROSS_CLASSLOADERS));
             // use MethodProxy before
             mock.returningSomething();
 
@@ -86,14 +95,13 @@ public class AcrossClassLoaderSerializationTest {
         public Object call() throws Exception {
             ByteArrayInputStream to_unserialize = new ByteArrayInputStream(bytes);
             return SimpleSerializationUtil.deserializeMock(
-                    to_unserialize,
-                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class
-            );
+                    to_unserialize, AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class);
         }
     }
 
-
     public static class AClassToBeMockedInThisTestOnlyAndInCallablesOnly {
-        List returningSomething() { return Collections.emptyList(); }
+        List returningSomething() {
+            return Collections.emptyList();
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
index 3294614..856e89b 100644
--- a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
+++ b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
@@ -4,22 +4,28 @@
  */
 package org.mockitousage.serialization;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.*;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
 
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.List;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
+import org.junit.Test;
 
 public class DeepStubsSerializableTest {
 
     @Test
     public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {
         // given
-        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
+        SampleClass sampleClass =
+                mock(
+                        SampleClass.class,
+                        withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
         when(sampleClass.getSample().isFalse()).thenReturn(true);
         when(sampleClass.getSample().number()).thenReturn(999);
 
@@ -32,31 +38,42 @@ public class DeepStubsSerializableTest {
     }
 
     @Test
-    public void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {
+    public void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs()
+            throws Exception {
         // given
-        ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
+        ListContainer deep_stubbed =
+                mock(
+                        ListContainer.class,
+                        withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
         when(deep_stubbed.iterator().next().add("yes")).thenReturn(true);
 
         // when
         ListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);
 
         // then
-        assertThat(deserialized_deep_stub.iterator().next().add("not stubbed but mock already previously resolved")).isEqualTo(false);
+        assertThat(
+                        deserialized_deep_stub
+                                .iterator()
+                                .next()
+                                .add("not stubbed but mock already previously resolved"))
+                .isEqualTo(false);
         assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);
     }
 
-    @Test(expected = ClassCastException.class)
-    public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {
+    @Test
+    public void
+            should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics()
+                    throws Exception {
         // given
-        ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
+        ListContainer deep_stubbed =
+                mock(
+                        ListContainer.class,
+                        withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
         when(deep_stubbed.iterator().hasNext()).thenReturn(true);
 
         ListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);
 
-        // when stubbing on a deserialized mock
-        when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");
-
-        // then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException
+        assertThat(deserialized_deep_stub.iterator().next()).isNull();
     }
 
     static class SampleClass implements Serializable {
@@ -99,8 +116,7 @@ public class DeepStubsSerializableTest {
                     return e;
                 }
 
-                public void remove() {
-                }
+                public void remove() {}
             };
         }
     }
diff --git a/src/test/java/org/mockitousage/serialization/ParallelSerializationTest.java b/src/test/java/org/mockitousage/serialization/ParallelSerializationTest.java
index 92faeed..e2caf7c 100644
--- a/src/test/java/org/mockitousage/serialization/ParallelSerializationTest.java
+++ b/src/test/java/org/mockitousage/serialization/ParallelSerializationTest.java
@@ -2,12 +2,10 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.serialization;
 
-import org.junit.Test;
-import org.mockitousage.IMethods;
-import org.mockitoutil.SimpleSerializationUtil;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
 
 import java.nio.charset.CharacterCodingException;
 import java.util.ArrayList;
@@ -15,46 +13,55 @@ import java.util.List;
 import java.util.Random;
 import java.util.concurrent.*;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.withSettings;
+import org.junit.Test;
+import org.mockitousage.IMethods;
+import org.mockitoutil.SimpleSerializationUtil;
 
 public class ParallelSerializationTest {
 
     @Test
-    public void single_mock_being_serialized_in_different_classloaders_by_multiple_threads() throws ExecutionException, InterruptedException {
+    public void single_mock_being_serialized_in_different_classloaders_by_multiple_threads()
+            throws ExecutionException, InterruptedException {
         // given
         int iterations = 2;
         int threadingFactor = 200;
         final ExecutorService executorService = Executors.newFixedThreadPool(threadingFactor);
-        final IMethods iMethods_that_store_invocations = mock(IMethods.class, withSettings().serializable());
+        final IMethods iMethods_that_store_invocations =
+                mock(IMethods.class, withSettings().serializable());
 
         // when
         for (int i = 0; i <= iterations; i++) {
             List<Future<?>> futures = new ArrayList<Future<?>>(threadingFactor);
-            final CyclicBarrier barrier_that_will_wait_until_threads_are_ready = new CyclicBarrier(threadingFactor);
+            final CyclicBarrier barrier_that_will_wait_until_threads_are_ready =
+                    new CyclicBarrier(threadingFactor);
 
             // prepare all threads by submitting a callable
             //  - that will serialize the mock a 'threadingFactor' times
             //  - that will use the mock a 'threadingFactor' times
             for (int j = 0; j < threadingFactor; j++) {
                 // submit a callable that will serialize the mock 'iMethods'
-                futures.add(executorService.submit(new Callable<Object>() {
-                    public Object call() throws Exception {
-                        barrier_that_will_wait_until_threads_are_ready.await();
+                futures.add(
+                        executorService.submit(
+                                new Callable<Object>() {
+                                    public Object call() throws Exception {
+                                        barrier_that_will_wait_until_threads_are_ready.await();
 
-                        randomCallOn(iMethods_that_store_invocations);
+                                        randomCallOn(iMethods_that_store_invocations);
 
-                        return SimpleSerializationUtil.serializeMock(iMethods_that_store_invocations).toByteArray();
-                    }
-                }));
+                                        return SimpleSerializationUtil.serializeMock(
+                                                        iMethods_that_store_invocations)
+                                                .toByteArray();
+                                    }
+                                }));
 
                 // submit a callable that will only use the mock 'iMethods'
-                executorService.submit(new Callable<Object>() {
-                    public Object call() throws Exception {
-                        barrier_that_will_wait_until_threads_are_ready.await();
-                        return iMethods_that_store_invocations.longObjectReturningMethod();
-                    }
-                });
+                executorService.submit(
+                        new Callable<Object>() {
+                            public Object call() throws Exception {
+                                barrier_that_will_wait_until_threads_are_ready.await();
+                                return iMethods_that_store_invocations.longObjectReturningMethod();
+                            }
+                        });
             }
 
             // ensure we are getting the futures
@@ -67,16 +74,36 @@ public class ParallelSerializationTest {
     private void randomCallOn(IMethods iMethods) throws CharacterCodingException {
         int random = new Random().nextInt(10);
         switch (random) {
-            case 0 : iMethods.arrayReturningMethod(); break;
-            case 1 : iMethods.longObjectReturningMethod(); break;
-            case 2 : iMethods.linkedListReturningMethod(); break;
-            case 3 : iMethods.iMethodsReturningMethod(); break;
-            case 4 : iMethods.canThrowException(); break;
-            case 5 : iMethods.differentMethod(); break;
-            case 6 : iMethods.voidMethod(); break;
-            case 7 : iMethods.varargsString(1, ""); break;
-            case 8 : iMethods.forMap(null); break;
-            case 9 : iMethods.throwsNothing(false); break;
+            case 0:
+                iMethods.arrayReturningMethod();
+                break;
+            case 1:
+                iMethods.longObjectReturningMethod();
+                break;
+            case 2:
+                iMethods.linkedListReturningMethod();
+                break;
+            case 3:
+                iMethods.iMethodsReturningMethod();
+                break;
+            case 4:
+                iMethods.canThrowException();
+                break;
+            case 5:
+                iMethods.differentMethod();
+                break;
+            case 6:
+                iMethods.voidMethod();
+                break;
+            case 7:
+                iMethods.varargsString(1, "");
+                break;
+            case 8:
+                iMethods.forMap(null);
+                break;
+            case 9:
+                iMethods.throwsNothing(false);
+                break;
             default:
         }
     }
diff --git a/src/test/java/org/mockitousage/serialization/StrictStubsSerializableTest.java b/src/test/java/org/mockitousage/serialization/StrictStubsSerializableTest.java
new file mode 100644
index 0000000..456cde2
--- /dev/null
+++ b/src/test/java/org/mockitousage/serialization/StrictStubsSerializableTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.serialization;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.*;
+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
+
+import java.io.Serializable;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+@RunWith(MockitoJUnitRunner.StrictStubs.class)
+public class StrictStubsSerializableTest {
+
+    @Mock(serializable = true)
+    private SampleClass sampleClass;
+
+    @Test
+    public void should_serialize_and_deserialize_mock_created_with_serializable_and_strict_stubs()
+            throws Exception {
+        // given
+        when(sampleClass.isFalse()).thenReturn(true);
+
+        // when
+        SampleClass deserializedSample = serializeAndBack(sampleClass);
+        // to satisfy strict stubbing
+        deserializedSample.isFalse();
+        verify(deserializedSample).isFalse();
+        verify(sampleClass, never()).isFalse();
+
+        // then
+        assertThat(deserializedSample.isFalse()).isEqualTo(true);
+        assertThat(sampleClass.isFalse()).isEqualTo(true);
+    }
+
+    static class SampleClass implements Serializable {
+
+        boolean isFalse() {
+            return false;
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/session/MockitoSessionTest.java b/src/test/java/org/mockitousage/session/MockitoSessionTest.java
index 5271f92..958e569 100644
--- a/src/test/java/org/mockitousage/session/MockitoSessionTest.java
+++ b/src/test/java/org/mockitousage/session/MockitoSessionTest.java
@@ -4,6 +4,14 @@
  */
 package org.mockitousage.session;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mockingDetails;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,110 +28,115 @@ import org.mockitousage.IMethods;
 import org.mockitoutil.JUnitResultAssert;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mockingDetails;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 public class MockitoSessionTest extends TestBase {
 
     private JUnitCore junit = new JUnitCore();
 
-    @Test public void session_without_any_configuration() {
-        //when
+    @Test
+    public void session_without_any_configuration() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).succeeds(1);
     }
 
-    @Test public void session_without_init_mocks_configured() {
-        //when
+    @Test
+    public void session_without_init_mocks_configured() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).succeeds(1);
     }
 
-    @Test public void session_without_strictness_configured() {
-        //when
+    @Test
+    public void session_without_strictness_configured() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).succeeds(1);
     }
 
-    @Test public void session_with_incorrect_mockito_usage() {
-        //when
+    @Test
+    public void session_with_incorrect_mockito_usage() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
     }
 
-    @Test public void reports_other_failure_and_incorrect_mockito_usage() {
-        //when
-        Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
+    @Test
+    public void reports_other_failure_and_incorrect_mockito_usage() {
+        // when
+        Result result =
+                junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result)
                 .failsExactly(AssertionError.class, UnfinishedStubbingException.class);
     }
 
-    @Test public void allows_initializing_mocks_manually() {
-        //when
+    @Test
+    public void allows_initializing_mocks_manually() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithManuallyInitializedMock.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).succeeds(1);
     }
 
-    @Test public void allows_updating_strictness() {
-        //when
+    @Test
+    public void allows_updating_strictness() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithUpdatedStrictness.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).succeeds(1);
     }
 
-    @Test public void allows_overriding_failure() {
-        //when
+    @Test
+    public void allows_overriding_failure() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithOverriddenFailure.class);
 
-        //expect
+        // expect
         JUnitResultAssert.assertThat(result).isSuccessful();
 
-        //in order to demonstrate feature, we intentionally misuse Mockito and need to clean up state
+        // in order to demonstrate feature, we intentionally misuse Mockito and need to clean up
+        // state
         resetState();
     }
 
-    @Test public void cleans_up_state_when_init_fails() {
-        //when
+    @Test
+    public void cleans_up_state_when_init_fails() {
+        // when
         Result result = junit.run(MockitoSessionTest.SessionWithInitMocksFailure.class);
 
-        //expect that both failures are the same, indicating correct listener cleanup
-        //incorrect cleanup causes 1 failure to be InjectMocksException
-        //  but the next test method would have failed with unuseful error that session was not cleaned up
-        JUnitResultAssert.assertThat(result)
-            .fails(2, InjectMocksException.class);
+        // expect that both failures are the same, indicating correct listener cleanup
+        // incorrect cleanup causes 1 failure to be InjectMocksException
+        //  but the next test method would have failed with unuseful error that session was not
+        // cleaned up
+        JUnitResultAssert.assertThat(result).fails(2, InjectMocksException.class);
     }
 
     public static class SessionWithoutAnyConfiguration {
 
         @Mock IMethods mock;
 
-        //session without initMocks is not currently supported
+        // session without initMocks is not currently supported
         MockitoSession mockito = Mockito.mockitoSession().startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void some_test() {
-            assertNull(mock); //initMocks() was not used when configuring session
+        @Test
+        public void some_test() {
+            assertNull(mock); // initMocks() was not used when configuring session
         }
     }
 
@@ -131,14 +144,17 @@ public class MockitoSessionTest extends TestBase {
 
         @Mock IMethods mock;
 
-        MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
+        MockitoSession mockito =
+                Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void some_test() {
-            assertNull(mock); //initMocks() was not used when configuring session
+        @Test
+        public void some_test() {
+            assertNull(mock); // initMocks() was not used when configuring session
         }
     }
 
@@ -147,11 +163,13 @@ public class MockitoSessionTest extends TestBase {
 
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void some_test() {
+        @Test
+        public void some_test() {
             assertNotNull(mock);
         }
     }
@@ -161,12 +179,14 @@ public class MockitoSessionTest extends TestBase {
 
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
         @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-        @Test public void unfinished_stubbing() {
+        @Test
+        public void unfinished_stubbing() {
             when(mock.simpleMethod());
         }
     }
@@ -176,12 +196,14 @@ public class MockitoSessionTest extends TestBase {
 
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
         @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-        @Test public void unfinished_stubbing_with_other_failure() {
+        @Test
+        public void unfinished_stubbing_with_other_failure() {
             when(mock.simpleMethod());
             assertTrue(false);
         }
@@ -193,31 +215,43 @@ public class MockitoSessionTest extends TestBase {
 
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void manual_mock_preserves_its_settings() {
-            assertEquals("mock", mockingDetails(mock).getMockCreationSettings().getMockName().toString());
-            assertEquals("manual mock", mockingDetails(mock2).getMockCreationSettings().getMockName().toString());
+        @Test
+        public void manual_mock_preserves_its_settings() {
+            assertEquals(
+                    "mock",
+                    mockingDetails(mock).getMockCreationSettings().getMockName().toString());
+            assertEquals(
+                    "manual mock",
+                    mockingDetails(mock2).getMockCreationSettings().getMockName().toString());
         }
     }
 
     public static class SessionWithUpdatedStrictness {
         @Mock IMethods mock;
-        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
-
-        @After public void after() {
+        MockitoSession mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
+
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void manual_mock_preserves_its_settings() {
+        @Test
+        public void manual_mock_preserves_its_settings() {
             when(mock.simpleMethod(1)).thenReturn("foo");
 
-            //when
+            // when
             mockito.setStrictness(Strictness.LENIENT);
 
-            //then no exception is thrown, even though the arg is different
+            // then no exception is thrown, even though the arg is different
             mock.simpleMethod(2);
         }
     }
@@ -226,12 +260,14 @@ public class MockitoSessionTest extends TestBase {
         @Mock IMethods mock;
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
 
-        @After public void after() {
+        @After
+        public void after() {
             mockito.finishMocking(new RuntimeException("Boo!"));
         }
 
         @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-        @Test public void invalid_mockito_usage() {
+        @Test
+        public void invalid_mockito_usage() {
             verify(mock);
         }
     }
@@ -245,20 +281,23 @@ public class MockitoSessionTest extends TestBase {
             mockito = Mockito.mockitoSession().initMocks(this).startMocking();
         }
 
-        @After public void after() {
+        @After
+        public void after() {
             if (mockito != null) {
-                //so that we reduce amount of exceptions for easier assertions
-                //otherwise we would get an NPE here
+                // so that we reduce amount of exceptions for easier assertions
+                // otherwise we would get an NPE here
                 mockito.finishMocking();
             }
         }
 
-        @Test public void test1() {
-            //should fail the same way
+        @Test
+        public void test1() {
+            // should fail the same way
         }
 
-        @Test public void test2() {
-            //should fail the same way
+        @Test
+        public void test2() {
+            // should fail the same way
         }
 
         static class ConstructorFail {
diff --git a/src/test/java/org/mockitousage/spies/PartialMockingWithSpiesTest.java b/src/test/java/org/mockitousage/spies/PartialMockingWithSpiesTest.java
index b5ea754..bf616f8 100644
--- a/src/test/java/org/mockitousage/spies/PartialMockingWithSpiesTest.java
+++ b/src/test/java/org/mockitousage/spies/PartialMockingWithSpiesTest.java
@@ -2,14 +2,8 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.spies;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockitoutil.TestBase;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.doThrow;
@@ -18,6 +12,11 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 import static org.mockitoutil.Conditions.methodsInStackTrace;
 
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
 @SuppressWarnings("unchecked")
 public class PartialMockingWithSpiesTest extends TestBase {
 
@@ -28,6 +27,7 @@ public class PartialMockingWithSpiesTest extends TestBase {
 
     class InheritMe {
         private String inherited = "100$";
+
         protected String getInherited() {
             return inherited;
         }
@@ -90,13 +90,14 @@ public class PartialMockingWithSpiesTest extends TestBase {
     public void shouldAllowStubbingWithThrowablesMethodsThatDelegateToOtherMethods() {
         // when
         doThrow(new RuntimeException("appetite for destruction"))
-            .when(spy).getNameButDelegateToMethodThatThrows();
+                .when(spy)
+                .getNameButDelegateToMethodThatThrows();
 
         // then
         try {
             spy.getNameButDelegateToMethodThatThrows();
             fail();
-        } catch(Exception e) {
+        } catch (Exception e) {
             assertEquals("appetite for destruction", e.getMessage());
         }
     }
@@ -109,15 +110,16 @@ public class PartialMockingWithSpiesTest extends TestBase {
             fail();
         } catch (Throwable t) {
             // then
-            Assertions.assertThat(t).has(methodsInStackTrace(
-                    "throwSomeException",
-                    "getNameButDelegateToMethodThatThrows",
-                    "shouldStackTraceGetFilteredOnUserExceptions"
-                    ));
+            Assertions.assertThat(t)
+                    .has(
+                            methodsInStackTrace(
+                                    "throwSomeException",
+                                    "getNameButDelegateToMethodThatThrows",
+                                    "shouldStackTraceGetFilteredOnUserExceptions"));
         }
     }
 
-//    @Test //manual verification
+    //    @Test //manual verification
     public void verifyTheStackTrace() {
         spy.getNameButDelegateToMethodThatThrows();
     }
diff --git a/src/test/java/org/mockitousage/spies/SpiesWithRealEqualsAndInOrderTest.java b/src/test/java/org/mockitousage/spies/SpiesWithRealEqualsAndInOrderTest.java
new file mode 100644
index 0000000..e2dabe9
--- /dev/null
+++ b/src/test/java/org/mockitousage/spies/SpiesWithRealEqualsAndInOrderTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.spies;
+
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.inOrder;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+
+// https://github.com/mockito/mockito/issues/2394
+public class SpiesWithRealEqualsAndInOrderTest {
+
+    @Test
+    public void should_be_able_to_handle_in_order_on_spies_with_equals() {
+        ToBeSpied mock1 = spy(new ToBeSpied());
+        ToBeSpied mock2 = spy(new ToBeSpied());
+        mock1.someMethod();
+        InOrder order = inOrder(mock1, mock2);
+        order.verify(mock1).someMethod();
+        order.verifyNoMoreInteractions();
+    }
+
+    static class ToBeSpied {
+        void someMethod() {}
+    }
+}
diff --git a/src/test/java/org/mockitousage/spies/SpyingOnInterfacesTest.java b/src/test/java/org/mockitousage/spies/SpyingOnInterfacesTest.java
index 6bebbdf..b6fe514 100644
--- a/src/test/java/org/mockitousage/spies/SpyingOnInterfacesTest.java
+++ b/src/test/java/org/mockitousage/spies/SpyingOnInterfacesTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.spies;
 
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.List;
+
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.description.modifier.Visibility;
@@ -17,15 +25,6 @@ import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings({"unchecked"})
 public class SpyingOnInterfacesTest extends TestBase {
 
@@ -33,9 +32,9 @@ public class SpyingOnInterfacesTest extends TestBase {
     public void shouldFailFastWhenCallingRealMethodOnInterface() throws Exception {
         List<?> list = mock(List.class);
         try {
-            //when
+            // when
             when(list.get(0)).thenCallRealMethod();
-            //then
+            // then
             fail();
         } catch (MockitoException e) {
         }
@@ -43,19 +42,19 @@ public class SpyingOnInterfacesTest extends TestBase {
 
     @Test
     public void shouldFailInRuntimeWhenCallingRealMethodOnInterface() throws Exception {
-        //given
+        // given
         List<Object> list = mock(List.class);
-        when(list.get(0)).thenAnswer(
-                new Answer<Object>() {
-                    public Object answer(InvocationOnMock invocation) throws Throwable {
-                        return invocation.callRealMethod();
-                    }
-                }
-        );
+        when(list.get(0))
+                .thenAnswer(
+                        new Answer<Object>() {
+                            public Object answer(InvocationOnMock invocation) throws Throwable {
+                                return invocation.callRealMethod();
+                            }
+                        });
         try {
-            //when
+            // when
             list.get(0);
-            //then
+            // then
             fail();
         } catch (MockitoException e) {
         }
@@ -63,48 +62,55 @@ public class SpyingOnInterfacesTest extends TestBase {
 
     @Test
     public void shouldAllowDelegatingToDefaultMethod() throws Exception {
-        assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
-
-        Class<?> type = new ByteBuddy()
-                .makeInterface()
-                .defineMethod("foo", String.class, Visibility.PUBLIC)
-                .intercept(FixedValue.value("bar"))
-                .make()
-                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
-                .getLoaded();
+        assumeTrue(
+                "Test can only be executed on Java 8 capable VMs",
+                ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
+
+        Class<?> type =
+                new ByteBuddy()
+                        .makeInterface()
+                        .defineMethod("foo", String.class, Visibility.PUBLIC)
+                        .intercept(FixedValue.value("bar"))
+                        .make()
+                        .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                        .getLoaded();
 
         Object object = mock(type);
 
-        //when
+        // when
         when(type.getMethod("foo").invoke(object)).thenCallRealMethod();
-        //then
+        // then
         Assertions.assertThat(type.getMethod("foo").invoke(object)).isEqualTo((Object) "bar");
         type.getMethod("foo").invoke(verify(object));
     }
 
     @Test
     public void shouldAllowSpyingOnDefaultMethod() throws Exception {
-        assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
-
-        Class<?> iFace = new ByteBuddy()
-                .makeInterface()
-                .defineMethod("foo", String.class, Visibility.PUBLIC)
-                .intercept(FixedValue.value("bar"))
-                .make()
-                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
-                .getLoaded();
-
-        Class<?> impl = new ByteBuddy()
-                .subclass(iFace)
-                .make()
-                .load(iFace.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
-                .getLoaded();
-
-        Object object = spy(impl.newInstance());
-
-        //when
+        assumeTrue(
+                "Test can only be executed on Java 8 capable VMs",
+                ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
+
+        Class<?> iFace =
+                new ByteBuddy()
+                        .makeInterface()
+                        .defineMethod("foo", String.class, Visibility.PUBLIC)
+                        .intercept(FixedValue.value("bar"))
+                        .make()
+                        .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                        .getLoaded();
+
+        Class<?> impl =
+                new ByteBuddy()
+                        .subclass(iFace)
+                        .make()
+                        .load(iFace.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                        .getLoaded();
+
+        Object object = spy(impl.getConstructor().newInstance());
+
+        // when
         Assertions.assertThat(impl.getMethod("foo").invoke(object)).isEqualTo((Object) "bar");
-        //then
+        // then
         impl.getMethod("foo").invoke(verify(object));
     }
 }
diff --git a/src/test/java/org/mockitousage/spies/SpyingOnRealObjectsTest.java b/src/test/java/org/mockitousage/spies/SpyingOnRealObjectsTest.java
index 8603ca0..30d3784 100644
--- a/src/test/java/org/mockitousage/spies/SpyingOnRealObjectsTest.java
+++ b/src/test/java/org/mockitousage/spies/SpyingOnRealObjectsTest.java
@@ -2,27 +2,26 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.spies;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.*;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.*;
+
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockitoutil.TestBase;
 
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.junit.Assert.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.*;
-
 public class SpyingOnRealObjectsTest extends TestBase {
 
     List<String> list = new LinkedList<String>();
@@ -49,9 +48,7 @@ public class SpyingOnRealObjectsTest extends TestBase {
     @Test
     public void shouldStub() {
         spy.add("one");
-        when(spy.get(0))
-            .thenReturn("1")
-            .thenReturn("1 again");
+        when(spy.get(0)).thenReturn("1").thenReturn("1 again");
 
         assertEquals("1", spy.get(0));
         assertEquals("1 again", spy.get(0));
@@ -62,7 +59,7 @@ public class SpyingOnRealObjectsTest extends TestBase {
 
     @Test
     public void shouldAllowOverridingStubs() {
-        when(spy.contains(anyObject())).thenReturn(true);
+        when(spy.contains(any())).thenReturn(true);
         when(spy.contains("foo")).thenReturn(false);
 
         assertTrue(spy.contains("bar"));
@@ -71,26 +68,22 @@ public class SpyingOnRealObjectsTest extends TestBase {
 
     @Test
     public void shouldStubVoid() {
-        doNothing()
-        .doThrow(new RuntimeException())
-        .when(spy)
-        .clear();
+        doNothing().doThrow(new RuntimeException()).when(spy).clear();
 
         spy.add("one");
         spy.clear();
         try {
             spy.clear();
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
 
         assertEquals(1, spy.size());
     }
 
     @Test
     public void shouldStubWithDoReturnAndVerify() {
-        doReturn("foo")
-        .doReturn("bar")
-        .when(spy).get(0);
+        doReturn("foo").doReturn("bar").when(spy).get(0);
 
         assertEquals("foo", spy.get(0));
         assertEquals("bar", spy.get(0));
@@ -121,7 +114,8 @@ public class SpyingOnRealObjectsTest extends TestBase {
         try {
             inOrder.verify(spy).add("one");
             fail();
-        } catch (VerificationInOrderFailure f) {}
+        } catch (VerificationInOrderFailure f) {
+        }
     }
 
     @Test
@@ -141,7 +135,8 @@ public class SpyingOnRealObjectsTest extends TestBase {
         try {
             verify(spy, times(3)).add("one");
             fail();
-        } catch (TooLittleActualInvocations e) {}
+        } catch (TooFewActualInvocations e) {
+        }
     }
 
     @Test
@@ -153,13 +148,14 @@ public class SpyingOnRealObjectsTest extends TestBase {
         try {
             verifyNoMoreInteractions(spy);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
     public void shouldToString() {
         spy.add("foo");
-        assertEquals("[foo]" , spy.toString());
+        assertEquals("[foo]", spy.toString());
     }
 
     interface Foo {
@@ -168,14 +164,16 @@ public class SpyingOnRealObjectsTest extends TestBase {
 
     @Test
     public void shouldAllowSpyingAnonymousClasses() {
-        //when
-        Foo spy = spy(new Foo() {
-            public String print() {
-                return "foo";
-            }
-        });
-
-        //then
+        // when
+        Foo spy =
+                spy(
+                        new Foo() {
+                            public String print() {
+                                return "foo";
+                            }
+                        });
+
+        // then
         assertEquals("foo", spy.print());
     }
 
@@ -184,10 +182,14 @@ public class SpyingOnRealObjectsTest extends TestBase {
         List<String> real = Arrays.asList("first", "second");
         try {
             List<String> spy = spy(real);
-            assumeTrue("Using inline mocks, it is possible to spy on private types", spy.getClass() != real.getClass());
+            assumeTrue(
+                    "Using inline mocks, it is possible to spy on private types",
+                    spy.getClass() != real.getClass());
             fail();
         } catch (MockitoException e) {
-            assertThat(e).hasMessageContaining("Most likely it is due to mocking a private class that is not visible to Mockito");
+            assertThat(e)
+                    .hasMessageContaining(
+                            "Most likely it is due to mocking a private class that is not visible to Mockito");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/spies/StubbingSpiesDoesNotYieldNPETest.java b/src/test/java/org/mockitousage/spies/StubbingSpiesDoesNotYieldNPETest.java
index 12d3a41..da46788 100644
--- a/src/test/java/org/mockitousage/spies/StubbingSpiesDoesNotYieldNPETest.java
+++ b/src/test/java/org/mockitousage/spies/StubbingSpiesDoesNotYieldNPETest.java
@@ -4,14 +4,14 @@
  */
 package org.mockitousage.spies;
 
-import org.junit.Test;
-import org.mockitoutil.TestBase;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.spy;
 
 import java.util.Collection;
 import java.util.Map;
 
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.spy;
+import org.junit.Test;
+import org.mockitoutil.TestBase;
 
 public class StubbingSpiesDoesNotYieldNPETest extends TestBase {
 
diff --git a/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesTest.java b/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesTest.java
index 92e1e85..e204784 100644
--- a/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesTest.java
@@ -2,20 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 public class ClickableStackTracesTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -35,7 +34,9 @@ public class ClickableStackTracesTest extends TestBase {
             verifyTheMock(1, "not foo");
             fail();
         } catch (ArgumentsAreDifferent e) {
-            assertThat(e).hasMessageContaining("callMethodOnMock(").hasMessageContaining("verifyTheMock(");
+            assertThat(e)
+                    .hasMessageContaining("callMethodOnMock(")
+                    .hasMessageContaining("verifyTheMock(");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java b/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java
index e9a98c1..2bd7e0c 100644
--- a/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -14,10 +17,6 @@ import org.mockito.exceptions.misusing.UnfinishedVerificationException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class ClickableStackTracesWhenFrameworkMisusedTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -28,7 +27,7 @@ public class ClickableStackTracesWhenFrameworkMisusedTest extends TestBase {
     }
 
     private void misplacedArgumentMatcherHere() {
-        anyString();
+        String ignored = anyString();
     }
 
     @Test
@@ -39,8 +38,8 @@ public class ClickableStackTracesWhenFrameworkMisusedTest extends TestBase {
             fail();
         } catch (InvalidUseOfMatchersException e) {
             assertThat(e)
-                .hasMessageContaining("-> at ")
-                .hasMessageContaining("misplacedArgumentMatcherHere(");
+                    .hasMessageContaining("-> at ")
+                    .hasMessageContaining("misplacedArgumentMatcherHere(");
         }
     }
 
@@ -58,8 +57,8 @@ public class ClickableStackTracesWhenFrameworkMisusedTest extends TestBase {
             fail();
         } catch (UnfinishedStubbingException e) {
             assertThat(e)
-                .hasMessageContaining("-> at ")
-                .hasMessageContaining("unfinishedStubbingHere(");
+                    .hasMessageContaining("-> at ")
+                    .hasMessageContaining("unfinishedStubbingHere(");
         }
     }
 
diff --git a/src/test/java/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java b/src/test/java/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java
index e1bd9af..03d99be 100644
--- a/src/test/java/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.mockito.Mockito.*;
+
+import java.util.LinkedList;
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -16,11 +20,6 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-import java.util.List;
-
-import static org.mockito.Mockito.*;
-
 @Ignore
 @RunWith(MockitoJUnitRunner.class)
 public class ModellingDescriptiveMessagesTest extends TestBase {
@@ -35,7 +34,7 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
     @Test
     public void makeSureStateIsValidatedInTheVeryFirstTestThanksToTheRunner() {
-        //mess up the state:
+        // mess up the state:
         verify(mock);
     }
 
@@ -59,7 +58,7 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
     }
 
     @Test
-    public void shouldSayTooLittleInvocations() {
+    public void shouldSayTooFewInvocations() {
         mock.simpleMethod();
         verify(mock, times(2)).simpleMethod();
     }
@@ -81,7 +80,7 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
     }
 
     @Test
-    public void shouldSayTooLittleInvocationsInOrder() {
+    public void shouldSayTooFewInvocationsInOrder() {
         mock.simpleMethod();
         mock.otherMethod();
         mock.otherMethod();
@@ -108,7 +107,7 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
     }
 
     @Test
-    public void shouldSayTooLittleInvocationsInAtLeastModeInOrder() {
+    public void shouldSayTooFewInvocationsInAtLeastModeInOrder() {
         mock.simpleMethod();
 
         InOrder inOrder = inOrder(mock);
@@ -116,7 +115,7 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
     }
 
     @Test
-    public void shouldSayTooLittleInvocationsInAtLeastMode() {
+    public void shouldSayTooFewInvocationsInAtLeastMode() {
         mock.simpleMethod();
 
         verify(mock, atLeast(2)).simpleMethod();
@@ -159,14 +158,14 @@ public class ModellingDescriptiveMessagesTest extends TestBase {
 
     @Test
     public void shouldMentionFinalAndObjectMethodsWhenMisplacedArgumentMatcher() {
-        when(mock.equals(anyObject())).thenReturn(false);
+        when(mock.equals(any())).thenReturn(false);
     }
 
     @Test
     public void shouldShowExampleOfCorrectArgumentCapturing() {
         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);
-        argument.capture();
-        argument.getValue();
+        Object ignored = argument.capture();
+        String ignoredValue = argument.getValue();
     }
 
     @SuppressWarnings({"CheckReturnValue", "MockitoUsage"})
diff --git a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java
index cbb8334..4a2b7b7 100644
--- a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -15,10 +18,6 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 @RunWith(MockitoJUnitRunner.class)
 public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {
 
@@ -40,14 +39,17 @@ public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBa
         mock.simpleMethod(1);
         mock.simpleMethod(1);
     }
+
     private void secondChunk() {
         mockTwo.simpleMethod(2);
         mockTwo.simpleMethod(2);
     }
+
     private void thirdChunk() {
         mock.simpleMethod(3);
         mock.simpleMethod(3);
     }
+
     private void fourthChunk() {
         mockTwo.simpleMethod(4);
         mockTwo.simpleMethod(4);
@@ -79,7 +81,7 @@ public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBa
     }
 
     @Test
-    public void shouldPointToThirdChunkWhenTooLittleActualInvocations() {
+    public void shouldPointToThirdChunkWhenTooFewActualInvocations() {
         inOrder.verify(mock, times(2)).simpleMethod(anyInt());
         inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());
         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());
diff --git a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java
index 6e05111..a85252d 100644
--- a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -15,11 +18,7 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
-//This is required to make sure stack trace is well filtered when runner is ON
+// This is required to make sure stack trace is well filtered when runner is ON
 @RunWith(MockitoJUnitRunner.class)
 public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {
 
@@ -40,12 +39,15 @@ public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {
     private void first() {
         mock.simpleMethod(1);
     }
+
     private void second() {
         mockTwo.simpleMethod(2);
     }
+
     private void third() {
         mock.simpleMethod(3);
     }
+
     private void fourth() {
         mockTwo.simpleMethod(4);
     }
@@ -111,7 +113,7 @@ public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {
     }
 
     @Test
-    public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations() {
+    public void shouldPointToFourthMethodBecauseOfTooFewActualInvocations() {
         inOrder.verify(mock).simpleMethod(anyInt());
         inOrder.verify(mockTwo).simpleMethod(anyInt());
         inOrder.verify(mock).simpleMethod(anyInt());
diff --git a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java
index 34f3e15..41c2f04 100644
--- a/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,12 +18,7 @@ import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-//This is required to make sure stack trace is well filtered when runner is ON
+// This is required to make sure stack trace is well filtered when runner is ON
 @RunWith(MockitoJUnitRunner.class)
 public class PointingStackTraceToActualInvocationTest extends TestBase {
 
@@ -37,12 +36,15 @@ public class PointingStackTraceToActualInvocationTest extends TestBase {
     private void first() {
         mock.simpleMethod(1);
     }
+
     private void second() {
         mockTwo.simpleMethod(2);
     }
+
     private void third() {
         mock.simpleMethod(3);
     }
+
     private void fourth() {
         mockTwo.simpleMethod(4);
     }
diff --git a/src/test/java/org/mockitousage/stacktrace/StackTraceFilteringTest.java b/src/test/java/org/mockitousage/stacktrace/StackTraceFilteringTest.java
index 6186130..1734e53 100644
--- a/src/test/java/org/mockitousage/stacktrace/StackTraceFilteringTest.java
+++ b/src/test/java/org/mockitousage/stacktrace/StackTraceFilteringTest.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stacktrace;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+import static org.mockitoutil.Conditions.firstMethodInStackTrace;
+
 import org.assertj.core.api.Assertions;
 import org.junit.After;
 import org.junit.Before;
@@ -18,14 +25,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static org.mockitoutil.Conditions.firstMethodInStackTrace;
-
 public class StackTraceFilteringTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -57,18 +56,22 @@ public class StackTraceFilteringTest extends TestBase {
             verifyNoMoreInteractions(mock);
             fail();
         } catch (NoInteractionsWanted e) {
-            Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoMoreInteractions"));
+            Assertions.assertThat(e)
+                    .has(
+                            firstMethodInStackTrace(
+                                    "shouldFilterStackTraceOnVerifyNoMoreInteractions"));
         }
     }
 
     @Test
-    public void shouldFilterStackTraceOnVerifyZeroInteractions() {
+    public void shouldFilterStackTraceOnVerifyNoInteractions() {
         mock.oneArg(true);
         try {
-            verifyZeroInteractions(mock);
+            verifyNoInteractions(mock);
             fail();
         } catch (NoInteractionsWanted e) {
-            Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyZeroInteractions"));
+            Assertions.assertThat(e)
+                    .has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoInteractions"));
         }
     }
 
@@ -80,7 +83,8 @@ public class StackTraceFilteringTest extends TestBase {
             verify(mock).oneArg(true);
             fail();
         } catch (MockitoException expected) {
-            Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));
+            Assertions.assertThat(expected)
+                    .has(firstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));
         }
     }
 
@@ -95,7 +99,8 @@ public class StackTraceFilteringTest extends TestBase {
             inOrder.verify(mock).oneArg(true);
             fail();
         } catch (VerificationInOrderFailure e) {
-            Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));
+            Assertions.assertThat(e)
+                    .has(firstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));
         }
     }
 
@@ -105,7 +110,10 @@ public class StackTraceFilteringTest extends TestBase {
             inOrder();
             fail();
         } catch (MockitoException expected) {
-            Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceWhenInOrderThrowsMockitoException"));
+            Assertions.assertThat(expected)
+                    .has(
+                            firstMethodInStackTrace(
+                                    "shouldFilterStacktraceWhenInOrderThrowsMockitoException"));
         }
     }
 
@@ -116,7 +124,8 @@ public class StackTraceFilteringTest extends TestBase {
             inOrder.verify(null);
             fail();
         } catch (MockitoException expected) {
-            Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));
+            Assertions.assertThat(expected)
+                    .has(firstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));
         }
     }
 
@@ -126,7 +135,10 @@ public class StackTraceFilteringTest extends TestBase {
             when(mock.oneArg(true)).thenThrow(new Exception());
             fail();
         } catch (MockitoException expected) {
-            Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));
+            Assertions.assertThat(expected)
+                    .has(
+                            firstMethodInStackTrace(
+                                    "shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));
         }
     }
 
@@ -138,7 +150,8 @@ public class StackTraceFilteringTest extends TestBase {
             mock.simpleMethod();
             fail();
         } catch (RuntimeException e) {
-            Assertions.assertThat(e).has(firstMethodInStackTrace("shouldShowProperExceptionStackTrace"));
+            Assertions.assertThat(e)
+                    .has(firstMethodInStackTrace("shouldShowProperExceptionStackTrace"));
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/strictness/LenientMockAnnotationTest.java b/src/test/java/org/mockitousage/strictness/LenientMockAnnotationTest.java
new file mode 100644
index 0000000..e2f4b7e
--- /dev/null
+++ b/src/test/java/org/mockitousage/strictness/LenientMockAnnotationTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.strictness;
+
+import static org.mockito.Mockito.when;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.exceptions.misusing.PotentialStubbingProblem;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+import org.mockito.quality.Strictness;
+import org.mockitousage.IMethods;
+
+public class LenientMockAnnotationTest {
+
+    public @Rule MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
+
+    @Mock(lenient = true)
+    IMethods lenientMock;
+
+    @Mock IMethods regularMock;
+
+    @Test
+    public void mock_is_lenient() {
+        when(lenientMock.simpleMethod("1")).thenReturn("1");
+        when(regularMock.simpleMethod("2")).thenReturn("2");
+
+        // then lenient mock does not throw:
+        ProductionCode.simpleMethod(lenientMock, "3");
+
+        // but regular mock throws:
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                ProductionCode.simpleMethod(regularMock, "4");
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
+    }
+}
diff --git a/src/test/java/org/mockitousage/strictness/PotentialStubbingSensitivityTest.java b/src/test/java/org/mockitousage/strictness/PotentialStubbingSensitivityTest.java
new file mode 100644
index 0000000..9b468ff
--- /dev/null
+++ b/src/test/java/org/mockitousage/strictness/PotentialStubbingSensitivityTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.strictness;
+
+import static org.mockito.Mockito.when;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.exceptions.misusing.PotentialStubbingProblem;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+import org.mockito.quality.Strictness;
+import org.mockitousage.IMethods;
+
+public class PotentialStubbingSensitivityTest {
+
+    @Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
+    @Mock IMethods mock;
+
+    @Before
+    public void setup() {
+        when(mock.simpleMethod("1")).thenReturn("1");
+    }
+
+    @Test
+    public void allows_stubbing_with_different_arg_in_test_code() {
+        // although we are calling 'simpleMethod' with different argument
+        // Mockito understands that this is stubbing in the test code and does not trigger
+        // PotentialStubbingProblem
+        when(mock.simpleMethod("2")).thenReturn("2");
+
+        // methods in anonymous inner classes are ok, too
+        new Runnable() {
+            public void run() {
+                when(mock.simpleMethod("3")).thenReturn("3");
+            }
+        }.run();
+
+        // avoiding unnecessary stubbing failures:
+        mock.simpleMethod("1");
+        mock.simpleMethod("2");
+        mock.simpleMethod("3");
+    }
+
+    @Test
+    public void reports_potential_stubbing_problem_in_production_code() {
+        // when
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                ProductionCode.simpleMethod(mock, "2");
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
+    }
+}
diff --git a/src/test/java/org/mockitousage/strictness/ProductionCode.java b/src/test/java/org/mockitousage/strictness/ProductionCode.java
new file mode 100644
index 0000000..8e76702
--- /dev/null
+++ b/src/test/java/org/mockitousage/strictness/ProductionCode.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.strictness;
+
+import org.mockitousage.IMethods;
+
+/**
+ * Test utility class that simulates invocation of mock in production code.
+ * In certain tests, the production code needs to be invoked in a different class/source file than the test.
+ */
+public class ProductionCode {
+
+    public static void simpleMethod(IMethods mock, String argument) {
+        mock.simpleMethod(argument);
+    }
+
+    public static void simpleMethod(IMethods mock, int argument) {
+        mock.simpleMethod(argument);
+    }
+}
diff --git a/src/test/java/org/mockitousage/strictness/StrictnessPerMockTest.java b/src/test/java/org/mockitousage/strictness/StrictnessPerMockTest.java
index 2dce3e0..fd1c053 100644
--- a/src/test/java/org/mockitousage/strictness/StrictnessPerMockTest.java
+++ b/src/test/java/org/mockitousage/strictness/StrictnessPerMockTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.strictness;
 
+import static junit.framework.TestCase.assertFalse;
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertNull;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.mockingDetails;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.withSettings;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.After;
@@ -20,16 +28,7 @@ import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static junit.framework.TestCase.assertFalse;
-import static junit.framework.TestCase.assertTrue;
-import static org.junit.Assert.assertNull;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.mockingDetails;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.withSettings;
-
-//TODO 792 also move other Strictness tests to this package (unless they already have good package)
+// TODO 792 also move other Strictness tests to this package (unless they already have good package)
 public class StrictnessPerMockTest {
 
     MockitoSession mockito;
@@ -38,7 +37,11 @@ public class StrictnessPerMockTest {
 
     @Before
     public void before() {
-        mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+        mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
         assertNull(lenientMock);
         lenientMock = mock(IMethods.class, withSettings().lenient());
     }
@@ -51,63 +54,73 @@ public class StrictnessPerMockTest {
 
     @Test
     public void potential_stubbing_problem() {
-        //when
+        // when
         given(lenientMock.simpleMethod(100)).willReturn("100");
         given(strictStubsMock.simpleMethod(100)).willReturn("100");
 
-        //then on lenient mock (created by hand), we can call the stubbed method with different arg:
+        // then on lenient mock (created by hand), we can call the stubbed method with different
+        // arg:
         lenientMock.simpleMethod(200);
 
-        //and on strict stub mock (created by session), we cannot call stubbed method with different arg:
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                strictStubsMock.simpleMethod(200);
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        // and on strict stub mock (created by session), we cannot call stubbed method with
+        // different arg:
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                ProductionCode.simpleMethod(strictStubsMock, 200);
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
     }
 
     @Test
     public void unnecessary_stubbing() {
-        //when
+        // when
         given(lenientMock.simpleMethod(100)).willReturn("100");
         given(strictStubsMock.simpleMethod(100)).willReturn("100");
 
-        //then unnecessary stubbing flags method only on the strict stub mock:
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mockito.finishMocking();
-            }
-        }).isInstanceOf(UnnecessaryStubbingException.class)
-            .hasMessageContaining("1. -> ")
-            //good enough to prove that we're flagging just one unnecessary stubbing:
-            //TODO 792: let's make UnnecessaryStubbingException exception contain the Invocation instance
-            //so that we can write clean assertion rather than depending on string
-            .isNot(TestBase.hasMessageContaining("2. ->"));
+        // then unnecessary stubbing flags method only on the strict stub mock:
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                mockito.finishMocking();
+                            }
+                        })
+                .isInstanceOf(UnnecessaryStubbingException.class)
+                .hasMessageContaining("1. -> ")
+                // good enough to prove that we're flagging just one unnecessary stubbing:
+                // TODO 792: let's make UnnecessaryStubbingException exception contain the
+                // Invocation instance
+                // so that we can write clean assertion rather than depending on string
+                .isNot(TestBase.hasMessageContaining("2. ->"));
     }
 
     @Test
     public void verify_no_more_invocations() {
-        //when
+        // when
         given(lenientMock.simpleMethod(100)).willReturn("100");
         given(strictStubsMock.simpleMethod(100)).willReturn("100");
 
-        //and:
+        // and:
         strictStubsMock.simpleMethod(100);
         lenientMock.simpleMethod(100);
 
-        //then 'verifyNoMoreInteractions' ignores strict stub (implicitly verified) but flags the lenient mock
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                verifyNoMoreInteractions(strictStubsMock, lenientMock);
-            }
-        }).isInstanceOf(NoInteractionsWanted.class)
-            .hasMessageContaining("But found this interaction on mock 'iMethods'")
-            //TODO 792: let's make NoInteractionsWanted exception contain the Invocation instances
-            //so that we can write clean assertion rather than depending on string
-            .hasMessageContaining("Actually, above is the only interaction with this mock");
+        // then 'verifyNoMoreInteractions' ignores strict stub (implicitly verified) but flags the
+        // lenient mock
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                verifyNoMoreInteractions(strictStubsMock, lenientMock);
+                            }
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContaining("But found this interaction on mock 'iMethods'")
+                // TODO 792: let's make NoInteractionsWanted exception contain the Invocation
+                // instances
+                // so that we can write clean assertion rather than depending on string
+                .hasMessageContaining("Actually, above is the only interaction with this mock");
     }
 
     @After
diff --git a/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingTest.java b/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingTest.java
index 3838bee..cc78e2a 100644
--- a/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingTest.java
+++ b/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingTest.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.strictness;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.After;
 import org.junit.Before;
@@ -20,14 +27,6 @@ import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
 public class StrictnessPerStubbingTest {
 
     MockitoSession mockito;
@@ -35,135 +34,155 @@ public class StrictnessPerStubbingTest {
 
     @Before
     public void before() {
-        mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+        mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
     }
 
     @Test
     public void potential_stubbing_problem() {
-        //when
+        // when
         when(mock.simpleMethod("1")).thenReturn("1");
         lenient().when(mock.differentMethod("2")).thenReturn("2");
 
-        //then on lenient stubbing, we can call it with different argument:
+        // then on lenient stubbing, we can call it with different argument:
         mock.differentMethod("200");
 
-        //but on strict stubbing, we cannot:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mock.simpleMethod("100");
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        // but on strict stubbing, we cannot:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                ProductionCode.simpleMethod(mock, "100");
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
     }
 
     @Test
     public void doReturn_syntax() {
-        //when
-        lenient().doReturn("2").doReturn("3")
-            .when(mock).simpleMethod(1);
+        // when
+        lenient().doReturn("2").doReturn("3").when(mock).simpleMethod(1);
 
-        //then on lenient stubbing, we can call it with different argument:
+        // then on lenient stubbing, we can call it with different argument:
         mock.simpleMethod(200);
 
-        //and stubbing works, too:
+        // and stubbing works, too:
         assertEquals("2", mock.simpleMethod(1));
         assertEquals("3", mock.simpleMethod(1));
     }
 
     @Test
     public void doReturn_varargs_syntax() {
-        //when
-        lenient().doReturn("2", "3")
-            .when(mock).simpleMethod(1);
+        // when
+        lenient().doReturn("2", "3").when(mock).simpleMethod(1);
 
-        //then on lenient stubbing, we can call it with different argument with no exception:
+        // then on lenient stubbing, we can call it with different argument with no exception:
         mock.simpleMethod(200);
 
-        //and stubbing works, too:
+        // and stubbing works, too:
         assertEquals("2", mock.simpleMethod(1));
         assertEquals("3", mock.simpleMethod(1));
     }
 
     @Test
     public void doThrow_syntax() {
-        //when
+        // when
         lenient()
-            .doThrow(IllegalArgumentException.class)
-            .doThrow(IllegalStateException.class)
-            .when(mock).simpleMethod(1);
+                .doThrow(IllegalArgumentException.class)
+                .doThrow(IllegalStateException.class)
+                .when(mock)
+                .simpleMethod(1);
 
-        //then on lenient stubbing, we can call it with different argument with no exception:
+        // then on lenient stubbing, we can call it with different argument with no exception:
         mock.simpleMethod(200);
 
-        //and stubbing works, too:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalArgumentException.class);
-
-        //testing consecutive call:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalStateException.class);
+        // and stubbing works, too:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
+
+        // testing consecutive call:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalStateException.class);
     }
 
     @Test
     public void doThrow_vararg_syntax() {
-        //when
+        // when
         lenient()
-            .doThrow(IllegalArgumentException.class, IllegalStateException.class)
-            .when(mock).simpleMethod(1);
+                .doThrow(IllegalArgumentException.class, IllegalStateException.class)
+                .when(mock)
+                .simpleMethod(1);
 
-        //then on lenient stubbing, we can call it with different argument with no exception:
+        // then on lenient stubbing, we can call it with different argument with no exception:
         mock.simpleMethod(200);
 
-        //and stubbing works, too:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalArgumentException.class);
-
-        //testing consecutive call:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalStateException.class);
+        // and stubbing works, too:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
+
+        // testing consecutive call:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalStateException.class);
     }
 
     @Test
     public void doThrow_instance_vararg_syntax() {
-        //when
+        // when
         lenient()
-            .doThrow(new IllegalArgumentException(), new IllegalStateException())
-            .when(mock).simpleMethod(1);
+                .doThrow(new IllegalArgumentException(), new IllegalStateException())
+                .when(mock)
+                .simpleMethod(1);
 
-        //then on lenient stubbing, we can call it with different argument with no exception:
+        // then on lenient stubbing, we can call it with different argument with no exception:
         mock.simpleMethod(200);
 
-        //and stubbing works, too:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalArgumentException.class);
-
-        //testing consecutive call:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() throws Throwable {
-                mock.simpleMethod(1);
-            }
-        }).isInstanceOf(IllegalStateException.class);
+        // and stubbing works, too:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
+
+        // testing consecutive call:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() throws Throwable {
+                                mock.simpleMethod(1);
+                            }
+                        })
+                .isInstanceOf(IllegalStateException.class);
     }
 
     static class Counter {
         int increment(int x) {
             return x + 1;
         }
+
         void scream(String message) {
             throw new RuntimeException(message);
         }
@@ -171,97 +190,104 @@ public class StrictnessPerStubbingTest {
 
     @Test
     public void doCallRealMethod_syntax() {
-        //when
+        // when
         Counter mock = mock(Counter.class);
         lenient().doCallRealMethod().when(mock).increment(1);
 
-        //then no exception and default return value if we call it with different arg:
+        // then no exception and default return value if we call it with different arg:
         assertEquals(0, mock.increment(0));
 
-        //and real method is called when using correct arg:
+        // and real method is called when using correct arg:
         assertEquals(2, mock.increment(1));
     }
 
     @Test
     public void doNothing_syntax() {
-        //when
+        // when
         final Counter spy = spy(Counter.class);
         lenient().doNothing().when(spy).scream("1");
 
-        //then no stubbing exception and real method is called if we call stubbed method with different arg:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                spy.scream("2");
-            }
-        }).hasMessage("2");
-
-        //and we do nothing when stubbing called with correct arg:
+        // then no stubbing exception and real method is called if we call stubbed method with
+        // different arg:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                spy.scream("2");
+                            }
+                        })
+                .hasMessage("2");
+
+        // and we do nothing when stubbing called with correct arg:
         spy.scream("1");
     }
 
     @Test
     public void doAnswer_syntax() {
-        //when
+        // when
         lenient().doAnswer(AdditionalAnswers.returnsFirstArg()).when(mock).simpleMethod("1");
 
-        //then on lenient stubbing, we can call it with different argument:
+        // then on lenient stubbing, we can call it with different argument:
         mock.simpleMethod("200");
 
-        //and stubbing works, too:
+        // and stubbing works, too:
         assertEquals("1", mock.simpleMethod("1"));
     }
 
     @Test
     public void unnecessary_stubbing() {
-        //when
+        // when
         when(mock.simpleMethod("1")).thenReturn("1");
         lenient().when(mock.differentMethod("2")).thenReturn("2");
 
-        //then unnecessary stubbing flags method only on the strict stubbing:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mockito.finishMocking();
-            }
-        }).isInstanceOf(UnnecessaryStubbingException.class)
-            .hasMessageContaining("1. -> ")
-            //good enough to prove that we're flagging just one unnecessary stubbing:
-            //TODO 792: this assertion is duplicated with StrictnessPerMockTest
-            .isNot(TestBase.hasMessageContaining("2. ->"));
+        // then unnecessary stubbing flags method only on the strict stubbing:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                mockito.finishMocking();
+                            }
+                        })
+                .isInstanceOf(UnnecessaryStubbingException.class)
+                .hasMessageContaining("1. -> ")
+                // good enough to prove that we're flagging just one unnecessary stubbing:
+                // TODO 792: this assertion is duplicated with StrictnessPerMockTest
+                .isNot(TestBase.hasMessageContaining("2. ->"));
     }
 
     @Test
     public void unnecessary_stubbing_with_doReturn() {
-        //when
+        // when
         lenient().doReturn("2").when(mock).differentMethod("2");
 
-        //then no exception is thrown:
+        // then no exception is thrown:
         mockito.finishMocking();
     }
 
     @Test
     public void verify_no_more_invocations() {
-        //when
+        // when
         when(mock.simpleMethod("1")).thenReturn("1");
         lenient().when(mock.differentMethod("2")).thenReturn("2");
 
-        //and:
+        // and:
         mock.simpleMethod("1");
         mock.differentMethod("200"); // <- different arg
 
-        //then 'verifyNoMoreInteractions' flags the lenient stubbing (called with different arg)
-        //and reports it with [?] in the exception message
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                verifyNoMoreInteractions(mock);
-            }
-        }).isInstanceOf(NoInteractionsWanted.class)
-            .hasMessageContaining("1. ->")
-            .hasMessageContaining("2. [?]->");
-            //TODO 792: assertion duplicated with StrictnessPerMockTest
-            // and we should use assertions based on content of the exception rather than the string
+        // then 'verifyNoMoreInteractions' flags the lenient stubbing (called with different arg)
+        // and reports it with [?] in the exception message
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                verifyNoMoreInteractions(mock);
+                            }
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContaining("1. ->")
+                .hasMessageContaining("2. [?]->");
+        // TODO 792: assertion duplicated with StrictnessPerMockTest
+        // and we should use assertions based on content of the exception rather than the string
     }
 
     @After
diff --git a/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingWithRunnerTest.java b/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingWithRunnerTest.java
index e42d340..b8a5dc4 100644
--- a/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingWithRunnerTest.java
+++ b/src/test/java/org/mockitousage/strictness/StrictnessPerStubbingWithRunnerTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.strictness;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.when;
+
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -13,10 +16,6 @@ import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.when;
-
 @RunWith(MockitoJUnitRunner.StrictStubs.class)
 public class StrictnessPerStubbingWithRunnerTest {
 
@@ -24,28 +23,29 @@ public class StrictnessPerStubbingWithRunnerTest {
 
     @Test
     public void potential_stubbing_problem() {
-        //when
+        // when
         when(mock.simpleMethod("1")).thenReturn("1");
         lenient().when(mock.differentMethod("2")).thenReturn("2");
 
-        //then on lenient stubbing, we can call it with different argument:
+        // then on lenient stubbing, we can call it with different argument:
         mock.differentMethod("200");
 
-        //but on strict stubbing, we cannot:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mock.simpleMethod("100");
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        // but on strict stubbing, we cannot:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                ProductionCode.simpleMethod(mock, "100");
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
 
-        //let's use the strict stubbing so that it is not reported as failure by the runner:
+        // let's use the strict stubbing so that it is not reported as failure by the runner:
         mock.simpleMethod("1");
     }
 
     @Test
     public void unnecessary_stubbing() {
-        //this unnecessary stubbing is not flagged by the runner:
+        // this unnecessary stubbing is not flagged by the runner:
         lenient().when(mock.differentMethod("2")).thenReturn("2");
     }
 }
diff --git a/src/test/java/org/mockitousage/strictness/StrictnessWhenRuleStrictnessIsUpdatedTest.java b/src/test/java/org/mockitousage/strictness/StrictnessWhenRuleStrictnessIsUpdatedTest.java
index 592cca9..c108127 100644
--- a/src/test/java/org/mockitousage/strictness/StrictnessWhenRuleStrictnessIsUpdatedTest.java
+++ b/src/test/java/org/mockitousage/strictness/StrictnessWhenRuleStrictnessIsUpdatedTest.java
@@ -2,9 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.strictness;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
+
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Rule;
 import org.junit.Test;
@@ -15,12 +20,6 @@ import org.mockito.junit.MockitoRule;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
-
 public class StrictnessWhenRuleStrictnessIsUpdatedTest {
 
     @Mock IMethods mock;
@@ -28,19 +27,20 @@ public class StrictnessWhenRuleStrictnessIsUpdatedTest {
 
     @Test
     public void strictness_per_mock() {
-        //when
+        // when
         rule.strictness(Strictness.STRICT_STUBS);
 
-        //then previous mock is strict:
+        // then previous mock is strict:
         when(mock.simpleMethod(1)).thenReturn("1");
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mock.simpleMethod(2);
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                ProductionCode.simpleMethod(mock, 2);
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
 
-        //but the new mock is lenient, even though the rule is not:
+        // but the new mock is lenient, even though the rule is not:
         final IMethods lenientMock = mock(IMethods.class, withSettings().lenient());
         when(lenientMock.simpleMethod(1)).thenReturn("1");
         lenientMock.simpleMethod(100);
@@ -48,19 +48,20 @@ public class StrictnessWhenRuleStrictnessIsUpdatedTest {
 
     @Test
     public void strictness_per_stubbing() {
-        //when
+        // when
         rule.strictness(Strictness.STRICT_STUBS);
 
-        //then previous mock is strict:
+        // then previous mock is strict:
         when(mock.simpleMethod(1)).thenReturn("1");
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mock.simpleMethod(2);
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                ProductionCode.simpleMethod(mock, 2);
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
 
-        //but the new mock is lenient, even though the rule is not:
+        // but the new mock is lenient, even though the rule is not:
         lenient().when(mock.simpleMethod(1)).thenReturn("1");
         mock.simpleMethod(100);
     }
diff --git a/src/test/java/org/mockitousage/strictness/StrictnessWithRulesTest.java b/src/test/java/org/mockitousage/strictness/StrictnessWithRulesTest.java
index 3a323fb..1bc9574 100644
--- a/src/test/java/org/mockitousage/strictness/StrictnessWithRulesTest.java
+++ b/src/test/java/org/mockitousage/strictness/StrictnessWithRulesTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.strictness;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.when;
+
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Rule;
 import org.junit.Test;
@@ -15,10 +18,6 @@ import org.mockito.junit.MockitoRule;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.when;
-
 public class StrictnessWithRulesTest {
 
     @Mock IMethods mock;
@@ -26,28 +25,29 @@ public class StrictnessWithRulesTest {
 
     @Test
     public void potential_stubbing_problem() {
-        //when
+        // when
         when(mock.simpleMethod("1")).thenReturn("1");
         lenient().when(mock.differentMethod("2")).thenReturn("2");
 
-        //then on lenient stubbing, we can call it with different argument:
+        // then on lenient stubbing, we can call it with different argument:
         mock.differentMethod("200");
 
-        //but on strict stubbing, we cannot:
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                mock.simpleMethod("100");
-            }
-        }).isInstanceOf(PotentialStubbingProblem.class);
+        // but on strict stubbing, we cannot:
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                ProductionCode.simpleMethod(mock, "100");
+                            }
+                        })
+                .isInstanceOf(PotentialStubbingProblem.class);
 
-        //let's use the strict stubbing so that it is not reported as failure by the rule:
+        // let's use the strict stubbing so that it is not reported as failure by the rule:
         mock.simpleMethod("1");
     }
 
     @Test
     public void unnecessary_stubbing() {
-        //this unnecessary stubbing is not flagged by the rule:
+        // this unnecessary stubbing is not flagged by the rule:
         lenient().when(mock.differentMethod("2")).thenReturn("2");
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/BasicStubbingTest.java b/src/test/java/org/mockitousage/stubbing/BasicStubbingTest.java
index c63cb6d..15e4346 100644
--- a/src/test/java/org/mockitousage/stubbing/BasicStubbingTest.java
+++ b/src/test/java/org/mockitousage/stubbing/BasicStubbingTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
@@ -13,11 +17,6 @@ import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class BasicStubbingTest extends TestBase {
 
     private IMethods mock;
@@ -34,7 +33,8 @@ public class BasicStubbingTest extends TestBase {
 
         assertEquals(200, mock.objectReturningMethod(200));
         assertEquals(100, mock.objectReturningMethod(666));
-        assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));
+        assertEquals(
+                "default behavior should return null", null, mock.objectReturningMethod("blah"));
     }
 
     @Test
@@ -46,7 +46,8 @@ public class BasicStubbingTest extends TestBase {
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -63,7 +64,15 @@ public class BasicStubbingTest extends TestBase {
         when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
         doThrow(new RuntimeException()).when(mock).simpleMethod("two");
 
-        verifyZeroInteractions(mock);
+        verifyNoInteractions(mock);
+    }
+
+    @Test
+    public void should_stubbing_not_be_treated_as_interaction_verify_no_interactions() {
+        when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
+        doThrow(new RuntimeException()).when(mock).simpleMethod("two");
+
+        verifyNoInteractions(mock);
     }
 
     @Test
@@ -72,10 +81,24 @@ public class BasicStubbingTest extends TestBase {
         try {
             when("").thenReturn("");
             fail();
-        } catch (MissingMethodInvocationException e) {}
+        } catch (MissingMethodInvocationException e) {
+        }
+
+        // anything that can cause state validation
+        verifyNoInteractions(mock);
+    }
+
+    @Test
+    public void unfinished_stubbing_cleans_up_the_state_verify_no_interactions() {
+        reset(mock);
+        try {
+            when("").thenReturn("");
+            fail();
+        } catch (MissingMethodInvocationException e) {
+        }
 
-        //anything that can cause state validation
-        verifyZeroInteractions(mock);
+        // anything that can cause state validation
+        verifyNoInteractions(mock);
     }
 
     @Test
@@ -108,12 +131,16 @@ public class BasicStubbingTest extends TestBase {
 
         assertEquals(200, localMock.objectReturningMethod(200));
         assertEquals(100, localMock.objectReturningMethod(666));
-        assertEquals("default behavior should return null", null, localMock.objectReturningMethod("blah"));
+        assertEquals(
+                "default behavior should return null",
+                null,
+                localMock.objectReturningMethod("blah"));
 
         try {
             verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));
             fail();
-        } catch (CannotVerifyStubOnlyMock e) {}
+        } catch (CannotVerifyStubOnlyMock e) {
+        }
     }
 
     @SuppressWarnings("MockitoUsage")
@@ -124,6 +151,34 @@ public class BasicStubbingTest extends TestBase {
         try {
             verify(localMock); // throws exception before method invocation
             fail();
-        } catch (CannotVerifyStubOnlyMock e) {}
+        } catch (CannotVerifyStubOnlyMock e) {
+            assertEquals(
+                    "\n"
+                            + "Argument \"iMethods\" passed to verify is a stubOnly() mock which cannot be verified.\n"
+                            + "If you intend to verify invocations on this mock, don't use stubOnly() in its MockSettings.",
+                    e.getMessage());
+        }
+    }
+
+    @Test
+    public void test_stub_only_not_verifiable_verify_no_more_interactions() {
+        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());
+
+        try {
+            verifyNoMoreInteractions(localMock);
+            fail();
+        } catch (CannotVerifyStubOnlyMock e) {
+        }
+    }
+
+    @Test
+    public void test_stub_only_not_verifiable_in_order() {
+        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());
+
+        try {
+            inOrder(localMock);
+            fail();
+        } catch (CannotVerifyStubOnlyMock e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/CallingRealMethodTest.java b/src/test/java/org/mockitousage/stubbing/CallingRealMethodTest.java
index 9fcf6e0..333661d 100644
--- a/src/test/java/org/mockitousage/stubbing/CallingRealMethodTest.java
+++ b/src/test/java/org/mockitousage/stubbing/CallingRealMethodTest.java
@@ -4,17 +4,16 @@
  */
 package org.mockitousage.stubbing;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.*;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
-
 public class CallingRealMethodTest extends TestBase {
 
-    @Mock
-    TestedObject mock;
+    @Mock TestedObject mock;
 
     static class TestedObject {
 
diff --git a/src/test/java/org/mockitousage/stubbing/CloningParameterTest.java b/src/test/java/org/mockitousage/stubbing/CloningParameterTest.java
index 3da0cdc..000f766 100644
--- a/src/test/java/org/mockitousage/stubbing/CloningParameterTest.java
+++ b/src/test/java/org/mockitousage/stubbing/CloningParameterTest.java
@@ -2,17 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
-import org.junit.Test;
-import org.mockito.internal.stubbing.answers.ClonesArguments;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.ArgumentMatchers.*;
+import static org.mockito.Mockito.*;
 
 import java.util.List;
 
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Mockito.*;
+import org.junit.Test;
+import org.mockito.internal.stubbing.answers.ClonesArguments;
+import org.mockitoutil.TestBase;
 
 public class CloningParameterTest extends TestBase {
 
@@ -49,6 +49,34 @@ public class CloningParameterTest extends TestBase {
         assertNotNull(emails);
     }
 
+    @Test
+    public void shouldCloneArrays() throws Exception {
+
+        EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());
+
+        // 1. Pass an array into a mock that "ClonesArguments"
+        Person[] ccList = new Person[] {new Person("Wes")};
+        emailSender.sendGroupEmail(1, ccList);
+
+        // 2. Mutate the array
+        ccList[0] = new Person("Joe");
+
+        // 3. Verify that the mock made a copy of the array
+        verify(emailSender).sendGroupEmail(1, new Person[] {new Person("Wes")});
+    }
+
+    @Test
+    public void shouldNotThrowNPEWhenCloningNulls() throws Exception {
+
+        EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());
+
+        // 1. Pass a null into a mock that "ClonesArguments"
+        emailSender.sendEmail(1, (Person) null);
+
+        // 2. Verify that the null argument was captured
+        verify(emailSender).sendEmail(eq(1), (Person) isNull());
+    }
+
     public class Person {
 
         private final String name;
@@ -74,36 +102,29 @@ public class CloningParameterTest extends TestBase {
 
         @Override
         public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
+            if (this == obj) return true;
+            if (obj == null) return false;
+            if (getClass() != obj.getClass()) return false;
             Person other = (Person) obj;
-            if (!getOuterType().equals(other.getOuterType()))
-                return false;
-            if (emailSent != other.emailSent)
-                return false;
+            if (!getOuterType().equals(other.getOuterType())) return false;
+            if (emailSent != other.emailSent) return false;
             if (name == null) {
-                if (other.name != null)
-                    return false;
-            } else if (!name.equals(other.name))
-                return false;
+                if (other.name != null) return false;
+            } else if (!name.equals(other.name)) return false;
             return true;
         }
 
         private CloningParameterTest getOuterType() {
             return CloningParameterTest.this;
         }
-
     }
 
     public interface EmailSender {
 
         void sendEmail(int i, Person person);
 
-        List<?> getAllEmails(Person person);
+        void sendGroupEmail(int i, Person[] persons);
 
+        List<?> getAllEmails(Person person);
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java b/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
index 5622b54..5e39714 100644
--- a/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
+++ b/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
@@ -4,23 +4,28 @@
  */
 package org.mockitousage.stubbing;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.InOrder;
-import org.mockito.exceptions.verification.TooManyActualInvocations;
-import org.mockitoutil.TestBase;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.*;
 
-import javax.net.SocketFactory;
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.util.List;
 import java.util.Locale;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.*;
+import javax.net.SocketFactory;
 
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.MockSettings;
+import org.mockito.exceptions.verification.TooManyActualInvocations;
+import org.mockitoutil.TestBase;
 
 public class DeepStubbingTest extends TestBase {
 
@@ -74,6 +79,20 @@ public class DeepStubbingTest extends TestBase {
 
     interface Second extends List<String> {}
 
+    class BaseClassGenerics<A, B> {}
+
+    class ReversedGenerics<A, B> extends BaseClassGenerics<A, B> {
+        ReversedGenerics<B, A> reverse() {
+            return null;
+        }
+
+        A finalMethod() {
+            return null;
+        }
+    }
+
+    class SuperOfReversedGenerics extends ReversedGenerics<String, Long> {}
+
     @Test
     public void myTest() throws Exception {
         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);
@@ -147,7 +166,7 @@ public class DeepStubbingTest extends TestBase {
     public void withAnyPatternArguments() throws Exception {
         OutputStream out = new ByteArrayOutputStream();
 
-        //TODO: should not use javax in case it changes
+        // TODO: should not use javax in case it changes
         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);
         when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);
 
@@ -204,56 +223,80 @@ public class DeepStubbingTest extends TestBase {
         assertEquals(a, sf.createSocket("stackoverflow.com", 80).getPort());
     }
 
+    @Test
+    public void unnamed_to_string() {
+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);
+        assertNotNull(sf.toString());
+    }
+
+    @Test
+    public void named_to_string() {
+        MockSettings settings =
+                withSettings().name("name of mock").defaultAnswer(RETURNS_DEEP_STUBS);
+        SocketFactory sf = mock(SocketFactory.class, settings);
+        assertEquals("name of mock", sf.toString());
+    }
+
     Person person = mock(Person.class, RETURNS_DEEP_STUBS);
 
     @Test
-    public void shouldStubbingBasicallyWorkFine() throws Exception {
-        //given
+    public void shouldStubbingBasicallyWorkFine() {
+        // given
         given(person.getAddress().getStreet().getName()).willReturn("Norymberska");
 
-        //when
+        // when
         String street = person.getAddress().getStreet().getName();
 
-        //then
+        // then
         assertEquals("Norymberska", street);
     }
 
     @Test
-    public void shouldVerificationBasicallyWorkFine() throws Exception {
-        //given
+    public void shouldVerificationBasicallyWorkFine() {
+        // given
         person.getAddress().getStreet().getName();
 
-        //then
+        // then
         verify(person.getAddress().getStreet()).getName();
     }
 
     @Test
-    public void verification_work_with_argument_Matchers_in_nested_calls() throws Exception {
-        //given
+    public void verification_work_with_argument_Matchers_in_nested_calls() {
+        // given
         person.getAddress("111 Mock Lane").getStreet();
         person.getAddress("111 Mock Lane").getStreet(Locale.ITALIAN).getName();
 
-        //then
+        // then
         verify(person.getAddress(anyString())).getStreet();
         verify(person.getAddress(anyString()).getStreet(Locale.CHINESE), never()).getName();
         verify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();
     }
 
     @Test
-    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() throws Exception {
+    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
 
         person.getAddress("the docks").getStreet().getName();
 
-        assertSame(person.getAddress("the docks").getStreet(), person.getAddress(anyString()).getStreet());
-        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(anyString()).getStreet());
-        assertSame(person.getAddress("the docks").getStreet(), person.getAddress("the docks").getStreet());
-        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress("the docks").getStreet());
-        assertSame(person.getAddress("111 Mock Lane").getStreet(), person.getAddress("the docks").getStreet());
+        assertSame(
+                person.getAddress("the docks").getStreet(),
+                person.getAddress(anyString()).getStreet());
+        assertSame(
+                person.getAddress(anyString()).getStreet(),
+                person.getAddress(anyString()).getStreet());
+        assertSame(
+                person.getAddress("the docks").getStreet(),
+                person.getAddress("the docks").getStreet());
+        assertSame(
+                person.getAddress(anyString()).getStreet(),
+                person.getAddress("the docks").getStreet());
+        assertSame(
+                person.getAddress("111 Mock Lane").getStreet(),
+                person.getAddress("the docks").getStreet());
     }
 
     @Test
-    public void times_never_atLeast_atMost_verificationModes_should_work() throws Exception {
+    public void times_never_atLeast_atMost_verificationModes_should_work() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
 
         person.getAddress("the docks").getStreet().getName();
@@ -263,12 +306,11 @@ public class DeepStubbingTest extends TestBase {
 
         verify(person.getAddress("the docks").getStreet(), times(3)).getName();
         verify(person.getAddress("the docks").getStreet(Locale.CHINESE), never()).getName();
-        verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atMost(1)).getName();
+        verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atMostOnce()).getName();
     }
 
-
     @Test
-    public void inOrder_only_work_on_the_very_last_mock_but_it_works() throws Exception {
+    public void inOrder_only_work_on_the_very_last_mock_but_it_works() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
         when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");
         when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");
@@ -278,19 +320,20 @@ public class DeepStubbingTest extends TestBase {
         person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();
         person.getAddress("the docks").getStreet(Locale.CHINESE).getName();
 
-        InOrder inOrder = inOrder(
-                person.getAddress("the docks").getStreet(),
-                person.getAddress("the docks").getStreet(Locale.CHINESE),
-                person.getAddress("the docks").getStreet(Locale.ITALIAN)
-        );
+        InOrder inOrder =
+                inOrder(
+                        person.getAddress("the docks").getStreet(),
+                        person.getAddress("the docks").getStreet(Locale.CHINESE),
+                        person.getAddress("the docks").getStreet(Locale.ITALIAN));
         inOrder.verify(person.getAddress("the docks").getStreet(), times(1)).getName();
         inOrder.verify(person.getAddress("the docks").getStreet()).getLongName();
-        inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atLeast(1)).getName();
+        inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atLeast(1))
+                .getName();
         inOrder.verify(person.getAddress("the docks").getStreet(Locale.CHINESE)).getName();
     }
 
     @Test
-    public void verificationMode_only_work_on_the_last_returned_mock() throws Exception {
+    public void verificationMode_only_work_on_the_last_returned_mock() {
         // 1st invocation on Address mock (stubbing)
         when(person.getAddress("the docks").getStreet().getName()).thenReturn("deep");
 
@@ -304,19 +347,17 @@ public class DeepStubbingTest extends TestBase {
             verify(person.getAddress("the docks"), times(1)).getStreet();
             fail();
         } catch (TooManyActualInvocations e) {
-            Assertions.assertThat(e.getMessage())
-                    .contains("Wanted 1 time")
-                    .contains("But was 3 times");
+            assertThat(e.getMessage()).contains("Wanted 1 time").contains("But was 3 times");
         }
     }
 
     @Test
-    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {
-        //when
+    public void shouldFailGracefullyWhenClassIsFinal() {
+        // when
         FinalClass value = new FinalClass();
         given(person.getFinalClass()).willReturn(value);
 
-        //then
+        // then
         assertEquals(value, person.getFinalClass());
     }
 
@@ -326,4 +367,13 @@ public class DeepStubbingTest extends TestBase {
         assertNull(first.getString());
         assertNull(first.getSecond().get(0));
     }
+
+    @Test
+    public void deep_stub_does_not_stack_overflow_on_reversed_generics() {
+        SuperOfReversedGenerics mock = mock(SuperOfReversedGenerics.class, RETURNS_DEEP_STUBS);
+
+        when((Object) mock.reverse().finalMethod()).thenReturn(5L);
+
+        assertThat(mock.reverse().finalMethod()).isEqualTo(5L);
+    }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/MisusingStubbingTest.java b/src/test/java/org/mockitousage/stubbing/MisusingStubbingTest.java
new file mode 100644
index 0000000..556bc56
--- /dev/null
+++ b/src/test/java/org/mockitousage/stubbing/MisusingStubbingTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.stubbing;
+
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.validateMockitoUsage;
+
+import org.junit.Test;
+import org.mockitoutil.TestBase;
+
+public class MisusingStubbingTest extends TestBase {
+
+    @Test
+    public void clean_state_after_not_a_mock() {
+        // when
+        assertThatThrownBy(() -> doReturn(100).when("not a mock"));
+
+        // then
+        validateMockitoUsage();
+    }
+
+    @Test
+    public void clean_state_after_null_passed() {
+        // when
+        assertThatThrownBy(() -> doReturn(100).when(null));
+
+        // then
+        validateMockitoUsage();
+    }
+}
diff --git a/src/test/java/org/mockitousage/stubbing/ReturningDefaultValuesTest.java b/src/test/java/org/mockitousage/stubbing/ReturningDefaultValuesTest.java
index 5629898..fb2592c 100644
--- a/src/test/java/org/mockitousage/stubbing/ReturningDefaultValuesTest.java
+++ b/src/test/java/org/mockitousage/stubbing/ReturningDefaultValuesTest.java
@@ -2,22 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class ReturningDefaultValuesTest extends TestBase {
diff --git a/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java b/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java
new file mode 100644
index 0000000..38f5ff6
--- /dev/null
+++ b/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.stubbing;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
+
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.Answers;
+
+// Reproduces issue #1551
+public class SmartNullsGenericBugTest {
+
+    @Test
+    public void smart_nulls_generic_bug_generic_T() {
+        ConcreteDao concreteDao =
+                mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final Entity result = concreteDao.findById();
+
+        Assertions.assertThat(result).as("#1551").isNotNull();
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M() {
+        ConcreteDao concreteDao =
+                mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.find();
+
+        Assertions.assertThat(other).as("#1551 - CCannot resolve type").isNull();
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M_provided_in_args() {
+        ConcreteDao concreteDao =
+                mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.findArgs(1, "plop");
+
+        Assertions.assertThat(other).as("#1551").isEqualTo("");
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M_provided_as_varargs() {
+        ConcreteDao concreteDao =
+                mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.findVarargs(42, "plip", "plop");
+
+        Assertions.assertThat(other).as("#1551").isEqualTo("");
+    }
+
+    static class AbstractDao<T> {
+        T findById() {
+            return null;
+        }
+
+        <M> M find() {
+            return null;
+        }
+
+        <M> M findArgs(int idx, M arg) {
+            return null;
+        }
+
+        <M> M findVarargs(int idx, M... args) {
+            return null;
+        }
+    }
+
+    static class Entity {}
+
+    static class ConcreteDao extends AbstractDao<Entity> {}
+}
diff --git a/src/test/java/org/mockitousage/stubbing/SmartNullsStubbingTest.java b/src/test/java/org/mockitousage/stubbing/SmartNullsStubbingTest.java
index 9b3dc86..cd98a0d 100644
--- a/src/test/java/org/mockitousage/stubbing/SmartNullsStubbingTest.java
+++ b/src/test/java/org/mockitousage/stubbing/SmartNullsStubbingTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
@@ -13,11 +17,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class SmartNullsStubbingTest extends TestBase {
 
     private IMethods mock;
@@ -42,6 +41,15 @@ public class SmartNullsStubbingTest extends TestBase {
         }
     }
 
+    @Test
+    public void should_not_throw_NPE_when_verifying_with_returns_smart_nulls() {
+        Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
+
+        when(mock.returnsFromArg(null)).thenReturn("Does not fail.");
+
+        assertThat((Object) mock.returnsFromArg(null)).isEqualTo("Does not fail.");
+    }
+
     interface Bar {
         void boo();
     }
@@ -59,6 +67,10 @@ public class SmartNullsStubbingTest extends TestBase {
             return null;
         }
 
+        <T> T returnsFromArg(T arg) {
+            return arg;
+        }
+
         void boo() {}
     }
 
@@ -69,7 +81,8 @@ public class SmartNullsStubbingTest extends TestBase {
         try {
             foo.boo();
             fail();
-        } catch (SmartNullPointerException e) {}
+        } catch (SmartNullPointerException e) {
+        }
     }
 
     @Test
@@ -79,10 +92,10 @@ public class SmartNullsStubbingTest extends TestBase {
         try {
             bar.boo();
             fail();
-        } catch (SmartNullPointerException e) {}
+        } catch (SmartNullPointerException e) {
+        }
     }
 
-
     @Test
     public void shouldReturnOrdinaryEmptyValuesForOrdinaryTypes() throws Exception {
         IMethods mock = mock(IMethods.class, RETURNS_SMART_NULLS);
@@ -99,13 +112,14 @@ public class SmartNullsStubbingTest extends TestBase {
         try {
             verify(mock).simpleMethod(smartNull);
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 
     @Test
     public void shouldNotThrowSmartNullPointerOnObjectMethods() {
         Object smartNull = mock.objectReturningMethod();
-        smartNull.toString();
+        String ignored = smartNull.toString();
     }
 
     @Test
@@ -124,7 +138,8 @@ public class SmartNullsStubbingTest extends TestBase {
     @Test
     public void shouldShowParametersWhenParamsAreHuge() {
         Foo foo = mock(Foo.class, RETURNS_SMART_NULLS);
-        String longStr = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.";
+        String longStr =
+                "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.";
         Bar smartNull = foo.getBarWithParams(10, longStr);
 
         try {
diff --git a/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java b/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
index 724239e..71ae857 100644
--- a/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockitousage.stubbing;
 
+import static org.mockito.BDDMockito.given;
+import static org.mockitoutil.ConcurrentTesting.concurrently;
+import static org.mockitoutil.JUnitResultAssert.assertThat;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
@@ -17,62 +24,71 @@ import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
-
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import static org.mockito.BDDMockito.given;
-import static org.mockitoutil.ConcurrentTesting.concurrently;
-import static org.mockitoutil.JUnitResultAssert.assertThat;
+import org.mockitousage.strictness.ProductionCode;
 
 public class StrictStubbingEndToEndTest {
 
     JUnitCore junit = new JUnitCore();
 
-    @After public void after() {
+    @After
+    public void after() {
         new StateMaster().clearMockitoListeners();
     }
 
-    @Test public void finish_mocking_exception_does_not_hide_the_exception_from_test() {
+    @Test
+    public void finish_mocking_exception_does_not_hide_the_exception_from_test() {
         Result result = junit.run(UnnecessaryStubbing.class);
         assertThat(result)
-                //both exceptions are reported to JUnit:
+                // both exceptions are reported to JUnit:
                 .fails("unnecessary_stubbing", IllegalStateException.class)
                 .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
     }
 
-    @Test public void does_not_report_unused_stubbing_if_mismatch_reported() {
+    @Test
+    public void does_not_report_unused_stubbing_if_mismatch_reported() {
         Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
         assertThat(result).fails(1, PotentialStubbingProblem.class);
     }
 
-    @Test public void strict_stubbing_does_not_leak_to_other_tests() {
-        Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
-        //all tests pass, lenient test cases contain incorrect stubbing
+    @Test
+    public void strict_stubbing_does_not_leak_to_other_tests() {
+        Result result =
+                junit.run(
+                        LenientStrictness1.class,
+                        StrictStubsPassing.class,
+                        LenientStrictness2.class);
+        // all tests pass, lenient test cases contain incorrect stubbing
         assertThat(result).succeeds(5);
     }
 
-    @Test public void detects_unfinished_session() {
+    @Test
+    public void detects_unfinished_session() {
         Result result = junit.run(UnfinishedMocking.class);
         assertThat(result)
-            .fails(UnfinishedMockingSessionException.class, "\n" +
-                "Unfinished mocking session detected.\n" +
-                "Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
-                "For examples of correct usage see javadoc for MockitoSession class.");
+                .fails(
+                        UnfinishedMockingSessionException.class,
+                        "\n"
+                                + "Unfinished mocking session detected.\n"
+                                + "Previous MockitoSession was not concluded with 'finishMocking()'.\n"
+                                + "For examples of correct usage see javadoc for MockitoSession class.");
     }
 
-    @Test public void concurrent_sessions_in_different_threads() throws Exception {
+    @Test
+    public void concurrent_sessions_in_different_threads() throws Exception {
         final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
-        concurrently(new Runnable() {
-                         public void run() {
-                             results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
-                         }
-                     }, new Runnable() {
-                         public void run() {
-                             results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
-                         }
-                     }
-        );
+        concurrently(
+                new Runnable() {
+                    public void run() {
+                        results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
+                    }
+                },
+                new Runnable() {
+                    public void run() {
+                        results.put(
+                                ReportMismatchButNotUnusedStubbing.class,
+                                junit.run(ReportMismatchButNotUnusedStubbing.class));
+                    }
+                });
 
         assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
         assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
@@ -80,13 +96,19 @@ public class StrictStubbingEndToEndTest {
 
     public static class UnnecessaryStubbing {
         @Mock IMethods mock;
-        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
-
-        @After public void after() {
+        MockitoSession mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
+
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void unnecessary_stubbing() {
+        @Test
+        public void unnecessary_stubbing() {
             given(mock.simpleMethod("1")).willReturn("one");
             throw new IllegalStateException();
         }
@@ -94,27 +116,39 @@ public class StrictStubbingEndToEndTest {
 
     public static class ReportMismatchButNotUnusedStubbing {
         @Mock IMethods mock;
-        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
-
-        @After public void after() {
+        MockitoSession mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
+
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void mismatch() {
+        @Test
+        public void mismatch() {
             given(mock.simpleMethod(1)).willReturn("");
-            mock.simpleMethod(2);
+            ProductionCode.simpleMethod(mock, 2);
         }
     }
 
     public static class StrictStubsPassing {
         @Mock IMethods mock;
-        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
-
-        @After public void after() {
+        MockitoSession mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
+
+        @After
+        public void after() {
             mockito.finishMocking();
         }
 
-        @Test public void used() {
+        @Test
+        public void used() {
             given(mock.simpleMethod(1)).willReturn("");
             mock.simpleMethod(1);
         }
@@ -123,11 +157,13 @@ public class StrictStubbingEndToEndTest {
     public static class LenientStrictness1 {
         @Mock IMethods mock = Mockito.mock(IMethods.class);
 
-        @Test public void unused() {
+        @Test
+        public void unused() {
             given(mock.simpleMethod(1)).willReturn("");
         }
 
-        @Test public void mismatch() {
+        @Test
+        public void mismatch() {
             given(mock.simpleMethod(2)).willReturn("");
             mock.simpleMethod(3);
         }
@@ -136,11 +172,13 @@ public class StrictStubbingEndToEndTest {
     public static class LenientStrictness2 {
         @Mock IMethods mock = Mockito.mock(IMethods.class);
 
-        @Test public void unused() {
+        @Test
+        public void unused() {
             given(mock.simpleMethod(1)).willReturn("");
         }
 
-        @Test public void mismatch() {
+        @Test
+        public void mismatch() {
             given(mock.simpleMethod(2)).willReturn("");
             mock.simpleMethod(3);
         }
@@ -148,13 +186,19 @@ public class StrictStubbingEndToEndTest {
 
     public static class UnfinishedMocking {
         @Mock IMethods mock;
-        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
-
-        @Test public void unused() {
+        MockitoSession mockito =
+                Mockito.mockitoSession()
+                        .initMocks(this)
+                        .strictness(Strictness.STRICT_STUBS)
+                        .startMocking();
+
+        @Test
+        public void unused() {
             given(mock.simpleMethod("1")).willReturn("one");
         }
 
-        @Test public void unused2() {
+        @Test
+        public void unused2() {
             given(mock.simpleMethod("1")).willReturn("one");
         }
     }
diff --git a/src/test/java/org/mockitousage/stubbing/StrictStubbingTest.java b/src/test/java/org/mockitousage/stubbing/StrictStubbingTest.java
index 2f40a2d..dfc0323 100644
--- a/src/test/java/org/mockitousage/stubbing/StrictStubbingTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StrictStubbingTest.java
@@ -4,6 +4,11 @@
  */
 package org.mockitousage.stubbing;
 
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockitoutil.ThrowableAssert.assertThat;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -14,88 +19,102 @@ import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
-
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockitoutil.ThrowableAssert.assertThat;
+import org.mockitousage.strictness.ProductionCode;
 
 public class StrictStubbingTest {
 
     @Mock IMethods mock;
 
-    MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+    MockitoSession mockito =
+            Mockito.mockitoSession()
+                    .initMocks(this)
+                    .strictness(Strictness.STRICT_STUBS)
+                    .startMocking();
 
-    @After public void after() {
-        //Some tests already invoke below but that's ok
+    @After
+    public void after() {
+        // Some tests already invoke below but that's ok
         mockito.finishMocking();
     }
 
-    @Test public void no_interactions() throws Throwable {
-        //expect no exception
+    @Test
+    public void no_interactions() throws Throwable {
+        // expect no exception
         mockito.finishMocking();
     }
 
-    @Test public void few_interactions() throws Throwable {
+    @Test
+    public void few_interactions() throws Throwable {
         mock.simpleMethod(100);
         mock.otherMethod();
     }
 
-    @Test public void few_verified_interactions() throws Throwable {
-        //when
+    @Test
+    public void few_verified_interactions() throws Throwable {
+        // when
         mock.simpleMethod(100);
         mock.otherMethod();
 
-        //and
+        // and
         verify(mock).simpleMethod(100);
         verify(mock).otherMethod();
         verifyNoMoreInteractions(mock);
     }
 
-    @Test public void stubbed_method_is_implicitly_verified() throws Throwable {
-        //when
+    @Test
+    public void stubbed_method_is_implicitly_verified() throws Throwable {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
         mock.simpleMethod(100);
 
-        //no exceptions:
+        // no exceptions:
         verifyNoMoreInteractions(mock);
     }
 
-    @Test public void unused_stubbed_is_not_implicitly_verified() throws Throwable {
-        //when
+    @Test
+    public void unused_stubbed_is_not_implicitly_verified() throws Throwable {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
         mock.simpleMethod(100); // <- implicitly verified
         mock.simpleMethod(200); // <- unverified
 
-        //expect
-        assertThat(new Runnable() {
-            public void run() {
-                verifyNoMoreInteractions(mock);
-            }
-        }).throwsException(NoInteractionsWanted.class);
+        // expect
+        assertThat(
+                        new Runnable() {
+                            public void run() {
+                                verifyNoMoreInteractions(mock);
+                            }
+                        })
+                .throwsException(NoInteractionsWanted.class);
     }
 
-    @Test public void stubbing_argument_mismatch() throws Throwable {
-        //when
+    @Test
+    public void stubbing_argument_mismatch() throws Throwable {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
 
-        //stubbing argument mismatch is detected
-        assertThat(new Runnable() {
-            public void run() {
-                mock.simpleMethod(200);
-            }
-        }).throwsException(PotentialStubbingProblem.class);
+        // stubbing argument mismatch is detected
+        assertThat(
+                        new Runnable() {
+                            public void run() {
+                                ProductionCode.simpleMethod(mock, 200);
+                            }
+                        })
+                .throwsException(PotentialStubbingProblem.class);
     }
 
-    @Test public void unused_stubbing() throws Throwable {
-        //when
+    @Test
+    public void unused_stubbing() throws Throwable {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
 
-        //unused stubbing is reported
-        assertThat(new Runnable() {
-            public void run() {
-                mockito.finishMocking();
-            }
-        }).throwsException(UnnecessaryStubbingException.class);
+        // unused stubbing is reported
+        assertThat(
+                        new Runnable() {
+                            public void run() {
+                                mockito.finishMocking();
+                            }
+                        })
+                .throwsException(UnnecessaryStubbingException.class);
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java
index 47c2172..0d64e2b 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java
@@ -2,29 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
 public class StubbingConsecutiveAnswersTest extends TestBase {
 
-    @Mock
-    private IMethods mock;
+    @Mock private IMethods mock;
 
     @Test
-    public void should_return_consecutive_values() throws Exception {
-        when(mock.simpleMethod())
-                .thenReturn("one")
-                .thenReturn("two")
-                .thenReturn("three");
+    public void should_return_consecutive_values() {
+        when(mock.simpleMethod()).thenReturn("one").thenReturn("two").thenReturn("three");
 
         assertEquals("one", mock.simpleMethod());
         assertEquals("two", mock.simpleMethod());
@@ -34,7 +34,7 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_values_for_two_nulls() throws Exception {
+    public void should_return_consecutive_values_for_two_nulls() {
         when(mock.simpleMethod()).thenReturn(null, (String[]) null);
 
         assertNull(mock.simpleMethod());
@@ -42,7 +42,7 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_values_first_var_arg_null() throws Exception {
+    public void should_return_consecutive_values_first_var_arg_null() {
         when(mock.simpleMethod()).thenReturn("one", (String) null);
 
         assertEquals("one", mock.simpleMethod());
@@ -51,7 +51,7 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_values_var_arg_null() throws Exception {
+    public void should_return_consecutive_values_var_arg_null() {
         when(mock.simpleMethod()).thenReturn("one", (String[]) null);
 
         assertEquals("one", mock.simpleMethod());
@@ -60,7 +60,7 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_values_var_args_contain_null() throws Exception {
+    public void should_return_consecutive_values_var_args_contain_null() {
         when(mock.simpleMethod()).thenReturn("one", "two", null);
 
         assertEquals("one", mock.simpleMethod());
@@ -70,7 +70,7 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_values_set_by_shorten_then_return_method() throws Exception {
+    public void should_return_consecutive_values_set_by_shorten_then_return_method() {
         when(mock.simpleMethod()).thenReturn("one", "two", "three");
 
         assertEquals("one", mock.simpleMethod());
@@ -81,12 +81,14 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
     }
 
     @Test
-    public void should_return_consecutive_value_and_throw_exceptions_set_by_shorten_return_methods() {
-        when(mock.simpleMethod()).thenReturn("zero")
-                                 .thenReturn("one", "two")
-                                 .thenThrow(new NullPointerException(), new RuntimeException())
-                                 .thenReturn("three")
-                                 .thenThrow(new IllegalArgumentException());
+    public void
+            should_return_consecutive_value_and_throw_exceptions_set_by_shorten_return_methods() {
+        when(mock.simpleMethod())
+                .thenReturn("zero")
+                .thenReturn("one", "two")
+                .thenThrow(new NullPointerException(), new RuntimeException())
+                .thenReturn("three")
+                .thenThrow(new IllegalArgumentException());
 
         assertEquals("zero", mock.simpleMethod());
         assertEquals("one", mock.simpleMethod());
@@ -94,119 +96,141 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
         try {
             mock.simpleMethod();
             fail();
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
         assertEquals("three", mock.simpleMethod());
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
     }
 
     @Test
-    public void should_throw_consecutively() throws Exception {
-        when(mock.simpleMethod()).thenThrow(new RuntimeException())
-                                 .thenThrow(new IllegalArgumentException())
-                                 .thenThrow(new NullPointerException());
+    public void should_throw_consecutively() {
+        when(mock.simpleMethod())
+                .thenThrow(new RuntimeException())
+                .thenThrow(new IllegalArgumentException())
+                .thenThrow(new NullPointerException());
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
     }
 
     @Test
-    public void should_throw_consecutively_set_by_shorten_then_throw_method() throws Exception {
-        when(mock.simpleMethod()).thenThrow(new RuntimeException(),
-                                            new IllegalArgumentException(),
-                                            new NullPointerException());
+    public void should_throw_consecutively_set_by_shorten_then_throw_method() {
+        when(mock.simpleMethod())
+                .thenThrow(
+                        new RuntimeException(),
+                        new IllegalArgumentException(),
+                        new NullPointerException());
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
     }
 
     @Test
-    public void should_throw_classes() throws Exception {
+    public void should_throw_classes() {
         // Unavoidable JDK7+ 'unchecked generic array creation' warning
         when(mock.simpleMethod()).thenThrow(IllegalArgumentException.class);
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
     }
 
     @Test
     @SuppressWarnings("unchecked")
-    public void should_throw_consecutively_classes_set_by_shorten_then_throw_method() throws Exception {
+    public void should_throw_consecutively_classes_set_by_shorten_then_throw_method() {
         // Unavoidable JDK7+ 'unchecked generic array creation' warning
-        when(mock.simpleMethod()).thenThrow(RuntimeException.class,
-                                            IllegalArgumentException.class,
-                                            NullPointerException.class);
+        when(mock.simpleMethod())
+                .thenThrow(
+                        RuntimeException.class,
+                        IllegalArgumentException.class,
+                        NullPointerException.class);
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
     }
 
     @Test
-    public void should_mix_consecutive_returns_with_exceptions() throws Exception {
+    public void should_mix_consecutive_returns_with_exceptions() {
         when(mock.simpleMethod())
                 .thenThrow(new IllegalArgumentException())
                 .thenReturn("one")
@@ -216,75 +240,87 @@ public class StubbingConsecutiveAnswersTest extends TestBase {
         try {
             mock.simpleMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         assertEquals("one", mock.simpleMethod());
 
         try {
             mock.simpleMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         assertEquals(null, mock.simpleMethod());
         assertEquals(null, mock.simpleMethod());
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_validate_consecutive_exception() throws Exception {
-        when(mock.simpleMethod())
-                .thenReturn("one")
-                .thenThrow(new Exception());
+    @Test
+    public void should_validate_consecutive_exception() {
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.simpleMethod()).thenReturn("one").thenThrow(new Exception());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Checked exception is invalid for this method!",
+                        "Invalid: java.lang.Exception");
     }
 
     @Test
-    public void should_stub_void_method_and_continue_throwing() throws Exception {
+    public void should_stub_void_method_and_continue_throwing() {
         doThrow(new IllegalArgumentException())
-        .doNothing()
-        .doThrow(new NullPointerException())
-        .when(mock).voidMethod();
+                .doNothing()
+                .doThrow(new NullPointerException())
+                .when(mock)
+                .voidMethod();
 
         try {
             mock.voidMethod();
             fail();
-        } catch (IllegalArgumentException expected) { }
+        } catch (IllegalArgumentException expected) {
+        }
 
         mock.voidMethod();
 
         try {
             mock.voidMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         try {
             mock.voidMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
     }
 
     @Test
-    public void should_stub_void_method() throws Exception {
-        doNothing()
-        .doThrow(new NullPointerException())
-        .doNothing()
-        .when(mock)
-        .voidMethod();
+    public void should_stub_void_method() {
+        doNothing().doThrow(new NullPointerException()).doNothing().when(mock).voidMethod();
 
         mock.voidMethod();
 
         try {
             mock.voidMethod();
             fail();
-        } catch (NullPointerException expected) { }
+        } catch (NullPointerException expected) {
+        }
 
         mock.voidMethod();
         mock.voidMethod();
     }
 
-    @Test(expected = MockitoException.class)
-    public void should_validate_consecutive_exception_for_void_method() throws Exception {
-        doNothing()
-        .doThrow(new Exception())
-        .when(mock)
-        .voidMethod();
+    @Test
+    public void should_validate_consecutive_exception_for_void_method() {
+        assertThatThrownBy(
+                        () -> {
+                            doNothing().doThrow(new Exception()).when(mock).voidMethod();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Checked exception is invalid for this method!",
+                        "Invalid: java.lang.Exception");
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingReturnsSelfTest.java b/src/test/java/org/mockitousage/stubbing/StubbingReturnsSelfTest.java
index 5362fa8..4e75dfb 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingReturnsSelfTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingReturnsSelfTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockitousage.stubbing;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.*;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
+import org.junit.Test;
 
 public class StubbingReturnsSelfTest {
 
@@ -150,6 +150,5 @@ public class StubbingReturnsSelfTest {
         public String request() {
             return uri + headers.toString();
         }
-
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java b/src/test/java/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java
index f8169b0..53d9029 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java
@@ -2,63 +2,72 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
-import org.assertj.core.api.Assertions;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+import java.io.IOException;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.mockitousage.IMethods;
 import org.mockitousage.MethodsImpl;
 import org.mockitoutil.TestBase;
 
-import java.io.IOException;
-
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 @SuppressWarnings("serial")
 public class StubbingUsingDoReturnTest extends TestBase {
 
     @Mock private IMethods mock;
 
-    @After public void reset_state() {
+    @After
+    public void reset_state() {
         super.resetState();
     }
 
     @Test
-    public void should_stub() throws Exception {
+    public void should_stub() {
         doReturn("foo").when(mock).simpleMethod();
         doReturn("bar").when(mock).simpleMethod();
 
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("bar");
+        assertThat(mock.simpleMethod()).isEqualTo("bar");
     }
 
     @Test
-    public void should_stub_with_args() throws Exception {
+    public void should_stub_with_args() {
         doReturn("foo").when(mock).simpleMethod("foo");
         doReturn("bar").when(mock).simpleMethod(eq("one"), anyInt());
 
-        Assertions.assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
-        Assertions.assertThat(mock.simpleMethod("one", 234)).isEqualTo("bar");
-        Assertions.assertThat(mock.simpleMethod("xxx", 234)).isEqualTo(null);
+        assertThat(mock.simpleMethod("foo")).isEqualTo("foo");
+        assertThat(mock.simpleMethod("one", 234)).isEqualTo("bar");
+        assertThat(mock.simpleMethod("xxx", 234)).isNull();
     }
 
     class FooRuntimeException extends RuntimeException {}
 
     @Test
-    public void should_stub_with_throwable() throws Exception {
+    public void should_stub_with_throwable() {
         doThrow(new FooRuntimeException()).when(mock).voidMethod();
         try {
             mock.voidMethod();
             fail();
-        } catch (FooRuntimeException e) {}
+        } catch (FooRuntimeException e) {
+        }
     }
 
     @Test
@@ -68,13 +77,14 @@ public class StubbingUsingDoReturnTest extends TestBase {
         try {
             mock.throwsIOException(0);
             fail();
-        } catch (IOException e) {}
+        } catch (IOException e) {
+        }
     }
 
     class FooCheckedException extends Exception {}
 
     @Test
-    public void should_detect_invalid_checked_exception() throws Exception {
+    public void should_detect_invalid_checked_exception() {
         try {
             doThrow(new FooCheckedException()).when(mock).throwsIOException(0);
             fail();
@@ -84,19 +94,17 @@ public class StubbingUsingDoReturnTest extends TestBase {
     }
 
     @Test
-    public void should_scream_when_return_set_for_void() throws Exception {
+    public void should_scream_when_return_set_for_void() {
         try {
             doReturn("foo").when(mock).voidMethod();
             fail();
         } catch (MockitoException e) {
-            assertThat(e)
-                .hasMessageContaining("void method")
-                .hasMessageContaining("cannot");
+            assertThat(e).hasMessageContaining("void method").hasMessageContaining("cannot");
         }
     }
 
     @Test
-    public void should_scream_when_not_a_mock_passed() throws Exception {
+    public void should_scream_when_not_a_mock_passed() {
         try {
             doReturn("foo").when("foo").toString();
             fail();
@@ -106,7 +114,7 @@ public class StubbingUsingDoReturnTest extends TestBase {
     }
 
     @Test
-    public void should_scream_when_null_passed() throws Exception {
+    public void should_scream_when_null_passed() {
         try {
             doReturn("foo").when((Object) null).toString();
             fail();
@@ -117,19 +125,17 @@ public class StubbingUsingDoReturnTest extends TestBase {
 
     @Test
     public void should_allow_chained_stubbing() {
-        doReturn("foo")
-                .doThrow(new RuntimeException())
-                .doReturn("bar")
-                .when(mock).simpleMethod();
+        doReturn("foo").doThrow(new RuntimeException()).doReturn("bar").when(mock).simpleMethod();
 
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("foo");
+        assertThat(mock.simpleMethod()).isEqualTo("foo");
         try {
             mock.simpleMethod();
             fail();
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
 
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("bar");
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("bar");
+        assertThat(mock.simpleMethod()).isEqualTo("bar");
+        assertThat(mock.simpleMethod()).isEqualTo("bar");
     }
 
     @Test
@@ -137,68 +143,67 @@ public class StubbingUsingDoReturnTest extends TestBase {
         doReturn("foo", "bar")
                 .doThrow(new RuntimeException())
                 .doReturn(430L, new byte[0], "qix")
-                .when(mock).objectReturningMethodNoArgs();
+                .when(mock)
+                .objectReturningMethodNoArgs();
 
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("foo");
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("bar");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("foo");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("bar");
         try {
             mock.objectReturningMethodNoArgs();
             fail("exception not raised");
-        } catch (RuntimeException expected) { }
+        } catch (RuntimeException expected) {
+        }
 
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(430L);
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");
-        Assertions.assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(430L);
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");
+        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");
     }
 
     @Test
-    public void should_allow_do_call_real_method_in_chained_stubbing() throws Exception {
+    public void should_allow_do_call_real_method_in_chained_stubbing() {
         MethodsImpl methods = mock(MethodsImpl.class);
-        doReturn("A").doCallRealMethod()
-                .when(methods).simpleMethod();
+        doReturn("A").doCallRealMethod().when(methods).simpleMethod();
 
-        Assertions.assertThat(methods.simpleMethod()).isEqualTo("A");
-        Assertions.assertThat(methods.simpleMethod()).isEqualTo(null);
+        assertThat(methods.simpleMethod()).isEqualTo("A");
+        assertThat(methods.simpleMethod()).isNull();
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void should_allow_chained_stubbing_with_exception_class() throws Exception {
+    @Test
+    public void should_allow_chained_stubbing_with_exception_class() {
         doReturn("whatever").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();
 
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("whatever");
-        mock.simpleMethod();
+        assertThat(mock.simpleMethod()).isEqualTo("whatever");
+        assertThatThrownBy(
+                        () -> {
+                            mock.simpleMethod();
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
     }
 
     @Test
     public void should_allow_chained_stubbing_on_void_methods() {
-        doNothing()
-                .doNothing()
-                .doThrow(new RuntimeException())
-                .when(mock).voidMethod();
+        doNothing().doNothing().doThrow(new RuntimeException()).when(mock).voidMethod();
 
         mock.voidMethod();
         mock.voidMethod();
         try {
             mock.voidMethod();
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
         try {
             mock.voidMethod();
             fail();
-        } catch (RuntimeException e) {}
+        } catch (RuntimeException e) {
+        }
     }
 
     @Test
     public void should_stub_with_generic_answer() {
-        doAnswer(new Answer<Object>() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return "foo";
-            }
-        })
-        .when(mock).simpleMethod();
-
-        Assertions.assertThat(mock.simpleMethod()).isEqualTo("foo");
+        doAnswer((Answer<Object>) invocation -> "foo").when(mock).simpleMethod();
+
+        assertThat(mock.simpleMethod()).isEqualTo("foo");
     }
 
     @Test
@@ -212,17 +217,18 @@ public class StubbingUsingDoReturnTest extends TestBase {
     }
 
     @Test
-    public void should_stubbing_be_treated_as_interaction() throws Exception {
+    public void should_stubbing_be_treated_as_interaction() {
         doReturn("foo").when(mock).simpleMethod();
         mock.simpleMethod();
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
-    public void should_verify_stubbed_call() throws Exception {
+    public void should_verify_stubbed_call() {
         doReturn("foo").when(mock).simpleMethod();
         mock.simpleMethod();
         mock.simpleMethod();
@@ -232,25 +238,27 @@ public class StubbingUsingDoReturnTest extends TestBase {
     }
 
     @Test
-    public void should_allow_stubbing_to_string() throws Exception {
+    public void should_allow_stubbing_to_string() {
         doReturn("test").when(mock).toString();
-        Assertions.assertThat(mock.toString()).isEqualTo("test");
+        assertThat(mock.toString()).isEqualTo("test");
     }
 
     @Test
-    public void should_detect_invalid_return_type() throws Exception {
+    public void should_detect_invalid_return_type() {
         try {
             doReturn("foo").when(mock).booleanObjectReturningMethod();
             fail();
         } catch (Exception e) {
-            assertThat(e).hasMessageContaining("String cannot be returned by booleanObjectReturningMethod()" +
-                    "\n" +
-                    "booleanObjectReturningMethod() should return Boolean");
+            assertThat(e)
+                    .hasMessageContaining(
+                            "String cannot be returned by booleanObjectReturningMethod()"
+                                    + "\n"
+                                    + "booleanObjectReturningMethod() should return Boolean");
         }
     }
 
     @Test
-    public void should_detect_when_null_assigned_to_boolean() throws Exception {
+    public void should_detect_when_null_assigned_to_boolean() {
         try {
             doReturn(null).when(mock).intReturningMethod();
             fail();
@@ -260,7 +268,7 @@ public class StubbingUsingDoReturnTest extends TestBase {
     }
 
     @Test
-    public void should_allow_stubbing_when_types_match_signature() throws Exception {
+    public void should_allow_stubbing_when_types_match_signature() {
         doReturn("foo").when(mock).objectReturningMethodNoArgs();
         doReturn("foo").when(mock).simpleMethod();
         doReturn(1).when(mock).intReturningMethod();
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWarningsTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWarningsTest.java
index 6bf2041..c2564f7 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWarningsTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWarningsTest.java
@@ -4,6 +4,13 @@
  */
 package org.mockitousage.stubbing;
 
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+import static org.mockitoutil.TestBase.filterLineNo;
+
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -15,12 +22,6 @@ import org.mockito.internal.util.SimpleMockitoLogger;
 import org.mockito.quality.Strictness;
 import org.mockitousage.IMethods;
 
-import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.verify;
-import static org.mockitoutil.TestBase.filterLineNo;
-
 public class StubbingWarningsTest {
 
     private static final String TEST_NAME = "test.name";
@@ -28,85 +29,114 @@ public class StubbingWarningsTest {
     @Mock IMethods mock;
 
     SimpleMockitoLogger logger = new SimpleMockitoLogger();
-    MockitoSession mockito = new DefaultMockitoSession(singletonList((Object) this), TEST_NAME, Strictness.WARN, logger);
+    MockitoSession mockito =
+            new DefaultMockitoSession(
+                    singletonList((Object) this), TEST_NAME, Strictness.WARN, logger);
 
-    @After public void after() {
+    @After
+    public void after() {
         StateMaster stateMaster = new StateMaster();
         stateMaster.reset();
         stateMaster.clearMockitoListeners();
     }
 
-    @Test public void few_interactions() throws Throwable {
-        //when
+    @Test
+    public void few_interactions() {
+        // when
         mock.simpleMethod(100);
         mock.otherMethod();
 
-        //expect no exception
+        // expect no exception
         mockito.finishMocking();
         logger.assertEmpty();
     }
 
-    @Test public void stubbing_used() throws Throwable {
-        //when
+    @Test
+    public void stubbing_used() {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
         mock.simpleMethod(100);
 
-        //then
+        // then
         mockito.finishMocking();
         logger.assertEmpty();
     }
 
-    @Test public void unused_stubbed_is_not_implicitly_verified() throws Throwable {
-        //when
+    @Test
+    public void unused_stubbed_is_not_implicitly_verified() {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
         mock.simpleMethod(100); // <- stubbing is used
         mock.simpleMethod(200); // <- other method should not generate arg mismatch
 
-        //then
+        // then
         mockito.finishMocking();
         logger.assertEmpty();
     }
 
-    @Test public void stubbing_argument_mismatch() throws Throwable {
-        //when
+    @Test
+    public void stubbing_argument_mismatch() {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
         mock.simpleMethod(200);
 
         mockito.finishMocking();
 
-        //TODO - currently we warn about "Unused" instead of "Arg mismatch" below
-        //because it was simpler to implement. This can be improved given we put priority to improve the warnings.
-        //then
-        assertEquals(filterLineNo(
-            "[MockitoHint] " + TEST_NAME + " (see javadoc for MockitoHint):\n" +
-            "[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
+        // TODO - currently we warn about "Unused" instead of "Arg mismatch" below
+        // because it was simpler to implement. This can be improved given we put priority to
+        // improve the warnings.
+        // then
+        assertEquals(
+                filterLineNo(
+                        "[MockitoHint] "
+                                + TEST_NAME
+                                + " (see javadoc for MockitoHint):\n"
+                                + "[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
                 filterLineNo(logger.getLoggedInfo()));
     }
 
-    @Test public void unused_stubbing() throws Throwable {
-        //when
+    @Test
+    public void unused_stubbing() {
+        // when
         given(mock.simpleMethod(100)).willReturn("100");
 
         mockito.finishMocking();
 
-        //then
-        assertEquals(filterLineNo(
-            "[MockitoHint] " + TEST_NAME + " (see javadoc for MockitoHint):\n" +
-            "[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
+        // then
+        assertEquals(
+                filterLineNo(
+                        "[MockitoHint] "
+                                + TEST_NAME
+                                + " (see javadoc for MockitoHint):\n"
+                                + "[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
                 filterLineNo(logger.getLoggedInfo()));
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-    @Test(expected = MockitoException.class) public void unfinished_verification_without_throwable() throws Throwable {
-        //when
+    @Test
+    public void unfinished_verification_without_throwable() {
+        // when
         verify(mock);
 
-        mockito.finishMocking();
+        assertThatThrownBy(
+                        () -> {
+                            mockito.finishMocking();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Missing method call for verify(mock) here:",
+                        "-> at",
+                        "Example of correct verification:",
+                        "    verify(mock).doSomething()",
+                        "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
+                        "Those methods *cannot* be stubbed/verified.",
+                        "Mocking methods declared on non-public parent classes is not supported.");
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
-    @Test public void unfinished_verification_with_throwable() throws Throwable {
-        //when
+    @Test
+    public void unfinished_verification_with_throwable() {
+        // when
         verify(mock);
 
         mockito.finishMocking(new AssertionError());
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
index 417d998..7dfed44 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
@@ -8,11 +8,11 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.within;
 import static org.mockito.AdditionalAnswers.answer;
 import static org.mockito.AdditionalAnswers.answerVoid;
+import static org.mockito.AdditionalAnswers.answersWithDelay;
 import static org.mockito.AdditionalAnswers.returnsArgAt;
 import static org.mockito.AdditionalAnswers.returnsFirstArg;
 import static org.mockito.AdditionalAnswers.returnsLastArg;
 import static org.mockito.AdditionalAnswers.returnsSecondArg;
-import static org.mockito.AdditionalAnswers.answersWithDelay;
 import static org.mockito.BDDMockito.any;
 import static org.mockito.BDDMockito.anyInt;
 import static org.mockito.BDDMockito.anyString;
@@ -21,6 +21,9 @@ import static org.mockito.BDDMockito.given;
 import static org.mockito.BDDMockito.mock;
 import static org.mockito.BDDMockito.times;
 import static org.mockito.BDDMockito.verify;
+
+import java.util.Date;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -30,15 +33,15 @@ import org.mockito.stubbing.Answer2;
 import org.mockito.stubbing.Answer3;
 import org.mockito.stubbing.Answer4;
 import org.mockito.stubbing.Answer5;
+import org.mockito.stubbing.Answer6;
 import org.mockito.stubbing.VoidAnswer1;
 import org.mockito.stubbing.VoidAnswer2;
 import org.mockito.stubbing.VoidAnswer3;
 import org.mockito.stubbing.VoidAnswer4;
 import org.mockito.stubbing.VoidAnswer5;
+import org.mockito.stubbing.VoidAnswer6;
 import org.mockitousage.IMethods;
 
-import java.util.Date;
-
 @RunWith(MockitoJUnitRunner.class)
 public class StubbingWithAdditionalAnswersTest {
 
@@ -59,7 +62,8 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_after_delay() throws Exception {
         final long sleepyTime = 500L;
 
-        given(iMethods.objectArgMethod(any())).will(answersWithDelay(sleepyTime, returnsFirstArg()));
+        given(iMethods.objectArgMethod(any()))
+                .will(answersWithDelay(sleepyTime, returnsFirstArg()));
 
         final Date before = new Date();
         assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
@@ -73,7 +77,8 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_expanded_arguments_of_invocation() throws Exception {
         given(iMethods.varargsObject(eq(1), any())).will(returnsArgAt(3));
 
-        assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl")).isEqualTo("alice");
+        assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl"))
+                .isEqualTo("alice");
     }
 
     @Test
@@ -88,25 +93,30 @@ public class StubbingWithAdditionalAnswersTest {
     @Test
     public void can_return_based_on_strongly_types_one_parameter_function() throws Exception {
         given(iMethods.simpleMethod(anyString()))
-                .will(answer(new Answer1<String, String>() {
-                    public String answer(String s) {
-                        return s;
-                    }
-                }));
+                .will(
+                        answer(
+                                new Answer1<String, String>() {
+                                    public String answer(String s) {
+                                        return s;
+                                    }
+                                }));
 
         assertThat(iMethods.simpleMethod("string")).isEqualTo("string");
     }
 
     @Test
-    public void will_execute_a_void_based_on_strongly_typed_one_parameter_function() throws Exception {
+    public void will_execute_a_void_based_on_strongly_typed_one_parameter_function()
+            throws Exception {
         final IMethods target = mock(IMethods.class);
 
         given(iMethods.simpleMethod(anyString()))
-                .will(answerVoid(new VoidAnswer1<String>() {
-                    public void answer(String s) {
-                        target.simpleMethod(s);
-                    }
-                }));
+                .will(
+                        answerVoid(
+                                new VoidAnswer1<String>() {
+                                    public void answer(String s) {
+                                        target.simpleMethod(s);
+                                    }
+                                }));
 
         // invoke on iMethods
         iMethods.simpleMethod("string");
@@ -118,28 +128,33 @@ public class StubbingWithAdditionalAnswersTest {
     @Test
     public void can_return_based_on_strongly_typed_two_parameter_function() throws Exception {
         given(iMethods.simpleMethod(anyString(), anyInt()))
-            .will(answer(new Answer2<String, String, Integer>() {
-                public String answer(String s, Integer i) {
-                    return s + "-" + i;
-                }
-            }));
-
-        assertThat(iMethods.simpleMethod("string",1)).isEqualTo("string-1");
+                .will(
+                        answer(
+                                new Answer2<String, String, Integer>() {
+                                    public String answer(String s, Integer i) {
+                                        return s + "-" + i;
+                                    }
+                                }));
+
+        assertThat(iMethods.simpleMethod("string", 1)).isEqualTo("string-1");
     }
 
     @Test
-    public void will_execute_a_void_based_on_strongly_typed_two_parameter_function() throws Exception {
+    public void will_execute_a_void_based_on_strongly_typed_two_parameter_function()
+            throws Exception {
         final IMethods target = mock(IMethods.class);
 
         given(iMethods.simpleMethod(anyString(), anyInt()))
-            .will(answerVoid(new VoidAnswer2<String, Integer>() {
-                public void answer(String s, Integer i) {
-                    target.simpleMethod(s, i);
-                }
-            }));
+                .will(
+                        answerVoid(
+                                new VoidAnswer2<String, Integer>() {
+                                    public void answer(String s, Integer i) {
+                                        target.simpleMethod(s, i);
+                                    }
+                                }));
 
         // invoke on iMethods
-        iMethods.simpleMethod("string",1);
+        iMethods.simpleMethod("string", 1);
 
         // expect the answer to write correctly to "target"
         verify(target, times(1)).simpleMethod("string", 1);
@@ -149,27 +164,33 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_three_parameter_function() throws Exception {
         final IMethods target = mock(IMethods.class);
         given(iMethods.threeArgumentMethodWithStrings(anyInt(), anyString(), anyString()))
-                .will(answer(new Answer3<String, Integer, String, String>() {
-                    public String answer(Integer i, String s1, String s2) {
-                        target.threeArgumentMethodWithStrings(i, s1, s2);
-                        return "answered";
-                    }
-                }));
-
-        assertThat(iMethods.threeArgumentMethodWithStrings(1, "string1", "string2")).isEqualTo("answered");
+                .will(
+                        answer(
+                                new Answer3<String, Integer, String, String>() {
+                                    public String answer(Integer i, String s1, String s2) {
+                                        target.threeArgumentMethodWithStrings(i, s1, s2);
+                                        return "answered";
+                                    }
+                                }));
+
+        assertThat(iMethods.threeArgumentMethodWithStrings(1, "string1", "string2"))
+                .isEqualTo("answered");
         verify(target, times(1)).threeArgumentMethodWithStrings(1, "string1", "string2");
     }
 
     @Test
-    public void will_execute_a_void_based_on_strongly_typed_three_parameter_function() throws Exception {
+    public void will_execute_a_void_based_on_strongly_typed_three_parameter_function()
+            throws Exception {
         final IMethods target = mock(IMethods.class);
 
         given(iMethods.threeArgumentMethodWithStrings(anyInt(), anyString(), anyString()))
-                .will(answerVoid(new VoidAnswer3<Integer, String, String>() {
-                    public void answer(Integer i, String s1, String s2) {
-                        target.threeArgumentMethodWithStrings(i, s1, s2);
-                    }
-                }));
+                .will(
+                        answerVoid(
+                                new VoidAnswer3<Integer, String, String>() {
+                                    public void answer(Integer i, String s1, String s2) {
+                                        target.threeArgumentMethodWithStrings(i, s1, s2);
+                                    }
+                                }));
 
         // invoke on iMethods
         iMethods.threeArgumentMethodWithStrings(1, "string1", "string2");
@@ -182,31 +203,39 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_four_parameter_function() throws Exception {
         final IMethods target = mock(IMethods.class);
         given(iMethods.fourArgumentMethod(anyInt(), anyString(), anyString(), any(boolean[].class)))
-                .will(answer(new Answer4<String, Integer, String, String, boolean[]>() {
-                    public String answer(Integer i, String s1, String s2, boolean[] a) {
-                        target.fourArgumentMethod(i, s1, s2, a);
-                        return "answered";
-                    }
-                }));
-
-        boolean[] booleanArray = { true, false };
-        assertThat(iMethods.fourArgumentMethod(1, "string1", "string2", booleanArray)).isEqualTo("answered");
+                .will(
+                        answer(
+                                new Answer4<String, Integer, String, String, boolean[]>() {
+                                    public String answer(
+                                            Integer i, String s1, String s2, boolean[] a) {
+                                        target.fourArgumentMethod(i, s1, s2, a);
+                                        return "answered";
+                                    }
+                                }));
+
+        boolean[] booleanArray = {true, false};
+        assertThat(iMethods.fourArgumentMethod(1, "string1", "string2", booleanArray))
+                .isEqualTo("answered");
         verify(target, times(1)).fourArgumentMethod(1, "string1", "string2", booleanArray);
     }
 
     @Test
-    public void will_execute_a_void_based_on_strongly_typed_four_parameter_function() throws Exception {
+    public void will_execute_a_void_based_on_strongly_typed_four_parameter_function()
+            throws Exception {
         final IMethods target = mock(IMethods.class);
 
         given(iMethods.fourArgumentMethod(anyInt(), anyString(), anyString(), any(boolean[].class)))
-                .will(answerVoid(new VoidAnswer4<Integer, String, String, boolean[]>() {
-                    public void answer(Integer i, String s1, String s2, boolean[] a) {
-                        target.fourArgumentMethod(i, s1, s2, a);
-                    }
-                }));
+                .will(
+                        answerVoid(
+                                new VoidAnswer4<Integer, String, String, boolean[]>() {
+                                    public void answer(
+                                            Integer i, String s1, String s2, boolean[] a) {
+                                        target.fourArgumentMethod(i, s1, s2, a);
+                                    }
+                                }));
 
         // invoke on iMethods
-        boolean[] booleanArray = { true, false };
+        boolean[] booleanArray = {true, false};
         iMethods.fourArgumentMethod(1, "string1", "string2", booleanArray);
 
         // expect the answer to write correctly to "target"
@@ -217,27 +246,42 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_five_parameter_function() throws Exception {
         final IMethods target = mock(IMethods.class);
         given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt()))
-                .will(answer(new Answer5<String, String, Integer, Integer, Integer, Integer>() {
-                    public String answer(String s1, Integer i1, Integer i2, Integer i3, Integer i4) {
-                        target.simpleMethod(s1, i1, i2, i3, i4);
-                        return "answered";
-                    }
-                }));
+                .will(
+                        answer(
+                                new Answer5<String, String, Integer, Integer, Integer, Integer>() {
+                                    public String answer(
+                                            String s1,
+                                            Integer i1,
+                                            Integer i2,
+                                            Integer i3,
+                                            Integer i4) {
+                                        target.simpleMethod(s1, i1, i2, i3, i4);
+                                        return "answered";
+                                    }
+                                }));
 
         assertThat(iMethods.simpleMethod("hello", 1, 2, 3, 4)).isEqualTo("answered");
         verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4);
     }
 
     @Test
-    public void will_execute_a_void_based_on_strongly_typed_five_parameter_function() throws Exception {
+    public void will_execute_a_void_based_on_strongly_typed_five_parameter_function()
+            throws Exception {
         final IMethods target = mock(IMethods.class);
 
         given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt()))
-                .will(answerVoid(new VoidAnswer5<String, Integer, Integer, Integer, Integer>() {
-                    public void  answer(String s1, Integer i1, Integer i2, Integer i3, Integer i4) {
-                        target.simpleMethod(s1, i1, i2, i3, i4);
-                    }
-                }));
+                .will(
+                        answerVoid(
+                                new VoidAnswer5<String, Integer, Integer, Integer, Integer>() {
+                                    public void answer(
+                                            String s1,
+                                            Integer i1,
+                                            Integer i2,
+                                            Integer i3,
+                                            Integer i4) {
+                                        target.simpleMethod(s1, i1, i2, i3, i4);
+                                    }
+                                }));
 
         // invoke on iMethods
         iMethods.simpleMethod("hello", 1, 2, 3, 4);
@@ -246,4 +290,61 @@ public class StubbingWithAdditionalAnswersTest {
         verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4);
     }
 
+    @Test
+    public void can_return_based_on_strongly_typed_six_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt()))
+                .will(
+                        answer(
+                                new Answer6<
+                                        String,
+                                        String,
+                                        Integer,
+                                        Integer,
+                                        Integer,
+                                        Integer,
+                                        Integer>() {
+                                    public String answer(
+                                            String s1,
+                                            Integer i1,
+                                            Integer i2,
+                                            Integer i3,
+                                            Integer i4,
+                                            Integer i5) {
+                                        target.simpleMethod(s1, i1, i2, i3, i4, i5);
+                                        return "answered";
+                                    }
+                                }));
+
+        assertThat(iMethods.simpleMethod("hello", 1, 2, 3, 4, 5)).isEqualTo("answered");
+        verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void will_execute_a_void_returning_strongly_typed_six_parameter_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer6<
+                                        String, Integer, Integer, Integer, Integer, Integer>() {
+                                    public void answer(
+                                            String s1,
+                                            Integer i1,
+                                            Integer i2,
+                                            Integer i3,
+                                            Integer i4,
+                                            Integer i5) {
+                                        target.simpleMethod(s1, i1, i2, i3, i4, i5);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.simpleMethod("hello", 1, 2, 3, 4, 5);
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4, 5);
+    }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithBadThrowablesTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithBadThrowablesTest.java
new file mode 100644
index 0000000..43824bf
--- /dev/null
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithBadThrowablesTest.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.stubbing;
+
+import static org.mockito.Mockito.doThrow;
+
+import java.util.List;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockitoutil.TestBase;
+
+// issue 1514
+@SuppressWarnings({"serial", "unchecked", "rawtypes"})
+public class StubbingWithBadThrowablesTest extends TestBase {
+
+    @Mock List mock;
+
+    @Test
+    public void handles_bad_exception() {
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                doThrow(UninstantiableException.class).when(mock).clear();
+                            }
+                        })
+                .isInstanceOf(
+                        InstantiationError.class); // because the exception cannot be instantiated
+
+        // ensure that the state is cleaned
+        Mockito.validateMockitoUsage();
+    }
+
+    abstract static class UninstantiableException extends RuntimeException {}
+}
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java
index 6d59b6c..5591bc4 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java
@@ -4,6 +4,12 @@
  */
 package org.mockitousage.stubbing;
 
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import java.lang.reflect.Method;
+import java.util.Set;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
@@ -11,25 +17,20 @@ import org.mockito.stubbing.Answer;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.lang.reflect.Method;
-import java.util.Set;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
 public class StubbingWithCustomAnswerTest extends TestBase {
-    @Mock
-    private IMethods mock;
+    @Mock private IMethods mock;
 
     @Test
     public void shouldAnswer() throws Exception {
-        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                String arg =  invocation.getArgument(0);
+        when(mock.simpleMethod(anyString()))
+                .thenAnswer(
+                        new Answer<String>() {
+                            public String answer(InvocationOnMock invocation) throws Throwable {
+                                String arg = invocation.getArgument(0);
 
-                return invocation.getMethod().getName() + "-" + arg;
-            }
-        });
+                                return invocation.getMethod().getName() + "-" + arg;
+                            }
+                        });
 
         assertEquals("simpleMethod-test", mock.simpleMethod("test"));
     }
@@ -39,7 +40,7 @@ public class StubbingWithCustomAnswerTest extends TestBase {
         RecordCall recordCall = new RecordCall();
         Set<?> mockedSet = (Set<?>) when(mock(Set.class).isEmpty()).then(recordCall).getMock();
 
-        mockedSet.isEmpty();
+        boolean unused = mockedSet.isEmpty();
 
         assertTrue(recordCall.isCalled());
     }
@@ -47,17 +48,19 @@ public class StubbingWithCustomAnswerTest extends TestBase {
     @Test
     public void shouldAnswerConsecutively() throws Exception {
         when(mock.simpleMethod())
-                .thenAnswer(new Answer<String>() {
-                    public String answer(InvocationOnMock invocation) throws Throwable {
-                        return invocation.getMethod().getName();
-                    }
-                })
+                .thenAnswer(
+                        new Answer<String>() {
+                            public String answer(InvocationOnMock invocation) throws Throwable {
+                                return invocation.getMethod().getName();
+                            }
+                        })
                 .thenReturn("Hello")
-                .thenAnswer(new Answer<String>() {
-                    public String answer(InvocationOnMock invocation) throws Throwable {
-                        return invocation.getMethod().getName() + "-1";
-                    }
-                });
+                .thenAnswer(
+                        new Answer<String>() {
+                            public String answer(InvocationOnMock invocation) throws Throwable {
+                                return invocation.getMethod().getName() + "-1";
+                            }
+                        });
 
         assertEquals("simpleMethod", mock.simpleMethod());
         assertEquals("Hello", mock.simpleMethod());
@@ -81,9 +84,10 @@ public class StubbingWithCustomAnswerTest extends TestBase {
         RecordCall call2 = new RecordCall();
 
         doAnswer(call1)
-        .doThrow(new UnsupportedOperationException())
-        .doAnswer(call2)
-        .when(mock).voidMethod();
+                .doThrow(new UnsupportedOperationException())
+                .doAnswer(call2)
+                .when(mock)
+                .voidMethod();
 
         mock.voidMethod();
         assertTrue(call1.isCalled());
@@ -101,14 +105,16 @@ public class StubbingWithCustomAnswerTest extends TestBase {
 
     @Test
     public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {
-        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {
-            public String answer(InvocationOnMock invocation) throws Throwable {
-                assertTrue(invocation.getArguments().getClass().isArray());
-                assertEquals(Method.class, invocation.getMethod().getClass());
+        when(mock.simpleMethod(anyString()))
+                .thenAnswer(
+                        new Answer<String>() {
+                            public String answer(InvocationOnMock invocation) throws Throwable {
+                                assertTrue(invocation.getArguments().getClass().isArray());
+                                assertEquals(Method.class, invocation.getMethod().getClass());
 
-                return "assertions passed";
-            }
-        });
+                                return "assertions passed";
+                            }
+                        });
 
         assertEquals("assertions passed", mock.simpleMethod("test"));
     }
@@ -125,5 +131,4 @@ public class StubbingWithCustomAnswerTest extends TestBase {
             return null;
         }
     }
-
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateTest.java
index 24c4854..245fa78 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateTest.java
@@ -4,22 +4,24 @@
  */
 package org.mockitousage.stubbing;
 
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockitousage.IMethods;
-import org.mockitousage.MethodsImpl;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.AdditionalAnswers.delegatesTo;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.AdditionalAnswers;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockitousage.IMethods;
+import org.mockitousage.MethodsImpl;
 
 @SuppressWarnings("unchecked")
 public class StubbingWithDelegateTest {
@@ -95,15 +97,10 @@ public class StubbingWithDelegateTest {
     }
 
     @Test
-    public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {
+    public void null_wrapper_dont_throw_exception_from_org_mockito_package() {
         IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));
 
-        try {
-            byte b = methods.byteObjectReturningMethod(); // real method returns null
-            fail();
-        } catch (Exception e) {
-            assertThat(e.toString()).doesNotContain("org.mockito");
-        }
+        assertThat(methods.byteObjectReturningMethod()).isNull();
     }
 
     @Test
@@ -142,7 +139,9 @@ public class StubbingWithDelegateTest {
             mock.size();
             fail();
         } catch (MockitoException e) {
-            assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");
+            assertThat(e.toString())
+                    .contains(
+                            "Methods called on delegated instance must have compatible return type");
         }
     }
 
@@ -154,19 +153,25 @@ public class StubbingWithDelegateTest {
             mock.subList(0, 0);
             fail();
         } catch (MockitoException e) {
-            assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");
+            assertThat(e.toString())
+                    .contains(
+                            "Methods called on delegated instance must have compatible return type");
         }
     }
 
     @Test
     public void exception_should_be_propagated_from_delegate() throws Exception {
         final RuntimeException failure = new RuntimeException("angry-method");
-        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl() {
-            @Override
-            public String simpleMethod() {
-                throw failure;
-            }
-        }));
+        IMethods methods =
+                mock(
+                        IMethods.class,
+                        delegatesTo(
+                                new MethodsImpl() {
+                                    @Override
+                                    public String simpleMethod() {
+                                        throw failure;
+                                    }
+                                }));
 
         try {
             methods.simpleMethod(); // delegate throws an exception
@@ -175,4 +180,26 @@ public class StubbingWithDelegateTest {
             assertThat(e).isEqualTo(failure);
         }
     }
+
+    interface Foo {
+        int bar();
+    }
+
+    @Test
+    public void should_call_anonymous_class_method() throws Throwable {
+        Foo foo =
+                new Foo() {
+                    public int bar() {
+                        return 0;
+                    }
+                };
+
+        Foo mock = mock(Foo.class);
+        when(mock.bar()).thenAnswer(AdditionalAnswers.delegatesTo(foo));
+
+        // when
+        mock.bar();
+
+        // then no exception is thrown
+    }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateVarArgsTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateVarArgsTest.java
index d1c3828..5bd3f33 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateVarArgsTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithDelegateVarArgsTest.java
@@ -4,13 +4,13 @@
  */
 package org.mockitousage.stubbing;
 
-import org.junit.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.AdditionalAnswers.delegatesTo;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.withSettings;
 
+import org.junit.Test;
+
 public class StubbingWithDelegateVarArgsTest {
 
     public interface Foo {
@@ -23,28 +23,24 @@ public class StubbingWithDelegateVarArgsTest {
         public int bar(String baz, Object... args) {
             return args != null ? args.length : -1; // simple return argument count
         }
-
     }
 
     @Test
     public void should_not_fail_when_calling_varargs_method() {
-        Foo foo = mock(Foo.class, withSettings()
-                .defaultAnswer(delegatesTo(new FooImpl())));
+        Foo foo = mock(Foo.class, withSettings().defaultAnswer(delegatesTo(new FooImpl())));
         assertThat(foo.bar("baz", 12, "45", 67.8)).isEqualTo(3);
     }
 
     @Test
     public void should_not_fail_when_calling_varargs_method_without_arguments() {
-        Foo foo = mock(Foo.class, withSettings()
-                .defaultAnswer(delegatesTo(new FooImpl())));
+        Foo foo = mock(Foo.class, withSettings().defaultAnswer(delegatesTo(new FooImpl())));
         assertThat(foo.bar("baz")).isEqualTo(0);
         assertThat(foo.bar("baz", new Object[0])).isEqualTo(0);
     }
 
     @Test
     public void should_not_fail_when_calling_varargs_method_with_null_argument() {
-        Foo foo = mock(Foo.class, withSettings()
-                .defaultAnswer(delegatesTo(new FooImpl())));
+        Foo foo = mock(Foo.class, withSettings().defaultAnswer(delegatesTo(new FooImpl())));
         assertThat(foo.bar("baz", (Object[]) null)).isEqualTo(-1);
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithExtraAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithExtraAnswersTest.java
index a2cc3d1..b7f1cec 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithExtraAnswersTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithExtraAnswersTest.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
+import static java.util.Arrays.asList;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.AdditionalAnswers;
 import org.mockito.Mock;
@@ -12,39 +19,34 @@ import org.mockito.exceptions.base.MockitoException;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.when;
-
 public class StubbingWithExtraAnswersTest extends TestBase {
 
     @Mock private IMethods mock;
 
     @Test
     public void shouldWorkAsStandardMockito() throws Exception {
-        //when
+        // when
         List<Integer> list = asList(1, 2, 3);
-        when(mock.objectReturningMethodNoArgs()).thenAnswer(AdditionalAnswers.returnsElementsOf(list));
+        when(mock.objectReturningMethodNoArgs())
+                .thenAnswer(AdditionalAnswers.returnsElementsOf(list));
 
-        //then
+        // then
         assertEquals(1, mock.objectReturningMethodNoArgs());
         assertEquals(2, mock.objectReturningMethodNoArgs());
         assertEquals(3, mock.objectReturningMethodNoArgs());
-        //last element is returned continuously
+        // last element is returned continuously
         assertEquals(3, mock.objectReturningMethodNoArgs());
         assertEquals(3, mock.objectReturningMethodNoArgs());
     }
 
     @Test
     public void shouldReturnNullIfNecessary() throws Exception {
-        //when
+        // when
         List<Integer> list = asList(1, null);
-        when(mock.objectReturningMethodNoArgs()).thenAnswer(AdditionalAnswers.returnsElementsOf(list));
+        when(mock.objectReturningMethodNoArgs())
+                .thenAnswer(AdditionalAnswers.returnsElementsOf(list));
 
-        //then
+        // then
         assertEquals(1, mock.objectReturningMethodNoArgs());
         assertEquals(null, mock.objectReturningMethodNoArgs());
         assertEquals(null, mock.objectReturningMethodNoArgs());
@@ -53,10 +55,11 @@ public class StubbingWithExtraAnswersTest extends TestBase {
     @Test
     public void shouldScreamWhenNullPassed() throws Exception {
         try {
-            //when
+            // when
             AdditionalAnswers.returnsElementsOf(null);
-            //then
+            // then
             fail();
-        } catch (MockitoException e) {}
+        } catch (MockitoException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
index 9353724..045a8b6 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
@@ -2,19 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.stubbing;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.hamcrest.CoreMatchers.sameInstance;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import java.io.IOException;
@@ -24,27 +24,21 @@ import java.util.LinkedList;
 import java.util.Map;
 
 import org.assertj.core.api.Assertions;
-import org.assertj.core.api.ThrowableAssert;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-@SuppressWarnings({ "serial", "unchecked", "rawtypes" })
+@SuppressWarnings({"serial", "unchecked", "rawtypes"})
 public class StubbingWithThrowablesTest extends TestBase {
 
     private LinkedList mock;
 
     private Map mockTwo;
 
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
     @Before
     public void setup() {
         mock = mock(LinkedList.class);
@@ -55,82 +49,114 @@ public class StubbingWithThrowablesTest extends TestBase {
     public void throws_same_exception_consecutively() {
         when(mock.add("")).thenThrow(new ExceptionOne());
 
-        //1st invocation
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                mock.add("");
-            }
-        }).isInstanceOf(ExceptionOne.class);
+        // 1st invocation
+        assertThatThrownBy(
+                        () -> {
+                            mock.add("");
+                        })
+                .isInstanceOf(ExceptionOne.class);
 
         mock.add("1");
 
-        //2nd invocation
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                mock.add("");
-            }
-        }).isInstanceOf(ExceptionOne.class);
+        // 2nd invocation
+        assertThatThrownBy(
+                        () -> {
+                            mock.add("");
+                        })
+                .isInstanceOf(ExceptionOne.class);
     }
 
     @Test
     public void throws_same_exception_consecutively_with_doThrow() {
         doThrow(new ExceptionOne()).when(mock).clear();
 
-        //1st invocation
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                mock.clear();
-            }
-        }).isInstanceOf(ExceptionOne.class);
+        // 1st invocation
+        assertThatThrownBy(
+                        () -> {
+                            mock.clear();
+                        })
+                .isInstanceOf(ExceptionOne.class);
 
         mock.add("1");
 
-        //2nd invocation
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                mock.clear();
-            }
-        }).isInstanceOf(ExceptionOne.class);
+        // 2nd invocation
+        assertThatThrownBy(
+                        () -> {
+                            mock.clear();
+                        })
+                .isInstanceOf(ExceptionOne.class);
     }
 
     @Test
-    public void shouldStubWithThrowable() throws Exception {
+    public void throws_new_exception_consecutively_from_class() {
+        when(mock.add(null)).thenThrow(NaughtyException.class);
+
+        NaughtyException first =
+                Assertions.catchThrowableOfType(() -> mock.add(null), NaughtyException.class);
+        NaughtyException second =
+                Assertions.catchThrowableOfType(() -> mock.add(null), NaughtyException.class);
+
+        assertNotSame(first, second);
+    }
+
+    @Test
+    public void throws_new_exception_consecutively_from_class_with_doThrow() {
+        doThrow(NaughtyException.class).when(mock).add(null);
+
+        NaughtyException first =
+                Assertions.catchThrowableOfType(() -> mock.add(null), NaughtyException.class);
+        NaughtyException second =
+                Assertions.catchThrowableOfType(() -> mock.add(null), NaughtyException.class);
+
+        assertNotSame(first, second);
+    }
+
+    @Test
+    public void shouldStubWithThrowable() {
         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");
         when(mock.add("throw")).thenThrow(expected);
 
-        exception.expect(sameInstance(expected));
-        mock.add("throw");
+        assertThatThrownBy(
+                        () -> {
+                            mock.add("throw");
+                        })
+                .isEqualTo(expected);
     }
 
     @Test
-    public void shouldSetThrowableToVoidMethod() throws Exception {
+    public void shouldSetThrowableToVoidMethod() {
         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");
 
         doThrow(expected).when(mock).clear();
 
-        exception.expect(sameInstance(expected));
-
-        mock.clear();
-
+        assertThatThrownBy(
+                        () -> {
+                            mock.clear();
+                        })
+                .isEqualTo(expected);
     }
 
     @Test
-    public void shouldLastStubbingVoidBeImportant() throws Exception {
+    public void shouldLastStubbingVoidBeImportant() {
         doThrow(new ExceptionOne()).when(mock).clear();
         doThrow(new ExceptionTwo()).when(mock).clear();
 
-        exception.expect(ExceptionTwo.class);
-
-        mock.clear();
+        assertThatThrownBy(
+                        () -> {
+                            mock.clear();
+                        })
+                .isInstanceOf(ExceptionTwo.class);
     }
 
     @Test
-    public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {
+    public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() {
         when(mock.size()).thenThrow(new ExceptionOne());
 
-        exception.expect(ExceptionOne.class);
-
-        when(mock.size()).thenThrow(new ExceptionTwo());
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.size()).thenThrow(new ExceptionTwo());
+                        })
+                .isInstanceOf(ExceptionOne.class);
     }
 
     @Test
@@ -140,160 +166,199 @@ public class StubbingWithThrowablesTest extends TestBase {
 
         when(reader.read()).thenThrow(ioException);
 
-        exception.expect(sameInstance(ioException));
-
-        reader.read();
+        assertThatThrownBy(
+                        () -> {
+                            reader.read();
+                        })
+                .isEqualTo(ioException);
     }
 
     @Test
-    public void shouldAllowSettingError() throws Exception {
+    public void shouldAllowSettingError() {
         Error error = new Error();
 
         when(mock.add("quake")).thenThrow(error);
 
-        exception.expect(Error.class);
-
-        mock.add("quake");
+        assertThatThrownBy(
+                        () -> {
+                            mock.add("quake");
+                        })
+                .isEqualTo(error);
     }
 
     @Test
     public void shouldNotAllowNullExceptionType() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
-        when(mock.add(null)).thenThrow((Exception) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.add(null)).thenThrow((Exception) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable");
     }
 
     @Test
     public void shouldInstantiateExceptionClassOnInteraction() {
         when(mock.add(null)).thenThrow(NaughtyException.class);
 
-        exception.expect(NaughtyException.class);
-
-        mock.add(null);
+        assertThatThrownBy(
+                        () -> {
+                            mock.add(null);
+                        })
+                .isInstanceOf(NaughtyException.class);
     }
 
     @Test
     public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction() {
         doThrow(NaughtyException.class).when(mock).add(null);
 
-        exception.expect(NaughtyException.class);
-
-        mock.add(null);
+        assertThatThrownBy(
+                        () -> {
+                            mock.add(null);
+                        })
+                .isInstanceOf(NaughtyException.class);
     }
 
     @Test
     public void shouldNotAllowSettingInvalidCheckedException() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.add("monkey island")).thenThrow(new Exception());
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.add("monkey island")).thenThrow(new Exception());
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Checked exception is invalid for this method");
     }
 
     @Test
     public void shouldNotAllowSettingNullThrowable() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
-        when(mock.add("monkey island")).thenThrow((Throwable) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.add("monkey island")).thenThrow((Throwable) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable");
     }
 
     @Test
     public void shouldNotAllowSettingNullThrowableArray() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
-        when(mock.add("monkey island")).thenThrow((Throwable[]) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.add("monkey island")).thenThrow((Throwable[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Cannot stub with null throwable");
     }
 
     @Test
     public void shouldNotAllowSettingNullThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow((Class) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.isEmpty()).thenThrow((Class) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
     public void shouldNotAllowSettingNullThrowableClasses() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
     public void shouldNotAllowSettingNullVarArgThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
     public void doThrowShouldNotAllowSettingNullThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow((Class) null).when(mock).isEmpty();
+        assertThatThrownBy(
+                        () -> {
+                            doThrow((Class) null).when(mock).isEmpty();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
-    public void doThrowShouldNotAllowSettingNullThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow(RuntimeException.class, (Class) null).when(mock).isEmpty();
+    public void doThrowShouldNotAllowSettingNullThrowableClasses() {
+        assertThatThrownBy(
+                        () -> {
+                            doThrow(RuntimeException.class, (Class) null).when(mock).isEmpty();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
-    public void doThrowShouldNotAllowSettingNullVarArgThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow(RuntimeException.class, (Class[]) null).when(mock).isEmpty();
+    public void doThrowShouldNotAllowSettingNullVarArgThrowableClasses() {
+        assertThatThrownBy(
+                        () -> {
+                            doThrow(RuntimeException.class, (Class[]) null).when(mock).isEmpty();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
-    public void shouldNotAllowSettingNullVarArgsThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class<RuntimeException>[]) null);
+    public void shouldNotAllowSettingNullVarArgsThrowableClasses() {
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.isEmpty())
+                                    .thenThrow(
+                                            RuntimeException.class,
+                                            (Class<RuntimeException>[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Exception type cannot be null");
     }
 
     @Test
-    public void shouldNotAllowDifferntCheckedException() throws Exception {
+    public void shouldNotAllowDifferentCheckedException() {
         IMethods mock = mock(IMethods.class);
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsIOException(0)).thenThrow(CheckedException.class);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.throwsIOException(0)).thenThrow(CheckedException.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Checked exception is invalid for this method");
     }
 
     @Test
-    public void shouldNotAllowCheckedExceptionWhenErrorIsDeclared() throws Exception {
+    public void shouldNotAllowCheckedExceptionWhenErrorIsDeclared() {
         IMethods mock = mock(IMethods.class);
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsError(0)).thenThrow(CheckedException.class);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.throwsError(0)).thenThrow(CheckedException.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Checked exception is invalid for this method");
     }
 
     @Test
-    public void shouldNotAllowCheckedExceptionWhenNothingIsDeclared() throws Exception {
+    public void shouldNotAllowCheckedExceptionWhenNothingIsDeclared() {
         IMethods mock = mock(IMethods.class);
 
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsNothing(true)).thenThrow(CheckedException.class);
+        assertThatThrownBy(
+                        () -> {
+                            when(mock.throwsNothing(true)).thenThrow(CheckedException.class);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Checked exception is invalid for this method");
     }
 
     @Test
-    public void shouldMixThrowablesAndReturnsOnDifferentMocks() throws Exception {
+    public void shouldMixThrowablesAndReturnsOnDifferentMocks() {
         when(mock.add("ExceptionOne")).thenThrow(new ExceptionOne());
         when(mock.getLast()).thenReturn("last");
         doThrow(new ExceptionTwo()).when(mock).clear();
@@ -357,7 +422,7 @@ public class StubbingWithThrowablesTest extends TestBase {
         when(mock.size()).thenThrow(new RuntimeException());
         doThrow(new RuntimeException()).when(mock).clone();
 
-        verifyZeroInteractions(mock);
+        verifyNoInteractions(mock);
 
         mock.add("test");
 
@@ -380,20 +445,15 @@ public class StubbingWithThrowablesTest extends TestBase {
         }
     }
 
-    private class ExceptionOne extends RuntimeException {
-    }
+    private class ExceptionOne extends RuntimeException {}
 
-    private class ExceptionTwo extends RuntimeException {
-    }
+    private class ExceptionTwo extends RuntimeException {}
 
-    private class ExceptionThree extends RuntimeException {
-    }
+    private class ExceptionThree extends RuntimeException {}
 
-    private class ExceptionFour extends RuntimeException {
-    }
+    private class ExceptionFour extends RuntimeException {}
 
-    private class CheckedException extends Exception {
-    }
+    private class CheckedException extends Exception {}
 
     public class NaughtyException extends RuntimeException {
         public NaughtyException() {
diff --git a/src/test/java/org/mockitousage/verification/AtLeastXVerificationTest.java b/src/test/java/org/mockitousage/verification/AtLeastXVerificationTest.java
index c766498..8a3f6b1 100644
--- a/src/test/java/org/mockitousage/verification/AtLeastXVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/AtLeastXVerificationTest.java
@@ -2,31 +2,30 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class AtLeastXVerificationTest extends TestBase {
 
     @Mock private List<String> mock;
 
     @Test
     public void shouldVerifyAtLeastXTimes() throws Exception {
-        //when
+        // when
         mock.clear();
         mock.clear();
         mock.clear();
 
-        //then
+        // then
         verify(mock, atLeast(2)).clear();
     }
 
@@ -38,16 +37,18 @@ public class AtLeastXVerificationTest extends TestBase {
         try {
             verify(mock, atLeast(2)).add(anyString());
             fail();
-        } catch (MockitoAssertionError e) {}
+        } catch (MockitoAssertionError e) {
+        }
     }
 
     @Test
-    public void shouldAllowAtLeastZeroForTheSakeOfVerifyNoMoreInteractionsSometimes() throws Exception {
-        //when
+    public void shouldAllowAtLeastZeroForTheSakeOfVerifyNoMoreInteractionsSometimes()
+            throws Exception {
+        // when
         mock.add("one");
         mock.clear();
 
-        //then
+        // then
         verify(mock, atLeast(0)).add("one");
         verify(mock, atLeast(0)).clear();
 
diff --git a/src/test/java/org/mockitousage/verification/AtMostXVerificationTest.java b/src/test/java/org/mockitousage/verification/AtMostXVerificationTest.java
index 2756ef8..f6c08ac 100644
--- a/src/test/java/org/mockitousage/verification/AtMostXVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/AtMostXVerificationTest.java
@@ -2,28 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
-import org.junit.Test;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockitoutil.TestBase;
-
-import java.util.List;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.atMost;
+import static org.mockito.Mockito.atMostOnce;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
+import java.util.List;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.verification.VerificationMode;
+import org.mockitoutil.TestBase;
+
 public class AtMostXVerificationTest extends TestBase {
 
     @Mock private List<String> mock;
@@ -37,9 +38,10 @@ public class AtMostXVerificationTest extends TestBase {
         verify(mock, atMost(3)).clear();
 
         try {
-            verify(mock, atMost(1)).clear();
+            verify(mock, atMostOnce()).clear();
             fail();
-        } catch (MoreThanAllowedActualInvocations e) {}
+        } catch (MoreThanAllowedActualInvocations e) {
+        }
     }
 
     @Test
@@ -50,7 +52,8 @@ public class AtMostXVerificationTest extends TestBase {
         try {
             verify(mock, atMost(0)).add(anyString());
             fail();
-        } catch (MoreThanAllowedActualInvocations e) {}
+        } catch (MoreThanAllowedActualInvocations e) {
+        }
     }
 
     @Test
@@ -69,7 +72,7 @@ public class AtMostXVerificationTest extends TestBase {
         mock.clear();
 
         try {
-            verify(mock, atMost(1)).clear();
+            verify(mock, atMostOnce()).clear();
             fail();
         } catch (MoreThanAllowedActualInvocations e) {
             assertEquals("\nWanted at most 1 time but was 2", e.getMessage());
@@ -82,7 +85,7 @@ public class AtMostXVerificationTest extends TestBase {
         InOrder inOrder = inOrder(mock);
 
         try {
-            inOrder.verify(mock, atMost(1)).clear();
+            inOrder.verify(mock, atMostOnce()).clear();
             fail();
         } catch (MockitoException e) {
             assertEquals("AtMost is not implemented to work with InOrder", e.getMessage());
@@ -108,11 +111,18 @@ public class AtMostXVerificationTest extends TestBase {
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch(NoInteractionsWanted e) {
+        } catch (NoInteractionsWanted e) {
             assertThat(e).hasMessageContaining("undesiredInteraction(");
         }
     }
 
+    @Test
+    public void should_return_formatted_output_from_toString_method() {
+        VerificationMode atMost = atMost(3);
+
+        assertThat(atMost).hasToString("Wanted invocations count: at most 3");
+    }
+
     private void undesiredInteraction() {
         mock.add("");
     }
diff --git a/src/test/java/org/mockitousage/verification/BasicVerificationInOrderTest.java b/src/test/java/org/mockitousage/verification/BasicVerificationInOrderTest.java
index b0e3179..80d02e3 100644
--- a/src/test/java/org/mockitousage/verification/BasicVerificationInOrderTest.java
+++ b/src/test/java/org/mockitousage/verification/BasicVerificationInOrderTest.java
@@ -2,23 +2,31 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.misusing.NotAMockException;
+import org.mockito.exceptions.misusing.NullInsteadOfMockException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class BasicVerificationInOrderTest extends TestBase {
 
     private IMethods mockOne;
@@ -99,14 +107,36 @@ public class BasicVerificationInOrderTest extends TestBase {
         }
     }
 
-    @Test(expected = VerificationInOrderFailure.class)
+    @Test
     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {
-        inOrder.verify(mockOne, times(0)).simpleMethod(1);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockOne, times(0)).simpleMethod(1);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure:",
+                        "iMethods.simpleMethod(1);",
+                        "Wanted 0 times:",
+                        "-> at ",
+                        "But was 1 time:",
+                        "-> at ");
     }
 
-    @Test(expected = VerificationInOrderFailure.class)
+    @Test
     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {
-        inOrder.verify(mockOne, times(2)).simpleMethod(1);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockOne, times(2)).simpleMethod(1);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure:",
+                        "iMethods.simpleMethod(1);",
+                        "Wanted 2 times:",
+                        "-> at ",
+                        "But was 1 time:",
+                        "-> at ");
     }
 
     @Test
@@ -157,14 +187,56 @@ public class BasicVerificationInOrderTest extends TestBase {
 
     /* ------------- */
 
-    @Test(expected = ArgumentsAreDifferent.class)
+    @Test
     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {
-        inOrder.verify(mockOne).simpleMethod(100);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockOne).simpleMethod(100);
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class)
+                .hasMessageContainingAll(
+                        "Argument(s) are different! Wanted:",
+                        "iMethods.simpleMethod(100);",
+                        "-> at ",
+                        "Actual invocations have different arguments:",
+                        "iMethods.simpleMethod(1);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(3);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(4);",
+                        "-> at ");
     }
 
-    @Test(expected = WantedButNotInvoked.class)
+    @Test
     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {
-        inOrder.verify(mockOne).oneArg(true);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockOne).oneArg(true);
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:",
+                        "iMethods.oneArg(true);",
+                        "-> at ",
+                        "However, there were exactly 6 interactions with this mock:",
+                        "iMethods.simpleMethod(1);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(3);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(4);",
+                        "-> at ");
     }
 
     @Test
@@ -259,14 +331,62 @@ public class BasicVerificationInOrderTest extends TestBase {
         }
     }
 
-    @Test(expected = NoInteractionsWanted.class)
-    public void shouldFailOnVerifyZeroInteractions() {
-        verifyZeroInteractions(mockOne);
+    @Test
+    public void shouldFailOnVerifyNoInteractions() {
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoInteractions(mockOne);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class)
+                .hasMessageContainingAll(
+                        "No interactions wanted here:",
+                        "-> at ",
+                        "But found these interactions on mock 'iMethods':",
+                        "-> at ",
+                        "-> at ",
+                        "***",
+                        "For your reference, here is the list of all invocations ([?] - means unverified).",
+                        "1. [?]-> at ",
+                        "2. [?]-> at ");
     }
 
     @SuppressWarnings({"all", "CheckReturnValue", "MockitoUsage"})
-    @Test(expected = MockitoException.class)
+    @Test
     public void shouldScreamWhenNullPassed() {
-        inOrder((Object[])null);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder((Object[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that require verification in order.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne, mockTwo);");
+    }
+
+    @Test
+    public void shouldThrowNullPassedToVerifyException() {
+        try {
+            inOrder.verify(null);
+            fail();
+        } catch (NullInsteadOfMockException e) {
+            assertThat(e)
+                    .hasMessageContaining(
+                            "Argument passed to verify() should be a mock but is null!");
+        }
+    }
+
+    @Test
+    public void shouldThrowNotAMockPassedToVerifyException() {
+        Object object = new Object();
+        try {
+            inOrder.verify(object);
+            fail();
+        } catch (NotAMockException e) {
+            assertThat(e)
+                    .hasMessageContaining(
+                            "Argument passed to verify() is of type Object and is not a mock!");
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/BasicVerificationTest.java b/src/test/java/org/mockitousage/verification/BasicVerificationTest.java
index d9a74ff..70df2b1 100644
--- a/src/test/java/org/mockitousage/verification/BasicVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/BasicVerificationTest.java
@@ -2,32 +2,34 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
-import org.assertj.core.api.ThrowableAssert;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.TooManyActualInvocations;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class BasicVerificationTest extends TestBase {
 
     @Mock private List<String> mock;
     @Mock private List<String> mockTwo;
 
     @Test
-    public void shouldVerify() throws Exception {
+    public void shouldVerify() {
         mock.clear();
         verify(mock).clear();
 
@@ -37,28 +39,36 @@ public class BasicVerificationTest extends TestBase {
         verifyNoMoreInteractions(mock);
     }
 
-    @Test(expected=WantedButNotInvoked.class)
-    public void shouldFailVerification() throws Exception {
-        verify(mock).clear();
+    @Test
+    public void shouldFailVerification() {
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).clear();
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:",
+                        "mock.clear();",
+                        "-> at ",
+                        "Actually, there were zero interactions with this mock.");
     }
 
     @Test
-    public void shouldFailVerificationOnMethodArgument() throws Exception {
+    public void shouldFailVerificationOnMethodArgument() {
         mock.clear();
         mock.add("foo");
 
         verify(mock).clear();
 
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock).add("bar");
-            }
-        }).isInstanceOf(ArgumentsAreDifferent.class);
+        assertThatThrownBy(
+                        () -> {
+                            verify(mock).add("bar");
+                        })
+                .isInstanceOf(ArgumentsAreDifferent.class);
     }
 
     @Test
-    public void shouldFailOnWrongMethod() throws Exception {
+    public void shouldFailOnWrongMethod() {
         mock.clear();
         mock.clear();
 
@@ -69,11 +79,12 @@ public class BasicVerificationTest extends TestBase {
         try {
             verify(mockTwo, atLeastOnce()).add("foo");
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 
     @Test
-    public void shouldDetectRedundantInvocation() throws Exception {
+    public void shouldDetectRedundantInvocation() {
         mock.clear();
         mock.add("foo");
         mock.add("bar");
@@ -84,11 +95,12 @@ public class BasicVerificationTest extends TestBase {
         try {
             verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
-    public void shouldDetectWhenInvokedMoreThanOnce() throws Exception {
+    public void shouldDetectWhenInvokedMoreThanOnce() {
         mock.add("foo");
         mock.clear();
         mock.clear();
@@ -98,11 +110,12 @@ public class BasicVerificationTest extends TestBase {
         try {
             verify(mock).clear();
             fail();
-        } catch (TooManyActualInvocations e) {}
+        } catch (TooManyActualInvocations e) {
+        }
     }
 
     @Test
-    public void shouldVerifyStubbedMethods() throws Exception {
+    public void shouldVerifyStubbedMethods() {
         when(mock.add("test")).thenReturn(Boolean.FALSE);
 
         mock.add("test");
@@ -110,15 +123,15 @@ public class BasicVerificationTest extends TestBase {
         verify(mock).add("test");
     }
 
-
     @Test
-    public void shouldDetectWhenOverloadedMethodCalled() throws Exception {
+    public void shouldDetectWhenOverloadedMethodCalled() {
         IMethods mockThree = mock(IMethods.class);
 
         mockThree.varargs((Object[]) new Object[] {});
         try {
             verify(mockThree).varargs((String[]) new String[] {});
             fail();
-        } catch(WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/CustomVerificationTest.java b/src/test/java/org/mockitousage/verification/CustomVerificationTest.java
deleted file mode 100644
index e38df06..0000000
--- a/src/test/java/org/mockitousage/verification/CustomVerificationTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitousage.verification;
-
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.exceptions.base.MockitoAssertionError;
-import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.internal.verification.api.VerificationData;
-import org.mockito.invocation.Invocation;
-import org.mockito.verification.VerificationMode;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
-
-public class CustomVerificationTest extends TestBase {
-
-    @Mock IMethods mock;
-
-    @Test
-    public void custom_verification_with_old_api() {
-        //given:
-        mock.simpleMethod("a", 10);
-
-        //expect:
-        verify(mock, ignoreParametersUsingOldApi()).simpleMethod();
-
-        try {
-            verify(mock, ignoreParametersUsingOldApi()).otherMethod();
-            fail();
-        } catch (MockitoAssertionError e) {}
-    }
-
-    //Old api still supported, see https://github.com/mockito/mockito/issues/730
-    private VerificationMode ignoreParametersUsingOldApi() {
-        return new VerificationMode() {
-            public void verify(VerificationData data) {
-                //use old api
-                InvocationMatcher target = data.getWanted();
-
-                //sanity check the new api
-                if (data.getTarget() != target) {
-                    throw new RuntimeException("Sanity check");
-                }
-
-                //look for the relevant invocation and exit if found
-                for (Invocation invocation : data.getAllInvocations()) {
-                    if (target.getInvocation().getMethod().getName().equals(invocation.getMethod().getName())) {
-                        return;
-                    }
-                }
-
-                //verification failed!
-                throw new MockitoAssertionError("Expected method with name: " + target + " not found in:\n" + data.getAllInvocations());
-            }
-            public VerificationMode description(String description) {
-                return this;
-            }
-        };
-    }
-}
diff --git a/src/test/java/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java b/src/test/java/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java
index 8e1bf06..9e5ffeb 100644
--- a/src/test/java/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java
+++ b/src/test/java/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -14,10 +17,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase {
 
     private IMethods one;
@@ -50,24 +49,24 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
             fail();
         } catch (VerificationInOrderFailure e) {
             String expected =
-                    "\n" +
-                    "Verification in order failure" +
-                    "\n" +
-                    "Wanted but not invoked:" +
-                    "\n" +
-                    "iMethods.simpleMethod(11);" +
-                    "\n" +
-                    "-> at ";
+                    "\n"
+                            + "Verification in order failure"
+                            + "\n"
+                            + "Wanted but not invoked:"
+                            + "\n"
+                            + "iMethods.simpleMethod(11);"
+                            + "\n"
+                            + "-> at ";
 
             assertThat(e).hasMessageContaining(expected);
 
             String expectedCause =
-                "\n" +
-                "Wanted anywhere AFTER following interaction:" +
-                "\n" +
-                "iMethods.simpleMethod(2);" +
-                "\n" +
-                "-> at ";
+                    "\n"
+                            + "Wanted anywhere AFTER following interaction:"
+                            + "\n"
+                            + "iMethods.simpleMethod(2);"
+                            + "\n"
+                            + "-> at ";
 
             assertThat(e).hasMessageContaining(expectedCause);
         }
@@ -80,12 +79,12 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
             fail();
         } catch (WantedButNotInvoked e) {
             String expected =
-                    "\n" +
-                    "Wanted but not invoked:" +
-                    "\n" +
-                    "iMethods.differentMethod();" +
-                    "\n" +
-                    "-> at";
+                    "\n"
+                            + "Wanted but not invoked:"
+                            + "\n"
+                            + "iMethods.differentMethod();"
+                            + "\n"
+                            + "-> at";
 
             assertThat(e).hasMessageContaining(expected);
         }
@@ -96,14 +95,15 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
         try {
             inOrder.verify(one).simpleMethod(999);
             fail();
-        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
-            assertThat(e).hasMessageContaining("has different arguments");
+        } catch (org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent e) {
+            assertThat(e).hasMessageContaining("have different arguments");
         }
     }
 
     @Test
     public void shouldNotSayArgumentsAreDifferent() {
-        //this is the last invocation so any next verification in order should simply say wanted but not invoked
+        // this is the last invocation so any next verification in order should simply say wanted
+        // but not invoked
         inOrder.verify(three).simpleMethod(3);
         try {
             inOrder.verify(one).simpleMethod(999);
@@ -124,12 +124,12 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
             fail();
         } catch (VerificationInOrderFailure e) {
             String expectedMessage =
-                    "\n" +
-                    "Verification in order failure" +
-                    "\n" +
-                    "Wanted but not invoked:" +
-                    "\n" +
-                    "iMethods.simpleMethod(999);";
+                    "\n"
+                            + "Verification in order failure"
+                            + "\n"
+                            + "Wanted but not invoked:"
+                            + "\n"
+                            + "iMethods.simpleMethod(999);";
             assertThat(e).hasMessageContaining(expectedMessage);
         }
     }
@@ -143,27 +143,23 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
             fail();
         } catch (VerificationInOrderFailure e) {
             String expectedMessage =
-                    "\n" +
-                    "Verification in order failure:" +
-                    "\n" +
-                    "iMethods.simpleMethod(2);" +
-                    "\n" +
-                    "Wanted 1 time:" +
-                    "\n" +
-                    "-> at";
+                    "\n"
+                            + "Verification in order failure:"
+                            + "\n"
+                            + "iMethods.simpleMethod(2);"
+                            + "\n"
+                            + "Wanted 1 time:"
+                            + "\n"
+                            + "-> at";
             assertThat(e).hasMessageContaining(expectedMessage);
 
-            String expectedCause =
-                "\n" +
-                "But was 2 times:" +
-                "\n" +
-                "-> at";
+            String expectedCause = "\n" + "But was 2 times:" + "\n" + "-> at";
             assertThat(e).hasMessageContaining(expectedCause);
         }
     }
 
     @Test
-    public void shouldPrintTooLittleInvocations() {
+    public void shouldPrintTooFewInvocations() {
         two.simpleMethod(2);
 
         inOrder.verify(one, atLeastOnce()).simpleMethod(anyInt());
@@ -175,21 +171,17 @@ public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase
             fail();
         } catch (VerificationInOrderFailure e) {
             String expectedMessage =
-                    "\n" +
-                    "Verification in order failure:" +
-                    "\n" +
-                    "iMethods.simpleMethod(2);" +
-                    "\n" +
-                    "Wanted 2 times:" +
-                    "\n" +
-                    "-> at";
+                    "\n"
+                            + "Verification in order failure:"
+                            + "\n"
+                            + "iMethods.simpleMethod(2);"
+                            + "\n"
+                            + "Wanted 2 times:"
+                            + "\n"
+                            + "-> at";
             assertThat(e).hasMessageContaining(expectedMessage);
 
-            String expectedCause =
-                "\n" +
-                "But was 1 time:" +
-                "\n" +
-                "-> at";
+            String expectedCause = "\n" + "But was 1 time:" + "\n" + "-> at";
 
             assertThat(e).hasMessageContaining(expectedCause);
         }
diff --git a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java
index 1d5bed0..7ad4627 100644
--- a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java
+++ b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java
@@ -2,22 +2,21 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.times;
+
+import java.util.LinkedList;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.Mockito;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
 import org.mockito.exceptions.verification.TooManyActualInvocations;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.times;
-
 @SuppressWarnings("unchecked")
 public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends TestBase {
 
@@ -33,11 +32,11 @@ public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends TestBase
         try {
             Mockito.verify(mock, times(100)).clear();
             fail();
-        } catch (TooLittleActualInvocations e) {
+        } catch (TooFewActualInvocations e) {
             assertThat(e)
-                .hasMessageContaining("mock.clear();")
-                .hasMessageContaining("Wanted 100 times")
-                .hasMessageContaining("was 3");
+                    .hasMessageContaining("mock.clear();")
+                    .hasMessageContaining("Wanted 100 times")
+                    .hasMessageContaining("was 3");
         }
     }
 
@@ -54,9 +53,9 @@ public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends TestBase
             fail();
         } catch (TooManyActualInvocations e) {
             assertThat(e)
-                .hasMessageContaining("mock.clear();")
-                .hasMessageContaining("Wanted 1 time")
-                .hasMessageContaining("was 4");
+                    .hasMessageContaining("mock.clear();")
+                    .hasMessageContaining("Wanted 1 time")
+                    .hasMessageContaining("was 4");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
index 43729f3..bae7c31 100644
--- a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
+++ b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
@@ -2,9 +2,15 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.AdditionalMatchers.aryEq;
+import static org.mockito.Mockito.*;
+
+import java.sql.Date;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -13,15 +19,10 @@ import org.mockito.Mockito;
 import org.mockito.exceptions.verification.NeverWantedButInvoked;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.AdditionalMatchers.aryEq;
-import static org.mockito.Mockito.*;
-
 public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
 
     private IMethods mock;
@@ -38,12 +39,12 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (WantedButNotInvoked e) {
             String expectedMessage =
-                    "\n" +
-                    "Wanted but not invoked:" +
-                    "\n" +
-                    "iMethods.simpleMethod();" +
-                    "\n" +
-                    "-> at";
+                    "\n"
+                            + "Wanted but not invoked:"
+                            + "\n"
+                            + "iMethods.simpleMethod();"
+                            + "\n"
+                            + "-> at";
             assertThat(e).hasMessageContaining(expectedMessage);
         }
     }
@@ -73,18 +74,18 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (ArgumentsAreDifferent e) {
             String wanted =
-                    "\n" +
-                    "Argument(s) are different! Wanted:" +
-                    "\n" +
-                    "iMethods.varargs(1, 1000);";
+                    "\n"
+                            + "Argument(s) are different! Wanted:"
+                            + "\n"
+                            + "iMethods.varargs(1, 1000);";
 
             assertThat(e).hasMessageContaining(wanted);
 
             String actual =
-                    "\n" +
-                    "Actual invocation has different arguments:" +
-                    "\n" +
-                    "iMethods.varargs(1, 2);";
+                    "\n"
+                            + "Actual invocations have different arguments:"
+                            + "\n"
+                            + "iMethods.varargs(1, 2);";
 
             assertThat(e).hasMessageContaining(actual);
         }
@@ -99,46 +100,49 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (ArgumentsAreDifferent e) {
             String wanted =
-                    "\n" +
-                    "Argument(s) are different! Wanted:" +
-                    "\n" +
-                    "iMethods.varargs(" +
-                    "\n" +
-                    "    \"x\"," +
-                    "\n" +
-                    "    \"y\"," +
-                    "\n" +
-                    "    \"z\"" +
-                    "\n" +
-                    ");";
+                    "\n"
+                            + "Argument(s) are different! Wanted:"
+                            + "\n"
+                            + "iMethods.varargs("
+                            + "\n"
+                            + "    \"x\","
+                            + "\n"
+                            + "    \"y\","
+                            + "\n"
+                            + "    \"z\""
+                            + "\n"
+                            + ");";
 
             assertThat(e).hasMessageContaining(wanted);
 
             String actual =
-                    "\n" +
-                    "Actual invocation has different arguments:" +
-                    "\n" +
-                    "iMethods.varargs(" +
-                    "\n" +
-                    "    \"this is very long string\"," +
-                    "\n" +
-                    "    \"this is another very long string\"" +
-                    "\n" +
-                    ");";
+                    "\n"
+                            + "Actual invocations have different arguments:"
+                            + "\n"
+                            + "iMethods.varargs("
+                            + "\n"
+                            + "    \"this is very long string\","
+                            + "\n"
+                            + "    \"this is another very long string\""
+                            + "\n"
+                            + ");";
 
             assertThat(e).hasMessageContaining(actual);
         }
     }
 
     @Test
-    public void should_print_actual_and_wanted_when_actual_method_name_and_wanted_method_name_are_the_same() {
+    public void
+            should_print_actual_and_wanted_when_actual_method_name_and_wanted_method_name_are_the_same() {
         mock.simpleMethod();
 
         try {
             verify(mock).simpleMethod(10);
             fail();
         } catch (ArgumentsAreDifferent e) {
-            assertThat(e).hasMessageContaining("simpleMethod(10)").hasMessageContaining("simpleMethod()");
+            assertThat(e)
+                    .hasMessageContaining("simpleMethod(10)")
+                    .hasMessageContaining("simpleMethod()");
         }
     }
 
@@ -167,44 +171,30 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             verifyNoMoreInteractions(mock);
             fail();
         } catch (NoInteractionsWanted e) {
-            String expectedMessage =
-                    "\n" +
-                    "No interactions wanted here:" +
-                    "\n" +
-                    "-> at";
+            String expectedMessage = "\n" + "No interactions wanted here:" + "\n" + "-> at";
             assertThat(e).hasMessageContaining(expectedMessage);
 
             String expectedCause =
-                    "\n" +
-                    "But found this interaction on mock '" + mock + "':" +
-                    "\n" +
-                    "-> at";
+                    "\n" + "But found this interaction on mock '" + mock + "':" + "\n" + "-> at";
             assertThat(e).hasMessageContaining(expectedCause);
         }
     }
 
     @Test
-    public void should_print_first_unexpected_invocation_when_verifying_zero_interactions() {
+    public void should_print_first_unexpected_invocation_when_verifying_no_interactions() {
         mock.twoArgumentMethod(1, 2);
         mock.threeArgumentMethod(1, "2", "3");
 
         try {
-            verifyZeroInteractions(mock);
+            verifyNoInteractions(mock);
             fail();
         } catch (NoInteractionsWanted e) {
-            String expected =
-                    "\n" +
-                    "No interactions wanted here:" +
-                    "\n" +
-                    "-> at";
+            String expected = "\n" + "No interactions wanted here:" + "\n" + "-> at";
 
             assertThat(e).hasMessageContaining(expected);
 
             String expectedCause =
-                "\n" +
-                "But found this interaction on mock '" + mock + "':" +
-                "\n" +
-                "-> at";
+                    "\n" + "But found these interactions on mock '" + mock + "':" + "\n" + "-> at";
 
             assertThat(e).hasMessageContaining(expectedCause);
         }
@@ -227,28 +217,28 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (WantedButNotInvoked e) {
             String expectedMessage =
-                "\n" +
-                "Wanted but not invoked:" +
-                "\n" +
-                "iMethods.twoArgumentMethod(\n" +
-                "    <any integer>,\n" +
-                "    100\n" +
-                ");";
+                    "\n"
+                            + "Wanted but not invoked:"
+                            + "\n"
+                            + "iMethods.twoArgumentMethod(\n"
+                            + "    <any integer>,\n"
+                            + "    100\n"
+                            + ");";
             assertThat(e).hasMessageContaining(expectedMessage);
         }
     }
 
     @Test
     public void should_print_method_when_missing_invocation_with_array_matcher() {
-        mock.oneArray(new boolean[] { true, false, false });
+        mock.oneArray(new boolean[] {true, false, false});
 
         try {
-            verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));
+            verify(mock).oneArray(aryEq(new boolean[] {false, false, false}));
             fail();
         } catch (ArgumentsAreDifferent e) {
             assertThat(e)
-                .hasMessageContaining("[false, false, false]")
-                .hasMessageContaining("[true, false, false]");
+                    .hasMessageContaining("[false, false, false]")
+                    .hasMessageContaining("[true, false, false]");
         }
     }
 
@@ -260,9 +250,7 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             verify(mock).varargsString(10, "111", "222", "333");
             fail();
         } catch (ArgumentsAreDifferent e) {
-            assertThat(e)
-                .hasMessageContaining("111")
-                .hasMessageContaining("\"xxx\"");
+            assertThat(e).hasMessageContaining("111").hasMessageContaining("\"xxx\"");
         }
     }
 
@@ -275,8 +263,8 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (ArgumentsAreDifferent e) {
             assertThat(e)
-                .hasMessageContaining("matches(\"burrito from Exmouth\")")
-                .hasMessageContaining("\"foo\"");
+                    .hasMessageContaining("matches(\"burrito from Exmouth\")")
+                    .hasMessageContaining("\"foo\"");
         }
     }
 
@@ -301,8 +289,8 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (NeverWantedButInvoked e) {
             assertThat(e)
-                .hasMessageContaining("Never wanted here:")
-                .hasMessageContaining("But invoked here:");
+                    .hasMessageContaining("Never wanted here:")
+                    .hasMessageContaining("But invoked here:");
         }
     }
 
@@ -315,9 +303,7 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             verify(mock).simpleMethod("bar");
             fail();
         } catch (ArgumentsAreDifferent e) {
-            assertThat(e)
-                .hasMessageContaining("bar")
-                .hasMessageContaining("foo");
+            assertThat(e).hasMessageContaining("bar").hasMessageContaining("foo");
         }
     }
 
@@ -332,13 +318,14 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (ArgumentsAreDifferent e) {
             assertThat(e)
-                .hasMessageContaining("iHavefunkyName.simpleMethod(20)")
-                .hasMessageContaining("iHavefunkyName.simpleMethod(10)");
+                    .hasMessageContaining("iHavefunkyName.simpleMethod(20)")
+                    .hasMessageContaining("iHavefunkyName.simpleMethod(10)");
         }
     }
 
     @Test
-    public void should_print_interactions_on_mock_when_ordinary_verification_fail() throws Exception {
+    public void should_print_interactions_on_mock_when_ordinary_verification_fail()
+            throws Exception {
         mock.otherMethod();
         mock.booleanReturningMethod();
 
@@ -346,7 +333,7 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             verify(mock).simpleMethod();
             fail();
         } catch (WantedButNotInvoked e) {
-//            assertContains("")
+            //            assertContains("")
         }
     }
 
@@ -357,13 +344,16 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
         try {
             verify(veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock).simpleMethod();
             fail();
-        } catch(WantedButNotInvoked e) {
-            assertThat(e).hasMessageContaining("veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()");
+        } catch (WantedButNotInvoked e) {
+            assertThat(e)
+                    .hasMessageContaining("veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()");
         }
     }
 
     @Test
-    public void should_print_method_name_and_arguments_of_other_interactions_with_different_methods() throws Exception {
+    public void
+            should_print_method_name_and_arguments_of_other_interactions_with_different_methods()
+                    throws Exception {
         try {
             mock.arrayMethod(new String[] {"a", "b", "c"});
             mock.forByte((byte) 25);
@@ -372,15 +362,134 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (WantedButNotInvoked e) {
             assertThat(e)
-                .hasMessageContaining("iMethods.threeArgumentMethod(12, foo, \"xx\")")
-                .hasMessageContaining("iMethods.arrayMethod([\"a\", \"b\", \"c\"])")
-                .hasMessageContaining("iMethods.forByte((byte) 0x19)");
+                    .hasMessageContaining("iMethods.threeArgumentMethod(12, foo, \"xx\")")
+                    .hasMessageContaining("iMethods.arrayMethod([\"a\", \"b\", \"c\"])")
+                    .hasMessageContaining("iMethods.forByte((byte) 0x19)");
+        }
+    }
+
+    @Test
+    public void should_print_fully_qualified_name_when_arguments_classes_have_same_simple_name() {
+        try {
+            mock.overloadedMethodWithSameClassNameArguments(new Date(0), new IMethods.Date(0));
+            verify(mock)
+                    .overloadedMethodWithSameClassNameArguments(new IMethods.Date(0), new Date(0));
+            fail();
+        } catch (Throwable e) {
+            String wanted =
+                    "\n"
+                            + "Argument(s) are different! Wanted:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithSameClassNameArguments("
+                            + "\n"
+                            + "    (org.mockitousage.IMethods.Date) 0,"
+                            + "\n"
+                            + "    (java.sql.Date) 1970-01-01"
+                            + "\n"
+                            + ");";
+
+            assertThat(e).hasMessageContaining(wanted);
+
+            String actual =
+                    "\n"
+                            + "Actual invocations have different arguments:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithSameClassNameArguments("
+                            + "\n"
+                            + "    (java.sql.Date) 1970-01-01,"
+                            + "\n"
+                            + "    (org.mockitousage.IMethods.Date) 0"
+                            + "\n"
+                            + ");";
+            assertThat(e).hasMessageContaining(actual);
+        }
+    }
+
+    @Test
+    public void
+            should_not_print_fully_qualified_name_when_arguments_classes_have_different_simple_name() {
+        try {
+            mock.overloadedMethodWithDifferentClassNameArguments("string", 0);
+            verify(mock).overloadedMethodWithDifferentClassNameArguments(0, "string");
+            fail();
+        } catch (Throwable e) {
+            String wanted =
+                    "\n"
+                            + "Argument(s) are different! Wanted:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithDifferentClassNameArguments("
+                            + "\n"
+                            + "    0,"
+                            + "\n"
+                            + "    \"string\""
+                            + "\n"
+                            + ");";
+
+            assertThat(e).hasMessageContaining(wanted);
+
+            String actual =
+                    "\n"
+                            + "Actual invocations have different arguments:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithDifferentClassNameArguments("
+                            + "\n"
+                            + "    \"string\","
+                            + "\n"
+                            + "    0"
+                            + "\n"
+                            + ");";
+            assertThat(e).hasMessageContaining(actual);
+        }
+    }
+
+    @Test
+    public void
+            should_print_fully_qualified_name_when_some_arguments_classes_have_same_simple_name() {
+        try {
+            mock.overloadedMethodWithSameClassNameArguments(
+                    new Date(0), "string", new IMethods.Date(0));
+            verify(mock)
+                    .overloadedMethodWithSameClassNameArguments(
+                            new IMethods.Date(0), "string", new Date(0));
+            fail();
+        } catch (Throwable e) {
+            String wanted =
+                    "\n"
+                            + "Argument(s) are different! Wanted:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithSameClassNameArguments("
+                            + "\n"
+                            + "    (org.mockitousage.IMethods.Date) 0,"
+                            + "\n"
+                            + "    \"string\","
+                            + "\n"
+                            + "    (java.sql.Date) 1970-01-01"
+                            + "\n"
+                            + ");";
+
+            assertThat(e).hasMessageContaining(wanted);
+
+            String actual =
+                    "\n"
+                            + "Actual invocations have different arguments:"
+                            + "\n"
+                            + "iMethods.overloadedMethodWithSameClassNameArguments("
+                            + "\n"
+                            + "    (java.sql.Date) 1970-01-01,"
+                            + "\n"
+                            + "    \"string\","
+                            + "\n"
+                            + "    (org.mockitousage.IMethods.Date) 0"
+                            + "\n"
+                            + ");";
+            assertThat(e).hasMessageContaining(actual);
         }
     }
 
     @Test
     @Ignore("issue 380 related")
-    public void should_print_method_name_and_arguments_of_other_interactions_of_same_method() throws Exception {
+    public void should_print_method_name_and_arguments_of_other_interactions_of_same_method()
+            throws Exception {
         try {
             mock.forByte((byte) 25);
             mock.forByte((byte) 12);
@@ -389,9 +498,9 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             fail();
         } catch (WantedButNotInvoked e) {
             assertThat(e)
-                .hasMessageContaining("iMethods.forByte(42)")
-                .hasMessageContaining("iMethods.forByte(25)")
-                .hasMessageContaining("iMethods.forByte(12)");
+                    .hasMessageContaining("iMethods.forByte(42)")
+                    .hasMessageContaining("iMethods.forByte(25)")
+                    .hasMessageContaining("iMethods.forByte(12)");
         }
     }
 
diff --git a/src/test/java/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java b/src/test/java/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java
index 40d2270..a3500b4 100644
--- a/src/test/java/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java
@@ -2,21 +2,20 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
+import java.util.LinkedList;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.exceptions.verification.*;
 import org.mockitoutil.TestBase;
 
-import java.util.LinkedList;
-
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 @SuppressWarnings("unchecked")
 public class ExactNumberOfTimesVerificationTest extends TestBase {
 
@@ -28,7 +27,7 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldDetectTooLittleActualInvocations() throws Exception {
+    public void shouldDetectTooFewActualInvocations() throws Exception {
         mock.clear();
         mock.clear();
 
@@ -36,10 +35,8 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
         try {
             verify(mock, times(100)).clear();
             fail();
-        } catch (TooLittleActualInvocations e) {
-            assertThat(e)
-                .hasMessageContaining("Wanted 100 times")
-                .hasMessageContaining("was 2");
+        } catch (TooFewActualInvocations e) {
+            assertThat(e).hasMessageContaining("Wanted 100 times").hasMessageContaining("was 2");
         }
     }
 
@@ -53,9 +50,7 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
             verify(mock, times(1)).clear();
             fail();
         } catch (TooManyActualInvocations e) {
-            assertThat(e)
-                .hasMessageContaining("Wanted 1 time")
-                .hasMessageContaining("was 2 times");
+            assertThat(e).hasMessageContaining("Wanted 1 time").hasMessageContaining("was 2 times");
         }
     }
 
@@ -65,7 +60,8 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
         try {
             verify(mock, times(15)).clear();
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 
     @Test
@@ -107,7 +103,8 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
         try {
             verify(mock, never()).add("one");
             fail();
-        } catch (NeverWantedButInvoked e) {}
+        } catch (NeverWantedButInvoked e) {
+        }
     }
 
     @Test
@@ -124,6 +121,7 @@ public class ExactNumberOfTimesVerificationTest extends TestBase {
         try {
             inOrder.verify(mock, never()).add("two");
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/FindingRedundantInvocationsInOrderTest.java b/src/test/java/org/mockitousage/verification/FindingRedundantInvocationsInOrderTest.java
index 271d95c..104f410 100644
--- a/src/test/java/org/mockitousage/verification/FindingRedundantInvocationsInOrderTest.java
+++ b/src/test/java/org/mockitousage/verification/FindingRedundantInvocationsInOrderTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mock;
@@ -13,11 +17,6 @@ import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verify;
-
 public class FindingRedundantInvocationsInOrderTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -25,36 +24,36 @@ public class FindingRedundantInvocationsInOrderTest extends TestBase {
 
     @Test
     public void shouldWorkFineIfNoInvocations() throws Exception {
-        //when
+        // when
         InOrder inOrder = inOrder(mock);
 
-        //then
+        // then
         inOrder.verifyNoMoreInteractions();
     }
 
     @Test
     public void shouldSayNoInteractionsWanted() throws Exception {
-        //when
+        // when
         mock.simpleMethod();
 
-        //then
+        // then
         InOrder inOrder = inOrder(mock);
         try {
             inOrder.verifyNoMoreInteractions();
             fail();
-        } catch(VerificationInOrderFailure e) {
+        } catch (VerificationInOrderFailure e) {
             assertThat(e).hasMessageContaining("No interactions wanted");
         }
     }
 
     @Test
     public void shouldVerifyNoMoreInteractionsInOrder() throws Exception {
-        //when
+        // when
         mock.simpleMethod();
         mock.simpleMethod(10);
         mock.otherMethod();
 
-        //then
+        // then
         InOrder inOrder = inOrder(mock);
         inOrder.verify(mock).simpleMethod(10);
         inOrder.verify(mock).otherMethod();
@@ -63,12 +62,12 @@ public class FindingRedundantInvocationsInOrderTest extends TestBase {
 
     @Test
     public void shouldVerifyNoMoreInteractionsInOrderWithMultipleMocks() throws Exception {
-        //when
+        // when
         mock.simpleMethod();
         mock2.simpleMethod();
         mock.otherMethod();
 
-        //then
+        // then
         InOrder inOrder = inOrder(mock, mock2);
         inOrder.verify(mock2).simpleMethod();
         inOrder.verify(mock).otherMethod();
@@ -77,47 +76,50 @@ public class FindingRedundantInvocationsInOrderTest extends TestBase {
 
     @Test
     public void shouldFailToVerifyNoMoreInteractionsInOrder() throws Exception {
-        //when
+        // when
         mock.simpleMethod();
         mock.simpleMethod(10);
         mock.otherMethod();
 
-        //then
+        // then
         InOrder inOrder = inOrder(mock);
         inOrder.verify(mock).simpleMethod(10);
         try {
             inOrder.verifyNoMoreInteractions();
             fail();
-        } catch(VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
     public void shouldFailToVerifyNoMoreInteractionsInOrderWithMultipleMocks() throws Exception {
-        //when
+        // when
         mock.simpleMethod();
         mock2.simpleMethod();
         mock.otherMethod();
 
-        //then
+        // then
         InOrder inOrder = inOrder(mock, mock2);
         inOrder.verify(mock2).simpleMethod();
         try {
             inOrder.verifyNoMoreInteractions();
             fail();
-        } catch(VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @SuppressWarnings({"MockitoUsage", "CheckReturnValue"})
     @Test
     public void shouldValidateState() throws Exception {
-        //when
+        // when
         InOrder inOrder = inOrder(mock);
         verify(mock); // mess up state
 
-        //then
+        // then
         try {
             inOrder.verifyNoMoreInteractions();
             fail();
-        } catch(UnfinishedVerificationException e) {}
+        } catch (UnfinishedVerificationException e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java b/src/test/java/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java
index 7f2187d..38ad1df 100644
--- a/src/test/java/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java
@@ -2,22 +2,27 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockitoutil.TestBase;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
 
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class NoMoreInteractionsVerificationTest extends TestBase {
@@ -30,7 +35,7 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldStubbingNotRegisterRedundantInteractions() throws Exception {
+    public void shouldStubbingNotRegisterRedundantInteractions() {
         when(mock.add("one")).thenReturn(true);
         when(mock.add("two")).thenReturn(true);
 
@@ -41,7 +46,7 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldVerifyWhenWantedNumberOfInvocationsUsed() throws Exception {
+    public void shouldVerifyWhenWantedNumberOfInvocationsUsed() {
         mock.add("one");
         mock.add("one");
         mock.add("one");
@@ -52,36 +57,29 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldVerifyNoInteractionsAsManyTimesAsYouWant() throws Exception {
-        verifyNoMoreInteractions(mock);
-        verifyNoMoreInteractions(mock);
-
-        verifyZeroInteractions(mock);
-        verifyZeroInteractions(mock);
-    }
-
-    @Test
-    public void shouldFailZeroInteractionsVerification() throws Exception {
+    public void shouldFailNoMoreInteractionsVerification() {
         mock.clear();
 
         try {
-            verifyZeroInteractions(mock);
+            verifyNoMoreInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
-    public void shouldFailNoMoreInteractionsVerification() throws Exception {
+    public void shouldFailNoInteractionsVerification() {
         mock.clear();
 
         try {
-            verifyNoMoreInteractions(mock);
+            verifyNoInteractions(mock);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
-    public void shouldPrintAllInvocationsWhenVerifyingNoMoreInvocations() throws Exception {
+    public void shouldPrintAllInvocationsWhenVerifyingNoMoreInvocations() {
         mock.add(1);
         mock.add(2);
         mock.clear();
@@ -96,7 +94,7 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldNotContainAllInvocationsWhenSingleUnwantedFound() throws Exception {
+    public void shouldNotContainAllInvocationsWhenSingleUnwantedFound() {
         mock.add(1);
 
         try {
@@ -108,7 +106,27 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
     }
 
     @Test
-    public void shouldVerifyOneMockButFailOnOther() throws Exception {
+    public void shouldVerifyOneMockButFailOnOther() {
+        List<String> list = mock(List.class);
+        Map<String, Integer> map = mock(Map.class);
+
+        list.add("one");
+        list.add("one");
+
+        map.put("one", 1);
+
+        verify(list, times(2)).add("one");
+
+        verifyNoMoreInteractions(list);
+        try {
+            verifyNoInteractions(map);
+            fail();
+        } catch (NoInteractionsWanted e) {
+        }
+    }
+
+    @Test
+    public void shouldVerifyOneMockButFailOnOtherVerifyNoInteractions() {
         List<String> list = mock(List.class);
         Map<String, Integer> map = mock(Map.class);
 
@@ -121,14 +139,24 @@ public class NoMoreInteractionsVerificationTest extends TestBase {
 
         verifyNoMoreInteractions(list);
         try {
-            verifyZeroInteractions(map);
+            verifyNoInteractions(map);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
-    @SuppressWarnings("all")
-    @Test(expected=MockitoException.class)
-    public void verifyNoMoreInteractionsShouldScreamWhenNullPassed() throws Exception {
-        verifyNoMoreInteractions((Object[])null);
+    // @SuppressWarnings("all")
+    @Test
+    public void verifyNoMoreInteractionsShouldScreamWhenNullPassed() {
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions((Object[]) null);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "Method requires argument(s)!",
+                        "Pass mocks that should be verified, e.g:",
+                        "    verifyNoMoreInteractions(mockOne, mockTwo);",
+                        "    verifyNoInteractions(mockOne, mockTwo);");
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/OnlyVerificationTest.java b/src/test/java/org/mockitousage/verification/OnlyVerificationTest.java
index b866877..94eafe6 100644
--- a/src/test/java/org/mockitousage/verification/OnlyVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/OnlyVerificationTest.java
@@ -2,22 +2,23 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.Mockito.only;
+import static org.mockito.Mockito.verify;
+
+import java.util.List;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
+import org.mockito.verification.VerificationMode;
 import org.mockitoutil.TestBase;
 
-import java.util.List;
-
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.verify;
-
 public class OnlyVerificationTest extends TestBase {
 
     @Mock private List<Object> mock;
@@ -42,7 +43,8 @@ public class OnlyVerificationTest extends TestBase {
         try {
             verify(mock, only()).get(0);
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 
     @Test
@@ -52,7 +54,8 @@ public class OnlyVerificationTest extends TestBase {
         try {
             verify(mock, only()).clear();
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -62,7 +65,8 @@ public class OnlyVerificationTest extends TestBase {
         try {
             verify(mock, only()).get(999);
             fail();
-        } catch (WantedButNotInvoked e) {}
+        } catch (WantedButNotInvoked e) {
+        }
     }
 
     @Test
@@ -72,7 +76,8 @@ public class OnlyVerificationTest extends TestBase {
         try {
             verify(mock, only()).get(2);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -83,4 +88,10 @@ public class OnlyVerificationTest extends TestBase {
         verify(mock2, only()).get(0);
     }
 
+    @Test
+    public void should_return_formatted_output_from_toString_method() {
+        VerificationMode only = only();
+
+        assertThat(only).hasToString("Wanted invocations count: 1 and no other method invoked");
+    }
 }
diff --git a/src/test/java/org/mockitousage/verification/OrdinaryVerificationPrintsAllInteractionsTest.java b/src/test/java/org/mockitousage/verification/OrdinaryVerificationPrintsAllInteractionsTest.java
index db85d39..0bf65fa 100644
--- a/src/test/java/org/mockitousage/verification/OrdinaryVerificationPrintsAllInteractionsTest.java
+++ b/src/test/java/org/mockitousage/verification/OrdinaryVerificationPrintsAllInteractionsTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.verify;
-
 public class OrdinaryVerificationPrintsAllInteractionsTest extends TestBase {
 
     @Mock private IMethods mock;
@@ -22,21 +21,22 @@ public class OrdinaryVerificationPrintsAllInteractionsTest extends TestBase {
 
     @Test
     public void shouldShowAllInteractionsOnMockWhenOrdinaryVerificationFail() throws Exception {
-        //given
+        // given
         firstInteraction();
         secondInteraction();
 
-        verify(mock).otherMethod(); //verify 1st interaction
+        verify(mock).otherMethod(); // verify 1st interaction
         try {
-            //when
+            // when
             verify(mock).simpleMethod();
             fail();
         } catch (WantedButNotInvoked e) {
-            //then
+            // then
             assertThat(e)
-                .hasMessageContaining("However, there were exactly 2 interactions with this mock")
-                .hasMessageContaining("firstInteraction(")
-                .hasMessageContaining("secondInteraction(");
+                    .hasMessageContaining(
+                            "However, there were exactly 2 interactions with this mock")
+                    .hasMessageContaining("firstInteraction(")
+                    .hasMessageContaining("secondInteraction(");
         }
     }
 
@@ -49,7 +49,9 @@ public class OrdinaryVerificationPrintsAllInteractionsTest extends TestBase {
             verify(mock).simpleMethod();
             fail();
         } catch (WantedButNotInvoked e) {
-            assertThat(e.getMessage()).contains("firstInteraction(").doesNotContain("differentMockInteraction(");
+            assertThat(e.getMessage())
+                    .contains("firstInteraction(")
+                    .doesNotContain("differentMockInteraction(");
         }
     }
 
diff --git a/src/test/java/org/mockitousage/verification/PrintingVerboseTypesWithArgumentsTest.java b/src/test/java/org/mockitousage/verification/PrintingVerboseTypesWithArgumentsTest.java
index 954b99f..472e184 100644
--- a/src/test/java/org/mockitousage/verification/PrintingVerboseTypesWithArgumentsTest.java
+++ b/src/test/java/org/mockitousage/verification/PrintingVerboseTypesWithArgumentsTest.java
@@ -2,107 +2,103 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import static org.junit.Assert.fail;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
 public class PrintingVerboseTypesWithArgumentsTest extends TestBase {
 
     class Boo {
-        public void withLong(long x) {
-        }
+        public void withLong(long x) {}
 
-        public void withLongAndInt(long x, int y) {
-        }
+        public void withLongAndInt(long x, int y) {}
     }
 
     @Test
     public void should_not_report_argument_types_when_to_string_is_the_same() {
-        //given
+        // given
         Boo boo = mock(Boo.class);
         boo.withLong(100);
 
         try {
-            //when
+            // when
             verify(boo).withLong(eq(100));
             fail();
         } catch (ArgumentsAreDifferent e) {
-            //then
+            // then
             assertThat(e)
-                .hasMessageContaining("withLong((Integer) 100);")
-                .hasMessageContaining("withLong((Long) 100L);");
+                    .hasMessageContaining("withLong((Integer) 100);")
+                    .hasMessageContaining("withLong((Long) 100L);");
         }
     }
 
     @Test
     public void should_show_the_type_of_only_the_argument_that_doesnt_match() {
-        //given
+        // given
         Boo boo = mock(Boo.class);
         boo.withLongAndInt(100, 200);
 
         try {
-            //when
+            // when
             verify(boo).withLongAndInt(eq(100), eq(200));
             fail();
         } catch (ArgumentsAreDifferent e) {
-            //then
+            // then
             assertThat(e)
-                .hasMessageContaining("withLongAndInt((Integer) 100, 200)")
-                .hasMessageContaining("withLongAndInt((Long) 100L, 200)");
+                    .hasMessageContaining("withLongAndInt((Integer) 100, 200)")
+                    .hasMessageContaining("withLongAndInt((Long) 100L, 200)");
         }
     }
 
     @Test
-    public void should_show_the_type_of_the_mismatching_argument_when_output_descriptions_for_invocations_are_different() {
-        //given
+    public void
+            should_show_the_type_of_the_mismatching_argument_when_output_descriptions_for_invocations_are_different() {
+        // given
         Boo boo = mock(Boo.class);
         boo.withLongAndInt(100, 200);
 
         try {
-            //when
+            // when
             verify(boo).withLongAndInt(eq(100), any(Integer.class));
             fail();
         } catch (ArgumentsAreDifferent e) {
-            //then
+            // then
             Assertions.assertThat(e.getMessage())
-                      .contains("withLongAndInt(\n" +
-                                        "    (Long) 100L,\n" +
-                                        "    200\n" +
-                                        ")")
-                      .contains("withLongAndInt(\n" +
-                                        "    (Integer) 100,\n" +
-                                        "    <any java.lang.Integer>\n" +
-                                        ")");
+                    .contains("withLongAndInt(\n" + "    (Long) 100L,\n" + "    200\n" + ")")
+                    .contains(
+                            "withLongAndInt(\n"
+                                    + "    (Integer) 100,\n"
+                                    + "    <any java.lang.Integer>\n"
+                                    + ")");
         }
     }
 
     @Test
     public void should_not_show_types_when_argument_value_is_different() {
-        //given
+        // given
         Boo boo = mock(Boo.class);
         boo.withLongAndInt(100, 200);
 
         try {
-            //when
+            // when
             verify(boo).withLongAndInt(eq(100L), eq(230));
             fail();
         } catch (ArgumentsAreDifferent e) {
-            //then
+            // then
             assertThat(e)
-                .hasMessageContaining("withLongAndInt(100L, 200)")
-                .hasMessageContaining("withLongAndInt(100L, 230)");
+                    .hasMessageContaining("withLongAndInt(100L, 200)")
+                    .hasMessageContaining("withLongAndInt(100L, 230)");
         }
     }
 
@@ -128,17 +124,18 @@ public class PrintingVerboseTypesWithArgumentsTest extends TestBase {
     }
 
     @Test
-    public void should_not_show_types_when_types_are_the_same_even_if_to_string_gives_the_same_result() {
-        //given
+    public void
+            should_not_show_types_when_types_are_the_same_even_if_to_string_gives_the_same_result() {
+        // given
         IMethods mock = mock(IMethods.class);
         mock.simpleMethod(new Foo(10));
 
         try {
-            //when
+            // when
             verify(mock).simpleMethod(new Foo(20));
             fail();
         } catch (ArgumentsAreDifferent e) {
-            //then
+            // then
             assertThat(e).hasMessageContaining("simpleMethod(foo)");
         }
     }
diff --git a/src/test/java/org/mockitousage/verification/RelaxedVerificationInOrderTest.java b/src/test/java/org/mockitousage/verification/RelaxedVerificationInOrderTest.java
index 876f1f4..d947dc8 100644
--- a/src/test/java/org/mockitousage/verification/RelaxedVerificationInOrderTest.java
+++ b/src/test/java/org/mockitousage/verification/RelaxedVerificationInOrderTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -15,9 +23,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 /**
  * ignored since 'relaxed' in order verification is not implemented (too complex to bother, maybe later).
  */
@@ -70,7 +75,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             verifyNoMoreInteractions(mockTwo);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -88,7 +94,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             verifyNoMoreInteractions(mockTwo);
             fail();
-        } catch(NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -105,7 +112,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockThree).simpleMethod(3);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -114,12 +122,26 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             verifyNoMoreInteractions(mockTwo);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
-    @Test(expected=VerificationInOrderFailure.class)
+    @Test
     public void shouldFailVerificationOfNonFirstChunk() {
-        inOrder.verify(mockTwo, times(1)).simpleMethod(2);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockTwo, times(1)).simpleMethod(2);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure:",
+                        "iMethods.simpleMethod(2);",
+                        "Wanted 1 time:",
+                        "-> at ",
+                        "But was 3 times:",
+                        "-> at ",
+                        "-> at ",
+                        "-> at ");
     }
 
     @Test
@@ -182,9 +204,30 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);
     }
 
-    @Test(expected=WantedButNotInvoked.class)
+    @Test
     public void shouldFailOnWrongMethodCalledOnMockTwo() {
-        inOrder.verify(mockTwo, atLeastOnce()).differentMethod();
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockTwo, atLeastOnce()).differentMethod();
+                        })
+                .isInstanceOf(WantedButNotInvoked.class)
+                .hasMessageContainingAll(
+                        "Wanted but not invoked:",
+                        "iMethods.differentMethod();",
+                        "-> at ",
+                        "However, there were exactly 6 interactions with this mock:",
+                        "iMethods.simpleMethod(1);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(3);",
+                        "-> at ",
+                        "iMethods.simpleMethod(2);",
+                        "-> at ",
+                        "iMethods.simpleMethod(4);",
+                        "-> at ");
     }
 
     @Test
@@ -195,7 +238,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             verify(mockOne, times(0)).simpleMethod(1);
             fail();
-        } catch (NeverWantedButInvoked e) {}
+        } catch (NeverWantedButInvoked e) {
+        }
     }
 
     @Test
@@ -204,12 +248,26 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockThree, times(0)).simpleMethod(3);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
-    @Test(expected=VerificationInOrderFailure.class)
+    @Test
     public void shouldFailWhenMockTwoWantedZeroTimes() {
-        inOrder.verify(mockTwo, times(0)).simpleMethod(2);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockTwo, times(0)).simpleMethod(2);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure:",
+                        "iMethods.simpleMethod(2);",
+                        "Wanted 0 times:",
+                        "-> at ",
+                        "But was 3 times:",
+                        "-> at ",
+                        "-> at ",
+                        "-> at ");
     }
 
     @Test
@@ -235,7 +293,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -244,7 +303,8 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockOne).simpleMethod(1);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -253,6 +313,7 @@ public class RelaxedVerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockOne).simpleMethod(999);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java b/src/test/java/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java
index f167369..39e5fdf 100644
--- a/src/test/java/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java
@@ -2,9 +2,11 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -13,9 +15,6 @@ import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 public class SelectedMocksInOrderVerificationTest extends TestBase {
 
     private IMethods mockOne;
@@ -85,7 +84,8 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             inOrder.verify(mockOne).differentMethod();
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -96,7 +96,8 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             inOrder.verify(mockOne).simpleMethod(1);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -124,7 +125,8 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             inOrder.verify(mockTwo).simpleMethod(2);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -134,17 +136,19 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             inOrder.verify(mockTwo, times(2)).simpleMethod(2);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
-    public void shouldThrowTooLittleInvocationsForMockTwo() {
+    public void shouldThrowTooFewInvocationsForMockTwo() {
         InOrder inOrder = inOrder(mockTwo);
 
         try {
             inOrder.verify(mockTwo, times(4)).simpleMethod(2);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -154,7 +158,8 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             inOrder.verify(mockTwo, times(2)).simpleMethod(2);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -183,6 +188,7 @@ public class SelectedMocksInOrderVerificationTest extends TestBase {
         try {
             verifyNoMoreInteractions(mockTwo);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationExcludingStubsTest.java b/src/test/java/org/mockitousage/verification/VerificationExcludingStubsTest.java
index a1b0874..1494d08 100644
--- a/src/test/java/org/mockitousage/verification/VerificationExcludingStubsTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationExcludingStubsTest.java
@@ -2,9 +2,16 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.ignoreStubs;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import org.junit.Test;
 import org.mockito.InOrder;
 import org.mockito.Mock;
@@ -13,45 +20,46 @@ import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.*;
-
 @SuppressWarnings("unchecked")
 public class VerificationExcludingStubsTest extends TestBase {
 
     @Mock IMethods mock;
 
     @Test
-    public void shouldAllowToExcludeStubsForVerification() throws Exception {
-        //given
+    public void shouldAllowToExcludeStubsForVerification() {
+        // given
         when(mock.simpleMethod()).thenReturn("foo");
 
-        //when
-        String stubbed = mock.simpleMethod(); //irrelevant call because it is stubbing
+        // when
+        String stubbed = mock.simpleMethod(); // irrelevant call because it is stubbing
         mock.objectArgMethod(stubbed);
 
-        //then
+        // then
         verify(mock).objectArgMethod("foo");
 
-        //verifyNoMoreInteractions fails:
-        try { verifyNoMoreInteractions(mock); fail(); } catch (NoInteractionsWanted e) {}
+        // verifyNoMoreInteractions fails:
+        try {
+            verifyNoMoreInteractions(mock);
+            fail();
+        } catch (NoInteractionsWanted e) {
+        }
 
-        //but it works when stubs are ignored:
-        ignoreStubs(mock);
+        // but it works when stubs are ignored:
+        Object[] ignored = ignoreStubs(mock);
         verifyNoMoreInteractions(mock);
     }
 
     @Test
-    public void shouldExcludeFromVerificationInOrder() throws Exception {
-        //given
+    public void shouldExcludeFromVerificationInOrder() {
+        // given
         when(mock.simpleMethod()).thenReturn("foo");
 
-        //when
+        // when
         mock.objectArgMethod("1");
         mock.objectArgMethod("2");
-        mock.simpleMethod(); //calling the stub
+        mock.simpleMethod(); // calling the stub
 
-        //then
+        // then
         InOrder inOrder = inOrder(ignoreStubs(mock));
         inOrder.verify(mock).objectArgMethod("1");
         inOrder.verify(mock).objectArgMethod("2");
@@ -59,14 +67,23 @@ public class VerificationExcludingStubsTest extends TestBase {
         verifyNoMoreInteractions(mock);
     }
 
-    @Test(expected = NotAMockException.class)
-    public void shouldIgnoringStubsDetectNulls() throws Exception {
-        ignoreStubs(mock, null);
+    @Test
+    public void shouldIgnoringStubsDetectNulls() {
+        assertThatThrownBy(
+                        () -> {
+                            Object ignored = ignoreStubs(mock, null);
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is null!");
     }
 
-    @Test(expected = NotAMockException.class)
-    public void shouldIgnoringStubsDetectNonMocks() throws Exception {
-        ignoreStubs(mock, new Object());
+    @Test
+    public void shouldIgnoringStubsDetectNonMocks() {
+        assertThatThrownBy(
+                        () -> {
+                            Object ignored = ignoreStubs(mock, new Object());
+                        })
+                .isInstanceOf(NotAMockException.class)
+                .hasMessage("Argument should be a mock, but is: class java.lang.Object");
     }
-
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java b/src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdinaryVerificationTest.java
similarity index 78%
rename from src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java
rename to src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdinaryVerificationTest.java
index beb6b84..8a978e4 100644
--- a/src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationInOrderMixedWithOrdinaryVerificationTest.java
@@ -2,9 +2,19 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -14,10 +24,7 @@ import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
-public class VerificationInOrderMixedWithOrdiraryVerificationTest extends TestBase {
+public class VerificationInOrderMixedWithOrdinaryVerificationTest extends TestBase {
 
     private IMethods mockOne;
     private IMethods mockTwo;
@@ -83,7 +90,8 @@ public class VerificationInOrderMixedWithOrdiraryVerificationTest extends TestBa
         try {
             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -95,7 +103,8 @@ public class VerificationInOrderMixedWithOrdiraryVerificationTest extends TestBa
         try {
             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);
             fail();
-        } catch (NoInteractionsWanted e) {}
+        } catch (NoInteractionsWanted e) {
+        }
     }
 
     @Test
@@ -116,12 +125,22 @@ public class VerificationInOrderMixedWithOrdiraryVerificationTest extends TestBa
         try {
             inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
-    @Test(expected=MockitoException.class)
+    @Test
     public void shouldScreamWhenUnfamiliarMockPassedToInOrderObject() {
-        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(1);
+        assertThatThrownBy(
+                        () -> {
+                            inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(1);
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContainingAll(
+                        "InOrder can only verify mocks that were passed in during creation of InOrder.",
+                        "For example:",
+                        "    InOrder inOrder = inOrder(mockOne);",
+                        "    inOrder.verify(mockOne).doStuff();");
     }
 
     @Test
diff --git a/src/test/java/org/mockitousage/verification/VerificationInOrderTest.java b/src/test/java/org/mockitousage/verification/VerificationInOrderTest.java
index 3207d53..030ac0d 100644
--- a/src/test/java/org/mockitousage/verification/VerificationInOrderTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationInOrderTest.java
@@ -2,9 +2,12 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.*;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -13,10 +16,6 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.fail;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
-
 public class VerificationInOrderTest extends TestBase {
 
     private IMethods mockOne;
@@ -48,7 +47,8 @@ public class VerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockOne).simpleMethod(1);
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -78,7 +78,8 @@ public class VerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockOne, atLeastOnce()).simpleMethod();
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 
     @Test
@@ -97,6 +98,7 @@ public class VerificationInOrderTest extends TestBase {
         try {
             inOrder.verify(mockOne, times(3)).simpleMethod(anyInt());
             fail();
-        } catch (VerificationInOrderFailure e) {}
+        } catch (VerificationInOrderFailure e) {
+        }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationInOrderWithCallsTest.java b/src/test/java/org/mockitousage/verification/VerificationInOrderWithCallsTest.java
index 4c52b34..f2861b7 100644
--- a/src/test/java/org/mockitousage/verification/VerificationInOrderWithCallsTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationInOrderWithCallsTest.java
@@ -4,9 +4,15 @@
  */
 package org.mockitousage.verification;
 
-import org.junit.Rule;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.atLeast;
+import static org.mockito.Mockito.calls;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.exceptions.base.MockitoException;
@@ -15,129 +21,129 @@ import org.mockito.exceptions.verification.VerificationInOrderFailure;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.mockito.Mockito.*;
-
 public class VerificationInOrderWithCallsTest extends TestBase {
 
     @Mock private IMethods mockOne;
     @Mock private IMethods mockTwo;
-    @Rule
-    public ExpectedException exceptionRule = ExpectedException.none();
 
     @Test
-    public void shouldFailWhenMethodNotCalled(){
+    public void shouldFailWhenMethodNotCalled() {
         // Given
-        mockOne.oneArg( 1 );
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "Verification in order failure" );
-        exceptionRule.expectMessage( "Wanted but not invoked" );
-        exceptionRule.expectMessage( "mockOne.oneArg(2)" );
-
-        // When
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
-
-        // Then - expected exception thrown
+        mockOne.oneArg(1);
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(1)).oneArg(2);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "Wanted but not invoked",
+                        "mockOne.oneArg(2)");
     }
 
     @Test
-    public void shouldFailWhenMethodCalledTooFewTimes(){
+    public void shouldFailWhenMethodCalledTooFewTimes() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "Verification in order failure" );
-        exceptionRule.expectMessage( "mockOne.oneArg(2)" );
-        exceptionRule.expectMessage( "Wanted 2 times" );
-        exceptionRule.expectMessage( "But was 1 time" );
-
-        // When
-        verifier.verify( mockOne, calls(2)).oneArg( 2 );
-
-        // Then - expected exception thrown
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(2)).oneArg(2);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "mockOne.oneArg(2)",
+                        "Wanted 2 times",
+                        "But was 1 time");
     }
 
     @Test
-    public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){
+    public void shouldFailWhenSingleMethodCallsAreOutOfSequence() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "Verification in order failure" );
-        exceptionRule.expectMessage( "Wanted but not invoked" );
-        exceptionRule.expectMessage( "mockOne.oneArg(1)" );
-
-        // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        // Then - expected exception thrown
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(2);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(1)).oneArg(1);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "Wanted but not invoked",
+                        "mockOne.oneArg(1)");
     }
 
     @Test
-    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){
+    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence() {
         // Given
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
 
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "Verification in order failure" );
-        exceptionRule.expectMessage( "Wanted but not invoked" );
-        exceptionRule.expectMessage( "mockOne.oneArg(1)" );
-
-        // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(1)).oneArg(1);
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "Wanted but not invoked",
+                        "mockOne.oneArg(1)");
     }
 
     @Test
-    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){
+    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence() {
         // Given
         mockOne.voidMethod();
         mockTwo.voidMethod();
 
-        InOrder verifier = inOrder( mockOne, mockTwo );
-        verifier.verify( mockTwo, calls(1)).voidMethod();
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "Verification in order failure" );
-        exceptionRule.expectMessage( "Wanted but not invoked" );
-        exceptionRule.expectMessage( "mockOne.voidMethod()" );
-
-        // When
-        verifier.verify( mockOne, calls(1)).voidMethod();
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne, mockTwo);
+        verifier.verify(mockTwo, calls(1)).voidMethod();
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(1)).voidMethod();
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContainingAll(
+                        "Verification in order failure",
+                        "Wanted but not invoked",
+                        "mockOne.voidMethod()");
     }
 
-
     @Test
-    public void shouldAllowSequentialCallsToCallsForSingleMethod(){
+    public void shouldAllowSequentialCallsToCallsForSingleMethod() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(2)).oneArg( 2 );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(2)).oneArg(2);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
         verifyNoMoreInteractions(mockOne);
         verifier.verifyNoMoreInteractions();
 
@@ -145,19 +151,19 @@ public class VerificationInOrderWithCallsTest extends TestBase {
     }
 
     @Test
-    public void shouldAllowSequentialCallsToCallsForDifferentMethods(){
+    public void shouldAllowSequentialCallsToCallsForDifferentMethods() {
         // Given
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
         mockOne.voidMethod();
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(2)).voidMethod();
-        verifier.verify( mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(2)).voidMethod();
+        verifier.verify(mockOne, calls(1)).oneArg(1);
         verifyNoMoreInteractions(mockOne);
         verifier.verifyNoMoreInteractions();
 
@@ -165,19 +171,19 @@ public class VerificationInOrderWithCallsTest extends TestBase {
     }
 
     @Test
-    public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){
+    public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks() {
         // Given
         mockOne.voidMethod();
         mockTwo.voidMethod();
         mockTwo.voidMethod();
         mockOne.voidMethod();
 
-        InOrder verifier = inOrder( mockOne, mockTwo );
+        InOrder verifier = inOrder(mockOne, mockTwo);
 
         // When
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockTwo, calls(2)).voidMethod();
-        verifier.verify( mockOne, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockTwo, calls(2)).voidMethod();
+        verifier.verify(mockOne, calls(1)).voidMethod();
         verifyNoMoreInteractions(mockOne);
         verifyNoMoreInteractions(mockTwo);
         verifier.verifyNoMoreInteractions();
@@ -185,131 +191,130 @@ public class VerificationInOrderWithCallsTest extends TestBase {
         // Then - no exception thrown
     }
 
-
     @Test
-    public void shouldAllowFewerCallsForSingleMethod(){
+    public void shouldAllowFewerCallsForSingleMethod() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).oneArg(2);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).oneArg(2);
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){
+    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
-
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        exceptionRule.expect( NoInteractionsWanted.class );
-
-        // When
-        verifyNoMoreInteractions( mockOne );
-
-        // Then - expected exception thrown
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
+
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).oneArg(2);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(mockOne);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class);
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){
+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).oneArg( 2 );
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "No interactions wanted here" );
-
-        // When
-        verifier.verifyNoMoreInteractions();
-
-        // Then - expected exception thrown
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).oneArg(2);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verifyNoMoreInteractions();
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("No interactions wanted here");
     }
 
     @Test
-    public void shouldAllowFewerCallsForDifferentMethods(){
+    public void shouldAllowFewerCallsForDifferentMethods() {
         // Given
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
         mockOne.voidMethod();
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).voidMethod();
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){
+    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods() {
         // Given
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
         mockOne.voidMethod();
-        mockOne.oneArg( 1 );
-
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-
-        exceptionRule.expect( NoInteractionsWanted.class );
-
-        // When
-        verifyNoMoreInteractions( mockOne );
-
-        // Then - no exception thrown
+        mockOne.oneArg(1);
+
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+
+        // When / Then - no exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(mockOne);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class);
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){
+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods() {
         // Given
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
         mockOne.voidMethod();
         mockOne.voidMethod();
 
-        InOrder verifier = inOrder( mockOne );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "No interactions wanted here" );
-
-        // When
-        verifier.verifyNoMoreInteractions();
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verifyNoMoreInteractions();
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("No interactions wanted here");
     }
 
     @Test
-    public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){
+    public void shouldAllowFewerCallsForMethodsOnDifferentMocks() {
         // Given
         mockOne.voidMethod();
         mockTwo.voidMethod();
@@ -317,181 +322,184 @@ public class VerificationInOrderWithCallsTest extends TestBase {
         mockOne.voidMethod();
         mockTwo.voidMethod();
 
-        InOrder verifier = inOrder( mockOne, mockTwo );
+        InOrder verifier = inOrder(mockOne, mockTwo);
 
         // When
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockTwo, calls(1)).voidMethod();
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockTwo, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockTwo, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockTwo, calls(1)).voidMethod();
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){
+    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks() {
         // Given
         mockOne.voidMethod();
         mockTwo.voidMethod();
         mockTwo.voidMethod();
         mockOne.voidMethod();
 
-        InOrder verifier = inOrder( mockOne, mockTwo );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockTwo, calls(1)).voidMethod();
-        verifier.verify( mockOne, calls(1)).voidMethod();
-
-        exceptionRule.expect(NoInteractionsWanted.class);
-
-        // When
-        verifyNoMoreInteractions( mockTwo );
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne, mockTwo);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockTwo, calls(1)).voidMethod();
+        verifier.verify(mockOne, calls(1)).voidMethod();
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifyNoMoreInteractions(mockTwo);
+                        })
+                .isInstanceOf(NoInteractionsWanted.class);
     }
 
     @Test
-    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){
+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks() {
         // Given
         mockOne.voidMethod();
         mockTwo.voidMethod();
         mockTwo.voidMethod();
 
-        InOrder verifier = inOrder( mockOne, mockTwo );
-        verifier.verify( mockOne, calls(1)).voidMethod();
-        verifier.verify( mockTwo, calls(1)).voidMethod();
-
-        exceptionRule.expect( VerificationInOrderFailure.class );
-        exceptionRule.expectMessage( "No interactions wanted here" );
-
-        // When
-        verifier.verifyNoMoreInteractions();
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne, mockTwo);
+        verifier.verify(mockOne, calls(1)).voidMethod();
+        verifier.verify(mockTwo, calls(1)).voidMethod();
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verifyNoMoreInteractions();
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("No interactions wanted here");
     }
 
     @Test
-    public void shouldVerifyWithCallsAfterUseOfTimes(){
+    public void shouldVerifyWithCallsAfterUseOfTimes() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, times(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(2)).oneArg( 2 );
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
+        verifier.verify(mockOne, times(1)).oneArg(1);
+        verifier.verify(mockOne, calls(2)).oneArg(2);
+        verifier.verify(mockOne, calls(1)).oneArg(1);
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldVerifyWithCallsAfterUseOfAtLeast(){
+    public void shouldVerifyWithCallsAfterUseOfAtLeast() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );
-        verifier.verify( mockOne, calls(2)).oneArg( 2 );
+        verifier.verify(mockOne, atLeast(1)).oneArg(1);
+        verifier.verify(mockOne, calls(2)).oneArg(2);
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldVerifyWithTimesAfterUseOfCalls(){
+    public void shouldVerifyWithTimesAfterUseOfCalls() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, times(2)).oneArg( 2 );
-        verifier.verify( mockOne, times(1)).oneArg( 1 );
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, times(2)).oneArg(2);
+        verifier.verify(mockOne, times(1)).oneArg(1);
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldVerifyWithAtLeastAfterUseOfCalls(){
+    public void shouldVerifyWithAtLeastAfterUseOfCalls() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 2 );
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(2);
+        mockOne.oneArg(2);
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, atLeast(1)).oneArg( 2 );
-        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, atLeast(1)).oneArg(2);
+        verifier.verify(mockOne, atLeast(1)).oneArg(1);
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldVerifyWithTimesAfterCallsInSameChunk(){
+    public void shouldVerifyWithTimesAfterCallsInSameChunk() {
         // Given
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 1 );
-        mockOne.oneArg( 1 );
+        mockOne.oneArg(1);
+        mockOne.oneArg(1);
+        mockOne.oneArg(1);
 
-        InOrder verifier = inOrder( mockOne );
+        InOrder verifier = inOrder(mockOne);
 
         // When
-        verifier.verify( mockOne, calls(1)).oneArg( 1 );
-        verifier.verify( mockOne, times(2)).oneArg( 1 );
+        verifier.verify(mockOne, calls(1)).oneArg(1);
+        verifier.verify(mockOne, times(2)).oneArg(1);
         verifier.verifyNoMoreInteractions();
 
         // Then - no exception thrown
     }
 
     @Test
-    public void shouldFailToCreateCallsWithZeroArgument(){
+    public void shouldFailToCreateCallsWithZeroArgument() {
         // Given
-        InOrder verifier = inOrder( mockOne );
-        exceptionRule.expect( MockitoException.class );
-        exceptionRule.expectMessage( "Negative and zero values are not allowed here" );
-
-        // When
-        verifier.verify( mockOne, calls(0)).voidMethod();
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(0)).voidMethod();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Negative and zero values are not allowed here");
     }
 
     @Test
-    public void shouldFailToCreateCallsWithNegativeArgument(){
+    public void shouldFailToCreateCallsWithNegativeArgument() {
         // Given
-        InOrder verifier = inOrder( mockOne );
-        exceptionRule.expect( MockitoException.class );
-        exceptionRule.expectMessage( "Negative and zero values are not allowed here" );
-
-        // When
-        verifier.verify( mockOne, calls(-1)).voidMethod();
-
-        // Then - expected exception thrown
+        InOrder verifier = inOrder(mockOne);
+
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verifier.verify(mockOne, calls(-1)).voidMethod();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Negative and zero values are not allowed here");
     }
 
     @Test
-    public void shouldFailToCreateCallsForNonInOrderVerification(){
+    public void shouldFailToCreateCallsForNonInOrderVerification() {
         // Given
         mockOne.voidMethod();
-        exceptionRule.expect( MockitoException.class );
-        exceptionRule.expectMessage( "calls is only intended to work with InOrder" );
-
-        // When
-        verify( mockOne, calls(1)).voidMethod();
 
-        // Then - expected exception thrown
+        // When / Then - expected exception thrown
+        assertThatThrownBy(
+                        () -> {
+                            verify(mockOne, calls(1)).voidMethod();
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("calls is only intended to work with InOrder");
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationInOrderWithTimeoutTest.java b/src/test/java/org/mockitousage/verification/VerificationInOrderWithTimeoutTest.java
index 5e1bdcb..121399d 100644
--- a/src/test/java/org/mockitousage/verification/VerificationInOrderWithTimeoutTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationInOrderWithTimeoutTest.java
@@ -2,9 +2,13 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.mockito.Mockito.after;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.junit.MockitoJUnit.rule;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.After;
@@ -19,11 +23,6 @@ import org.mockito.junit.MockitoRule;
 import org.mockitousage.IMethods;
 import org.mockitoutil.async.AsyncTesting;
 
-import static org.mockito.Mockito.after;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.junit.MockitoJUnit.rule;
-
 public class VerificationInOrderWithTimeoutTest {
 
     @Rule public MockitoRule mockito = rule();
@@ -33,23 +32,28 @@ public class VerificationInOrderWithTimeoutTest {
 
     private AsyncTesting async;
 
-    @Before public void setUp() {
+    @Before
+    public void setUp() {
         async = new AsyncTesting();
     }
 
-    @After public void tearDown() {
+    @After
+    public void tearDown() {
         async.cleanUp();
     }
 
     @Test
     public void should_not_allow_in_order_with_after() {
         // expect
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                inOrder(mock1).verify(mock1, after(100)).oneArg('a');
-            }
-        }).isInstanceOf(MockitoException.class).hasMessageContaining("not implemented to work with InOrder");
-        //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                inOrder(mock1).verify(mock1, after(100)).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("not implemented to work with InOrder");
+        // TODO specific exception
     }
 
     @Test
@@ -74,13 +78,16 @@ public class VerificationInOrderWithTimeoutTest {
         // then
         final InOrder inOrder = inOrder(mock1, mock2);
         inOrder.verify(mock2, timeout(300)).oneArg('b');
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                inOrder.verify(mock1, timeout(300)).oneArg('a');
-            }
-        }).isInstanceOf(VerificationInOrderFailure.class)
-            .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
-            .hasMessageContaining("Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                inOrder.verify(mock1, timeout(300)).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
+                .hasMessageContaining(
+                        "Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
     }
 
     @Test
@@ -109,24 +116,30 @@ public class VerificationInOrderWithTimeoutTest {
         final InOrder inOrder = inOrder(mock1, mock2);
         inOrder.verify(mock2, timeout(500).times(2)).oneArg('b');
 
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                inOrder.verify(mock1, timeout(100).times(2)).oneArg('a');
-            }
-        }).isInstanceOf(VerificationInOrderFailure.class)
-            .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
-            .hasMessageContaining("Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                inOrder.verify(mock1, timeout(100).times(2)).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
+                .hasMessageContaining(
+                        "Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
     }
 
     @Test
     public void should_not_allow_in_order_with_only() {
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() throws Throwable {
-                inOrder(mock1).verify(mock1, timeout(200).only()).oneArg('a');
-            }
-        }).isInstanceOf(MockitoException.class).hasMessageContaining("not implemented to work with InOrder");
-        //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() throws Throwable {
+                                inOrder(mock1).verify(mock1, timeout(200).only()).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("not implemented to work with InOrder");
+        // TODO specific exception
     }
 
     @Test
@@ -154,13 +167,16 @@ public class VerificationInOrderWithTimeoutTest {
         // then
         final InOrder inOrder = inOrder(mock1, mock2);
         inOrder.verify(mock2, timeout(300).atLeastOnce()).oneArg('b');
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                inOrder.verify(mock1, timeout(500).atLeastOnce()).oneArg('a');
-            }
-        }).isInstanceOf(VerificationInOrderFailure.class)
-            .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
-            .hasMessageContaining("Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                inOrder.verify(mock1, timeout(500).atLeastOnce()).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(VerificationInOrderFailure.class)
+                .hasMessageContaining("Wanted but not invoked:\nmock1.oneArg('a');")
+                .hasMessageContaining(
+                        "Wanted anywhere AFTER following interaction:\nmock2.oneArg('b');");
     }
 
     @Test
@@ -188,12 +204,14 @@ public class VerificationInOrderWithTimeoutTest {
         // then
         final InOrder inOrder = inOrder(mock1, mock2);
         inOrder.verify(mock2, timeout(300).atLeast(2)).oneArg('b');
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                inOrder.verify(mock1, timeout(500).atLeast(2)).oneArg('a');
-            }
-        }).isInstanceOf(AssertionError.class)
-            .hasMessageContaining("Verification in order failure");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                inOrder.verify(mock1, timeout(500).atLeast(2)).oneArg('a');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Verification in order failure");
     }
 
     private Runnable callMock(final IMethods mock, final char c) {
diff --git a/src/test/java/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java b/src/test/java/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java
index 45bf19d..77e7e46 100644
--- a/src/test/java/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java
@@ -2,19 +2,18 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockitoutil.TestBase;
+import static org.mockito.Mockito.*;
 
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import static org.mockito.Mockito.*;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockitoutil.TestBase;
 
 @SuppressWarnings("unchecked")
 public class VerificationOnMultipleMocksUsingMatchersTest extends TestBase {
@@ -30,10 +29,10 @@ public class VerificationOnMultipleMocksUsingMatchersTest extends TestBase {
         map.put("test", 100);
         map.put("test two", 200);
 
-        verify(list).add(anyObject());
+        verify(list).add(any());
         verify(list).add(anyInt(), eq("test two"));
 
-        verify(map, times(2)).put(anyObject(), anyObject());
+        verify(map, times(2)).put(any(), any());
         verify(map).put(eq("test two"), eq(200));
 
         verifyNoMoreInteractions(list, map);
@@ -56,9 +55,9 @@ public class VerificationOnMultipleMocksUsingMatchersTest extends TestBase {
         verify(list, times(1)).add("two");
         verify(list, times(0)).add("three");
 
-        verify(map, times(2)).put(anyObject(), anyInt());
+        verify(map, times(2)).put(any(), anyInt());
 
         verifyNoMoreInteractions(list, map);
-        verifyZeroInteractions(set);
+        verifyNoInteractions(set);
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationStartedListenerTest.java b/src/test/java/org/mockitousage/verification/VerificationStartedListenerTest.java
index bac0e7a..5d585f4 100644
--- a/src/test/java/org/mockitousage/verification/VerificationStartedListenerTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationStartedListenerTest.java
@@ -4,6 +4,15 @@
  */
 package org.mockitousage.verification;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.Mockito;
@@ -12,15 +21,6 @@ import org.mockito.listeners.VerificationStartedEvent;
 import org.mockito.listeners.VerificationStartedListener;
 import org.mockitoutil.TestBase;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 /**
  * This test demonstrates how verification started listeners work.
  * The test cases are contrived but they provide necessary coverage.
@@ -30,98 +30,124 @@ public class VerificationStartedListenerTest extends TestBase {
 
     @Test
     public void verified_mock_can_be_replaced() throws Exception {
-        //given
+        // given
         final List mock1 = mock(List.class);
-        mock1.clear(); //register clear() on mock1
-
-        //when
-        List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
-            public void onVerificationStarted(VerificationStartedEvent event) {
-                //this is a hack to simulate desired behavior
-                event.setMock(mock1);
-            }
-        }));
-
-        //then verified mock is not mock2 that was passed to 'verify' but the replacement: mock1
+        mock1.clear(); // register clear() on mock1
+
+        // when
+        List mock2 =
+                mock(
+                        List.class,
+                        Mockito.withSettings()
+                                .verificationStartedListeners(
+                                        new VerificationStartedListener() {
+                                            public void onVerificationStarted(
+                                                    VerificationStartedEvent event) {
+                                                // this is a hack to simulate desired behavior
+                                                event.setMock(mock1);
+                                            }
+                                        }));
+
+        // then verified mock is not mock2 that was passed to 'verify' but the replacement: mock1
         List verifiedMock = verify(mock2);
         assertEquals(mock1, verifiedMock);
 
-        //and verification is successful because mock1.clear() was called
+        // and verification is successful because mock1.clear() was called
         verifiedMock.clear();
 
-        //this test is admittedly contrived. it's goal is to provide coverage for the key functionality of the listener
-        //see the discussion at https://github.com/mockito/mockito/issues/1191
+        // this test is admittedly contrived. it's goal is to provide coverage for the key
+        // functionality of the listener
+        // see the discussion at https://github.com/mockito/mockito/issues/1191
     }
 
     @Test
     public void verification_started_event_contains_correct_mock() throws Exception {
-        //given
+        // given
         final List<Object> container = new ArrayList<Object>();
 
-        List mock = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
-            public void onVerificationStarted(VerificationStartedEvent event) {
-                //this is a hack to simulate desired behavior
-                container.add(event.getMock());
-            }
-        }));
-
-        //when
+        List mock =
+                mock(
+                        List.class,
+                        Mockito.withSettings()
+                                .verificationStartedListeners(
+                                        new VerificationStartedListener() {
+                                            public void onVerificationStarted(
+                                                    VerificationStartedEvent event) {
+                                                // this is a hack to simulate desired behavior
+                                                container.add(event.getMock());
+                                            }
+                                        }));
+
+        // when
         verify(mock, never()).clear();
 
-        //then
+        // then
         Assertions.assertThat(container).containsExactly(mock);
     }
 
     @Test
     public void listeners_are_executed_in_sequence() throws Exception {
-        //given
+        // given
         final List<Object> container = new ArrayList<Object>();
         final List mock1 = mock(List.class);
 
-        List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
-            public void onVerificationStarted(VerificationStartedEvent event) {
-                //this is a hack to simulate desired behavior
-                container.add(event.getMock());
-                event.setMock(mock1);
-            }
-        }, new VerificationStartedListener() {
-            @Override
-            public void onVerificationStarted(VerificationStartedEvent event) {
-                container.add(event.getMock());
-            }
-        }));
-
-        //when
+        List mock2 =
+                mock(
+                        List.class,
+                        Mockito.withSettings()
+                                .verificationStartedListeners(
+                                        new VerificationStartedListener() {
+                                            public void onVerificationStarted(
+                                                    VerificationStartedEvent event) {
+                                                // this is a hack to simulate desired behavior
+                                                container.add(event.getMock());
+                                                event.setMock(mock1);
+                                            }
+                                        },
+                                        new VerificationStartedListener() {
+                                            @Override
+                                            public void onVerificationStarted(
+                                                    VerificationStartedEvent event) {
+                                                container.add(event.getMock());
+                                            }
+                                        }));
+
+        // when
         verify(mock2, never()).clear();
 
-        //ensure that:
+        // ensure that:
         // 1. listeners were notified in sequence
         // 2. the state set by 1st listeners affects 2nd listener
         Assertions.assertThat(container).containsExactly(mock2, mock1);
 
-        //there is no particular reason we decided on that behavior
-        //we want to have a consistent and documented behavior of the verification started listener
+        // there is no particular reason we decided on that behavior
+        // we want to have a consistent and documented behavior of the verification started listener
     }
 
     @Test
     public void shows_clean_exception_when_null_array_passed() throws Exception {
         try {
-            //when
+            // when
             Mockito.withSettings().verificationStartedListeners(null);
             fail();
         } catch (MockitoException e) {
-            assertEquals("verificationStartedListeners() does not accept null vararg array. See the Javadoc.", e.getMessage());
+            assertEquals(
+                    "verificationStartedListeners() does not accept null vararg array. See the Javadoc.",
+                    e.getMessage());
         }
     }
 
     @Test
     public void shows_clean_exception_when_null_listener_passed() throws Exception {
         try {
-            //when
-            Mockito.withSettings().verificationStartedListeners(mock(VerificationStartedListener.class), null);
+            // when
+            Mockito.withSettings()
+                    .verificationStartedListeners(mock(VerificationStartedListener.class), null);
             fail();
         } catch (MockitoException e) {
-            assertEquals("verificationStartedListeners() does not accept null listeners. See the Javadoc.", e.getMessage());
+            assertEquals(
+                    "verificationStartedListeners() does not accept null listeners. See the Javadoc.",
+                    e.getMessage());
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationUsingMatchersTest.java b/src/test/java/org/mockitousage/verification/VerificationUsingMatchersTest.java
index 027eb2c..6e916b7 100644
--- a/src/test/java/org/mockitousage/verification/VerificationUsingMatchersTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationUsingMatchersTest.java
@@ -2,26 +2,29 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.ArgumentMatchers.same;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.isA;
+import static org.mockito.ArgumentMatchers.contains;
+import static org.mockito.AdditionalMatchers.geq;
+import static org.mockito.AdditionalMatchers.leq;
+import static org.mockito.AdditionalMatchers.and;
+
 import org.junit.Before;
 import org.junit.Test;
-import org.mockito.Matchers;
 import org.mockito.Mockito;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.fail;
-import static org.mockito.AdditionalMatchers.*;
-import static org.mockito.Matchers.*;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 public class VerificationUsingMatchersTest extends TestBase {
 
     private IMethods mock;
@@ -68,7 +71,8 @@ public class VerificationUsingMatchersTest extends TestBase {
         mock.threeArgumentMethod(11, "", "01234");
 
         try {
-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));
+            verify(mock)
+                    .threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains("123"));
             fail();
         } catch (ArgumentsAreDifferent e) {
         }
@@ -76,7 +80,8 @@ public class VerificationUsingMatchersTest extends TestBase {
         mock.threeArgumentMethod(8, new Object(), "01234");
 
         try {
-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));
+            verify(mock)
+                    .threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains("123"));
             fail();
         } catch (ArgumentsAreDifferent e) {
         }
@@ -84,13 +89,14 @@ public class VerificationUsingMatchersTest extends TestBase {
         mock.threeArgumentMethod(8, "", "no match");
 
         try {
-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));
+            verify(mock)
+                    .threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains("123"));
             fail();
         } catch (ArgumentsAreDifferent e) {
         }
 
         mock.threeArgumentMethod(8, "", "123");
 
-        verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));
+        verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains("123"));
     }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationWithAfterAndCaptorTest.java b/src/test/java/org/mockitousage/verification/VerificationWithAfterAndCaptorTest.java
index 1f11319..d173812 100644
--- a/src/test/java/org/mockitousage/verification/VerificationWithAfterAndCaptorTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationWithAfterAndCaptorTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.after;
+import static org.mockito.Mockito.verify;
+import static org.mockito.junit.MockitoJUnit.rule;
+import static org.mockitoutil.Stopwatch.createNotStarted;
+
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
@@ -15,14 +23,6 @@ import org.mockito.junit.MockitoRule;
 import org.mockitousage.IMethods;
 import org.mockitoutil.Stopwatch;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.after;
-import static org.mockito.Mockito.verify;
-import static org.mockito.junit.MockitoJUnit.rule;
-import static org.mockitoutil.Stopwatch.createNotStarted;
-
 public class VerificationWithAfterAndCaptorTest {
 
     @Rule public MockitoRule mockito = rule();
@@ -62,7 +62,7 @@ public class VerificationWithAfterAndCaptorTest {
         // when
         exerciseMockNTimes(n);
 
-        //Then
+        // Then
         verify(mock, after(200).times(n)).oneArg((char) captor.capture());
         assertEquals(n, captor.getAllValues().size());
         assertEquals('0', (char) captor.getAllValues().get(0));
@@ -79,7 +79,7 @@ public class VerificationWithAfterAndCaptorTest {
         // when
         exerciseMockNTimes(n);
 
-        //Then
+        // Then
         verify(mock, after(200).atLeast(n)).oneArg((char) captor.capture());
         assertEquals(n, captor.getAllValues().size());
         assertEquals('0', (char) captor.getAllValues().get(0));
diff --git a/src/test/java/org/mockitousage/verification/VerificationWithAfterTest.java b/src/test/java/org/mockitousage/verification/VerificationWithAfterTest.java
index 7bbb52b..0d3f40b 100644
--- a/src/test/java/org/mockitousage/verification/VerificationWithAfterTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationWithAfterTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.after;
+import static org.mockito.Mockito.verify;
+import static org.mockito.junit.MockitoJUnit.rule;
+import static org.mockitoutil.Stopwatch.createNotStarted;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.After;
@@ -15,34 +23,31 @@ import org.mockito.Mock;
 import org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.TooManyActualInvocations;
+import org.mockito.internal.verification.DummyVerificationMode;
 import org.mockito.junit.MockitoRule;
+import org.mockito.verification.VerificationMode;
 import org.mockitousage.IMethods;
 import org.mockitoutil.Stopwatch;
 import org.mockitoutil.async.AsyncTesting;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.mockito.Mockito.after;
-import static org.mockito.Mockito.verify;
-import static org.mockito.junit.MockitoJUnit.rule;
-import static org.mockitoutil.Stopwatch.createNotStarted;
-
 public class VerificationWithAfterTest {
 
     @Rule public MockitoRule mockito = rule();
 
     @Mock private IMethods mock;
 
-    private Runnable callMock = new Runnable() {
-        public void run() {
-            mock.oneArg('1');
-        }
-    };
+    private Runnable callMock =
+            new Runnable() {
+                public void run() {
+                    mock.oneArg('1');
+                }
+            };
 
     private AsyncTesting async = new AsyncTesting();
     private Stopwatch watch = createNotStarted();
 
-    @After public void tearDown() {
+    @After
+    public void tearDown() {
         async.cleanUp();
     }
 
@@ -63,12 +68,14 @@ public class VerificationWithAfterTest {
         async.runAfter(40, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(600)).oneArg('1');
-            }
-        }).isInstanceOf(TooManyActualInvocations.class);
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(600)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(TooManyActualInvocations.class);
     }
 
     @Test
@@ -90,12 +97,14 @@ public class VerificationWithAfterTest {
         async.runAfter(80, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(300).times(2)).oneArg('1');
-            }
-        }).isInstanceOf(TooManyActualInvocations.class);
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(300).times(2)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(TooManyActualInvocations.class);
     }
 
     @Test
@@ -116,12 +125,15 @@ public class VerificationWithAfterTest {
         async.runAfter(600, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(300).atLeast(3)).oneArg('1');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted *at least* 3 times"); //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(300).atLeast(3)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Wanted *at least* 3 times"); // TODO specific exception
     }
 
     @Test
@@ -143,12 +155,15 @@ public class VerificationWithAfterTest {
         async.runAfter(600, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(300).atMost(1)).oneArg('1');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted at most 1 time but was 2"); //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(300).atMost(1)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Wanted at most 1 time but was 2"); // TODO specific exception
     }
 
     @Test
@@ -166,12 +181,15 @@ public class VerificationWithAfterTest {
         async.runAfter(10, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(300).never()).oneArg('1');
-            }
-        }).isInstanceOf(MoreThanAllowedActualInvocations.class).hasMessageContaining("Wanted at most 0 times but was 1");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(300).never()).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(MoreThanAllowedActualInvocations.class)
+                .hasMessageContaining("Wanted at most 0 times but was 1");
     }
 
     @Test
@@ -191,12 +209,15 @@ public class VerificationWithAfterTest {
         async.runAfter(50, callMock);
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(300).only()).oneArg('1');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("No interactions wanted here"); //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(300).only()).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("No interactions wanted here"); // TODO specific exception
     }
 
     @Test
@@ -208,11 +229,13 @@ public class VerificationWithAfterTest {
         async.runAfter(100, callMock);
 
         // then
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                verify(mock, after(10000).atMost(1)).oneArg('1');
-            }
-        }).isInstanceOf(MoreThanAllowedActualInvocations.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                verify(mock, after(10000).atMost(1)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(MoreThanAllowedActualInvocations.class);
 
         // using generous number to avoid timing issues
         watch.assertElapsedTimeIsLessThan(2000, MILLISECONDS);
@@ -226,18 +249,20 @@ public class VerificationWithAfterTest {
         async.runAfter(50, callMock);
 
         // then
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                verify(mock, after(10000).never()).oneArg('1');
-            }
-        }).isInstanceOf(MoreThanAllowedActualInvocations.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                verify(mock, after(10000).never()).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(MoreThanAllowedActualInvocations.class);
 
         // using generous number to avoid timing issues
         watch.assertElapsedTimeIsLessThan(2000, MILLISECONDS);
     }
 
     @Test
-    @Ignore //TODO nice to have
+    @Ignore // TODO nice to have
     public void should_fail_early_when_only_is_used() {
         watch.start();
 
@@ -246,18 +271,20 @@ public class VerificationWithAfterTest {
         async.runAfter(100, callMock);
 
         // then
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                verify(mock, after(10000).only()).oneArg('1');
-            }
-        }).isInstanceOf(NoInteractionsWanted.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                verify(mock, after(10000).only()).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(NoInteractionsWanted.class);
 
         // using generous number to avoid timing issues
         watch.assertElapsedTimeIsLessThan(2000, MILLISECONDS);
     }
 
     @Test
-    @Ignore //TODO nice to have
+    @Ignore // TODO nice to have
     public void should_fail_early_when_time_x_is_used() {
         watch.start();
 
@@ -266,13 +293,40 @@ public class VerificationWithAfterTest {
         async.runAfter(100, callMock);
 
         // then
-        assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                verify(mock, after(10000).times(1)).oneArg('1');
-            }
-        }).isInstanceOf(NoInteractionsWanted.class);
+        assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                verify(mock, after(10000).times(1)).oneArg('1');
+                            }
+                        })
+                .isInstanceOf(NoInteractionsWanted.class);
 
         // using generous number to avoid timing issues
         watch.assertElapsedTimeIsLessThan(2000, MILLISECONDS);
     }
+
+    @Test
+    public void should_return_formatted_output_from_toString_when_created_with_factory_method() {
+        VerificationMode after = after(3);
+
+        assertThat(after).hasToString("Wanted after 3 ms: [Wanted invocations count: 1]");
+    }
+
+    @Test
+    public void should_return_formatted_output_from_toString_using_wrapped_verification_mode() {
+        org.mockito.verification.After after =
+                new org.mockito.verification.After(10, new DummyVerificationMode());
+
+        assertThat(after).hasToString("Wanted after 10 ms: [Dummy verification mode]");
+    }
+
+    @Test
+    public void
+            should_return_formatted_output_from_toString_when_chaining_other_verification_mode() {
+        VerificationMode afterAndOnly = after(5).only();
+
+        assertThat(afterAndOnly)
+                .hasToString(
+                        "Wanted after 5 ms: [Wanted invocations count: 1 and no other method invoked]");
+    }
 }
diff --git a/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java b/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
index 1a3b345..b51aafd 100644
--- a/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
@@ -2,9 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitousage.verification;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.after;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.verify;
+import static org.mockito.junit.MockitoJUnit.rule;
+import static org.mockitoutil.Stopwatch.createNotStarted;
+
+import java.util.concurrent.TimeUnit;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.After;
@@ -13,20 +21,15 @@ import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooFewActualInvocations;
+import org.mockito.internal.verification.DummyVerificationMode;
 import org.mockito.junit.MockitoRule;
+import org.mockito.verification.Timeout;
+import org.mockito.verification.VerificationMode;
 import org.mockitousage.IMethods;
 import org.mockitoutil.Stopwatch;
 import org.mockitoutil.async.AsyncTesting;
 
-import java.util.concurrent.TimeUnit;
-
-import static org.mockito.Mockito.after;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.verify;
-import static org.mockito.junit.MockitoJUnit.rule;
-import static org.mockitoutil.Stopwatch.createNotStarted;
-
 public class VerificationWithTimeoutTest {
 
     @Rule public MockitoRule mockito = rule();
@@ -55,7 +58,7 @@ public class VerificationWithTimeoutTest {
 
         // then
         verify(mock, timeout(200).only()).oneArg('c');
-        verify(mock).oneArg('c'); //sanity check
+        verify(mock).oneArg('c'); // sanity check
     }
 
     @Test
@@ -64,17 +67,20 @@ public class VerificationWithTimeoutTest {
         async.runAfter(200, callMock('c'));
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, timeout(50).only()).oneArg('c');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked");
-        //TODO let's have a specific exception vs. generic assertion error + message
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, timeout(50).only()).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Wanted but not invoked");
+        // TODO let's have a specific exception vs. generic assertion error + message
     }
 
     @Test
-    @Ignore //TODO nice to have
+    @Ignore // TODO nice to have
     public void should_verify_with_timeout_and_fail_early() {
         // when
         callMock('c');
@@ -83,12 +89,15 @@ public class VerificationWithTimeoutTest {
         watch.start();
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, timeout(2000)).oneArg('c');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked");
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, timeout(2000)).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Wanted but not invoked");
 
         watch.assertElapsedTimeIsLessThan(1000, TimeUnit.MILLISECONDS);
     }
@@ -111,12 +120,14 @@ public class VerificationWithTimeoutTest {
         async.runAfter(200, callMock('c'));
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, timeout(100).times(2)).oneArg('c');
-            }
-        }).isInstanceOf(TooLittleActualInvocations.class);
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, timeout(100).times(2)).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(TooFewActualInvocations.class);
     }
 
     @Test
@@ -146,11 +157,13 @@ public class VerificationWithTimeoutTest {
         async.runAfter(50, callMock('c'));
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                verify(mock, timeout(100).atLeast(3)).oneArg('c');
-            }
-        }).isInstanceOf(TooLittleActualInvocations.class);
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            public void call() {
+                                verify(mock, timeout(100).atLeast(3)).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(TooFewActualInvocations.class);
     }
 
     @Test
@@ -163,6 +176,31 @@ public class VerificationWithTimeoutTest {
         verify(mock, timeout(100).only()).oneArg('c');
     }
 
+    @Test
+    public void should_return_formatted_output_from_toString_when_created_with_factory_method() {
+        VerificationMode timeout = timeout(7);
+
+        assertThat(timeout).hasToString("Wanted after at most 7 ms: [Wanted invocations count: 1]");
+    }
+
+    @Test
+    public void should_return_formatted_output_from_toString_using_wrapped_verification_mode() {
+        VerificationMode timeoutAndAtLeastOnce = new Timeout(9, new DummyVerificationMode());
+
+        assertThat(timeoutAndAtLeastOnce)
+                .hasToString("Wanted after at most 9 ms: [Dummy verification mode]");
+    }
+
+    @Test
+    public void
+            should_return_formatted_output_from_toString_when_chaining_other_verification_mode() {
+        VerificationMode timeoutAndOnly = timeout(7).only();
+
+        assertThat(timeoutAndOnly)
+                .hasToString(
+                        "Wanted after at most 7 ms: [Wanted invocations count: 1 and no other method invoked]");
+    }
+
     @Test
     @Ignore("not testable, probably timeout().only() does not make sense")
     public void should_verify_with_only_and_fail() {
@@ -171,16 +209,18 @@ public class VerificationWithTimeoutTest {
         async.runAfter(50, callMock('c'));
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, after(200).only()).oneArg('c');
-            }
-        }).isInstanceOf(AssertionError.class);
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, after(200).only()).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class);
     }
 
     @Test
-    @Ignore //TODO nice to have
+    @Ignore // TODO nice to have
     public void should_verify_with_only_and_fail_early() {
         // when
         callMock('c');
@@ -189,12 +229,15 @@ public class VerificationWithTimeoutTest {
         watch.start();
 
         // then
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            @Override
-            public void call() {
-                verify(mock, timeout(2000).only()).oneArg('c');
-            }
-        }).isInstanceOf(AssertionError.class).hasMessageContaining("Wanted but not invoked"); //TODO specific exception
+        Assertions.assertThatThrownBy(
+                        new ThrowableAssert.ThrowingCallable() {
+                            @Override
+                            public void call() {
+                                verify(mock, timeout(2000).only()).oneArg('c');
+                            }
+                        })
+                .isInstanceOf(AssertionError.class)
+                .hasMessageContaining("Wanted but not invoked"); // TODO specific exception
 
         watch.assertElapsedTimeIsLessThan(1000, TimeUnit.MILLISECONDS);
     }
diff --git a/src/test/java/org/mockitousage/verification/VerifyPrintsAllInvocationsOnErrorTest.java b/src/test/java/org/mockitousage/verification/VerifyPrintsAllInvocationsOnErrorTest.java
new file mode 100644
index 0000000..e9b4a29
--- /dev/null
+++ b/src/test/java/org/mockitousage/verification/VerifyPrintsAllInvocationsOnErrorTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.verification;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+
+public class VerifyPrintsAllInvocationsOnErrorTest {
+
+    @Test
+    public void shouldPrintAllInvocationsOnError() {
+        ExampleBuilder mockBuilder = Mockito.mock(ExampleBuilder.class);
+        mockBuilder.with("key1", "val1");
+        mockBuilder.with("key2", "val2");
+        try {
+            Mockito.verify(mockBuilder).with("key1", "wrongValue");
+            fail();
+        } catch (ArgumentsAreDifferent e) {
+            assertThat(e).hasMessageContaining("exampleBuilder.with(\"key1\", \"val1\")");
+            assertThat(e).hasMessageContaining("exampleBuilder.with(\"key2\", \"val2\"");
+        }
+    }
+
+    private static class ExampleBuilder {
+        public ExampleBuilder with(String key, String val) {
+            return this;
+        }
+    }
+}
diff --git a/src/test/java/org/mockitoutil/Assertor.java b/src/test/java/org/mockitoutil/Assertor.java
deleted file mode 100644
index 9ac1763..0000000
--- a/src/test/java/org/mockitoutil/Assertor.java
+++ /dev/null
@@ -1,10 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitoutil;
-
-public interface Assertor<T> {
-
-    void assertValue(T value);
-}
diff --git a/src/test/java/org/mockitoutil/ClassLoaders.java b/src/test/java/org/mockitoutil/ClassLoaders.java
index 80be13e..308b309 100644
--- a/src/test/java/org/mockitoutil/ClassLoaders.java
+++ b/src/test/java/org/mockitoutil/ClassLoaders.java
@@ -4,6 +4,9 @@
  */
 package org.mockitoutil;
 
+import static java.lang.String.format;
+import static java.util.Arrays.asList;
+
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
@@ -32,18 +35,17 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
+
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.plugins.MemberAccessor;
 import org.objenesis.Objenesis;
 import org.objenesis.ObjenesisStd;
 import org.objenesis.instantiator.ObjectInstantiator;
 
-import static java.lang.String.format;
-import static java.util.Arrays.asList;
-
 public abstract class ClassLoaders {
     protected ClassLoader parent = currentClassLoader();
 
-    protected ClassLoaders() {
-    }
+    protected ClassLoaders() {}
 
     public static IsolatedURLClassLoaderBuilder isolatedClassLoader() {
         return new IsolatedURLClassLoaderBuilder();
@@ -104,28 +106,33 @@ public abstract class ClassLoaders {
         }
 
         public void execute(final Runnable task) throws Exception {
-            ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
-                @Override
-                public Thread newThread(Runnable r) {
-                    Thread thread = Executors.defaultThreadFactory().newThread(r);
-                    thread.setContextClassLoader(classLoader);
-                    return thread;
-                }
-            });
+            ExecutorService executorService =
+                    Executors.newSingleThreadExecutor(
+                            new ThreadFactory() {
+                                @Override
+                                public Thread newThread(Runnable r) {
+                                    Thread thread = Executors.defaultThreadFactory().newThread(r);
+                                    thread.setContextClassLoader(classLoader);
+                                    return thread;
+                                }
+                            });
             try {
-                Future<?> taskFuture = executorService.submit(new Runnable() {
-                    @Override
-                    public void run() {
-                        try {
-                            reloadTaskInClassLoader(task).run();
-                        } catch (Throwable throwable) {
-                            throw new IllegalStateException(format("Given task could not be loaded properly in the given classloader '%s', error '%s",
-                                                                   task,
-                                                                   throwable.getMessage()),
-                                                            throwable);
-                        }
-                    }
-                });
+                Future<?> taskFuture =
+                        executorService.submit(
+                                new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        try {
+                                            reloadTaskInClassLoader(task).run();
+                                        } catch (Throwable throwable) {
+                                            throw new IllegalStateException(
+                                                    format(
+                                                            "Given task could not be loaded properly in the given classloader '%s', error '%s",
+                                                            task, throwable.getMessage()),
+                                                    throwable);
+                                        }
+                                    }
+                                });
                 taskFuture.get();
                 executorService.shutdownNow();
             } catch (InterruptedException e) {
@@ -143,26 +150,27 @@ public abstract class ClassLoaders {
         Runnable reloadTaskInClassLoader(Runnable task) {
             try {
                 @SuppressWarnings("unchecked")
-                Class<Runnable> taskClassReloaded = (Class<Runnable>) classLoader.loadClass(task.getClass().getName());
+                Class<Runnable> taskClassReloaded =
+                        (Class<Runnable>) classLoader.loadClass(task.getClass().getName());
 
                 Objenesis objenesis = new ObjenesisStd();
-                ObjectInstantiator<Runnable> thingyInstantiator = objenesis.getInstantiatorOf(taskClassReloaded);
+                ObjectInstantiator<Runnable> thingyInstantiator =
+                        objenesis.getInstantiatorOf(taskClassReloaded);
                 Runnable reloaded = thingyInstantiator.newInstance();
 
                 // lenient shallow copy of class compatible fields
                 for (Field field : task.getClass().getDeclaredFields()) {
                     Field declaredField = taskClassReloaded.getDeclaredField(field.getName());
                     int modifiers = declaredField.getModifiers();
-                    if(Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers)) {
+                    if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers)) {
                         // Skip static final fields (e.g. jacoco fields)
                         // otherwise IllegalAccessException (can be bypassed with Unsafe though)
                         // We may also miss coverage data.
                         continue;
                     }
                     if (declaredField.getType() == field.getType()) { // don't copy this
-                        field.setAccessible(true);
-                        declaredField.setAccessible(true);
-                        declaredField.set(reloaded, field.get(task));
+                        MemberAccessor accessor = Plugins.getMemberAccessor();
+                        accessor.set(declaredField, reloaded, accessor.get(field, task));
                     }
                 }
 
@@ -214,8 +222,7 @@ public abstract class ClassLoaders {
                     jdkClassLoader(),
                     codeSourceUrls.toArray(new URL[codeSourceUrls.size()]),
                     privateCopyPrefixes,
-                    excludedPrefixes
-            );
+                    excludedPrefixes);
         }
     }
 
@@ -223,10 +230,11 @@ public abstract class ClassLoaders {
         private final ArrayList<String> privateCopyPrefixes;
         private final ArrayList<String> excludedPrefixes;
 
-        LocalIsolatedURLClassLoader(ClassLoader classLoader,
-                                    URL[] urls,
-                                    ArrayList<String> privateCopyPrefixes,
-                                    ArrayList<String> excludedPrefixes) {
+        LocalIsolatedURLClassLoader(
+                ClassLoader classLoader,
+                URL[] urls,
+                ArrayList<String> privateCopyPrefixes,
+                ArrayList<String> excludedPrefixes) {
             super(urls, classLoader);
             this.privateCopyPrefixes = privateCopyPrefixes;
             this.excludedPrefixes = excludedPrefixes;
@@ -235,17 +243,20 @@ public abstract class ClassLoaders {
         @Override
         public Class<?> findClass(String name) throws ClassNotFoundException {
             if (!classShouldBePrivate(name) || classShouldBeExcluded(name)) {
-                throw new ClassNotFoundException(format("Can only load classes with prefixes : %s, but not : %s",
-                                                        privateCopyPrefixes,
-                                                        excludedPrefixes));
+                throw new ClassNotFoundException(
+                        format(
+                                "Can only load classes with prefixes : %s, but not : %s",
+                                privateCopyPrefixes, excludedPrefixes));
             }
             try {
                 return super.findClass(name);
             } catch (ClassNotFoundException cnfe) {
-                throw new ClassNotFoundException(format("%s%n%s%n",
-                                                        cnfe.getMessage(),
-                                                        "    Did you forgot to add the code source url 'withCodeSourceUrlOf' / 'withCurrentCodeSourceUrls' ?"),
-                                                 cnfe);
+                throw new ClassNotFoundException(
+                        format(
+                                "%s%n%s%n",
+                                cnfe.getMessage(),
+                                "    Did you forgot to add the code source url 'withCodeSourceUrlOf' / 'withCurrentCodeSourceUrls' ?"),
+                        cnfe);
             }
         }
 
@@ -294,17 +305,15 @@ public abstract class ClassLoaders {
             return new LocalExcludingURLClassLoader(
                     jdkClassLoader(),
                     codeSourceUrls.toArray(new URL[codeSourceUrls.size()]),
-                    excludedPrefixes
-            );
+                    excludedPrefixes);
         }
     }
 
     static class LocalExcludingURLClassLoader extends URLClassLoader {
         private final ArrayList<String> excludedPrefixes;
 
-        LocalExcludingURLClassLoader(ClassLoader classLoader,
-                                     URL[] urls,
-                                     ArrayList<String> excludedPrefixes) {
+        LocalExcludingURLClassLoader(
+                ClassLoader classLoader, URL[] urls, ArrayList<String> excludedPrefixes) {
             super(urls, classLoader);
             this.excludedPrefixes = excludedPrefixes;
         }
@@ -312,7 +321,8 @@ public abstract class ClassLoaders {
         @Override
         public Class<?> findClass(String name) throws ClassNotFoundException {
             if (classShouldBeExcluded(name))
-                throw new ClassNotFoundException("classes with prefix : " + excludedPrefixes + " are excluded");
+                throw new ClassNotFoundException(
+                        "classes with prefix : " + excludedPrefixes + " are excluded");
             return super.findClass(name);
         }
 
@@ -408,12 +418,12 @@ public abstract class ClassLoaders {
             }
 
             @Override
-            public void connect() throws IOException {
-            }
+            public void connect() throws IOException {}
 
             @Override
             public InputStream getInputStream() throws IOException {
-                return new ByteArrayInputStream(inMemoryClassLoader.inMemoryClassObjects.get(qualifiedName));
+                return new ByteArrayInputStream(
+                        inMemoryClassLoader.inMemoryClassObjects.get(qualifiedName));
             }
         }
     }
@@ -474,8 +484,16 @@ public abstract class ClassLoaders {
                     addFromFileBasedClassLoader(classes, uri);
                 } else if (uri.getScheme().equalsIgnoreCase(InMemoryClassLoader.SCHEME)) {
                     addFromInMemoryBasedClassLoader(classes, uri);
+                } else if (uri.getScheme().equalsIgnoreCase("jar")) {
+                    // Java 9+ returns "jar:file:" style urls for modules.
+                    // It's not a classes owned by mockito itself.
+                    // Just ignore it.
+                    continue;
                 } else {
-                    throw new IllegalArgumentException(format("Given ClassLoader '%s' don't have reachable by File or vi ClassLoaders.inMemory", classLoader));
+                    throw new IllegalArgumentException(
+                            format(
+                                    "Given ClassLoader '%s' don't have reachable by File or vi ClassLoaders.inMemory",
+                                    classLoader));
                 }
             }
             return classes;
@@ -493,8 +511,8 @@ public abstract class ClassLoaders {
             }
         }
 
-
-        private Set<String> findClassQualifiedNames(File root, File file, Set<String> packageFilters) {
+        private Set<String> findClassQualifiedNames(
+                File root, File file, Set<String> packageFilters) {
             if (file.isDirectory()) {
                 File[] files = file.listFiles();
                 Set<String> classes = new HashSet<String>();
@@ -521,10 +539,11 @@ public abstract class ClassLoaders {
         }
 
         private String classNameFor(File root, File file) {
-            String temp = file.getAbsolutePath().substring(root.getAbsolutePath().length() + 1).
-                    replace(File.separatorChar, '.');
+            String temp =
+                    file.getAbsolutePath()
+                            .substring(root.getAbsolutePath().length() + 1)
+                            .replace(File.separatorChar, '.');
             return temp.subSequence(0, temp.indexOf(".class")).toString();
         }
-
     }
 }
diff --git a/src/test/java/org/mockitoutil/ClassLoadersTest.java b/src/test/java/org/mockitoutil/ClassLoadersTest.java
index deb0731..59da6e5 100644
--- a/src/test/java/org/mockitoutil/ClassLoadersTest.java
+++ b/src/test/java/org/mockitoutil/ClassLoadersTest.java
@@ -4,40 +4,45 @@
  */
 package org.mockitoutil;
 
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.Mockito;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.fail;
 import static org.mockitoutil.ClassLoaders.currentClassLoader;
 import static org.mockitoutil.ClassLoaders.excludingClassLoader;
 import static org.mockitoutil.ClassLoaders.isolatedClassLoader;
 import static org.mockitoutil.ClassLoaders.jdkClassLoader;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.assertj.core.api.Assertions;
+import org.junit.Test;
+import org.mockito.Mockito;
+
 public class ClassLoadersTest {
 
-    public static final String CLASS_NAME_DEPENDING_ON_INTERFACE = "org.mockitoutil.ClassLoadersTest$ClassUsingInterface1";
+    public static final String CLASS_NAME_DEPENDING_ON_INTERFACE =
+            "org.mockitoutil.ClassLoadersTest$ClassUsingInterface1";
     public static final String INTERFACE_NAME = "org.mockitoutil.ClassLoadersTest$Interface1";
 
-    @Test(expected = ClassNotFoundException.class)
-    public void isolated_class_loader_cannot_load_classes_when_no_given_prefix() throws Exception {
+    @Test
+    public void isolated_class_loader_cannot_load_classes_when_no_given_prefix() {
         // given
         ClassLoader cl = isolatedClassLoader().build();
 
-        // when
-        cl.loadClass("org.mockito.Mockito");
-
-        // then raises CNFE
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            cl.loadClass("org.mockito.Mockito");
+                        })
+                .isInstanceOf(ClassNotFoundException.class)
+                .hasMessage("Can only load classes with prefixes : [], but not : []");
     }
 
     @Test
-    public void isolated_class_loader_cannot_load_classes_if_no_code_source_path() throws Exception {
+    public void isolated_class_loader_cannot_load_classes_if_no_code_source_path() {
         // given
-        ClassLoader cl = isolatedClassLoader()
-                .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
-                .build();
+        ClassLoader cl =
+                isolatedClassLoader().withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE).build();
 
         // when
         try {
@@ -50,12 +55,15 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void isolated_class_loader_cannot_load_classes_if_dependent_classes_do_not_match_the_prefixes() throws Exception {
+    public void
+            isolated_class_loader_cannot_load_classes_if_dependent_classes_do_not_match_the_prefixes()
+                    throws Exception {
         // given
-        ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
-                .build();
+        ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
+                        .build();
 
         // when
         try {
@@ -68,13 +76,16 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void isolated_class_loader_can_load_classes_when_dependent_classes_are_matching_the_prefixes() throws Exception {
+    public void
+            isolated_class_loader_can_load_classes_when_dependent_classes_are_matching_the_prefixes()
+                    throws Exception {
         // given
-        ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
-                .withPrivateCopyOf(INTERFACE_NAME)
-                .build();
+        ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
+                        .withPrivateCopyOf(INTERFACE_NAME)
+                        .build();
 
         // when
         Class<?> aClass = cl.loadClass(CLASS_NAME_DEPENDING_ON_INTERFACE);
@@ -86,12 +97,14 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void isolated_class_loader_can_load_classes_isolated_classes_in_isolation() throws Exception {
+    public void isolated_class_loader_can_load_classes_isolated_classes_in_isolation()
+            throws Exception {
         // given
-        ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
-                .build();
+        ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
+                        .build();
 
         // when
         Class<?> aClass = cl.loadClass(AClass.class.getName());
@@ -103,13 +116,14 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void isolated_class_loader_cannot_load_classes_if_prefix_excluded() throws Exception {
+    public void isolated_class_loader_cannot_load_classes_if_prefix_excluded() {
         // given
-        ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
-                .without(AClass.class.getName())
-                .build();
+        ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
+                        .without(AClass.class.getName())
+                        .build();
 
         // when
         try {
@@ -117,41 +131,43 @@ public class ClassLoadersTest {
             fail();
         } catch (ClassNotFoundException e) {
             // then
-            assertThat(e).hasMessageContaining("org.mockitoutil")
-                         .hasMessageContaining(AClass.class.getName());
+            assertThat(e)
+                    .hasMessageContaining("org.mockitoutil")
+                    .hasMessageContaining(AClass.class.getName());
         }
     }
 
     @Test
-    public void isolated_class_loader_has_no_parent() throws Exception {
-        ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
-                .withPrivateCopyOf(INTERFACE_NAME)
-                .build();
+    public void isolated_class_loader_has_no_parent() {
+        ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(CLASS_NAME_DEPENDING_ON_INTERFACE)
+                        .withPrivateCopyOf(INTERFACE_NAME)
+                        .build();
 
         assertThat(cl.getParent()).isNull();
     }
 
-    @Test(expected = ClassNotFoundException.class)
-    public void excluding_class_loader_cannot_load_classes_when_no_correct_source_url_set() throws Exception {
+    @Test
+    public void excluding_class_loader_cannot_load_classes_when_no_correct_source_url_set() {
         // given
-        ClassLoader cl = excludingClassLoader()
-                .withCodeSourceUrlOf(this.getClass())
-                .build();
-
-        // when
-        cl.loadClass("org.mockito.Mockito");
-
-        // then class CNFE
+        ClassLoader cl = excludingClassLoader().withCodeSourceUrlOf(this.getClass()).build();
+
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            cl.loadClass("org.mockito.Mockito");
+                        })
+                .isInstanceOf(ClassNotFoundException.class)
+                .hasMessage("org.mockito.Mockito");
     }
 
     @Test
-    public void excluding_class_loader_can_load_classes_when_correct_source_url_set() throws Exception {
+    public void excluding_class_loader_can_load_classes_when_correct_source_url_set()
+            throws Exception {
         // given
-        ClassLoader cl = excludingClassLoader()
-                .withCodeSourceUrlOf(Mockito.class)
-                .build();
+        ClassLoader cl = excludingClassLoader().withCodeSourceUrlOf(Mockito.class).build();
 
         // when
         cl.loadClass("org.mockito.Mockito");
@@ -160,12 +176,14 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void excluding_class_loader_cannot_load_class_when_excluded_prefix_match_class_to_load() throws Exception {
+    public void excluding_class_loader_cannot_load_class_when_excluded_prefix_match_class_to_load()
+            throws Exception {
         // given
-        ClassLoader cl = excludingClassLoader()
-                .withCodeSourceUrlOf(Mockito.class)
-                .without("org.mockito.BDDMockito")
-                .build();
+        ClassLoader cl =
+                excludingClassLoader()
+                        .withCodeSourceUrlOf(Mockito.class)
+                        .without("org.mockito.BDDMockito")
+                        .build();
 
         cl.loadClass("org.mockito.Mockito");
 
@@ -181,12 +199,13 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void can_not_load_a_class_not_previously_registered_in_builder() throws Exception {
+    public void can_not_load_a_class_not_previously_registered_in_builder() {
         // given
-        ClassLoader cl = ClassLoaders
-                .inMemoryClassLoader()
-                .withClassDefinition("yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))
-                .build();
+        ClassLoader cl =
+                ClassLoaders.inMemoryClassLoader()
+                        .withClassDefinition(
+                                "yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))
+                        .build();
 
         // when
         try {
@@ -201,10 +220,11 @@ public class ClassLoadersTest {
     @Test
     public void can_load_a_class_in_memory_from_bytes() throws Exception {
         // given
-        ClassLoader cl = ClassLoaders
-                .inMemoryClassLoader()
-                .withClassDefinition("yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))
-                .build();
+        ClassLoader cl =
+                ClassLoaders.inMemoryClassLoader()
+                        .withClassDefinition(
+                                "yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))
+                        .build();
 
         // when
         Class<?> aClass = cl.loadClass("yop.Dude");
@@ -218,10 +238,7 @@ public class ClassLoadersTest {
     @Test
     public void cannot_load_a_class_file_not_in_parent() throws Exception {
         // given
-        ClassLoader cl = ClassLoaders
-                .inMemoryClassLoader()
-                .withParent(jdkClassLoader())
-                .build();
+        ClassLoader cl = ClassLoaders.inMemoryClassLoader().withParent(jdkClassLoader()).build();
 
         cl.loadClass("java.lang.String");
 
@@ -237,20 +254,24 @@ public class ClassLoadersTest {
 
     @Test
     public void can_list_all_classes_reachable_in_a_classloader() throws Exception {
-        ClassLoader classLoader = ClassLoaders.inMemoryClassLoader()
-                                              .withParent(jdkClassLoader())
-                                              .withClassDefinition("a.A", SimpleClassGenerator.makeMarkerInterface("a.A"))
-                                              .withClassDefinition("a.b.B", SimpleClassGenerator.makeMarkerInterface("a.b.B"))
-                                              .withClassDefinition("c.C", SimpleClassGenerator.makeMarkerInterface("c.C"))
-//                .withCodeSourceUrlOf(ClassLoaders.class)
-                                              .build();
-
-        assertThat(ClassLoaders.in(classLoader).listOwnedClasses()).containsOnly("a.A", "a.b.B", "c.C");
-        assertThat(ClassLoaders.in(classLoader).omit("b", "c").listOwnedClasses()).containsOnly("a.A");
+        ClassLoader classLoader =
+                ClassLoaders.inMemoryClassLoader()
+                        .withParent(jdkClassLoader())
+                        .withClassDefinition("a.A", SimpleClassGenerator.makeMarkerInterface("a.A"))
+                        .withClassDefinition(
+                                "a.b.B", SimpleClassGenerator.makeMarkerInterface("a.b.B"))
+                        .withClassDefinition("c.C", SimpleClassGenerator.makeMarkerInterface("c.C"))
+                        //                .withCodeSourceUrlOf(ClassLoaders.class)
+                        .build();
+
+        assertThat(ClassLoaders.in(classLoader).listOwnedClasses())
+                .containsOnly("a.A", "a.b.B", "c.C");
+        assertThat(ClassLoaders.in(classLoader).omit("b", "c").listOwnedClasses())
+                .containsOnly("a.A");
     }
 
     @Test
-    public void return_bootstrap_classloader() throws Exception {
+    public void return_bootstrap_classloader() {
         assertThat(jdkClassLoader()).isNotEqualTo(Mockito.class.getClassLoader());
         assertThat(jdkClassLoader()).isNotEqualTo(ClassLoaders.class.getClassLoader());
         assertThat(jdkClassLoader()).isEqualTo(Number.class.getClassLoader());
@@ -258,87 +279,99 @@ public class ClassLoadersTest {
     }
 
     @Test
-    public void return_current_classloader() throws Exception {
+    public void return_current_classloader() {
         assertThat(currentClassLoader()).isEqualTo(this.getClass().getClassLoader());
     }
 
     @Test
     public void can_run_in_given_classloader() throws Exception {
         // given
-        final ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withCodeSourceUrlOf(Assertions.class)
-                .withPrivateCopyOf("org.assertj.core")
-                .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
-                .without(AClass.class.getName())
-                .build();
+        final ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withCodeSourceUrlOf(Assertions.class)
+                        .withPrivateCopyOf("org.assertj.core")
+                        .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
+                        .without(AClass.class.getName())
+                        .build();
 
         final AtomicBoolean executed = new AtomicBoolean(false);
 
         // when
-        ClassLoaders.using(cl).execute(new Runnable() {
-            @Override
-            public void run() {
-                assertThat(this.getClass().getClassLoader()).describedAs("runnable is reloaded in given classloader").isEqualTo(cl);
-                assertThat(Thread.currentThread().getContextClassLoader()).describedAs("Thread context classloader is using given classloader").isEqualTo(cl);
-
-                try {
-                    assertThat(Thread.currentThread()
-                                     .getContextClassLoader()
-                                     .loadClass("java.lang.String"))
-                            .describedAs("can load JDK type")
-                            .isNotNull();
-                    assertThat(Thread.currentThread()
-                                     .getContextClassLoader()
-                                     .loadClass("org.mockitoutil.ClassLoadersTest$ClassUsingInterface1"))
-                            .describedAs("can load classloader types")
-                            .isNotNull();
-                } catch (ClassNotFoundException cnfe) {
-                    Assertions.fail("should not have raised a CNFE", cnfe);
-                }
-                executed.set(true);
-            }
-        });
+        ClassLoaders.using(cl)
+                .execute(
+                        new Runnable() {
+                            @Override
+                            public void run() {
+                                assertThat(this.getClass().getClassLoader())
+                                        .describedAs("runnable is reloaded in given classloader")
+                                        .isEqualTo(cl);
+                                assertThat(Thread.currentThread().getContextClassLoader())
+                                        .describedAs(
+                                                "Thread context classloader is using given classloader")
+                                        .isEqualTo(cl);
+
+                                try {
+                                    assertThat(
+                                                    Thread.currentThread()
+                                                            .getContextClassLoader()
+                                                            .loadClass("java.lang.String"))
+                                            .describedAs("can load JDK type")
+                                            .isNotNull();
+                                    assertThat(
+                                                    Thread.currentThread()
+                                                            .getContextClassLoader()
+                                                            .loadClass(
+                                                                    "org.mockitoutil.ClassLoadersTest$ClassUsingInterface1"))
+                                            .describedAs("can load classloader types")
+                                            .isNotNull();
+                                } catch (ClassNotFoundException cnfe) {
+                                    Assertions.fail("should not have raised a CNFE", cnfe);
+                                }
+                                executed.set(true);
+                            }
+                        });
 
         // then
         assertThat(executed.get()).isEqualTo(true);
     }
 
-
     @Test
-    public void cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded() throws Exception {
+    public void cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded()
+            throws Exception {
         // given
-        final ClassLoader cl = isolatedClassLoader()
-                .withCurrentCodeSourceUrls()
-                .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
-                .without(AClass.class.getName())
-                .build();
+        final ClassLoader cl =
+                isolatedClassLoader()
+                        .withCurrentCodeSourceUrls()
+                        .withPrivateCopyOf(ClassLoadersTest.class.getPackage().getName())
+                        .without(AClass.class.getName())
+                        .build();
 
         // when
         try {
-            ClassLoaders.using(cl).execute(new Runnable() {
-                @Override
-                public void run() {
-                    AClass cant_be_found = new AClass();
-                }
-            });
+            ClassLoaders.using(cl)
+                    .execute(
+                            new Runnable() {
+                                @Override
+                                public void run() {
+                                    AClass cant_be_found = new AClass();
+                                }
+                            });
             Assertions.fail("should have raised a ClassNotFoundException");
         } catch (IllegalStateException ise) {
             // then
-            assertThat(ise).hasCauseInstanceOf(NoClassDefFoundError.class)
-                           .hasMessageContaining("AClass");
+            assertThat(ise)
+                    .hasCauseInstanceOf(NoClassDefFoundError.class)
+                    .hasMessageContaining("AClass");
         }
     }
 
     @SuppressWarnings("unused")
-    static class AClass {
-    }
+    static class AClass {}
 
     @SuppressWarnings("unused")
-    static class ClassUsingInterface1 implements Interface1 {
-    }
+    static class ClassUsingInterface1 implements Interface1 {}
 
     @SuppressWarnings("unused")
-    interface Interface1 {
-    }
+    interface Interface1 {}
 }
diff --git a/src/test/java/org/mockitoutil/ConcurrentTesting.java b/src/test/java/org/mockitoutil/ConcurrentTesting.java
index 1722aeb..f5717fe 100644
--- a/src/test/java/org/mockitoutil/ConcurrentTesting.java
+++ b/src/test/java/org/mockitoutil/ConcurrentTesting.java
@@ -25,7 +25,7 @@ public class ConcurrentTesting {
      * Starts all supplied runnables and then waits for all of them to complete.
      * Runnables are executed concurrently.
      */
-    public static void concurrently(Runnable ... runnables) throws InterruptedException {
+    public static void concurrently(Runnable... runnables) throws InterruptedException {
         List<Thread> threads = new LinkedList<Thread>();
         for (Runnable r : runnables) {
             Thread t = new Thread(r);
diff --git a/src/test/java/org/mockitoutil/Conditions.java b/src/test/java/org/mockitoutil/Conditions.java
index 202737f..96491fa 100644
--- a/src/test/java/org/mockitoutil/Conditions.java
+++ b/src/test/java/org/mockitoutil/Conditions.java
@@ -2,18 +2,17 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitoutil;
 
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.Condition;
 import org.assertj.core.description.Description;
 import org.assertj.core.description.TextDescription;
 import org.hamcrest.CoreMatchers;
 
-import java.lang.reflect.Method;
-import java.util.Arrays;
-
 @SuppressWarnings("unchecked")
 public class Conditions {
 
@@ -24,10 +23,11 @@ public class Conditions {
                 StackTraceElement[] trace = traceElements.getStackTrace();
 
                 Assertions.assertThat(trace.length)
-                          .describedAs("Number of classes does not match.\nExpected: %s\nGot: %s",
-                                       Arrays.toString(classes),
-                                       Arrays.toString(traceElements.getStackTrace()))
-                          .isEqualTo(classes.length);
+                        .describedAs(
+                                "Number of classes does not match.\nExpected: %s\nGot: %s",
+                                Arrays.toString(classes),
+                                Arrays.toString(traceElements.getStackTrace()))
+                        .isEqualTo(classes.length);
 
                 for (int i = 0; i < trace.length; i++) {
                     Assertions.assertThat(trace[i].getClassName()).isEqualTo(classes[i]);
@@ -44,10 +44,10 @@ public class Conditions {
             @Override
             public boolean matches(StackTraceElement[] traceElements) {
                 Assertions.assertThat(traceElements.length)
-                          .describedAs("Number of classes does not match.\nExpected: %s\nGot: %s",
-                                       Arrays.toString(classes),
-                                       Arrays.toString(traceElements))
-                          .isEqualTo(classes.length);
+                        .describedAs(
+                                "Number of classes does not match.\nExpected: %s\nGot: %s",
+                                Arrays.toString(classes), Arrays.toString(traceElements))
+                        .isEqualTo(classes.length);
 
                 for (int i = 0; i < traceElements.length; i++) {
                     Assertions.assertThat(traceElements[i].getClassName()).isEqualTo(classes[i]);
@@ -62,7 +62,8 @@ public class Conditions {
         return methodInStackTraceAt(0, method);
     }
 
-    public static Condition<Throwable> methodInStackTraceAt(final int stackTraceIndex, final String method) {
+    public static Condition<Throwable> methodInStackTraceAt(
+            final int stackTraceIndex, final String method) {
         return new Condition<Throwable>() {
             private String actualMethodAtIndex;
 
@@ -75,7 +76,9 @@ public class Conditions {
 
             @Override
             public Description description() {
-                return new TextDescription("Method at index: %d\nexpected to be: %s\nbut is: %s", stackTraceIndex, method, actualMethodAtIndex);
+                return new TextDescription(
+                        "Method at index: %d\nexpected to be: %s\nbut is: %s",
+                        stackTraceIndex, method, actualMethodAtIndex);
             }
         };
     }
@@ -112,12 +115,12 @@ public class Conditions {
             public boolean matches(Throwable value) {
                 StackTraceElement[] trace = value.getStackTrace();
                 for (int i = 0; i < methods.length; i++) {
-                    Assertions.assertThat(trace[i].getMethodName()).describedAs("Expected methods[%d] to be in the stack trace.", i).isEqualTo(methods[i]);
+                    Assertions.assertThat(trace[i].getMethodName())
+                            .describedAs("Expected methods[%d] to be in the stack trace.", i)
+                            .isEqualTo(methods[i]);
                 }
                 return true;
             }
         };
     }
-
-
 }
diff --git a/src/test/java/org/mockitoutil/JUnitResultAssert.java b/src/test/java/org/mockitoutil/JUnitResultAssert.java
index b4604ba..76be637 100644
--- a/src/test/java/org/mockitoutil/JUnitResultAssert.java
+++ b/src/test/java/org/mockitoutil/JUnitResultAssert.java
@@ -4,17 +4,17 @@
  */
 package org.mockitoutil;
 
-import org.junit.runner.Result;
-import org.junit.runner.notification.Failure;
-
-import java.util.List;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.internal.util.collections.Iterables.firstOf;
 import static org.mockitoutil.TestBase.filterLineNo;
 
+import java.util.List;
+
+import org.junit.runner.Result;
+import org.junit.runner.notification.Failure;
+
 /**
- * Assertion utility for cleaner & easier to debug tests that inspect on JUnit's Result object
+ * Assertion utility for cleaner and easier to debug tests that inspect on JUnit's Result object
  */
 public class JUnitResultAssert {
     private Result result;
@@ -39,8 +39,13 @@ public class JUnitResultAssert {
         fails(expectedFailureCount);
         for (Failure f : result.getFailures()) {
             if (!expectedException.isInstance(f.getException())) {
-                throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
-                        formatFailures(result.getFailures()));
+                throw new AssertionError(
+                        "Incorrect failure type, expected: "
+                                + expectedException
+                                + ", actual: "
+                                + f.getException().getClass().getSimpleName()
+                                + "\n"
+                                + formatFailures(result.getFailures()));
             }
         }
         return this;
@@ -51,8 +56,13 @@ public class JUnitResultAssert {
      */
     public JUnitResultAssert fails(int expectedFailureCount) {
         if (result.getFailures().size() != expectedFailureCount) {
-            throw new AssertionError("Wrong number of failures, expected: " + expectedFailureCount + ", actual: " + result.getFailures().size() + "\n" +
-                    formatFailures(result.getFailures()));
+            throw new AssertionError(
+                    "Wrong number of failures, expected: "
+                            + expectedFailureCount
+                            + ", actual: "
+                            + result.getFailures().size()
+                            + "\n"
+                            + formatFailures(result.getFailures()));
         }
         return this;
     }
@@ -61,15 +71,20 @@ public class JUnitResultAssert {
      * @param expectedExceptions - failures must match the supplied sequence in order,
      *                           if supplied input is empty, this method is a no-op
      */
-    public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
+    public JUnitResultAssert failsExactly(Class... expectedExceptions) {
         fails(expectedExceptions.length);
         int i = 0;
         for (Failure f : result.getFailures()) {
             if (!expectedExceptions[i].isInstance(f.getException())) {
-                throw new AssertionError("Actual failure #" + (i+1)
-                        + " should be of type: " + expectedExceptions[i].getSimpleName()
-                        + " but is of type: " + f.getException().getClass().getSimpleName()
-                        + "\n" + formatFailures(result.getFailures()));
+                throw new AssertionError(
+                        "Actual failure #"
+                                + (i + 1)
+                                + " should be of type: "
+                                + expectedExceptions[i].getSimpleName()
+                                + " but is of type: "
+                                + f.getException().getClass().getSimpleName()
+                                + "\n"
+                                + formatFailures(result.getFailures()));
             }
             i++;
         }
@@ -92,27 +107,41 @@ public class JUnitResultAssert {
      */
     public JUnitResultAssert fails(String methodName, Class expectedException) {
         for (Failure f : result.getFailures()) {
-            if (methodName.equals(f.getDescription().getMethodName()) && expectedException.isInstance(f.getException())) {
+            if (methodName.equals(f.getDescription().getMethodName())
+                    && expectedException.isInstance(f.getException())) {
                 return this;
             }
         }
-        throw new AssertionError("Method '" + methodName + "' did not fail with: " + expectedException.getSimpleName()
-                + "\n" + formatFailures(result.getFailures()));
+        throw new AssertionError(
+                "Method '"
+                        + methodName
+                        + "' did not fail with: "
+                        + expectedException.getSimpleName()
+                        + "\n"
+                        + formatFailures(result.getFailures()));
     }
 
     /**
      * Expects given amount of failures, with given exception triggered by given test method
      */
-    public JUnitResultAssert fails(int expectedFailureCount, String methodName, Class expectedException) {
-        return fails(expectedFailureCount, expectedException)
-                .fails(methodName, expectedException);
+    public JUnitResultAssert fails(
+            int expectedFailureCount, String methodName, Class expectedException) {
+        return fails(expectedFailureCount, expectedException).fails(methodName, expectedException);
     }
 
     public JUnitResultAssert succeeds(int successCount) {
         int i = result.getRunCount() - result.getFailureCount();
         if (i != successCount) {
-            throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
-                    "\n" + formatFailures(result.getFailures()));
+            throw new AssertionError(
+                    "Expected "
+                            + successCount
+                            + " passes but "
+                            + i
+                            + "/"
+                            + result.getRunCount()
+                            + " passed."
+                            + "\n"
+                            + formatFailures(result.getFailures()));
         }
         return this;
     }
diff --git a/src/test/java/org/mockitoutil/SafeJUnitRule.java b/src/test/java/org/mockitoutil/SafeJUnitRule.java
index db256d5..701c3eb 100644
--- a/src/test/java/org/mockitoutil/SafeJUnitRule.java
+++ b/src/test/java/org/mockitoutil/SafeJUnitRule.java
@@ -18,7 +18,10 @@ public class SafeJUnitRule implements MethodRule {
 
     private final MethodRule testedRule;
     private FailureAssert failureAssert = null;
-    private Runnable successAssert = new Runnable() { public void run() { } };
+    private Runnable successAssert =
+            new Runnable() {
+                public void run() {}
+            };
 
     /**
      * Wraps rule under test with exception handling so that it is easy to assert on exceptions fired from the tested rule.
@@ -27,7 +30,8 @@ public class SafeJUnitRule implements MethodRule {
         this.testedRule = testedRule;
     }
 
-    public Statement apply(final Statement base, final FrameworkMethod method, final Object target) {
+    public Statement apply(
+            final Statement base, final FrameworkMethod method, final Object target) {
         return new Statement() {
             public void evaluate() throws Throwable {
                 try {
@@ -41,8 +45,9 @@ public class SafeJUnitRule implements MethodRule {
                     return;
                 }
                 if (failureAssert != null) {
-                    //looks like the user expects a throwable but it was not thrown!
-                    throw new ExpectedThrowableNotReported("Expected the tested rule to throw an exception but it did not.");
+                    // looks like the user expects a throwable but it was not thrown!
+                    throw new ExpectedThrowableNotReported(
+                            "Expected the tested rule to throw an exception but it did not.");
                 }
             }
         };
@@ -51,26 +56,30 @@ public class SafeJUnitRule implements MethodRule {
     /**
      * Expects that _after_ the test, the rule will fire specific exception with specific exception message
      */
-    public void expectFailure(final Class<? extends Throwable> expected, final String expectedMessage) {
-        this.expectFailure(new FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertThrowable(t, expected).hasMessage(expectedMessage);
-            }
-        });
+    public void expectFailure(
+            final Class<? extends Throwable> expected, final String expectedMessage) {
+        this.expectFailure(
+                new FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertThrowable(t, expected).hasMessage(expectedMessage);
+                    }
+                });
     }
 
     /**
      * Expects that _after_ the test, the rule will fire specific exception with specific exception message
      */
     public void expectFailure(final Class<? extends Throwable> expected) {
-        this.expectFailure(new FailureAssert() {
-            public void doAssert(Throwable t) {
-                assertThrowable(t, expected);
-            }
-        });
+        this.expectFailure(
+                new FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        assertThrowable(t, expected);
+                    }
+                });
     }
 
-    private static AbstractThrowableAssert assertThrowable(Throwable throwable, Class<? extends Throwable> expected) {
+    private static AbstractThrowableAssert assertThrowable(
+            Throwable throwable, Class<? extends Throwable> expected) {
         return Assertions.assertThat(throwable).isInstanceOf(expected);
     }
 
diff --git a/src/test/java/org/mockitoutil/SafeJUnitRuleTest.java b/src/test/java/org/mockitoutil/SafeJUnitRuleTest.java
index c4bc62f..cfc4dd1 100644
--- a/src/test/java/org/mockitoutil/SafeJUnitRuleTest.java
+++ b/src/test/java/org/mockitoutil/SafeJUnitRuleTest.java
@@ -4,122 +4,165 @@
  */
 package org.mockitoutil;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.Statement;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.mock;
-
 public class SafeJUnitRuleTest {
 
     MethodRuleStub delegate = new MethodRuleStub();
     SafeJUnitRule rule = new SafeJUnitRule(delegate);
 
-    @Test public void happy_path_no_exception() throws Throwable {
-        //when
-        rule.apply(new Statement() {
-            public void evaluate() throws Throwable {
-                //all good
-            }
-        }, mock(FrameworkMethod.class), this).evaluate();
-
-        //then
+    @Test
+    public void happy_path_no_exception() throws Throwable {
+        // when
+        rule.apply(
+                        new Statement() {
+                            public void evaluate() {
+                                // all good
+                            }
+                        },
+                        mock(FrameworkMethod.class),
+                        this)
+                .evaluate();
+
+        // then
         assertTrue(delegate.statementEvaluated);
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void regular_failing_test() throws Throwable {
-        //when
-        rule.apply(new Statement() {
-            public void evaluate() throws Throwable {
-                throw new IllegalArgumentException();
-            }
-        }, mock(FrameworkMethod.class), this).evaluate();
+    @Test
+    public void regular_failing_test() {
+        // given
+        Statement baseStatement =
+                new Statement() {
+                    public void evaluate() {
+                        throw new IllegalArgumentException();
+                    }
+                };
+        Statement statement = rule.apply(baseStatement, mock(FrameworkMethod.class), this);
+
+        // when / then
+        assertThatThrownBy(
+                        () -> {
+                            statement.evaluate();
+                        })
+                .isInstanceOf(IllegalArgumentException.class);
     }
 
-    @Test public void rule_threw_exception() throws Throwable {
-        //expect
+    @Test
+    public void rule_threw_exception() throws Throwable {
+        // expect
         rule.expectFailure(AssertionError.class, "x");
 
-        //when
-        rule.apply(new Statement() {
-            public void evaluate() throws Throwable {
-                throw new AssertionError("x");
-            }
-        }, mock(FrameworkMethod.class), this).evaluate();
+        // when
+        rule.apply(
+                        new Statement() {
+                            public void evaluate() {
+                                throw new AssertionError("x");
+                            }
+                        },
+                        mock(FrameworkMethod.class),
+                        this)
+                .evaluate();
     }
 
-    @Test public void expected_exception_but_no_exception() throws Throwable {
-        //expect
+    @Test
+    public void expected_exception_but_no_exception() throws Throwable {
+        // expect
         rule.expectFailure(AssertionError.class, "x");
 
-        //when
+        // when
         try {
-            rule.apply(new Statement() {
-                public void evaluate() throws Throwable {
-                    //all good
-                }
-            }, mock(FrameworkMethod.class), this).evaluate();
+            rule.apply(
+                            new Statement() {
+                                public void evaluate() {
+                                    // all good
+                                }
+                            },
+                            mock(FrameworkMethod.class),
+                            this)
+                    .evaluate();
             fail();
 
-        //then
+            // then
         } catch (SafeJUnitRule.ExpectedThrowableNotReported t) {
-            //yup, expected
+            // yup, expected
         }
     }
 
-    @Test public void expected_exception_message_did_not_match() throws Throwable {
-        //expect
+    @Test
+    public void expected_exception_message_did_not_match() throws Throwable {
+        // expect
         rule.expectFailure(AssertionError.class, "FOO");
 
-        //when
+        // when
         try {
-            rule.apply(new Statement() {
-                public void evaluate() throws Throwable {
-                    throw new AssertionError("BAR");
-                }
-            }, mock(FrameworkMethod.class), this).evaluate();
+            rule.apply(
+                            new Statement() {
+                                public void evaluate() {
+                                    throw new AssertionError("BAR");
+                                }
+                            },
+                            mock(FrameworkMethod.class),
+                            this)
+                    .evaluate();
             fail();
         } catch (AssertionError throwable) {
             Assertions.assertThat(throwable).hasMessageContaining("Expecting message");
         }
     }
 
-    @Test public void expected_exception_type_did_not_match() throws Throwable {
-        //expect
+    @Test
+    public void expected_exception_type_did_not_match() throws Throwable {
+        // expect
         rule.expectFailure(AssertionError.class, "x");
 
-        //when
+        // when
         try {
-            rule.apply(new Statement() {
-                public void evaluate() throws Throwable {
-                    throw new RuntimeException("x");
-                }
-            }, mock(FrameworkMethod.class), this).evaluate();
+            rule.apply(
+                            new Statement() {
+                                public void evaluate() {
+                                    throw new RuntimeException("x");
+                                }
+                            },
+                            mock(FrameworkMethod.class),
+                            this)
+                    .evaluate();
             fail();
         } catch (AssertionError throwable) {
             Assertions.assertThat(throwable).hasMessageContaining("but was:");
         }
     }
 
-    @Test public void expected_exception_assert_did_not_match() throws Throwable {
-        //expect
-        rule.expectFailure(new SafeJUnitRule.FailureAssert() {
-            public void doAssert(Throwable t) {
-                throw new AssertionError("x");
-            }
-        });
-
-        //when
+    @Test
+    public void expected_exception_assert_did_not_match() throws Throwable {
+        // expect
+        rule.expectFailure(
+                new SafeJUnitRule.FailureAssert() {
+                    public void doAssert(Throwable t) {
+                        throw new AssertionError("x");
+                    }
+                });
+
+        // when
         try {
-            rule.apply(new Statement() {
-                public void evaluate() throws Throwable {
-                    throw new RuntimeException();
-                }
-            }, mock(FrameworkMethod.class), this).evaluate();
+            rule.apply(
+                            new Statement() {
+                                public void evaluate() {
+                                    throw new RuntimeException();
+                                }
+                            },
+                            mock(FrameworkMethod.class),
+                            this)
+                    .evaluate();
             fail();
         } catch (AssertionError throwable) {
             assertEquals(throwable.getMessage(), "x");
@@ -128,6 +171,7 @@ public class SafeJUnitRuleTest {
 
     private static class MethodRuleStub implements MethodRule {
         private boolean statementEvaluated;
+
         public Statement apply(final Statement base, FrameworkMethod method, Object target) {
             return new Statement() {
                 public void evaluate() throws Throwable {
diff --git a/src/test/java/org/mockitoutil/SimpleClassGenerator.java b/src/test/java/org/mockitoutil/SimpleClassGenerator.java
index 0567893..9ec5194 100644
--- a/src/test/java/org/mockitoutil/SimpleClassGenerator.java
+++ b/src/test/java/org/mockitoutil/SimpleClassGenerator.java
@@ -4,20 +4,11 @@
  */
 package org.mockitoutil;
 
-import org.objectweb.asm.ClassWriter;
-
-import static org.objectweb.asm.Opcodes.*;
+import net.bytebuddy.ByteBuddy;
 
 public class SimpleClassGenerator {
 
     public static byte[] makeMarkerInterface(String qualifiedName) {
-        String relativePath = qualifiedName.replace('.', '/');
-
-        ClassWriter cw = new ClassWriter(0);
-        cw.visit(V1_6, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, relativePath, null, "java/lang/Object", null);
-        cw.visitEnd();
-
-        return cw.toByteArray();
+        return new ByteBuddy().makeInterface().name(qualifiedName).make().getBytes();
     }
-
 }
diff --git a/src/test/java/org/mockitoutil/SimplePerRealmReloadingClassLoader.java b/src/test/java/org/mockitoutil/SimplePerRealmReloadingClassLoader.java
index 1f49afb..5855d21 100644
--- a/src/test/java/org/mockitoutil/SimplePerRealmReloadingClassLoader.java
+++ b/src/test/java/org/mockitoutil/SimplePerRealmReloadingClassLoader.java
@@ -18,7 +18,7 @@ import java.util.concurrent.Callable;
  */
 public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
 
-    private final Map<String,Class<?>> classHashMap = new HashMap<String, Class<?>>();
+    private final Map<String, Class<?>> classHashMap = new HashMap<String, Class<?>>();
     private ReloadClassPredicate reloadClassPredicate;
 
     public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {
@@ -26,16 +26,17 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
         this.reloadClassPredicate = reloadClassPredicate;
     }
 
-    public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {
+    public SimplePerRealmReloadingClassLoader(
+            ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {
         super(getPossibleClassPathsUrls(), parentClassLoader);
         this.reloadClassPredicate = reloadClassPredicate;
     }
 
     private static URL[] getPossibleClassPathsUrls() {
-        return new URL[]{
-                obtainClassPath(),
-                obtainClassPath("org.mockito.Mockito"),
-                obtainClassPath("net.bytebuddy.ByteBuddy")
+        return new URL[] {
+            obtainClassPath(),
+            obtainClassPath("org.mockito.Mockito"),
+            obtainClassPath("net.bytebuddy.ByteBuddy")
         };
     }
 
@@ -46,7 +47,11 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
 
     private static URL obtainClassPath(String className) {
         String path = className.replace('.', '/') + ".class";
-        String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();
+        String url =
+                SimplePerRealmReloadingClassLoader.class
+                        .getClassLoader()
+                        .getResource(path)
+                        .toExternalForm();
 
         try {
             return new URL(url.substring(0, url.length() - path.length()));
@@ -55,14 +60,12 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
         }
     }
 
-
-
     @Override
     public Class<?> loadClass(String qualifiedClassName) throws ClassNotFoundException {
-        if(reloadClassPredicate.acceptReloadOf(qualifiedClassName)) {
+        if (reloadClassPredicate.acceptReloadOf(qualifiedClassName)) {
             // return customLoadClass(qualifiedClassName);
-//            Class<?> loadedClass = findLoadedClass(qualifiedClassName);
-            if(!classHashMap.containsKey(qualifiedClassName)) {
+            //            Class<?> loadedClass = findLoadedClass(qualifiedClassName);
+            if (!classHashMap.containsKey(qualifiedClassName)) {
                 Class<?> foundClass = findClass(qualifiedClassName);
                 saveFoundClass(qualifiedClassName, foundClass);
                 return foundClass;
@@ -77,17 +80,16 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
         classHashMap.put(qualifiedClassName, foundClass);
     }
 
-
     private Class<?> useParentClassLoaderFor(String qualifiedName) throws ClassNotFoundException {
         return super.loadClass(qualifiedName);
     }
 
-
     public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {
         ClassLoader current = Thread.currentThread().getContextClassLoader();
         try {
             Thread.currentThread().setContextClassLoader(this);
-            Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor().newInstance();
+            Object instance =
+                    this.loadClass(callableCalledInClassLoaderRealm).getConstructor().newInstance();
             if (instance instanceof Callable) {
                 Callable<?> callableInRealm = (Callable<?>) instance;
                 return callableInRealm.call();
@@ -95,15 +97,22 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
         } finally {
             Thread.currentThread().setContextClassLoader(current);
         }
-        throw new IllegalArgumentException("qualified name '" + callableCalledInClassLoaderRealm + "' should represent a class implementing Callable");
+        throw new IllegalArgumentException(
+                "qualified name '"
+                        + callableCalledInClassLoaderRealm
+                        + "' should represent a class implementing Callable");
     }
 
-
-    public Object doInRealm(String callableCalledInClassLoaderRealm, Class<?>[] argTypes, Object[] args) throws Exception {
+    public Object doInRealm(
+            String callableCalledInClassLoaderRealm, Class<?>[] argTypes, Object[] args)
+            throws Exception {
         ClassLoader current = Thread.currentThread().getContextClassLoader();
         try {
             Thread.currentThread().setContextClassLoader(this);
-            Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor(argTypes).newInstance(args);
+            Object instance =
+                    this.loadClass(callableCalledInClassLoaderRealm)
+                            .getConstructor(argTypes)
+                            .newInstance(args);
             if (instance instanceof Callable) {
                 Callable<?> callableInRealm = (Callable<?>) instance;
                 return callableInRealm.call();
@@ -112,10 +121,12 @@ public class SimplePerRealmReloadingClassLoader extends URLClassLoader {
             Thread.currentThread().setContextClassLoader(current);
         }
 
-        throw new IllegalArgumentException("qualified name '" + callableCalledInClassLoaderRealm + "' should represent a class implementing Callable");
+        throw new IllegalArgumentException(
+                "qualified name '"
+                        + callableCalledInClassLoaderRealm
+                        + "' should represent a class implementing Callable");
     }
 
-
     public interface ReloadClassPredicate {
         boolean acceptReloadOf(String qualifiedName);
     }
diff --git a/src/test/java/org/mockitoutil/SimpleSerializationUtil.java b/src/test/java/org/mockitoutil/SimpleSerializationUtil.java
index 3d7849e..fd336e0 100644
--- a/src/test/java/org/mockitoutil/SimpleSerializationUtil.java
+++ b/src/test/java/org/mockitoutil/SimpleSerializationUtil.java
@@ -4,26 +4,32 @@
  */
 package org.mockitoutil;
 
-import java.io.*;
-
 import static org.junit.Assert.assertNotNull;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
 public abstract class SimpleSerializationUtil {
 
-    //TODO use widely
+    // TODO use widely
     @SuppressWarnings("unchecked")
     public static <T> T serializeAndBack(T obj) throws Exception {
         ByteArrayOutputStream os = serializeMock(obj);
         return (T) deserializeMock(os, Object.class);
     }
 
-    public static <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,
-            ClassNotFoundException {
+    public static <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type)
+            throws IOException, ClassNotFoundException {
         InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());
         return deserializeMock(unserialize, type);
     }
 
-    public static <T> T deserializeMock(InputStream unserialize, Class<T> type) throws IOException, ClassNotFoundException {
+    public static <T> T deserializeMock(InputStream unserialize, Class<T> type)
+            throws IOException, ClassNotFoundException {
         Object readObject = new ObjectInputStream(unserialize).readObject();
         assertNotNull(readObject);
         return type.cast(readObject);
diff --git a/src/test/java/org/mockitoutil/Stopwatch.java b/src/test/java/org/mockitoutil/Stopwatch.java
index c2140dd..5c0ea2d 100644
--- a/src/test/java/org/mockitoutil/Stopwatch.java
+++ b/src/test/java/org/mockitoutil/Stopwatch.java
@@ -4,14 +4,14 @@
  */
 package org.mockitoutil;
 
-import org.mockito.exceptions.base.MockitoAssertionError;
-
-import java.util.concurrent.TimeUnit;
-
 import static java.lang.String.format;
 import static java.lang.System.nanoTime;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
+import java.util.concurrent.TimeUnit;
+
+import org.mockito.exceptions.base.MockitoAssertionError;
+
 /**
  * This class can be uses as stopwatch to assert that a given time is elapsed or not.
  */
@@ -25,8 +25,7 @@ public class Stopwatch {
     /**
      * To create an instance use {@link #createNotStarted()}
      */
-    private Stopwatch() {
-    }
+    private Stopwatch() {}
 
     /**
      * Return a new and not started {@link Stopwatch}.
@@ -47,7 +46,9 @@ public class Stopwatch {
         long expectedNanos = unit.toNanos(expected);
 
         if (elapsedNanos <= expectedNanos)
-            fail("Expected that more than %dms elapsed! But was: %dms", expectedNanos, elapsedNanos);
+            fail(
+                    "Expected that more than %dms elapsed! But was: %dms",
+                    expectedNanos, elapsedNanos);
     }
 
     public void assertElapsedTimeIsLessThan(long expected, TimeUnit unit) {
@@ -55,17 +56,22 @@ public class Stopwatch {
         long expectedNanos = unit.toNanos(expected);
 
         if (elapsedNanos >= expectedNanos)
-            fail("Expected that less than %dms elapsed! But was: %dms", expectedNanos, elapsedNanos);
+            fail(
+                    "Expected that less than %dms elapsed! But was: %dms",
+                    expectedNanos, elapsedNanos);
     }
 
     private long elapsedNanos() {
-        if (startNanos == null)
-            throw new IllegalStateException("This stop watch is not started!");
+        if (startNanos == null) throw new IllegalStateException("This stop watch is not started!");
         return nanoTime() - startNanos;
     }
 
     private static void fail(String message, long expectedNanos, long elapsedNanos) {
-        throw new MockitoAssertionError(format(message, NANOSECONDS.toMillis(expectedNanos), NANOSECONDS.toMillis(elapsedNanos)));
+        throw new MockitoAssertionError(
+                format(
+                        message,
+                        NANOSECONDS.toMillis(expectedNanos),
+                        NANOSECONDS.toMillis(elapsedNanos)));
     }
 
     /**
diff --git a/src/test/java/org/mockitoutil/TestBase.java b/src/test/java/org/mockitoutil/TestBase.java
index 98066eb..2fe8950 100644
--- a/src/test/java/org/mockitoutil/TestBase.java
+++ b/src/test/java/org/mockitoutil/TestBase.java
@@ -2,9 +2,14 @@
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitoutil;
 
+import static org.mockito.Mockito.mock;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
+
 import org.assertj.core.api.Condition;
 import org.junit.After;
 import org.junit.Before;
@@ -12,20 +17,14 @@ import org.mockito.MockitoAnnotations;
 import org.mockito.StateMaster;
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.configuration.ConfigurationAccess;
-import org.mockito.internal.invocation.mockref.MockStrongReference;
-import org.mockito.internal.invocation.InterceptedInvocation;
 import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.InterceptedInvocation;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.invocation.SerializableMethod;
+import org.mockito.internal.invocation.mockref.MockStrongReference;
 import org.mockito.invocation.Invocation;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.PrintStream;
-
-import static org.mockito.Mockito.mock;
-
 /**
  * the easiest way to make sure that tests clean up invalid state is to require
  * valid state for all tests.
@@ -49,16 +48,17 @@ public class TestBase {
         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);
         ConfigurationAccess.getConfig().overrideDefaultAnswer(null);
         StateMaster state = new StateMaster();
-        //catch any invalid state left over after test case run
-        //this way we can catch early if some Mockito operations leave weird state afterwards
+        // catch any invalid state left over after test case run
+        // this way we can catch early if some Mockito operations leave weird state afterwards
         state.validate();
-        //reset the state, especially, reset any ongoing stubbing for correct error messages of tests that assert unhappy paths
+        // reset the state, especially, reset any ongoing stubbing for correct error messages of
+        // tests that assert unhappy paths
         state.reset();
     }
 
     @Before
     public void init() {
-        MockitoAnnotations.initMocks(this);
+        MockitoAnnotations.openMocks(this);
     }
 
     public static void makeStackTracesClean() {
@@ -73,14 +73,19 @@ public class TestBase {
         return new MockitoCore().getLastInvocation();
     }
 
-    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {
+    protected static Invocation invocationOf(Class<?> type, String methodName, Object... args)
+            throws NoSuchMethodException {
         Class<?>[] types = new Class<?>[args.length];
         for (int i = 0; i < args.length; i++) {
             types[i] = args[i].getClass();
         }
-        return new InterceptedInvocation(new MockStrongReference<Object>(mock(type), false),
-            new SerializableMethod(type.getMethod(methodName, types)), args, InterceptedInvocation.NO_OP,
-            new LocationImpl(), 1);
+        return new InterceptedInvocation(
+                new MockStrongReference<Object>(mock(type), false),
+                new SerializableMethod(type.getMethod(methodName, types)),
+                args,
+                InterceptedInvocation.NO_OP,
+                new LocationImpl(),
+                1);
     }
 
     protected static Invocation invocationAt(String location) {
@@ -96,7 +101,8 @@ public class TestBase {
         e.printStackTrace(new PrintStream(out));
         try {
             out.close();
-        } catch (IOException ex) {}
+        } catch (IOException ex) {
+        }
         return out.toString();
     }
 
diff --git a/src/test/java/org/mockitoutil/TestBaseTest.java b/src/test/java/org/mockitoutil/TestBaseTest.java
index 0ab70bd..aa98f33 100644
--- a/src/test/java/org/mockitoutil/TestBaseTest.java
+++ b/src/test/java/org/mockitoutil/TestBaseTest.java
@@ -4,19 +4,25 @@
  */
 package org.mockitoutil;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 
+import org.junit.Test;
+
 public class TestBaseTest extends TestBase {
 
-    @Test public void filters_line_no_from_stack_trace() {
+    @Test
+    public void filters_line_no_from_stack_trace() {
         assertEquals("", filterLineNo(""));
         assertEquals("asdf", filterLineNo("asdf"));
         assertEquals("asdf (FooBar.java:0) blah", filterLineNo("asdf (FooBar.java:23) blah"));
-        assertEquals("asdf\n(FooBar.java:0)\nblah", filterLineNo("asdf\n(FooBar.java:123123)\nblah"));
-        assertEquals("asdf\n(FooBar.java:0)\n(Xxx.java:0)blah", filterLineNo("asdf\n(FooBar.java:2)\n(Xxx.java:1)blah"));
+        assertEquals(
+                "asdf\n(FooBar.java:0)\nblah", filterLineNo("asdf\n(FooBar.java:123123)\nblah"));
+        assertEquals(
+                "asdf\n(FooBar.java:0)\n(Xxx.java:0)blah",
+                filterLineNo("asdf\n(FooBar.java:2)\n(Xxx.java:1)blah"));
 
-        assertEquals("asdf\n(FooBar.java:0)\nXxx.java:20)blah", filterLineNo("asdf\n(FooBar.java:2)\nXxx.java:20)blah"));
+        assertEquals(
+                "asdf\n(FooBar.java:0)\nXxx.java:20)blah",
+                filterLineNo("asdf\n(FooBar.java:2)\nXxx.java:20)blah"));
     }
 }
diff --git a/src/test/java/org/mockitoutil/ThrowableAssert.java b/src/test/java/org/mockitoutil/ThrowableAssert.java
index c58ca8e..54c4b27 100644
--- a/src/test/java/org/mockitoutil/ThrowableAssert.java
+++ b/src/test/java/org/mockitoutil/ThrowableAssert.java
@@ -24,10 +24,12 @@ public class ThrowableAssert {
     }
 
     public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
-        if(!exceptionType.isInstance(reportedException)) {
-            throw new AssertionError("Exception should be of type: "
-                    + exceptionType.getSimpleName() + " but it was: "
-                    + reportedException.getClass().getSimpleName());
+        if (!exceptionType.isInstance(reportedException)) {
+            throw new AssertionError(
+                    "Exception should be of type: "
+                            + exceptionType.getSimpleName()
+                            + " but it was: "
+                            + reportedException.getClass().getSimpleName());
         }
         return this;
     }
diff --git a/src/test/java/org/mockitoutil/VmArgAssumptions.java b/src/test/java/org/mockitoutil/VmArgAssumptions.java
index 0591a3a..4ab606e 100644
--- a/src/test/java/org/mockitoutil/VmArgAssumptions.java
+++ b/src/test/java/org/mockitoutil/VmArgAssumptions.java
@@ -4,12 +4,12 @@
  */
 package org.mockitoutil;
 
-import java.lang.management.ManagementFactory;
-import java.util.List;
-
 import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 
+import java.lang.management.ManagementFactory;
+import java.util.List;
+
 public class VmArgAssumptions {
     public static void assumeVmArgPresent(String vmArg) {
         assumeTrue(assertEnabled(vmArg));
@@ -28,5 +28,4 @@ public class VmArgAssumptions {
         }
         return false;
     }
-
 }
diff --git a/src/test/java/org/mockitoutil/async/AsyncTesting.java b/src/test/java/org/mockitoutil/async/AsyncTesting.java
index a193eb6..855d3fb 100644
--- a/src/test/java/org/mockitoutil/async/AsyncTesting.java
+++ b/src/test/java/org/mockitoutil/async/AsyncTesting.java
@@ -15,8 +15,8 @@ import java.util.LinkedList;
  */
 public class AsyncTesting {
 
-    //Sanity limit of threas. Increase it if justified.
-    private final static int MAX_THREADS = 4;
+    // Sanity limit of threas. Increase it if justified.
+    private static final int MAX_THREADS = 4;
 
     private final LinkedList<Exception> problems = new LinkedList<Exception>();
     private final LinkedList<Thread> threads = new LinkedList<Thread>();
@@ -32,22 +32,28 @@ public class AsyncTesting {
      */
     public void runAfter(final int delayMillis, final Runnable runnable) {
         if (threads.size() == MAX_THREADS) {
-            throw new RuntimeException("Please don't schedule any more threads. Figure out how to test the code with minimum amount of threads");
+            throw new RuntimeException(
+                    "Please don't schedule any more threads. Figure out how to test the code with minimum amount of threads");
         }
-        Thread t = new Thread() {
-            public void run() {
-                try {
-                    Thread.sleep(delayMillis);
-                    runnable.run();
-                } catch (Exception e) {
-                    boolean cleanStop = e instanceof InterruptedException && stopping;
-                    if (!cleanStop) {
-                        problems.add(e);
+        Thread t =
+                new Thread() {
+                    public void run() {
+                        try {
+                            Thread.sleep(delayMillis);
+                            runnable.run();
+                        } catch (Exception e) {
+                            boolean cleanStop = e instanceof InterruptedException && stopping;
+                            if (!cleanStop) {
+                                problems.add(e);
+                            }
+                        }
                     }
-                }
-            }
-        };
-        System.out.println("[AsyncTesting] Starting thread that will execute the runnable after " + delayMillis + " millis. Threads so far: " + threads.size());
+                };
+        System.out.println(
+                "[AsyncTesting] Starting thread that will execute the runnable after "
+                        + delayMillis
+                        + " millis. Threads so far: "
+                        + threads.size());
         threads.add(t);
         t.start();
     }
@@ -58,8 +64,11 @@ public class AsyncTesting {
      */
     public void cleanUp() {
         stopping = true;
-        System.out.println("[AsyncTesting] Interrupting and waiting for " + threads.size() + " threads to complete...");
-        while(!threads.isEmpty()) {
+        System.out.println(
+                "[AsyncTesting] Interrupting and waiting for "
+                        + threads.size()
+                        + " threads to complete...");
+        while (!threads.isEmpty()) {
             Thread t = threads.removeFirst();
             try {
                 t.interrupt();
@@ -69,7 +78,9 @@ public class AsyncTesting {
             }
         }
         if (!problems.isEmpty()) {
-            throw new RuntimeException("Caught " + problems.size() + " exception(s). First one is included as cause", problems.getFirst());
+            throw new RuntimeException(
+                    "Caught " + problems.size() + " exception(s). First one is included as cause",
+                    problems.getFirst());
         }
     }
 }
diff --git a/src/test/java/org/mockitoutil/async/AsyncTestingTest.java b/src/test/java/org/mockitoutil/async/AsyncTestingTest.java
index 4aacfe5..e6d7cdf 100644
--- a/src/test/java/org/mockitoutil/async/AsyncTestingTest.java
+++ b/src/test/java/org/mockitoutil/async/AsyncTestingTest.java
@@ -4,16 +4,17 @@
  */
 package org.mockitoutil.async;
 
-import org.junit.After;
-import org.junit.Test;
-import org.mockitoutil.Stopwatch;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
 import static org.junit.Assert.assertEquals;
 import static org.mockitoutil.Stopwatch.createNotStarted;
 
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.After;
+import org.junit.Test;
+import org.mockitoutil.Stopwatch;
+
 public class AsyncTestingTest {
 
     private AsyncTesting async = new AsyncTesting();
@@ -26,27 +27,29 @@ public class AsyncTestingTest {
 
     @Test
     public void sanity_test() {
-        //given
+        // given
         watch.start();
         final AtomicInteger value = new AtomicInteger(0);
 
-        //when
-        async.runAfter(200, new Runnable() {
-            public void run() {
-                value.incrementAndGet();
-            }
-        });
+        // when
+        async.runAfter(
+                200,
+                new Runnable() {
+                    public void run() {
+                        value.incrementAndGet();
+                    }
+                });
 
-        //then the runnable is truly async and has not ran yet:
+        // then the runnable is truly async and has not ran yet:
         assertEquals(0, value.get());
 
-        //after some wait...
+        // after some wait...
         watch.waitFor(300);
 
-        //we actually waited for some time
+        // we actually waited for some time
         watch.assertElapsedTimeIsMoreThan(200, MILLISECONDS);
 
-        //and the async has actually ran:
+        // and the async has actually ran:
         assertEquals(1, value.get());
     }
 }
diff --git a/subprojects/android/android.gradle b/subprojects/android/android.gradle
index 8f86eab..4cbd7dd 100644
--- a/subprojects/android/android.gradle
+++ b/subprojects/android/android.gradle
@@ -3,8 +3,8 @@ description = "Mockito for Android"
 apply from: "$rootDir/gradle/java-library.gradle"
 
 dependencies {
-    compile project.rootProject
-    compile libraries.bytebuddyandroid
+    api project.rootProject
+    implementation libraries.bytebuddyandroid
 }
 
 tasks.javadoc.enabled = false
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidByteBuddyMockMaker.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidByteBuddyMockMaker.java
index 56ffcec..98ffbcb 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidByteBuddyMockMaker.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidByteBuddyMockMaker.java
@@ -4,8 +4,8 @@
  */
 package org.mockito.android.internal.creation;
 
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
-import org.mockito.internal.util.ConsoleMockitoLogger;
 import org.mockito.internal.util.Platform;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
@@ -21,7 +21,7 @@ public class AndroidByteBuddyMockMaker implements MockMaker {
         if (Platform.isAndroid() || Platform.isAndroidMockMakerRequired()) {
             delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
         } else {
-            new ConsoleMockitoLogger().log(join(
+            Plugins.getMockitoLogger().log(join(
                     "IMPORTANT NOTE FROM MOCKITO:",
                     "",
                     "You included the 'mockito-android' dependency in a non-Android environment.",
@@ -53,4 +53,9 @@ public class AndroidByteBuddyMockMaker implements MockMaker {
     public TypeMockability isTypeMockable(Class<?> type) {
         return delegate.isTypeMockable(type);
     }
+
+    @Override
+    public void clearAllCaches() {
+        delegate.clearAllCaches();
+    }
 }
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
index 5a66ab1..7229438 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
@@ -16,7 +16,12 @@ import static org.mockito.internal.util.StringUtil.join;
 class AndroidLoadingStrategy implements SubclassLoader {
 
     @Override
-    public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
+    public boolean isDisrespectingOpenness() {
+        return false;
+    }
+
+    @Override
+    public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean localMock) {
         File target = AndroidTempFileLocator.target;
         if (target == null) {
             throw new MockitoException(join(
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidTempFileLocator.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidTempFileLocator.java
index a79816c..4d193ba 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidTempFileLocator.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidTempFileLocator.java
@@ -23,12 +23,10 @@ class AndroidTempFileLocator {
         } catch (Throwable ignored) {
         }
         if (t == null) {
-            try {
-                Class<?> clazz = Class.forName("android.support.test.InstrumentationRegistry");
-                Object context = clazz.getDeclaredMethod("getTargetContext").invoke(clazz);
-                t = (File) context.getClass().getMethod("getCacheDir").invoke(context);
-            } catch (Throwable ignored) {
-            }
+            t = getCacheDirFromInstrumentationRegistry("android.support.test.InstrumentationRegistry");
+        }
+        if (t == null) {
+            t = getCacheDirFromInstrumentationRegistry("androidx.test.InstrumentationRegistry");
         }
         if (t == null) {
             try {
@@ -46,6 +44,16 @@ class AndroidTempFileLocator {
         target = t;
     }
 
+    private static File getCacheDirFromInstrumentationRegistry(String className) {
+        try {
+            Class<?> clazz = Class.forName(className);
+            Object context = clazz.getDeclaredMethod("getTargetContext").invoke(clazz);
+            return (File) context.getClass().getMethod("getCacheDir").invoke(context);
+        } catch (Throwable ignored) {
+        }
+        return null;
+    }
+
     private static File[] guessPath(String input) {
         List<File> results = new ArrayList<File>();
         for (String potential : splitPathList(input)) {
@@ -63,10 +71,10 @@ class AndroidTempFileLocator {
             }
             String packageName = potential.substring(start, end);
             File dataDir = new File("/data/data/" + packageName);
-            if (isWriteableDirectory(dataDir)) {
+            if (isWritableDirectory(dataDir)) {
                 File cacheDir = new File(dataDir, "cache");
                 if (fileOrDirExists(cacheDir) || cacheDir.mkdir()) {
-                    if (isWriteableDirectory(cacheDir)) {
+                    if (isWritableDirectory(cacheDir)) {
                         results.add(cacheDir);
                     }
                 }
@@ -91,7 +99,7 @@ class AndroidTempFileLocator {
         return file.exists();
     }
 
-    private static boolean isWriteableDirectory(File file) {
+    private static boolean isWritableDirectory(File file) {
         return file.isDirectory() && file.canWrite();
     }
 }
diff --git a/subprojects/inline/inline.gradle b/subprojects/inline/inline.gradle
index b8d2577..f96cffc 100644
--- a/subprojects/inline/inline.gradle
+++ b/subprojects/inline/inline.gradle
@@ -3,11 +3,19 @@ description = "Mockito preconfigured inline mock maker (intermediate and to be s
 apply from: "$rootDir/gradle/java-library.gradle"
 
 dependencies {
-    compile project.rootProject
-    testCompile libraries.junit4
+    api project.rootProject
+    testImplementation libraries.junit4
+    testImplementation libraries.assertj
 }
 
 tasks.javadoc.enabled = false
 
-//required by the "StressTest.java"
+//required by the "StressTest.java" and "OneLinerStubStressTest.java"
 test.maxHeapSize = "256m"
+retryTest.maxHeapSize = "256m"
+
+if (JavaVersion.current().java9Compatible) {
+    test {
+        jvmArgs '--illegal-access=deny'
+    }
+}
diff --git a/subprojects/inline/src/main/resources/mockito-extensions/org.mockito.plugins.MemberAccessor b/subprojects/inline/src/main/resources/mockito-extensions/org.mockito.plugins.MemberAccessor
new file mode 100644
index 0000000..1422f99
--- /dev/null
+++ b/subprojects/inline/src/main/resources/mockito-extensions/org.mockito.plugins.MemberAccessor
@@ -0,0 +1 @@
+member-accessor-module
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockRuleTest.java b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockRuleTest.java
new file mode 100644
index 0000000..e53202e
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockRuleTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockedConstruction;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import static junit.framework.TestCase.*;
+
+public final class ConstructionMockRuleTest {
+
+    @Rule
+    public MockitoRule mockitoRule = MockitoJUnit.rule();
+
+    @Mock
+    private MockedConstruction<Dummy> dummy;
+
+    @Test
+    public void testConstructionMockSimple() {
+        assertNull(new Dummy().foo());
+    }
+
+    @Test
+    public void testConstructionMockCollection() {
+        assertEquals(0, dummy.constructed().size());
+        Dummy mock = new Dummy();
+        assertEquals(1, dummy.constructed().size());
+        assertTrue(dummy.constructed().contains(mock));
+    }
+
+    static class Dummy {
+
+        String foo() {
+            return "foo";
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java
new file mode 100644
index 0000000..7eb87c5
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import static junit.framework.TestCase.assertEquals;
+import static junit.framework.TestCase.assertNull;
+import static junit.framework.TestCase.assertTrue;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Collections;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.Test;
+import org.mockito.MockedConstruction;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+
+public final class ConstructionMockTest {
+
+    @Test
+    public void testConstructionMockSimple() {
+        assertEquals("foo", new Dummy().foo());
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class)) {
+            assertNull(new Dummy().foo());
+        }
+        assertEquals("foo", new Dummy().foo());
+    }
+
+    @Test
+    public void testConstructionMockCollection() {
+        try (MockedConstruction<Dummy> dummy = Mockito.mockConstruction(Dummy.class)) {
+            assertEquals(0, dummy.constructed().size());
+            Dummy mock = new Dummy();
+            assertEquals(1, dummy.constructed().size());
+            assertTrue(dummy.constructed().contains(mock));
+        }
+    }
+
+    @Test
+    public void testConstructionMockDefaultAnswer() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstructionWithAnswer(Dummy.class, invocation -> "bar")) {
+            assertEquals("bar", new Dummy().foo());
+        }
+    }
+
+    @Test
+    public void testConstructionMockDefaultAnswerMultiple() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstructionWithAnswer(Dummy.class, invocation -> "bar", invocation -> "qux")) {
+            assertEquals("bar", new Dummy().foo());
+            assertEquals("qux", new Dummy().foo());
+            assertEquals("qux", new Dummy().foo());
+        }
+    }
+
+    /**
+     * Tests issue #2544
+     */
+    @Test
+    public void testConstructionMockDefaultAnswerMultipleMoreThanTwo() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstructionWithAnswer(Dummy.class, invocation -> "bar", invocation -> "qux", invocation -> "baz")) {
+            assertEquals("bar", new Dummy().foo());
+            assertEquals("qux", new Dummy().foo());
+            assertEquals("baz", new Dummy().foo());
+            assertEquals("baz", new Dummy().foo());
+        }
+    }
+
+    @Test
+    public void testConstructionMockPrepared() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class, (mock, context) -> when(mock.foo()).thenReturn("bar"))) {
+            assertEquals("bar", new Dummy().foo());
+        }
+    }
+
+
+    @Test
+    public void testConstructionMockContext() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class, (mock, context) -> {
+            assertEquals(1, context.getCount());
+            assertEquals(Collections.singletonList("foobar"), context.arguments());
+            assertEquals(mock.getClass().getDeclaredConstructor(String.class), context.constructor());
+            when(mock.foo()).thenReturn("bar");
+        })) {
+            assertEquals("bar", new Dummy("foobar").foo());
+        }
+    }
+
+    @Test
+    public void testConstructionMockDoesNotAffectDifferentThread() throws InterruptedException {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class)) {
+            Dummy dummy = new Dummy();
+            when(dummy.foo()).thenReturn("bar");
+            assertEquals("bar", dummy.foo());
+            verify(dummy).foo();
+            AtomicReference<String> reference = new AtomicReference<>();
+            Thread thread = new Thread(() -> reference.set(new Dummy().foo()));
+            thread.start();
+            thread.join();
+            assertEquals("foo", reference.get());
+            when(dummy.foo()).thenReturn("bar");
+            assertEquals("bar", dummy.foo());
+            verify(dummy, times(2)).foo();
+        }
+    }
+
+    @Test
+    public void testConstructionMockCanCoexistWithMockInDifferentThread() throws InterruptedException {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class)) {
+            Dummy dummy = new Dummy();
+            when(dummy.foo()).thenReturn("bar");
+            assertEquals("bar", dummy.foo());
+            verify(dummy).foo();
+            AtomicReference<String> reference = new AtomicReference<>();
+            Thread thread = new Thread(() -> {
+                try (MockedConstruction<Dummy> ignored2 = Mockito.mockConstruction(Dummy.class)) {
+                    Dummy other = new Dummy();
+                    when(other.foo()).thenReturn("qux");
+                    reference.set(other.foo());
+                }
+            });
+            thread.start();
+            thread.join();
+            assertEquals("qux", reference.get());
+            assertEquals("bar", dummy.foo());
+            verify(dummy, times(2)).foo();
+        }
+    }
+
+    @Test
+    public void testConstructionMockMustBeExclusiveInScopeWithinThread() {
+        assertThatThrownBy(
+                () -> {
+                    try (
+                            MockedConstruction<Dummy> dummy = Mockito.mockConstruction(Dummy.class);
+                            MockedConstruction<Dummy> duplicate = Mockito.mockConstruction(Dummy.class)) {
+                    }
+                })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("static mocking is already registered in the current thread");
+    }
+
+    @Test
+    public void testConstructionMockMustNotTargetAbstractClass() {
+        assertThatThrownBy(
+                () -> {
+                    Mockito.mockConstruction(Runnable.class).close();
+                })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("It is not possible to construct primitive types or abstract types");
+    }
+
+    static class Dummy {
+
+
+        public Dummy() {
+        }
+
+        public Dummy(String value) {
+        }
+
+        String foo() {
+            return "foo";
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/EnumMockingTest.java b/subprojects/inline/src/test/java/org/mockitoinline/EnumMockingTest.java
new file mode 100644
index 0000000..a418aab
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/EnumMockingTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2021 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+public class EnumMockingTest {
+
+    @Test
+    public void testMockEnum() {
+        Animal a = Mockito.mock(Animal.class);
+        assertThat(a, not(equalTo(Animal.CAT)));
+        assertThat(a.sound(), nullValue(String.class));
+        assertThat(a.name(), nullValue(String.class));
+    }
+
+    enum Animal {
+        CAT {
+            @Override
+            public String sound() {
+                return "meow";
+            }
+        };
+
+        public abstract String sound();
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/HierarchyPreInitializationTest.java b/subprojects/inline/src/test/java/org/mockitoinline/HierarchyPreInitializationTest.java
new file mode 100644
index 0000000..16aed5f
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/HierarchyPreInitializationTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+
+import static org.mockito.Mockito.mock;
+
+public class HierarchyPreInitializationTest {
+
+    @Test
+    @SuppressWarnings("CheckReturnValue")
+    public void testOrder() {
+        mock(MyClass.class);
+        mock(TestSubInterface.class);
+    }
+
+    public interface TestInterface {
+
+        @SuppressWarnings("unused")
+        MyClass INSTANCE = new MyClass().probe();
+    }
+
+    public interface TestSubInterface extends TestInterface {
+    }
+
+    public static class MyClass {
+
+        private final Object obj;
+
+        public MyClass() {
+            obj = new Object();
+        }
+
+        public MyClass probe() {
+            if (obj == null) {
+                throw new RuntimeException();
+            }
+            return this;
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/InitializationTest.java b/subprojects/inline/src/test/java/org/mockitoinline/InitializationTest.java
new file mode 100644
index 0000000..c4f62f4
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/InitializationTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import static junit.framework.TestCase.assertEquals;
+
+public class InitializationTest {
+
+    @Test
+    public void assure_initialization_prior_to_instrumentation() {
+        @SuppressWarnings("unused")
+        SampleEnum mock = Mockito.mock(SampleEnum.class);
+        SampleEnum[] values = SampleEnum.values();
+        assertEquals("VALUE", values[0].name());
+    }
+
+    public enum SampleEnum {
+        VALUE
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/OneLinerStubStressTest.java b/subprojects/inline/src/test/java/org/mockitoinline/OneLinerStubStressTest.java
new file mode 100644
index 0000000..44ff959
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/OneLinerStubStressTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class OneLinerStubStressTest {
+
+    public class OneLinerStubTestClass {
+        public String getStuff() {
+            return "A";
+        }
+    }
+
+    private static String generateLargeString() {
+        final int length = 2000000;
+        final StringBuilder stringBuilder = new StringBuilder(length);
+        for (int i = 0; i <= length; i++) {
+            stringBuilder.append("B");
+        }
+        return stringBuilder.toString();
+    }
+
+    @Test
+    public void call_a_lot_of_mocks_using_one_line_stubbing() {
+        //This requires smaller heap set for the test process, see "inline.gradle"
+        final String returnValue = generateLargeString();
+        for (int i = 0; i < 50000; i++) {
+            // make sure that mock object does not get cleaned up prematurely
+            final OneLinerStubTestClass mock =
+                when(mock(OneLinerStubTestClass.class).getStuff()).thenReturn(returnValue).getMock();
+            assertEquals(returnValue, mock.getStuff());
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/PluginTest.java b/subprojects/inline/src/test/java/org/mockitoinline/PluginTest.java
index 19526db..16e2da2 100644
--- a/subprojects/inline/src/test/java/org/mockitoinline/PluginTest.java
+++ b/subprojects/inline/src/test/java/org/mockitoinline/PluginTest.java
@@ -7,14 +7,20 @@ package org.mockitoinline;
 import org.junit.Test;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
+import org.mockito.internal.util.reflection.ModuleMemberAccessor;
 
 import static org.junit.Assert.*;
 
 public class PluginTest {
 
     @Test
-    public void plugin_type_should_be_inline() throws Exception {
+    public void mock_maker_should_be_inline() throws Exception {
         assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);
     }
 
+    @Test
+    public void member_accessor_should_be_module() throws Exception {
+        assertTrue(Plugins.getMemberAccessor() instanceof ModuleMemberAccessor);
+    }
+
 }
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java b/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java
new file mode 100644
index 0000000..fcaa581
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertEquals;
+import static org.mockito.Mockito.*;
+
+public class SpyWithConstructorTest {
+
+    private SomethingAbstract somethingAbstract;
+
+    @Before
+    public void setUp() {
+        somethingAbstract = mock(SomethingAbstract.class, withSettings()
+            .useConstructor("foo")
+            .defaultAnswer(CALLS_REAL_METHODS));
+    }
+
+    @Test
+    public void shouldUseConstructor() {
+        assertEquals("foo", somethingAbstract.getValue());
+    }
+
+    static abstract class SomethingAbstract {
+
+        private final String value;
+
+        SomethingAbstract(String value) {
+            this.value = value;
+        }
+
+        public String getValue() {
+            return value;
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StaticMockRuleTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StaticMockRuleTest.java
new file mode 100644
index 0000000..c54d6a6
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/StaticMockRuleTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockedStatic;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import static junit.framework.TestCase.*;
+
+public final class StaticMockRuleTest {
+
+    @Rule
+    public MockitoRule mockitoRule = MockitoJUnit.rule();
+
+    @Mock
+    private MockedStatic<Dummy> dummy;
+
+    @Test
+    public void testStaticMockSimple() {
+        assertNull(Dummy.foo());
+    }
+
+    @Test
+    public void testStaticMockWithVerification() {
+        dummy.when(Dummy::foo).thenReturn("bar");
+        assertEquals("bar", Dummy.foo());
+        dummy.verify(Dummy::foo);
+    }
+
+    static class Dummy {
+
+        static String foo() {
+            return "foo";
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StaticMockTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StaticMockTest.java
new file mode 100644
index 0000000..eaa3ed1
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/StaticMockTest.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import static junit.framework.TestCase.assertEquals;
+import static junit.framework.TestCase.assertNull;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.times;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.Test;
+import org.mockito.MockedStatic;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
+
+public final class StaticMockTest {
+
+    @Test
+    public void testStaticMockSimple() {
+        assertEquals("foo", Dummy.foo());
+        try (MockedStatic<Dummy> ignored = Mockito.mockStatic(Dummy.class)) {
+            assertNull(Dummy.foo());
+        }
+        assertEquals("foo", Dummy.foo());
+    }
+
+    @Test
+    public void testStaticMockWithVerification() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo);
+        }
+    }
+
+    @Test
+    public void testStaticMockWithVerificationFailed() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            assertThatThrownBy(
+                    () -> {
+                        dummy.verify(Dummy::foo);
+                    })
+                    .isInstanceOf(WantedButNotInvoked.class)
+                    .hasMessageContaining("there were zero interactions with this mock");
+        }
+    }
+
+    @Test
+    public void testStaticMockWithNoInteractions() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            dummy.verifyNoInteractions();
+        }
+    }
+
+    @Test
+    public void testStaticMockWithNoInteractionsFailed() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            assertThatThrownBy(
+                    () -> {
+                        dummy.verifyNoInteractions();
+                    })
+                    .isInstanceOf(NoInteractionsWanted.class)
+                    .hasMessageContaining("No interactions wanted here")
+                    .hasMessageContaining("above is the only interaction with this mock.");
+        }
+    }
+
+    @Test
+    public void testStaticMockWithNoMoreInteractions() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo);
+            dummy.verifyNoMoreInteractions();
+        }
+    }
+
+    @Test
+    public void testStaticMockWithNoMoreInteractionsFailed() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            assertThatThrownBy(
+                    () -> {
+                        dummy.verifyNoInteractions();
+                    })
+                    .isInstanceOf(NoInteractionsWanted.class)
+                    .hasMessageContaining("No interactions wanted here")
+                    .hasMessageContaining("above is the only interaction with this mock.");
+        }
+    }
+
+    @Test
+    public void testStaticMockWithDefaultAnswer() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class, invocation -> "bar")) {
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo);
+        }
+    }
+
+    @Test
+    public void testStaticMockWithRealMethodCall() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenCallRealMethod();
+            assertEquals("foo", Dummy.foo());
+            dummy.verify(Dummy::foo);
+        }
+    }
+
+    @Test
+    public void testStaticMockReset() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            dummy.reset();
+            assertNull(Dummy.foo());
+        }
+    }
+
+    @Test
+    public void testStaticMockClear() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.clearInvocations();
+            dummy.verifyNoInteractions();
+        }
+    }
+
+    @Test
+    public void testStaticMockDoesNotAffectDifferentThread() throws InterruptedException {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo);
+            AtomicReference<String> reference = new AtomicReference<>();
+            Thread thread = new Thread(() -> reference.set(Dummy.foo()));
+            thread.start();
+            thread.join();
+            assertEquals("foo", reference.get());
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo, times(2));
+        }
+    }
+
+    @Test
+    public void testStaticMockCanCoexistWithMockInDifferentThread() throws InterruptedException {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo);
+            AtomicReference<String> reference = new AtomicReference<>();
+            Thread thread = new Thread(() -> {
+                try (MockedStatic<Dummy> dummy2 = Mockito.mockStatic(Dummy.class)) {
+                    dummy2.when(Dummy::foo).thenReturn("qux");
+                    reference.set(Dummy.foo());
+                }
+            });
+            thread.start();
+            thread.join();
+            assertEquals("qux", reference.get());
+            dummy.when(Dummy::foo).thenReturn("bar");
+            assertEquals("bar", Dummy.foo());
+            dummy.verify(Dummy::foo, times(2));
+        }
+    }
+
+    @Test
+    public void testStaticMockMustBeExclusiveInScopeWithinThread() {
+        assertThatThrownBy(
+                () -> {
+                    try (
+                            MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class);
+                            MockedStatic<Dummy> duplicate = Mockito.mockStatic(Dummy.class)
+                    ) {
+                    }
+                })
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("static mocking is already registered in the current thread");
+    }
+
+    @Test
+    public void testStaticMockVoid() {
+        try (MockedStatic<Dummy> dummy = Mockito.mockStatic(Dummy.class)) {
+            Dummy.fooVoid("bar");
+            assertNull(Dummy.var1);
+            dummy.verify(() -> Dummy.fooVoid("bar"));
+        }
+        Dummy.fooVoid("bar");
+        assertEquals("bar", Dummy.var1);
+    }
+
+    @Test
+    public void testStaticMockMustUseValidMatchers() {
+        try (MockedStatic<Dummy> mockedClass = Mockito.mockStatic(Dummy.class)) {
+            assertThatThrownBy(
+                    () -> {
+                        mockedClass.when(() -> Dummy.fooVoid("foo", any())).thenReturn(null);
+                    })
+                .hasMessageContaining("Invalid use of argument matchers!");
+
+            Dummy.fooVoid("foo", "bar");
+        }
+    }
+
+    static class Dummy {
+
+        static String var1 = null;
+
+        static String foo() {
+            return "foo";
+        }
+
+        static void fooVoid(String var2) {
+            var1 = var2;
+        }
+
+        static void fooVoid(String var2, String var3) {
+            var1 = var2;
+        }
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StaticRuleTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StaticRuleTest.java
new file mode 100644
index 0000000..68b9c6a
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/StaticRuleTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockedStatic;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.UUID;
+
+import static junit.framework.TestCase.assertEquals;
+
+public final class StaticRuleTest {
+
+    @Rule
+    public MockitoRule mockitoRule = MockitoJUnit.rule();
+
+    @Mock
+    private MockedStatic<UUID> mock;
+
+    @Test
+    public void runs() {
+        mock.when(UUID::randomUUID).thenReturn(new UUID(123, 456));
+        assertEquals(UUID.randomUUID(), new UUID(123, 456));
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StaticRunnerTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StaticRunnerTest.java
new file mode 100644
index 0000000..e015959
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/StaticRunnerTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockedStatic;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.UUID;
+
+import static junit.framework.TestCase.assertEquals;
+
+@RunWith(MockitoJUnitRunner.class)
+public final class StaticRunnerTest {
+
+    @Mock
+    private MockedStatic<UUID> mock;
+
+    @Test
+    public void runs() {
+        mock.when(UUID::randomUUID).thenReturn(new UUID(123, 456));
+        assertEquals(UUID.randomUUID(), new UUID(123, 456));
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/bugs/CyclicMockMethodArgumentMemoryLeakTest.java b/subprojects/inline/src/test/java/org/mockitoinline/bugs/CyclicMockMethodArgumentMemoryLeakTest.java
index 936bd01..20efc9d 100644
--- a/subprojects/inline/src/test/java/org/mockitoinline/bugs/CyclicMockMethodArgumentMemoryLeakTest.java
+++ b/subprojects/inline/src/test/java/org/mockitoinline/bugs/CyclicMockMethodArgumentMemoryLeakTest.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2019 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitoinline.bugs;
 
 import org.junit.Test;
@@ -37,4 +36,3 @@ public class CyclicMockMethodArgumentMemoryLeakTest {
         void accept(A a) {}
     }
 }
-
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/bugs/SelfSpyReferenceMemoryLeakTest.java b/subprojects/inline/src/test/java/org/mockitoinline/bugs/SelfSpyReferenceMemoryLeakTest.java
index 0ef8e71..678e43c 100644
--- a/subprojects/inline/src/test/java/org/mockitoinline/bugs/SelfSpyReferenceMemoryLeakTest.java
+++ b/subprojects/inline/src/test/java/org/mockitoinline/bugs/SelfSpyReferenceMemoryLeakTest.java
@@ -2,7 +2,6 @@
  * Copyright (c) 2019 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
-
 package org.mockitoinline.bugs;
 
 import org.junit.Test;
@@ -33,4 +32,3 @@ public class SelfSpyReferenceMemoryLeakTest {
         }
     }
 }
-
diff --git a/update_source.sh b/update_source.sh
deleted file mode 100755
index 12f1a36..0000000
--- a/update_source.sh
+++ /dev/null
@@ -1,66 +0,0 @@
-#!/bin/bash
-#
-# Copyright 2013 The Android Open Source Project.
-#
-# Retrieves the current Mockito source code into the current directory, excluding portions related
-# to mockito's internal build system and javadoc.
-
-# Force stop on first error.
-set -e
-
-if [ $# -ne 1 ]; then
-    echo "$0 <version>" >&2
-    exit 1;
-fi
-
-if [ -z "$ANDROID_BUILD_TOP" ]; then
-    echo "Missing environment variables. Did you run build/envsetup.sh and lunch?" >&2
-    exit 1
-fi
-
-VERSION=${1}
-
-SOURCE="git://github.com/mockito/mockito.git"
-INCLUDE="
-    LICENSE
-    src
-    subprojects/android
-    subprojects/inline
-    "
-
-EXCLUDE="
-    src/conf
-    src/javadoc
-    "
-
-working_dir="$(mktemp -d)"
-trap "echo \"Removing temporary directory\"; rm -rf $working_dir" EXIT
-
-echo "Fetching Mockito source into $working_dir"
-git clone $SOURCE $working_dir/source
-(cd $working_dir/source; git checkout $VERSION)
-
-for include in ${INCLUDE}; do
-  echo "Updating $include"
-  rm -rf $include
-  mkdir -p $(dirname $include)
-  cp -R $working_dir/source/$include $include
-done;
-
-for exclude in ${EXCLUDE}; do
-  echo "Excluding $exclude"
-  rm -r $exclude
-done;
-
-echo "Done"
-
-# Update the version.
-perl -pi -e "s|^Version: .*$|Version: ${VERSION}|" "README.version"
-
-# Remove any documentation about local modifications.
-mv README.version README.tmp
-grep -B 100 "Local Modifications" README.tmp > README.version
-echo "        None" >> README.version
-rm README.tmp
-
-echo "Done"
```

