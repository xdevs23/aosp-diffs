```diff
diff --git a/.appveyor.yml b/.appveyor.yml
index 7b1f9f2a..708e7cec 100644
--- a/.appveyor.yml
+++ b/.appveyor.yml
@@ -10,17 +10,24 @@ matrix:
   fast_finish: true
 
 install:
-  - cinst winflexbison
+  - choco install winflexbison
   - win_flex --version
   - win_bison --version
-  - appveyor DownloadFile https://www.winpcap.org/install/bin/WpdPack_4_1_2.zip
+  - appveyor DownloadFile https://github.com/the-tcpdump-group/tcpdump-htdocs/raw/master/depends/WpdPack_4_1_2.zip
   - 7z x .\WpdPack_4_1_2.zip -oc:\projects\libpcap\Win32
   - appveyor DownloadFile https://npcap.com/dist/npcap-sdk-1.13.zip
-  - 7z x .\npcap-sdk-1.13.zip -oc:\projects\libpcap\Win32\npcap-sdk-1.13
+  - 7z x .\npcap-sdk-1.13.zip -oc:\projects\libpcap\Win32\npcap-sdk
   - appveyor DownloadFile https://support.riverbed.com/bin/support/download?sid=l3vk3eu649usgu3rj60uncjqqu -FileName AirPcap_Devpack.zip
   - 7z x .\AirPcap_Devpack.zip -oc:\projects\libpcap\Win32
 
 environment:
+  #
+  # The OpenSSL library on the current AppVeyor Visual Studio 2019
+  # images has a weird opensslv.h that claims its 1.0.2, even though
+  # it's 3.0.  This causes... problems.
+  #
+  # For now, we disable the remote capture build there.
+  #
   matrix:
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
       GENERATOR: "MinGW Makefiles"
@@ -33,10 +40,10 @@ environment:
       AIRPCAP: -DDISABLE_AIRPCAP=YES
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
       GENERATOR: "Visual Studio 14 2015"
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
       GENERATOR: "Visual Studio 14 2015 Win64"
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=YES
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
       GENERATOR: "Visual Studio 15 2017"
@@ -47,41 +54,46 @@ environment:
       AIRPCAP: -DDISABLE_AIRPCAP=YES
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
       GENERATOR: "Visual Studio 15 2017"
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=YES
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
       GENERATOR: "Visual Studio 15 2017 Win64"
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=YES
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
       GENERATOR: "Visual Studio 15 2017 Win64"
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=NO
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
       GENERATOR: "Visual Studio 16 2019"
       PLATFORM: Win32
       SDK: WpdPack
       AIRPCAP: -DDISABLE_AIRPCAP=YES
+      REMOTE: -DENABLE_REMOTE=NO
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
       GENERATOR: "Visual Studio 16 2019"
       PLATFORM: x64
       SDK: WpdPack
       AIRPCAP: -DDISABLE_AIRPCAP=YES
+      REMOTE: -DENABLE_REMOTE=NO
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
       GENERATOR: "Visual Studio 16 2019"
       PLATFORM: Win32
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=YES
+      REMOTE: -DENABLE_REMOTE=NO
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
       GENERATOR: "Visual Studio 16 2019"
       PLATFORM: x64
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=YES
+      REMOTE: -DENABLE_REMOTE=NO
     - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019
       GENERATOR: "Visual Studio 16 2019"
       PLATFORM: x64
-      SDK: npcap-sdk-1.12
+      SDK: npcap-sdk
       AIRPCAP: -DDISABLE_AIRPCAP=NO
+      REMOTE: -DENABLE_REMOTE=NO
 
 build_script:
   #
@@ -98,7 +110,7 @@ build_script:
   # that breaks MinGW builds - CMake checks for that and fails in the
   # configuration stage
   - if "%GENERATOR%"=="MinGW Makefiles" set PATH=%PATH:C:\Program Files\Git\usr\bin;=%
-  - if NOT DEFINED PLATFORM  cmake %AIRPCAP% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DAirPcap_ROOT=c:\projects\libpcap\Win32\Airpcap_Devpack -G"%GENERATOR%" ..
-  - if DEFINED PLATFORM cmake %AIRPCAP% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DAirPcap_ROOT=c:\projects\libpcap\Win32\Airpcap_Devpack -G"%GENERATOR%" -A %PLATFORM% ..
+  - if NOT DEFINED PLATFORM cmake %AIRPCAP% %REMOTE% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DAirPcap_ROOT=c:\projects\libpcap\Win32\Airpcap_Devpack -G"%GENERATOR%" ..
+  - if DEFINED PLATFORM cmake %AIRPCAP% %REMOTE% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -DPacket_ROOT=c:\projects\libpcap\Win32\%SDK% -G"%GENERATOR%" -DAirPcap_ROOT=c:\projects\libpcap\Win32\Airpcap_Devpack -G"%GENERATOR%" -A %PLATFORM% ..
   - if NOT "%GENERATOR%"=="MinGW Makefiles" msbuild /m /nologo /p:Configuration=Release pcap.sln
   - if "%GENERATOR%"=="MinGW Makefiles" mingw32-make
diff --git a/.ci-coverity-scan-build.sh b/.ci-coverity-scan-build.sh
index 686806a3..6d00f4fe 100755
--- a/.ci-coverity-scan-build.sh
+++ b/.ci-coverity-scan-build.sh
@@ -46,7 +46,7 @@ if [ ! -d $TOOL_BASE ]; then
 fi
 
 TOOL_DIR=$(find $TOOL_BASE -type d -name 'cov-analysis*')
-export PATH=$TOOL_DIR/bin:$PATH
+export PATH="$TOOL_DIR/bin:$PATH"
 
 # Build
 printf "\033[33;1mRunning Coverity Scan Analysis Tool...\033[0m\n"
diff --git a/.cirrus.yml b/.cirrus.yml
index c2cf4223..ca7969ba 100644
--- a/.cirrus.yml
+++ b/.cirrus.yml
@@ -6,20 +6,15 @@ freebsd_task:
   name: freebsd-amd64
   only_if: $CIRRUS_BRANCH != 'coverity_scan'
   freebsd_instance:
-    matrix:
-      - image_family: freebsd-12-3
-        cpu: 2
-        memory: 2G
-      - image_family: freebsd-13-1
-        cpu: 4
-        memory: 4G
+    cpu: 1
+    memory: 2G
+    image_family: freebsd-13-3
   env:
     IGNORE_OSVERSION: yes
-    MAKEFLAGS: -j 4
-    MATRIX_CC: clang14 gcc12
+    MATRIX_CC: clang17 gcc13
   script:
-    - pkg install -qy autoconf gcc12 llvm14
-    - pkg install -qy cmake git-tiny # for build_matrix.sh and build.sh
+    - pkg install -qy autoconf gcc13 llvm17
+    - pkg install -qy cmake-core git-tiny # for build_matrix.sh and build.sh
     - ./build_matrix.sh
 
 linux_task:
@@ -27,18 +22,21 @@ linux_task:
   only_if: $CIRRUS_BRANCH != 'coverity_scan'
   container:
     image: ubuntu:22.04
-    cpu: 2
+    cpu: 1
     memory: 1G
   env:
     DEBIAN_FRONTEND: noninteractive
-    MAKEFLAGS: -j 3
+    LANG: C
   script:
     - apt-get -qy update >/dev/null
-    - apt-get -qy install libdbus-1-dev libbluetooth-dev libnl-genl-3-dev libibverbs-dev libssl-dev >/dev/null
-    - apt-get -qy install flex bison autoconf make clang gcc valgrind >/dev/null
-    - apt-get -qy install cmake git bc >/dev/null # for build_matrix.sh and build.sh
-    - apt list --installed 'lib*-dev'
-    - ./build_matrix.sh
+    - apt-get -qy install flex bison autoconf make gcc >/dev/null # for "./configure"
+    - apt-get -qy install cmake git >/dev/null # for "make releasecheck"
+    - apt-get -qy install shellcheck >/dev/null
+    - ./autogen.sh
+    - ./configure --quiet # build the Makefile
+    - make releasecheck
+    - make whitespacecheck
+    - make shellcheck
 
 macos_task:
   name: macos-aarch64
@@ -52,35 +50,25 @@ macos_task:
     - brew install openssl@3
     - ./build_matrix.sh
 
-#
-# Just testing for now.
-#
-windows_task:
-  name: windows-amd64
-  only_if: $CIRRUS_BRANCH != 'coverity_scan'
-  windows_container:
-    image: cirrusci/windowsservercore:2019
-  script:
-    - set/?
-
 coverity_task:
   name: Coverity Scan
   only_if: $CIRRUS_BRANCH == 'coverity_scan'
   container:
     image: ubuntu:22.04
-    cpu: 2
+    cpu: 1
     memory: 2G
   env:
     DEBIAN_FRONTEND: noninteractive
-    MAKEFLAGS: -j 3
     COVERITY_SCAN_PROJECT_NAME: $CIRRUS_REPO_FULL_NAME
     COVERITY_SCAN_TOKEN: ENCRYPTED[58bfbfcf624e5b7b85fb9df95dd0b3f9f93642824e6ae94616e4d345af4848580932a6ece02337fee112194b29ce6593]
-    COVERITY_SCAN_BUILD_COMMAND_PREPEND: ./configure --enable-remote
+    COVERITY_SCAN_BUILD_COMMAND_PREPEND: ./configure --enable-remote --enable-optimizer-dbg --enable-yydebug
     COVERITY_SCAN_BUILD_COMMAND: make
+    LANG: C
   script:
     - apt-get -qy update >/dev/null
-    - apt-get -qy install libdbus-1-dev libbluetooth-dev libnl-genl-3-dev libibverbs-dev >/dev/null
+    - apt-get -qy install libdbus-1-dev libbluetooth-dev libnl-genl-3-dev libibverbs-dev libssl-dev >/dev/null
     - apt-get -qy install flex bison autoconf make gcc >/dev/null
     - apt-get -qy install git curl wget ruby rubygems ruby-json >/dev/null # for the coverity script
     - apt list --installed 'lib*-dev'
+    - ./autogen.sh
     - ./.ci-coverity-scan-build.sh
diff --git a/.gitignore b/.gitignore
index 789b8df8..21ab3c16 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,59 +1,52 @@
 .DS_Store
-Makefile
+/Makefile
 *~
-*.o
-/bpf_filter.c
-capturetest
-can_set_rfmon_test
+/*.o
 CMakeCache.txt
 cmake_install.cmake
 CMakeFiles/
-config.h
-config.log
-config.cache
-config.status
-stamp-h
-stamp-h.in
-autom4te.cache/
-.devel
-filtertest
-findalldevstest
-opentest
-valgrindtest
-reactivatetest
-grammar.c
-grammar.h
-grammar.y
-libpcap.a
-libpcap.*.dylib
-libpcap.pc
-libpcap.sl
-libpcap.so
-libpcap.so.*
-libpcap-*.tar.gz
-net
-os-proto.h
-pcap-config
-pcap-filter.manmisc
-pcap-linktype.manmisc
-pcap-savefile.manfile
-pcap-tstamp.manmisc
-pcap.3pcap
-pcap_compile.3pcap
-pcap_datalink.3pcap
-pcap_dump_open.3pcap
-pcap_get_tstamp_precision.3pcap
-pcap_list_datalinks.3pcap
-pcap_list_tstamp_types.3pcap
-pcap_open_dead.3pcap
-pcap_open_offline.3pcap
-pcap_set_immediate_mode.3pcap
-pcap_set_tstamp_precision.3pcap
-pcap_set_tstamp_type.3pcap
-scanner.c
-scanner.c.bottom
-scanner.h
-selpolltest
+/config.h
+/config.h.in
+/config.log
+/config.cache
+/config.status
+/configure
+/stamp-h
+/stamp-h.in
+/autom4te.cache/
+/.devel
+/grammar.c
+/grammar.h
+/grammar.y
+/libpcap.a
+/libpcap.*.dylib
+/libpcap.pc
+/libpcap.sl
+/libpcap.so
+/libpcap.so.*
+/libpcap.shareda
+/libpcap-*.tar.gz
+/os-proto.h
+/pcap-config
+/pcap-filter.manmisc
+/pcap-linktype.manmisc
+/pcap-savefile.manfile
+/pcap-tstamp.manmisc
+/pcap.3pcap
+/pcap_compile.3pcap
+/pcap_datalink.3pcap
+/pcap_dump_open.3pcap
+/pcap_get_tstamp_precision.3pcap
+/pcap_list_datalinks.3pcap
+/pcap_list_tstamp_types.3pcap
+/pcap_open_dead.3pcap
+/pcap_open_offline.3pcap
+/pcap_set_immediate_mode.3pcap
+/pcap_set_tstamp_precision.3pcap
+/pcap_set_tstamp_type.3pcap
+/scanner.c
+/scanner.c.bottom
+/scanner.h
 *.log
 *.tlog
 *.obj
@@ -67,7 +60,7 @@ selpolltest
 *.vcxproj.user
 Debug/
 Release/
-msdos/.depend.dj
-msdos/bin2c.exe
-msdos/pkt_rx1.lst
-msdos/pkt_stub.inc
+/msdos/.depend.dj
+/msdos/bin2c.exe
+/msdos/pkt_rx1.lst
+/msdos/pkt_stub.inc
diff --git a/Android.bp b/Android.bp
index cb5827ee..2861363f 100644
--- a/Android.bp
+++ b/Android.bp
@@ -61,7 +61,6 @@ cc_library {
         "pcap-common.c",
         "pcap-linux.c",
         "pcap-netfilter-linux-android.c",
-        "pcap-usb-linux-common.c",
         "pcap-usb-linux.c",
         "pcap-util.c",
         "pcap.c",
diff --git a/CHANGES b/CHANGES
index c574a278..bf8701c8 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,168 @@
+Friday, August 30, 2024 / The Tcpdump Group
+  Summary for 1.10.5 libpcap release
+    Source code:
+      Spell WirelessHART details properly.
+      Mark pcap_vasprintf() as printf-like.
+      Finalize moving of bpf_filter.c. (GH #1166)
+      Remove an unneeded argument from gen_mcode6().
+      Don't do some Berkeley YACC workarounds with YACC releases not
+        requiring them.
+      Use correct data types rather than int in some cases.
+      Squelch compiler warning in grammar.c.
+      Fix findalldevtest compilation if IPv6 isn't enabled.
+      Rename helper routines for pcap modules to have names beginning with
+        pcapint_, to avoid namespace collisions for code linking statically
+        with libpcap.
+      Avoid casting hack for the Windows cleanup-on-exit routine.
+      Use %zu format for one case of printing a size_t.
+      Fix some Coverity errors.
+      Fix availabilities of some functions to match reality.
+      pcap: make the seconds and microseconds/nanoseconds fields unsigned.
+      Remove the unused pcap-rpcap-int.h header file.
+    Thread safety:
+      Make some static variables thread-local; fixes issue #1174.
+    Packet filtering:
+      Improve reporting of some invalid filter expressions.
+      Return an error from pcap_compile() if the scanner fails to initialize.
+      Optimizer fix from Archit Shah to recompute dominators after
+        moving code (#976); fixes #945 (although the resulting filter
+        isn't empty).
+      Optimizer fix from Archit Shah to mark value as unknown when store
+        of that value is deleted (#972); fixes #143, #434, #436, #437,
+        and #1076.
+    Linux:
+      Properly return warnings.
+      Don't use DLT_LINUX_SLL2 for anything other than the "any" device.
+      Avoid 32-bit unsigned integer overflow in USB captures.  Fixes
+        issues #1134 and #1205.
+      Fix a file descriptor leak.
+      Properly report warnings about unknown ARPHRD_ types.
+      Fix DLT_CAN_SOCKETCAN handling of CAN FD.
+      Add CAN XL support to DLT_CAN_SOCKETCAN.
+      Clean up the code that sets the "real" ("original") length for
+        isochronous USB transfers.
+      Avoid unnecessary blocking on recvmsg() in the Bluetooth monitor and
+        Bluetoth modules.
+    Solaris:
+      Handle BPF returning ESRCH for unknown devices.
+      List the "any" device if it's supported.
+      Report {non-existent zone}/{interface} errors appropriately.
+      Allow attaching to links owned by a non-global zone.  (Based on
+        pull request #1202.)
+      Fix AF_LINK handling on illumos.
+    macOS:
+      Redid the availability macros to be closer to what Apple's doing
+        in recent SDKs, including tagging pcap-namedb.h routines.
+      Fix the install name of the installed shared library to have a
+        full path when building with CMake.
+      Fix universal builds.
+    Haiku:
+      Convert the module to C.  Fixes issue #1114.
+      Address a few compiler warnings.  Fixes issue #1114.
+      Fix various build problems.  Fixes issue #1114.
+      Report non-existent devices correctly.
+      Fix handling of packet statistics.
+      Fix packet timestamping.
+      Fix packet filtering with low snaplen.
+      Improve connection status reporting.
+      Add support for promiscuous mode.
+      Detect DLTs and loopback capture support at run time.
+      Report IEEE 802.11 as PCAP_IF_WIRELESS.
+    Windows:
+      Fix internal handling of "not supported" error codes from NPF.
+      Work around a bug in Npcap 1.00 in case of driver version mismatch.
+      Don't call WSACleanup() when handling a failed WSAStartup().
+    BSD, macOS, AIX, Solaris 11, Linux:
+      Add a new error PCAP_ERROR_CAPTURE_NOTSUP, for use if a capture
+        mechanism is not present, in the hopes that, for example,
+        attempts to capture on Windows Services for Linux 1, in which
+        the NT kernel attempts to simulate Linux system calls but does
+        not support packet sockets, can get an error that better
+        indicates the underlying problem.
+    AirPcap:
+      Format an error message if we run out of memory.
+    nflog:
+      Fix count of dropped packets.
+      Make sure we don't overflow when rounding up the TLV length.
+    rpcap:
+      Handle routines removed in at least some OpenSSL libraries.
+      CVE-2023-7256: Clean up sock_initaddress() and its callers to avoid
+        double frees in some cases.
+      Don't define SOCKET ourselves; instead, define PCAP_SOCKET as int
+        on UN*Xes and as SOCKET on Windows.
+      CVE-2024-8006: Fix pcap_findalldevs_ex() not to crash if passed a
+        file:// URL with a path to a directory that cannot be opened.
+    Savefiles:
+      Handle DLT_/LINKTYPE_ mapping better, to handle some
+        OpenBSD-specific link types better.
+      Treat if_tsoffset as signed in pcapng files, as the spec says.
+      Don't try to fix the "real" length for isochronous USB
+        transfers if the number of USB descriptors is too large.
+      Reject pcap files where one of the reserved fields in the
+        "link-layer type plus other stuff" is non-zero.
+    Building and testing:
+      Add a configure option to help debugging (--enable-instrument-functions).
+      Improved tests and error reporting for uses of pkg-config, and
+        improve help message.
+      Fix Haiku build.
+      With CMake, install headers in CMAKE_INSTALL_INCLUDEDIR rather
+        than just include.
+      Build libpcap.a before building test programs.
+      Print address family numerically, as well as symbolically,
+        in findalldevstest.
+      Fail with suggestions, rather than failing over to no capture
+        support, if no capture mechanism was found.  Fixes issue #1016.
+      Don't indent comments in Make, as that may cause them not to be
+        recognized as comments.
+      Don't check for libssl if we aren't going to use it.
+      Better handle enabling and disabling of sanitizers.  Fixes issue
+        #1171.
+      CMakeLists.txt: Print "Symlinking: /some/path to ..." conditionally.
+      Evaluate CMAKE_INSTALL_PREFIX at install time.
+      cmake: Update the minimum required version to 2.8.12 (except Windows).
+      cmake: suppress CMP0042 OLD deprecated warning.
+      Makefile.in: Add the releasecheck target.
+      Cirrus CI: Add the "make releasecheck" command in the Linux task.
+      Makefile.in: Add the whitespacecheck target.
+      Cirrus CI: Run the "make whitespacecheck" command in the Linux task.
+      Autoconf: Update config.{guess,sub}, timestamps 2024-01-01.
+      Autoconf: Update the install-sh script to the 2020-11-14.01 version.
+      Compile with '-Wnull-pointer-subtraction',
+        '-Wunused-but-set-parameter', and '-Wunused-but-set-variable' in
+        devel mode if supported.
+      Don't ignore spaces between CMAKE_C_FLAGS and DPDK_C_FLAGS with
+        CMake.
+      Use noreturn and __format__ with XL C 7.0 and later.
+      Check for the same -W flags in autotools and CMake.
+      Autoconf: Add autogen.sh, remove configure and config.h.in and put
+        these generated files in the release tarball.
+      Autoconf: Get the size of a time_t.
+      Fix propagation of cc_werr_cflags() output.
+      Makefile.in(s): Fix the depend target.
+      mkdep: Exit with a non-zero status if a command fails.
+      Fix HCI_CHANNEL_MONITOR detection with musl libc.
+      Extend "make shellcheck" onto mkdep too.
+      Add initial support for building with TinyCC.
+      Address all known compiler warnings specific to illumos, Linux, NetBSD,
+        Solaris and Sun C; in CI expect warnings specific to TinyCC only.
+    Documentation:
+      Update and fix pcap-filter man page.
+      Add a README.haiku.md file.
+      Document pcap-config better.
+      Man page formatting and prose fixes.
+      Rename doc/README.Win32.md to doc/README.windows.md.
+      Update pcap-savefile man page to match the Internet-Draft for
+        pcap.
+      Fix CMake issues for target used by other projects.
+      Explain "any" device better in pcap_open_live(3PCAP).
+      Update INSTALL.md.
+      Note in man pages that errbuf arguments must point to an error
+        buffer.
+      Note that if pcap_findalldevs() fails it sets *alldevsp to NULL;
+        there's no devices list to free.
+      Explain "other addresses" in pcap_findalldevs(3PCAP).
+      Document pcap_lookupnet(3PCAP) a bit better.
+
 Friday, April 7, 2023 / The Tcpdump Group
   Summary for 1.10.4 libpcap release
     Source code:
@@ -58,7 +223,7 @@ Saturday, December 31, 2022 / The Tcpdump Group
         when reading a LINKTYPE_PFLOG file.
       Put CAN ID field in CAN pseudo-headers for LINUX_SLL2, as we do
         for LINUX_SLL.
-      Fix inorrectly-computed "real" length for isochronous USB
+      Fix incorrectly-computed "real" length for isochronous USB
         transfers when reading savefiles.
       Don't crash if pcap_can_set_rfmon() is called.
       Fix pcap_offline_read() loop.
@@ -139,7 +304,7 @@ Saturday, December 31, 2022 / The Tcpdump Group
       Return an error if the driver reports 0 timestamp modes supported.
       Close the ADAPTER handle for some errors in
         pcap_create_interface().
-      Get rid of old umaintained VS project files.
+      Get rid of old unmaintained VS project files.
       Fix deprecation warning for pcap_handle().
       Npcap is now at npcap.com, not npcap.org.
       Make sure "no such device" and "no permission to open device"
@@ -307,7 +472,7 @@ Tuesday, December 29, 2020
     Remove (unused) SITA support
     Capture file reading:
         Correctly handle pcapng captures with more than one IDB with a
-            snspshot length greater than the supported maximum
+            snapshot length greater than the supported maximum
     Capture file writing:
         Create the file in pcap_dump_open_append() if it doesn't exist
     Packet filtering:
@@ -421,7 +586,7 @@ Tuesday, December 29, 2020
             isn't called
         Fix compilation on Cygwin/MSYS
         Add pcap_handle(), and deprecate pcap_fileno()
-        Report PCAP_ERROR_NO_SUCH_DEVICE for a non-existent device
+        Report PCAP_ERROR_NO_SUCH_DEVICE for a nonexistent device
         Return an appropriate error message for device removed or
             device unusable due to a suspend/resume
         Report a warning for unknown NdisMedium types
@@ -503,7 +668,7 @@ Sunday, July 22, 2018
         Windows with WinPcap/Npcap (GitHub issue #824)
     Have pcap_dump_open_append() create the dump file if it doesn't
         exists (GitHub issue #247)
-    Fix the maxmum snapshot length for DLT_USBPCAP
+    Fix the maximum snapshot length for DLT_USBPCAP
     Use -fPIC when building for 64-bit SPARC on Linux (GitHub issue #837)
     Fix CMake 64-bit library installation directory on some Linux
         distributions
@@ -668,7 +833,7 @@ Wednesday Nov. 12, 2014 guy@alum.mit.edu/mcr@sandelman.ca
 
 Monday Aug. 12, 2014 guy@alum.mit.edu
   Summary for 1.6.2 libpcap release
-	Don't crash on filters testing a non-existent link-layer type
+	Don't crash on filters testing a nonexistent link-layer type
 	    field.
 	Fix sending in non-blocking mode on Linux with memory-mapped
 	    capture.
@@ -956,7 +1121,7 @@ Mon.    October 27, 2008.  ken@netfunctional.ca.  Summary for 1.0.0 libpcap rele
 	Autogenerate VERSION numbers better
 
 Mon.    September 10, 2007.  ken@xelerance.com.  Summary for 0.9.8 libpcap release
-        Change build process to put public libpcap headers into pcap subir
+        Change build process to put public libpcap headers into pcap subdir
         DLT: Add value for IPMI IPMB packets
         DLT: Add value for u10 Networks boards
         Require <net/pfvar.h> for pf definitions - allows reading of pflog formatted
@@ -1285,7 +1450,7 @@ v0.2.1 Sun Jul 14 03:02:26 PDT 1996
   (steve@research.oknet.com)
 
 - Fixed to handle raw ip addresses such as 0.0.0.1 without "left
-  justifing"
+  justifying"
 
 - Add "sca" keyword (for DEC cluster services) as suggested by Terry
   Kennedy (terry@spcvxa.spc.edu)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 58c51599..9012ef41 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -2,9 +2,26 @@ if(WIN32)
     #
     # We need 3.12 or later, so that we can set policy CMP0074; see
     # below.
+    #
     cmake_minimum_required(VERSION 3.12)
 else(WIN32)
-    cmake_minimum_required(VERSION 2.8.6)
+    #
+    # For now:
+    #
+    #  if this is a version of CMake less than 3.5, require only
+    #  2.8.12, just in case somebody is configuring with CMake
+    #  on a "long-term support" version # of some OS and that
+    #  version supplies an older version of CMake;
+    #
+    #  otherwise, require 3.5, so we don't get messages warning
+    #  that support for versions of CMake lower than 3.5 is
+    #  deprecated.
+    #
+    if(CMAKE_VERSION VERSION_LESS "3.5")
+        cmake_minimum_required(VERSION 2.8.12)
+    else()
+        cmake_minimum_required(VERSION 3.5)
+    endif()
 endif(WIN32)
 
 #
@@ -12,8 +29,15 @@ endif(WIN32)
 # neither do we with autotools; don't do so with CMake, either, and
 # suppress warnings about that.
 #
+# Setting CMAKE_MACOSX_RPATH to FALSE uses the old behavior,
+# but removes the POLICY CMP0042 OLD deprecated warning.
+# See https://cmake.org/cmake/help/latest/policy/CMP0042.html
+#
+if (NOT DEFINED CMAKE_MACOSX_RPATH)
+    set(CMAKE_MACOSX_RPATH FALSE)
+endif()
 if(POLICY CMP0042)
-    cmake_policy(SET CMP0042 OLD)
+    cmake_policy(SET CMP0042 NEW)
 endif()
 
 #
@@ -47,20 +71,52 @@ endif()
 set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules)
 
 #
-# We only need a C++ compiler for Haiku; all code except for its
-# pcap module is in C.
+# We explicitly indicate what languages are used in libpcap to avoid
+# checking for a C++ compiler.
+#
+# One reason to avoid that check is that there's no need to waste
+# configuration time performing it.
+#
+# Another reason is that:
+#
+# CMake will try to determine the sizes of some data types, including
+# void *, early in the process of configuration; apparently, it's done
+# as part of processing the project() command.
 #
-# We do that by specifying just C in the project() call and, after
-# that finishes, checking for Haiku and, if we're building for
-# Haiku, use enable_language() to check for C++.  This means that
-# we don't require a C++ compiler on platforms other than Haiku.
+# At least as of CMake 2.8.6, it does so by checking the size of
+# "void *" in C, setting CMAKE_C_SIZEOF_DATA_PTR based on that,
+# setting CMAKE_SIZEOF_VOID_P to that, and then checking the size
+# of "void *" in C++, setting CMAKE_CXX_SIZEOF_DATA_PTR based on
+# that, and then setting CMAKE_SIZEOF_VOID_P to *that*.
 #
-# CMAKE_SYSTEM_NAME is set by project(), so we can't do this by
-# testing CMAKE_SYSTEM_NAME and then passing different language
-# lists to project() based on the system.
+# The compile tests include whatever C flags may have been provided
+# to CMake in the CFLAGS and CXXFLAGS environment variables.
+#
+# If you set an architecture flag such as -m32 or -m64 in CFLAGS
+# but *not* in CXXFLAGS, the size for C++ will win, and hilarity
+# will ensue.
+#
+# Or if, at least on Solaris, you have a newer version of GCC
+# installed, but *not* a newer version of G++, and you have Oracle
+# Studio installed, it will find GCC, which will default to building
+# 64-bit, and Oracle Studio's C++ compiler, which will default to
+# building 32-bit, the size for C++ will win, and, again, hilarity
+# will ensue.
 #
 project(pcap C)
 
+#
+# Setting CMAKE_MACOSX_RPATH to FALSE causes the installed
+# libpcap.A.dylib to have just libpcap.A.dylib as the install
+# name;  Apple built libpcap with an install_name of /usr/lib/libpcap.A.dylib
+# (back when they still shipped individual system dylibs rather than
+# shipping a pre-built shared library cache, at least), and we do the
+# same with autotools; do the same with CMake.
+#
+if (NOT DEFINED CMAKE_INSTALL_NAME_DIR)
+    set(CMAKE_INSTALL_NAME_DIR ${CMAKE_INSTALL_PREFIX}/lib)
+endif()
+
 #
 # For getting raw lists of --libs and --libs --static information from a
 # pkg-config module.
@@ -190,55 +246,6 @@ macro(get_link_info_from_library_path  _library_prefix _library_name)
   endif()
 endmacro()
 
-if(CMAKE_SYSTEM_NAME STREQUAL "Haiku")
-    enable_language(CXX)
-
-    #
-    # OK, this is a royal pain.
-    #
-    # CMake will try to determine the sizes of some data types, including
-    # void *, early in the process of configuration; apparently, it's done
-    # as part of processing the project() command.
-    #
-    # At least as of CMake 2.8.6, it does so by checking the size of
-    # "void *" in C, setting CMAKE_C_SIZEOF_DATA_PTR based on that,
-    # setting CMAKE_SIZEOF_VOID_P to that, and then checking the size
-    # of "void *" in C++, setting CMAKE_CXX_SIZEOF_DATA_PTR based on
-    # that, and then setting CMAKE_SIZEOF_VOID_P to *that*.
-    #
-    # The compile tests include whatever C flags may have been provided
-    # to CMake in the CFLAGS and CXXFLAGS environment variables.
-    #
-    # If you set an architecture flag such as -m32 or -m64 in CFLAGS
-    # but *not* in CXXFLAGS, the size for C++ will win, and hilarity
-    # will ensue.
-    #
-    # Or if, at least on Solaris, you have a newer version of GCC
-    # installed, but *not* a newer version of G++, and you have Oracle
-    # Studio installed, it will find GCC, which will default to building
-    # 64-bit, and Oracle Studio's C++ compiler, which will default to
-    # building 32-bit, the size for C++ will win, and, again, hilarity
-    # will ensue.
-    #
-    # So we make sure both languages have the same pointer sizes with
-    # the flags they're given; if they don't, it means that the
-    # compilers for the languages will, with those flags, not produce
-    # code that can be linked together.
-    #
-    # This is unlikely to happen on Haiku, but it *has* happened on
-    # Solaris; we do this for future-proofing, in case we ever need
-    # C++ on a platform where that can happen.
-    #
-    if(NOT ${CMAKE_C_SIZEOF_DATA_PTR} EQUAL ${CMAKE_CXX_SIZEOF_DATA_PTR})
-         message(FATAL_ERROR
-"C compiler ${CMAKE_C_COMPILER} produces code with \
-${CMAKE_C_SIZEOF_DATA_PTR}-byte pointers while C++ compiler \
-${CMAKE_CXX_COMPILER} produces code with \
-${CMAKE_CXX_SIZEOF_DATA_PTR}-byte pointers. \
-This prevents code in these languages from being combined.")
-    endif()
-endif()
-
 #
 # Show the bit width for which we're compiling.
 # This can help debug problems if you're dealing with a compiler that
@@ -256,7 +263,7 @@ endif()
 # Solaris pkg-config is annoying.  For at least one package (D-Bus, I'm
 # looking at *you*!), there are separate include files for 32-bit and
 # 64-bit builds (I guess using "unsigned long long" as a 64-bit integer
-# type on a 64-bit build is like crossing the beams or soething), and
+# type on a 64-bit build is like crossing the beams or something), and
 # there are two separate .pc files, so if we're doing a 32-bit build we
 # should make sure we look in /usr/lib/pkgconfig for .pc files and if
 # we're doing a 64-bit build we should make sure we look in
@@ -563,8 +570,6 @@ set(PACKAGE_STRING "${LIBRARY_NAME} ${PACKAGE_VERSION}")
 # Project settings
 ######################################
 
-add_definitions(-DHAVE_CONFIG_H)
-
 include_directories(
     ${CMAKE_CURRENT_BINARY_DIR}
     ${pcap_SOURCE_DIR}
@@ -615,9 +620,7 @@ if(USE_STATIC_RT)
         if(MSVC)
             foreach(RT_FLAG
                 CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE
-                CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO
-                CMAKE_CXX_FLAGS CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_RELEASE
-                CMAKE_CXX_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_RELWITHDEBINFO)
+                CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO)
                 string(REGEX REPLACE "/MD" "/MT" ${RT_FLAG} "${${RT_FLAG}}")
             endforeach(RT_FLAG)
         elseif(MINGW)
@@ -699,7 +702,6 @@ main(void)
 #
 # Now check for various system functions.
 #
-check_function_exists(strerror HAVE_STRERROR)
 check_function_exists(strerror_r HAVE_STRERROR_R)
 if(HAVE_STRERROR_R)
     #
@@ -755,29 +757,26 @@ if(NOT WIN32)
 endif()
 
 #
-# These tests are for network applications that need socket functions
-# and getaddrinfo()/getnameinfo()-ish functions.  We now require
-# getaddrinfo() and getnameinfo().  On UN*X systems, we also prefer
-# versions of recvmsg() that conform to the Single UNIX Specification,
-# so that we can check whether a datagram received with recvmsg() was
-# truncated when received due to the buffer being too small.
+# Look for various networking-related libraries that we may need.
 #
-# On Windows, getaddrinfo() is in the ws2_32 library.
-
-# On most UN*X systems, they're available in the system library.
+# We need getaddrinfo() to translate host names in filters to IP
+# addresses. We use getaddrinfo() because we want a portable
+# thread-safe way of getting information for a host name or port;
+# there exist _r versions of gethostbyname() and getservbyname() on
+# some platforms, but not on all platforms.
 #
-# Under Solaris, we need to link with libsocket and libnsl to get
-# getaddrinfo() and getnameinfo() and, if we have libxnet, we need to
-# link with libxnet before libsocket to get a version of recvmsg()
-# that conforms to the Single UNIX Specification.
+# We may also need socket() and other socket functions to support:
 #
-# We use getaddrinfo() because we want a portable thread-safe way
-# of getting information for a host name or port; there exist _r
-# versions of gethostbyname() and getservbyname() on some platforms,
-# but not on all platforms.
+#   Local packet capture with capture mechanisms that use sockets.
 #
-# NOTE: if you hand check_library_exists as its last argument a variable
-# that's been set, it skips the test, so we need different variables.
+#   Local capture device enumeration if a socket call is needed to
+#   enumerate devices or get device attributes.
+#
+#   Packet capture from services that put captured packets on the
+#   network, such as rpcap servers.
+#
+# We may also need getnameinfo() for packet capture from services
+# that put packets on the network.
 #
 set(PCAP_LINK_LIBRARIES "")
 set(LIBS "")
@@ -786,9 +785,13 @@ set(REQUIRES_PRIVATE "")
 set(LIBS_PRIVATE "")
 include(CheckLibraryExists)
 if(WIN32)
+    #
+    # Windows.
     #
     # We need winsock2.h and ws2tcpip.h.
     #
+    # On Windows, getaddrinfo() is in the ws2_32 library.
+    #
     cmake_push_check_state()
     set(CMAKE_REQUIRED_LIBRARIES ws2_32)
     check_symbol_exists(getaddrinfo "winsock2.h;ws2tcpip.h" LIBWS2_32_HAS_GETADDRINFO)
@@ -800,16 +803,28 @@ if(WIN32)
     endif(LIBWS2_32_HAS_GETADDRINFO)
 else(WIN32)
     #
-    # UN*X.  First try the system libraries, then try the libraries
-    # for Solaris and possibly other systems that picked up the
-    # System V library split.
+    # UN*X.
+    #
+    # Most UN*Xes have getaddrinfo(), and the other routines we may
+    # need, in the default searched libraries (e.g., libc).
+    # Check there first.
+    #
+    # NOTE: if you hand check_library_exists as its last argument a
+    # variable that's been set, it skips the test, so we need different
+    # variables for different libraries.
     #
     check_function_exists(getaddrinfo STDLIBS_HAVE_GETADDRINFO)
     if(NOT STDLIBS_HAVE_GETADDRINFO)
-        #
-        # Not found in the standard system libraries.
-        # Try libsocket, which requires libnsl.
-        #
+	#
+	# Not found in the standard system libraries.
+	#
+	# In some versions of Solaris, we need to link with libsocket
+	# and libnsl, so check in libsocket and also link with liblnsl
+	# when doing this test.
+	#
+	# Linking with libsocket and libnsl will find all the routines
+	# we need.
+	#
         cmake_push_check_state()
         set(CMAKE_REQUIRED_LIBRARIES nsl)
         check_library_exists(socket getaddrinfo "" LIBSOCKET_HAS_GETADDRINFO)
@@ -823,10 +838,17 @@ else(WIN32)
             set(LIBS_STATIC "-lsocket -lnsl ${LIBS_STATIC}")
             set(LIBS_PRIVATE "-lsocket -lnsl ${LIBS_PRIVATE}")
         else(LIBSOCKET_HAS_GETADDRINFO)
+	    #
+	    # Not found in libsocket; test for it in libnetwork, which
+	    # is where it is in Haiku.
+	    #
+	    # Linking with libnetwork will find all the routines we
+	    # need.
+	    #
             check_library_exists(network getaddrinfo "" LIBNETWORK_HAS_GETADDRINFO)
             if(LIBNETWORK_HAS_GETADDRINFO)
                 #
-                # OK, we found it in libnetwork (Haiku).
+		# OK, we found it in libnetwork.
                 #
                 set(PCAP_LINK_LIBRARIES network ${PCAP_LINK_LIBRARIES})
                 set(LIBS "-lnetwork ${LIBS}")
@@ -840,17 +862,32 @@ else(WIN32)
             endif(LIBNETWORK_HAS_GETADDRINFO)
         endif(LIBSOCKET_HAS_GETADDRINFO)
 
-        #
-        # OK, do we have recvmsg() in libxnet?
-        # We also link with libsocket and libnsl.
-        #
+	#
+	# We require a version of recvmsg() that conforms to the Single
+	# UNIX Specification, so that we can check whether a datagram
+	# received with recvmsg() was truncated when received due to the
+	# buffer being too small.
+	#
+	# On most systems, the version of recvmsg() in the libraries
+	# found above conforms to the SUS.
+	#
+	# On at least some versions of Solaris, it does not conform to
+	# the SUS, and we need the version in libxnet, which does
+	# conform.
+	#
+	# Check whether libxnet exists and has a version of recvmsg();
+	# if it does, link with libxnet before we link with libsocket,
+	# to get that version.
+	#
+	# This test also links with libsocket and libnsl.
+	#
         cmake_push_check_state()
         set(CMAKE_REQUIRED_LIBRARIES socket nsl)
         check_library_exists(xnet recvmsg "" LIBXNET_HAS_RECVMSG)
         cmake_pop_check_state()
         if(LIBXNET_HAS_RECVMSG)
             #
-            # Yes - link with it as well.
+	    # libxnet has recvmsg(); link with it as well.
             #
             set(PCAP_LINK_LIBRARIES xnet ${PCAP_LINK_LIBRARIES})
             set(LIBSC "-lxnet ${LIBS_LIBS}")
@@ -859,7 +896,9 @@ else(WIN32)
         endif(LIBXNET_HAS_RECVMSG)
     endif(NOT STDLIBS_HAVE_GETADDRINFO)
 
-    # DLPI needs putmsg under HPUX so test for -lstr while we're at it
+    #
+    # DLPI needs putmsg under HP-UX, so test for -lstr while we're at it.
+    #
     check_function_exists(putmsg STDLIBS_HAVE_PUTMSG)
     if(NOT STDLIBS_HAVE_PUTMSG)
         check_library_exists(str putmsg "" LIBSTR_HAS_PUTMSG)
@@ -1231,7 +1270,6 @@ endif(NOT WIN32)
 if(ENABLE_PROFILING)
     if(NOT MSVC)
         set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pg")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pg")
     endif()
 endif()
 
@@ -1264,7 +1302,7 @@ endif()
 #
 # Test if the each of the sanitizers in the ENABLE_SANITIZERS list are
 # supported by the compiler, and, if so, adds the appropriate flags to
-# CMAKE_C_FLAGS, CMAKE_CXX_FLAGS, and SANITIZER_FLAGS.  If not, it fails.
+# CMAKE_C_FLAGS, and SANITIZER_FLAGS.  If not, it fails.
 #
 # Do this last, in the hope that it will prevent configuration on Linux
 # from somehow deciding it doesn't need -lpthread when building rpcapd
@@ -1272,17 +1310,25 @@ endif()
 # obvious CMake debugging flag reveals, it doesn't realize that if we
 # turn sanitizer stuff on).
 #
-set(SANITIZER_FLAGS "")
-foreach(sanitizer IN LISTS ENABLE_SANITIZERS)
+# Note: apparently, some projects have decided that ENABLE_SANITIZERS
+# is a Boolean, with OFF meaning "no sanitizers" and ON meaning "all
+# sanitizers".  Whoever decided that didn't put it up as a common
+# CMake idiom, as far as I can tell; we only discovered this because
+# JetBrains' CLion "helpfully" appears to pass -DENABLE_SANITIZERS=OFF
+# to CMake by default, which causes CMake to fail on libpcap.  Thanks!
+#
+# We thus also allow a setting of OFF to mean "no sanitizers" and ON to
+# mean "all supported sanitizers that we know about and that can all
+# be used together".
+#
+macro(test_sanitizer _sanitizer _sanitizer_flag)
+    message(STATUS "Checking sanitizer ${_sanitizer}")
+    set(sanitizer_variable "sanitize_${_sanitizer}")
     # Set -Werror to catch "argument unused during compilation" warnings
-
-    message(STATUS "Checking sanitizer ${sanitizer}")
-    set(sanitizer_variable "sanitize_${sanitizer}")
-    set(CMAKE_REQUIRED_FLAGS "-Werror -fsanitize=${sanitizer}")
-    check_c_compiler_flag("-fsanitize=${sanitizer}" ${sanitizer_variable})
+    set(CMAKE_REQUIRED_FLAGS "-Werror -fsanitize=${_sanitizer}")
+    check_c_compiler_flag("-fsanitize=${_sanitizer}" ${sanitizer_variable})
     if(${${sanitizer_variable}})
-        set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fsanitize=${sanitizer}")
-        message(STATUS "${sanitizer} sanitizer supported using -fsanitizer=${sanitizer}")
+        set(${_sanitizer_flag} "-fsanitize=${_sanitizer}")
     else()
         #
         # Try the versions supported prior to Clang 3.2.
@@ -1291,119 +1337,397 @@ foreach(sanitizer IN LISTS ENABLE_SANITIZERS)
         # Otherwise, give up.
         #
         set(sanitizer_variable "OLD_${sanitizer_variable}")
-        if ("${sanitizer}" STREQUAL "address")
+        if ("${_sanitizer}" STREQUAL "address")
             set(CMAKE_REQUIRED_FLAGS "-Werror -fsanitize-address")
             check_c_compiler_flag("-fsanitize-address" ${sanitizer_variable})
             if(${${sanitizer_variable}})
-                set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fsanitize-address")
-                message(STATUS "${sanitizer} sanitizer supported using -fsanitize-address")
-            else()
-                message(FATAL_ERROR "${sanitizer} isn't a supported sanitizer")
+                set(${_sanitizer_flag} "-fsanitize-address")
             endif()
-        elseif("${sanitizer}" STREQUAL "undefined")
+        elseif("${_sanitizer}" STREQUAL "undefined")
             set(CMAKE_REQUIRED_FLAGS "-Werror -fcatch-undefined-behavior")
             check_c_compiler_flag("-fcatch-undefined-behavior" ${sanitizer_variable})
             if(${${sanitizer_variable}})
-                set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fcatch-undefined-behavior")
-                message(STATUS "${sanitizer} sanitizer supported using catch-undefined-behavior")
-            else()
-                message(FATAL_ERROR "${sanitizer} isn't a supported sanitizer")
+                set(${_sanitizer_flag} "-fcatch-undefined-behavior")
             endif()
-        else()
-            message(FATAL_ERROR "${sanitizer} isn't a supported sanitizer")
         endif()
     endif()
-
     unset(CMAKE_REQUIRED_FLAGS)
-endforeach()
+endmacro(test_sanitizer)
+
+set(SANITIZER_FLAGS "")
+if("${ENABLE_SANITIZERS}")
+    #
+    # This appears to indicate that ENABLE_SANITIZERS was set to a
+    # string value that is "one of the true constants", meaning
+    # "1, ON, YES, TRUE, Y, or a non-zero number".
+    #
+    # It does not appear to happen for other settings, including
+    # setting it to a list of one or more sanitizers.
+    #
+    # This setting means "enable all sanitizers that the compiler
+    # supports".
+    #
+    foreach(sanitizer "address" "undefined")
+        unset(SANITIZER_FLAG)
+        test_sanitizer(${sanitizer} SANITIZER_FLAG)
+        if(SANITIZER_FLAG)
+            message(STATUS "${sanitizer} sanitizer supported using ${SANITIZER_FLAG}")
+            set(SANITIZER_FLAGS "${SANITIZER_FLAGS} ${SANITIZER_FLAG}")
+        else()
+            message(STATUS "${sanitizer} isn't a supported sanitizer")
+        endif()
+    endforeach()
+    if("${SANITIZER_FLAGS}" STREQUAL "")
+        message(FATAL_ERROR "No supported sanitizers found")
+    endif()
+else()
+    #
+    # This appears to indicate that ENABLE_SANITIZERS was either:
+    #
+    #   not set;
+    #   set to a set to a string value that is not "one of the true
+    #   constants", meaning "1, ON, YES, TRUE, Y, or a non-zero number".
+    #
+    # The latter includes setting it to "one of the false constants",
+    # meaning the string "is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND,
+    # the empty string, or ends in the suffix -NOTFOUND."
+    #
+    # It also includes setting it to a list of one or more sanitizers.
+    #
+    # We want to treat "not set" and "set to one of the false constants"
+    # as meaning "do not enable any sanitizers".
+    #
+    # We want to treat "set to a list of one or more sanitizers" as
+    # meaning "enable all the sanitizers in the list".
+    #
+    # This requires that we distinguish between those two cases.
+    #
+    if(ENABLE_SANITIZERS)
+        #
+        # This appears to indicate that ENABLE_SANITIZERS was set to
+        # a string value that is "not one of the false constants".
+        #
+        # We already know it's "not one of the true constants", so
+        # we treat it as a list of sanitizers.
+        #
+        foreach(sanitizer IN LISTS ENABLE_SANITIZERS)
+            unset(SANITIZER_FLAG)
+            test_sanitizer(${sanitizer} SANITIZER_FLAG)
+            if(SANITIZER_FLAG)
+                message(STATUS "${sanitizer} sanitizer supported using ${SANITIZER_FLAG}")
+                set(SANITIZER_FLAGS "${SANITIZER_FLAGS} ${SANITIZER_FLAG}")
+            else()
+                message(FATAL_ERROR "${sanitizer} isn't a supported sanitizer")
+            endif()
+        endforeach()
+    else()
+        #
+        # This appears to indicate that ENABLE_SANITIZERS was either:
+        #
+        #   not set;
+        #   set to a value that's "one of the false constants";
+        #
+        # so we don't enable any sanitizers.
+        #
+        message(STATUS "Not enabling sanitizers")
+    endif()
+endif()
 
 if(NOT "${SANITIZER_FLAGS}" STREQUAL "")
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O1 -g ${SANITIZER_FLAGS} -fno-omit-frame-pointer -fno-optimize-sibling-calls")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O1 -g ${SANITIZER_FLAGS} -fno-omit-frame-pointer -fno-optimize-sibling-calls")
 endif()
 
-#
-# OpenSSL/libressl.
-#
-find_package(OpenSSL)
-if(OPENSSL_FOUND)
+if(ENABLE_REMOTE)
   #
-  # We have OpenSSL.
+  # OpenSSL/libressl.
   #
-  include_directories(SYSTEM ${OPENSSL_INCLUDE_DIR})
-  set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${OPENSSL_LIBRARIES})
+  find_package(OpenSSL)
+  if(OPENSSL_FOUND)
+    #
+    # We have OpenSSL.
+    #
+    include_directories(SYSTEM ${OPENSSL_INCLUDE_DIR})
+    set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${OPENSSL_LIBRARIES})
 
-  #
-  # The find_package() module CMake provides for OpenSSL uses does not
-  # give us a defined indication of whether it found OpenSSL with
-  # pkg-config or not.  We need to know that as, if it was found with
-  # pkg-config, we should set the Requires.private value in libpcap.pc
-  # to include its package name, openssl, otherwise we should add the
-  # names for the static libraries to Libs.private.
-  #
-  # On UN*X, FindOpenSSL happens to use pkg-config to find OpenSSL, but
-  # it doesn't appear to be documented as doing so; therefore, we don't
-  # assume that, if we got here, we have pkg-config.
-  #
-  # So we use pkg_get_link_info() to run pkg-config ourselves, both
-  # because FindOpenSSL doesn't set the OPENSSL_LDFLAGS or
-  # OPENSSL_STATIC_LDFLAGS variables and because, for reasons explained
-  # in the comment before the pkg_get_link_info() macro, even if it did,
-  # it wouldn't be what we want anyway.
-  #
-  if (PKG_CONFIG_EXECUTABLE)
-    pkg_get_link_info(OPENSSL openssl)
-    if (OPENSSL_FOUND_WITH_PKG_CONFIG)
-      #
-      # pkg-config failed; assume that means that there is no openssl
-      # package for it to find.  Just add OPENSSL_LIBRARIES to
-      # LIBS_PRIVATE AND LIBS_STATIC, as that's the
-      # best we can do. XXX - need list of -l and -L flags to add....
-      #
-      set(LIBS "${LIBS} ${OPENSSL_LIBS}")
-      set(LIBS_STATIC "${LIBS_STATIC} ${OPENSSL_LIBS_STATIC}")
-      set(REQUIRES_PRIVATE "${REQUIRES_PRIVATE} ${OPENSSL_PACKAGE_NAME}")
+    #
+    # The find_package() module CMake provides for OpenSSL uses does not
+    # give us a defined indication of whether it found OpenSSL with
+    # pkg-config or not.  We need to know that as, if it was found with
+    # pkg-config, we should set the Requires.private value in libpcap.pc
+    # to include its package name, openssl, otherwise we should add the
+    # names for the static libraries to Libs.private.
+    #
+    # On UN*X, FindOpenSSL happens to use pkg-config to find OpenSSL, but
+    # it doesn't appear to be documented as doing so; therefore, we don't
+    # assume that, if we got here, we have pkg-config.
+    #
+    # So we use pkg_get_link_info() to run pkg-config ourselves, both
+    # because FindOpenSSL doesn't set the OPENSSL_LDFLAGS or
+    # OPENSSL_STATIC_LDFLAGS variables and because, for reasons explained
+    # in the comment before the pkg_get_link_info() macro, even if it did,
+    # it wouldn't be what we want anyway.
+    #
+    if (PKG_CONFIG_EXECUTABLE)
+      pkg_get_link_info(OPENSSL openssl)
+      if (OPENSSL_FOUND_WITH_PKG_CONFIG)
+        #
+        # pkg-config failed; assume that means that there is no openssl
+        # package for it to find.  Just add OPENSSL_LIBRARIES to
+        # LIBS_PRIVATE AND LIBS_STATIC, as that's the
+        # best we can do. XXX - need list of -l and -L flags to add....
+        #
+        set(LIBS "${LIBS} ${OPENSSL_LIBS}")
+        set(LIBS_STATIC "${LIBS_STATIC} ${OPENSSL_LIBS_STATIC}")
+        set(REQUIRES_PRIVATE "${REQUIRES_PRIVATE} ${OPENSSL_PACKAGE_NAME}")
+      endif()
+    else()
+      # Get it from OPENSSL_LIBRARIES
+      foreach(_lib IN LISTS OPENSSL_LIBRARIES)
+        #
+        # Get the directory in which the library resides.
+        #
+        get_filename_component(_lib_directory "${_lib}" DIRECTORY)
+
+        #
+        # Is the library directory in CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES?
+        # (See comment above on why we use that.)
+        #
+        list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${_lib_directory}" _lib_index)
+        if(_lib_index EQUAL -1)
+          #
+          # No, so add a -L flag to get the linker to search in that
+          # directory.
+          #
+          set(LIBS "${LIBS} -L${_lib_directory}")
+          set(LIBS_STATIC "${LIBS_STATIC} -L${_lib_directory}")
+          set(LIBS_PRIVATE "${LIBS_PRIVATE} -L${_lib_directory}")
+        endif()
+
+        #
+        # Get the file name of the library, without the extension.
+        #
+        get_filename_component(_lib_filename "${_lib}" NAME_WE)
+
+        #
+        # Strip off the "lib" prefix to get the library name, and
+        # add a -l flag based on that.
+        #
+        string(REGEX REPLACE "^lib" "" _library_name "${_lib_filename}")
+        set(LIBS "${LIBS} -l${_library_name}")
+        set(LIBS_STATIC "${LIBS_STATIC} -l${_library_name}")
+        set(LIBS_PRIVATE "${LIBS_PRIVATE} -l${_library_name}")
+      endforeach()
     endif()
-  else()
-    # Get it from OPENSSL_LIBRARIES
-    foreach(_lib IN LISTS OPENSSL_LIBRARIES)
-      #
-      # Get the directory in which the library resides.
-      #
-      get_filename_component(_lib_directory "${_lib}" DIRECTORY)
+    set(HAVE_OPENSSL YES)
+  endif(OPENSSL_FOUND)
+endif(ENABLE_REMOTE)
 
-      #
-      # Is the library directory in CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES?
-      # (See comment above on why we use that.)
-      #
-      list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${_lib_directory}" _lib_index)
-      if(_lib_index EQUAL -1)
+#
+# On macOS, build libpcap for the appropriate architectures, if
+# CMAKE_OSX_ARCHITECTURES isn't set (if it is, let that control
+# the architectures for which to build it).
+#
+if(APPLE AND "${CMAKE_OSX_ARCHITECTURES}" STREQUAL "")
+    #
+    # Get the major version of Darwin.
+    #
+    string(REGEX MATCH "^([0-9]+)" SYSTEM_VERSION_MAJOR "${CMAKE_SYSTEM_VERSION}")
+
+    if(SYSTEM_VERSION_MAJOR LESS 8)
         #
-        # No, so add a -L flag to get the linker to search in that
-        # directory.
+        # Pre-Tiger.
         #
-        set(LIBS "${LIBS} -L${_lib_directory}")
-        set(LIBS_STATIC "${LIBS_STATIC} -L${_lib_directory}")
-        set(LIBS_PRIVATE "${LIBS_PRIVATE} -L${_lib_directory}")
-      endif()
+        # Build libraries and executables only for 32-bit PowerPC, as
+        # that's all that is supported.
+        #
+        set(OSX_LIBRARY_ARCHITECTURES "ppc")
+        set(OSX_EXECUTABLE_ARCHITECTURES "ppc")
+    elseif(SYSTEM_VERSION_MAJOR EQUAL 8)
+        #
+        # Tiger.  Is this prior to, or with, Intel support?
+        #
+        # Get the minor version of Darwin.
+        #
+        string(REPLACE "${SYSTEM_VERSION_MAJOR}." "" SYSTEM_MINOR_AND_PATCH_VERSION ${CMAKE_SYSTEM_VERSION})
+        string(REGEX MATCH "^([0-9]+)" SYSTEM_VERSION_MINOR "${SYSTEM_MINOR_AND_PATCH_VERSION}")
+        if(SYSTEM_VERSION_MINOR LESS 4)
+            #
+            # Prior to Intel support.
+            #
+            # Build libraries and executables for 32-bit PowerPC and
+            # 64-bit PowerPC, with 32-bit PowerPC first, as those
+            # are both supported.  (I'm guessing that's what Apple
+            # does.)
+            #
+            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64")
+            set(OSX_EXECUTABLE_ARCHITECTURES "ppc;ppc64")
+        elseif(SYSTEM_VERSION_MINOR LESS 7)
+            #
+            # With Intel support but prior to x86-64 support.
+            #
+            # Build for 32-bit PowerPC, 64-bit PowerPC, and 32-bit x86,
+            # with 32-bit PowerPC first, as those are all supported.
+            # (I'm guessing that's what Apple does.)
+            #
+            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386")
+            set(OSX_EXECUTABLE_ARCHITECTURES "ppc;ppc64;i386")
+        else()
+            #
+            # With Intel support including x86-64 support.
+            #
+            # Build for 32-bit PowerPC, 64-bit PowerPC, 32-bit x86,
+            # and x86-64, with 32-bit PowerPC first, as those are
+            # all supported.  (I'm guessing that's what Apple does.)
+            #
+            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386;x86_64")
+            set(OSX_EXECUTABLE_ARCHITECTURES "ppc;ppc64;i386;x86_64")
+        endif()
+    elseif(SYSTEM_VERSION_MAJOR EQUAL 9)
+        #
+        # Leopard.
+        #
+        # Build libraries and executables for 32-bit PowerPC, 64-bit
+        # PowerPC, 32-bit x86, and x86-64, with 32-bit PowerPC
+        # first, as those are all supported.  (That's what Apple
+        # does.)
+        #
+        set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386;x86_64")
+        set(OSX_EXECUTABLE_ARCHITECTURES "ppc;ppc64;i386;x86_64")
+    elseif(SYSTEM_VERSION_MAJOR EQUAL 10)
+        #
+        # Snow Leopard.
+        #
+        # Build libraries for x86-64, 32-bit x86, and 32-bit PowerPC,
+        # with x86-64 first, because 32-bit PowerPC executables are
+        # supported with Rosetta.  (That's what Apple does, even though
+        # Snow Leopard doesn't run on PPC, so PPC libpcap runs under
+        # Rosetta, and Rosetta doesn't support BPF ioctls, so PPC
+        # executables can't do live captures.)
+        #
+        set(OSX_LIBRARY_ARCHITECTURES "x86_64;i386;ppc")
 
-      #
-      # Get the file name of the library, without the extension.
-      #
-      get_filename_component(_lib_filename "${_lib}" NAME_WE)
+        #
+        # Build executables only for 32-bit x86 and 64-bit x86, as PPC
+        # machines are no longer supported.
+        #
+        set(OSX_EXECUTABLE_ARCHITECTURES "x86_64;i386")
+    elseif(SYSTEM_VERSION_MAJOR GREATER 10 AND SYSTEM_VERSION_MAJOR LESS 19)
+        #
+        # Post-Snow Leopard, pre-Catalina.
+        #
+        # Build libraries for 64-bit x86 and 32-bit x86, with 64-bit x86
+        # first, as PPC machines are no longer supported, but 32-bit
+        # x86 executables are.  (That's what Apple does.)
+        #
+        # First, check whether we're building with OpenSSL.
+        # If so, don't bother trying to build fat.
+        #
+        if(HAVE_OPENSSL)
+          set(X86_32_BIT_SUPPORTED NO)
+          set(OSX_LIBRARY_ARCHITECTURES "x86_64")
+          set(OSX_EXECUTABLE_ARCHITECTURES "x86_64")
+          message(WARNING "We're assuming the OpenSSL libraries are 64-bit only, so we're not compiling for 32-bit x86")
+        else()
+          #
+          # Now, check whether we *can* build for i386.
+          #
+          cmake_push_check_state()
+          set(CMAKE_REQUIRED_FLAGS "-arch i386")
+          check_c_source_compiles(
+"int
+main(void)
+{
+    return 0;
+}
+"
+                   X86_32_BIT_SUPPORTED)
+          cmake_pop_check_state()
+          if(X86_32_BIT_SUPPORTED)
+              set(OSX_LIBRARY_ARCHITECTURES "x86_64;i386")
+          else()
+              set(OSX_LIBRARY_ARCHITECTURES "x86_64")
+              #
+              # We can't build fat; suggest that the user install the
+              # /usr/include headers if they want to build fat.
+              #
+              if(SYSTEM_VERSION_MAJOR LESS 18)
+                  #
+                  # Pre-Mojave; the command-line tools should be sufficient to
+                  # enable 32-bit x86 builds.
+                  #
+                  message(WARNING "Compiling for 32-bit x86 gives an error; try installing the command-line tools")
+              else()
+                  message(WARNING "Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package")
+              endif()
+          endif()
+        endif()
 
-      #
-      # Strip off the "lib" prefix to get the library name, and
-      # add a -l flag based on that.
-      #
-      string(REGEX REPLACE "^lib" "" _library_name "${_lib_filename}")
-      set(LIBS "${LIBS} -l${_library_name}")
-      set(LIBS_STATIC "${LIBS_STATIC} -l${_library_name}")
-      set(LIBS_PRIVATE "${LIBS_PRIVATE} -l${_library_name}")
-    endforeach()
-  endif()
-  set(HAVE_OPENSSL YES)
-endif(OPENSSL_FOUND)
+        #
+        # Build executables only for 64-bit x86, as 32-bit x86 machines
+        # are no longer supported.
+        #
+        set(OSX_EXECUTABLE_ARCHITECTURES "x86_64")
+    elseif(SYSTEM_VERSION_MAJOR EQUAL 19)
+        #
+        # Catalina.
+        #
+        # Build libraries and executables only for x86-64, as 32-bit
+        # executables are no longer supported.  (That's what Apple
+        # does.)
+        #
+        set(OSX_LIBRARY_ARCHITECTURES "x86_64")
+        set(OSX_EXECUTABLE_ARCHITECTURES "x86_64")
+    else()
+        #
+        # Post-Catalina.  Build libraries and
+        # executables for x86-64 and ARM64.
+        # (That's what Apple does, except they
+        # build for arm64e, which may include
+        # some of the pointer-checking extensions.)
+        #
+        # If we're building with libssl, make sure
+        # we can build fat with it (i.e., that it
+        # was built fat); if we can't, don't set
+        # the target architectures, and just
+        # build for the host we're on.
+        #
+        # Otherwise, just add both of them.
+        #
+        if(HAVE_OPENSSL)
+          cmake_push_check_state()
+          set(CMAKE_REQUIRED_FLAGS "-arch x86_64 -arch arm64")
+          set(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})
+          set(CMAKE_REQUIRED_LIBRARIES ${OPENSSL_LIBRARIES})
+          #
+          # We must test whether this compiles and links, so
+          # check_symbol_exists() isn't sufficient.
+          #
+          # SSL_library_init() may be a macro that's #defined
+          # to be the real function to call, so we have to
+          # include <openssl/ssl.h>, and check_function_exists()
+          # isn't sufficient.
+          #
+          check_c_source_compiles(
+"#include <openssl/ssl.h>
+int
+main(void)
+{
+    SSL_library_init();
+    return 0;
+}
+"
+              FAT_SSL_BUILDS_SUPPORTED)
+          cmake_pop_check_state()
+          if(FAT_SSL_BUILDS_SUPPORTED)
+            set(OSX_LIBRARY_ARCHITECTURES "x86_64;arm64")
+            set(OSX_EXECUTABLE_ARCHITECTURES "x86_64;arm64")
+          endif()
+        else()
+          set(OSX_LIBRARY_ARCHITECTURES "x86_64;arm64")
+          set(OSX_EXECUTABLE_ARCHITECTURES "x86_64;arm64")
+        endif()
+    endif()
+endif()
 
 #
 # Additional linker flags.
@@ -1431,7 +1755,6 @@ set(PROJECT_SOURCE_LIST_C
     nametoaddr.c
     optimize.c
     pcap-common.c
-    pcap-usb-linux-common.c
     pcap-util.c
     pcap.c
     savefile.c
@@ -1487,11 +1810,21 @@ if(WIN32)
             set(PCAP_TYPE npf)
         else()
             #
-            # We don't have any capture type we know about, so just use
-            # the null capture type, and only support reading (and writing)
-            # capture files.
-            #
-            set(PCAP_TYPE null)
+            # We don't have any capture type we know about.
+            # Report an error, and tell the user to configure with
+            # -DPCAP_TYPE=null if they want a libpcap that can't
+            # capture but that can read capture files.  That way,
+            # nobody gets surprised by getting a no-capture
+            # libpcap without asking for that.
+            #
+            message(FATAL_ERROR "No supported packet capture interface was found.
+In order to build a version of libpcap that supports packet capture
+on Windows, you will need to install Npcap and the Npcap SDK, or
+WinPcap and the WinPcap SDK, and run cmake with -DPacket_ROOT={path of SDK},
+where {path of SDK} is the path name of the top-level directory of the SDK.
+That argument may have to be quoted if the path contains blanks.
+If you want a libpcap that cannot capture packets but that can read
+pcap and pcapng files, run cmake with -DPCAP_TYPE=null.")
         endif()
     endif()
 else()
@@ -1607,12 +1940,18 @@ else()
             set(PCAP_TYPE haiku)
         else()
             #
-            # Nothing we support.
-            #
-            set(PCAP_TYPE null)
-            message(WARNING
-"cannot determine packet capture interface
-(see the INSTALL.md file for more info)")
+            # We don't have any capture type we know about.
+            # Report an error, and tell the user to configure with
+            # -DPCAP_TYPE=null if they want a libpcap that can't
+            # capture but that can read capture files.  That way,
+            # nobody gets surprised by getting a no-capture
+            # libpcap without asking for that.
+            #
+            message(FATAL_ERROR "No supported packet capture interface was found.
+See the INSTALL.md file for information on packet capture support in
+various operating systems.
+If you want a libpcap that cannot capture packets but that can read
+pcap and pcapng files, run cmake with -DPCAP_TYPE=null.")
         endif()
     endif()
 endif(WIN32)
@@ -1756,12 +2095,35 @@ else(WIN32)
             check_type_size("struct BPF_TIMEVAL" STRUCT_BPF_TIMEVAL)
         endif()
         cmake_pop_check_state()
+
+        #
+        # Check whether there's a inet/ipnet.h header and,
+        # if so, whether it defines IPNET_ANY_LINK - if so,
+        # we assume we have the "any" device (that's a
+        # Solaris header, and later versions of Solaris
+        # have an "any" device).
+        #
+        # Attempting to include it at compile time could
+        # be a pain, as it's a kernel header.
+        #
+        message(STATUS "Checking whether the Solaris \"any\" device is supported")
+        if(EXISTS /usr/include/inet/ipnet.h)
+            file(STRINGS /usr/include/inet/ipnet.h IPNET_ANY_LINK_LINES REGEX IPNET_ANY_LINK)
+            if(NOT IPNET_ANY_LINK_LINES STREQUAL "")
+                set(HAVE_SOLARIS_ANY_DEVICE TRUE)
+            endif()
+        endif()
+        if(HAVE_SOLARIS_ANY_DEVICE)
+            message(STATUS "Checking whether the Solaris \"any\" device is supported - supported")
+        else()
+            message(STATUS "Checking whether the Solaris \"any\" device is supported - not supported")
+        endif()
     elseif(PCAP_TYPE STREQUAL "haiku")
         #
         # Check for some headers just in case.
         #
         check_include_files("net/if.h;net/if_dl.h;net/if_types.h" HAVE_NET_IF_TYPES_H)
-        set(PCAP_SRC pcap-${PCAP_TYPE}.cpp)
+        set(PCAP_SRC pcap-${PCAP_TYPE}.c)
     elseif(PCAP_TYPE STREQUAL "null")
     else()
         message(FATAL_ERROR "${PCAP_TYPE} is not a valid pcap type")
@@ -1955,7 +2317,7 @@ if(NOT DISABLE_NETMAP)
     #
     # Check whether net/netmap_user.h is usable if NETMAP_WITH_LIBS is
     # defined; it's not usable on DragonFly BSD 4.6 if NETMAP_WITH_LIBS
-    # is defined, for example, as it includes a non-existent malloc.h
+    # is defined, for example, as it includes a nonexistent malloc.h
     # header.
     #
     check_c_source_compiles(
@@ -1989,7 +2351,7 @@ if(NOT DISABLE_DPDK)
         cmake_pop_check_state()
         if(HAVE_RTE_ETH_DEV_COUNT_AVAIL)
             set(DPDK_C_FLAGS "-march=native")
-            set(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${DPDK_C_FLAGS})
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${DPDK_C_FLAGS}")
             include_directories(AFTER ${dpdk_INCLUDE_DIRS})
             link_directories(AFTER ${dpdk_LIBRARIES})
             set(PCAP_LINK_LIBRARIES ${PCAP_LINK_LIBRARIES} ${dpdk_LIBRARIES})
@@ -2042,7 +2404,7 @@ if(NOT DISABLE_BLUETOOTH)
 int
 main(void)
 {
-    u_int i = HCI_CHANNEL_MONITOR;
+    int i = HCI_CHANNEL_MONITOR;
     return 0;
 }
 "
@@ -2425,6 +2787,7 @@ if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/.devel OR EXISTS ${CMAKE_BINARY_DIR}/.deve
         # Microsoft's code generator.  We currently treat them as if
         # they might support GCC-style -W options.
         #
+        check_and_add_compiler_option(-W)
         check_and_add_compiler_option(-Wall)
         check_and_add_compiler_option(-Wcomma)
         # Warns about safeguards added in case the enums are extended
@@ -2434,13 +2797,17 @@ if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/.devel OR EXISTS ${CMAKE_BINARY_DIR}/.deve
         check_and_add_compiler_option(-Wmissing-noreturn)
         check_and_add_compiler_option(-Wmissing-prototypes)
         check_and_add_compiler_option(-Wmissing-variable-declarations)
+        check_and_add_compiler_option(-Wnull-pointer-subtraction)
         check_and_add_compiler_option(-Wpointer-arith)
         check_and_add_compiler_option(-Wpointer-sign)
         check_and_add_compiler_option(-Wshadow)
-        check_and_add_compiler_option(-Wsign-compare)
         check_and_add_compiler_option(-Wshorten-64-to-32)
+        check_and_add_compiler_option(-Wsign-compare)
         check_and_add_compiler_option(-Wstrict-prototypes)
+        check_and_add_compiler_option(-Wundef)
         check_and_add_compiler_option(-Wunreachable-code)
+        check_and_add_compiler_option(-Wunused-but-set-parameter)
+        check_and_add_compiler_option(-Wunused-but-set-variable)
         check_and_add_compiler_option(-Wunused-parameter)
         check_and_add_compiler_option(-Wused-but-marked-unused)
     endif()
@@ -2501,9 +2868,13 @@ endif(NOT MSVC)
 # usage: cmake -DEXTRA_CFLAGS='-Wall -Wextra -Werror' ...
 #
 if(NOT "${EXTRA_CFLAGS}" STREQUAL "")
-    foreach(_extra_cflag ${EXTRA_CFLAGS})
-        check_and_add_compiler_option("${_extra_cflag}")
-    endforeach(_extra_cflag)
+    # The meaning of EXTRA_CFLAGS is "use the exact specified options, or the
+    # build risks failing to fail", not "try every specified option, omit those
+    # that do not work and use the rest".  Thus use add_compile_options(), not
+    # foreach()/check_and_add_compiler_option().  Another reason to do that is
+    # that the effect lasts in testprogs/ and testprogs/fuzz/.
+    string(REPLACE " " ";" _extra_cflags_list ${EXTRA_CFLAGS})
+    add_compile_options(${_extra_cflags_list})
     message(STATUS "Added extra compile options (${EXTRA_CFLAGS})")
 endif()
 
@@ -2787,6 +3158,10 @@ if(BUILD_SHARED_LIBS)
         ${CMAKE_CURRENT_BINARY_DIR}/scanner.c
         ${PROJECT_EXTERNAL_OBJECT_LIST}
     )
+    target_include_directories(${LIBRARY_NAME} PUBLIC
+        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+        $<INSTALL_INTERFACE:include>
+    )
     add_dependencies(${LIBRARY_NAME} SerializeTarget)
     set_target_properties(${LIBRARY_NAME} PROPERTIES
         COMPILE_DEFINITIONS BUILDING_PCAP)
@@ -2812,6 +3187,10 @@ add_library(${LIBRARY_NAME}_static STATIC
     ${CMAKE_CURRENT_BINARY_DIR}/scanner.c
     ${PROJECT_EXTERNAL_OBJECT_LIST}
 )
+target_include_directories(${LIBRARY_NAME}_static PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+    $<INSTALL_INTERFACE:include>
+)
 add_dependencies(${LIBRARY_NAME}_static SerializeTarget)
 set_target_properties(${LIBRARY_NAME}_static PROPERTIES
     COMPILE_DEFINITIONS BUILDING_PCAP)
@@ -2873,6 +3252,15 @@ if(BUILD_SHARED_LIBS)
     if(NOT C_ADDITIONAL_FLAGS STREQUAL "")
         set_target_properties(${LIBRARY_NAME} PROPERTIES COMPILE_FLAGS ${C_ADDITIONAL_FLAGS})
     endif()
+
+    #
+    # If this is macOS and we've picked the default architectures on
+    # which to build, build the library on them.
+    #
+    if(APPLE AND "${CMAKE_OSX_ARCHITECTURES}" STREQUAL "")
+        set_target_properties(${LIBRARY_NAME} PROPERTIES
+            OSX_ARCHITECTURES "${OSX_LIBRARY_ARCHITECTURES}")
+    endif()
     target_link_libraries(${LIBRARY_NAME} ${PCAP_LINK_LIBRARIES})
 endif(BUILD_SHARED_LIBS)
 
@@ -2881,177 +3269,10 @@ if(NOT C_ADDITIONAL_FLAGS STREQUAL "")
 endif()
 
 #
-# On macOS, build libpcap for the appropriate architectures, if
-# CMAKE_OSX_ARCHITECTURES isn't set (if it is, let that control
-# the architectures for which to build it).
+# If this is macOS and we've picked the default architectures on
+# which to build, build the library on them.
 #
 if(APPLE AND "${CMAKE_OSX_ARCHITECTURES}" STREQUAL "")
-    #
-    # Get the major version of Darwin.
-    #
-    string(REGEX MATCH "^([0-9]+)" SYSTEM_VERSION_MAJOR "${CMAKE_SYSTEM_VERSION}")
-
-    if(SYSTEM_VERSION_MAJOR LESS 8)
-        #
-        # Pre-Tiger.  Build only for 32-bit PowerPC.
-        #
-        set(OSX_LIBRARY_ARCHITECTURES "ppc")
-    elseif(SYSTEM_VERSION_MAJOR EQUAL 8)
-        #
-        # Tiger.  Is this prior to, or with, Intel support?
-        #
-        # Get the minor version of Darwin.
-        #
-        string(REPLACE "${SYSTEM_VERSION_MAJOR}." "" SYSTEM_MINOR_AND_PATCH_VERSION ${CMAKE_SYSTEM_VERSION})
-        string(REGEX MATCH "^([0-9]+)" SYSTEM_VERSION_MINOR "${SYSTEM_MINOR_AND_PATCH_VERSION}")
-        if(SYSTEM_VERSION_MINOR LESS 4)
-            #
-            # Prior to Intel support.  Build for 32-bit
-            # PowerPC and 64-bit PowerPC, with 32-bit PowerPC
-            # first.  (I'm guessing that's what Apple does.)
-            #
-            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64")
-        elseif(SYSTEM_VERSION_MINOR LESS 7)
-            #
-            # With Intel support but prior to x86-64 support.
-            # Build for 32-bit PowerPC, 64-bit PowerPC, and 32-bit x86,
-            # with 32-bit PowerPC first.
-            # (I'm guessing that's what Apple does.)
-            #
-            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386")
-        else()
-            #
-            # With Intel support including x86-64 support.
-            # Build for 32-bit PowerPC, 64-bit PowerPC, 32-bit x86,
-            # and x86-64, with 32-bit PowerPC first.
-            # (I'm guessing that's what Apple does.)
-            #
-            set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386;x86_64")
-        endif()
-    elseif(SYSTEM_VERSION_MAJOR EQUAL 9)
-        #
-        # Leopard.  Build for 32-bit PowerPC, 64-bit
-        # PowerPC, 32-bit x86, and x86-64, with 32-bit PowerPC
-        # first.  (That's what Apple does.)
-        #
-        set(OSX_LIBRARY_ARCHITECTURES "ppc;ppc64;i386;x86_64")
-    elseif(SYSTEM_VERSION_MAJOR EQUAL 10)
-        #
-        # Snow Leopard.  Build for x86-64, 32-bit x86, and
-        # 32-bit PowerPC, with x86-64 first.  (That's
-        # what Apple does, even though Snow Leopard
-        # doesn't run on PPC, so PPC libpcap runs under
-        # Rosetta, and Rosetta doesn't support BPF
-        # ioctls, so PPC programs can't do live
-        # captures.)
-        #
-        set(OSX_LIBRARY_ARCHITECTURES "x86_64;i386;ppc")
-    elseif(SYSTEM_VERSION_MAJOR GREATER 10 AND SYSTEM_VERSION_MAJOR LESS 19)
-        #
-        # Post-Snow Leopard, pre-Catalina.  Build for x86-64
-        # and 32-bit x86, with x86-64 first.  (That's what Apple does)
-        #
-        # First, check whether we're building with OpenSSL.
-        # If so, don't bother trying to build fat.
-        #
-        if(HAVE_OPENSSL)
-          set(X86_32_BIT_SUPPORTED NO)
-          set(OSX_LIBRARY_ARCHITECTURES "x86_64")
-          message(WARNING "We're assuming the OpenSSL libraries are 64-bit only, so we're not compiling for 32-bit x86")
-        else()
-          #
-          # Now, check whether we *can* build for i386.
-          #
-          cmake_push_check_state()
-          set(CMAKE_REQUIRED_FLAGS "-arch i386")
-          check_c_source_compiles(
-"int
-main(void)
-{
-    return 0;
-}
-"
-                   X86_32_BIT_SUPPORTED)
-          cmake_pop_check_state()
-          if(X86_32_BIT_SUPPORTED)
-              set(OSX_LIBRARY_ARCHITECTURES "x86_64;i386")
-          else()
-              set(OSX_LIBRARY_ARCHITECTURES "x86_64")
-              #
-              # We can't build fat; suggest that the user install the
-              # /usr/include headers if they want to build fat.
-              #
-              if(SYSTEM_VERSION_MAJOR LESS 18)
-                  #
-                  # Pre-Mojave; the command-line tools should be sufficient to
-                  # enable 32-bit x86 builds.
-                  #
-                  message(WARNING "Compiling for 32-bit x86 gives an error; try installing the command-line tools")
-              else()
-                  message(WARNING "Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package")
-              endif()
-          endif()
-        endif()
-    elseif(SYSTEM_VERSION_MAJOR EQUAL 19)
-        #
-        # Catalina.  Build libraries and executables
-        # only for x86-64.  (That's what Apple does;
-        # 32-bit x86 binaries are not supported on
-        # Catalina.)
-        #
-        set(OSX_LIBRARY_ARCHITECTURES "x86_64")
-    else()
-        #
-        # Post-Catalina.  Build libraries and
-        # executables for x86-64 and ARM64.
-        # (That's what Apple does, except they
-        # build for arm64e, which may include
-        # some of the pointer-checking extensions.)
-        #
-        # If we're building with libssl, make sure
-        # we can build fat with it (i.e., that it
-        # was built fat); if we can't, don't set
-        # the target architectures, and just
-        # build for the host we're on.
-        #
-        # Otherwise, just add both of them.
-        #
-        if(HAVE_OPENSSL)
-          cmake_push_check_state()
-          set(CMAKE_REQUIRED_FLAGS "-arch x86_64 -arch arm64")
-          set(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})
-          set(CMAKE_REQUIRED_LIBRARIES ${OPENSSL_LIBRARIES})
-          #
-          # We must test whether this compiles and links, so
-          # check_symbol_exists() isn't sufficient.
-          #
-          # SSL_library_init() may be a macro that's #defined
-          # to be the real function to call, so we have to
-          # include <openssl/ssl.h>, and check_function_exists()
-          # isn't sufficient.
-          #
-          check_c_source_compiles(
-"#include <openssl/ssl.h>
-int
-main(void)
-{
-    SSL_library_init();
-    return 0;
-}
-"
-              FAT_SSL_BUILDS_SUPPORTED)
-          cmake_pop_check_state()
-          if(FAT_SSL_BUILDS_SUPPORTED)
-              set(OSX_LIBRARY_ARCHITECTURES "x86_64;arm64")
-          endif()
-        else()
-            set(OSX_LIBRARY_ARCHITECTURES "x86_64;arm64")
-        endif()
-    endif()
-    if(BUILD_SHARED_LIBS)
-        set_target_properties(${LIBRARY_NAME} PROPERTIES
-            OSX_ARCHITECTURES "${OSX_LIBRARY_ARCHITECTURES}")
-    endif(BUILD_SHARED_LIBS)
     set_target_properties(${LIBRARY_NAME}_static PROPERTIES
         OSX_ARCHITECTURES "${OSX_LIBRARY_ARCHITECTURES}")
 endif()
@@ -3092,21 +3313,23 @@ function(install_manpage_symlink SOURCE TARGET MANDIR)
         set(LINK_COMMAND "\"${CMAKE_COMMAND}\" \"-E\" \"create_symlink\" \"${SOURCE}\" \"${TARGET}\"")
     endif(MINGW)
 
-    install(CODE
-        "message(STATUS \"Symlinking: \$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\")
+    install(CODE "
+         if(NOT ${CMAKE_INSTALL_MESSAGE} STREQUAL \"NEVER\")
+             message(STATUS \"Symlinking: \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\")
+         endif()
          execute_process(
             COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"remove\" \"${TARGET}\"
-            WORKING_DIRECTORY \$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/${MANDIR}
+            WORKING_DIRECTORY \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${MANDIR}
           )
          execute_process(
             COMMAND ${LINK_COMMAND}
-            WORKING_DIRECTORY \$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/${MANDIR}
+            WORKING_DIRECTORY \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${MANDIR}
             RESULT_VARIABLE EXIT_STATUS
           )
           if(NOT EXIT_STATUS EQUAL 0)
-              message(FATAL_ERROR \"Could not create symbolic link from ${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\")
+              message(FATAL_ERROR \"Could not create symbolic link from \${CMAKE_INSTALL_PREFIX}/${MANDIR}/${SOURCE} to ${TARGET}\")
           endif()
-          set(CMAKE_INSTALL_MANIFEST_FILES \${CMAKE_INSTALL_MANIFEST_FILES} ${CMAKE_INSTALL_PREFIX}/${MANDIR}/${TARGET})")
+          set(CMAKE_INSTALL_MANIFEST_FILES \${CMAKE_INSTALL_MANIFEST_FILES} \${CMAKE_INSTALL_PREFIX}/${MANDIR}/${TARGET})")
 endfunction(install_manpage_symlink)
 
 set(MAN1_NOEXPAND pcap-config.1)
@@ -3230,13 +3453,13 @@ if(WIN32 OR CYGWIN OR MSYS)
         endif(MSVC)
     endif(MSVC AND CMAKE_SIZEOF_VOID_P EQUAL 8)
 else(WIN32 OR CYGWIN OR MSYS)
-    install(TARGETS ${LIBRARIES_TO_INSTALL} DESTINATION ${CMAKE_INSTALL_FULL_LIBDIR})
+    install(TARGETS ${LIBRARIES_TO_INSTALL} DESTINATION ${CMAKE_INSTALL_LIBDIR})
 endif(WIN32 OR CYGWIN OR MSYS)
 
-install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcap/ DESTINATION include/pcap)
-install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap.h DESTINATION include)
-install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-bpf.h DESTINATION include)
-install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-namedb.h DESTINATION include)
+install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/pcap/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/pcap)
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-bpf.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pcap-namedb.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 
 # On UN*X, and on Windows when not using MSVC, generate libpcap.pc and
 # pcap-config and process man pages and arrange that they be installed.
diff --git a/CREDITS b/CREDITS
index 4b820ee7..78ce6a10 100644
--- a/CREDITS
+++ b/CREDITS
@@ -17,6 +17,7 @@ Additional people who have contributed patches (in alphabetical order):
     Alex Smith                    <44322503+MadAlexUK at users dot noreply dot github dot com>
     Alfredo Alvarez Fernandez     <alfredoalvarezernandez at gmail dot com>
     Ali Abdulkadir                <autostart dot ini at gmail dot com>
+    Alois Klink                   <alois at aloisklink dot com>
     Alon Bar-Lev                  <alonbl at sourceforge dot net>
     Anders Broman                 <anders dot broman at ericsson dot com>
     Andres Perera                 <andres dot p at zoho dot com>
@@ -24,7 +25,9 @@ Additional people who have contributed patches (in alphabetical order):
                                   <andy-1 at sourceforge dot net>
     Ani Sinha                     <ani at aristanetworks dot com>
     Anthony Kirby                 <Anthony dot Kirby at nominet dot uk>
+    Antonio Vzquez Blanco        <antonio dot vazquez at tarlogic dot com>
     Antti Kantee                  <pooka at netbsd dot org>
+    Archit Shah                   <archit at cave32 dot com>
     Arien Vijn                    <arienvijn at sourceforge dot net>
     Arkadiusz Miskiewicz          <misiek at pld dot org dot pl>
     Armando L. Caro Jr.           <acaro at mail dot eecis dot udel dot edu>
@@ -49,6 +52,7 @@ Additional people who have contributed patches (in alphabetical order):
     Christian Peron               <csjp at freebsd dot org>
     Christian Svensson            <blue at cmd dot nu>
     Christopher K Lee             <christopher dot lee at cspi dot com>
+    Clment Pron                 <peron dot clem at gmail dot com>
     Daniel Borkmann               <dborkman at redhat dot com>
     Daniele Orlandi               <daniele at orlandi dot com>
     Daniel Lublin                 <daniel at lublin dot se>
@@ -69,6 +73,7 @@ Additional people who have contributed patches (in alphabetical order):
     Dug Song                      <dugsong at monkey dot org>
     Dustin Spicuzza               <dustin at virtualroadside dot com>
     dzejarczech                   <dzejarczech at sourceforge dot net>
+    Ed Maste                      <emaste at FreeBSD dot org>
     Edward Sheldrake              <ejs1920 at sourceforge dot net>
     Eli Schwartz                  <eschwartz93 at gmail dot com>
     Eric Anderson                 <anderse at hpl dot hp dot com>
@@ -85,6 +90,7 @@ Additional people who have contributed patches (in alphabetical order):
     Fulko Hew                     <fulko dot hew at gmail dot com>
     Fumiyuki Shimizu              <fumifumi at abacustech dot jp>
     Gabor Tatarka                 <gabor dot tatarka at ericsson dot com>
+    Gabriel Ganne                 <gabriel dot ganne at gmail dot com>
     Garrett Cooper                <yaberauneya at sourceforge dot net>
     George Neville-Neil           <gnn at freebsd dot org>
     Gerald Combs                  <gerald at zing dot org>
@@ -99,8 +105,10 @@ Additional people who have contributed patches (in alphabetical order):
     Guillaume Pelat               <endymion_ at users dot sourceforge dot net>
     Gustavo Zacarias              <gustavo at zacarias dot com dot ar>
     Hagen Paul Pfeifer            <hagen at jauu dot net>
+    headshog                      <craaaaaachind at gmail dot com>
     Henri Doreau                  <hdoreau at sourceforge dot net>
     Hiroaki KAWAI                 <kawai at stratosphere dot co dot jp>
+    hopper-vul                    <hopper dot vul at gmail dot com>
     Hyung Sik Yoon                <hsyn at kr dot ibm dot com>
     Igor Khristophorov            <igor at atdot dot org>
     Jakub Sitnicki                <jsitnicki at gmail dot com>
@@ -120,16 +128,19 @@ Additional people who have contributed patches (in alphabetical order):
     jingyu yang                   <jingleyang at users dot noreply dot github dot com>
     Jiri Slaby                    <jirislaby at gmail dot com>
     Joo Valverde                 <joao dot valverde at tecnico dot ulisboa dot pt>
+    Joel                          <82591719+joelg989 at users dot noreply dot github dot com>
     Joerg Mayer                   <jmayer at loplof dot de>
     John Bankier                  <jbankier at rainfinity dot com>
     Jon Lindgren                  <jonl at yubyub dot net>
     Jon Smirl                     <jonsmirl at gmail dot com>
     Jorge Boncompte [DTI2]        <jorge at dti2 dot net>
+    Josh Soref                    <2119212+jsoref at users dot noreply dot github dot com>
     jromanr                       <jromanr at hotmail dot com>
     Juergen Schoenwaelder         <schoenw at ibr dot cs dot tu-bs dot de>
     Julien Moutinho               <julm at savines dot alpes dot fr dot eu dot org>
     Jung-uk Kim                   <jkim at FreeBSD dot org>
     Kazushi Sugyo                 <sugyo at pb dot jp dot nec dot com>
+    Kenny Luong                   <kluong at cloudflare dot com>
     Kevin Boulain                 <kevin dot boulain at securactive dot net>
     Klaus Klein                   <kleink at netbsd dot org>
     Koryn Grant                   <koryn at endace dot com>
@@ -141,6 +152,7 @@ Additional people who have contributed patches (in alphabetical order):
     Lorenzo Cavallaro             <sullivan at sikurezza dot org>
     Loris Degioanni               <loris at netgroup-serv dot polito dot it>
     Love Hrnquist-strand        <lha at stacken dot kth dot se>
+    Lubomir Varga                 <lubomir dot varga at qpp dot sk>
     Luis MartinGarcia             <luis dot mgarc at gmail dot com>
     lxy                           <391861737 at qq dot com>
     Maciej W. Rozycki             <macro at ds2 dot pg dot gda dot pl>
@@ -154,6 +166,7 @@ Additional people who have contributed patches (in alphabetical order):
     Markus Mayer                  <markus_mayer at sourceforge dot net>
     Martin Husemann               <martin at netbsd dot org>
     Mrton Nmeth                 <nm127 at freemail dot hu>
+    Matias Karhumaa               <matias dot karhumaa at gmail dot com>
     Matt Eaton                    <agnosticdev at gmail dot com>
     Matthew Luckie                <mjl at luckie dot org dot nz>
     Matthias Hannig               <matthias at hannig dot cc>
@@ -174,8 +187,10 @@ Additional people who have contributed patches (in alphabetical order):
     Nan Xiao                      <nan at chinadtrace dot org>
     nic-kaczinsky                 <68271784+nic-kaczinsky at users dot noreply dot github dot com>
     Nick Kelsey                   <nickk at silicondust dot com>
+    Nicolas Badoux                <n dot badoux at hotmail dot com>
     Nicolas Dade                  <ndade at nsd dot dyndns dot org>
     Niko Delarich                 <niko dot delarich at gmail dot com>
+    Nikolay Edigaryev             <edigaryev at gmail dot com>
     N. Leiten                     <nleiten at sourceforge dot net>
     nnposter                      <nnposter at users dot noreply dot github dot com>
                                   <nvercamm at sourceforge dot net>
@@ -209,6 +224,7 @@ Additional people who have contributed patches (in alphabetical order):
     Roland Dreier                 <roland at purestorage dot com>
     Romain Francoise              <rfrancoise at debian dot org>
     Rongxi Li                     <rongxi dot li at chaitin dot com>
+    Rose                          <83477269+AtariDreams at users dot noreply dot github dot com>
     Sagun Shakya                  <sagun dot shakya at sun dot com>
     Scott Barron                  <sb125499 at ohiou dot edu>
     Scott Gifford                 <sgifford at tir dot com>
@@ -218,6 +234,7 @@ Additional people who have contributed patches (in alphabetical order):
     Sepherosa Ziehau              <sepherosa at gmail dot com>
     Shane Kerr                    <shane at time-travellers dot org>
     Shaun Clowes                  <delius at progsoc dot uts dot edu dot au>
+    Shunyang Zhang                <shyzhang at grandstream dot cn>
     solofox                       <wensg100 at sina dot com>
     Solomon Peachy                <pizza at shaftnet dot org>
     Stefan Hudson                 <hudson at mbay dot net>
diff --git a/INSTALL.md b/INSTALL.md
index d0a19d81..27875807 100644
--- a/INSTALL.md
+++ b/INSTALL.md
@@ -4,10 +4,18 @@ with CMake and any build system supported by CMake.
 
 To build libpcap with the configure script and `make`:
 
+* If you build from a git clone rather than from a release archive,
+run `./autogen.sh` (a shell script). The autogen.sh script will
+build the `configure` and `config.h.in` files.
+
+On some system, you may need to set the `AUTORECONF` variable, like:
+`AUTORECONF=autoreconf-2.69 ./autogen.sh`
+to select the `autoreconf` version you want to use.
+
 * Run `./configure` (a shell script).  The configure script will
 determine your system attributes and generate an appropriate `Makefile`
 from `Makefile.in`.  The configure script has a number of options to
-control the configuration of libpcap; `./configure --help`` will show
+control the configuration of libpcap; `./configure --help` will show
 them.
 
 * Next, run `make`.  If everything goes well, you can
@@ -15,6 +23,10 @@ them.
 libpcap if you just want to build tcpdump; just make sure the tcpdump
 and libpcap directory trees have the same parent directory.
 
+On OpenBSD, you may need to set, before the `make`, the `AUTOCONF_VERSION`
+variable like:
+`AUTOCONF_VERSION=2.69 make`
+
 To build libpcap with CMake and the build system of your choice, from
 the command line:
 
@@ -62,7 +74,7 @@ forget to include an autoconf fragment suitable for use in
 `configure.ac`.
 
 It is possible to override the default packet capture type with the
-`--with-pcap`` option to `./configure` or the `-DPCAP_TYPE` option to
+`--with-pcap` option to `./configure` or the `-DPCAP_TYPE` option to
 CMake, although the circumstances where this works are limited.  One
 possible reason to do that would be to force a supported packet capture
 type in the case where the configure or CMake scripts fails to detect
@@ -186,37 +198,44 @@ in `/usr/include/sys/dlpi.h`, and find the corresponding value.
 	CONTRIBUTING.md	    - guidelines for contributing
 	CREDITS		    - people that have helped libpcap along
 	INSTALL.md	    - this file
-	LICENSE		    - the license under which tcpdump is distributed
+	LICENSE		    - the license under which libpcap is distributed
 	Makefile.in	    - compilation rules (input to the configure script)
 	README.md	    - description of distribution
 	doc/README.aix	    - notes on using libpcap on AIX
 	doc/README.dag	    - notes on using libpcap to capture on Endace DAG devices
+	doc/README.haiku.md - notes on using libpcap on Haiku
 	doc/README.hpux	    - notes on using libpcap on HP-UX
 	doc/README.linux    - notes on using libpcap on Linux
 	doc/README.macos    - notes on using libpcap on macOS
 	doc/README.septel   - notes on using libpcap to capture on Intel/Septel devices
 	doc/README.sita	    - notes on using libpcap to capture on SITA devices
 	doc/README.solaris.md - notes on using libpcap on Solaris
-	doc/README.Win32.md - notes on using libpcap on Win32 systems (with Npcap)
+	doc/README.windows.md - notes on using libpcap on Windows systems (with Npcap)
 	VERSION		    - version of this release
 	aclocal.m4	    - autoconf macros
 	arcnet.h	    - ARCNET definitions
 	atmuni31.h	    - ATM Q.2931 definitions
+	autogen.sh	    - build configure and config.h.in (run this first)
 	bpf_dump.c	    - BPF program printing routines
 	bpf_filter.c	    - BPF filtering routines
 	bpf_image.c	    - BPF disassembly routine
+	charconv.c	    - Windows Unicode routines
+	charconv.h	    - Windows Unicode prototypes
 	config.guess	    - autoconf support
-	config.h.in	    - autoconf input
 	config.sub	    - autoconf support
-	configure	    - configure script (run this first)
 	configure.ac	    - configure script source
+	diag-control.h	    - compiler diagnostics control macros
 	dlpisubs.c	    - DLPI-related functions for pcap-dlpi.c and pcap-libdlpi.c
 	dlpisubs.h	    - DLPI-related function declarations
 	etherent.c	    - /etc/ethers support routines
+	extract.h	    - Alignment definitions
 	ethertype.h	    - Ethernet protocol types and names definitions
 	fad-getad.c	    - pcap_findalldevs() for systems with getifaddrs()
 	fad-gifc.c	    - pcap_findalldevs() for systems with only SIOCGIFLIST
 	fad-glifc.c	    - pcap_findalldevs() for systems with SIOCGLIFCONF
+	fmtutils.c	    - error message formatting routines
+	fmtutils.h	    - error message formatting prototypes
+	ftmacros.h	    - feature test macros
 	testprogs/filtertest.c      - test program for BPF compiler
 	testprogs/findalldevstest.c - test program for pcap_findalldevs()
 	gencode.c	    - BPF code generation routines
@@ -224,54 +243,107 @@ in `/usr/include/sys/dlpi.h`, and find the corresponding value.
 	grammar.y	    - filter string grammar
 	ieee80211.h	    - 802.11 definitions
 	install-sh	    - BSD style install script
+	instrument-functions.c - functions instrumentation calls for entry/exit
 	lbl/os-*.h	    - OS-dependent defines and prototypes
 	llc.h		    - 802.2 LLC SAP definitions
 	missing/*	    - replacements for missing library functions
 	mkdep		    - construct Makefile dependency list
 	msdos/*		    - drivers for MS-DOS capture support
 	nametoaddr.c	    - hostname to address routines
+	nametoaddr.h	    - hostname to address prototypes
 	nlpid.h		    - OSI network layer protocol identifier definitions
 	optimize.c	    - BPF optimization routines
+	optimize.h	    - BPF optimization prototypes
 	pcap/bluetooth.h    - public definition of DLT_BLUETOOTH_HCI_H4_WITH_PHDR header
 	pcap/bpf.h	    - BPF definitions
+	pcap/can_socketcan.h - SocketCAN header
+	pcap/compiler-tests.h - compiler version comparison and other macros
+	pcap/dlt.h	    - Link-layer header type codes.
+	pcap/funcattrs.h    - function attribute macros
+	pcap/ipnet.h	    - Solaris IPnet definitions
 	pcap/namedb.h	    - public libpcap name database definitions
+	pcap/nflog.h	    - NFLOG-related definitions
 	pcap/pcap.h	    - public libpcap definitions
+	pcap/pcap-inttypes.h - header for OS-specific integer type includes
 	pcap/sll.h	    - public definitions of DLT_LINUX_SLL and DLT_LINUX_SLL2 headers
+	pcap/socket.h	    - IP sockets support for various OSes
 	pcap/usb.h	    - public definition of DLT_USB header
+	pcap/vlan.h	    - VLAN-specific definitions
+	pcap-airpcap.c	    - AirPcap device capture support
+	pcap-airpcap.h	    - AirPcap device capture support
 	pcap-bpf.c	    - BSD Packet Filter support
 	pcap-bpf.h	    - header for backwards compatibility
 	pcap-bt-linux.c	    - Bluetooth capture support for Linux
 	pcap-bt-linux.h	    - Bluetooth capture support for Linux
+	pcap-bt-monitor-linux.c - Bluetooth monitor capture support for Linux
+	pcap-bt-monitor-linux.h - Bluetooth monitor capture support for Linux
+	pcap-common.c	    - common code for pcap and pcapng files
+	pcap-common.h	    - common code for pcap and pcapng files
 	pcap-dag.c	    - Endace DAG device capture support
 	pcap-dag.h	    - Endace DAG device capture support
+	pcap-dbus.c	    - D-Bus capture support
+	pcap-dbus.h	    - D-Bus capture support
 	pcap-dlpi.c	    - Data Link Provider Interface support
 	pcap-dos.c	    - MS-DOS capture support
 	pcap-dos.h	    - headers for MS-DOS capture support
+	pcap-dpdk.c	    - DPDK device support
+	pcap-dpdk.h	    - DPDK device support
 	pcap-enet.c	    - enet support
+	pcap-haiku.c	    - Haiku capture support
 	pcap-int.h	    - internal libpcap definitions
 	pcap-libdlpi.c	    - Data Link Provider Interface support for systems with libdlpi
 	pcap-linux.c	    - Linux packet socket support
 	pcap-namedb.h	    - header for backwards compatibility
+	pcap-netfilter-linux.c - Linux netfilter support
+	pcap-netfilter-linux.h - Linux netfilter support
+	pcap-netmap.c	    - netmap support
+	pcap-netmap.h	    - netmap support
 	pcap-nit.c	    - SunOS Network Interface Tap support
 	pcap-npf.c	    - Npcap capture support
 	pcap-null.c	    - dummy monitor support (allows offline use of libpcap)
 	pcap-pf.c	    - Ultrix and Digital/Tru64 UNIX Packet Filter support
+	pcap-rdmasniff.c    - RDMA/InfiniBand capture support
+	pcap-rdmasniff.h    - RDMA/InfiniBand capture support
+	pcap-rpcap.c	    - RPCAP protocol capture support
+	pcap-rpcap.h	    - RPCAP protocol capture support
 	pcap-septel.c       - Intel/Septel device capture support
 	pcap-septel.h       - Intel/Septel device capture support
 	pcap-sita.c	    - SITA device capture support
 	pcap-sita.h	    - SITA device capture support
 	pcap-sita.html	    - SITA device capture documentation
+	pcap-snf.c	    - Myricom SNF device capture support
+	pcap-snf.h	    - Myricom SNF device capture support
 	pcap-snit.c	    - SunOS 4.x STREAMS-based Network Interface Tap support
 	pcap-snoop.c	    - IRIX Snoop network monitoring support
+	pcap-tc.c	    - TurboCap device capture support
+	pcap-tc.h	    - TurboCap device capture support
+	pcap-types.h	    - header for OS-specific type includes
 	pcap-usb-linux.c    - USB capture support for Linux
 	pcap-usb-linux.h    - USB capture support for Linux
+	pcap-usb-linux-common.c - Linux USB common routines
+	pcap-usb-linux-common.h - Linux USB common prototypes
+	pcap-util.c	    - common code for various files
+	pcap-util.h	    - common code for various files
 	pcap.3pcap	    - manual entry for the library
 	pcap.c		    - pcap utility routines
 	pcap.h		    - header for backwards compatibility
 	pcap_*.3pcap	    - manual entries for library functions
 	pcap-filter.manmisc.in   - manual entry for filter syntax
 	pcap-linktype.manmisc.in - manual entry for link-layer header types
+	pflog.h		    - header for DLT_PFLOG handling in filter code
+	portability.h	    - Portability declarations/definitions
 	ppp.h		    - Point to Point Protocol definitions
+	rpcap-protocol.c    - RPCAP client/server common routines
+	rpcap-protocol.h    - RPCAP client/server common prototypes
 	savefile.c	    - offline support
 	scanner.l	    - filter string scanner
+	sf-pcap.c	    - routines for .pcap savefiles
+	sf-pcap.h	    - prototypes for .pcap savefiles
+	sf-pcapng.c	    - routines for .pcapng savefiles
+	sf-pcapng.h	    - prototypes for .pcapng savefiles
+	sockutils.c	    - socket and name lookup API routines
+	sockutils.h	    - socket and name lookup API prototypes
+	sslutils.c	    - OpenSSL interface routines
+	sslutils.h	    - OpenSSL interface prototypes
 	sunatmpos.h	    - definitions for SunATM capturing
+	varattrs.h	    - variable attribute macros
diff --git a/METADATA b/METADATA
index b9f284e7..1e2b36cc 100644
--- a/METADATA
+++ b/METADATA
@@ -1,26 +1,23 @@
 # This project was upgraded with external_updater.
-# Usage: tools/external_updater/updater.sh update libpcap
-# For more info, check https://cs.android.com/android/platform/superproject/+/main:tools/external_updater/README.md
+# Usage: tools/external_updater/updater.sh update external/libpcap
+# For more info, check https://cs.android.com/android/platform/superproject/main/+/main:tools/external_updater/README.md
 
 name: "libpcap"
 description: "A system-independent interface for user-level packet capture."
 third_party {
-  url {
-    type: HOMEPAGE
-    value: "https://www.tcpdump.org/"
-  }
-  url {
-    type: GIT
-    value: "https://github.com/the-tcpdump-group/libpcap.git"
-  }
-  version: "libpcap-1.10.4"
   license_type: NOTICE
   security {
     tag: "NVD-CPE2.3:cpe:/a:tcpdump:libpcap:-"
   }
   last_upgrade_date {
-    year: 2023
-    month: 7
-    day: 12
+    year: 2025
+    month: 1
+    day: 9
+  }
+  homepage: "https://www.tcpdump.org/"
+  identifier {
+    type: "Git"
+    value: "https://github.com/the-tcpdump-group/libpcap.git"
+    version: "libpcap-1.10.5"
   }
 }
diff --git a/Makefile.in b/Makefile.in
index 3468e204..207ad8c0 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -70,7 +70,6 @@ INSTALL_RPCAPD=@INSTALL_RPCAPD@
 
 # Standard CFLAGS for building members of a shared library
 FULL_CFLAGS = $(CCOPT) @V_LIB_CCOPT_FAT@ $(SHLIB_CCOPT) $(INCLS) $(DEFS) $(CFLAGS)
-CXXFLAGS = $(CCOPT) @V_LIB_CCOPT_FAT@ $(SHLIB_CCOPT) $(INCLS) $(DEFS) $(CFLAGS)
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -88,24 +87,22 @@ BISON_BYACC = @BISON_BYACC@
 	$(CC) $(FULL_CFLAGS) -c $(srcdir)/$*.c
 
 PLATFORM_C_SRC =	@PLATFORM_C_SRC@
-PLATFORM_CXX_SRC =	@PLATFORM_CXX_SRC@
 MODULE_C_SRC =		@MODULE_C_SRC@
 REMOTE_C_SRC =		@REMOTE_C_SRC@
 COMMON_C_SRC =	pcap.c gencode.c optimize.c nametoaddr.c etherent.c \
 		fmtutils.c pcap-util.c \
 		savefile.c sf-pcap.c sf-pcapng.c pcap-common.c \
-		pcap-usb-linux-common.c bpf_image.c bpf_filter.c bpf_dump.c
+		bpf_image.c bpf_filter.c bpf_dump.c
 GENERATED_C_SRC = scanner.c grammar.c
 LIBOBJS = @LIBOBJS@
 
-SRC =	$(PLATFORM_C_SRC) $(PLATFORM_CXX_SRC) \
+SRC =	$(PLATFORM_C_SRC) \
 	$(MODULE_C_SRC) $(REMOTE_C_SRC) $(COMMON_C_SRC) \
 	$(GENERATED_C_SRC)
 
 # We would like to say "OBJ = $(SRC:.c=.o)" but Ultrix's make cannot
-# hack the extra indirection, and we have to handle PLATFORM_CXX_SRC
-# differently from the defines for C source
-OBJ =	$(PLATFORM_C_SRC:.c=.o) $(PLATFORM_CXX_SRC:.cpp=.o) \
+# hack the extra indirection
+OBJ =	$(PLATFORM_C_SRC:.c=.o) \
 	$(MODULE_C_SRC:.c=.o) $(REMOTE_C_SRC:.c=.o) $(COMMON_C_SRC:.c=.o) \
 	$(GENERATED_C_SRC:.c=.o) \
 	$(LIBOBJS)
@@ -157,6 +154,7 @@ HDR = $(PUBHDR) \
 	sf-pcap.h \
 	sf-pcapng.h \
 	sunatmpos.h \
+	thread-local.h \
 	varattrs.h
 
 GENHDR = \
@@ -167,7 +165,7 @@ TAGFILES = \
 
 CLEANFILES = $(OBJ) libpcap.a libpcap.so.`cat $(srcdir)/VERSION` \
 	$(PROG)-`cat $(srcdir)/VERSION`.tar.gz $(GENERATED_C_SRC) $(GENHDR) \
-	lex.yy.c pcap-config libpcap.pc
+	lex.yy.c pcap-config libpcap.pc libpcap.$(DYEXT)
 
 MAN1 = pcap-config.1
 
@@ -254,19 +252,21 @@ EXTRA_DIST = \
 	Makefile.in \
 	Makefile-devel-adds \
 	README.md \
-	doc/README.Win32.md \
 	doc/README.aix \
 	doc/README.dag \
+	doc/README.haiku.md \
 	doc/README.hpux \
 	doc/README.linux \
 	doc/README.macos \
 	doc/README.septel \
 	doc/README.sita \
 	doc/README.solaris.md \
+	doc/README.windows.md \
 	CONTRIBUTING.md \
 	TODO \
 	VERSION \
 	aclocal.m4 \
+	autogen.sh \
 	charconv.c \
 	charconv.h \
 	chmod_bpf \
@@ -282,9 +282,7 @@ EXTRA_DIST = \
 	cmake/Modules/FindTC.cmake \
 	cmake/have_siocglifconf.c \
 	config.guess \
-	config.h.in \
 	config.sub \
-	configure \
 	configure.ac \
 	dlpisubs.c \
 	dlpisubs.h \
@@ -340,7 +338,7 @@ EXTRA_DIST = \
 	pcap-dpdk.c \
 	pcap-dpdk.h \
 	pcap-enet.c \
-	pcap-haiku.cpp \
+	pcap-haiku.c \
 	pcap-int.h \
 	pcap-libdlpi.c \
 	pcap-linux.c \
@@ -357,7 +355,6 @@ EXTRA_DIST = \
 	pcap-rdmasniff.c \
 	pcap-rdmasniff.h \
 	pcap-rpcap.c \
-	pcap-rpcap-int.h \
 	pcap-septel.c \
 	pcap-septel.h \
 	pcap-sita.h \
@@ -423,7 +420,7 @@ EXTRA_DIST = \
 	testprogs/visopts.py \
 	testprogs/writecaptest.c
 
-TEST_DIST = `git ls-files tests | grep -v 'tests/\..*'`
+TEST_DIST = `git -C "$$DIR" ls-files tests | grep -v 'tests/\..*'`
 
 RELEASE_FILES = $(COMMON_C_SRC) $(HDR) $(MAN1) $(MAN3PCAP_EXPAND) \
 	$(MAN3PCAP_NOEXPAND) $(MANFILE) $(MANMISC) $(EXTRA_DIST) \
@@ -536,7 +533,7 @@ scanner.o: scanner.c grammar.h
 #
 # and this is an explicit target entry.
 #
-# Therefore, instead of using $<, we explicitly put in $(srcdir)/libpcap.pc.in.
+# Therefore, instead of using $<, we explicitly put in $(srcdir)/grammar.y.in.
 #
 grammar.y: $(srcdir)/grammar.y.in ./config.status
 	@rm -f $@ $@.tmp
@@ -610,8 +607,8 @@ build-rpcapd: libpcap.a
 #
 # Test programs - not built by default, and not installed.
 #
-testprogs: FORCE
-	(cd testprogs; $(MAKE))
+testprogs: FORCE libpcap.a
+	(cd testprogs; $(MAKE) CFLAGS="$(CFLAGS)")
 
 FORCE:
 
@@ -716,31 +713,31 @@ install-shared-sl: libpcap.sl
 	MAJOR_VER=`sed 's/\([0-9][0-9]*\)\..*/\1/' $(srcdir)/VERSION`; \
 	$(INSTALL_PROGRAM) libpcap.$$MAJOR_VER $(DESTDIR)$(libdir)
 	ln -sf libpcap.$$MAJOR_VER $(DESTDIR)$(libdir)/libpcap.sl
+#
+# AIX shared libraries are weird.  They're archive libraries
+# with one or more shared object components.
+#
 install-shared-shareda: libpcap.shareda
-	#
-	# AIX shared libraries are weird.  They're archive libraries
-	# with one or more shared object components.
-	#
 	[ -d $(DESTDIR)$(libdir) ] || \
 	    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))
 	$(INSTALL_PROGRAM) libpcap.shareda $(DESTDIR)$(libdir)/libpcap.a
 install-shared-none:
 
 install-archive: install-archive-$(DYEXT)
+#
+# Most platforms have separate suffixes for shared and
+# archive libraries, so we install both.
+#
 install-archive-so install-archive-dylib install-archive-sl install-archive-none: libpcap.a
-	#
-	# Most platforms have separate suffixes for shared and
-	# archive libraries, so we install both.
-	#
 	[ -d $(DESTDIR)$(libdir) ] || \
 	    (mkdir -p $(DESTDIR)$(libdir); chmod 755 $(DESTDIR)$(libdir))
 	$(INSTALL_DATA) libpcap.a $(DESTDIR)$(libdir)/libpcap.a
 	$(RANLIB) $(DESTDIR)$(libdir)/libpcap.a
+#
+# AIX, however, doesn't, so we don't install the archive
+# library on AIX.
+#
 install-archive-shareda:
-	#
-	# AIX, however, doesn't, so we don't install the archive
-	# library on AIX.
-	#
 
 install-rpcapd:
 	(cd rpcapd; $(MAKE) DESTDIR=$(DESTDIR) install)
@@ -803,14 +800,13 @@ uninstall-rpcapd:
 	(cd rpcapd; $(MAKE) DESTDIR=$(DESTDIR) uninstall)
 
 clean:
-	rm -f $(CLEANFILES)
+	rm -f $(CLEANFILES) config.h.in~ configure~ configure.ac~
 	(cd rpcapd; $(MAKE) clean)
 	(cd testprogs; $(MAKE) clean)
 
 distclean: clean
 	rm -f Makefile grammar.y config.cache config.log config.status \
-	    config.h config.h.in~ configure~ configure.ac~ \
-	    net os-proto.h libpcap.pc pcap-config stamp-h stamp-h.in
+	    config.h os-proto.h libpcap.pc pcap-config stamp-h stamp-h.in
 	rm -f $(MAN3PCAP_EXPAND:.in=) $(MANFILE:.in=) $(MANMISC:.in=)
 	rm -rf autom4te.cache
 	(cd rpcapd; $(MAKE) distclean)
@@ -822,22 +818,116 @@ extags: $(TAGFILES)
 tags: $(TAGFILES)
 	ctags -wtd $(TAGFILES)
 
+#
+# Use git archive piped to tar to construct a subdirectory whose name
+# is libpcap-{release}, containing all the checked-in source files,
+# and then run autoreconf in that directory to generate the configure
+# script and other files from that source. Then remove autom4te.cache,
+# construct the release tarball from that subdirectory, and remove
+# the subdirectory.
+#
+# The --format=tar is to force git archive to write a non-compressed
+# archive, in case the platform's tar command doesn't have built-in
+# decompression.
+#
+# The ^{tree} is there to force git archive not to write out the
+# "helpful" global extended pax header with a commit ID, as not all
+# versions of tar can handle that (Solaris tar can't, for example).
+# (It turns HEAD, or a tag, both of which are apparently "tree-ish"es,
+# into a tree; apparently, unlike HEAD, or a tag, which have a commit
+# ID associated with them, the tree associated with them doesn't have
+# a commit ID, so no commit ID is available to write, and thus
+# git archive doesn't write one.)
+#
 releasetar:
 	@TAG=$(PROG)-`cat VERSION` && \
-	if git show-ref --tags --quiet --verify -- "refs/tags/$$TAG"; then \
-	    git archive --prefix="$$TAG"/ -o "$$TAG".tar.gz "$$TAG" \
-	    $(RELEASE_FILES) && \
+	if [ ! -d .git ]; then echo 'Not in a git clone, stop.'; exit 1; fi && \
+	TMPTESTFILE=`mktemp -t tmptestfile_XXXXXXXX` && \
+	rm -f "$$TMPTESTFILE" && \
+	AUTORECONF_DIR=`dirname "$$TMPTESTFILE"`/"$(PROG)"_build_autoreconf_$$$$ && \
+	DIR=`pwd` && \
+	rm -rf "$$AUTORECONF_DIR" && \
+	mkdir "$$AUTORECONF_DIR" && \
+	cd "$$AUTORECONF_DIR" && \
+	if git -C "$$DIR" show-ref --tags --quiet --verify -- "refs/tags/$$TAG"; then \
+	    (git -C "$$DIR" archive --format=tar --prefix="$$TAG"/ "$$TAG^{tree}" $(RELEASE_FILES) | \
+	     tar xf -) && \
 	    echo "Archive build from tag $$TAG."; \
 	else \
-	    git archive --prefix="$$TAG"/ -o "$$TAG".tar.gz HEAD \
-	    $(RELEASE_FILES) && \
+	    (git -C "$$DIR" archive --format=tar --prefix="$$TAG"/ "HEAD^{tree}" $(RELEASE_FILES) | \
+	     tar xf -) && \
 	    echo "No $$TAG tag. Archive build from HEAD."; \
+	fi && \
+	(cd "$$TAG" && "$${AUTORECONF:-autoreconf}" && rm -rf autom4te.cache) && \
+	tar cf "$$DIR/$$TAG".tar "$$TAG" && \
+	rm -f "$$DIR/$$TAG".tar.gz && \
+	gzip --best "$$DIR/$$TAG".tar && \
+	cd "$$DIR" && \
+	rm -rf "$$AUTORECONF_DIR"
+
+releasecheck: releasetar
+	@TAG=$(PROG)-`cat VERSION` && \
+	INSTALL_DIR=/tmp/install_"$$TAG"_$$$$ && \
+	DIR=`pwd` && \
+	cd /tmp && \
+	rm -rf "$$TAG" && \
+	rm -rf "$$INSTALL_DIR" && \
+	tar xf "$$DIR"/"$$TAG".tar.gz && \
+	cd "$$TAG" && \
+	echo "[$@] $$ touch .devel" && \
+	touch .devel && \
+	echo "[$@] $$ ./configure --enable-remote --quiet --prefix=$$INSTALL_DIR" && \
+	./configure --enable-remote --quiet --prefix="$$INSTALL_DIR" && \
+	echo '[$@] $$ $(MAKE) -s all testprogs' && \
+	$(MAKE) -s all testprogs && \
+	echo '[$@] $$ $(MAKE) -s install' && \
+	$(MAKE) -s install && \
+	cd .. && \
+	rm -rf "$$TAG" && \
+	rm -rf "$$INSTALL_DIR" && \
+	tar xf "$$DIR"/"$$TAG".tar.gz && \
+	cd "$$TAG" && \
+	echo "[$@] $$ touch .devel" && \
+	touch .devel && \
+	mkdir build && \
+	cd build && \
+	echo '[$@] $$ cmake -DENABLE_REMOTE=yes [...] ..' && \
+	cmake -DENABLE_REMOTE=yes \
+	    -DCMAKE_INSTALL_PREFIX="$$INSTALL_DIR" \
+	    -DCMAKE_MESSAGE_LOG_LEVEL=NOTICE \
+	    -DCMAKE_RULE_MESSAGES=OFF \
+	    -DCMAKE_INSTALL_MESSAGE=NEVER \
+	    .. && \
+	echo '[$@] $$ $(MAKE) -s all testprogs' && \
+	$(MAKE) -s all testprogs && \
+	echo '[$@] $$ $(MAKE) -s install' && \
+	$(MAKE) -s install && \
+	cd ../.. && \
+	rm -rf "$$TAG" && \
+	rm -rf "$$INSTALL_DIR" && \
+	echo '[$@] Done.'
+
+whitespacecheck:
+	@# trailing space(s)?
+	@if git grep -I -n ' $$' $$(git ls-files|grep -v '^tests/'); then \
+	    echo 'Error: Trailing space(s).'; \
+	    exit 1; \
+	fi
+	@# trailing tab(s)?
+	@if git grep -I -n '	$$' $$(git ls-files|grep -v '^tests/'); then \
+	    echo 'Error: Trailing tabs(s).'; \
+	    exit 1; \
+	fi
+	@# space(s) before tab(s)?
+	@if git grep -I -n '[ ][	]' $$(git ls-files|grep -v '^tests/'); then \
+	    echo 'Error: space(s) before tab(s).'; \
+	    exit 1; \
 	fi
 
 depend:	$(GENERATED_C_SRC) $(GENHDR)
-	$(MKDEP) -c "$(CC)" -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
+	$(MKDEP) -c $(CC) -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
 	(cd rpcapd; $(MAKE) depend)
 	(cd testprogs; $(MAKE) depend)
 
 shellcheck:
-	shellcheck -f gcc -e SC2006 build.sh build_matrix.sh build_common.sh
+	shellcheck -f gcc -e SC2006 autogen.sh build.sh build_matrix.sh build_common.sh mkdep .ci-coverity-scan-build.sh
diff --git a/TODO b/TODO
index 65e166b6..8fdd1c42 100644
--- a/TODO
+++ b/TODO
@@ -6,10 +6,6 @@ Important stuff (to be done before the next release)
 
 General
 
-- configure should not be in Git. Most open source projects have an
-  autogen.sh script to run autoconf etc. after checkout. I think we
-  should stick to the standard.
-
 - The source files should be better documented. There is no official
   design guideline for what is done where. There should be a common coding
   style (okay, you can guess that by looking at the code) and a guide for
@@ -20,7 +16,6 @@ Less urgent items
 
 - Better documentation and cleanup of the interface. I am seeing a few
   problems at the first glance which needs fixing:
-  + pcap_lookupnet makes little to no sense with protocols != IPv4
   + not very well suited for interactive programs (think ethereal). There
     should be a way for the application to get a file descriptor which it
     has to monitor and a callback in pcap which has to be called on
diff --git a/VERSION b/VERSION
index 18b31142..db77e0ee 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-1.10.4
+1.10.5
diff --git a/aclocal.m4 b/aclocal.m4
index 9ec93c28..374a68db 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -296,7 +296,7 @@ AC_DEFUN(AC_LBL_CHECK_COMPILER_OPT,
 	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
 	#
 	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
+	# but we only require 2.69 or newer for now.
 	#
 	AC_COMPILE_IFELSE(
 	    [AC_LANG_SOURCE([[int main(void) { return 0; }]])],
@@ -836,21 +836,22 @@ AC_DEFUN(AC_LBL_DEVEL,
 		    AC_LBL_CHECK_COMPILER_OPT($1, -W)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wall)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wcomma)
+		    # Warns about safeguards added in case the enums are
+		    # extended
+		    # AC_LBL_CHECK_COMPILER_OPT($1, -Wcovered-switch-default)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wdocumentation)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wformat-nonliteral)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-noreturn)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-prototypes)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wmissing-variable-declarations)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wnull-pointer-subtraction)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wpointer-arith)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wpointer-sign)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wshadow)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wshorten-64-to-32)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wsign-compare)
 		    AC_LBL_CHECK_COMPILER_OPT($1, -Wstrict-prototypes)
-		    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-parameter)
-		    AC_LBL_CHECK_COMPILER_OPT($1, -Wused-but-marked-unused)
-		    # Warns about safeguards added in case the enums are
-		    # extended
-		    # AC_LBL_CHECK_COMPILER_OPT($1, -Wcovered-switch-default)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wundef)
 		    #
 		    # This can cause problems with ntohs(), ntohl(),
 		    # htons(), and htonl() on some platforms, such
@@ -863,7 +864,7 @@ AC_DEFUN(AC_LBL_DEVEL,
 		    # on whether it is, does a compile-time swap or
 		    # a run-time swap; perhaps the compiler always
 		    # considers one of the two results of the
-		    # conditional expressin is never evaluated,
+		    # conditional expression is never evaluated,
 		    # because the conditional check is done at
 		    # compile time, and thus always says "that
 		    # expression is never executed".
@@ -886,7 +887,10 @@ testme(unsigned short a)
 }
 		      ],
 		      [generates warnings from ntohs()])
-		    AC_LBL_CHECK_COMPILER_OPT($1, -Wshorten-64-to-32)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-but-set-parameter)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-but-set-variable)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wunused-parameter)
+		    AC_LBL_CHECK_COMPILER_OPT($1, -Wused-but-marked-unused)
 	    fi
 	    AC_LBL_CHECK_DEPENDENCY_GENERATION_OPT()
 	    #
@@ -975,35 +979,44 @@ fi
 dnl
 dnl AC_LBL_LIBRARY_NET
 dnl
-dnl This test is for network applications that need socket functions and
-dnl getaddrinfo()/getnameinfo()-ish functions.  We now require
-dnl getaddrinfo() and getnameinfo().  We also prefer versions of
-dnl recvmsg() that conform to the Single UNIX Specification, so that we
-dnl can check whether a datagram received with recvmsg() was truncated
-dnl when received due to the buffer being too small.
+dnl Look for various networking-related libraries that we may need.
+dnl
+dnl We need getaddrinfo() to translate host names in filters to IP
+dnl addresses. We use getaddrinfo() because we want a portable
+dnl thread-safe way of getting information for a host name or port;
+dnl there exist _r versions of gethostbyname() and getservbyname() on
+dnl some platforms, but not on all platforms.
 dnl
-dnl On most operating systems, they're available in the system library.
+dnl We may also need socket() and other socket functions to support:
 dnl
-dnl Under Solaris, we need to link with libsocket and libnsl to get
-dnl getaddrinfo() and getnameinfo() and, if we have libxnet, we need to
-dnl link with libxnet before libsocket to get a version of recvmsg()
-dnl that conforms to the Single UNIX Specification.
+dnl   Local packet capture with capture mechanisms that use sockets.
 dnl
-dnl We use getaddrinfo() because we want a portable thread-safe way
-dnl of getting information for a host name or port; there exist _r
-dnl versions of gethostbyname() and getservbyname() on some platforms,
-dnl but not on all platforms.
+dnl   Local capture device enumeration if a socket call is needed to
+dnl   enumerate devices or get device attributes.
+dnl
+dnl   Packet capture from services that put captured packets on the
+dnl   network, such as rpcap servers.
+dnl
+dnl We may also need getnameinfo() for packet capture from services
+dnl that put packets on the network.
 dnl
 AC_DEFUN(AC_LBL_LIBRARY_NET, [
     #
-    # Most operating systems have getaddrinfo() in the default searched
-    # libraries (i.e. libc).  Check there first.
+    # Most operating systems have getaddrinfo(), and the other routines
+    # we may need, in the default searched libraries (e.g., libc).
+    # Check there first.
     #
     AC_CHECK_FUNC(getaddrinfo,,
     [
 	#
 	# Not found in the standard system libraries.
-	# Try libsocket, which requires libnsl.
+	#
+	# In some versions of Solaris, we need to link with libsocket
+	# and libnsl, so check in libsocket and also link with liblnsl
+	# when doing this test.
+	#
+	# Linking with libsocket and libnsl will find all the routines
+	# we need.
 	#
 	AC_CHECK_LIB(socket, getaddrinfo,
 	[
@@ -1017,6 +1030,9 @@ AC_DEFUN(AC_LBL_LIBRARY_NET, [
 	    # Not found in libsocket; test for it in libnetwork, which
 	    # is where it is in Haiku.
 	    #
+	    # Linking with libnetwork will find all the routines we
+	    # need.
+	    #
 	    AC_CHECK_LIB(network, getaddrinfo,
 	    [
 		#
@@ -1033,18 +1049,36 @@ AC_DEFUN(AC_LBL_LIBRARY_NET, [
 	], -lnsl)
 
 	#
-	# OK, do we have recvmsg() in libxnet?
-	# We also link with libsocket and libnsl.
+	# We require a version of recvmsg() that conforms to the Single
+	# UNIX Specification, so that we can check whether a datagram
+	# received with recvmsg() was truncated when received due to the
+	# buffer being too small.
+	#
+	# On most systems, the version of recvmsg() in the libraries
+	# found above conforms to the SUS.
+	#
+	# On at least some versions of Solaris, it does not conform to
+	# the SUS, and we need the version in libxnet, which does
+	# conform.
+	#
+	# Check whether libxnet exists and has a version of recvmsg();
+	# if it does, link with libxnet before we link with libsocket,
+	# to get that version.
+	#
+	# This test also links with libsocket and libnsl.
 	#
 	AC_CHECK_LIB(xnet, recvmsg,
 	[
 	    #
-	    # Yes - link with it as well.
+	    # libxnet has recvmsg(); link with it as well.
 	    #
 	    LIBS="-lxnet $LIBS"
 	], , -lsocket -lnsl)
     ])
-    # DLPI needs putmsg under HPUX so test for -lstr while we're at it
+
+    #
+    # DLPI needs putmsg under HP-UX, so test for -lstr while we're at it.
+    #
     AC_SEARCH_LIBS(putmsg, str)
 ])
 
@@ -1128,12 +1162,12 @@ if test -n "$PKG_CONFIG"; then
 fi[]dnl
 ])dnl PKG_PROG_PKG_CONFIG
 
-dnl PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+dnl PKG_CHECK_EXISTS(MODULE, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
 dnl -------------------------------------------------------------------
 dnl Since: 0.18
 dnl
-dnl Check to see whether a particular set of modules exists. Similar to
-dnl PKG_CHECK_MODULES(), but does not set variables or print errors.
+dnl Check to see whether a particular module exists. Similar to
+dnl PKG_CHECK_MODULE(), but does not set variables or print errors.
 AC_DEFUN([PKG_CHECK_EXISTS],
 [
 if test -n "$PKG_CONFIG" && \
@@ -1143,7 +1177,34 @@ m4_ifvaln([$3], [else
   $3])dnl
 fi])
 
-dnl _PKG_CONFIG([VARIABLE], [FLAGS], [MODULES])
+dnl _PKG_CONFIG_WITH_FLAGS([VARIABLE], [FLAGS], [MODULE])
+dnl ---------------------------------------------
+dnl Internal wrapper calling pkg-config via PKG_CONFIG and, if
+dnl pkg-config fails, reporting the error and quitting.
+m4_define([_PKG_CONFIG_WITH_FLAGS],
+[if test ! -n "$$1"; then
+    $1=`$PKG_CONFIG $2 "$3" 2>/dev/null`
+    if test "x$?" != "x0"; then
+        #
+        # That failed - report an error.
+        # Re-run the command, telling pkg-config to print an error
+        # message, capture the error message, and report it.
+        # This causes the configuration script to fail, as it means
+        # the script is almost certainly doing something wrong.
+        #
+        _PKG_SHORT_ERRORS_SUPPORTED
+	if test $_pkg_short_errors_supported = yes; then
+	    _pkg_error_string=`$PKG_CONFIG --short-errors --print-errors $2 "$3" 2>&1`
+	else
+	    _pkg_error_string=`$PKG_CONFIG --print-errors $2 "$3" 2>&1`
+	fi
+        AC_MSG_ERROR([$PKG_CONFIG $2 "$3" failed: $_pkg_error_string])
+    fi
+ fi[]dnl
+])dnl _PKG_CONFIG_WITH_FLAGS
+
+
+dnl _PKG_CONFIG([VARIABLE], [FLAGS], [MODULE])
 dnl ---------------------------------------------
 dnl Internal wrapper calling pkg-config via PKG_CONFIG and setting
 dnl pkg_failed based on the result.
@@ -1173,97 +1234,55 @@ fi[]dnl
 ])dnl _PKG_SHORT_ERRORS_SUPPORTED
 
 
-dnl PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl PKG_CHECK_MODULE(VARIABLE-PREFIX, MODULE, [ACTION-IF-FOUND],
 dnl   [ACTION-IF-NOT-FOUND])
 dnl --------------------------------------------------------------
 dnl Since: 0.4.0
-AC_DEFUN([PKG_CHECK_MODULES],
+AC_DEFUN([PKG_CHECK_MODULE],
 [
-AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $2, overriding pkg-config])dnl
-AC_ARG_VAR([$1][_LIBS], [linker flags for $2, overriding pkg-config])dnl
-AC_ARG_VAR([$1][_LIBS_STATIC], [static-link linker flags for $2, overriding pkg-config])dnl
-
-pkg_failed=no
 AC_MSG_CHECKING([for $2 with pkg-config])
-PKG_CHECK_EXISTS($2,
-    [
+if test -n "$PKG_CONFIG"; then
+    AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $2, overriding pkg-config])dnl
+    AC_ARG_VAR([$1][_LIBS], [linker flags for $2, overriding pkg-config])dnl
+    AC_ARG_VAR([$1][_LIBS_STATIC], [static-link linker flags for $2, overriding pkg-config])dnl
+
+    if AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$2"]); then
 	#
 	# The package was found, so try to get its C flags and
 	# libraries.
 	#
-	_PKG_CONFIG([$1][_CFLAGS], [--cflags], [$2])
-	_PKG_CONFIG([$1][_LIBS], [--libs], [$2])
-	_PKG_CONFIG([$1][_LIBS_STATIC], [--libs --static], [$2])
-
-	m4_define([_PKG_TEXT], [
-Alternatively, you may set the environment variables $1[]_CFLAGS
-and $1[]_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.])
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		AC_MSG_RESULT([error])
-		_PKG_SHORT_ERRORS_SUPPORTED
-	        if test $_pkg_short_errors_supported = yes; then
-		        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
-	        else
-		        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
-
-		m4_default([$4], [AC_MSG_ERROR(
-[Package requirements ($2) were not met:
-
-$$1_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-_PKG_TEXT])[]dnl
-        ])
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		AC_MSG_RESULT([not found (pkg-config not found)])
-	else
-		#
-		# We found the package.
-		#
-		$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
-		$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
-		$1[]_LIBS_STATIC=$pkg_cv_[]$1[]_LIBS_STATIC
-	        AC_MSG_RESULT([found])
-		$3
-	fi[]dnl
-    ],
-    [
-	#
-	# The package isn't present.
-	#
-	AC_MSG_RESULT([not found])
-    ])
-])dnl PKG_CHECK_MODULES
+        AC_MSG_RESULT([found])
+	_PKG_CONFIG_WITH_FLAGS([$1][_CFLAGS], [--cflags], [$2])
+	_PKG_CONFIG_WITH_FLAGS([$1][_LIBS], [--libs], [$2])
+	_PKG_CONFIG_WITH_FLAGS([$1][_LIBS_STATIC], [--libs --static], [$2])
+        m4_default([$3], [:])
+    else
+        AC_MSG_RESULT([not found])
+        m4_default([$4], [:])
+    fi
+else
+    # No pkg-config, so obviously not found with pkg-config.
+    AC_MSG_RESULT([pkg-config not found])
+    m4_default([$4], [:])
+fi
+])dnl PKG_CHECK_MODULE
 
 
-dnl PKG_CHECK_MODULES_STATIC(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl PKG_CHECK_MODULE_STATIC(VARIABLE-PREFIX, MODULE, [ACTION-IF-FOUND],
 dnl   [ACTION-IF-NOT-FOUND])
 dnl ---------------------------------------------------------------------
 dnl Since: 0.29
 dnl
-dnl Checks for existence of MODULES and gathers its build flags with
+dnl Checks for existence of MODULE and gathers its build flags with
 dnl static libraries enabled. Sets VARIABLE-PREFIX_CFLAGS from --cflags
 dnl and VARIABLE-PREFIX_LIBS from --libs.
-AC_DEFUN([PKG_CHECK_MODULES_STATIC],
+AC_DEFUN([PKG_CHECK_MODULE_STATIC],
 [
 _save_PKG_CONFIG=$PKG_CONFIG
 PKG_CONFIG="$PKG_CONFIG --static"
-PKG_CHECK_MODULES($@)
+PKG_CHECK_MODULE($@)
 PKG_CONFIG=$_save_PKG_CONFIG[]dnl
-])dnl PKG_CHECK_MODULES_STATIC
+])dnl PKG_CHECK_MODULE_STATIC
 
 
 dnl PKG_INSTALLDIR([DIRECTORY])
diff --git a/atmuni31.h b/atmuni31.h
index 7d4f270b..83208d1f 100644
--- a/atmuni31.h
+++ b/atmuni31.h
@@ -68,7 +68,7 @@
 #define B_BEARER		0x5e	/* broadband bearer capability */
 #define B_LOWER			0x5f	/* broadband lower information */
 #define CALLING_PARTY		0x6c	/* calling party number */
-#define CALLED_PARTY		0x70	/* called party nmber */
+#define CALLED_PARTY		0x70	/* called party number */
 
 #define Q2931			0x09
 
diff --git a/autogen.sh b/autogen.sh
new file mode 100755
index 00000000..c84a6b5c
--- /dev/null
+++ b/autogen.sh
@@ -0,0 +1,25 @@
+#!/bin/sh -e
+
+: "${AUTORECONF:=autoreconf}"
+
+AUTORECONFVERSION=`$AUTORECONF --version 2>&1 | grep "^autoreconf" | sed 's/.*) *//'`
+
+maj=`echo "$AUTORECONFVERSION" | cut -d. -f1`
+min=`echo "$AUTORECONFVERSION" | cut -d. -f2`
+# The minimum required version of autoconf is currently 2.69.
+if [ "$maj" = "" ] || [ "$min" = "" ] || \
+   [ "$maj" -lt 2 ] || { [ "$maj" -eq 2 ] && [ "$min" -lt 69 ]; }; then
+	cat >&2 <<-EOF
+	Please install the 'autoconf' package version 2.69 or later.
+	If version 2.69 or later is already installed and there is no
+	autoconf default, it may be necessary to set the AUTORECONF
+	environment variable to enable the one to use, like:
+	AUTORECONF=autoreconf-2.69 ./autogen.sh
+	or
+	AUTORECONF=autoreconf-2.71 ./autogen.sh
+	EOF
+	exit 1
+fi
+
+echo "$AUTORECONF identification: $AUTORECONFVERSION"
+"$AUTORECONF" -f
diff --git a/bpf_dump.c b/bpf_dump.c
index a9c91169..79a5a342 100644
--- a/bpf_dump.c
+++ b/bpf_dump.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap.h>
 #include <stdio.h>
diff --git a/bpf_filter.c b/bpf_filter.c
index 8691d0d1..9b899bbb 100644
--- a/bpf_filter.c
+++ b/bpf_filter.c
@@ -38,9 +38,7 @@
  *	@(#)bpf.c	7.5 (Berkeley) 7/15/91
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap/pcap-inttypes.h>
 #include "pcap-types.h"
@@ -86,11 +84,11 @@ enum {
  */
 #if defined(SKF_AD_VLAN_TAG_PRESENT)
 u_int
-pcap_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,
+pcapint_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,
     u_int wirelen, u_int buflen, const struct pcap_bpf_aux_data *aux_data)
 #else
 u_int
-pcap_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,
+pcapint_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,
     u_int wirelen, u_int buflen, const struct pcap_bpf_aux_data *aux_data _U_)
 #endif
 {
@@ -388,10 +386,10 @@ DIAG_ON_DEFAULT_ONLY_SWITCH
 }
 
 u_int
-pcap_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
+pcapint_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
     u_int buflen)
 {
-	return pcap_filter_with_aux_data(pc, p, wirelen, buflen, NULL);
+	return pcapint_filter_with_aux_data(pc, p, wirelen, buflen, NULL);
 }
 
 /*
@@ -406,7 +404,7 @@ pcap_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
  * Otherwise, a bogus program could easily crash the system.
  */
 int
-pcap_validate_filter(const struct bpf_insn *f, int len)
+pcapint_validate_filter(const struct bpf_insn *f, int len)
 {
 	u_int i, from;
 	const struct bpf_insn *p;
@@ -536,11 +534,11 @@ u_int
 bpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,
     u_int buflen)
 {
-	return pcap_filter(pc, p, wirelen, buflen);
+	return pcapint_filter(pc, p, wirelen, buflen);
 }
 
 int
 bpf_validate(const struct bpf_insn *f, int len)
 {
-	return pcap_validate_filter(f, len);
+	return pcapint_validate_filter(f, len);
 }
diff --git a/bpf_image.c b/bpf_image.c
index e48c76d5..38eb857b 100644
--- a/bpf_image.c
+++ b/bpf_image.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 
@@ -44,6 +42,8 @@
 
 #include "pcap-int.h"
 
+#include "thread-local.h"
+
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
 #endif
@@ -130,7 +130,7 @@ char *
 bpf_image(const struct bpf_insn *p, int n)
 {
 	const char *op;
-	static char image[256];
+	static thread_local char image[256];
 	char operand_buf[64];
 	const char *operand;
 
diff --git a/build.sh b/build.sh
index 1af10ca0..defa21be 100755
--- a/build.sh
+++ b/build.sh
@@ -1,12 +1,17 @@
 #!/bin/sh -e
 
-# This script runs one build with setup environment variables: CC, CMAKE and
-# REMOTE.
+# This script runs one build with setup environment variables: CC, CMAKE, IPV6
+# and REMOTE.
 : "${CC:=gcc}"
 : "${CMAKE:=no}"
+: "${IPV6:=no}"
 : "${REMOTE:=no}"
 : "${LIBPCAP_TAINTED:=no}"
+: "${LIBPCAP_CMAKE_TAINTED:=no}"
 : "${MAKE_BIN:=make}"
+# At least one OS (AIX 7) where this software can build does not have at least
+# one command (mktemp) required for a successful run of "make releasetar".
+: "${TEST_RELEASETAR:=yes}"
 
 . ./build_common.sh
 # Install directory prefix
@@ -24,96 +29,32 @@ print_cc_version
 # later warnings in the same matrix subset trigger an error.
 # shellcheck disable=SC2221,SC2222
 case `cc_id`/`os_id` in
-gcc-*/Linux-*)
-    # This warning is a bit odd.  It is steadily present in Cirrus CI, but not
-    # in Buildbot.  On my Linux system with the same exact distribution and GCC
-    # as Cirrus CI it reproduces only if GCC receives the "-g" flag:
-    # make CFLAGS=-g -- does not reproduce
-    # CFLAGS=-g make -- reproduces
-    # make -- reproduces
-    #
-    # pcap-linux.c:947:8: warning: ignoring return value of 'write', declared
-    # with attribute warn_unused_result [-Wunused-result]
-    #
-    # And even this way it does not make GCC exit with an error when it has
-    # reported the warning and has received the "-Werror" flag. So let's keep
-    # this block no-op for now.
-    ;;
-clang-*/NetBSD-*)
-    # pcap-bpf.c:1044:18: warning: implicit conversion loses integer precision:
-    # 'uint64_t' (aka 'unsigned long') to 'u_int' (aka 'unsigned int')
-    # [-Wshorten-64-to-32]
-    # pcap-bpf.c:1045:18: warning: implicit conversion loses integer precision:
-    # 'uint64_t' (aka 'unsigned long') to 'u_int' (aka 'unsigned int')
-    # [-Wshorten-64-to-32]
-    # pcap-bpf.c:1274:39: warning: implicit conversion loses integer precision:
-    # 'long' to 'suseconds_t' (aka 'int') [-Wshorten-64-to-32]
+tcc-*/*)
+    # At least one warning is expected because TCC does not implement
+    # thread-local storage.
     LIBPCAP_TAINTED=yes
     ;;
-clang-15.*/*)
-    # grammar.c:1369:14: warning: variable 'pcap_nerrs' set but not used
-    #   [-Wunused-but-set-variable]
-    LIBPCAP_TAINTED=yes
+*)
     ;;
+esac
+[ "$LIBPCAP_TAINTED" != yes ] && CFLAGS=`cc_werr_cflags`
+
+case `cc_id`/`os_id` in
 clang-*/SunOS-5.11)
-    # (Solaris 11 and OpenIndiana)
-    # pcap-bpf.c:1044:18: warning: implicit conversion loses integer precision:
-    #   'uint64_t' (aka 'unsigned long') to 'u_int' (aka 'unsigned int')
-    #   [-Wshorten-64-to-32]
-    # pcap-bpf.c:1045:18: warning: implicit conversion loses integer precision:
-    #   'uint64_t' (aka 'unsigned long') to 'u_int' (aka 'unsigned int')
-    #   [-Wshorten-64-to-32]
-    # fad-getad.c:266:52: warning: implicit conversion loses integer precision:
-    #   'uint64_t'(aka 'unsigned long') to 'bpf_u_int32' (aka 'unsigned int')
-    #   [-Wshorten-64-to-32]
-    # (Solaris 11)
-    # pcap-bpf.c:1843:22: warning: implicit conversion loses integer precision:
-    #   'long' to 'int' [-Wshorten-64-to-32]
-    # (OpenIndiana)
-    # rpcapd.c:393:18: warning: this function declaration is not a prototype
-    #   [-Wstrict-prototypes]
-    [ "`uname -p`" = i386 ] && LIBPCAP_TAINTED=yes
-    ;;
-suncc-5.1[45]/SunOS-5.11)
-    # "scanner.l", line 257: warning: statement not reached
-    # (186 warnings for scanner.l)
-    #
-    # "./filtertest.c", line 259: warning: statement not reached
-    # "./filtertest.c", line 276: warning: statement not reached
-    # "./filtertest.c", line 281: warning: statement not reached
-    LIBPCAP_TAINTED=yes
-    ;;
-*/Haiku-*)
-    # (GCC 8.3.0 and later, Clang 9.0.1.)
-    # pcap-haiku.cpp:55:21: warning: unused variable 'handlep' [-Wunused-variable]
-    # pcap-haiku.cpp:50:37: warning: unused parameter 'maxPackets' [-Wunused-parameter]
-    # pcap-haiku.cpp:111:47: warning: unused parameter 'buffer' [-Wunused-parameter]
-    # pcap-haiku.cpp:111:59: warning: unused parameter 'size' [-Wunused-parameter]
-    # pcap-haiku.cpp:268:26: warning: unused parameter 'name' [-Wunused-parameter]
-    # pcap-haiku.cpp:274:26: warning: unused parameter 'name' [-Wunused-parameter]
-    # pcap-haiku.cpp:274:58: warning: unused parameter 'errbuf' [-Wunused-parameter]
-    #
-    # (The warnings below come from GCC and Clang in CMake builds after installing
-    # all system updates.)
-    # gencode.c:4143:9: warning: converting a packed 'struct in6_addr' pointer
-    #   (alignment 1) to a 'uint32_t' {aka 'unsigned int'} pointer (alignment 4) may
-    #   result in an unaligned pointer value [-Waddress-of-packed-member]
-    # gencode.c:4144:9: warning: converting a packed 'struct in6_addr' pointer
-    #   (alignment 1) to a 'uint32_t' {aka 'unsigned int'} pointer (alignment 4) may
-    #   result in an unaligned pointer value [-Waddress-of-packed-member]
-    # gencode.c:7189:9: warning: converting a packed 'struct in6_addr' pointer
-    #   (alignment 1) to a 'uint32_t' {aka 'unsigned int'} pointer (alignment 4) may
-    #   result in an unaligned pointer value [-Waddress-of-packed-member]
-    # gencode.c:7190:9: warning: converting a packed 'struct in6_addr' pointer
-    #   (alignment 1) to a 'uint32_t' {aka 'unsigned int'} pointer (alignment 4) may
-    #   result in an unaligned pointer value [-Waddress-of-packed-member]
-    LIBPCAP_TAINTED=yes
+    # Work around https://www.illumos.org/issues/16369
+    [ "`uname -o`" = illumos ] && grep -Fq OpenIndiana /etc/release && CFLAGS="-Wno-fuse-ld-path${CFLAGS:+ $CFLAGS}"
     ;;
 esac
-[ "$LIBPCAP_TAINTED" != yes ] && CFLAGS=`cc_werr_cflags`
+
+# If necessary, set LIBPCAP_CMAKE_TAINTED here to exempt particular cmake from
+# warnings. Use as specific terms as possible (e.g. some specific version and
+# some specific OS).
+
+[ "$LIBPCAP_CMAKE_TAINTED" != yes ] && CMAKE_OPTIONS='-Werror=dev'
 
 if [ "$CMAKE" = no ]; then
-    run_after_echo ./configure --prefix="$PREFIX" --enable-remote="$REMOTE"
+    run_after_echo ./autogen.sh
+    run_after_echo ./configure --prefix="$PREFIX" --enable-ipv6="$IPV6" --enable-remote="$REMOTE"
 else
     # Remove the leftovers from any earlier in-source builds, so this
     # out-of-source build does not break because of that.
@@ -125,7 +66,8 @@ else
     run_after_echo mkdir build
     run_after_echo cd build
     run_after_echo cmake ${CFLAGS:+-DEXTRA_CFLAGS="$CFLAGS"} \
-        -DCMAKE_INSTALL_PREFIX="$PREFIX" -DENABLE_REMOTE="$REMOTE" ..
+        ${CMAKE_OPTIONS:+"$CMAKE_OPTIONS"} \
+        -DCMAKE_INSTALL_PREFIX="$PREFIX" -DINET6="$IPV6" -DENABLE_REMOTE="$REMOTE" ..
 fi
 run_after_echo "$MAKE_BIN" -s clean
 if [ "$CMAKE" = no ]; then
@@ -137,11 +79,22 @@ else
     run_after_echo "$MAKE_BIN" testprogs
 fi
 run_after_echo "$MAKE_BIN" install
+
+run_after_echo "$PREFIX/bin/pcap-config" --help
+run_after_echo "$PREFIX/bin/pcap-config" --version
+run_after_echo "$PREFIX/bin/pcap-config" --cflags
+run_after_echo "$PREFIX/bin/pcap-config" --libs
+run_after_echo "$PREFIX/bin/pcap-config" --additional-libs
+run_after_echo "$PREFIX/bin/pcap-config" --libs --static
+run_after_echo "$PREFIX/bin/pcap-config" --additional-libs --static
+run_after_echo "$PREFIX/bin/pcap-config" --libs --static-pcap-only
+run_after_echo "$PREFIX/bin/pcap-config" --additional-libs --static-pcap-only
+
 # VALGRIND_CMD is meant either to collapse or to expand.
 # shellcheck disable=SC2086
 if [ "$CMAKE" = no ]; then
     run_after_echo $VALGRIND_CMD testprogs/findalldevstest
-    run_after_echo "$MAKE_BIN" releasetar
+    [ "$TEST_RELEASETAR" = yes ] && run_after_echo "$MAKE_BIN" releasetar
 else
     run_after_echo $VALGRIND_CMD run/findalldevstest
 fi
diff --git a/build_common.sh b/build_common.sh
index b5fa66b6..ce9349ed 100644
--- a/build_common.sh
+++ b/build_common.sh
@@ -45,6 +45,7 @@ mktempdir() {
     *)
         # At least Haiku, Linux and OpenBSD implementations require explicit
         # trailing X'es in the template, so make it the same suffix as above.
+        # XXX - is MSYS2 GNU-based, so that it would be like Linux?
         mktemp -d -t "${mktempdir_prefix}.XXXXXXXX"
         ;;
     esac
@@ -62,7 +63,7 @@ print_sysinfo() {
 cc_version_nocache() {
     : "${CC:?}"
     case `basename "$CC"` in
-    gcc*|egcc*|clang*)
+    gcc*|egcc*|clang*|tcc*)
         # GCC and Clang recognize --version, print to stdout and exit with 0.
         "$CC" --version
         ;;
@@ -94,6 +95,16 @@ cc_version_nocache() {
             ;;
         esac
         ;;
+    cl)
+        # Visual Studio's compiler doesn't have a "print the compiler
+        # version" option, but we can get version information by
+        # running it with no options, sending its standard error to
+        # the standard output, and throwing out the usage message;
+        # as we have MSYS2, we can just "head" it out.
+        #
+        # XXX - does it exit with an error?
+        "$CC" 2>&1 | head -2
+        ;;
     *)
         "$CC" --version || "$CC" -V || :
         ;;
@@ -134,6 +145,23 @@ cc_id_nocache() {
         return
     fi
 
+    cc_id_guessed=`echo "$cc_id_firstline" | sed 's/^Microsoft (R) C\/C++ Optimizing Compiler Version \([0-9\.]*\) .*$/msvc-\1/'`
+    if [ "$cc_id_firstline" != "$cc_id_guessed" ]; then
+        echo "$cc_id_guessed"
+        return
+    fi
+
+    # Examples of installed packages:
+    # "tcc version 0.9.27 (x86_64 Linux)"
+    # "tcc version 0.9.27 2023-07-05 mob@5b28165 (x86_64 OpenBSD)"
+    # Example of a development version:
+    # "tcc version 0.9.28rc 2024-04-28 mob@0aca8611 (x86_64 Linux)"
+    cc_id_guessed=`echo "$cc_id_firstline" | sed 's/^.*tcc version \([0-9\.rc]*\).*$/tcc-\1/'`
+    if [ "$cc_id_firstline" != "$cc_id_guessed" ]; then
+        echo "$cc_id_guessed"
+        return
+    fi
+
     # OpenBSD default GCC:
     # "gcc (GCC) 4.2.1 20070719"
     # RedHat GCC:
@@ -170,7 +198,7 @@ discard_cc_cache() {
 # warnings as errors.
 cc_werr_cflags() {
     case `cc_id` in
-    gcc-*|clang-*)
+    gcc-*|clang-*|tcc-*)
         echo '-Werror'
         ;;
     xlc-*)
@@ -179,7 +207,14 @@ cc_werr_cflags() {
         echo '-qhalt=w'
         ;;
     suncc-*)
-        echo '-errwarn=%all'
+        # GCC and Clang print an identification for every warning, which is
+        # useful for root cause analysis and bug fixing.  Sun C does not do it
+        # by default, but an additional option makes the style more consistent.
+        echo '-errwarn=%all -errtags=yes'
+        ;;
+    msvc-*)
+        # XXX - what?
+        echo ''
         ;;
     esac
 }
@@ -205,19 +240,34 @@ os_id() {
         : "${os_id_version:=`uname -v`}"
         echo "${os_id_version}.${os_id_release}"
         ;;
-    Darwin|NetBSD|OpenBSD|SunOS)
+    Darwin|GNU|OpenBSD|SunOS)
         echo "$os_id_release"
         ;;
-    FreeBSD|Linux)
+    FreeBSD|NetBSD|Linux)
         # Meaningful version is usually the substring before the first dash.
+        # Or the first underscore.
         echo "$os_id_release" | sed 's/^\([0-9\.]*\).*$/\1/'
         ;;
     Haiku)
-        # Meaningful version is the substring before the plus sign.
-        # "hrev55181" stands for "R1/beta3".
-        # "hrev54154" stands for "R1/beta2".
+        # The complete version is a substring before the first space, e.g.:
+        # * "hrevNNNNN" for a release without updates, e.g. hrev56578 for
+        #   R1/beta4, also for a clean build of master branch;
+        # * "hrevNNNNN+MM" for a release with updates;
+        # * "hrevNNNNN-MM" for a build of a branch that is ahead of the master
+        #   branch;
+        # * "hrevNNNNN_MMMM_KK" for a CI build of a Gerrit review;
+        # * something else for a build of a working copy with the changes not
+        #   yet committed.
+        # With this system it is not clear which version components would be
+        # meaningful to relate with the build result, so let's return the
+        # complete version and leave any interpretation to the user.
         : "${os_id_version:=`uname -v`}"
-        echo "$os_id_version" | sed 's/^\(hrev.*\)+.*$/\1/'
+        echo "$os_id_version" | sed -E 's/^(hrev[^ ]+).+$/\1/'
+        ;;
+    MSYS*)
+        # uname -s produces "MSYS_NT-{NT version?}-{build?}
+        # uname -r produces MSYS2 version?
+        echo "$os_id_version", MSYS "$os_id_release"
         ;;
     *)
         echo 'UNKNOWN'
@@ -227,7 +277,8 @@ os_id() {
 
 increment() {
     # No arithmetic expansion in Solaris /bin/sh before 11.
-    echo "${1:?} + 1" | bc
+    # shellcheck disable=SC2003
+    expr "${1:?}" + 1
 }
 
 # Display text in magenta.
@@ -248,6 +299,12 @@ print_so_deps() {
     Darwin-*)
         run_after_echo otool -L "${1:?}"
         ;;
+    Haiku-*)
+        run_after_echo objdump -p "${1:?}"
+        ;;
+    MSYS*)
+        run_after_echo dumpbin /dependents "${1:?}"
+        ;;
     *)
         run_after_echo ldd "${1:?}"
         ;;
diff --git a/build_matrix.sh b/build_matrix.sh
index 60065966..631d1898 100755
--- a/build_matrix.sh
+++ b/build_matrix.sh
@@ -1,11 +1,18 @@
 #!/bin/sh -e
 
 # This script executes the matrix loops, exclude tests and cleaning.
-# The matrix can be configured with the following environment variables: MATRIX_CC,
-# MATRIX_CMAKE and MATRIX_REMOTE.
+# The matrix can be configured with the following environment variables:
+# MATRIX_CC, MATRIX_CMAKE, MATRIX_IPV6 and MATRIX_REMOTE.
 : "${MATRIX_CC:=gcc clang}"
 : "${MATRIX_CMAKE:=no yes}"
+: "${MATRIX_IPV6:=no yes}"
 : "${MATRIX_REMOTE:=no yes}"
+# Set this variable to "yes" before calling this script to disregard all cmake
+# warnings in a particular environment (CI or a local working copy).  Set it
+# to "yes" in this script or in build.sh when a matrix subset is known to be
+# not cmake warning-free because of the version or whatever other factor
+# that the scripts can detect both in and out of CI.
+: "${LIBPCAP_CMAKE_TAINTED:=no}"
 # Set this variable to "yes" before calling this script to disregard all
 # warnings in a particular environment (CI or a local working copy).  Set it
 # to "yes" in this script or in build.sh when a matrix subset is known to be
@@ -16,7 +23,7 @@
 # GNU Make available as "gmake".
 : "${MAKE_BIN:=make}"
 # It calls the build.sh script which runs one build with setup environment
-# variables: CC, CMAKE and REMOTE.
+# variables: CC, CMAKE, IPV6 and REMOTE.
 
 . ./build_common.sh
 print_sysinfo
@@ -28,12 +35,13 @@ if [ -z "$PREFIX" ]; then
 fi
 COUNT=0
 export LIBPCAP_TAINTED
+export LIBPCAP_CMAKE_TAINTED
 if command -v valgrind >/dev/null 2>&1; then
     VALGRIND_CMD="valgrind --leak-check=full --error-exitcode=1"
     export VALGRIND_CMD
 fi
 
-touch .devel configure
+touch .devel
 for CC in $MATRIX_CC; do
     export CC
     discard_cc_cache
@@ -43,18 +51,20 @@ for CC in $MATRIX_CC; do
     fi
     for CMAKE in $MATRIX_CMAKE; do
         export CMAKE
-        for REMOTE in $MATRIX_REMOTE; do
-            export REMOTE
-            COUNT=`increment $COUNT`
-            echo_magenta "===== SETUP $COUNT: CC=$CC CMAKE=$CMAKE REMOTE=$REMOTE =====" >&2
-            # Run one build with setup environment variables: CC, CMAKE and REMOTE
-            run_after_echo ./build.sh
-            echo 'Cleaning...'
-            if [ "$CMAKE" = yes ]; then rm -rf build; else "$MAKE_BIN" distclean; fi
-            purge_directory "$PREFIX"
-            run_after_echo git status -suall
-            # Cancel changes in configure
-            run_after_echo git checkout configure
+        for IPV6 in $MATRIX_IPV6; do
+            export IPV6
+            for REMOTE in $MATRIX_REMOTE; do
+                export REMOTE
+                COUNT=`increment "$COUNT"`
+                echo_magenta "===== SETUP $COUNT: CC=$CC CMAKE=$CMAKE IPV6=$IPV6 REMOTE=$REMOTE =====" >&2
+                # Run one build with setup environment variables: CC, CMAKE,
+                # IPV6 and REMOTE
+                run_after_echo ./build.sh
+                echo 'Cleaning...'
+                if [ "$CMAKE" = yes ]; then rm -rf build; else "$MAKE_BIN" distclean; fi
+                purge_directory "$PREFIX"
+                run_after_echo git status -suall
+            done
         done
     done
 done
diff --git a/charconv.c b/charconv.c
index 5f97509a..98f90232 100644
--- a/charconv.c
+++ b/charconv.c
@@ -185,14 +185,14 @@ utf_8_to_acp_truncated(char *errbuf)
 
 	/*
 	 * Now, convert that to the local code page.
-	 * Use the current thread's code page.  For unconvertable
+	 * Use the current thread's code page.  For unconvertible
 	 * characters, let it pick the "best fit" character.
 	 *
 	 * XXX - we'd like some way to do what utf_16le_to_utf_8_truncated()
 	 * does if the buffer isn't big enough, but we don't want to have
 	 * to handle all local code pages ourselves; doing so requires
 	 * knowledge of all those code pages, including knowledge of how
-	 * characters are formed in thoe code pages so that we can avoid
+	 * characters are formed in those code pages so that we can avoid
 	 * cutting a multi-byte character into pieces.
 	 *
 	 * Converting to an un-truncated string using Windows APIs, and
diff --git a/cmake/Modules/Finddpdk.cmake b/cmake/Modules/Finddpdk.cmake
index 323262af..13ae0e4a 100644
--- a/cmake/Modules/Finddpdk.cmake
+++ b/cmake/Modules/Finddpdk.cmake
@@ -86,7 +86,7 @@ if(dpdk_FOUND)
   # Please keep this in mind when changing any CMake files,
   # and keep in mind what versions of CMake come with, for
   # example, commonly-used versions of commonly-used
-  # Linux distributiions.)
+  # Linux distributions.)
   #
   if(NOT CMAKE_VERSION VERSION_LESS 3.19)
     if(NOT TARGET dpdk::cflags)
diff --git a/cmakeconfig.h.in b/cmakeconfig.h.in
index 4ac85cc5..ae7cf525 100644
--- a/cmakeconfig.h.in
+++ b/cmakeconfig.h.in
@@ -150,6 +150,9 @@
 /* On solaris */
 #cmakedefine HAVE_SOLARIS 1
 
+/* target host supports Solaris "any" device */
+#cmakedefine HAVE_SOLARIS_ANY_DEVICE 1
+
 /* define if we have the Solaris/IRIX getnetbyname_r() */
 #cmakedefine HAVE_SOLARIS_IRIX_GETNETBYNAME_R 1
 
@@ -162,9 +165,6 @@
 /* Define to 1 if you have the <stdlib.h> header file. */
 #cmakedefine HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strerror' function. */
-#cmakedefine HAVE_STRERROR 1
-
 /* Define to 1 if you have the <strings.h> header file. */
 #cmakedefine HAVE_STRINGS_H 1
 
diff --git a/config.guess b/config.guess
index 69188da7..f6d217a4 100755
--- a/config.guess
+++ b/config.guess
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2023 Free Software Foundation, Inc.
+#   Copyright 1992-2024 Free Software Foundation, Inc.
 
 # shellcheck disable=SC2006,SC2268 # see below for rationale
 
-timestamp='2023-01-01'
+timestamp='2024-01-01'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -47,7 +47,7 @@ me=`echo "$0" | sed -e 's,.*/,,'`
 usage="\
 Usage: $0 [OPTION]
 
-Output the configuration name of the system \`$me' is run on.
+Output the configuration name of the system '$me' is run on.
 
 Options:
   -h, --help         print this help, then exit
@@ -60,13 +60,13 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2023 Free Software Foundation, Inc.
+Copyright 1992-2024 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -102,8 +102,8 @@ GUESS=
 # temporary files to be created and, as you can see below, it is a
 # headache to deal with in a portable fashion.
 
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
+# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still
+# use 'HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
@@ -155,6 +155,9 @@ Linux|GNU|GNU/*)
 
 	set_cc_for_build
 	cat <<-EOF > "$dummy.c"
+	#if defined(__ANDROID__)
+	LIBC=android
+	#else
 	#include <features.h>
 	#if defined(__UCLIBC__)
 	LIBC=uclibc
@@ -162,6 +165,8 @@ Linux|GNU|GNU/*)
 	LIBC=dietlibc
 	#elif defined(__GLIBC__)
 	LIBC=gnu
+	#elif defined(__LLVM_LIBC__)
+	LIBC=llvm
 	#else
 	#include <stdarg.h>
 	/* First heuristic to detect musl libc.  */
@@ -169,6 +174,7 @@ Linux|GNU|GNU/*)
 	LIBC=musl
 	#endif
 	#endif
+	#endif
 	EOF
 	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
 	eval "$cc_set_libc"
@@ -459,7 +465,7 @@ case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
+	# Japanese Language versions have a version number like '4.1.3-JL'.
 	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
 	GUESS=sparc-sun-sunos$SUN_REL
 	;;
@@ -904,7 +910,7 @@ EOF
 	fi
 	;;
     *:FreeBSD:*:*)
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	UNAME_PROCESSOR=`uname -p`
 	case $UNAME_PROCESSOR in
 	    amd64)
 		UNAME_PROCESSOR=x86_64 ;;
@@ -976,7 +982,27 @@ EOF
 	GUESS=$UNAME_MACHINE-unknown-minix
 	;;
     aarch64:Linux:*:*)
-	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	set_cc_for_build
+	CPU=$UNAME_MACHINE
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __ARM_EABI__
+	    #ifdef __ARM_PCS_VFP
+	    ABI=eabihf
+	    #else
+	    ABI=eabi
+	    #endif
+	    #endif
+EOF
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		eabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;
+	    esac
+	fi
+	GUESS=$CPU-unknown-linux-$LIBCABI
 	;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
@@ -1042,6 +1068,15 @@ EOF
     k1om:Linux:*:*)
 	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	;;
+    kvx:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    kvx:cos:*:*)
+	GUESS=$UNAME_MACHINE-unknown-cos
+	;;
+    kvx:mbr:*:*)
+	GUESS=$UNAME_MACHINE-unknown-mbr
+	;;
     loongarch32:Linux:*:* | loongarch64:Linux:*:*)
 	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	;;
@@ -1197,7 +1232,7 @@ EOF
 	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
 	;;
     i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
+	# If we were able to find 'uname', then EMX Unix compatibility
 	# is probably installed.
 	GUESS=$UNAME_MACHINE-pc-os2-emx
 	;;
@@ -1338,7 +1373,7 @@ EOF
 		GUESS=ns32k-sni-sysv
 	fi
 	;;
-    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+    PENTIUM:*:4.0*:*)	# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort
 			# says <Richard.M.Bartel@ccMail.Census.GOV>
 	GUESS=i586-unisys-sysv4
 	;;
@@ -1560,6 +1595,9 @@ EOF
     *:Unleashed:*:*)
 	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
 	;;
+    *:Ironclad:*:*)
+	GUESS=$UNAME_MACHINE-unknown-ironclad
+	;;
 esac
 
 # Do we have a guess based on uname results?
diff --git a/config.h b/config.h
index 2ebacd86..0dd3eea1 100644
--- a/config.h
+++ b/config.h
@@ -7,6 +7,9 @@
 /* Enable optimizer debugging */
 /* #undef BDEBUG */
 
+/* define if you want to build the instrument functions code */
+/* #undef ENABLE_INSTRUMENT_FUNCTIONS */
+
 /* Define to 1 if remote packet capture is to be supported */
 /* #undef ENABLE_REMOTE */
 
@@ -105,9 +108,6 @@
 /* Define to 1 if you have the <linux/wireless.h> header file. */
 #define HAVE_LINUX_WIRELESS_H 1
 
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
 /* Define to 1 if you have the <netpacket/packet.h> header file. */
 #define HAVE_NETPACKET_PACKET_H 1
 
@@ -159,6 +159,9 @@
 /* On solaris */
 /* #undef HAVE_SOLARIS */
 
+/* target host supports Solaris "any" device */
+/* #undef HAVE_SOLARIS_ANY_DEVICE */
+
 /* define if we have the Solaris/IRIX getnetbyname_r() */
 /* #undef HAVE_SOLARIS_IRIX_GETNETBYNAME_R */
 
@@ -168,12 +171,12 @@
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
 /* Define to 1 if you have the <strings.h> header file. */
 #define HAVE_STRINGS_H 1
 
@@ -209,7 +212,7 @@
 /* #undef HAVE_STRUCT_RTE_ETHER_ADDR */
 
 /* Define to 1 if `hci_channel' is a member of `struct sockaddr_hci'. */
-/* #undef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL */
+#define HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL 1
 
 /* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
 /* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
@@ -291,7 +294,7 @@
 #define PACKAGE_NAME "pcap"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "pcap 1.10.4"
+#define PACKAGE_STRING "pcap 1.10.5"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "pcap"
@@ -300,7 +303,7 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "1.10.4"
+#define PACKAGE_VERSION "1.10.5"
 
 /* target host supports Bluetooth sniffing */
 /* #undef PCAP_SUPPORT_BT */
@@ -311,6 +314,9 @@
 /* support D-Bus sniffing */
 /* #undef PCAP_SUPPORT_DBUS */
 
+/* target host supports DPDK */
+/* #undef PCAP_SUPPORT_DPDK */
+
 /* target host supports Linux usbmon for USB sniffing */
 #define PCAP_SUPPORT_LINUX_USBMON 1
 
@@ -323,10 +329,15 @@
 /* target host supports RDMA sniffing */
 /* #undef PCAP_SUPPORT_RDMASNIFF */
 
-/* The size of `const void *', as computed by sizeof. */
-/* #undef SIZEOF_CONST_VOID_P */
+/* The size of `time_t', as computed by sizeof. */
+/* #undef SIZEOF_TIME_T */
+
+/* The size of `void *', as computed by sizeof. */
+/* #undef SIZEOF_VOID_P */
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C90 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #define STDC_HEADERS 1
 
 /* Define to 1 if strings.h declares `ffs' */
@@ -342,11 +353,6 @@
    `char[]'. */
 #define YYTEXT_POINTER 1
 
-/* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef _DARWIN_USE_64_BIT_INODE
-# define _DARWIN_USE_64_BIT_INODE 1
-#endif
-
 /* Number of bits in a file offset, on hosts where this is settable. */
 /* #undef _FILE_OFFSET_BITS */
 
diff --git a/config.h.in b/config.h.in
deleted file mode 100644
index 282a9559..00000000
--- a/config.h.in
+++ /dev/null
@@ -1,368 +0,0 @@
-/* config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if arpa/inet.h declares `ether_hostton' */
-#undef ARPA_INET_H_DECLARES_ETHER_HOSTTON
-
-/* Enable optimizer debugging */
-#undef BDEBUG
-
-/* Define to 1 if remote packet capture is to be supported */
-#undef ENABLE_REMOTE
-
-/* define if we have the AIX getnetbyname_r() */
-#undef HAVE_AIX_GETNETBYNAME_R
-
-/* define if we have the AIX getprotobyname_r() */
-#undef HAVE_AIX_GETPROTOBYNAME_R
-
-/* Define to 1 if you have the `asprintf' function. */
-#undef HAVE_ASPRINTF
-
-/* Define to 1 if you have the <config/HaikuConfig.h> header file. */
-#undef HAVE_CONFIG_HAIKUCONFIG_H
-
-/* Define to 1 if you have the <dagapi.h> header file. */
-#undef HAVE_DAGAPI_H
-
-/* define if you have the DAG API */
-#undef HAVE_DAG_API
-
-/* define if you have dag_get_erf_types() */
-#undef HAVE_DAG_GET_ERF_TYPES
-
-/* define if you have dag_get_stream_erf_types() */
-#undef HAVE_DAG_GET_STREAM_ERF_TYPES
-
-/* define if you have large streams capable DAG API */
-#undef HAVE_DAG_LARGE_STREAMS_API
-
-/* define if you have vdag_set_device_info() */
-#undef HAVE_DAG_VDAG
-
-/* Define to 1 if you have the declaration of `ether_hostton' */
-#undef HAVE_DECL_ETHER_HOSTTON
-
-/* Define to 1 if `dl_module_id_1' is a member of `dl_hp_ppa_info_t'. */
-#undef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1
-
-/* Define to 1 if the system has the type `dl_passive_req_t'. */
-#undef HAVE_DL_PASSIVE_REQ_T
-
-/* Define to 1 if you have the `ether_hostton' function. */
-#undef HAVE_ETHER_HOSTTON
-
-/* Define to 1 if you have the `ffs' function. */
-#undef HAVE_FFS
-
-/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
-#undef HAVE_FSEEKO
-
-/* Define to 1 if you have the `getspnam' function. */
-#undef HAVE_GETSPNAM
-
-/* Define to 1 if you have a GNU-style `strerror_r' function. */
-#undef HAVE_GNU_STRERROR_R
-
-/* on HP-UX 10.20 or later */
-#undef HAVE_HPUX10_20_OR_LATER
-
-/* on HP-UX 9.x */
-#undef HAVE_HPUX9
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the `bsd' library (-lbsd). */
-#undef HAVE_LIBBSD
-
-/* if libdlpi exists */
-#undef HAVE_LIBDLPI
-
-/* if libnl exists */
-#undef HAVE_LIBNL
-
-/* Define to 1 if you have the <linux/compiler.h> header file. */
-#undef HAVE_LINUX_COMPILER_H
-
-/* define if we have the Linux getnetbyname_r() */
-#undef HAVE_LINUX_GETNETBYNAME_R
-
-/* define if we have the Linux getprotobyname_r() */
-#undef HAVE_LINUX_GETPROTOBYNAME_R
-
-/* Define to 1 if you have the <linux/net_tstamp.h> header file. */
-#undef HAVE_LINUX_NET_TSTAMP_H
-
-/* Define to 1 if you have the <linux/socket.h> header file. */
-#undef HAVE_LINUX_SOCKET_H
-
-/* Define to 1 if you have the <linux/usbdevice_fs.h> header file. */
-#undef HAVE_LINUX_USBDEVICE_FS_H
-
-/* Define to 1 if you have the <linux/wireless.h> header file. */
-#undef HAVE_LINUX_WIRELESS_H
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the <netpacket/packet.h> header file. */
-#undef HAVE_NETPACKET_PACKET_H
-
-/* Define to 1 if you have the <net/bpf.h> header file. */
-#undef HAVE_NET_BPF_H
-
-/* Define to 1 if you have the <net/enet.h> header file. */
-#undef HAVE_NET_ENET_H
-
-/* Define to 1 if you have the <net/if_dl.h> header file. */
-#undef HAVE_NET_IF_DL_H
-
-/* Define to 1 if you have the <net/if.h> header file. */
-#undef HAVE_NET_IF_H
-
-/* Define to 1 if you have the <net/if_media.h> header file. */
-#undef HAVE_NET_IF_MEDIA_H
-
-/* Define to 1 if you have the <net/if_types.h> header file. */
-#undef HAVE_NET_IF_TYPES_H
-
-/* Define to 1 if you have the <net/nit.h> header file. */
-#undef HAVE_NET_NIT_H
-
-/* Define to 1 if you have the <net/pfilt.h> header file. */
-#undef HAVE_NET_PFILT_H
-
-/* Define to 1 if you have the <net/raw.h> header file. */
-#undef HAVE_NET_RAW_H
-
-/* Use OpenSSL */
-#undef HAVE_OPENSSL
-
-/* if there's an os_proto.h for this platform, to use additional prototypes */
-#undef HAVE_OS_PROTO_H
-
-/* Define to 1 if you have a POSIX-style `strerror_r' function. */
-#undef HAVE_POSIX_STRERROR_R
-
-/* define if you have the Septel API */
-#undef HAVE_SEPTEL_API
-
-/* define if you have the Myricom SNF API */
-#undef HAVE_SNF_API
-
-/* Define to 1 if the system has the type `socklen_t'. */
-#undef HAVE_SOCKLEN_T
-
-/* On solaris */
-#undef HAVE_SOLARIS
-
-/* define if we have the Solaris/IRIX getnetbyname_r() */
-#undef HAVE_SOLARIS_IRIX_GETNETBYNAME_R
-
-/* define if we have the Solaris/IRIX getprotobyname_r() */
-#undef HAVE_SOLARIS_IRIX_GETPROTOBYNAME_R
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strerror' function. */
-#undef HAVE_STRERROR
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strlcat' function. */
-#undef HAVE_STRLCAT
-
-/* Define to 1 if you have the `strlcpy' function. */
-#undef HAVE_STRLCPY
-
-/* Define to 1 if you have the `strtok_r' function. */
-#undef HAVE_STRTOK_R
-
-/* Define to 1 if the system has the type `struct BPF_TIMEVAL'. */
-#undef HAVE_STRUCT_BPF_TIMEVAL
-
-/* Define to 1 if the system has the type `struct ether_addr'. */
-#undef HAVE_STRUCT_ETHER_ADDR
-
-/* Define to 1 if `msg_control' is a member of `struct msghdr'. */
-#undef HAVE_STRUCT_MSGHDR_MSG_CONTROL
-
-/* Define to 1 if `msg_flags' is a member of `struct msghdr'. */
-#undef HAVE_STRUCT_MSGHDR_MSG_FLAGS
-
-/* Define to 1 if the system has the type `struct rte_ether_addr'. */
-#undef HAVE_STRUCT_RTE_ETHER_ADDR
-
-/* Define to 1 if `hci_channel' is a member of `struct sockaddr_hci'. */
-#undef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL
-
-/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
-#undef HAVE_STRUCT_SOCKADDR_SA_LEN
-
-/* Define to 1 if the system has the type `struct sockaddr_storage'. */
-#undef HAVE_STRUCT_SOCKADDR_STORAGE
-
-/* Define to 1 if `tp_vlan_tci' is a member of `struct tpacket_auxdata'. */
-#undef HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI
-
-/* Define to 1 if `bRequestType' is a member of `struct
-   usbdevfs_ctrltransfer'. */
-#undef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
-
-/* Define to 1 if you have the <sys/bufmod.h> header file. */
-#undef HAVE_SYS_BUFMOD_H
-
-/* Define to 1 if you have the <sys/dlpi_ext.h> header file. */
-#undef HAVE_SYS_DLPI_EXT_H
-
-/* Define to 1 if you have the <sys/dlpi.h> header file. */
-#undef HAVE_SYS_DLPI_H
-
-/* Define to 1 if you have the <sys/ioccom.h> header file. */
-#undef HAVE_SYS_IOCCOM_H
-
-/* Define to 1 if you have the <sys/net/nit.h> header file. */
-#undef HAVE_SYS_NET_NIT_H
-
-/* Define to 1 if you have the <sys/sockio.h> header file. */
-#undef HAVE_SYS_SOCKIO_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* define if you have the TurboCap API */
-#undef HAVE_TC_API
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to 1 if you have the `vasprintf' function. */
-#undef HAVE_VASPRINTF
-
-/* Define to 1 if you have the `vsyslog' function. */
-#undef HAVE_VSYSLOG
-
-/* Define to 1 if you have the `_wcserror_s' function. */
-#undef HAVE__WCSERROR_S
-
-/* define if __atomic_load_n is supported by the compiler */
-#undef HAVE___ATOMIC_LOAD_N
-
-/* define if __atomic_store_n is supported by the compiler */
-#undef HAVE___ATOMIC_STORE_N
-
-/* IPv6 */
-#undef INET6
-
-/* Define to 1 if netinet/ether.h declares `ether_hostton' */
-#undef NETINET_ETHER_H_DECLARES_ETHER_HOSTTON
-
-/* Define to 1 if netinet/if_ether.h declares `ether_hostton' */
-#undef NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON
-
-/* Define to 1 if net/ethernet.h declares `ether_hostton' */
-#undef NET_ETHERNET_H_DECLARES_ETHER_HOSTTON
-
-/* do not use protochain */
-#undef NO_PROTOCHAIN
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the home page for this package. */
-#undef PACKAGE_URL
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* target host supports Bluetooth sniffing */
-#undef PCAP_SUPPORT_BT
-
-/* target host supports Bluetooth Monitor */
-#undef PCAP_SUPPORT_BT_MONITOR
-
-/* support D-Bus sniffing */
-#undef PCAP_SUPPORT_DBUS
-
-/* target host supports DPDK */
-#undef PCAP_SUPPORT_DPDK
-
-/* target host supports Linux usbmon for USB sniffing */
-#undef PCAP_SUPPORT_LINUX_USBMON
-
-/* target host supports netfilter sniffing */
-#undef PCAP_SUPPORT_NETFILTER
-
-/* target host supports netmap */
-#undef PCAP_SUPPORT_NETMAP
-
-/* target host supports RDMA sniffing */
-#undef PCAP_SUPPORT_RDMASNIFF
-
-/* The size of `const void *', as computed by sizeof. */
-#undef SIZEOF_CONST_VOID_P
-
-/* The size of `void *', as computed by sizeof. */
-#undef SIZEOF_VOID_P
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Define to 1 if strings.h declares `ffs' */
-#undef STRINGS_H_DECLARES_FFS
-
-/* Define to 1 if sys/ethernet.h declares `ether_hostton' */
-#undef SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON
-
-/* Enable parser debugging */
-#undef YYDEBUG
-
-/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
-   `char[]'. */
-#undef YYTEXT_POINTER
-
-/* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef _DARWIN_USE_64_BIT_INODE
-# define _DARWIN_USE_64_BIT_INODE 1
-#endif
-
-/* Number of bits in a file offset, on hosts where this is settable. */
-#undef _FILE_OFFSET_BITS
-
-/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
-#undef _LARGEFILE_SOURCE
-
-/* Define for large files, on AIX-style hosts. */
-#undef _LARGE_FILES
-
-/* define on AIX to get certain functions */
-#undef _SUN
-
-/* to handle Ultrix compilers that don't support const in prototypes */
-#undef const
-
-/* Define as token for inline if inlining supported */
-#undef inline
-
-/* on sinix */
-#undef sinix
diff --git a/config.sub b/config.sub
index de4259e4..2c6a07ab 100755
--- a/config.sub
+++ b/config.sub
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2023 Free Software Foundation, Inc.
+#   Copyright 1992-2024 Free Software Foundation, Inc.
 
 # shellcheck disable=SC2006,SC2268 # see below for rationale
 
-timestamp='2023-01-21'
+timestamp='2024-01-01'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -76,13 +76,13 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2023 Free Software Foundation, Inc.
+Copyright 1992-2024 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -130,7 +130,7 @@ IFS=$saved_IFS
 # Separate into logical components for further validation
 case $1 in
 	*-*-*-*-*)
-		echo Invalid configuration \`"$1"\': more than four components >&2
+		echo "Invalid configuration '$1': more than four components" >&2
 		exit 1
 		;;
 	*-*-*-*)
@@ -145,7 +145,8 @@ case $1 in
 			nto-qnx* | linux-* | uclinux-uclibc* \
 			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
 			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
-			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-*)
+			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* \
+			| windows-* )
 				basic_machine=$field1
 				basic_os=$maybe_os
 				;;
@@ -943,7 +944,7 @@ $basic_machine
 EOF
 		IFS=$saved_IFS
 		;;
-	# We use `pc' rather than `unknown'
+	# We use 'pc' rather than 'unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
@@ -1180,7 +1181,7 @@ case $cpu-$vendor in
 		case $cpu in
 			1750a | 580 \
 			| a29k \
-			| aarch64 | aarch64_be \
+			| aarch64 | aarch64_be | aarch64c | arm64ec \
 			| abacus \
 			| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \
 			| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \
@@ -1199,12 +1200,14 @@ case $cpu-$vendor in
 			| d10v | d30v | dlx | dsp16xx \
 			| e2k | elxsi | epiphany \
 			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
+			| javascript \
 			| h8300 | h8500 \
 			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 			| hexagon \
 			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
 			| ip2k | iq2000 \
 			| k1om \
+			| kvx \
 			| le32 | le64 \
 			| lm32 \
 			| loongarch32 | loongarch64 \
@@ -1213,36 +1216,13 @@ case $cpu-$vendor in
 			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
 			| m88110 | m88k | maxq | mb | mcore | mep | metag \
 			| microblaze | microblazeel \
-			| mips | mipsbe | mipseb | mipsel | mipsle \
-			| mips16 \
-			| mips64 | mips64eb | mips64el \
-			| mips64octeon | mips64octeonel \
-			| mips64orion | mips64orionel \
-			| mips64r5900 | mips64r5900el \
-			| mips64vr | mips64vrel \
-			| mips64vr4100 | mips64vr4100el \
-			| mips64vr4300 | mips64vr4300el \
-			| mips64vr5000 | mips64vr5000el \
-			| mips64vr5900 | mips64vr5900el \
-			| mipsisa32 | mipsisa32el \
-			| mipsisa32r2 | mipsisa32r2el \
-			| mipsisa32r3 | mipsisa32r3el \
-			| mipsisa32r5 | mipsisa32r5el \
-			| mipsisa32r6 | mipsisa32r6el \
-			| mipsisa64 | mipsisa64el \
-			| mipsisa64r2 | mipsisa64r2el \
-			| mipsisa64r3 | mipsisa64r3el \
-			| mipsisa64r5 | mipsisa64r5el \
-			| mipsisa64r6 | mipsisa64r6el \
-			| mipsisa64sb1 | mipsisa64sb1el \
-			| mipsisa64sr71k | mipsisa64sr71kel \
-			| mipsr5900 | mipsr5900el \
-			| mipstx39 | mipstx39el \
+			| mips* \
 			| mmix \
 			| mn10200 | mn10300 \
 			| moxie \
 			| mt \
 			| msp430 \
+			| nanomips* \
 			| nds32 | nds32le | nds32be \
 			| nfp \
 			| nios | nios2 | nios2eb | nios2el \
@@ -1274,6 +1254,7 @@ case $cpu-$vendor in
 			| ubicom32 \
 			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
 			| vax \
+			| vc4 \
 			| visium \
 			| w65 \
 			| wasm32 | wasm64 \
@@ -1285,7 +1266,7 @@ case $cpu-$vendor in
 				;;
 
 			*)
-				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
+				echo "Invalid configuration '$1': machine '$cpu-$vendor' not recognized" 1>&2
 				exit 1
 				;;
 		esac
@@ -1306,11 +1287,12 @@ esac
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
-if test x$basic_os != x
+if test x"$basic_os" != x
 then
 
 # First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
 # set os.
+obj=
 case $basic_os in
 	gnu/linux*)
 		kernel=linux
@@ -1510,10 +1492,16 @@ case $os in
 			os=eabi
 			;;
 		    *)
-			os=elf
+			os=
+			obj=elf
 			;;
 		esac
 		;;
+	aout* | coff* | elf* | pe*)
+		# These are machine code file formats, not OSes
+		obj=$os
+		os=
+		;;
 	*)
 		# No normalization, but not necessarily accepted, that comes below.
 		;;
@@ -1532,12 +1520,15 @@ else
 # system, and we'll never get to this point.
 
 kernel=
+obj=
 case $cpu-$vendor in
 	score-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	spu-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	*-acorn)
 		os=riscix1.2
@@ -1547,28 +1538,35 @@ case $cpu-$vendor in
 		os=gnu
 		;;
 	arm*-semi)
-		os=aout
+		os=
+		obj=aout
 		;;
 	c4x-* | tic4x-*)
-		os=coff
+		os=
+		obj=coff
 		;;
 	c8051-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	clipper-intergraph)
 		os=clix
 		;;
 	hexagon-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	tic54x-*)
-		os=coff
+		os=
+		obj=coff
 		;;
 	tic55x-*)
-		os=coff
+		os=
+		obj=coff
 		;;
 	tic6x-*)
-		os=coff
+		os=
+		obj=coff
 		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
@@ -1590,19 +1588,24 @@ case $cpu-$vendor in
 		os=sunos3
 		;;
 	m68*-cisco)
-		os=aout
+		os=
+		obj=aout
 		;;
 	mep-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	mips*-cisco)
-		os=elf
+		os=
+		obj=elf
 		;;
-	mips*-*)
-		os=elf
+	mips*-*|nanomips*-*)
+		os=
+		obj=elf
 		;;
 	or32-*)
-		os=coff
+		os=
+		obj=coff
 		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=sysv3
@@ -1611,7 +1614,8 @@ case $cpu-$vendor in
 		os=sunos4.1.1
 		;;
 	pru-*)
-		os=elf
+		os=
+		obj=elf
 		;;
 	*-be)
 		os=beos
@@ -1692,10 +1696,12 @@ case $cpu-$vendor in
 		os=uxpv
 		;;
 	*-rom68k)
-		os=coff
+		os=
+		obj=coff
 		;;
 	*-*bug)
-		os=coff
+		os=
+		obj=coff
 		;;
 	*-apple)
 		os=macos
@@ -1713,10 +1719,11 @@ esac
 
 fi
 
-# Now, validate our (potentially fixed-up) OS.
+# Now, validate our (potentially fixed-up) individual pieces (OS, OBJ).
+
 case $os in
 	# Sometimes we do "kernel-libc", so those need to count as OSes.
-	musl* | newlib* | relibc* | uclibc*)
+	llvm* | musl* | newlib* | relibc* | uclibc*)
 		;;
 	# Likewise for "kernel-abi"
 	eabi* | gnueabi*)
@@ -1724,6 +1731,9 @@ case $os in
 	# VxWorks passes extra cpu info in the 4th filed.
 	simlinux | simwindows | spe)
 		;;
+	# See `case $cpu-$os` validation below
+	ghcjs)
+		;;
 	# Now accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST end in a * to match a version number.
@@ -1732,7 +1742,7 @@ case $os in
 	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
 	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
 	     | hiux* | abug | nacl* | netware* | windows* \
-	     | os9* | macos* | osx* | ios* \
+	     | os9* | macos* | osx* | ios* | tvos* | watchos* \
 	     | mpw* | magic* | mmixware* | mon960* | lnews* \
 	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
 	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
@@ -1741,11 +1751,11 @@ case $os in
 	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
 	     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \
 	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
-	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
-	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
+	     | bosx* | nextstep* | cxux* | oabi* \
+	     | ptx* | ecoff* | winnt* | domain* | vsta* \
 	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
 	     | chorusrdb* | cegcc* | glidix* | serenity* \
-	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
+	     | cygwin* | msys* | moss* | proelf* | rtems* \
 	     | midipix* | mingw32* | mingw64* | mint* \
 	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
 	     | interix* | uwin* | mks* | rhapsody* | darwin* \
@@ -1758,62 +1768,116 @@ case $os in
 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
 	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
 	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
-	     | fiwix* | mlibc* )
+	     | fiwix* | mlibc* | cos* | mbr* | ironclad* )
 		;;
 	# This one is extra strict with allowed versions
 	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
 		# Don't forget version if it is 3.2v4 or newer.
 		;;
+	# This refers to builds using the UEFI calling convention
+	# (which depends on the architecture) and PE file format.
+	# Note that this is both a different calling convention and
+	# different file format than that of GNU-EFI
+	# (x86_64-w64-mingw32).
+	uefi)
+		;;
 	none)
 		;;
-	kernel* )
+	kernel* | msvc* )
 		# Restricted further below
 		;;
+	'')
+		if test x"$obj" = x
+		then
+			echo "Invalid configuration '$1': Blank OS only allowed with explicit machine code file format" 1>&2
+		fi
+		;;
 	*)
-		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
+		echo "Invalid configuration '$1': OS '$os' not recognized" 1>&2
+		exit 1
+		;;
+esac
+
+case $obj in
+	aout* | coff* | elf* | pe*)
+		;;
+	'')
+		# empty is fine
+		;;
+	*)
+		echo "Invalid configuration '$1': Machine code format '$obj' not recognized" 1>&2
+		exit 1
+		;;
+esac
+
+# Here we handle the constraint that a (synthetic) cpu and os are
+# valid only in combination with each other and nowhere else.
+case $cpu-$os in
+	# The "javascript-unknown-ghcjs" triple is used by GHC; we
+	# accept it here in order to tolerate that, but reject any
+	# variations.
+	javascript-ghcjs)
+		;;
+	javascript-* | *-ghcjs)
+		echo "Invalid configuration '$1': cpu '$cpu' is not valid with os '$os$obj'" 1>&2
 		exit 1
 		;;
 esac
 
 # As a final step for OS-related things, validate the OS-kernel combination
 # (given a valid OS), if there is a kernel.
-case $kernel-$os in
-	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
-		   | linux-musl* | linux-relibc* | linux-uclibc* | linux-mlibc* )
+case $kernel-$os-$obj in
+	linux-gnu*- | linux-android*- | linux-dietlibc*- | linux-llvm*- \
+		    | linux-mlibc*- | linux-musl*- | linux-newlib*- \
+		    | linux-relibc*- | linux-uclibc*- )
 		;;
-	uclinux-uclibc* )
+	uclinux-uclibc*- )
 		;;
-	managarm-mlibc* | managarm-kernel* )
+	managarm-mlibc*- | managarm-kernel*- )
 		;;
-	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )
+	windows*-msvc*-)
+		;;
+	-dietlibc*- | -llvm*- | -mlibc*- | -musl*- | -newlib*- | -relibc*- \
+		    | -uclibc*- )
 		# These are just libc implementations, not actual OSes, and thus
 		# require a kernel.
-		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
+		echo "Invalid configuration '$1': libc '$os' needs explicit kernel." 1>&2
 		exit 1
 		;;
-	-kernel* )
-		echo "Invalid configuration \`$1': \`$os' needs explicit kernel." 1>&2
+	-kernel*- )
+		echo "Invalid configuration '$1': '$os' needs explicit kernel." 1>&2
 		exit 1
 		;;
-	*-kernel* )
-		echo "Invalid configuration \`$1': \`$kernel' does not support \`$os'." 1>&2
+	*-kernel*- )
+		echo "Invalid configuration '$1': '$kernel' does not support '$os'." 1>&2
 		exit 1
 		;;
-	kfreebsd*-gnu* | kopensolaris*-gnu*)
+	*-msvc*- )
+		echo "Invalid configuration '$1': '$os' needs 'windows'." 1>&2
+		exit 1
 		;;
-	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
+	kfreebsd*-gnu*- | kopensolaris*-gnu*-)
 		;;
-	nto-qnx*)
+	vxworks-simlinux- | vxworks-simwindows- | vxworks-spe-)
 		;;
-	os2-emx)
+	nto-qnx*-)
+		;;
+	os2-emx-)
+		;;
+	*-eabi*- | *-gnueabi*-)
 		;;
-	*-eabi* | *-gnueabi*)
+	none--*)
+		# None (no kernel, i.e. freestanding / bare metal),
+		# can be paired with an machine code file format
 		;;
-	-*)
+	-*-)
 		# Blank kernel with real OS is always fine.
 		;;
-	*-*)
-		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
+	--*)
+		# Blank kernel and OS with real machine code file format is always fine.
+		;;
+	*-*-*)
+		echo "Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'." 1>&2
 		exit 1
 		;;
 esac
@@ -1896,7 +1960,7 @@ case $vendor in
 		;;
 esac
 
-echo "$cpu-$vendor-${kernel:+$kernel-}$os"
+echo "$cpu-$vendor${kernel:+-$kernel}${os:+-$os}${obj:+-$obj}"
 exit
 
 # Local variables:
diff --git a/configure b/configure
deleted file mode 100755
index 4f8fd5ac..00000000
--- a/configure
+++ /dev/null
@@ -1,15246 +0,0 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for pcap 1.10.4.
-#
-#
-# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
-#
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-# Use a proper internal environment variable to ensure we don't fall
-  # into an infinite loop, continuously re-executing ourselves.
-  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
-    _as_can_reexec=no; export _as_can_reexec;
-    # We cannot yet assume a decent shell, so we have to provide a
-# neutralization value for shells without unset; and this also
-# works around shells that cannot unset nonexistent variables.
-# Preserve -v and -x to the replacement shell.
-BASH_ENV=/dev/null
-ENV=/dev/null
-(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-case $- in # ((((
-  *v*x* | *x*v* ) as_opts=-vx ;;
-  *v* ) as_opts=-v ;;
-  *x* ) as_opts=-x ;;
-  * ) as_opts= ;;
-esac
-exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
-# Admittedly, this is quite paranoid, since all the known shells bail
-# out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
-as_fn_exit 255
-  fi
-  # We don't want this to propagate to other subprocesses.
-          { _as_can_reexec=; unset _as_can_reexec;}
-if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '\${1+\"\$@\"}'='\"\$@\"'
-  setopt NO_GLOB_SUBST
-else
-  case \`(set -o) 2>/dev/null\` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-"
-  as_required="as_fn_return () { (exit \$1); }
-as_fn_success () { as_fn_return 0; }
-as_fn_failure () { as_fn_return 1; }
-as_fn_ret_success () { return 0; }
-as_fn_ret_failure () { return 1; }
-
-exitcode=0
-as_fn_success || { exitcode=1; echo as_fn_success failed.; }
-as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
-as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
-as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
-
-else
-  exitcode=1; echo positional parameters were not saved.
-fi
-test x\$exitcode = x0 || exit 1
-test -x / || exit 1"
-  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
-  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
-  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
-  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
-
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_found=false
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  as_found=:
-  case $as_dir in #(
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
-	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  break 2
-fi
-fi
-	   done;;
-       esac
-  as_found=false
-done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
-IFS=$as_save_IFS
-
-
-      if test "x$CONFIG_SHELL" != x; then :
-  export CONFIG_SHELL
-             # We cannot yet assume a decent shell, so we have to provide a
-# neutralization value for shells without unset; and this also
-# works around shells that cannot unset nonexistent variables.
-# Preserve -v and -x to the replacement shell.
-BASH_ENV=/dev/null
-ENV=/dev/null
-(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-case $- in # ((((
-  *v*x* | *x*v* ) as_opts=-vx ;;
-  *v* ) as_opts=-v ;;
-  *x* ) as_opts=-x ;;
-  * ) as_opts= ;;
-esac
-exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
-# Admittedly, this is quite paranoid, since all the known shells bail
-# out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
-exit 255
-fi
-
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
-  else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
-$0: including any error possibly output before this
-$0: message. Then install a modern shell, or manually run
-$0: the script under such a shell if you do have one."
-  fi
-  exit 1
-fi
-fi
-fi
-SHELL=${CONFIG_SHELL-/bin/sh}
-export SHELL
-# Unset more variables known to interfere with behavior of common tools.
-CLICOLOR_FORCE= GREP_OPTIONS=
-unset CLICOLOR_FORCE GREP_OPTIONS
-
-## --------------------- ##
-## M4sh Shell Functions. ##
-## --------------------- ##
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-
-# as_fn_executable_p FILE
-# -----------------------
-# Test if FILE is an executable regular file.
-as_fn_executable_p ()
-{
-  test -f "$1" && test -x "$1"
-} # as_fn_executable_p
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
-  fi
-  $as_echo "$as_me: error: $2" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-
-  as_lineno_1=$LINENO as_lineno_1a=$LINENO
-  as_lineno_2=$LINENO as_lineno_2a=$LINENO
-  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
-  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
-  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
-
-  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
-  # already done that, so ensure we don't try to do so again and fall
-  # in an infinite loop.  This has already happened in practice.
-  _as_can_reexec=no; export _as_can_reexec
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -pR'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -pR'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -pR'
-  fi
-else
-  as_ln_s='cp -pR'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-as_test_x='test -x'
-as_executable_p=as_fn_executable_p
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-test -n "$DJDIR" || exec 7<&0 </dev/null
-exec 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-
-# Identity of this package.
-PACKAGE_NAME='pcap'
-PACKAGE_TARNAME='pcap'
-PACKAGE_VERSION='1.10.4'
-PACKAGE_STRING='pcap 1.10.4'
-PACKAGE_BUGREPORT=''
-PACKAGE_URL=''
-
-ac_unique_file="pcap.c"
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='LTLIBOBJS
-RPCAPD_LIBS
-INSTALL_RPCAPD
-BUILD_RPCAPD
-PTHREAD_LIBS
-REMOTE_C_SRC
-MODULE_C_SRC
-PLATFORM_CXX_SRC
-PLATFORM_C_SRC
-ADDLARCHIVEOBJS
-ADDLOBJS
-RPATH
-V_SONAME_OPT
-V_SHLIB_OPT
-V_SHLIB_CMD
-V_SHLIB_CCOPT
-INSTALL_DATA
-INSTALL_SCRIPT
-INSTALL_PROGRAM
-PCAP_SUPPORT_RDMASNIFF
-LIBIBVERBS_LIBS_STATIC
-LIBIBVERBS_LIBS
-LIBIBVERBS_CFLAGS
-PCAP_SUPPORT_DBUS
-DBUS_LIBS_STATIC
-DBUS_LIBS
-DBUS_CFLAGS
-PCAP_SUPPORT_BT
-PCAP_SUPPORT_DPDK
-DPDK_LIBS_STATIC
-DPDK_LIBS
-DPDK_CFLAGS
-PCAP_SUPPORT_NETMAP
-PCAP_SUPPORT_NETFILTER
-PCAP_SUPPORT_LINUX_USBMON
-MKDEP
-DEPENDENCY_CFLAG
-LN_S
-AR
-RANLIB
-MAN_ADMIN_COMMANDS
-MAN_MISC_INFO
-MAN_FILE_FORMATS
-MAN_DEVICES
-DYEXT
-V_PROG_LDFLAGS_FAT
-V_PROG_CCOPT_FAT
-V_LIB_LDFLAGS_FAT
-V_LIB_CCOPT_FAT
-REENTRANT_PARSER
-BISON_BYACC
-LEXLIB
-LEX_OUTPUT_ROOT
-LEX
-OPENSSL_LIBS_STATIC
-OPENSSL_LIBS
-OPENSSL_CFLAGS
-LIBNL_LIBS_STATIC
-LIBNL_LIBS
-LIBNL_CFLAGS
-BREW
-PKG_CONFIG_LIBDIR
-PKG_CONFIG_PATH
-PKG_CONFIG
-VALGRINDTEST_SRC
-LIBOBJS
-ac_ct_CXX
-CXXFLAGS
-CXX
-EGREP
-GREP
-CPP
-OBJEXT
-EXEEXT
-ac_ct_CC
-CPPFLAGS
-LDFLAGS
-CFLAGS
-CC
-SHLICC2
-target_os
-target_vendor
-target_cpu
-target
-host_os
-host_vendor
-host_cpu
-host
-build_os
-build_vendor
-build_cpu
-build
-LIBS_PRIVATE
-REQUIRES_PRIVATE
-LIBS_STATIC
-V_INCLS
-V_DEFS
-V_CCOPT
-target_alias
-host_alias
-build_alias
-LIBS
-ECHO_T
-ECHO_N
-ECHO_C
-DEFS
-mandir
-localedir
-libdir
-psdir
-pdfdir
-dvidir
-htmldir
-infodir
-docdir
-oldincludedir
-includedir
-localstatedir
-sharedstatedir
-sysconfdir
-datadir
-datarootdir
-libexecdir
-sbindir
-bindir
-program_transform_name
-prefix
-exec_prefix
-PACKAGE_URL
-PACKAGE_BUGREPORT
-PACKAGE_STRING
-PACKAGE_VERSION
-PACKAGE_TARNAME
-PACKAGE_NAME
-PATH_SEPARATOR
-SHELL'
-ac_subst_files=''
-ac_user_opts='
-enable_option_checking
-with_gcc
-enable_largefile
-enable_protochain
-with_pcap
-with_libnl
-enable_ipv6
-with_dag
-with_dag_includes
-with_dag_libraries
-with_septel
-with_snf
-with_snf_includes
-with_snf_libraries
-with_turbocap
-enable_remote
-enable_optimizer_dbg
-enable_yydebug
-enable_universal
-enable_shared
-enable_usb
-enable_netmap
-with_dpdk
-enable_bluetooth
-enable_dbus
-enable_rdma
-'
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CC
-CFLAGS
-LDFLAGS
-LIBS
-CPPFLAGS
-CPP
-CXX
-CXXFLAGS
-CCC
-PKG_CONFIG
-PKG_CONFIG_PATH
-PKG_CONFIG_LIBDIR
-LIBNL_CFLAGS
-LIBNL_LIBS
-LIBNL_LIBS_STATIC
-OPENSSL_CFLAGS
-OPENSSL_LIBS
-OPENSSL_LIBS_STATIC
-DPDK_CFLAGS
-DPDK_LIBS
-DPDK_LIBS_STATIC
-DBUS_CFLAGS
-DBUS_LIBS
-DBUS_LIBS_STATIC
-LIBIBVERBS_CFLAGS
-LIBIBVERBS_LIBS
-LIBIBVERBS_LIBS_STATIC'
-
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-ac_unrecognized_opts=
-ac_unrecognized_sep=
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
-
-ac_prev=
-ac_dashdash=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
-    ac_prev=
-    continue
-  fi
-
-  case $ac_option in
-  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *=)   ac_optarg= ;;
-  *)    ac_optarg=yes ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
-    datadir=$ac_optarg ;;
-
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
-
-  -enable-* | --enable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=\$ac_optarg ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=\$ac_optarg ;;
-
-  -without-* | --without-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=no ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) as_fn_error $? "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information"
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    case $ac_envvar in #(
-      '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
-    esac
-    eval $ac_envvar=\$ac_optarg
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error $? "missing argument to $ac_option"
-fi
-
-if test -n "$ac_unrecognized_opts"; then
-  case $enable_option_checking in
-    no) ;;
-    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
-  esac
-fi
-
-# Check all directory arguments for consistency.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
-do
-  eval ac_val=\$$ac_var
-  # Remove trailing slashes.
-  case $ac_val in
-    */ )
-      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
-      eval $ac_var=\$ac_val;;
-  esac
-  # Be sure to have absolute directory names.
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
-  esac
-  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error $? "working directory cannot be determined"
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error $? "pwd does not report name of working directory"
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$as_myself" ||
-$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_myself" : 'X\(//\)[^/]' \| \
-	 X"$as_myself" : 'X\(//\)$' \| \
-	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures pcap 1.10.4 to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking ...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR            user executables [EPREFIX/bin]
-  --sbindir=DIR           system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR        program executables [EPREFIX/libexec]
-  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --libdir=DIR            object code libraries [EPREFIX/lib]
-  --includedir=DIR        C header files [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
-  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR           info documentation [DATAROOTDIR/info]
-  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/pcap]
-  --htmldir=DIR           html documentation [DOCDIR]
-  --dvidir=DIR            dvi documentation [DOCDIR]
-  --pdfdir=DIR            pdf documentation [DOCDIR]
-  --psdir=DIR             ps documentation [DOCDIR]
-_ACEOF
-
-  cat <<\_ACEOF
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-  --target=TARGET   configure for building compilers for TARGET [HOST]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-  case $ac_init_help in
-     short | recursive ) echo "Configuration of pcap 1.10.4:";;
-   esac
-  cat <<\_ACEOF
-
-Optional Features:
-  --disable-option-checking  ignore unrecognized --enable/--with options
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --disable-largefile     omit support for large files
-  --disable-protochain    disable \"protochain\" insn
-  --enable-ipv6           build IPv6-capable version [default=yes]
-  --enable-remote         enable remote packet capture [default=no]
-  --enable-optimizer-dbg  build optimizer debugging code
-  --enable-yydebug        build parser debugging code
-  --disable-universal     don't build universal on macOS
-  --enable-shared         build shared libraries [default=yes, if support
-                          available]
-  --enable-usb            enable Linux usbmon USB capture support
-                          [default=yes, if support available]
-  --enable-netmap         enable netmap support [default=yes, if support
-                          available]
-  --enable-bluetooth      enable Bluetooth support [default=yes, if support
-                          available]
-  --enable-dbus           enable D-Bus capture support [default=yes, if
-                          support available]
-  --enable-rdma           enable RDMA capture support [default=yes, if support
-                          available]
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --without-gcc           don't use gcc
-  --with-pcap=TYPE        use packet capture TYPE
-  --without-libnl         disable libnl support [default=yes, on Linux, if
-                          present]
-  --with-dag[=DIR]        include Endace DAG support (located in directory
-                          DIR, if supplied). [default=yes, if present]
-  --with-dag-includes=IDIR
-                          Endace DAG include directory, if not DIR/include
-  --with-dag-libraries=LDIR
-                          Endace DAG library directory, if not DIR/lib
-  --with-septel[=DIR]     include Septel support (located in directory DIR, if
-                          supplied). [default=yes, if present]
-  --with-snf[=DIR]        include Myricom SNF support (located in directory
-                          DIR, if supplied). [default=yes, if present]
-  --with-snf-includes=IDIR
-                          Myricom SNF include directory, if not DIR/include
-  --with-snf-libraries=LDIR
-                          Myricom SNF library directory, if not DIR/lib
-  --with-turbocap[=DIR]   include Riverbed TurboCap support (located in
-                          directory DIR, if supplied). [default=yes, if
-                          present]
-  --with-dpdk[=DIR]       include DPDK support (located in directory DIR, if
-                          supplied). [default=yes, if present]
-
-Some influential environment variables:
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
-  CXX         C++ compiler command
-  CXXFLAGS    C++ compiler flags
-  PKG_CONFIG  path to pkg-config utility
-  PKG_CONFIG_PATH
-              directories to add to pkg-config's search path
-  PKG_CONFIG_LIBDIR
-              path overriding pkg-config's built-in search path
-  LIBNL_CFLAGS
-              C compiler flags for libnl-genl-3.0, overriding pkg-config
-  LIBNL_LIBS  linker flags for libnl-genl-3.0, overriding pkg-config
-  LIBNL_LIBS_STATIC
-              static-link linker flags for libnl-genl-3.0, overriding
-              pkg-config
-  OPENSSL_CFLAGS
-              C compiler flags for openssl, overriding pkg-config
-  OPENSSL_LIBS
-              linker flags for openssl, overriding pkg-config
-  OPENSSL_LIBS_STATIC
-              static-link linker flags for openssl, overriding pkg-config
-  DPDK_CFLAGS C compiler flags for libdpdk, overriding pkg-config
-  DPDK_LIBS   linker flags for libdpdk, overriding pkg-config
-  DPDK_LIBS_STATIC
-              static-link linker flags for libdpdk, overriding pkg-config
-  DBUS_CFLAGS C compiler flags for dbus-1, overriding pkg-config
-  DBUS_LIBS   linker flags for dbus-1, overriding pkg-config
-  DBUS_LIBS_STATIC
-              static-link linker flags for dbus-1, overriding pkg-config
-  LIBIBVERBS_CFLAGS
-              C compiler flags for libibverbs, overriding pkg-config
-  LIBIBVERBS_LIBS
-              linker flags for libibverbs, overriding pkg-config
-  LIBIBVERBS_LIBS_STATIC
-              static-link linker flags for libibverbs, overriding pkg-config
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-Report bugs to the package provider.
-_ACEOF
-ac_status=$?
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" ||
-      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
-      continue
-    ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
-    else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
-  done
-fi
-
-test -n "$ac_init_help" && exit $ac_status
-if $ac_init_version; then
-  cat <<\_ACEOF
-pcap configure 1.10.4
-generated by GNU Autoconf 2.69
-
-Copyright (C) 2012 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit
-fi
-
-## ------------------------ ##
-## Autoconf initialization. ##
-## ------------------------ ##
-
-# ac_fn_c_try_compile LINENO
-# --------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_compile
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_run
-
-# ac_fn_c_compute_int LINENO EXPR VAR INCLUDES
-# --------------------------------------------
-# Tries to find the compile-time value of EXPR in a program that includes
-# INCLUDES, setting VAR accordingly. Returns whether the value could be
-# computed
-ac_fn_c_compute_int ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if test "$cross_compiling" = yes; then
-    # Depending upon the size, compute the lo and hi bounds.
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_hi=$ac_mid; break
-else
-  as_fn_arith $ac_mid + 1 && ac_lo=$as_val
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			as_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_lo=$ac_mid; break
-else
-  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			as_fn_arith 2 '*' $ac_mid && ac_mid=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  ac_lo= ac_hi=
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_hi=$ac_mid
-else
-  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in #((
-?*) eval "$3=\$ac_lo"; ac_retval=0 ;;
-'') ac_retval=1 ;;
-esac
-  else
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-static long int longval () { return $2; }
-static unsigned long int ulongval () { return $2; }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (($2) < 0)
-    {
-      long int i = longval ();
-      if (i != ($2))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ($2))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  echo >>conftest.val; read $3 <conftest.val; ac_retval=0
-else
-  ac_retval=1
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-rm -f conftest.val
-
-  fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_compute_int
-
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_header_compile
-
-# ac_fn_cxx_try_compile LINENO
-# ----------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_cxx_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_compile
-
-# ac_fn_cxx_try_run LINENO
-# ------------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_cxx_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_run
-
-# ac_fn_cxx_compute_int LINENO EXPR VAR INCLUDES
-# ----------------------------------------------
-# Tries to find the compile-time value of EXPR in a program that includes
-# INCLUDES, setting VAR accordingly. Returns whether the value could be
-# computed
-ac_fn_cxx_compute_int ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if test "$cross_compiling" = yes; then
-    # Depending upon the size, compute the lo and hi bounds.
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_hi=$ac_mid; break
-else
-  as_fn_arith $ac_mid + 1 && ac_lo=$as_val
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			as_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_lo=$ac_mid; break
-else
-  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			as_fn_arith 2 '*' $ac_mid && ac_mid=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  ac_lo= ac_hi=
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0;
-return test_array [0];
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_hi=$ac_mid
-else
-  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in #((
-?*) eval "$3=\$ac_lo"; ac_retval=0 ;;
-'') ac_retval=1 ;;
-esac
-  else
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-static long int longval () { return $2; }
-static unsigned long int ulongval () { return $2; }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (($2) < 0)
-    {
-      long int i = longval ();
-      if (i != ($2))
-	return 1;
-      fprintf (f, "%ld", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ($2))
-	return 1;
-      fprintf (f, "%lu", i);
-    }
-  /* Do not output a trailing newline, as this causes \r\n confusion
-     on some platforms.  */
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_run "$LINENO"; then :
-  echo >>conftest.val; read $3 <conftest.val; ac_retval=0
-else
-  ac_retval=1
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-rm -f conftest.val
-
-  fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_compute_int
-
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_c_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_header_mongrel
-
-# ac_fn_c_check_func LINENO FUNC VAR
-# ----------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_c_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_func
-
-# ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES
-# ---------------------------------------------
-# Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR
-# accordingly.
-ac_fn_c_check_decl ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  as_decl_name=`echo $2|sed 's/ *(.*//'`
-  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared" >&5
-$as_echo_n "checking whether $as_decl_name is declared... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-#ifndef $as_decl_name
-#ifdef __cplusplus
-  (void) $as_decl_use;
-#else
-  (void) $as_decl_name;
-#endif
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_decl
-
-# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
-# -------------------------------------------
-# Tests whether TYPE exists after having included INCLUDES, setting cache
-# variable VAR accordingly.
-ac_fn_c_check_type ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=no"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-if (sizeof ($2))
-	 return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-int
-main ()
-{
-if (sizeof (($2)))
-	    return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  eval "$3=yes"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_type
-
-# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES
-# ----------------------------------------------------
-# Tries to find if the field MEMBER exists in type AGGR, after including
-# INCLUDES, setting cache variable VAR accordingly.
-ac_fn_c_check_member ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
-$as_echo_n "checking for $2.$3... " >&6; }
-if eval \${$4+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$5
-int
-main ()
-{
-static $2 ac_aggr;
-if (ac_aggr.$3)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$4=yes"
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$5
-int
-main ()
-{
-static $2 ac_aggr;
-if (sizeof ac_aggr.$3)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$4=yes"
-else
-  eval "$4=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$4
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_member
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by pcap $as_me 1.10.4, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-exec 5>>config.log
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
-  done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
-    2)
-      as_fn_append ac_configure_args1 " '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      as_fn_append ac_configure_args " '$ac_arg'"
-      ;;
-    esac
-  done
-done
-{ ac_configure_args0=; unset ac_configure_args0;}
-{ ac_configure_args1=; unset ac_configure_args1;}
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    $as_echo "## ---------------- ##
-## Cache variables. ##
-## ---------------- ##"
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
-
-    $as_echo "## ----------------- ##
-## Output variables. ##
-## ----------------- ##"
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      $as_echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
-## File substitutions. ##
-## ------------------- ##"
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      $as_echo "## ----------- ##
-## confdefs.h. ##
-## ----------- ##"
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
-
-$as_echo "/* confdefs.h */" > confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
-if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
-elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
-else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
-fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
-do
-  test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "failed to load site script $ac_site_file
-See \`config.log' for more details" "$LINENO" 5; }
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special files
-  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
-  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
-fi
-## -------------------- ##
-## Main body of script. ##
-## -------------------- ##
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-
-
-#
-# These are the variables that are used in Makefile, pcap-config, and
-# libpcap.pc.
-#
-# CFLAGS: inherited from the environment, not modified by us (except
-# temporarily during tests that involve compilation).  Used only when
-# compiling C source.
-#
-# CXXFLAGS: inherited from the environment, not modified by us.  Used only
-# when compiling C++ source.
-#
-# LDFLAGS: inherited from the environment, not modified by us.
-#
-# LIBS: inherited from the environment; we add libraries required by
-# libpcap.  Librares that the core libpcap code requires are added
-# first; libraries required by additional pcap modules are first
-# added to ADDITIONAL_LIBS, and only added to LIBS at the end, after
-# we're finished doing configuration tests for the modules.
-#
-# LIBS_STATIC: libraries with which a program using the libpcap *static*
-# library needs to be linked.  This is a superset of LIBS, used in
-# pcap-config, so that "pcap-config --libs --static" will report them.
-# Initialized to LIBS.
-#
-# REQUIRES_PRIVATE: pkg-config package names for additional libraries
-# with which a program using the libpcap *static* library needs to be
-# linked and for which a .pc file exists.  This is used in libpcap.pc,
-# so that "pkg-config --libs --static" will report them, and so that
-# those libraries will be determined using the library's .pc file, not
-# from our .pc file.  Initialized to an empty string.
-#
-# V_CCOPT: additional compiler flags other than -I and -D flags
-# needed when compiling libpcap.  Used in Makefile for both C and
-# C++ source.
-#
-# V_DEFS: additional -D compiler flags needed when compiling
-# libpcap.  Used in Makefile for both C and C++ source.
-#
-# V_INCLS: additional -I compiler flags needed when compiling
-# libpcap.  Used in Makefile for both C and C++ source.
-#
-# ADDITIONAL_LIBS: additional libraries with which the libpcap dynamic
-# library needs to be linked.  Used in Makwfile; not used in pcap-config
-# or libpcap.pc, as, in all platforms on which we run, if a dynamic
-# library is linked with other dynamic libraries, a program using
-# that dynamic library doesn't have to link with those libraries -
-# they will be automatically loaded at run time.  Initialized to an
-# empty string.
-#
-# ADDITIONAL_LIBS_STATIC: additional libraries with which a program
-# using the libpcap *static* library needs to be linked.  This is used
-# in pcap-config, so that "pcap-config --libs --static" will report
-# them.  Initialized to an empty string.
-#
-# REQUIRES_PRIVATE: pkg-config package names for additional libraries
-# with which a program using the libpcap *static* library needs to be
-# linked and for which a .pc file exists.  This is used in libpcap.pc,
-# so that "pkg-config --libs --static" will report them, and so that
-# those libraries will be determined using the library's .pc file, not
-# from our .pc file.  Initialized to an empty string.
-#
-# LIBS_PRIVATE: pkg-config package names for additional libraries with
-# which a program using the libpcap *static* library needs to be linked
-# and for which a .pc file does not exist.  This is used in libpcap.pc,
-# so that "pkg-config --libs --static" will report them (those libraries
-# cannot be determined using the library's .pc file, as there is no such
-# file, so it has to come from our .pc file.  Initialized to an empty
-# string.
-#
-LIBS_STATIC=""
-REQUIRES_PRIVATE=""
-LIBS_PRIVATE=""
-
-
-
-
-
-
-
-
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
-$as_echo_n "checking target system type... " >&6; }
-if ${ac_cv_target+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
-else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
-$as_echo "$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) as_fn_error $? "invalid value of canonical target" "$LINENO" 5;;
-esac
-target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
-
-
-# The aliases save the names the user supplied, while $host etc.
-# will get canonicalized.
-test -n "$target_alias" &&
-  test "$program_prefix$program_suffix$program_transform_name" = \
-    NONENONEs,x,x, &&
-  program_prefix=${target_alias}-
-
-
-
-
-
-
-
-
-# Check whether --with-gcc was given.
-if test "${with_gcc+set}" = set; then :
-  withval=$with_gcc;
-fi
-
-    V_CCOPT=""
-    if test "${srcdir}" != "." ; then
-	    V_CCOPT="-I\$(srcdir)"
-    fi
-    if test "${CFLAGS+set}" = set; then
-	    LBL_CFLAGS="$CFLAGS"
-    fi
-    if test -z "$CC" ; then
-	    case "$host_os" in
-
-	    bsdi*)
-		    # Extract the first word of "shlicc2", so it can be a program name with args.
-set dummy shlicc2; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_SHLICC2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$SHLICC2"; then
-  ac_cv_prog_SHLICC2="$SHLICC2" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_SHLICC2="yes"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_prog_SHLICC2" && ac_cv_prog_SHLICC2="no"
-fi
-fi
-SHLICC2=$ac_cv_prog_SHLICC2
-if test -n "$SHLICC2"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $SHLICC2" >&5
-$as_echo "$SHLICC2" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-		    if test $SHLICC2 = yes ; then
-			    CC=shlicc2
-			    export CC
-		    fi
-		    ;;
-	    esac
-    fi
-    if test -z "$CC" -a "$with_gcc" = no ; then
-	    CC=cc
-	    export CC
-    fi
-
-#
-# We require C99 or later.
-# Try to get it, which may involve adding compiler flags;
-# if that fails, give up.
-#
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "no acceptable C compiler found in \$PATH
-See \`config.log' for more details" "$LINENO" 5; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-
-# The possible output files:
-ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
-
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { { ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-if test -z "$ac_file"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "C compiler cannot create executables
-See \`config.log' for more details" "$LINENO" 5; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
-ac_exeext=$ac_cv_exeext
-
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
-ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
-if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-rm -f conftest conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdio.h>
-int
-main ()
-{
-FILE *f = fopen ("conftest.out", "w");
- return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files="$ac_clean_files conftest.out"
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
-if test "$cross_compiling" != yes; then
-  { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-  if { ac_try='./conftest$ac_cv_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details" "$LINENO" 5; }
-    fi
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
-
-rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
-ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if ${ac_cv_objext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-else
-  CFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-struct stat;
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
-
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C99" >&5
-$as_echo_n "checking for $CC option to accept ISO C99... " >&6; }
-if ${ac_cv_prog_cc_c99+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c99=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <wchar.h>
-#include <stdio.h>
-
-// Check varargs macros.  These examples are taken from C99 6.10.3.5.
-#define debug(...) fprintf (stderr, __VA_ARGS__)
-#define showlist(...) puts (#__VA_ARGS__)
-#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
-static void
-test_varargs_macros (void)
-{
-  int x = 1234;
-  int y = 5678;
-  debug ("Flag");
-  debug ("X = %d\n", x);
-  showlist (The first, second, and third items.);
-  report (x>y, "x is %d but y is %d", x, y);
-}
-
-// Check long long types.
-#define BIG64 18446744073709551615ull
-#define BIG32 4294967295ul
-#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
-#if !BIG_OK
-  your preprocessor is broken;
-#endif
-#if BIG_OK
-#else
-  your preprocessor is broken;
-#endif
-static long long int bignum = -9223372036854775807LL;
-static unsigned long long int ubignum = BIG64;
-
-struct incomplete_array
-{
-  int datasize;
-  double data[];
-};
-
-struct named_init {
-  int number;
-  const wchar_t *name;
-  double average;
-};
-
-typedef const char *ccp;
-
-static inline int
-test_restrict (ccp restrict text)
-{
-  // See if C++-style comments work.
-  // Iterate through items via the restricted pointer.
-  // Also check for declarations in for loops.
-  for (unsigned int i = 0; *(text+i) != '\0'; ++i)
-    continue;
-  return 0;
-}
-
-// Check varargs and va_copy.
-static void
-test_varargs (const char *format, ...)
-{
-  va_list args;
-  va_start (args, format);
-  va_list args_copy;
-  va_copy (args_copy, args);
-
-  const char *str;
-  int number;
-  float fnumber;
-
-  while (*format)
-    {
-      switch (*format++)
-	{
-	case 's': // string
-	  str = va_arg (args_copy, const char *);
-	  break;
-	case 'd': // int
-	  number = va_arg (args_copy, int);
-	  break;
-	case 'f': // float
-	  fnumber = va_arg (args_copy, double);
-	  break;
-	default:
-	  break;
-	}
-    }
-  va_end (args_copy);
-  va_end (args);
-}
-
-int
-main ()
-{
-
-  // Check bool.
-  _Bool success = false;
-
-  // Check restrict.
-  if (test_restrict ("String literal") == 0)
-    success = true;
-  char *restrict newvar = "Another string";
-
-  // Check varargs.
-  test_varargs ("s, d' f .", "string", 65, 34.234);
-  test_varargs_macros ();
-
-  // Check flexible array members.
-  struct incomplete_array *ia =
-    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
-  ia->datasize = 10;
-  for (int i = 0; i < ia->datasize; ++i)
-    ia->data[i] = i * 1.234;
-
-  // Check named initializers.
-  struct named_init ni = {
-    .number = 34,
-    .name = L"Test wide string",
-    .average = 543.34343,
-  };
-
-  ni.number = 58;
-
-  int dynamic_array[ni.number];
-  dynamic_array[ni.number - 1] = 543;
-
-  // work around unused variable warnings
-  return (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == 'x'
-	  || dynamic_array[ni.number - 1] != 543);
-
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -std=gnu99 -std=c99 -c99 -AC99 -D_STDC_C99= -qlanglvl=extc99
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c99=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c99" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c99" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c99"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99" >&5
-$as_echo "$ac_cv_prog_cc_c99" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c99" != xno; then :
-
-fi
-
-
-if test "$ac_cv_prog_cc_c99" = "no"; then
-	as_fn_error $? "The C compiler does not support C99" "$LINENO" 5
-fi
-
-#
-# Get the size of a void *, to determine whether this is a 32-bit
-# or 64-bit build.
-#
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_GREP" || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_EGREP" || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void *" >&5
-$as_echo_n "checking size of void *... " >&6; }
-if ${ac_cv_sizeof_void_p+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void *))" "ac_cv_sizeof_void_p"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_void_p" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (void *)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_void_p=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_void_p" >&5
-$as_echo "$ac_cv_sizeof_void_p" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_VOID_P $ac_cv_sizeof_void_p
-_ACEOF
-
-
-ac_lbl_c_sizeof_void_p="$ac_cv_sizeof_void_p"
-
-#
-# We only need a C++ compiler for Haiku; all code except for its
-# pcap module is in C.
-#
-case "$host_os" in
-haiku*)
-	ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-if test -z "$CXX"; then
-  if test -n "$CCC"; then
-    CXX=$CCC
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CXX"; then
-  ac_cv_prog_CXX="$CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CXX=$ac_cv_prog_CXX
-if test -n "$CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
-$as_echo "$CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CXX" && break
-  done
-fi
-if test -z "$CXX"; then
-  ac_ct_CXX=$CXX
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CXX"; then
-  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CXX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
-if test -n "$ac_ct_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
-$as_echo "$ac_ct_CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CXX" && break
-done
-
-  if test "x$ac_ct_CXX" = x; then
-    CXX="g++"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CXX=$ac_ct_CXX
-  fi
-fi
-
-  fi
-fi
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
-$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
-if ${ac_cv_cxx_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
-$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GXX=yes
-else
-  GXX=
-fi
-ac_test_CXXFLAGS=${CXXFLAGS+set}
-ac_save_CXXFLAGS=$CXXFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
-$as_echo_n "checking whether $CXX accepts -g... " >&6; }
-if ${ac_cv_prog_cxx_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
-   ac_cxx_werror_flag=yes
-   ac_cv_prog_cxx_g=no
-   CXXFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-else
-  CXXFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-
-else
-  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-	 CXXFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
-$as_echo "$ac_cv_prog_cxx_g" >&6; }
-if test "$ac_test_CXXFLAGS" = set; then
-  CXXFLAGS=$ac_save_CXXFLAGS
-elif test $ac_cv_prog_cxx_g = yes; then
-  if test "$GXX" = yes; then
-    CXXFLAGS="-g -O2"
-  else
-    CXXFLAGS="-g"
-  fi
-else
-  if test "$GXX" = yes; then
-    CXXFLAGS="-O2"
-  else
-    CXXFLAGS=
-  fi
-fi
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-	#
-	# Make sure C and C++ have the same pointer sizes with the flags
-	# they're given; if they don't, it means that the compilers for the
-	# languages will, with those flags, not produce code that can be
-	# linked together.
-	#
-	# We have to use different data types, because the results of
-	# a test are cached, so if we test for the size of a given type
-	# in C, the subsequent test in C++ will use the cached variable.
-	# We trick autoconf by testing the size of a "void *" in C and a
-	# "const void *" in C++.
-	#
-	ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of const void *" >&5
-$as_echo_n "checking size of const void *... " >&6; }
-if ${ac_cv_sizeof_const_void_p+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if ac_fn_cxx_compute_int "$LINENO" "(long int) (sizeof (const void *))" "ac_cv_sizeof_const_void_p"        "$ac_includes_default"; then :
-
-else
-  if test "$ac_cv_type_const_void_p" = yes; then
-     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "cannot compute sizeof (const void *)
-See \`config.log' for more details" "$LINENO" 5; }
-   else
-     ac_cv_sizeof_const_void_p=0
-   fi
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_const_void_p" >&5
-$as_echo "$ac_cv_sizeof_const_void_p" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_CONST_VOID_P $ac_cv_sizeof_const_void_p
-_ACEOF
-
-
-	ac_lbl_cxx_sizeof_void_p="$ac_cv_sizeof_const_void_p"
-	ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-	if test "$ac_lbl_cxx_sizeof_void_p" -eq 0; then
-		as_fn_error $? "No C++ compiler was found" "$LINENO" 5
-	fi
-	if test "$ac_lbl_c_sizeof_void_p" -ne "$ac_lbl_cxx_sizeof_void_p"; then
-		as_fn_error $? "C compiler $CC produces code with $ac_lbl_c_sizeof_void_p-byte pointers
-while C++ compiler $CXX produces code with $ac_lbl_cxx_sizeof_void_p-byte pointers.  This prevents
-code in those languages from being combined." "$LINENO" 5
-	fi
-	;;
-esac
-
-
-
-
-
-    if test "$GCC" = yes ; then
-	    #
-	    # -Werror forces warnings to be errors.
-	    #
-	    ac_lbl_cc_force_warning_errors=-Werror
-
-	    #
-	    # Try to have the compiler default to hiding symbols,
-	    # so that only symbols explicitly exported with
-	    # PCAP_API will be visible outside (shared) libraries.
-	    #
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -fvisibility=hidden option" >&5
-$as_echo_n "checking whether the compiler supports the -fvisibility=hidden option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -fvisibility=hidden"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -fvisibility=hidden " >&5
-$as_echo_n "checking whether -fvisibility=hidden ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -fvisibility=hidden"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-    else
-	    V_INCLS="$V_INCLS -I/usr/local/include"
-	    LDFLAGS="$LDFLAGS -L/usr/local/lib"
-
-	    case "$host_os" in
-
-	    darwin*)
-		    #
-		    # This is assumed either to be GCC or clang, both
-		    # of which use -Werror to force warnings to be errors.
-		    #
-		    ac_lbl_cc_force_warning_errors=-Werror
-
-		    #
-		    # Try to have the compiler default to hiding symbols,
-		    # so that only symbols explicitly exported with
-		    # PCAP_API will be visible outside (shared) libraries.
-		    #
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -fvisibility=hidden option" >&5
-$as_echo_n "checking whether the compiler supports the -fvisibility=hidden option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -fvisibility=hidden"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -fvisibility=hidden " >&5
-$as_echo_n "checking whether -fvisibility=hidden ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -fvisibility=hidden"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-		    ;;
-
-	    hpux*)
-		    #
-		    # HP C, which is what we presume we're using, doesn't
-		    # exit with a non-zero exit status if we hand it an
-		    # invalid -W flag, can't be forced to do so even with
-		    # +We, and doesn't handle GCC-style -W flags, so we
-		    # don't want to try using GCC-style -W flags.
-		    #
-		    ac_lbl_cc_dont_try_gcc_dashW=yes
-		    ;;
-
-	    irix*)
-		    #
-		    # MIPS C, which is what we presume we're using, doesn't
-		    # necessarily exit with a non-zero exit status if we
-		    # hand it an invalid -W flag, can't be forced to do
-		    # so, and doesn't handle GCC-style -W flags, so we
-		    # don't want to try using GCC-style -W flags.
-		    #
-		    ac_lbl_cc_dont_try_gcc_dashW=yes
-		    #
-		    # It also, apparently, defaults to "char" being
-		    # unsigned, unlike most other C implementations;
-		    # I suppose we could say "signed char" whenever
-		    # we want to guarantee a signed "char", but let's
-		    # just force signed chars.
-		    #
-		    # -xansi is normally the default, but the
-		    # configure script was setting it; perhaps -cckr
-		    # was the default in the Old Days.  (Then again,
-		    # that would probably be for backwards compatibility
-		    # in the days when ANSI C was Shiny and New, i.e.
-		    # 1989 and the early '90's, so maybe we can just
-		    # drop support for those compilers.)
-		    #
-		    # -g is equivalent to -g2, which turns off
-		    # optimization; we choose -g3, which generates
-		    # debugging information but doesn't turn off
-		    # optimization (even if the optimization would
-		    # cause inaccuracies in debugging).
-		    #
-		    V_CCOPT="$V_CCOPT -xansi -signed -g3"
-		    ;;
-
-	    osf*)
-		    #
-		    # Presumed to be DEC OSF/1, Digital UNIX, or
-		    # Tru64 UNIX.
-		    #
-		    # The DEC C compiler, which is what we presume we're
-		    # using, doesn't exit with a non-zero exit status if we
-		    # hand it an invalid -W flag, can't be forced to do
-		    # so, and doesn't handle GCC-style -W flags, so we
-		    # don't want to try using GCC-style -W flags.
-		    #
-		    ac_lbl_cc_dont_try_gcc_dashW=yes
-		    #
-		    # -g is equivalent to -g2, which turns off
-		    # optimization; we choose -g3, which generates
-		    # debugging information but doesn't turn off
-		    # optimization (even if the optimization would
-		    # cause inaccuracies in debugging).
-		    #
-		    V_CCOPT="$V_CCOPT -g3"
-		    ;;
-
-	    solaris*)
-		    #
-		    # Assumed to be Sun C, which requires -errwarn to force
-		    # warnings to be treated as errors.
-		    #
-		    ac_lbl_cc_force_warning_errors=-errwarn
-
-		    #
-		    # Try to have the compiler default to hiding symbols,
-		    # so that only symbols explicitly exported with
-		    # PCAP_API will be visible outside (shared) libraries.
-		    #
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -xldscope=hidden option" >&5
-$as_echo_n "checking whether the compiler supports the -xldscope=hidden option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -xldscope=hidden"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -xldscope=hidden " >&5
-$as_echo_n "checking whether -xldscope=hidden ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -xldscope=hidden"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-		    ;;
-
-	    ultrix*)
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking that Ultrix $CC hacks const in prototypes" >&5
-$as_echo_n "checking that Ultrix $CC hacks const in prototypes... " >&6; }
-		    if ${ac_cv_lbl_cc_const_proto+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
-int
-main ()
-{
-struct a { int b; };
-			    void c(const struct a *)
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_lbl_cc_const_proto=yes
-else
-  ac_cv_lbl_cc_const_proto=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lbl_cc_const_proto" >&5
-$as_echo "$ac_cv_lbl_cc_const_proto" >&6; }
-		    if test $ac_cv_lbl_cc_const_proto = no ; then
-
-$as_echo "#define const /**/" >>confdefs.h
-
-		    fi
-		    ;;
-	    esac
-	    V_CCOPT="$V_CCOPT -O"
-    fi
-
-
-    if test "$GCC" = yes ; then
-	    #
-	    # On platforms where we build a shared library:
-	    #
-	    #	add options to generate position-independent code,
-	    #	if necessary (it's the default in AIX and Darwin/macOS);
-	    #
-	    #	define option to set the soname of the shared library,
-	    #	if the OS supports that;
-	    #
-	    #	add options to specify, at link time, a directory to
-	    #	add to the run-time search path, if that's necessary.
-	    #
-	    V_SHLIB_CMD="\$(CC)"
-	    V_SHLIB_OPT="-shared"
-	    case "$host_os" in
-
-	    aix*)
-		    ;;
-
-	    freebsd*|netbsd*|openbsd*|dragonfly*|linux*|osf*|haiku*|midipix*)
-		    #
-		    # Platforms where the C compiler is GCC or accepts
-		    # compatible command-line arguments, and the linker
-		    # is the GNU linker or accepts compatible command-line
-		    # arguments.
-		    #
-		    # Some instruction sets require -fPIC on some
-		    # operating systems.  Check for them.  If you
-		    # have a combination that requires it, add it
-		    # here.
-		    #
-		    PIC_OPT=-fpic
-		    case "$host_cpu" in
-
-		    sparc64*)
-			case "$host_os" in
-
-			freebsd*|openbsd*|linux*)
-			    PIC_OPT=-fPIC
-			    ;;
-			esac
-			;;
-		    esac
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT $PIC_OPT"
-		    V_SONAME_OPT="-Wl,-soname,"
-		    ;;
-
-	    hpux*)
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT -fpic"
-		    #
-		    # XXX - this assumes GCC is using the HP linker,
-		    # rather than the GNU linker, and that the "+h"
-		    # option is used on all HP-UX platforms, both .sl
-		    # and .so.
-		    #
-		    V_SONAME_OPT="-Wl,+h,"
-		    #
-		    # By default, directories specified with -L
-		    # are added to the run-time search path, so
-		    # we don't add them in pcap-config.
-		    #
-		    ;;
-
-	    solaris*)
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT -fpic"
-		    #
-		    # Sun/Oracle's C compiler, GCC, and GCC-compatible
-		    # compilers support -Wl,{comma-separated list of options},
-		    # and we use the C compiler, not ld, for all linking,
-		    # including linking to produce a shared library.
-		    #
-		    V_SONAME_OPT="-Wl,-h,"
-		    ;;
-	    esac
-    else
-	    #
-	    # Set the appropriate compiler flags and, on platforms
-	    # where we build a shared library:
-	    #
-	    #	add options to generate position-independent code,
-	    #	if necessary (it's the default in Darwin/macOS);
-	    #
-	    #	if we generate ".so" shared libraries, define the
-	    #	appropriate options for building the shared library;
-	    #
-	    #	add options to specify, at link time, a directory to
-	    #	add to the run-time search path, if that's necessary.
-	    #
-	    # Note: spaces after V_SONAME_OPT are significant; on
-	    # some platforms the soname is passed with a GCC-like
-	    # "-Wl,-soname,{soname}" option, with the soname part
-	    # of the option, while on other platforms the C compiler
-	    # driver takes it as a regular option with the soname
-	    # following the option.
-	    #
-	    case "$host_os" in
-
-	    aix*)
-		    V_SHLIB_CMD="\$(CC)"
-		    V_SHLIB_OPT="-G -bnoentry -bexpall"
-		    ;;
-
-	    freebsd*|netbsd*|openbsd*|dragonfly*|linux*)
-		    #
-		    # Platforms where the C compiler is GCC or accepts
-		    # compatible command-line arguments, and the linker
-		    # is the GNU linker or accepts compatible command-line
-		    # arguments.
-		    #
-		    # XXX - does 64-bit SPARC require -fPIC?
-		    #
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT -fpic"
-		    V_SHLIB_CMD="\$(CC)"
-		    V_SHLIB_OPT="-shared"
-		    V_SONAME_OPT="-Wl,-soname,"
-		    ;;
-
-	    hpux*)
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT +z"
-		    V_SHLIB_CMD="\$(LD)"
-		    V_SHLIB_OPT="-b"
-		    V_SONAME_OPT="+h "
-		    #
-		    # By default, directories specified with -L
-		    # are added to the run-time search path, so
-		    # we don't add them in pcap-config.
-		    #
-		    ;;
-
-	    osf*)
-		    #
-		    # Presumed to be DEC OSF/1, Digital UNIX, or
-		    # Tru64 UNIX.
-		    #
-		    V_SHLIB_CMD="\$(CC)"
-		    V_SHLIB_OPT="-shared"
-		    V_SONAME_OPT="-soname "
-		    ;;
-
-	    solaris*)
-		    V_SHLIB_CCOPT="$V_SHLIB_CCOPT -Kpic"
-		    V_SHLIB_CMD="\$(CC)"
-		    V_SHLIB_OPT="-G"
-		    #
-		    # Sun/Oracle's C compiler, GCC, and GCC-compatible
-		    # compilers support -Wl,{comma-separated list of options},
-		    # and we use the C compiler, not ld, for all linking,
-		    # including linking to produce a shared library.
-		    #
-		    V_SONAME_OPT="-Wl,-h,"
-		    ;;
-	    esac
-    fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
-$as_echo_n "checking for inline... " >&6; }
-    save_CFLAGS="$CFLAGS"
-    CFLAGS="$V_CCOPT"
-    if ${ac_cv_lbl_inline+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-	ac_cv_lbl_inline=""
-	ac_lbl_cc_inline=no
-	for ac_lbl_inline in inline __inline__ __inline
-	do
-	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#define inline $ac_lbl_inline
-		static inline struct iltest *foo(void);
-		struct iltest {
-		    int iltest1;
-		    int iltest2;
-		};
-
-		static inline struct iltest *
-		foo()
-		{
-		    static struct iltest xxx;
-
-		    return &xxx;
-		}
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_lbl_cc_inline=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	    if test "$ac_lbl_cc_inline" = yes ; then
-		break;
-	    fi
-	done
-	if test "$ac_lbl_cc_inline" = yes ; then
-	    ac_cv_lbl_inline=$ac_lbl_inline
-	fi
-fi
-
-    CFLAGS="$save_CFLAGS"
-    if test ! -z "$ac_cv_lbl_inline" ; then
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lbl_inline" >&5
-$as_echo "$ac_cv_lbl_inline" >&6; }
-    else
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-
-cat >>confdefs.h <<_ACEOF
-#define inline $ac_cv_lbl_inline
-_ACEOF
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load_n" >&5
-$as_echo_n "checking for __atomic_load_n... " >&6; }
-	if ${ac_cv_have___atomic_load_n+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-# ac_fn_c_try_link LINENO
-# -----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 test -x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_link
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-		    int i = 17;
-		    int j;
-		    j = __atomic_load_n(&i, __ATOMIC_RELAXED);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_have___atomic_load_n=yes
-else
-  ac_have___atomic_load_n=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_have___atomic_load_n" >&5
-$as_echo "$ac_have___atomic_load_n" >&6; }
-	if test $ac_have___atomic_load_n = yes ; then
-
-$as_echo "#define HAVE___ATOMIC_LOAD_N 1" >>confdefs.h
-
-	fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_store_n" >&5
-$as_echo_n "checking for __atomic_store_n... " >&6; }
-	if ${ac_cv_have___atomic_store_n+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-		    int i;
-		    __atomic_store_n(&i, 17, __ATOMIC_RELAXED);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_have___atomic_store_n=yes
-else
-  ac_have___atomic_store_n=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_have___atomic_store_n" >&5
-$as_echo "$ac_have___atomic_store_n" >&6; }
-	if test $ac_have___atomic_store_n = yes ; then
-
-$as_echo "#define HAVE___ATOMIC_STORE_N 1" >>confdefs.h
-
-	fi
-
-#
-# Try to arrange for large file support.
-#
-# Check whether --enable-largefile was given.
-if test "${enable_largefile+set}" = set; then :
-  enableval=$enable_largefile;
-fi
-
-if test "$enable_largefile" != no; then
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
-$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
-if ${ac_cv_sys_largefile_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_sys_largefile_CC=no
-     if test "$GCC" != yes; then
-       ac_save_CC=$CC
-       while :; do
-	 # IRIX 6.2 and later do not support large files by default,
-	 # so use the C compiler's -n32 option if that helps.
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-	 if ac_fn_c_try_compile "$LINENO"; then :
-  break
-fi
-rm -f core conftest.err conftest.$ac_objext
-	 CC="$CC -n32"
-	 if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_largefile_CC=' -n32'; break
-fi
-rm -f core conftest.err conftest.$ac_objext
-	 break
-       done
-       CC=$ac_save_CC
-       rm -f conftest.$ac_ext
-    fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
-$as_echo "$ac_cv_sys_largefile_CC" >&6; }
-  if test "$ac_cv_sys_largefile_CC" != no; then
-    CC=$CC$ac_cv_sys_largefile_CC
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
-$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
-if ${ac_cv_sys_file_offset_bits+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  while :; do
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_file_offset_bits=no; break
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#define _FILE_OFFSET_BITS 64
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_file_offset_bits=64; break
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  ac_cv_sys_file_offset_bits=unknown
-  break
-done
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
-$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
-case $ac_cv_sys_file_offset_bits in #(
-  no | unknown) ;;
-  *)
-cat >>confdefs.h <<_ACEOF
-#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
-_ACEOF
-;;
-esac
-rm -rf conftest*
-  if test $ac_cv_sys_file_offset_bits = unknown; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
-$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
-if ${ac_cv_sys_large_files+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  while :; do
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_large_files=no; break
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#define _LARGE_FILES 1
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_large_files=1; break
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  ac_cv_sys_large_files=unknown
-  break
-done
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
-$as_echo "$ac_cv_sys_large_files" >&6; }
-case $ac_cv_sys_large_files in #(
-  no | unknown) ;;
-  *)
-cat >>confdefs.h <<_ACEOF
-#define _LARGE_FILES $ac_cv_sys_large_files
-_ACEOF
-;;
-esac
-rm -rf conftest*
-  fi
-
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGEFILE_SOURCE value needed for large files" >&5
-$as_echo_n "checking for _LARGEFILE_SOURCE value needed for large files... " >&6; }
-if ${ac_cv_sys_largefile_source+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  while :; do
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h> /* for off_t */
-     #include <stdio.h>
-int
-main ()
-{
-int (*fp) (FILE *, off_t, int) = fseeko;
-     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_sys_largefile_source=no; break
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#define _LARGEFILE_SOURCE 1
-#include <sys/types.h> /* for off_t */
-     #include <stdio.h>
-int
-main ()
-{
-int (*fp) (FILE *, off_t, int) = fseeko;
-     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_sys_largefile_source=1; break
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  ac_cv_sys_largefile_source=unknown
-  break
-done
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_source" >&5
-$as_echo "$ac_cv_sys_largefile_source" >&6; }
-case $ac_cv_sys_largefile_source in #(
-  no | unknown) ;;
-  *)
-cat >>confdefs.h <<_ACEOF
-#define _LARGEFILE_SOURCE $ac_cv_sys_largefile_source
-_ACEOF
-;;
-esac
-rm -rf conftest*
-
-# We used to try defining _XOPEN_SOURCE=500 too, to work around a bug
-# in glibc 2.1.3, but that breaks too many other things.
-# If you want fseeko and ftello with glibc, upgrade to a fixed glibc.
-if test $ac_cv_sys_largefile_source != unknown; then
-
-$as_echo "#define HAVE_FSEEKO 1" >>confdefs.h
-
-fi
-
-
-for ac_header in sys/ioccom.h sys/sockio.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-for ac_header in netpacket/packet.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "netpacket/packet.h" "ac_cv_header_netpacket_packet_h" "$ac_includes_default"
-if test "x$ac_cv_header_netpacket_packet_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_NETPACKET_PACKET_H 1
-_ACEOF
-
-fi
-
-done
-
-
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-case "$host_os" in
-haiku*)
-	#
-	# Haiku needs _BSD_SOURCE for the _IO* macros because it doesn't use them.
-	#
-	CFLAGS="$CFLAGS -D_BSD_SOURCE"
-	#
-	# Haiku has getpass in libbsd.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for getpass in -lbsd" >&5
-$as_echo_n "checking for getpass in -lbsd... " >&6; }
-if ${ac_cv_lib_bsd_getpass+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lbsd  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char getpass ();
-int
-main ()
-{
-return getpass ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_bsd_getpass=yes
-else
-  ac_cv_lib_bsd_getpass=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_getpass" >&5
-$as_echo "$ac_cv_lib_bsd_getpass" >&6; }
-if test "x$ac_cv_lib_bsd_getpass" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBBSD 1
-_ACEOF
-
-  LIBS="-lbsd $LIBS"
-
-fi
-
-	;;
-esac
-
-if test "$GCC" = yes ; then
-	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI ioctl definitions" >&5
-$as_echo_n "checking for ANSI ioctl definitions... " >&6; }
-	    if ${ac_cv_lbl_gcc_fixincludes+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/*
-		     * This generates a "duplicate case value" when fixincludes
-		     * has not be run.
-		     */
-#		include <sys/types.h>
-#		include <sys/time.h>
-#		include <sys/ioctl.h>
-#		ifdef HAVE_SYS_IOCCOM_H
-#		include <sys/ioccom.h>
-#		endif
-int
-main ()
-{
-switch (0) {
-		    case _IO('A', 1):;
-		    case _IO('B', 1):;
-		    }
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_lbl_gcc_fixincludes=yes
-else
-  ac_cv_lbl_gcc_fixincludes=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lbl_gcc_fixincludes" >&5
-$as_echo "$ac_cv_lbl_gcc_fixincludes" >&6; }
-	    if test $ac_cv_lbl_gcc_fixincludes = no ; then
-		    # Don't cache failure
-		    unset ac_cv_lbl_gcc_fixincludes
-		    as_fn_error $? "see the INSTALL for more info" "$LINENO" 5
-	    fi
-    fi
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-
-for ac_func in strerror
-do :
-  ac_fn_c_check_func "$LINENO" "strerror" "ac_cv_func_strerror"
-if test "x$ac_cv_func_strerror" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STRERROR 1
-_ACEOF
-
-fi
-done
-
-ac_fn_c_check_func "$LINENO" "strerror_r" "ac_cv_func_strerror_r"
-if test "x$ac_cv_func_strerror_r" = xyes; then :
-
-	#
-	# We have strerror_r; if we define _GNU_SOURCE, is it a
-	# POSIX-compliant strerror_r() or a GNU strerror_r()?
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether strerror_r is GNU-style" >&5
-$as_echo_n "checking whether strerror_r is GNU-style... " >&6; }
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-		#define _GNU_SOURCE
-#include <string.h>
-
-/* Define it GNU-style; that will cause an error if it's not GNU-style */
-extern char *strerror_r(int, char *, size_t);
-
-int
-main(void)
-{
-	return 0;
-}
-
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		# GNU-style
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_GNU_STRERROR_R /**/" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-$as_echo "#define HAVE_POSIX_STRERROR_R /**/" >>confdefs.h
-
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-else
-
-	#
-	# We don't have strerror_r; do we have _wcserror_s?
-	#
-	for ac_func in _wcserror_s
-do :
-  ac_fn_c_check_func "$LINENO" "_wcserror_s" "ac_cv_func__wcserror_s"
-if test "x$ac_cv_func__wcserror_s" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE__WCSERROR_S 1
-_ACEOF
-
-fi
-done
-
-
-fi
-
-
-#
-# Thanks, IBM, for not providing vsyslog() in AIX!
-#
-for ac_func in vsyslog
-do :
-  ac_fn_c_check_func "$LINENO" "vsyslog" "ac_cv_func_vsyslog"
-if test "x$ac_cv_func_vsyslog" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_VSYSLOG 1
-_ACEOF
-
-fi
-done
-
-
-#
-# Make sure we have vsnprintf() and snprintf(); we require them.
-#
-ac_fn_c_check_func "$LINENO" "vsnprintf" "ac_cv_func_vsnprintf"
-if test "x$ac_cv_func_vsnprintf" = xyes; then :
-
-else
-  as_fn_error $? "vsnprintf() is required but wasn't found" "$LINENO" 5
-fi
-
-ac_fn_c_check_func "$LINENO" "snprintf" "ac_cv_func_snprintf"
-if test "x$ac_cv_func_snprintf" = xyes; then :
-
-else
-  as_fn_error $? "snprintf() is required but wasn't found" "$LINENO" 5
-fi
-
-
-needasprintf=no
-for ac_func in vasprintf asprintf
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-else
-  needasprintf=yes
-fi
-done
-
-if test $needasprintf = yes; then
-	case " $LIBOBJS " in
-  *" asprintf.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS asprintf.$ac_objext"
- ;;
-esac
-
-fi
-
-needstrlcat=no
-for ac_func in strlcat
-do :
-  ac_fn_c_check_func "$LINENO" "strlcat" "ac_cv_func_strlcat"
-if test "x$ac_cv_func_strlcat" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STRLCAT 1
-_ACEOF
-
-else
-  needstrlcat=yes
-fi
-done
-
-if test $needstrlcat = yes; then
-	case " $LIBOBJS " in
-  *" strlcat.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strlcat.$ac_objext"
- ;;
-esac
-
-fi
-
-needstrlcpy=no
-for ac_func in strlcpy
-do :
-  ac_fn_c_check_func "$LINENO" "strlcpy" "ac_cv_func_strlcpy"
-if test "x$ac_cv_func_strlcpy" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STRLCPY 1
-_ACEOF
-
-else
-  needstrlcpy=yes
-fi
-done
-
-if test $needstrlcpy = yes; then
-	case " $LIBOBJS " in
-  *" strlcpy.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strlcpy.$ac_objext"
- ;;
-esac
-
-fi
-
-needstrtok_r=no
-for ac_func in strtok_r
-do :
-  ac_fn_c_check_func "$LINENO" "strtok_r" "ac_cv_func_strtok_r"
-if test "x$ac_cv_func_strtok_r" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STRTOK_R 1
-_ACEOF
-
-else
-  needstrtok_r=yes
-fi
-done
-
-if test $needstrtok_r = yes; then
-	case " $LIBOBJS " in
-  *" strtok_r.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strtok_r.$ac_objext"
- ;;
-esac
-
-fi
-
-#
-# Do we have ffs(), and is it declared in <strings.h>?
-#
-for ac_func in ffs
-do :
-  ac_fn_c_check_func "$LINENO" "ffs" "ac_cv_func_ffs"
-if test "x$ac_cv_func_ffs" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_FFS 1
-_ACEOF
-
-fi
-done
-
-if test "$ac_cv_func_ffs" = yes; then
-	#
-	# We have ffs(); is it declared in <strings.h>?
-	#
-	# This test fails if we don't have <strings.h> or if we do
-	# but it doesn't declare ffs().
-	#
-	ac_fn_c_check_decl "$LINENO" "ffs" "ac_cv_have_decl_ffs" "
-#include <strings.h>
-
-"
-if test "x$ac_cv_have_decl_ffs" = xyes; then :
-
-
-$as_echo "#define STRINGS_H_DECLARES_FFS /**/" >>confdefs.h
-
-
-fi
-
-fi
-
-#
-# Do this before checking for ether_hostton(), as it's a
-# "getaddrinfo()-ish function".
-#
-
-    #
-    # Most operating systems have getaddrinfo() in the default searched
-    # libraries (i.e. libc).  Check there first.
-    #
-    ac_fn_c_check_func "$LINENO" "getaddrinfo" "ac_cv_func_getaddrinfo"
-if test "x$ac_cv_func_getaddrinfo" = xyes; then :
-
-else
-
-	#
-	# Not found in the standard system libraries.
-	# Try libsocket, which requires libnsl.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for getaddrinfo in -lsocket" >&5
-$as_echo_n "checking for getaddrinfo in -lsocket... " >&6; }
-if ${ac_cv_lib_socket_getaddrinfo+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket -lnsl $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char getaddrinfo ();
-int
-main ()
-{
-return getaddrinfo ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_socket_getaddrinfo=yes
-else
-  ac_cv_lib_socket_getaddrinfo=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_getaddrinfo" >&5
-$as_echo "$ac_cv_lib_socket_getaddrinfo" >&6; }
-if test "x$ac_cv_lib_socket_getaddrinfo" = xyes; then :
-
-	    #
-	    # OK, we found it in libsocket.
-	    #
-	    LIBS="-lsocket -lnsl $LIBS"
-
-else
-
-	    #
-	    # Not found in libsocket; test for it in libnetwork, which
-	    # is where it is in Haiku.
-	    #
-	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for getaddrinfo in -lnetwork" >&5
-$as_echo_n "checking for getaddrinfo in -lnetwork... " >&6; }
-if ${ac_cv_lib_network_getaddrinfo+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnetwork  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char getaddrinfo ();
-int
-main ()
-{
-return getaddrinfo ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_network_getaddrinfo=yes
-else
-  ac_cv_lib_network_getaddrinfo=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_network_getaddrinfo" >&5
-$as_echo "$ac_cv_lib_network_getaddrinfo" >&6; }
-if test "x$ac_cv_lib_network_getaddrinfo" = xyes; then :
-
-		#
-		# OK, we found it in libnetwork.
-		#
-		LIBS="-lnetwork $LIBS"
-
-else
-
-		#
-		# We didn't find it.
-		#
-		as_fn_error $? "getaddrinfo is required, but wasn't found" "$LINENO" 5
-
-fi
-
-
-fi
-
-
-	#
-	# OK, do we have recvmsg() in libxnet?
-	# We also link with libsocket and libnsl.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for recvmsg in -lxnet" >&5
-$as_echo_n "checking for recvmsg in -lxnet... " >&6; }
-if ${ac_cv_lib_xnet_recvmsg+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lxnet -lsocket -lnsl $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char recvmsg ();
-int
-main ()
-{
-return recvmsg ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_xnet_recvmsg=yes
-else
-  ac_cv_lib_xnet_recvmsg=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xnet_recvmsg" >&5
-$as_echo "$ac_cv_lib_xnet_recvmsg" >&6; }
-if test "x$ac_cv_lib_xnet_recvmsg" = xyes; then :
-
-	    #
-	    # Yes - link with it as well.
-	    #
-	    LIBS="-lxnet $LIBS"
-
-fi
-
-
-fi
-
-    # DLPI needs putmsg under HPUX so test for -lstr while we're at it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing putmsg" >&5
-$as_echo_n "checking for library containing putmsg... " >&6; }
-if ${ac_cv_search_putmsg+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char putmsg ();
-int
-main ()
-{
-return putmsg ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' str; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_search_putmsg=$ac_res
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext
-  if ${ac_cv_search_putmsg+:} false; then :
-  break
-fi
-done
-if ${ac_cv_search_putmsg+:} false; then :
-
-else
-  ac_cv_search_putmsg=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_putmsg" >&5
-$as_echo "$ac_cv_search_putmsg" >&6; }
-ac_res=$ac_cv_search_putmsg
-if test "$ac_res" != no; then :
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-
-
-#
-# Check for reentrant versions of getnetbyname_r(), as provided by
-# Linux (glibc), Solaris/IRIX, and AIX (with three different APIs!).
-# If we don't find one, we just use getnetbyname(), which uses
-# thread-specific data on many platforms, but doesn't use it on
-# NetBSD or OpenBSD, and may not use it on older versions of other
-# platforms.
-#
-# Only do the check if we have a declaration of getnetbyname_r();
-# without it, we can't check which API it has.  (We assume that
-# if there's a declaration, it has a prototype, so that the API
-# can be checked.)
-#
-ac_fn_c_check_decl "$LINENO" "getnetbyname_r" "ac_cv_have_decl_getnetbyname_r" "#include <netdb.h>
-"
-if test "x$ac_cv_have_decl_getnetbyname_r" = xyes; then :
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for the Linux getnetbyname_r()" >&5
-$as_echo_n "checking for the Linux getnetbyname_r()... " >&6; }
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-		struct netent netent_buf;
-		char buf[1024];
-		struct netent *resultp;
-		int h_errnoval;
-
-		return getnetbyname_r((const char *)0, &netent_buf, buf, sizeof buf, &resultp, &h_errnoval);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_LINUX_GETNETBYNAME_R 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Solaris/IRIX getnetbyname_r()" >&5
-$as_echo_n "checking for Solaris/IRIX getnetbyname_r()... " >&6; }
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-			struct netent netent_buf;
-			char buf[1024];
-
-			return getnetbyname_r((const char *)0, &netent_buf, buf, (int)sizeof buf) != NULL;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_SOLARIS_IRIX_GETNETBYNAME_R 1" >>confdefs.h
-
-
-else
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for AIX getnetbyname_r()" >&5
-$as_echo_n "checking for AIX getnetbyname_r()... " >&6; }
-			cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-				struct netent netent_buf;
-				struct netent_data net_data;
-
-				return getnetbyname_r((const char *)0, &netent_buf, &net_data);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_AIX_GETNETBYNAME_R 1" >>confdefs.h
-
-
-else
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-
-
-#
-# Check for reentrant versions of getprotobyname_r(), as provided by
-# Linux (glibc), Solaris/IRIX, and AIX (with three different APIs!).
-# If we don't find one, we just use getprotobyname(), which uses
-# thread-specific data on many platforms, but doesn't use it on
-# NetBSD or OpenBSD, and may not use it on older versions of other
-# platforms.
-#
-# Only do the check if we have a declaration of getprotobyname_r();
-# without it, we can't check which API it has.  (We assume that
-# if there's a declaration, it has a prototype, so that the API
-# can be checked.)
-#
-ac_fn_c_check_decl "$LINENO" "getprotobyname_r" "ac_cv_have_decl_getprotobyname_r" "#include <netdb.h>
-"
-if test "x$ac_cv_have_decl_getprotobyname_r" = xyes; then :
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for the Linux getprotobyname_r()" >&5
-$as_echo_n "checking for the Linux getprotobyname_r()... " >&6; }
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-		struct protoent protoent_buf;
-		char buf[1024];
-		struct protoent *resultp;
-
-		return getprotobyname_r((const char *)0, &protoent_buf, buf, sizeof buf, &resultp);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_LINUX_GETPROTOBYNAME_R 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Solaris/IRIX getprotobyname_r()" >&5
-$as_echo_n "checking for Solaris/IRIX getprotobyname_r()... " >&6; }
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-			struct protoent protoent_buf;
-			char buf[1024];
-
-			return getprotobyname_r((const char *)0, &protoent_buf, buf, (int)sizeof buf) != NULL;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_SOLARIS_IRIX_GETPROTOBYNAME_R 1" >>confdefs.h
-
-
-else
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for AIX getprotobyname_r()" >&5
-$as_echo_n "checking for AIX getprotobyname_r()... " >&6; }
-			cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <netdb.h>
-int
-main ()
-{
-
-				struct protoent protoent_buf;
-				struct protoent_data proto_data;
-
-				return getprotobyname_r((const char *)0, &protoent_buf, &proto_data);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_AIX_GETPROTOBYNAME_R 1" >>confdefs.h
-
-
-else
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-
-
-#
-# You are in a twisty little maze of UN*Xes, all different.
-# Some might not have ether_hostton().
-# Some might have it and declare it in <net/ethernet.h>.
-# Some might have it and declare it in <netinet/ether.h>
-# Some might have it and declare it in <sys/ethernet.h>.
-# Some might have it and declare it in <arpa/inet.h>.
-# Some might have it and declare it in <netinet/if_ether.h>.
-# Some might have it and not declare it in any header file.
-#
-# Before you is a C compiler.
-#
-for ac_func in ether_hostton
-do :
-  ac_fn_c_check_func "$LINENO" "ether_hostton" "ac_cv_func_ether_hostton"
-if test "x$ac_cv_func_ether_hostton" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_ETHER_HOSTTON 1
-_ACEOF
-
-fi
-done
-
-if test "$ac_cv_func_ether_hostton" = yes; then
-	#
-	# OK, we have ether_hostton().  Is it declared in <net/ethernet.h>?
-	#
-	# This test fails if we don't have <net/ethernet.h> or if we do
-	# but it doesn't declare ether_hostton().
-	#
-	ac_fn_c_check_decl "$LINENO" "ether_hostton" "ac_cv_have_decl_ether_hostton" "
-#include <net/ethernet.h>
-
-"
-if test "x$ac_cv_have_decl_ether_hostton" = xyes; then :
-
-
-$as_echo "#define NET_ETHERNET_H_DECLARES_ETHER_HOSTTON /**/" >>confdefs.h
-
-
-fi
-
-	#
-	# Did that succeed?
-	#
-	if test "$ac_cv_have_decl_ether_hostton" != yes; then
-		#
-		# No, how about <netinet/ether.h>, as on Linux?
-		#
-		# This test fails if we don't have <netinet/ether.h>
-		# or if we do but it doesn't declare ether_hostton().
-		#
-		# Unset ac_cv_have_decl_ether_hostton so we don't
-		# treat the previous failure as a cached value and
-		# suppress the next test.
-		#
-		unset ac_cv_have_decl_ether_hostton
-		ac_fn_c_check_decl "$LINENO" "ether_hostton" "ac_cv_have_decl_ether_hostton" "
-#include <netinet/ether.h>
-
-"
-if test "x$ac_cv_have_decl_ether_hostton" = xyes; then :
-
-
-$as_echo "#define NETINET_ETHER_H_DECLARES_ETHER_HOSTTON /**/" >>confdefs.h
-
-
-fi
-
-	fi
-	#
-	# Did that succeed?
-	#
-	if test "$ac_cv_have_decl_ether_hostton" != yes; then
-		#
-		# No, how about <sys/ethernet.h>, as on Solaris 10
-		# and later?
-		#
-		# This test fails if we don't have <sys/ethernet.h>
-		# or if we do but it doesn't declare ether_hostton().
-		#
-		# Unset ac_cv_have_decl_ether_hostton so we don't
-		# treat the previous failure as a cached value and
-		# suppress the next test.
-		#
-		unset ac_cv_have_decl_ether_hostton
-		ac_fn_c_check_decl "$LINENO" "ether_hostton" "ac_cv_have_decl_ether_hostton" "
-#include <sys/ethernet.h>
-
-"
-if test "x$ac_cv_have_decl_ether_hostton" = xyes; then :
-
-
-$as_echo "#define SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON /**/" >>confdefs.h
-
-
-fi
-
-	fi
-	#
-	# Did that succeed?
-	#
-	if test "$ac_cv_have_decl_ether_hostton" != yes; then
-		#
-		# No, how about <arpa/inet.h>, as in AIX?
-		#
-		# This test fails if we don't have <arpa/inet.h>
-		# (if we have ether_hostton(), we should have
-		# networking, and if we have networking, we should
-		# have <arpa/inet.h>) or if we do but it doesn't
-		# declare ether_hostton().
-		#
-		# Unset ac_cv_have_decl_ether_hostton so we don't
-		# treat the previous failure as a cached value and
-		# suppress the next test.
-		#
-		unset ac_cv_have_decl_ether_hostton
-		ac_fn_c_check_decl "$LINENO" "ether_hostton" "ac_cv_have_decl_ether_hostton" "
-#include <arpa/inet.h>
-
-"
-if test "x$ac_cv_have_decl_ether_hostton" = xyes; then :
-
-
-$as_echo "#define ARPA_INET_H_DECLARES_ETHER_HOSTTON /**/" >>confdefs.h
-
-
-fi
-
-	fi
-	#
-	# Did that succeed?
-	#
-	if test "$ac_cv_have_decl_ether_hostton" != yes; then
-		#
-		# No, how about <netinet/if_ether.h>?
-		# On some platforms, it requires <net/if.h> and
-		# <netinet/in.h>, and we always include it with
-		# both of them, so test it with both of them.
-		#
-		# This test fails if we don't have <netinet/if_ether.h>
-		# and the headers we include before it, or if we do but
-		# <netinet/if_ether.h> doesn't declare ether_hostton().
-		#
-		# Unset ac_cv_have_decl_ether_hostton so we don't
-		# treat the previous failure as a cached value and
-		# suppress the next test.
-		#
-		unset ac_cv_have_decl_ether_hostton
-		ac_fn_c_check_decl "$LINENO" "ether_hostton" "ac_cv_have_decl_ether_hostton" "
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <net/if.h>
-#include <netinet/in.h>
-#include <netinet/if_ether.h>
-
-"
-if test "x$ac_cv_have_decl_ether_hostton" = xyes; then :
-
-
-$as_echo "#define NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON /**/" >>confdefs.h
-
-
-fi
-
-	fi
-	#
-	# After all that, is ether_hostton() declared?
-	#
-	if test "$ac_cv_have_decl_ether_hostton" = yes; then
-		#
-		# Yes.
-		#
-
-$as_echo "#define HAVE_DECL_ETHER_HOSTTON 1" >>confdefs.h
-
-        else
-		#
-		# No, we'll have to declare it ourselves.
-		# Do we have "struct ether_addr" if we include
-		# <netinet/if_ether.h>?
-		#
-		ac_fn_c_check_type "$LINENO" "struct ether_addr" "ac_cv_type_struct_ether_addr" "
-			#include <sys/types.h>
-			#include <sys/socket.h>
-			#include <net/if.h>
-			#include <netinet/in.h>
-			#include <netinet/if_ether.h>
-
-"
-if test "x$ac_cv_type_struct_ether_addr" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_ETHER_ADDR 1
-_ACEOF
-
-
-fi
-
-	fi
-fi
-
-#
-# For various things that might use pthreads.
-#
-ac_fn_c_check_header_mongrel "$LINENO" "pthread.h" "ac_cv_header_pthread_h" "$ac_includes_default"
-if test "x$ac_cv_header_pthread_h" = xyes; then :
-
-	#
-	# OK, we have pthread.h.  Do we have pthread_create in the
-	# system libraries?
-	#
-	ac_fn_c_check_func "$LINENO" "pthread_create" "ac_cv_func_pthread_create"
-if test "x$ac_cv_func_pthread_create" = xyes; then :
-
-		#
-		# Yes.
-		#
-		ac_lbl_have_pthreads="found"
-
-else
-
-		#
-		# No - do we have it in -lpthreads?
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthreads" >&5
-$as_echo_n "checking for pthread_create in -lpthreads... " >&6; }
-if ${ac_cv_lib_pthreads_pthread_create+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpthreads  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pthread_create ();
-int
-main ()
-{
-return pthread_create ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_pthreads_pthread_create=yes
-else
-  ac_cv_lib_pthreads_pthread_create=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthreads_pthread_create" >&5
-$as_echo "$ac_cv_lib_pthreads_pthread_create" >&6; }
-if test "x$ac_cv_lib_pthreads_pthread_create" = xyes; then :
-
-			#
-			# Yes - add -lpthreads.
-			#
-			ac_lbl_have_pthreads="found"
-			PTHREAD_LIBS="$PTHREAD_LIBS -lpthreads"
-
-else
-
-			#
-			# No - do we have it in -lpthread?
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthread" >&5
-$as_echo_n "checking for pthread_create in -lpthread... " >&6; }
-if ${ac_cv_lib_pthread_pthread_create+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpthread  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pthread_create ();
-int
-main ()
-{
-return pthread_create ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_pthread_pthread_create=yes
-else
-  ac_cv_lib_pthread_pthread_create=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_create" >&5
-$as_echo "$ac_cv_lib_pthread_pthread_create" >&6; }
-if test "x$ac_cv_lib_pthread_pthread_create" = xyes; then :
-
-				#
-				# Yes - add -lpthread.
-				#
-                                ac_lbl_have_pthreads="found"
-				PTHREAD_LIBS="$PTHREAD_LIBS -lpthread"
-
-else
-
-				#
-				# No.
-				#
-				ac_lbl_have_pthreads="not found"
-
-fi
-
-
-fi
-
-
-fi
-
-
-else
-
-	#
-	# We didn't find pthread.h.
-	#
-	ac_lbl_have_pthreads="not found"
-
-
-fi
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if --disable-protochain option is specified" >&5
-$as_echo_n "checking if --disable-protochain option is specified... " >&6; }
-# Check whether --enable-protochain was given.
-if test "${enable_protochain+set}" = set; then :
-  enableval=$enable_protochain;
-fi
-
-case "x$enable_protochain" in
-xyes)	enable_protochain=enabled	;;
-xno)	enable_protochain=disabled	;;
-x)	enable_protochain=enabled	;;
-esac
-
-if test "$enable_protochain" = "disabled"; then
-
-$as_echo "#define NO_PROTOCHAIN 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: ${enable_protochain}" >&5
-$as_echo "${enable_protochain}" >&6; }
-
-#
-# valgrindtest directly uses the native capture mechanism, but
-# only tests with BPF and PF_PACKET sockets; only enable it if
-# we have BPF or PF_PACKET sockets.
-#
-VALGRINDTEST_SRC=
-
-
-# Check whether --with-pcap was given.
-if test "${with_pcap+set}" = set; then :
-  withval=$with_pcap;
-fi
-
-if test ! -z "$with_pcap" ; then
-	V_PCAP="$withval"
-else
-	#
-	# Check for a bunch of headers for various packet
-	# capture mechanisms.
-	#
-	for ac_header in net/bpf.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "net/bpf.h" "ac_cv_header_net_bpf_h" "$ac_includes_default"
-if test "x$ac_cv_header_net_bpf_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_NET_BPF_H 1
-_ACEOF
-
-fi
-
-done
-
-	if test "$ac_cv_header_net_bpf_h" = yes; then
-		#
-		# Does it define BIOCSETIF?
-		# I.e., is it a header for an LBL/BSD-style capture
-		# mechanism, or is it just a header for a BPF filter
-		# engine?  Some versions of Arch Linux, for example,
-		# have a net/bpf.h that doesn't define BIOCSETIF;
-		# as it's a Linux, it should use packet sockets,
-		# instead.
-		#
-		# We need:
-		#
-		#  sys/types.h, because FreeBSD 10's net/bpf.h
-		#  requires that various BSD-style integer types
-		#  be defined;
-		#
-		#  sys/time.h, because AIX 5.2 and 5.3's net/bpf.h
-		#  doesn't include it but does use struct timeval
-		#  in ioctl definitions;
-		#
-		#  sys/ioctl.h and, if we have it, sys/ioccom.h,
-		#  because net/bpf.h defines ioctls;
-		#
-		#  net/if.h, because it defines some structures
-		#  used in ioctls defined by net/bpf.h;
-		#
-		#  sys/socket.h, because OpenBSD 5.9's net/bpf.h
-		#  defines some structure fields as being
-		#  struct sockaddrs;
-		#
-		# and net/bpf.h doesn't necessarily include all
-		# of those headers itself.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if net/bpf.h defines BIOCSETIF" >&5
-$as_echo_n "checking if net/bpf.h defines BIOCSETIF... " >&6; }
-		if ${ac_cv_lbl_bpf_h_defines_biocsetif+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#ifdef HAVE_SYS_IOCCOM_H
-#include <sys/ioccom.h>
-#endif
-#include <net/bpf.h>
-#include <net/if.h>
-
-int
-main ()
-{
-u_int i = BIOCSETIF;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_lbl_bpf_h_defines_biocsetif=yes
-else
-  ac_cv_lbl_bpf_h_defines_biocsetif=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lbl_bpf_h_defines_biocsetif" >&5
-$as_echo "$ac_cv_lbl_bpf_h_defines_biocsetif" >&6; }
-	fi
-	for ac_header in net/pfilt.h net/enet.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-	for ac_header in net/nit.h sys/net/nit.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-	for ac_header in linux/socket.h net/raw.h sys/dlpi.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-	for ac_header in config/HaikuConfig.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "config/HaikuConfig.h" "ac_cv_header_config_HaikuConfig_h" "$ac_includes_default"
-if test "x$ac_cv_header_config_HaikuConfig_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_CONFIG_HAIKUCONFIG_H 1
-_ACEOF
-
-fi
-
-done
-
-
-	if test "$ac_cv_lbl_bpf_h_defines_biocsetif" = yes; then
-		#
-		# BPF.
-		# Check this before DLPI, so that we pick BPF on
-		# Solaris 11 and later.
-		#
-		V_PCAP=bpf
-
-		#
-		# We have BPF, so build valgrindtest with "make test"
-		# on macOS and FreeBSD (add your OS once there's a
-		# valgrind for it).
-		#
-		case "$host_os" in
-
-		freebsd*|darwin*|linux*)
-			VALGRINDTEST_SRC=valgrindtest.c
-			;;
-		esac
-	elif test "$ac_cv_header_linux_socket_h" = yes; then
-		#
-		# No prizes for guessing this one.
-		#
-		V_PCAP=linux
-		VALGRINDTEST_SRC=valgrindtest.c
-	elif test "$ac_cv_header_net_pfilt_h" = yes; then
-		#
-		# DEC OSF/1, Digital UNIX, Tru64 UNIX
-		#
-		V_PCAP=pf
-	elif test "$ac_cv_header_net_enet_h" = yes; then
-		#
-		# Stanford Enetfilter.
-		#
-		V_PCAP=enet
-	elif test "$ac_cv_header_net_nit_h" = yes; then
-		#
-		# SunOS 4.x STREAMS NIT.
-		#
-		V_PCAP=snit
-	elif test "$ac_cv_header_sys_net_nit_h" = yes; then
-		#
-		# Pre-SunOS 4.x non-STREAMS NIT.
-		#
-		V_PCAP=nit
-	elif test "$ac_cv_header_net_raw_h" = yes; then
-		#
-		# IRIX snoop.
-		#
-		V_PCAP=snoop
-	elif test "$ac_cv_header_sys_dlpi_h" = yes; then
-		#
-		# DLPI on pre-Solaris 11 SunOS 5, HP-UX, possibly others.
-		#
-		V_PCAP=dlpi
-	elif test "$ac_cv_header_config_HaikuConfig_h" = yes; then
-		#
-		# Haiku.
-		#
-		V_PCAP=haiku
-	else
-		#
-		# Nothing we support.
-		#
-		V_PCAP=null
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cannot determine packet capture interface" >&5
-$as_echo "$as_me: WARNING: cannot determine packet capture interface" >&2;}
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: (see the INSTALL.md file for more info)" >&5
-$as_echo "$as_me: WARNING: (see the INSTALL.md file for more info)" >&2;}
-	fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking packet capture type" >&5
-$as_echo_n "checking packet capture type... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $V_PCAP" >&5
-$as_echo "$V_PCAP" >&6; }
-
-
-#
-# Do we have pkg-config?
-#
-
-
-
-
-
-
-
-if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
-	if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
-set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PKG_CONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $PKG_CONFIG in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  ;;
-esac
-fi
-PKG_CONFIG=$ac_cv_path_PKG_CONFIG
-if test -n "$PKG_CONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
-$as_echo "$PKG_CONFIG" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_path_PKG_CONFIG"; then
-  ac_pt_PKG_CONFIG=$PKG_CONFIG
-  # Extract the first word of "pkg-config", so it can be a program name with args.
-set dummy pkg-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_ac_pt_PKG_CONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $ac_pt_PKG_CONFIG in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_ac_pt_PKG_CONFIG="$ac_pt_PKG_CONFIG" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_ac_pt_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  ;;
-esac
-fi
-ac_pt_PKG_CONFIG=$ac_cv_path_ac_pt_PKG_CONFIG
-if test -n "$ac_pt_PKG_CONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_pt_PKG_CONFIG" >&5
-$as_echo "$ac_pt_PKG_CONFIG" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_pt_PKG_CONFIG" = x; then
-    PKG_CONFIG=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    PKG_CONFIG=$ac_pt_PKG_CONFIG
-  fi
-else
-  PKG_CONFIG="$ac_cv_path_PKG_CONFIG"
-fi
-
-fi
-if test -n "$PKG_CONFIG"; then
-	_pkg_min_version=0.17.0
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking pkg-config is at least version $_pkg_min_version" >&5
-$as_echo_n "checking pkg-config is at least version $_pkg_min_version... " >&6; }
-	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		PKG_CONFIG=""
-	fi
-fi
-
-#
-# Do we have the brew command from Homebrew?
-#
-# Extract the first word of "brew", so it can be a program name with args.
-set dummy brew; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_BREW+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $BREW in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_BREW="$BREW" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_BREW="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  ;;
-esac
-fi
-BREW=$ac_cv_path_BREW
-if test -n "$BREW"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BREW" >&5
-$as_echo "$BREW" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-#
-# Solaris pkg-config is annoying.  For at least one package (D-Bus, I'm
-# looking at *you*!), there are separate include files for 32-bit and
-# 64-bit builds (I guess using "unsigned long long" as a 64-bit integer
-# type on a 64-bit build is like crossing the beams or soething), and
-# there are two separate .pc files, so if we're doing a 32-bit build we
-# should make sure we look in /usr/lib/pkgconfig for .pc files and if
-# we're doing a 64-bit build we should make sure we look in
-# /usr/lib/amd64/pkgconfig for .pc files.
-#
-case "$host_os" in
-
-solaris*)
-	if test "$ac_cv_sizeof_void_p" -eq 8; then
-		#
-		# 64-bit build.  If the path is empty, set it to
-                # /usr/lib/amd64/pkgconfig; otherwise, if
-                # /usr/lib/pkgconfig appears in the path, prepend
-		# /usr/lib/amd64/pkgconfig to it; otherwise, put
-		# /usr/lib/amd64/pkgconfig at the end.
-		#
-		if test -z "$PKG_CONFIG_PATH"; then
-			#
-			# Not set, or empty.  Set it to
-			# /usr/lib/amd64/pkgconfig.
-			#
-			PKG_CONFIG_PATH=/usr/lib/amd64/pkgconfig
-		elif test ! -z `echo "$PKG_CONFIG_PATH" | grep "/usr/lib/pkgconfig"`; then
-			#
-			# It contains /usr/lib/pkgconfig.  Prepend
-			# /usr/lib/amd64/pkgconfig to /usr/lib/pkgconfig.
-			#
-			PKG_CONFIG_PATH=`echo "$PKG_CONFIG_PATH" | sed "s;/usr/lib/pkgconfig;/usr/lib/amd64/pkgconfig:/usr/lib/pkgconfig;"`
-		else
-			#
-			# Not empty, but doesn't contain /usr/lib/pkgconfig.
-			# Append /usr/lib/amd64/pkgconfig to it.
-			#
-			PKG_CONFIG_PATH="$PKG_CONFIG_PATH:/usr/lib/amd64/pkgconfig"
-		fi
-		export PKG_CONFIG_PATH
-	elif test "$ac_cv_sizeof_void_p" -eq 4; then
-		#
-		# 32-bit build.  If /usr/amd64/lib/pkgconfig appears
-		# in the path, prepend /usr/lib/pkgconfig to it.
-		#
-		if test ! -z `echo "$PKG_CONFIG_PATH" | grep "/usr/lib/amd64/pkgconfig"`; then
-			#
-			# It contains /usr/lib/amd64/pkgconfig.  Prepend
-			# /usr/lib/pkgconfig to /usr/lib/amd64/pkgconfig.
-			#
-			PKG_CONFIG_PATH=`echo "$PKG_CONFIG_PATH" | sed "s;/usr/lib/amd64/pkgconfig;/usr/lib/pkgconfig:/usr/lib/amd64/pkgconfig;"`
-			export PKG_CONFIG_PATH
-		fi
-	fi
-esac
-
-#
-# Handle each capture type.
-#
-case "$V_PCAP" in
-dlpi)
-	#
-	# Checks for some header files.
-	#
-	for ac_header in sys/bufmod.h sys/dlpi_ext.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-	#
-	# Checks to see if Solaris has the public libdlpi(3LIB) library.
-	# Note: The existence of /usr/include/libdlpi.h does not mean it is the
-	# public libdlpi(3LIB) version. Before libdlpi was made public, a
-	# private version also existed, which did not have the same APIs.
-	# Due to a gcc bug, the default search path for 32-bit libraries does
-	# not include /lib, we add it explicitly here.
-	# [http://bugs.opensolaris.org/view_bug.do?bug_id=6619485].
-	# Also, due to the bug above applications that link to libpcap with
-	# libdlpi will have to add "-L/lib" option to "configure".
-	#
-	save_LDFLAGS="$LDFLAGS"
-	LDFLAGS="$LIBS -L/lib"
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlpi_walk in -ldlpi" >&5
-$as_echo_n "checking for dlpi_walk in -ldlpi... " >&6; }
-if ${ac_cv_lib_dlpi_dlpi_walk+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldlpi  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlpi_walk ();
-int
-main ()
-{
-return dlpi_walk ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dlpi_dlpi_walk=yes
-else
-  ac_cv_lib_dlpi_dlpi_walk=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dlpi_dlpi_walk" >&5
-$as_echo "$ac_cv_lib_dlpi_dlpi_walk" >&6; }
-if test "x$ac_cv_lib_dlpi_dlpi_walk" = xyes; then :
-
-			LIBS="-ldlpi $LIBS"
-			LIBS_STATIC="-ldlpi $LIBS_STATIC"
-			LIBS_PRIVATE="-ldlpi $LIBS_PRIVATE"
-			V_PCAP=libdlpi
-
-			#
-			# Capture module plus common code needed for
-			# common functions used by pcap-[dlpi,libdlpi].c
-			#
-			PLATFORM_C_SRC="pcap-libdlpi.c dlpisubs.c"
-
-$as_echo "#define HAVE_LIBDLPI 1" >>confdefs.h
-
-
-else
-
-			V_PCAP=dlpi
-
-			#
-			# Capture module plus common code needed for
-			# common functions used by pcap-[dlpi,libdlpi].c
-			#
-			PLATFORM_C_SRC="pcap-dlpi.c dlpisubs.c"
-
-fi
-
-	LDFLAGS="$save_LDFLAGS"
-
-	#
-	# Checks whether <sys/dlpi.h> is usable, to catch weird SCO
-	# versions of DLPI.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether <sys/dlpi.h> is usable" >&5
-$as_echo_n "checking whether <sys/dlpi.h> is usable... " >&6; }
-	if ${ac_cv_sys_dlpi_usable+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-			#include <sys/types.h>
-			#include <sys/time.h>
-			#include <sys/dlpi.h>
-
-int
-main ()
-{
-int i = DL_PROMISC_PHYS;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_sys_dlpi_usable=yes
-else
-  ac_cv_sys_dlpi_usable=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_dlpi_usable" >&5
-$as_echo "$ac_cv_sys_dlpi_usable" >&6; }
-	if test $ac_cv_sys_dlpi_usable = no ; then
-		as_fn_error $? "<sys/dlpi.h> is not usable on this system; it probably has a non-standard DLPI" "$LINENO" 5
-	fi
-
-	#
-	# Check to see if Solaris has the dl_passive_req_t struct defined
-	# in <sys/dlpi.h>.
-	# This check is for DLPI support for passive modes.
-	# See dlpi(7P) for more details.
-	#
-	ac_fn_c_check_type "$LINENO" "dl_passive_req_t" "ac_cv_type_dl_passive_req_t" "
-		#include <sys/types.h>
-		#include <sys/dlpi.h>
-
-"
-if test "x$ac_cv_type_dl_passive_req_t" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_DL_PASSIVE_REQ_T 1
-_ACEOF
-
-
-fi
-
-	;;
-
-enet)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-enet.c"
-	;;
-
-haiku)
-	#
-	# Capture module
-	#
-	PLATFORM_CXX_SRC="pcap-haiku.cpp"
-
-	#
-	# Just for the sake of it.
-	#
-	for ac_header in net/if.h net/if_dl.h net/if_types.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-	;;
-
-linux)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-linux.c"
-
-	#
-	# Do we have the wireless extensions?
-	#
-	for ac_header in linux/wireless.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "linux/wireless.h" "ac_cv_header_linux_wireless_h" "
-#include <sys/socket.h>
-#include <linux/if.h>
-#include <linux/types.h>
-
-"
-if test "x$ac_cv_header_linux_wireless_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_WIRELESS_H 1
-_ACEOF
-
-fi
-
-done
-
-
-	#
-	# Do we have libnl?
-	# We only want version 3.  Version 2 was, apparently,
-	# short-lived, and version 1 is source and binary
-	# incompatible with version 3, and it appears that,
-	# these days, everybody's using version 3.  We're
-	# not supporting older versions of the Linux kernel;
-	# let's drop support for older versions of libnl, too.
-	#
-
-# Check whether --with-libnl was given.
-if test "${with_libnl+set}" = set; then :
-  withval=$with_libnl; with_libnl=$withval
-else
-  with_libnl=if_available
-fi
-
-
-	if test x$with_libnl != xno ; then
-		#
-		# Check for libnl-genl-3.0 with pkg-config.
-		#
-
-
-pkg_failed=no
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for libnl-genl-3.0 with pkg-config" >&5
-$as_echo_n "checking for libnl-genl-3.0 with pkg-config... " >&6; }
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-genl-3.0\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libnl-genl-3.0") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-
-	#
-	# The package was found, so try to get its C flags and
-	# libraries.
-	#
-	if test -n "$LIBNL_CFLAGS"; then
-    pkg_cv_LIBNL_CFLAGS="$LIBNL_CFLAGS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-genl-3.0\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libnl-genl-3.0") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBNL_CFLAGS=`$PKG_CONFIG --cflags "libnl-genl-3.0" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$LIBNL_LIBS"; then
-    pkg_cv_LIBNL_LIBS="$LIBNL_LIBS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-genl-3.0\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libnl-genl-3.0") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBNL_LIBS=`$PKG_CONFIG --libs "libnl-genl-3.0" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$LIBNL_LIBS_STATIC"; then
-    pkg_cv_LIBNL_LIBS_STATIC="$LIBNL_LIBS_STATIC"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-genl-3.0\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libnl-genl-3.0") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBNL_LIBS_STATIC=`$PKG_CONFIG --libs --static "libnl-genl-3.0" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-
-
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: error" >&5
-$as_echo "error" >&6; }
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-	        if test $_pkg_short_errors_supported = yes; then
-		        LIBNL_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libnl-genl-3.0" 2>&1`
-	        else
-		        LIBNL_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libnl-genl-3.0" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$LIBNL_PKG_ERRORS" >&5
-
-		as_fn_error $? "Package requirements (libnl-genl-3.0) were not met:
-
-$LIBNL_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-
-Alternatively, you may set the environment variables LIBNL_CFLAGS
-and LIBNL_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details." "$LINENO" 5
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found (pkg-config not found)" >&5
-$as_echo "not found (pkg-config not found)" >&6; }
-	else
-		#
-		# We found the package.
-		#
-		LIBNL_CFLAGS=$pkg_cv_LIBNL_CFLAGS
-		LIBNL_LIBS=$pkg_cv_LIBNL_LIBS
-		LIBNL_LIBS_STATIC=$pkg_cv_LIBNL_LIBS_STATIC
-	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
-$as_echo "found" >&6; }
-
-			pkg_config_found_libnl=yes
-			V_INCLS="$V_INCLS $LIBNL_CFLAGS"
-			ADDITIONAL_LIBS="$LIBNL_LIBS $ADDITIONAL_LIBS"
-			ADDITIONAL_LIBS_STATIC="$LIBNL_LIBS_STATIC $ADDITIONAL_LIBS_STATIC"
-			REQUIRES_PRIVATE="libnl-genl-3.0 $REQUIRES_PRIVATE"
-
-$as_echo "#define HAVE_LIBNL 1" >>confdefs.h
-
-
-	fi
-else
-
-	#
-	# The package isn't present.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-
-fi
-
-
-		if test x$pkg_config_found_libnl != xyes; then
-			#
-			# OK, either we don't have pkg-config or there
-			# wasn't a .pc file for it; Check for it directly.
-			#
-			case "$with_libnl" in
-
-			yes|if_available)
-				incdir=-I/usr/include/libnl3
-				libnldir=
-				;;
-
-			*)
-				if test -d $withval; then
-					libnldir=-L${withval}/lib
-					incdir=-I${withval}/include
-				fi
-				;;
-			esac
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for nl_socket_alloc in -lnl-3" >&5
-$as_echo_n "checking for nl_socket_alloc in -lnl-3... " >&6; }
-if ${ac_cv_lib_nl_3_nl_socket_alloc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnl-3 ${incdir} ${libnldir} -lnl-genl-3 -lnl-3  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char nl_socket_alloc ();
-int
-main ()
-{
-return nl_socket_alloc ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_nl_3_nl_socket_alloc=yes
-else
-  ac_cv_lib_nl_3_nl_socket_alloc=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nl_3_nl_socket_alloc" >&5
-$as_echo "$ac_cv_lib_nl_3_nl_socket_alloc" >&6; }
-if test "x$ac_cv_lib_nl_3_nl_socket_alloc" = xyes; then :
-
-				#
-				# Yes, we have libnl 3.x.
-				#
-				ADDITIONAL_LIBS="${libnldir} -lnl-genl-3 -lnl-3 $ADDITIONAL_LIBS"
-				ADDITIONAL_LIBS_STATIC="${libnldir} -lnl-genl-3 -lnl-3 $ADDITIONAL_LIBS_STATIC"
-				LIBS_PRIVATE="${libnldir} -lnl-genl-3 -lnl-3 $LIBS_PRIVATE"
-
-$as_echo "#define HAVE_LIBNL 1" >>confdefs.h
-
-				V_INCLS="$V_INCLS ${incdir}"
-
-else
-
-				#
-				# No, we don't have libnl at all.
-				# Fail if the user explicitly requested
-				# it.
-				#
-				if test x$with_libnl = xyes ; then
-					as_fn_error $? "libnl support requested but libnl not found" "$LINENO" 5
-				fi
-
-fi
-
-		fi
-	fi
-
-	#
-	# Check to see if the tpacket_auxdata struct has a tp_vlan_tci member.
-	#
-	# NOTE: any failure means we conclude that it doesn't have that
-	# member, so if we don't have tpacket_auxdata, we conclude it
-	# doesn't have that member (which is OK, as either we won't be
-	# using code that would use that member, or we wouldn't compile
-	# in any case).
-	ac_fn_c_check_member "$LINENO" "struct tpacket_auxdata" "tp_vlan_tci" "ac_cv_member_struct_tpacket_auxdata_tp_vlan_tci" "
-		#include <sys/types.h>
-		#include <linux/if_packet.h>
-
-"
-if test "x$ac_cv_member_struct_tpacket_auxdata_tp_vlan_tci" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI 1
-_ACEOF
-
-
-fi
-
-	;;
-
-bpf)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-bpf.c"
-
-	#
-	# Check whether we have the *BSD-style ioctls.
-	#
-	for ac_header in net/if_media.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "net/if_media.h" "ac_cv_header_net_if_media_h" "$ac_includes_default"
-if test "x$ac_cv_header_net_if_media_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_NET_IF_MEDIA_H 1
-_ACEOF
-
-fi
-
-done
-
-
-	#
-	# Check whether we have struct BPF_TIMEVAL.
-	#
-	ac_fn_c_check_type "$LINENO" "struct BPF_TIMEVAL" "ac_cv_type_struct_BPF_TIMEVAL" "
-		#include <sys/types.h>
-		#include <sys/ioctl.h>
-		#ifdef HAVE_SYS_IOCCOM_H
-		#include <sys/ioccom.h>
-		#endif
-		#include <net/bpf.h>
-
-"
-if test "x$ac_cv_type_struct_BPF_TIMEVAL" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_BPF_TIMEVAL 1
-_ACEOF
-
-
-fi
-
-	;;
-
-pf)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-pf.c"
-	;;
-
-snit)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-snit.c"
-	;;
-
-snoop)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-snoop.c"
-	;;
-
-dag)
-	#
-	# --with-pcap=dag is the only way to get here, and it means
-	# "DAG support but nothing else"
-	#
-	V_DEFS="$V_DEFS -DDAG_ONLY"
-	PLATFORM_C_SRC="pcap-dag.c"
-	xxx_only=yes
-	;;
-
-dpdk)
-	#
-	# --with-pcap=dpdk is the only way to get here, and it means
-	# "DPDK support but nothing else"
-	#
-	V_DEFS="$V_DEFS -DDPDK_ONLY"
-	PLATFORM_C_SRC="pcap-dpdk.c"
-	xxx_only=yes
-	;;
-
-septel)
-	#
-	# --with-pcap=septel is the only way to get here, and it means
-	# "Septel support but nothing else"
-	#
-	V_DEFS="$V_DEFS -DSEPTEL_ONLY"
-	PLATFORM_C_SRC="pcap-septel.c"
-	xxx_only=yes
-	;;
-
-snf)
-	#
-	# --with-pcap=snf is the only way to get here, and it means
-	# "SNF support but nothing else"
-	#
-	V_DEFS="$V_DEFS -DSNF_ONLY"
-	PLATFORM_C_SRC="pcap-snf.c"
-	xxx_only=yes
-	;;
-
-null)
-	#
-	# Capture module
-	#
-	PLATFORM_C_SRC="pcap-null.c"
-	;;
-
-*)
-	as_fn_error $? "$V_PCAP is not a valid pcap type" "$LINENO" 5
-	;;
-esac
-
-if test "$V_PCAP" != null
-then
-	ac_fn_c_check_func "$LINENO" "getifaddrs" "ac_cv_func_getifaddrs"
-if test "x$ac_cv_func_getifaddrs" = xyes; then :
-
-		#
-		# We have "getifaddrs()"; make sure we have <ifaddrs.h>
-		# as well, just in case some platform is really weird.
-		#
-		ac_fn_c_check_header_mongrel "$LINENO" "ifaddrs.h" "ac_cv_header_ifaddrs_h" "$ac_includes_default"
-if test "x$ac_cv_header_ifaddrs_h" = xyes; then :
-
-		    #
-		    # We have the header, so we use "getifaddrs()" to
-		    # get the list of interfaces.
-		    #
-		    PLATFORM_C_SRC="$PLATFORM_C_SRC fad-getad.c"
-
-else
-
-		    #
-		    # We don't have the header - give up.
-		    # XXX - we could also fall back on some other
-		    # mechanism, but, for now, this'll catch this
-		    # problem so that we can at least try to figure
-		    # out something to do on systems with "getifaddrs()"
-		    # but without "ifaddrs.h", if there is something
-		    # we can do on those systems.
-		    #
-		    as_fn_error $? "Your system has getifaddrs() but doesn't have a usable <ifaddrs.h>." "$LINENO" 5
-
-fi
-
-
-
-else
-
-		#
-		# Well, we don't have "getifaddrs()", at least not with the
-		# libraries with which we've decided we need to link
-		# libpcap with, so we have to use some other mechanism.
-		#
-		# Note that this may happen on Solaris, which has
-		# getifaddrs(), but in -lsocket, not in -lxnet, so we
-		# won't find it if we link with -lxnet, which we want
-		# to do for other reasons.
-		#
-		# For now, we use either the SIOCGIFCONF ioctl or the
-		# SIOCGLIFCONF ioctl, preferring the latter if we have
-		# it; the latter is a Solarisism that first appeared
-		# in Solaris 8.  (Solaris's getifaddrs() appears to
-		# be built atop SIOCGLIFCONF; using it directly
-		# avoids a not-all-that-useful middleman.)
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we have SIOCGLIFCONF" >&5
-$as_echo_n "checking whether we have SIOCGLIFCONF... " >&6; }
-		if ${ac_cv_lbl_have_siocglifconf+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/param.h>
-			#include <sys/file.h>
-			#include <sys/ioctl.h>
-			#include <sys/socket.h>
-			#include <sys/sockio.h>
-int
-main ()
-{
-ioctl(0, SIOCGLIFCONF, (char *)0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_lbl_have_siocglifconf=yes
-else
-  ac_cv_lbl_have_siocglifconf=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lbl_have_siocglifconf" >&5
-$as_echo "$ac_cv_lbl_have_siocglifconf" >&6; }
-		if test $ac_cv_lbl_have_siocglifconf = yes ; then
-			PLATFORM_C_SRC="$PLATFORM_C_SRC fad-glifc.c"
-		else
-			PLATFORM_C_SRC="$PLATFORM_C_SRC fad-gifc.c"
-		fi
-
-fi
-
-fi
-
-case "$host_os" in
-linux*)
-	for ac_header in linux/net_tstamp.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "linux/net_tstamp.h" "ac_cv_header_linux_net_tstamp_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_net_tstamp_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_NET_TSTAMP_H 1
-_ACEOF
-
-fi
-
-done
-
-	;;
-*)
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: no hardware timestamp support implemented for $host_os" >&5
-$as_echo "$as_me: no hardware timestamp support implemented for $host_os" >&6;}
-	;;
-esac
-
-#
-# Check for socklen_t.
-#
-ac_fn_c_check_type "$LINENO" "socklen_t" "ac_cv_type_socklen_t" "
-	#include <sys/types.h>
-	#include <sys/socket.h>
-
-"
-if test "x$ac_cv_type_socklen_t" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SOCKLEN_T 1
-_ACEOF
-
-
-fi
-
-
-# Check whether --enable-ipv6 was given.
-if test "${enable_ipv6+set}" = set; then :
-  enableval=$enable_ipv6;
-else
-  enable_ipv6=yes
-fi
-
-if test "$enable_ipv6" != "no"; then
-	#
-	# We've already made sure we have getaddrinfo above in
-	# AC_LBL_LIBRARY_NET.
-	#
-
-$as_echo "#define INET6 1" >>confdefs.h
-
-fi
-
-# Check for Endace DAG card support.
-
-# Check whether --with-dag was given.
-if test "${with_dag+set}" = set; then :
-  withval=$with_dag;
-	if test "$withval" = no
-	then
-		# User doesn't want DAG support.
-		want_dag=no
-	elif test "$withval" = yes
-	then
-		# User wants DAG support but hasn't specified a directory.
-		want_dag=yes
-	else
-		# User wants DAG support and has specified a directory, so use the provided value.
-		want_dag=yes
-		dag_root=$withval
-	fi
-
-else
-
-	if test "$V_PCAP" = dag; then
-		# User requested DAG-only libpcap, so we'd better have
-		# the DAG API.
-		want_dag=yes
-	elif test "xxx_only" = yes; then
-		# User requested something-else-only pcap, so they don't
-		# want DAG support.
-		want_dag=no
-	else
-		#
-		# Use DAG API if present, otherwise don't
-		#
-		want_dag=ifpresent
-	fi
-
-fi
-
-
-
-# Check whether --with-dag-includes was given.
-if test "${with_dag_includes+set}" = set; then :
-  withval=$with_dag_includes;
-	# User wants DAG support and has specified a header directory, so use the provided value.
-	want_dag=yes
-	dag_include_dir=$withval
-
-fi
-
-
-
-# Check whether --with-dag-libraries was given.
-if test "${with_dag_libraries+set}" = set; then :
-  withval=$with_dag_libraries;
-	# User wants DAG support and has specified a library directory, so use the provided value.
-	want_dag=yes
-	dag_lib_dir=$withval
-
-fi
-
-
-if test "$want_dag" != no; then
-
-	# If necessary, set default paths for DAG API headers and libraries.
-	if test -z "$dag_root"; then
-		dag_root=/usr/local
-	fi
-
-	if test -z "$dag_include_dir"; then
-		dag_include_dir="$dag_root/include"
-	fi
-
-	if test -z "$dag_lib_dir"; then
-		dag_lib_dir="$dag_root/lib"
-		#
-		# Handle multiarch systems.
-		#
-		if test -d "$dag_lib_dir/$host"
-		then
-			dag_lib_dir="$dag_lib_dir/$host"
-		fi
-	fi
-
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-	CFLAGS="$CFLAGS -I$dag_include_dir"
-	for ac_header in dagapi.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "dagapi.h" "ac_cv_header_dagapi_h" "$ac_includes_default"
-if test "x$ac_cv_header_dagapi_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DAGAPI_H 1
-_ACEOF
-
-fi
-
-done
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-
-	if test "$ac_cv_header_dagapi_h" = yes; then
-
-		V_INCLS="$V_INCLS -I$dag_include_dir"
-
-		if test $V_PCAP != dag ; then
-			 MODULE_C_SRC="$MODULE_C_SRC pcap-dag.c"
-		fi
-
-		# Check for various DAG API functions.
-		# Don't need to save and restore LIBS to prevent -ldag being
-		# included if there's a found-action (arg 3).
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		LDFLAGS="-L$dag_lib_dir"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dag_attach_stream in -ldag" >&5
-$as_echo_n "checking for dag_attach_stream in -ldag... " >&6; }
-if ${ac_cv_lib_dag_dag_attach_stream+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldag  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dag_attach_stream ();
-int
-main ()
-{
-return dag_attach_stream ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dag_dag_attach_stream=yes
-else
-  ac_cv_lib_dag_dag_attach_stream=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dag_dag_attach_stream" >&5
-$as_echo "$ac_cv_lib_dag_dag_attach_stream" >&6; }
-if test "x$ac_cv_lib_dag_dag_attach_stream" = xyes; then :
-
-			#
-			# We assume that if we have libdag we have
-			# libdagconf, as they're installed at the
-			# same time from the same package.
-			#
-			ADDITIONAL_LIBS="-L$dag_lib_dir $ADDITIONAL_LIBS -ldag -ldagconf"
-			ADDITIONAL_LIBS_STATIC="-L$dag_lib_dir $ADDITIONAL_LIBS_STATIC -ldag -ldagconf"
-			LIBS_PRIVATE="-L$dag_lib_dir $LIBS_PRIVATE -ldag -ldagconf"
-
-else
-  as_fn_error $? "DAG library lacks streams support" "$LINENO" 5
-fi
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dag_attach_stream64 in -ldag" >&5
-$as_echo_n "checking for dag_attach_stream64 in -ldag... " >&6; }
-if ${ac_cv_lib_dag_dag_attach_stream64+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldag  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dag_attach_stream64 ();
-int
-main ()
-{
-return dag_attach_stream64 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dag_dag_attach_stream64=yes
-else
-  ac_cv_lib_dag_dag_attach_stream64=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dag_dag_attach_stream64" >&5
-$as_echo "$ac_cv_lib_dag_dag_attach_stream64" >&6; }
-if test "x$ac_cv_lib_dag_dag_attach_stream64" = xyes; then :
-  dag_large_streams="1"
-else
-  dag_large_streams="0"
-fi
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dag_get_erf_types in -ldag" >&5
-$as_echo_n "checking for dag_get_erf_types in -ldag... " >&6; }
-if ${ac_cv_lib_dag_dag_get_erf_types+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldag  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dag_get_erf_types ();
-int
-main ()
-{
-return dag_get_erf_types ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dag_dag_get_erf_types=yes
-else
-  ac_cv_lib_dag_dag_get_erf_types=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dag_dag_get_erf_types" >&5
-$as_echo "$ac_cv_lib_dag_dag_get_erf_types" >&6; }
-if test "x$ac_cv_lib_dag_dag_get_erf_types" = xyes; then :
-
-
-$as_echo "#define HAVE_DAG_GET_ERF_TYPES 1" >>confdefs.h
-
-fi
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dag_get_stream_erf_types in -ldag" >&5
-$as_echo_n "checking for dag_get_stream_erf_types in -ldag... " >&6; }
-if ${ac_cv_lib_dag_dag_get_stream_erf_types+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldag  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dag_get_stream_erf_types ();
-int
-main ()
-{
-return dag_get_stream_erf_types ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dag_dag_get_stream_erf_types=yes
-else
-  ac_cv_lib_dag_dag_get_stream_erf_types=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dag_dag_get_stream_erf_types" >&5
-$as_echo "$ac_cv_lib_dag_dag_get_stream_erf_types" >&6; }
-if test "x$ac_cv_lib_dag_dag_get_stream_erf_types" = xyes; then :
-
-
-$as_echo "#define HAVE_DAG_GET_STREAM_ERF_TYPES 1" >>confdefs.h
-
-fi
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-
-		#
-		# We assume that if we have libdag we have libdagconf,
-		# as they're installed at the same time from the same
-		# package.
-		#
-		if test "$dag_large_streams" = 1; then
-
-$as_echo "#define HAVE_DAG_LARGE_STREAMS_API 1" >>confdefs.h
-
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-			LIBS="$LIBS -ldag -ldagconf"
-			LDFLAGS="$LDFLAGS -L$dag_lib_dir"
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for vdag_set_device_info in -lvdag" >&5
-$as_echo_n "checking for vdag_set_device_info in -lvdag... " >&6; }
-if ${ac_cv_lib_vdag_vdag_set_device_info+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lvdag  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char vdag_set_device_info ();
-int
-main ()
-{
-return vdag_set_device_info ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_vdag_vdag_set_device_info=yes
-else
-  ac_cv_lib_vdag_vdag_set_device_info=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_vdag_vdag_set_device_info" >&5
-$as_echo "$ac_cv_lib_vdag_vdag_set_device_info" >&6; }
-if test "x$ac_cv_lib_vdag_vdag_set_device_info" = xyes; then :
-  ac_dag_have_vdag="1"
-else
-  ac_dag_have_vdag="0"
-fi
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-			if test "$ac_dag_have_vdag" = 1; then
-
-$as_echo "#define HAVE_DAG_VDAG 1" >>confdefs.h
-
-				if test "$ac_lbl_have_pthreads" != "found"; then
-					as_fn_error $? "DAG requires pthreads, but we didn't find them" "$LINENO" 5
-				fi
-				ADDITIONAL_LIBS="$ADDITIONAL_LIBS $PTHREAD_LIBS"
-				ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $PTHREAD_LIBS"
-				LIBS_PRIVATE="$LIBS_PRIVATE $PTHREAD_LIBS"
-			fi
-		fi
-
-
-$as_echo "#define HAVE_DAG_API 1" >>confdefs.h
-
-	else
-		if test "$V_PCAP" = dag; then
-			# User requested "dag" capture type but we couldn't
-			# find the DAG API support.
-			as_fn_error $? "DAG support requested with --with-pcap=dag, but the DAG headers weren't found at $dag_include_dir: make sure the DAG support is installed, specify a different path or paths if necessary, or don't request DAG support" "$LINENO" 5
-		fi
-
-		if test "$want_dag" = yes; then
-			# User wanted DAG support but we couldn't find it.
-			as_fn_error $? "DAG support requested with --with-dag, but the DAG headers weren't found at $dag_include_dir: make sure the DAG support is installed, specify a different path or paths if necessary, or don't request DAG support" "$LINENO" 5
-		fi
-	fi
-	CFLAGS="$save_CFLAGS"
-fi
-
-
-# Check whether --with-septel was given.
-if test "${with_septel+set}" = set; then :
-  withval=$with_septel;
-	if test "$withval" = no
-	then
-		want_septel=no
-	elif test "$withval" = yes
-	then
-		want_septel=yes
-		septel_root=
-	else
-		want_septel=yes
-		septel_root=$withval
-	fi
-
-else
-
-	if test "$V_PCAP" = septel; then
-		# User requested Septel-only libpcap, so we'd better have
-		# the Septel API.
-		want_septel=yes
-	elif test "xxx_only" = yes; then
-		# User requested something-else-only pcap, so they don't
-		# want Septel support.
-		want_septel=no
-	else
-		#
-		# Use Septel API if present, otherwise don't
-		#
-		want_septel=ifpresent
-	fi
-
-fi
-
-
-ac_cv_lbl_septel_api=no
-if test "$with_septel" != no; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we have Septel API headers" >&5
-$as_echo_n "checking whether we have Septel API headers... " >&6; }
-
-	# If necessary, set default paths for Septel API headers and libraries.
-	if test -z "$septel_root"; then
-		septel_root=$srcdir/../septel
-	fi
-
-	septel_tools_dir="$septel_root"
-	septel_include_dir="$septel_root/INC"
-
-	if test -r "$septel_include_dir/msg.h"; then
-		ac_cv_lbl_septel_api=yes
-	fi
-
-	if test "$ac_cv_lbl_septel_api" = yes; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes ($septel_include_dir)" >&5
-$as_echo "yes ($septel_include_dir)" >&6; }
-
-		V_INCLS="$V_INCLS -I$septel_include_dir"
-		ADDLOBJS="$ADDLOBJS $septel_tools_dir/asciibin.o $septel_tools_dir/bit2byte.o $septel_tools_dir/confirm.o $septel_tools_dir/fmtmsg.o $septel_tools_dir/gct_unix.o $septel_tools_dir/hqueue.o $septel_tools_dir/ident.o $septel_tools_dir/mem.o $septel_tools_dir/pack.o $septel_tools_dir/parse.o $septel_tools_dir/pool.o $septel_tools_dir/sdlsig.o $septel_tools_dir/strtonum.o $septel_tools_dir/timer.o $septel_tools_dir/trace.o"
-		ADDLARCHIVEOBJS="$ADDLARCHIVEOBJS $septel_tools_dir/asciibin.o $septel_tools_dir/bit2byte.o $septel_tools_dir/confirm.o $septel_tools_dir/fmtmsg.o $septel_tools_dir/gct_unix.o $septel_tools_dir/hqueue.o $septel_tools_dir/ident.o $septel_tools_dir/mem.o $septel_tools_dir/pack.o $septel_tools_dir/parse.o $septel_tools_dir/pool.o $septel_tools_dir/sdlsig.o $septel_tools_dir/strtonum.o $septel_tools_dir/timer.o $septel_tools_dir/trace.o"
-
-		if test "$V_PCAP" != septel ; then
-			 MODULE_C_SRC="$MODULE_C_SRC pcap-septel.c"
-		fi
-
-
-$as_echo "#define HAVE_SEPTEL_API 1" >>confdefs.h
-
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-		if test "$V_PCAP" = septel; then
-			# User requested "septel" capture type but
-			# we couldn't find the Septel API support.
-			as_fn_error $? "Septel support requested with --with-pcap=septel, but the Septel headers weren't found at $septel_include_dir: make sure the Septel support is installed, specify a different path or paths if necessary, or don't request Septel support" "$LINENO" 5
-		fi
-
-		if test "$want_septel" = yes; then
-			# User wanted Septel support but we couldn't find it.
-			as_fn_error $? "Septel support requested with --with-septel, but the Septel headers weren't found at $septel_include_dir: make sure the Septel support is installed, specify a different path or paths if necessary, or don't request Septel support" "$LINENO" 5
-		fi
-	fi
-fi
-
-# Check for Myricom SNF support.
-
-# Check whether --with-snf was given.
-if test "${with_snf+set}" = set; then :
-  withval=$with_snf;
-	if test "$withval" = no
-	then
-		# User explicitly doesn't want SNF
-		want_snf=no
-	elif test "$withval" = yes
-	then
-		# User wants SNF support but hasn't specified a directory.
-		want_snf=yes
-	else
-		# User wants SNF support with a specified directory.
-		want_snf=yes
-		snf_root=$withval
-	fi
-
-else
-
-	if test "$V_PCAP" = snf; then
-		# User requested Sniffer-only libpcap, so we'd better have
-		# the Sniffer API.
-		want_snf=yes
-	elif test "xxx_only" = yes; then
-		# User requested something-else-only pcap, so they don't
-		# want SNF support.
-		want_snf=no
-	else
-		#
-		# Use Sniffer API if present, otherwise don't
-		#
-		want_snf=ifpresent
-	fi
-
-fi
-
-
-
-# Check whether --with-snf-includes was given.
-if test "${with_snf_includes+set}" = set; then :
-  withval=$with_snf_includes;
-	# User wants SNF with specific header directory
-	want_snf=yes
-	snf_include_dir=$withval
-
-fi
-
-
-
-# Check whether --with-snf-libraries was given.
-if test "${with_snf_libraries+set}" = set; then :
-  withval=$with_snf_libraries;
-	# User wants SNF with specific lib directory
-	want_snf=yes
-	snf_lib_dir=$withval
-
-fi
-
-
-ac_cv_lbl_snf_api=no
-if test "$with_snf" != no; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we have Myricom Sniffer API" >&5
-$as_echo_n "checking whether we have Myricom Sniffer API... " >&6; }
-
-	# If necessary, set default paths for Sniffer headers and libraries.
-	if test -z "$snf_root"; then
-		snf_root=/opt/snf
-	fi
-
-	if test -z "$snf_include_dir"; then
-		snf_include_dir="$snf_root/include"
-	fi
-
-	if test -z "$snf_lib_dir"; then
-		snf_lib_dir="$snf_root/lib"
-		#
-		# Handle multiarch systems.
-		#
-		if test -d "$snf_lib_dir/$host"
-		then
-			snf_lib_dir="$snf_lib_dir/$host"
-		fi
-	fi
-
-	if test -f "$snf_include_dir/snf.h"; then
-		# We found a header; make sure we can link with the library
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		LDFLAGS="$LDFLAGS -L$snf_lib_dir"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for snf_init in -lsnf" >&5
-$as_echo_n "checking for snf_init in -lsnf... " >&6; }
-if ${ac_cv_lib_snf_snf_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsnf  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char snf_init ();
-int
-main ()
-{
-return snf_init ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_snf_snf_init=yes
-else
-  ac_cv_lib_snf_snf_init=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_snf_snf_init" >&5
-$as_echo "$ac_cv_lib_snf_snf_init" >&6; }
-if test "x$ac_cv_lib_snf_snf_init" = xyes; then :
-  ac_cv_lbl_snf_api="yes"
-fi
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-		if test "$ac_cv_lbl_snf_api" = no; then
-			as_fn_error $? "SNF API cannot correctly be linked; check config.log" "$LINENO" 5
-		fi
-	fi
-
-	if test "$ac_cv_lbl_snf_api" = yes; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes ($snf_root)" >&5
-$as_echo "yes ($snf_root)" >&6; }
-
-		V_INCLS="$V_INCLS -I$snf_include_dir"
-		ADDITIONAL_LIBS="$ADDITIONAL_LIBS -L$snf_lib_dir -lsnf"
-		ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC -L$snf_lib_dir -lsnf"
-		LIBS_PRIVATE="$LIBS_PRIVATE -L$snf_lib_dir -lsnf"
-
-		if test "$V_PCAP" != snf ; then
-			MODULE_C_SRC="$MODULE_C_SRC pcap-snf.c"
-		fi
-
-
-$as_echo "#define HAVE_SNF_API 1" >>confdefs.h
-
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-		if test "$want_snf" = yes; then
-			# User requested "snf" capture type but
-			# we couldn't find the Sniffer API support.
-			as_fn_error $? "Myricom Sniffer support requested with --with-pcap=snf, but the Sniffer headers weren't found at $snf_include_dir: make sure the Sniffer support is installed, specify a different path or paths if necessary, or don't request Sniffer support" "$LINENO" 5
-		fi
-
-		if test "$want_snf" = yes; then
-			as_fn_error $? "Myricom Sniffer support requested with --with-snf, but the Sniffer headers weren't found at $snf_include_dir: make sure the Sniffer support is installed, specify a different path or paths if necessary, or don't request Sniffer support" "$LINENO" 5
-		fi
-	fi
-fi
-
-# Check for Riverbed TurboCap support.
-
-# Check whether --with-turbocap was given.
-if test "${with_turbocap+set}" = set; then :
-  withval=$with_turbocap;
-	if test "$withval" = no
-	then
-		# User explicitly doesn't want TurboCap
-		want_turbocap=no
-	elif test "$withval" = yes
-	then
-		# User wants TurboCap support but hasn't specified a directory.
-		want_turbocap=yes
-	else
-		# User wants TurboCap support with a specified directory.
-		want_turbocap=yes
-		turbocap_root=$withval
-	fi
-
-else
-
-	if test "xxx_only" = yes; then
-		# User requested something-else-only pcap, so they don't
-		# want TurboCap support.
-		want_turbocap=no
-	else
-		#
-		# Use TurboCap API if present, otherwise don't
-		#
-		want_turbocap=ifpresent
-	fi
-
-fi
-
-
-ac_cv_lbl_turbocap_api=no
-if test "$want_turbocap" != no; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether TurboCap is supported" >&5
-$as_echo_n "checking whether TurboCap is supported... " >&6; }
-
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-	if test ! -z "$turbocap_root"; then
-		TURBOCAP_CFLAGS="-I$turbocap_root/include"
-		TURBOCAP_LDFLAGS="-L$turbocap_root/lib"
-		CFLAGS="$CFLAGS $TURBOCAP_CFLAGS"
-		LDFLAGS="$LDFLAGS $TURBOCAP_LDFLAGS"
-	fi
-
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-	    #include <TcApi.h>
-
-int
-main ()
-{
-
-	    TC_INSTANCE a; TC_PORT b; TC_BOARD c;
-	    TC_INSTANCE i;
-	    (void)TcInstanceCreateByName("foo", &i);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_lbl_turbocap_api=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-	if test $ac_cv_lbl_turbocap_api = yes; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-		MODULE_C_SRC="$MODULE_C_SRC pcap-tc.c"
-		V_INCLS="$V_INCLS $TURBOCAP_CFLAGS"
-		ADDITIONAL_LIBS="$ADDITIONAL_LIBS $TURBOCAP_LDFLAGS -lTcApi -lpthread -lstdc++"
-		ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $TURBOCAP_LDFLAGS -lTcApi -lpthread -lstdc++"
-		LIBS_PRIVATE="$LIBS_PRIVATE $TURBOCAP_LDFLAGS -lTcApi -lpthread -lstdc++"
-
-
-$as_echo "#define HAVE_TC_API 1" >>confdefs.h
-
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-		if test "$want_turbocap" = yes; then
-			# User wanted Turbo support but we couldn't find it.
-			as_fn_error $? "TurboCap support requested with --with-turbocap, but the TurboCap headers weren't found: make sure the TurboCap support is installed or don't request TurboCap support" "$LINENO" 5
-		fi
-	fi
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable remote packet capture" >&5
-$as_echo_n "checking whether to enable remote packet capture... " >&6; }
-# Check whether --enable-remote was given.
-if test "${enable_remote+set}" = set; then :
-  enableval=$enable_remote;
-else
-  enableval=no
-fi
-
-case "$enableval" in
-yes)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Remote packet capture may expose libpcap-based applications" >&5
-$as_echo "$as_me: WARNING: Remote packet capture may expose libpcap-based applications" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: to attacks by malicious remote capture servers!" >&5
-$as_echo "$as_me: WARNING: to attacks by malicious remote capture servers!" >&2;}
-	#
-	# rpcapd requires pthreads on UN*X.
-	#
-	if test "$ac_lbl_have_pthreads" != "found"; then
-		as_fn_error $? "rpcapd requires pthreads, but we didn't find them" "$LINENO" 5
-	fi
-	#
-	# It also requires crypt().
-	# Do we have it in the system libraries?
-	#
-	ac_fn_c_check_func "$LINENO" "crypt" "ac_cv_func_crypt"
-if test "x$ac_cv_func_crypt" = xyes; then :
-
-else
-
-		#
-		# No.  Do we have it in -lcrypt?
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for crypt in -lcrypt" >&5
-$as_echo_n "checking for crypt in -lcrypt... " >&6; }
-if ${ac_cv_lib_crypt_crypt+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcrypt  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char crypt ();
-int
-main ()
-{
-return crypt ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_crypt_crypt=yes
-else
-  ac_cv_lib_crypt_crypt=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_crypt_crypt" >&5
-$as_echo "$ac_cv_lib_crypt_crypt" >&6; }
-if test "x$ac_cv_lib_crypt_crypt" = xyes; then :
-
-			#
-			# Yes; add -lcrypt to the libraries for rpcapd.
-			#
-			RPCAPD_LIBS="$RPCAPD_LIBS -lcrypt"
-
-else
-
-			as_fn_error $? "rpcapd requires crypt(), but we didn't find it" "$LINENO" 5
-
-fi
-
-
-fi
-
-
-	#
-	# OK, we have crypt().  Do we have getspnam()?
-	#
-	for ac_func in getspnam
-do :
-  ac_fn_c_check_func "$LINENO" "getspnam" "ac_cv_func_getspnam"
-if test "x$ac_cv_func_getspnam" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GETSPNAM 1
-_ACEOF
-
-fi
-done
-
-
-	#
-	# Check for various members of struct msghdr.
-	#
-	ac_fn_c_check_member "$LINENO" "struct msghdr" "msg_control" "ac_cv_member_struct_msghdr_msg_control" "
-		#include \"ftmacros.h\"
-		#include <sys/socket.h>
-
-"
-if test "x$ac_cv_member_struct_msghdr_msg_control" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MSGHDR_MSG_CONTROL 1
-_ACEOF
-
-
-fi
-
-	ac_fn_c_check_member "$LINENO" "struct msghdr" "msg_flags" "ac_cv_member_struct_msghdr_msg_flags" "
-		#include \"ftmacros.h\"
-		#include <sys/socket.h>
-
-"
-if test "x$ac_cv_member_struct_msghdr_msg_flags" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
-_ACEOF
-
-
-fi
-
-
-	#
-	# Optionally, we may want to support SSL.
-	# Check for OpenSSL/libressl.
-	#
-	# First, try looking for it with pkg-config, if we have it.
-	#
-	# Homebrew's pkg-config does not, by default, look for
-	# pkg-config files for packages it has installed.
-	# Furthermore, at least for OpenSSL, they appear to be
-	# dumped in package-specific directories whose paths are
-	# not only package-specific but package-version-specific.
-	#
-	# So the only way to find openssl is to get the value of
-	# PKG_CONFIG_PATH from "brew --env openssl" and add that
-	# to PKG_CONFIG_PATH.  (No, we can't just assume it's under
-	# /usr/local; Homebrew have conveniently chosen to put it
-	# under /opt/homebrew on ARM.)
-	#
-	# That's the nice thing about Homebrew - it makes things easier!
-	# Thanks!
-	#
-	save_PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
-	if test -n "$BREW"; then
-		openssl_pkgconfig_dir=`$BREW --env --plain openssl | sed -n 's/PKG_CONFIG_PATH: //p'`
-		PKG_CONFIG_PATH="$openssl_pkgconfig_dir:$PKG_CONFIG_PATH"
-	fi
-
-
-pkg_failed=no
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for openssl with pkg-config" >&5
-$as_echo_n "checking for openssl with pkg-config... " >&6; }
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"openssl\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "openssl") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-
-	#
-	# The package was found, so try to get its C flags and
-	# libraries.
-	#
-	if test -n "$OPENSSL_CFLAGS"; then
-    pkg_cv_OPENSSL_CFLAGS="$OPENSSL_CFLAGS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"openssl\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "openssl") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_OPENSSL_CFLAGS=`$PKG_CONFIG --cflags "openssl" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$OPENSSL_LIBS"; then
-    pkg_cv_OPENSSL_LIBS="$OPENSSL_LIBS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"openssl\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "openssl") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_OPENSSL_LIBS=`$PKG_CONFIG --libs "openssl" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$OPENSSL_LIBS_STATIC"; then
-    pkg_cv_OPENSSL_LIBS_STATIC="$OPENSSL_LIBS_STATIC"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"openssl\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "openssl") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_OPENSSL_LIBS_STATIC=`$PKG_CONFIG --libs --static "openssl" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-
-
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: error" >&5
-$as_echo "error" >&6; }
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-	        if test $_pkg_short_errors_supported = yes; then
-		        OPENSSL_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "openssl" 2>&1`
-	        else
-		        OPENSSL_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "openssl" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$OPENSSL_PKG_ERRORS" >&5
-
-		as_fn_error $? "Package requirements (openssl) were not met:
-
-$OPENSSL_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-
-Alternatively, you may set the environment variables OPENSSL_CFLAGS
-and OPENSSL_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details." "$LINENO" 5
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found (pkg-config not found)" >&5
-$as_echo "not found (pkg-config not found)" >&6; }
-	else
-		#
-		# We found the package.
-		#
-		OPENSSL_CFLAGS=$pkg_cv_OPENSSL_CFLAGS
-		OPENSSL_LIBS=$pkg_cv_OPENSSL_LIBS
-		OPENSSL_LIBS_STATIC=$pkg_cv_OPENSSL_LIBS_STATIC
-	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
-$as_echo "found" >&6; }
-
-		#
-		# We found OpenSSL/libressl.
-		#
-		HAVE_OPENSSL=yes
-		REQUIRES_PRIVATE="$REQUIRES_PRIVATE openssl"
-
-	fi
-else
-
-	#
-	# The package isn't present.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-
-fi
-
-	PKG_CONFIG_PATH="$save_PKG_CONFIG_PATH"
-
-	#
-	# If it wasn't found, and we have Homebrew installed, see
-	# if it's in Homebrew.
-	#
-	if test "x$HAVE_OPENSSL" != "xyes" -a -n "$BREW"; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for openssl in Homebrew" >&5
-$as_echo_n "checking for openssl in Homebrew... " >&6; }
-		#
-		# The brew man page lies when it speaks of
-		# $BREW --prefix --installed <formula>
-		# outputting nothing.  In Homebrew 3.3.16,
-		# it produces output regardless of whether
-		# the formula is installed or not, so we
-		# send the standard output and error to
-		# the bit bucket.
-		#
-		if $BREW --prefix --installed openssl >/dev/null 2>&1; then
-			#
-			# Yes.  Get the include directory and library
-			# directory.  (No, we can't just assume it's
-			# under /usr/local; Homebrew have conveniently
-			# chosen to put it under /opt/homebrew on ARM.)
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			HAVE_OPENSSL=yes
-			openssl_path=`$BREW --prefix openssl`
-			OPENSSL_CFLAGS="-I$openssl_path/include"
-			OPENSSL_LIBS="-L$openssl_path/lib -lssl -lcrypto"
-			OPENSSL_LIBS_STATIC="-L$openssl_path/lib -lssl -lcrypto"
-			OPENSSL_LIBS_PRIVATE="-L$openssl_path/lib -lssl -lcrypto"
-		else
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		fi
-	fi
-
-	#
-	# If it wasn't found, and /usr/local/include and /usr/local/lib
-	# exist, check if it's in /usr/local.  (We check whether they
-	# exist because, if they don't exist, the compiler will warn
-	# about that and then ignore the argument, so they test
-	# using just the system header files and libraries.)
-	#
-	# We include the standard include file to 1) make sure that
-	# it's installed (if it's just a shared library for the
-	# benefit of existing programs, that's not useful) and 2)
-	# because SSL_library_init() is a library routine in some
-	# versions and a #defined wrapper around OPENSSL_init_ssl()
-	# in others.
-	#
-	if test "x$HAVE_OPENSSL" != "xyes" -a -d "/usr/local/include" -a -d "/usr/local/lib"; then
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		CFLAGS="$CFLAGS -I/usr/local/include"
-		LIBS="$LIBS -L/usr/local/lib -lssl -lcrypto"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we have OpenSSL/libressl in /usr/local that we can use" >&5
-$as_echo_n "checking whether we have OpenSSL/libressl in /usr/local that we can use... " >&6; }
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <openssl/ssl.h>
-
-int
-main ()
-{
-
-SSL_library_init();
-return 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			HAVE_OPENSSL=yes
-			OPENSSL_CFLAGS="-I/usr/local/include"
-			OPENSSL_LIBS="-L/usr/local/lib -lssl -lcrypto"
-			OPENSSL_LIBS_STATIC="-L/usr/local/lib -lssl -lcrypto"
-			OPENSSL_LIBS_PRIVATE="-L/usr/local/lib -lssl -lcrypto"
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-	fi
-
-	#
-	# If it wasn't found, check if it's a system library.
-	#
-	# We include the standard include file to 1) make sure that
-	# it's installed (if it's just a shared library for the
-	# benefit of existing programs, that's not useful) and 2)
-	# because SSL_library_init() is a library routine in some
-	# versions and a #defined wrapper around OPENSSL_init_ssl()
-	# in others.
-	#
-	if test "x$HAVE_OPENSSL" != "xyes"; then
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		LIBS="$LIBS -lssl -lcrypto"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we have a system OpenSSL/libressl that we can use" >&5
-$as_echo_n "checking whether we have a system OpenSSL/libressl that we can use... " >&6; }
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <openssl/ssl.h>
-
-int
-main ()
-{
-
-SSL_library_init();
-return 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			HAVE_OPENSSL=yes
-			OPENSSL_LIBS="-lssl -lcrypto"
-			OPENSSL_LIBS_STATIC="-lssl -lcrypto"
-			OPENSSL_LIBS_PRIVATE="-lssl -lcrypto"
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-	fi
-
-	#
-	# OK, did we find it?
-	#
-	if test "x$HAVE_OPENSSL" = "xyes"; then
-
-$as_echo "#define HAVE_OPENSSL 1" >>confdefs.h
-
-		V_INCLS="$V_INCLS $OPENSSL_CFLAGS"
-		ADDITIONAL_LIBS="$ADDITIONAL_LIBS $OPENSSL_LIBS"
-		ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $OPENSSL_LIBS_STATIC"
-		LIBS_PRIVATE="$LIBS_PRIVATE $OPENSSL_LIBS_PRIVATE"
-		REQUIRES_PRIVATE="$REQUIRES_PRIVATE $OPENSSL_REQUIRES_PRIVATE"
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: OpenSSL not found" >&5
-$as_echo "$as_me: OpenSSL not found" >&6;}
-	fi
-
-
-$as_echo "#define ENABLE_REMOTE /**/" >>confdefs.h
-
-	REMOTE_C_SRC="$REMOTE_C_SRC pcap-new.c pcap-rpcap.c rpcap-protocol.c sockutils.c sslutils.c"
-	BUILD_RPCAPD=build-rpcapd
-	INSTALL_RPCAPD=install-rpcapd
-	;;
-*)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-	;;
-esac
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build optimizer debugging code" >&5
-$as_echo_n "checking whether to build optimizer debugging code... " >&6; }
-# Check whether --enable-optimizer-dbg was given.
-if test "${enable_optimizer_dbg+set}" = set; then :
-  enableval=$enable_optimizer_dbg;
-fi
-
-if test "$enable_optimizer_dbg" = "yes"; then
-
-$as_echo "#define BDEBUG 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: ${enable_optimizer_dbg-no}" >&5
-$as_echo "${enable_optimizer_dbg-no}" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build parser debugging code" >&5
-$as_echo_n "checking whether to build parser debugging code... " >&6; }
-# Check whether --enable-yydebug was given.
-if test "${enable_yydebug+set}" = set; then :
-  enableval=$enable_yydebug;
-fi
-
-if test "$enable_yydebug" = "yes"; then
-
-$as_echo "#define YYDEBUG 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: ${enable_yydebug-no}" >&5
-$as_echo "${enable_yydebug-no}" >&6; }
-
-#
-# Look for {f}lex.
-#
-for ac_prog in flex lex
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_LEX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$LEX"; then
-  ac_cv_prog_LEX="$LEX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_LEX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-LEX=$ac_cv_prog_LEX
-if test -n "$LEX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LEX" >&5
-$as_echo "$LEX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$LEX" && break
-done
-test -n "$LEX" || LEX=":"
-
-if test "x$LEX" != "x:"; then
-  cat >conftest.l <<_ACEOF
-%%
-a { ECHO; }
-b { REJECT; }
-c { yymore (); }
-d { yyless (1); }
-e { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
-    yyless ((input () != 0)); }
-f { unput (yytext[0]); }
-. { BEGIN INITIAL; }
-%%
-#ifdef YYTEXT_POINTER
-extern char *yytext;
-#endif
-int
-main (void)
-{
-  return ! yylex () + ! yywrap ();
-}
-_ACEOF
-{ { ac_try="$LEX conftest.l"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$LEX conftest.l") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking lex output file root" >&5
-$as_echo_n "checking lex output file root... " >&6; }
-if ${ac_cv_prog_lex_root+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-if test -f lex.yy.c; then
-  ac_cv_prog_lex_root=lex.yy
-elif test -f lexyy.c; then
-  ac_cv_prog_lex_root=lexyy
-else
-  as_fn_error $? "cannot find output from $LEX; giving up" "$LINENO" 5
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_lex_root" >&5
-$as_echo "$ac_cv_prog_lex_root" >&6; }
-LEX_OUTPUT_ROOT=$ac_cv_prog_lex_root
-
-if test -z "${LEXLIB+set}"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking lex library" >&5
-$as_echo_n "checking lex library... " >&6; }
-if ${ac_cv_lib_lex+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-    ac_save_LIBS=$LIBS
-    ac_cv_lib_lex='none needed'
-    for ac_lib in '' -lfl -ll; do
-      LIBS="$ac_lib $ac_save_LIBS"
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-`cat $LEX_OUTPUT_ROOT.c`
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_lex=$ac_lib
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-      test "$ac_cv_lib_lex" != 'none needed' && break
-    done
-    LIBS=$ac_save_LIBS
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lex" >&5
-$as_echo "$ac_cv_lib_lex" >&6; }
-  test "$ac_cv_lib_lex" != 'none needed' && LEXLIB=$ac_cv_lib_lex
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether yytext is a pointer" >&5
-$as_echo_n "checking whether yytext is a pointer... " >&6; }
-if ${ac_cv_prog_lex_yytext_pointer+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  # POSIX says lex can declare yytext either as a pointer or an array; the
-# default is implementation-dependent.  Figure out which it is, since
-# not all implementations provide the %pointer and %array declarations.
-ac_cv_prog_lex_yytext_pointer=no
-ac_save_LIBS=$LIBS
-LIBS="$LEXLIB $ac_save_LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-  #define YYTEXT_POINTER 1
-`cat $LEX_OUTPUT_ROOT.c`
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_prog_lex_yytext_pointer=yes
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_save_LIBS
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_lex_yytext_pointer" >&5
-$as_echo "$ac_cv_prog_lex_yytext_pointer" >&6; }
-if test $ac_cv_prog_lex_yytext_pointer = yes; then
-
-$as_echo "#define YYTEXT_POINTER 1" >>confdefs.h
-
-fi
-rm -f conftest.l $LEX_OUTPUT_ROOT.c
-
-fi
-if test "$LEX" = ":"; then
-	as_fn_error $? "Neither flex nor lex was found." "$LINENO" 5
-fi
-
-#
-# Make sure {f}lex supports the -P, --header-file, and --nounput flags
-# and supports processing our scanner.l.
-#
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for capable lex" >&5
-$as_echo_n "checking for capable lex... " >&6; }
-if ${tcpdump_cv_capable_lex+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if $LEX -P pcap_ --header-file=/dev/null --nounput -t $srcdir/scanner.l > /dev/null 2>&1; then
-	    tcpdump_cv_capable_lex=yes
-	else
-	    tcpdump_cv_capable_lex=insufficient
-	fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $tcpdump_cv_capable_lex" >&5
-$as_echo "$tcpdump_cv_capable_lex" >&6; }
-if test $tcpdump_cv_capable_lex = insufficient ; then
-	as_fn_error $? "$LEX is insufficient to compile libpcap.
- libpcap requires Flex 2.5.31 or later, or a compatible version of lex.
- If a suitable version of Lex/Flex is available as a non-standard command
- and/or not in the PATH, you can specify it using the LEX environment
- variable. That said, on some systems the error can mean that Flex/Lex is
- actually acceptable, but m4 is not. Likewise, if a suitable version of
- m4 (such as GNU M4) is available but has not been detected, you can
- specify it using the M4 environment variable." "$LINENO" 5
-fi
-
-#
-# Look for yacc/bison/byacc.
-# If it's Bison, we do not want -y, as 1) we will be using -o to cause
-# the output for XXX.y to be written to XXX.c and 2) we don't want
-# it to issue warnings about stuff not supported by POSIX YACC - we
-# want to use that stuff, and don't care whether plain YACC supports
-# it or not, we require either Bison or Berkeley YACC.
-#
-BISON_BYACC=""
-#
-# Look for Bison.
-#
-for ac_prog in bison
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_BISON_BYACC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$BISON_BYACC"; then
-  ac_cv_prog_BISON_BYACC="$BISON_BYACC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_BISON_BYACC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-BISON_BYACC=$ac_cv_prog_BISON_BYACC
-if test -n "$BISON_BYACC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON_BYACC" >&5
-$as_echo "$BISON_BYACC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$BISON_BYACC" && break
-done
-
-if test x"$BISON_BYACC" != x; then
-	#
-	# We found Bison.
-	#
-	# Bison prior to 2.4(.1) doesn't support "%define api.pure", so use
-	# "%pure-parser".
-	#
-	bison_major_version=`$BISON_BYACC -V | sed -n 's/.* \([1-9][0-9]*\)\.[0-9][0-9.]*/\1/p'`
-	bison_minor_version=`$BISON_BYACC -V | sed -n 's/.* [1-9][0-9]*\.\([0-9]+\).*/\1/p'`
-	if test "$bison_major_version" -lt 2 -o \
-	    \( "$bison_major_version" -eq 2 -a "$bison_major_version" -lt 4 \)
-	then
-		REENTRANT_PARSER="%pure-parser"
-	else
-		REENTRANT_PARSER="%define api.pure"
-	fi
-else
-	#
-	# We didn't find Bison; check for Berkeley YACC, under the
-	# names byacc and yacc.
-	#
-	for ac_prog in byacc yacc
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_BISON_BYACC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$BISON_BYACC"; then
-  ac_cv_prog_BISON_BYACC="$BISON_BYACC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_BISON_BYACC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-BISON_BYACC=$ac_cv_prog_BISON_BYACC
-if test -n "$BISON_BYACC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON_BYACC" >&5
-$as_echo "$BISON_BYACC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$BISON_BYACC" && break
-done
-
-	if test x"$BISON_BYACC" != x; then
-		#
-		# Make sure this is Berkeley YACC, not AT&T YACC;
-		# the latter doesn't support reentrant parsers.
-		# Run it with "-V"; that succeeds and reports the
-		# version number with Berkeley YACC, but will
-		# (probably) fail with various vendor flavors
-		# of AT&T YACC.
-		#
-		# Hopefully this also eliminates any versions
-		# of Berkeley YACC that don't support reentrant
-		# parsers, if there are any.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for capable yacc" >&5
-$as_echo_n "checking for capable yacc... " >&6; }
-if ${tcpdump_cv_capable_yacc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if $BISON_BYACC -V >/dev/null 2>&1; then
-			tcpdump_cv_capable_yacc=yes
-		    else
-			tcpdump_cv_capable_yacc=insufficient
-		    fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $tcpdump_cv_capable_yacc" >&5
-$as_echo "$tcpdump_cv_capable_yacc" >&6; }
-		if test $tcpdump_cv_capable_yacc = insufficient ; then
-		    as_fn_error $? "$BISON_BYACC is insufficient to compile libpcap.
- libpcap requires Bison, a newer version of Berkeley YACC with support
- for reentrant parsers, or another YACC compatible with them." "$LINENO" 5
-		fi
-	else
-		#
-		# OK, we found neither byacc nor yacc.
-		#
-		as_fn_error $? "Neither bison, byacc, nor yacc was found.
- libpcap requires Bison, a newer version of Berkeley YACC with support
- for reentrant parsers, or another YACC compatible with them." "$LINENO" 5
-	fi
-
-	#
-	# Berkeley YACC doesn't support "%define api.pure", so use
-	# "%pure-parser".
-	#
-	REENTRANT_PARSER="%pure-parser"
-fi
-
-
-
-#
-# Do various checks for various OSes and versions of those OSes.
-#
-# Assume, by default, no support for shared libraries and V7/BSD
-# convention for man pages (devices in section 4, file formats in
-# section 5, miscellaneous info in section 7, administrative commands
-# and daemons in section 8).  Individual cases can override this.
-#
-DYEXT="none"
-MAN_DEVICES=4
-MAN_FILE_FORMATS=5
-MAN_MISC_INFO=7
-MAN_ADMIN_COMMANDS=8
-case "$host_os" in
-
-aix*)
-
-$as_echo "#define _SUN 1" >>confdefs.h
-
-
-	#
-	# AIX makes it fun to build shared and static libraries,
-	# because they're *both* ".a" archive libraries.  We
-	# build the static library for the benefit of the traditional
-	# scheme of building libpcap and tcpdump in subdirectories of
-	# the same directory, with tcpdump statically linked with the
-	# libpcap in question, but we also build a shared library as
-	# "libpcap.shareda" and install *it*, rather than the static
-	# library, as "libpcap.a".
-	#
-	DYEXT="shareda"
-
-	case "$V_PCAP" in
-
-	dlpi)
-		#
-		# If we're using DLPI, applications will need to
-		# use /lib/pse.exp if present, as we use the
-		# STREAMS routines.
-		#
-		pseexe="/lib/pse.exp"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $pseexe" >&5
-$as_echo_n "checking for $pseexe... " >&6; }
-		if test -f $pseexe ; then
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			LIBS="-I:$pseexe"
-		fi
-		;;
-
-	bpf)
-		#
-		# If we're using BPF, we need "-lodm" and "-lcfg", as
-		# we use them to load the BPF module.
-		#
-		LIBS="-lodm -lcfg"
-		;;
-	esac
-	;;
-
-darwin*)
-	DYEXT="dylib"
-	V_CCOPT="$V_CCOPT -fno-common"
-	# Check whether --enable-universal was given.
-if test "${enable_universal+set}" = set; then :
-  enableval=$enable_universal;
-fi
-
-	if test "$enable_universal" != "no"; then
-		case "$host_os" in
-
-		darwin[0-7].*)
-			#
-			# Pre-Tiger.  Build only for 32-bit PowerPC; no
-			# need for any special compiler or linker flags.
-			#
-			;;
-
-		darwin8.[0123]|darwin8.[0123].*)
-			#
-			# Tiger, prior to Intel support.  Build
-			# libraries and executables for 32-bit PowerPC
-			# and 64-bit PowerPC, with 32-bit PowerPC first.
-			# (I'm guessing that's what Apple does.)
-			#
-			# (The double brackets are needed because
-			# autotools/m4 use brackets as a quoting
-			# character; the double brackets turn into
-			# single brackets in the generated configure
-			# file.)
-			#
-			V_LIB_CCOPT_FAT="-arch ppc -arch ppc64"
-			V_LIB_LDFLAGS_FAT="-arch ppc -arch ppc64"
-			V_PROG_CCOPT_FAT="-arch ppc -arch ppc64"
-			V_PROG_LDFLAGS_FAT="-arch ppc -arch ppc64"
-			;;
-
-		darwin8.[456]|darwin8.[456].*)
-			#
-			# Tiger, subsequent to Intel support but prior
-			# to x86-64 support.  Build libraries and
-			# executables for 32-bit PowerPC, 64-bit
-			# PowerPC, and 32-bit x86, with 32-bit PowerPC
-			# first.  (I'm guessing that's what Apple does.)
-			#
-			# (The double brackets are needed because
-			# autotools/m4 use brackets as a quoting
-			# character; the double brackets turn into
-			# single brackets in the generated configure
-			# file.)
-			#
-			V_LIB_CCOPT_FAT="-arch ppc -arch ppc64 -arch i386"
-			V_LIB_LDFLAGS_FAT="-arch ppc -arch ppc64 -arch i386"
-			V_PROG_CCOPT_FAT="-arch ppc -arch ppc64 -arch i386"
-			V_PROG_LDFLAGS_FAT="-arch ppc -arch ppc64 -arch i386"
-			;;
-
-		darwin8.*)
-			#
-			# All other Tiger, so subsequent to x86-64
-			# support.  Build libraries and executables for
-			# 32-bit PowerPC, 64-bit PowerPC, 32-bit x86,
-			# and x86-64, with 32-bit PowerPC first.  (I'm
-			# guessing that's what Apple does.)
-			#
-			V_LIB_CCOPT_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			V_LIB_LDFLAGS_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			V_PROG_CCOPT_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			V_PROG_LDFLAGS_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			;;
-
-		darwin9.*)
-			#
-			# Leopard.  Build libraries for 32-bit PowerPC,
-			# 64-bit PowerPC, 32-bit x86, and x86-64, with
-			# 32-bit PowerPC first, and build executables
-			# for 32-bit x86 and 32-bit PowerPC, with 32-bit
-			# x86 first.  (That's what Apple does.)
-			#
-			V_LIB_CCOPT_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			V_LIB_LDFLAGS_FAT="-arch ppc -arch ppc64 -arch i386 -arch x86_64"
-			V_PROG_CCOPT_FAT="-arch i386 -arch ppc"
-			V_PROG_LDFLAGS_FAT="-arch i386 -arch ppc"
-			;;
-
-		darwin10.*)
-			#
-			# Snow Leopard.  Build libraries for x86-64,
-			# 32-bit x86, and 32-bit PowerPC, with x86-64
-			# first, and build executables for x86-64 and
-			# 32-bit x86, with x86-64 first.  (That's what
-			# Apple does, even though Snow Leopard doesn't
-			# run on PPC, so PPC libpcap runs under Rosetta,
-			# and Rosetta doesn't support BPF ioctls, so PPC
-			# programs can't do live captures.)
-			#
-			V_LIB_CCOPT_FAT="-arch x86_64 -arch i386 -arch ppc"
-			V_LIB_LDFLAGS_FAT="-arch x86_64 -arch i386 -arch ppc"
-			V_PROG_CCOPT_FAT="-arch x86_64 -arch i386"
-			V_PROG_LDFLAGS_FAT="-arch x86_64 -arch i386"
-			;;
-
-		darwin1[1-8]*)
-			#
-			# Post-Snow Leopard, pre-Catalina.  Build
-			# libraries for x86-64 and 32-bit x86, with
-			# x86-64 first, and build executables only for
-			# x86-64.  (That's what Apple does.)  This
-			# requires no special flags for programs.
-			#
-			# We check whether we *can* build for i386 and,
-			# if not, suggest that the user install the
-			# /usr/include headers if they want to build
-			# fat.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether building for 32-bit x86 is supported" >&5
-$as_echo_n "checking whether building for 32-bit x86 is supported... " >&6; }
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-			CFLAGS="$CFLAGS -arch i386"
-			cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-				V_LIB_CCOPT_FAT="-arch x86_64"
-				V_LIB_LDFLAGS_FAT="-arch x86_64"
-
-				#
-				# OpenSSL installation on macOS seems
-				# to install only the libs for 64-bit
-				# x86 - at least that's what Brew does:
-				# only configure 32-bit builds if we
-				# don't have OpenSSL.
-				#
-				if test "$HAVE_OPENSSL" != yes; then
-					V_LIB_CCOPT_FAT="$V_LIB_CCOPT_FAT -arch i386"
-					V_LIB_LDFLAGS_FAT="$V_LIB_LDFLAGS_FAT -arch i386"
-				fi
-
-else
-
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-				V_LIB_CCOPT_FAT="-arch x86_64"
-				V_LIB_LDFLAGS_FAT="-arch x86_64"
-				case "$host_os" in
-
-				darwin18.*)
-					#
-					# Mojave; you need to install the
-					# /usr/include headers to get
-					# 32-bit x86 builds to work.
-					#
-					{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package" >&5
-$as_echo "$as_me: WARNING: Compiling for 32-bit x86 gives an error; try installing the command-line tools and, after that, installing the /usr/include headers from the /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg package" >&2;}
-					;;
-
-				*)
-					#
-					# Pre-Mojave; the command-line
-					# tools should be sufficient to
-					# enable 32-bit x86 builds.
-					#
-					{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Compiling for 32-bit x86 gives an error; try installing the command-line tools" >&5
-$as_echo "$as_me: WARNING: Compiling for 32-bit x86 gives an error; try installing the command-line tools" >&2;}
-					;;
-				esac
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-			;;
-
-		darwin19*)
-			#
-			# Catalina.  Build libraries and executables
-			# only for x86-64.  (That's what Apple does;
-			# 32-bit x86 binaries are not supported on
-			# Catalina.)
-			#
-			V_LIB_CCOPT_FAT="-arch x86_64"
-			V_LIB_LDFLAGS_FAT="-arch x86_64"
-			V_PROG_CCOPT_FAT="-arch x86_64"
-			V_PROG_LDFLAGS_FAT="-arch x86_64"
-			;;
-
-		darwin*)
-			#
-			# Post-Catalina.  Build libraries and
-			# executables for x86-64 and ARM64.
-			# (That's what Apple does, except they
-			# build for arm64e, which may include
-			# some of the pointer-checking extensions.)
-			#
-			# If we're building with libssl, make sure
-			# we can build fat with it (i.e., that it
-			# was built fat); if we can't, don't set
-			# the target architectures, and just
-			# build for the host we're on.
-			#
-			# Otherwise, just add both of them.
-			#
-			if test "$HAVE_OPENSSL" = yes; then
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether building fat with libssl is supported" >&5
-$as_echo_n "checking whether building fat with libssl is supported... " >&6; }
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-				CFLAGS="$CFLAGS -arch x86_64 -arch arm64"
-				LDFLAGS="$LDFLAGS $OPENSSL_LIBS"
-				cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-					#include <openssl/ssl.h>
-
-int
-main ()
-{
-
-					SSL_library_init();
-					return 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-					{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-					V_LIB_CCOPT_FAT="-arch x86_64 -arch arm64"
-					V_LIB_LDFLAGS_FAT="-arch x86_64 -arch arm64"
-					V_PROG_CCOPT_FAT="-arch x86_64 -arch arm64"
-					V_PROG_LDFLAGS_FAT="-arch x86_64 -arch arm64"
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-			else
-				V_LIB_CCOPT_FAT="-arch x86_64 -arch arm64"
-				V_LIB_LDFLAGS_FAT="-arch x86_64 -arch arm64"
-				V_PROG_CCOPT_FAT="-arch x86_64 -arch arm64"
-				V_PROG_LDFLAGS_FAT="-arch x86_64 -arch arm64"
-			fi
-			;;
-		esac
-	fi
-	;;
-
-hpux9*)
-
-$as_echo "#define HAVE_HPUX9 1" >>confdefs.h
-
-
-	#
-	# Use System V conventions for man pages.
-	#
-	MAN_ADMIN_COMMANDS=1m
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	;;
-
-hpux10.0*)
-
-	#
-	# Use System V conventions for man pages.
-	#
-	MAN_ADMIN_COMMANDS=1m
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	;;
-
-hpux10.1*)
-
-	#
-	# Use System V conventions for man pages.
-	#
-	MAN_ADMIN_COMMANDS=1m
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	;;
-
-hpux*)
-
-$as_echo "#define HAVE_HPUX10_20_OR_LATER 1" >>confdefs.h
-
-	if test "`uname -m`" = "ia64"; then
-		DYEXT="so"
-	else
-		DYEXT="sl"
-	fi
-
-	#
-	# "-b" builds a shared library; "+h" sets the soname.
-	#
-	SHLIB_OPT="-b"
-	SONAME_OPT="+h"
-
-	#
-	# Use System V conventions for man pages.
-	#
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	;;
-
-irix*)
-	#
-	# Use IRIX conventions for man pages; they're the same as the
-	# System V conventions, except that they use section 8 for
-	# administrative commands and daemons.
-	#
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	;;
-
-linux*|freebsd*|netbsd*|openbsd*|dragonfly*|kfreebsd*|gnu*|haiku*|midipix*)
-	DYEXT="so"
-	;;
-
-osf*)
-	DYEXT="so"
-
-	#
-	# DEC OSF/1, a/k/a Digital UNIX, a/k/a Tru64 UNIX.
-	# Use Tru64 UNIX conventions for man pages; they're the same as
-	# the System V conventions except that they use section 8 for
-	# administrative commands and daemons.
-	#
-	MAN_FILE_FORMATS=4
-	MAN_MISC_INFO=5
-	MAN_DEVICES=7
-	;;
-
-sinix*)
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if SINIX compiler defines sinix" >&5
-$as_echo_n "checking if SINIX compiler defines sinix... " >&6; }
-	if ${ac_cv_cc_sinix_defined+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-int i = sinix;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_cc_sinix_defined=yes
-else
-  ac_cv_cc_sinix_defined=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cc_sinix_defined" >&5
-$as_echo "$ac_cv_cc_sinix_defined" >&6; }
-	    if test $ac_cv_cc_sinix_defined = no ; then
-
-$as_echo "#define sinix 1" >>confdefs.h
-
-	    fi
-	;;
-
-solaris*)
-
-$as_echo "#define HAVE_SOLARIS 1" >>confdefs.h
-
-
-	DYEXT="so"
-
-	#
-	# Make sure errno is thread-safe, in case we're called in
-	# a multithreaded program.  We don't guarantee that two
-	# threads can use the *same* pcap_t safely, but the
-	# current version does guarantee that you can use different
-	# pcap_t's in different threads, and even that pcap_compile()
-	# is thread-safe (it wasn't thread-safe in some older versions).
-	#
-	V_CCOPT="$V_CCOPT -D_TS_ERRNO"
-
-	case "`uname -r`" in
-
-	5.12)
-		;;
-
-	*)
-		#
-		# Use System V conventions for man pages.
-		#
-		MAN_ADMIN_COMMANDS=1m
-		MAN_FILE_FORMATS=4
-		MAN_MISC_INFO=5
-		MAN_DEVICES=7D
-	esac
-	;;
-esac
-
-
-
-
-
-
-
-
-
-
-# Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared;
-fi
-
-test "x$enable_shared" = "xno" && DYEXT="none"
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_AR="ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_AR" = x; then
-    AR=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
-else
-  AR="$ac_cv_prog_AR"
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
-LN_S=$as_ln_s
-if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
-fi
-
-
-
-rm -f os-proto.h
-    if test "${LBL_CFLAGS+set}" = set; then
-	    V_CCOPT="$V_CCOPT ${LBL_CFLAGS}"
-    fi
-    if test -f .devel ; then
-	    #
-	    # Skip all the warning option stuff on some compilers.
-	    #
-	    if test "$ac_lbl_cc_dont_try_gcc_dashW" != yes; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -W option" >&5
-$as_echo_n "checking whether the compiler supports the -W option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -W"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -W " >&5
-$as_echo_n "checking whether -W ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -W"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wall option" >&5
-$as_echo_n "checking whether the compiler supports the -Wall option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wall"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wall " >&5
-$as_echo_n "checking whether -Wall ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wall"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wcomma option" >&5
-$as_echo_n "checking whether the compiler supports the -Wcomma option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wcomma"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wcomma " >&5
-$as_echo_n "checking whether -Wcomma ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wcomma"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wdocumentation option" >&5
-$as_echo_n "checking whether the compiler supports the -Wdocumentation option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wdocumentation"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wdocumentation " >&5
-$as_echo_n "checking whether -Wdocumentation ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wdocumentation"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wformat-nonliteral option" >&5
-$as_echo_n "checking whether the compiler supports the -Wformat-nonliteral option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wformat-nonliteral"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wformat-nonliteral " >&5
-$as_echo_n "checking whether -Wformat-nonliteral ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wformat-nonliteral"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wmissing-noreturn option" >&5
-$as_echo_n "checking whether the compiler supports the -Wmissing-noreturn option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wmissing-noreturn"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wmissing-noreturn " >&5
-$as_echo_n "checking whether -Wmissing-noreturn ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wmissing-noreturn"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wmissing-prototypes option" >&5
-$as_echo_n "checking whether the compiler supports the -Wmissing-prototypes option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wmissing-prototypes"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wmissing-prototypes " >&5
-$as_echo_n "checking whether -Wmissing-prototypes ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wmissing-prototypes"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wmissing-variable-declarations option" >&5
-$as_echo_n "checking whether the compiler supports the -Wmissing-variable-declarations option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wmissing-variable-declarations"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wmissing-variable-declarations " >&5
-$as_echo_n "checking whether -Wmissing-variable-declarations ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wmissing-variable-declarations"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wpointer-arith option" >&5
-$as_echo_n "checking whether the compiler supports the -Wpointer-arith option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wpointer-arith"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wpointer-arith " >&5
-$as_echo_n "checking whether -Wpointer-arith ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wpointer-arith"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wpointer-sign option" >&5
-$as_echo_n "checking whether the compiler supports the -Wpointer-sign option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wpointer-sign"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wpointer-sign " >&5
-$as_echo_n "checking whether -Wpointer-sign ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wpointer-sign"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wshadow option" >&5
-$as_echo_n "checking whether the compiler supports the -Wshadow option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wshadow"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wshadow " >&5
-$as_echo_n "checking whether -Wshadow ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wshadow"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wsign-compare option" >&5
-$as_echo_n "checking whether the compiler supports the -Wsign-compare option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wsign-compare"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wsign-compare " >&5
-$as_echo_n "checking whether -Wsign-compare ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wsign-compare"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wstrict-prototypes option" >&5
-$as_echo_n "checking whether the compiler supports the -Wstrict-prototypes option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wstrict-prototypes"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wstrict-prototypes " >&5
-$as_echo_n "checking whether -Wstrict-prototypes ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wstrict-prototypes"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wunused-parameter option" >&5
-$as_echo_n "checking whether the compiler supports the -Wunused-parameter option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wunused-parameter"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wunused-parameter " >&5
-$as_echo_n "checking whether -Wunused-parameter ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wunused-parameter"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wused-but-marked-unused option" >&5
-$as_echo_n "checking whether the compiler supports the -Wused-but-marked-unused option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wused-but-marked-unused"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wused-but-marked-unused " >&5
-$as_echo_n "checking whether -Wused-but-marked-unused ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wused-but-marked-unused"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-		    # Warns about safeguards added in case the enums are
-		    # extended
-		    # AC_LBL_CHECK_COMPILER_OPT(V_CCOPT, -Wcovered-switch-default)
-		    #
-		    # This can cause problems with ntohs(), ntohl(),
-		    # htons(), and htonl() on some platforms, such
-		    # as OpenBSD 6.3 with Clang 5.0.1.  I guess the
-		    # problem is that the macro that ultimately does
-		    # the byte-swapping involves a conditional
-		    # expression that tests whether the value being
-		    # swapped is a compile-time constant or not,
-		    # using __builtin_constant_p(), and, depending
-		    # on whether it is, does a compile-time swap or
-		    # a run-time swap; perhaps the compiler always
-		    # considers one of the two results of the
-		    # conditional expressin is never evaluated,
-		    # because the conditional check is done at
-		    # compile time, and thus always says "that
-		    # expression is never executed".
-		    #
-		    # (Perhaps there should be a way of flagging
-		    # an expression that you *want* evaluated at
-		    # compile time, so that the compiler 1) warns
-		    # if it *can't* be evaluated at compile time
-		    # and 2) *doesn't* warn that the true or false
-		    # branch will never be reached.)
-		    #
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wunreachable-code option" >&5
-$as_echo_n "checking whether the compiler supports the -Wunreachable-code option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wunreachable-code"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "xgenerates warnings from ntohs()" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wunreachable-code generates warnings from ntohs()" >&5
-$as_echo_n "checking whether -Wunreachable-code generates warnings from ntohs()... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <arpa/inet.h>
-
-unsigned short
-testme(unsigned short a)
-{
-	return ntohs(a);
-}
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wunreachable-code"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports the -Wshorten-64-to-32 option" >&5
-$as_echo_n "checking whether the compiler supports the -Wshorten-64-to-32 option... " >&6; }
-	save_CFLAGS="$CFLAGS"
-	CFLAGS="$CFLAGS -Wshorten-64-to-32"
-	#
-	# XXX - yes, this depends on the way AC_LANG_WERROR works,
-	# but no mechanism is provided to turn AC_LANG_WERROR on
-	# *and then turn it back off*, so that we *only* do it when
-	# testing compiler options - 15 years after somebody asked
-	# for it:
-	#
-	#     https://autoconf.gnu.narkive.com/gTAVmfKD/how-to-cancel-flags-set-by-ac-lang-werror
-	#
-	save_ac_c_werror_flag="$ac_c_werror_flag"
-	ac_c_werror_flag=yes
-	#
-	# We use AC_LANG_SOURCE() so that we can control the complete
-	# content of the program being compiled.  We do not, for example,
-	# want the default "int main()" that AC_LANG_PROGRAM() generates,
-	# as it will generate a warning with -Wold-style-definition, meaning
-	# that we would treat it as not working, as the test will fail if
-	# *any* error output, including a warning due to the flag we're
-	# testing, is generated; see
-	#
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#    https://www.postgresql.org/message-id/2192993.1591682589%40sss.pgh.pa.us
-	#
-	# This may, as per those two messages, be fixed in autoconf 2.70,
-	# but we only require 2.64 or newer for now.
-	#
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		can_add_to_cflags=yes
-		#
-		# The compile supports this; do we have some C code for
-		# which the warning should *not* appear?
-		# We test the fourth argument because the third argument
-		# could contain quotes, breaking the test.
-		#
-		if test "x" != "x"
-		then
-		    CFLAGS="$CFLAGS $ac_lbl_cc_force_warning_errors"
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -Wshorten-64-to-32 " >&5
-$as_echo_n "checking whether -Wshorten-64-to-32 ... " >&6; }
-		    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-			#
-			# Not a problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-else
-
-			#
-			# A problem.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-			can_add_to_cflags=no
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-		fi
-		CFLAGS="$save_CFLAGS"
-		if test x"$can_add_to_cflags" = "xyes"
-		then
-		    V_CCOPT="$V_CCOPT -Wshorten-64-to-32"
-		fi
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		CFLAGS="$save_CFLAGS"
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	ac_c_werror_flag="$save_ac_c_werror_flag"
-
-	    fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports generating dependencies" >&5
-$as_echo_n "checking whether the compiler supports generating dependencies... " >&6; }
-	if test "$GCC" = yes ; then
-		#
-		# GCC, or a compiler deemed to be GCC by AC_PROG_CC (even
-		# though it's not); we assume that, in this case, the flag
-		# would be -M.
-		#
-		ac_lbl_dependency_flag="-M"
-	else
-		#
-		# Not GCC or a compiler deemed to be GCC; what platform is
-		# this?  (We're assuming that if the compiler isn't GCC
-		# it's the compiler from the vendor of the OS; that won't
-		# necessarily be true for x86 platforms, where it might be
-		# the Intel C compiler.)
-		#
-		case "$host_os" in
-
-		irix*|osf*|darwin*)
-			#
-			# MIPS C for IRIX, DEC C, and clang all use -M.
-			#
-			ac_lbl_dependency_flag="-M"
-			;;
-
-		solaris*)
-			#
-			# Sun C uses -xM.
-			#
-			ac_lbl_dependency_flag="-xM"
-			;;
-
-		hpux*)
-			#
-			# HP's older C compilers don't support this.
-			# HP's newer C compilers support this with
-			# either +M or +Make; the older compilers
-			# interpret +M as something completely
-			# different, so we use +Make so we don't
-			# think it works with the older compilers.
-			#
-			ac_lbl_dependency_flag="+Make"
-			;;
-
-		*)
-			#
-			# Not one of the above; assume no support for
-			# generating dependencies.
-			#
-			ac_lbl_dependency_flag=""
-			;;
-		esac
-	fi
-
-	#
-	# Is ac_lbl_dependency_flag defined and, if so, does the compiler
-	# complain about it?
-	#
-	# Note: clang doesn't seem to exit with an error status when handed
-	# an unknown non-warning error, even if you pass it
-	# -Werror=unknown-warning-option.  However, it always supports
-	# -M, so the fact that this test always succeeds with clang
-	# isn't an issue.
-	#
-	if test ! -z "$ac_lbl_dependency_flag"; then
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int main(void) { return 0; }
-_ACEOF
-		if { { $as_echo "$as_me:${as_lineno-$LINENO}: eval \"\$CC \$ac_lbl_dependency_flag conftest.c >/dev/null 2>&1\""; } >&5
-  (eval "$CC $ac_lbl_dependency_flag conftest.c >/dev/null 2>&1") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, with $ac_lbl_dependency_flag" >&5
-$as_echo "yes, with $ac_lbl_dependency_flag" >&6; }
-			DEPENDENCY_CFLAG="$ac_lbl_dependency_flag"
-			MKDEP='${top_srcdir}/mkdep'
-		else
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-			#
-			# We can't run mkdep, so have "make depend" do
-			# nothing.
-			#
-			MKDEP='${top_srcdir}/nomkdep'
-		fi
-		rm -rf conftest*
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-		#
-		# We can't run mkdep, so have "make depend" do
-		# nothing.
-		#
-		MKDEP='${top_srcdir}/nomkdep'
-	fi
-
-
-
-	    #
-	    # We used to set -n32 for IRIX 6 when not using GCC (presumed
-	    # to mean that we're using MIPS C or MIPSpro C); it specified
-	    # the "new" faster 32-bit ABI, introduced in IRIX 6.2.  I'm
-	    # not sure why that would be something to do *only* with a
-	    # .devel file; why should the ABI for which we produce code
-	    # depend on .devel?
-	    #
-	    os=`echo $host_os | sed -e 's/\([0-9][0-9]*\)[^0-9].*$/\1/'`
-	    name="lbl/os-$os.h"
-	    if test -f $name ; then
-		    ln -s $name os-proto.h
-
-$as_echo "#define HAVE_OS_PROTO_H 1" >>confdefs.h
-
-	    else
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: can't find $name" >&5
-$as_echo "$as_me: WARNING: can't find $name" >&2;}
-	    fi
-    fi
-
-#
-# Check to see if the sockaddr struct has the 4.4 BSD sa_len member.
-#
-ac_fn_c_check_member "$LINENO" "struct sockaddr" "sa_len" "ac_cv_member_struct_sockaddr_sa_len" "
-	#include <sys/types.h>
-	#include <sys/socket.h>
-
-"
-if test "x$ac_cv_member_struct_sockaddr_sa_len" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SOCKADDR_SA_LEN 1
-_ACEOF
-
-
-fi
-
-
-#
-# Check to see if there's a sockaddr_storage structure.
-#
-ac_fn_c_check_type "$LINENO" "struct sockaddr_storage" "ac_cv_type_struct_sockaddr_storage" "
-	#include <sys/types.h>
-	#include <sys/socket.h>
-
-"
-if test "x$ac_cv_type_struct_sockaddr_storage" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SOCKADDR_STORAGE 1
-_ACEOF
-
-
-fi
-
-
-#
-# Check to see if the dl_hp_ppa_info_t struct has the HP-UX 11.00
-# dl_module_id_1 member.
-#
-# NOTE: any failure means we conclude that it doesn't have that member,
-# so if we don't have DLPI, don't have a <sys/dlpi_ext.h> header, or
-# have one that doesn't declare a dl_hp_ppa_info_t type, we conclude
-# it doesn't have that member (which is OK, as either we won't be
-# using code that would use that member, or we wouldn't compile in
-# any case).
-#
-ac_fn_c_check_member "$LINENO" "dl_hp_ppa_info_t" "dl_module_id_1" "ac_cv_member_dl_hp_ppa_info_t_dl_module_id_1" "
-	#include <sys/types.h>
-	#include <sys/dlpi.h>
-	#include <sys/dlpi_ext.h>
-
-"
-if test "x$ac_cv_member_dl_hp_ppa_info_t_dl_module_id_1" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1 1
-_ACEOF
-
-
-fi
-
-
-#
-# Various Linux-specific mechanisms.
-#
-# Check whether --enable-usb was given.
-if test "${enable_usb+set}" = set; then :
-  enableval=$enable_usb;
-else
-  enable_usb=yes
-fi
-
-
-#
-# If somebody requested an XXX-only pcap, that doesn't include
-# additional mechanisms.
-#
-if test "xxx_only" != yes; then
-  case "$host_os" in
-  linux*)
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Linux usbmon USB sniffing support" >&5
-$as_echo_n "checking for Linux usbmon USB sniffing support... " >&6; }
-    if test "x$enable_usb" != "xno" ; then
-
-$as_echo "#define PCAP_SUPPORT_LINUX_USBMON 1" >>confdefs.h
-
-      MODULE_C_SRC="$MODULE_C_SRC pcap-usb-linux.c"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-      #
-      # Note: if the directory for special files is *EVER* somewhere
-      # other than the UN*X standard of /dev (which will break any
-      # software that looks for /dev/null or /dev/tty, for example,
-      # so doing that is *REALLY* not a good idea), please provide
-      # some mechanism to determine that directory at *run time*,
-      # rather than *configure time*, so that it works when doinga
-      # a cross-build, and that works with *multiple* distributions,
-      # with our without udev, and with multiple versions of udev,
-      # with udevinfo or udevadm or any other mechanism to get the
-      # special files directory.
-      #
-      # Do we have a version of <linux/compiler.h> available?
-      # If so, we might need it for <linux/usbdevice_fs.h>.
-      #
-      for ac_header in linux/compiler.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "linux/compiler.h" "ac_cv_header_linux_compiler_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_compiler_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_COMPILER_H 1
-_ACEOF
-
-fi
-
-done
-
-      if test "$ac_cv_header_linux_compiler_h" = yes; then
-        #
-        # Yes - include it when testing for <linux/usbdevice_fs.h>.
-        #
-        for ac_header in linux/usbdevice_fs.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "linux/usbdevice_fs.h" "ac_cv_header_linux_usbdevice_fs_h" "#include <linux/compiler.h>
-"
-if test "x$ac_cv_header_linux_usbdevice_fs_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_USBDEVICE_FS_H 1
-_ACEOF
-
-fi
-
-done
-
-      else
-        for ac_header in linux/usbdevice_fs.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "linux/usbdevice_fs.h" "ac_cv_header_linux_usbdevice_fs_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_usbdevice_fs_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_USBDEVICE_FS_H 1
-_ACEOF
-
-fi
-
-done
-
-      fi
-      if test "$ac_cv_header_linux_usbdevice_fs_h" = yes; then
-        #
-        # OK, does it define bRequestType?  Older versions of the kernel
-        # define fields with names like "requesttype, "request", and
-        # "value", rather than "bRequestType", "bRequest", and
-        # "wValue".
-        #
-        ac_fn_c_check_member "$LINENO" "struct usbdevfs_ctrltransfer" "bRequestType" "ac_cv_member_struct_usbdevfs_ctrltransfer_bRequestType" "
-            $ac_includes_default
-            #ifdef HAVE_LINUX_COMPILER_H
-            #include <linux/compiler.h>
-            #endif
-            #include <linux/usbdevice_fs.h>
-
-"
-if test "x$ac_cv_member_struct_usbdevfs_ctrltransfer_bRequestType" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE 1
-_ACEOF
-
-
-fi
-
-      fi
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-
-    #
-    # Life's too short to deal with trying to get this to compile
-    # if you don't get the right types defined with
-    # __KERNEL_STRICT_NAMES getting defined by some other include.
-    #
-    # Check whether the includes Just Work.  If not, don't turn on
-    # netfilter support.
-    #
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can compile the netfilter support" >&5
-$as_echo_n "checking whether we can compile the netfilter support... " >&6; }
-    if ${ac_cv_netfilter_can_compile+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-$ac_includes_default
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <linux/types.h>
-
-#include <linux/netlink.h>
-#include <linux/netfilter.h>
-#include <linux/netfilter/nfnetlink.h>
-#include <linux/netfilter/nfnetlink_log.h>
-#include <linux/netfilter/nfnetlink_queue.h>
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_netfilter_can_compile=yes
-else
-  ac_cv_netfilter_can_compile=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_netfilter_can_compile" >&5
-$as_echo "$ac_cv_netfilter_can_compile" >&6; }
-    if test $ac_cv_netfilter_can_compile = yes ; then
-
-$as_echo "#define PCAP_SUPPORT_NETFILTER 1" >>confdefs.h
-
-      MODULE_C_SRC="$MODULE_C_SRC pcap-netfilter-linux.c"
-    fi
-    ;;
-  esac
-fi
-
-
-
-# Check whether --enable-netmap was given.
-if test "${enable_netmap+set}" = set; then :
-  enableval=$enable_netmap;
-else
-  enable_netmap=yes
-fi
-
-
-if test "x$enable_netmap" != "xno" ; then
-	#
-	# Check whether net/netmap_user.h is usable if NETMAP_WITH_LIBS is
-	# defined; it's not usable on DragonFly BSD 4.6 if NETMAP_WITH_LIBS
-	# is defined, for example, as it includes a non-existent malloc.h
-	# header.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can compile the netmap support" >&5
-$as_echo_n "checking whether we can compile the netmap support... " >&6; }
-	if ${ac_cv_net_netmap_user_can_compile+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-$ac_includes_default
-#define NETMAP_WITH_LIBS
-#include <net/netmap_user.h>
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_net_netmap_user_can_compile=yes
-else
-  ac_cv_net_netmap_user_can_compile=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_net_netmap_user_can_compile" >&5
-$as_echo "$ac_cv_net_netmap_user_can_compile" >&6; }
-	if test $ac_cv_net_netmap_user_can_compile = yes ; then
-
-$as_echo "#define PCAP_SUPPORT_NETMAP 1" >>confdefs.h
-
-	    MODULE_C_SRC="$MODULE_C_SRC pcap-netmap.c"
-	fi
-
-fi
-
-# Check for DPDK support.
-
-# Check whether --with-dpdk was given.
-if test "${with_dpdk+set}" = set; then :
-  withval=$with_dpdk;
-	if test "$withval" = no
-	then
-		# User doesn't want DPDK support.
-		want_dpdk=no
-	elif test "$withval" = yes
-	then
-		# User wants DPDK support but hasn't specified a directory.
-		want_dpdk=yes
-	else
-		# User wants DPDK support and has specified a directory,
-		# so use the provided value.
-		want_dpdk=yes
-		dpdk_dir=$withval
-	fi
-
-else
-
-	if test "$V_PCAP" = dpdk; then
-		# User requested DPDK-only libpcap, so we'd better have
-		# the DPDK API.
-		want_dpdk=yes
-	elif test "xxx_only" = yes; then
-		# User requested something-else-only pcap, so they don't
-		# want DPDK support.
-		want_dpdk=no
-	else
-		#
-		# Use DPDK API if present, otherwise don't
-		#
-		want_dpdk=ifpresent
-	fi
-
-fi
-
-
-if test "$want_dpdk" != no; then
-	#
-	# The user didn't explicitly say they don't want DPDK,
-	# so see if we have it.
-	#
-	# We only try to find it using pkg-config; DPDK is *SO*
-	# complicated - DPDK 19.02, for example, has about 117(!)
-	# libraries, and the precise set of libraries required has
-	# changed over time - so attempting to guess which libraries
-	# you need, and hardcoding that in an attempt to find the
-	# libraries without DPDK, rather than relying on DPDK to
-	# tell you, with a .pc file, what libraries are needed,
-	# is *EXTREMELY* fragile and has caused some bug reports,
-	# so we're just not going to do it.
-	#
-	# If that causes a problem, the only thing we will do is
-	# accept an alternative way of finding the appropriate
-	# library set for the installed version of DPDK that is
-	# as robust as pkg-config (i.e., it had better work as well
-	# as pkg-config with *ALL* versions of DPDK that provide a
-	# libdpdk.pc file).
-	#
-	# If --with-dpdk={path} was specified, add {path}/pkgconfig
-	# to PKG_CONFIG_PATH, so we look for the .pc file there,
-	# first.
-	#
-	save_PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
-	if test -n "$dpdk_dir"; then
-		PKG_CONFIG_PATH="$dpdk_dir:$PKG_CONFIG_PATH"
-	fi
-
-
-pkg_failed=no
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for libdpdk with pkg-config" >&5
-$as_echo_n "checking for libdpdk with pkg-config... " >&6; }
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libdpdk\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libdpdk") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-
-	#
-	# The package was found, so try to get its C flags and
-	# libraries.
-	#
-	if test -n "$DPDK_CFLAGS"; then
-    pkg_cv_DPDK_CFLAGS="$DPDK_CFLAGS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libdpdk\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libdpdk") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DPDK_CFLAGS=`$PKG_CONFIG --cflags "libdpdk" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$DPDK_LIBS"; then
-    pkg_cv_DPDK_LIBS="$DPDK_LIBS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libdpdk\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libdpdk") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DPDK_LIBS=`$PKG_CONFIG --libs "libdpdk" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$DPDK_LIBS_STATIC"; then
-    pkg_cv_DPDK_LIBS_STATIC="$DPDK_LIBS_STATIC"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libdpdk\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libdpdk") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DPDK_LIBS_STATIC=`$PKG_CONFIG --libs --static "libdpdk" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-
-
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: error" >&5
-$as_echo "error" >&6; }
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-	        if test $_pkg_short_errors_supported = yes; then
-		        DPDK_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libdpdk" 2>&1`
-	        else
-		        DPDK_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libdpdk" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$DPDK_PKG_ERRORS" >&5
-
-		as_fn_error $? "Package requirements (libdpdk) were not met:
-
-$DPDK_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-
-Alternatively, you may set the environment variables DPDK_CFLAGS
-and DPDK_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details." "$LINENO" 5
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found (pkg-config not found)" >&5
-$as_echo "not found (pkg-config not found)" >&6; }
-	else
-		#
-		# We found the package.
-		#
-		DPDK_CFLAGS=$pkg_cv_DPDK_CFLAGS
-		DPDK_LIBS=$pkg_cv_DPDK_LIBS
-		DPDK_LIBS_STATIC=$pkg_cv_DPDK_LIBS_STATIC
-	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
-$as_echo "found" >&6; }
-
-		found_dpdk=yes
-
-	fi
-else
-
-	#
-	# The package isn't present.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-
-fi
-
-	PKG_CONFIG_PATH="$save_PKG_CONFIG_PATH"
-
-	#
-	# Did we find DPDK?
-	#
-	if test "$found_dpdk" = yes; then
-		#
-		# Found it.
-		#
-		# We call rte_eth_dev_count_avail(), and older versions
-		# of DPDK didn't have it, so check for it.
-		#
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		CFLAGS="$CFLAGS $DPDK_CFLAGS"
-		LIBS="$LIBS $DPDK_LIBS"
-		ac_fn_c_check_func "$LINENO" "rte_eth_dev_count_avail" "ac_cv_func_rte_eth_dev_count_avail"
-if test "x$ac_cv_func_rte_eth_dev_count_avail" = xyes; then :
-
-fi
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-	fi
-
-	if test "$ac_cv_func_rte_eth_dev_count_avail" = yes; then
-		#
-		# We found a usable DPDK.
-		#
-		# Check whether the rte_ether.h file defines
-		# struct ether_addr or struct rte_ether_addr.
-		#
-		# ("API compatibility?  That's for losers!")
-		#
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		CFLAGS="$CFLAGS $DPDK_CFLAGS"
-		LIBS="$LIBS $DPDK_LIBS"
-		ac_fn_c_check_type "$LINENO" "struct rte_ether_addr" "ac_cv_type_struct_rte_ether_addr" "
-			#include <rte_ether.h>
-
-"
-if test "x$ac_cv_type_struct_rte_ether_addr" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_RTE_ETHER_ADDR 1
-_ACEOF
-
-
-fi
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-
-		#
-		# We can build with DPDK.
-		#
-		V_INCLS="$V_INCLS $DPDK_CFLAGS"
-		ADDITIONAL_LIBS="$ADDITIONAL_LIBS $DPDK_LIBS"
-		ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $DPDK_LIBS_STATIC"
-		REQUIRES_PRIVATE="$REQUIRES_PRIVATE libdpdk"
-
-$as_echo "#define PCAP_SUPPORT_DPDK 1" >>confdefs.h
-
-		if test $V_PCAP != dpdk ; then
-			MODULE_C_SRC="$MODULE_C_SRC pcap-dpdk.c"
-		fi
-	else
-		#
-		# We didn't find a usable DPDK.
-		# If we required it (with --with-dpdk or --with-pcap=dpdk),
-		# fail with an appropriate message telling the user what
-		# the problem was, otherwise note the problem with a
-		# warning.
-		#
-		if test "$found_dpdk" != yes; then
-			#
-			# Not found with pkg-config.  Note that we
-			# require that DPDK must be findable with
-			# pkg-config.
-			#
-			if test "$V_PCAP" = dpdk; then
-				#
-				# User requested DPDK-only capture support.
-				#
-				as_fn_error $? "DPDK support requested with --with-pcap=dpdk, but
-we couldn't find DPDK with pkg-config.  Make sure that pkg-config is
-installed, that DPDK 18.02.2 or later is installed, and that DPDK
-provides a .pc file." "$LINENO" 5
-			fi
-
-			if test "$want_dpdk" = yes; then
-				#
-				# User requested that libpcap include
-				# DPDK capture support.
-				#
-				as_fn_error $? "DPDK support requested with --with-dpdk, but we
-couldn't find DPDK with pkg-config.  Make sure that pkg-config
-is installed, that DPDK 18.02.2 or later is installed, and that
-DPDK provides .pc file." "$LINENO" 5
-			fi
-
-			#
-			# User didn't indicate whether they wanted DPDK
-			# or not; just warn why we didn't find it.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: We couldn't find DPDK with pkg-config.  If
-you want DPDK support, make sure that pkg-config is installed,
-that DPDK 18.02.2 or later is installed, and that DPDK provides a
-.pc file." >&5
-$as_echo "$as_me: WARNING: We couldn't find DPDK with pkg-config.  If
-you want DPDK support, make sure that pkg-config is installed,
-that DPDK 18.02.2 or later is installed, and that DPDK provides a
-.pc file." >&2;}
-		elif test "$ac_cv_func_rte_eth_dev_count_avail" != yes; then
-			#
-			# Found with pkg-config, but we couldn't compile
-			# a program that calls rte_eth_dev_count(); we
-			# probably have the developer package installed,
-			# but don't have a sufficiently recent version
-			# of DPDK.  Note that we need a sufficiently
-			# recent version of DPDK.
-			#
-			if test "$V_PCAP" = dpdk; then
-				#
-				# User requested DPDK-only capture support.
-				#
-				as_fn_error $? "DPDK support requested with --with-pcap=dpdk, but we
-can't compile libpcap with DPDK.  Make sure that DPDK 18.02.2 or later
-is installed." "$LINENO" 5
-			fi
-
-			if test "$want_dpdk" = yes; then
-				#
-				# User requested that libpcap include
-				# DPDK capture support.
-				#
-				as_fn_error $? "DPDK support requested with --with-dpdk, but
-we can't compile libpcap with DPDK.  Make sure that DPDK 18.02.2
-or later is DPDK is installed." "$LINENO" 5
-			fi
-
-			#
-			# User didn't indicate whether they wanted DPDK
-			# or not; just warn why we didn't find it.
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: DPDK was found, but we can't compile libpcap with it.
-Make sure that DPDK 18.02.2 or later is installed." >&5
-$as_echo "$as_me: WARNING: DPDK was found, but we can't compile libpcap with it.
-Make sure that DPDK 18.02.2 or later is installed." >&2;}
-		fi
-	fi
-fi
-
-
-# Check whether --enable-bluetooth was given.
-if test "${enable_bluetooth+set}" = set; then :
-  enableval=$enable_bluetooth;
-else
-  enable_bluetooth=ifsupportavailable
-fi
-
-
-if test "xxx_only" = yes; then
-	# User requested something-else-only pcap, so they don't
-	# want Bluetooth support.
-	enable_bluetooth=no
-fi
-
-if test "x$enable_bluetooth" != "xno" ; then
-		case "$host_os" in
-	linux*)
-		ac_fn_c_check_header_mongrel "$LINENO" "bluetooth/bluetooth.h" "ac_cv_header_bluetooth_bluetooth_h" "$ac_includes_default"
-if test "x$ac_cv_header_bluetooth_bluetooth_h" = xyes; then :
-
-			#
-			# We have bluetooth.h, so we support Bluetooth
-			# sniffing.
-			#
-
-$as_echo "#define PCAP_SUPPORT_BT 1" >>confdefs.h
-
-			MODULE_C_SRC="$MODULE_C_SRC pcap-bt-linux.c"
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: Bluetooth sniffing is supported" >&5
-$as_echo "$as_me: Bluetooth sniffing is supported" >&6;}
-			ac_lbl_bluetooth_available=yes
-
-			#
-			# OK, does struct sockaddr_hci have an hci_channel
-			# member?
-			#
-			ac_fn_c_check_member "$LINENO" "struct sockaddr_hci" "hci_channel" "ac_cv_member_struct_sockaddr_hci_hci_channel" "
-				#include <bluetooth/bluetooth.h>
-				#include <bluetooth/hci.h>
-
-"
-if test "x$ac_cv_member_struct_sockaddr_hci_hci_channel" = xyes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL 1
-_ACEOF
-
-
-				#
-				# Yes; is HCI_CHANNEL_MONITOR defined?
-				#
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if HCI_CHANNEL_MONITOR is defined" >&5
-$as_echo_n "checking if HCI_CHANNEL_MONITOR is defined... " >&6; }
-				if ${ac_cv_lbl_hci_channel_monitor_is_defined+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-					    #include <bluetooth/bluetooth.h>
-					    #include <bluetooth/hci.h>
-
-int
-main ()
-{
-
-					    u_int i = HCI_CHANNEL_MONITOR;
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-					    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define PCAP_SUPPORT_BT_MONITOR /**/" >>confdefs.h
-
-					    MODULE_C_SRC="$MODULE_C_SRC pcap-bt-monitor-linux.c"
-
-else
-
-					    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-
-
-else
-
-			#
-			# We don't have bluetooth.h, so we don't support
-			# Bluetooth sniffing.
-			#
-			if test "x$enable_bluetooth" = "xyes" ; then
-				as_fn_error $? "Bluetooth sniffing is not supported; install bluez-lib devel to enable it" "$LINENO" 5
-			else
-				{ $as_echo "$as_me:${as_lineno-$LINENO}: Bluetooth sniffing is not supported; install bluez-lib devel to enable it" >&5
-$as_echo "$as_me: Bluetooth sniffing is not supported; install bluez-lib devel to enable it" >&6;}
-			fi
-
-fi
-
-
-		;;
-	*)
-		if test "x$enable_bluetooth" = "xyes" ; then
-			as_fn_error $? "no Bluetooth sniffing support implemented for $host_os" "$LINENO" 5
-		else
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: no Bluetooth sniffing support implemented for $host_os" >&5
-$as_echo "$as_me: no Bluetooth sniffing support implemented for $host_os" >&6;}
-		fi
-		;;
-	esac
-
-fi
-
-# Check whether --enable-dbus was given.
-if test "${enable_dbus+set}" = set; then :
-  enableval=$enable_dbus;
-else
-  enable_dbus=ifavailable
-fi
-
-
-if test "xxx_only" = yes; then
-	# User requested something-else-only pcap, so they don't
-	# want D-Bus support.
-	enable_dbus=no
-fi
-
-if test "x$enable_dbus" != "xno"; then
-	if test "x$enable_dbus" = "xyes"; then
-		case "$host_os" in
-
-		darwin*)
-			#
-			# We don't support D-Bus sniffing on macOS; see
-			#
-			# https://bugs.freedesktop.org/show_bug.cgi?id=74029
-			#
-			# The user requested it, so fail.
-			#
-			as_fn_error $? "Due to freedesktop.org bug 74029, D-Bus capture support is not available on macOS" "$LINENO" 5
-		esac
-	else
-		case "$host_os" in
-
-		darwin*)
-			#
-			# We don't support D-Bus sniffing on macOS; see
-			#
-			# https://bugs.freedesktop.org/show_bug.cgi?id=74029
-			#
-			# The user dind't explicitly request it, so just
-			# silently refuse to enable it.
-			#
-			enable_dbus="no"
-			;;
-		esac
-	fi
-fi
-
-if test "x$enable_dbus" != "xno"; then
-
-
-pkg_failed=no
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for dbus-1 with pkg-config" >&5
-$as_echo_n "checking for dbus-1 with pkg-config... " >&6; }
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-1\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "dbus-1") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-
-	#
-	# The package was found, so try to get its C flags and
-	# libraries.
-	#
-	if test -n "$DBUS_CFLAGS"; then
-    pkg_cv_DBUS_CFLAGS="$DBUS_CFLAGS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-1\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "dbus-1") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DBUS_CFLAGS=`$PKG_CONFIG --cflags "dbus-1" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$DBUS_LIBS"; then
-    pkg_cv_DBUS_LIBS="$DBUS_LIBS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-1\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "dbus-1") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DBUS_LIBS=`$PKG_CONFIG --libs "dbus-1" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$DBUS_LIBS_STATIC"; then
-    pkg_cv_DBUS_LIBS_STATIC="$DBUS_LIBS_STATIC"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-1\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "dbus-1") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_DBUS_LIBS_STATIC=`$PKG_CONFIG --libs --static "dbus-1" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-
-
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: error" >&5
-$as_echo "error" >&6; }
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-	        if test $_pkg_short_errors_supported = yes; then
-		        DBUS_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "dbus-1" 2>&1`
-	        else
-		        DBUS_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "dbus-1" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$DBUS_PKG_ERRORS" >&5
-
-
-		if test "x$enable_dbus" = "xyes"; then
-			as_fn_error $? "--enable-dbus was given, but the dbus-1 package is not installed" "$LINENO" 5
-		fi
-
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found (pkg-config not found)" >&5
-$as_echo "not found (pkg-config not found)" >&6; }
-	else
-		#
-		# We found the package.
-		#
-		DBUS_CFLAGS=$pkg_cv_DBUS_CFLAGS
-		DBUS_LIBS=$pkg_cv_DBUS_LIBS
-		DBUS_LIBS_STATIC=$pkg_cv_DBUS_LIBS_STATIC
-	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
-$as_echo "found" >&6; }
-
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		CFLAGS="$CFLAGS $DBUS_CFLAGS"
-		LIBS="$LIBS $DBUS_LIBS"
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the D-Bus library defines dbus_connection_read_write" >&5
-$as_echo_n "checking whether the D-Bus library defines dbus_connection_read_write... " >&6; }
-		cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-		     #include <time.h>
-		     #include <sys/time.h>
-
-		     #include <dbus/dbus.h>
-int
-main ()
-{
-return dbus_connection_read_write(NULL, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define PCAP_SUPPORT_DBUS 1" >>confdefs.h
-
-			MODULE_C_SRC="$MODULE_C_SRC pcap-dbus.c"
-			V_INCLS="$V_INCLS $DBUS_CFLAGS"
-			ADDITIONAL_LIBS="$ADDITIONAL_LIBS $DBUS_LIBS"
-			ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $DBUS_LIBS_STATIC"
-			REQUIRES_PRIVATE="$REQUIRES_PRIVATE dbus-1"
-
-else
-
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-			if test "x$enable_dbus" = "xyes"; then
-			    as_fn_error $? "--enable-dbus was given, but the D-Bus library doesn't define dbus_connection_read_write()" "$LINENO" 5
-			fi
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-
-	fi
-else
-
-	#
-	# The package isn't present.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-
-fi
-
-
-fi
-
-# Check whether --enable-rdma was given.
-if test "${enable_rdma+set}" = set; then :
-  enableval=$enable_rdma;
-else
-  enable_rdma=ifavailable
-fi
-
-
-if test "xxx_only" = yes; then
-	# User requested something-else-only pcap, so they don't
-	# want RDMA support.
-	enable_rdma=no
-fi
-
-if test "x$enable_rdma" != "xno"; then
-
-
-pkg_failed=no
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for libibverbs with pkg-config" >&5
-$as_echo_n "checking for libibverbs with pkg-config... " >&6; }
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libibverbs\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libibverbs") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-
-	#
-	# The package was found, so try to get its C flags and
-	# libraries.
-	#
-	if test -n "$LIBIBVERBS_CFLAGS"; then
-    pkg_cv_LIBIBVERBS_CFLAGS="$LIBIBVERBS_CFLAGS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libibverbs\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libibverbs") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBIBVERBS_CFLAGS=`$PKG_CONFIG --cflags "libibverbs" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$LIBIBVERBS_LIBS"; then
-    pkg_cv_LIBIBVERBS_LIBS="$LIBIBVERBS_LIBS"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libibverbs\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libibverbs") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBIBVERBS_LIBS=`$PKG_CONFIG --libs "libibverbs" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-	if test -n "$LIBIBVERBS_LIBS_STATIC"; then
-    pkg_cv_LIBIBVERBS_LIBS_STATIC="$LIBIBVERBS_LIBS_STATIC"
- elif test -n "$PKG_CONFIG"; then
-
-if test -n "$PKG_CONFIG" && \
-    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libibverbs\""; } >&5
-  ($PKG_CONFIG --exists --print-errors "libibverbs") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  pkg_cv_LIBIBVERBS_LIBS_STATIC=`$PKG_CONFIG --libs --static "libibverbs" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes
-else
-  pkg_failed=yes
-fi
- else
-    pkg_failed=untried
-fi
-
-
-
-	if test $pkg_failed = yes; then
-		#
-		# That failed - report an error.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: error" >&5
-$as_echo "error" >&6; }
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-	        if test $_pkg_short_errors_supported = yes; then
-		        LIBIBVERBS_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libibverbs" 2>&1`
-	        else
-		        LIBIBVERBS_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libibverbs" 2>&1`
-	        fi
-		# Put the nasty error message in config.log where it belongs
-		echo "$LIBIBVERBS_PKG_ERRORS" >&5
-
-		as_fn_error $? "Package requirements (libibverbs) were not met:
-
-$LIBIBVERBS_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-
-Alternatively, you may set the environment variables LIBIBVERBS_CFLAGS
-and LIBIBVERBS_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details." "$LINENO" 5
-	elif test $pkg_failed = untried; then
-		#
-		# We don't have pkg-config, so it didn't work.
-		#
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found (pkg-config not found)" >&5
-$as_echo "not found (pkg-config not found)" >&6; }
-	else
-		#
-		# We found the package.
-		#
-		LIBIBVERBS_CFLAGS=$pkg_cv_LIBIBVERBS_CFLAGS
-		LIBIBVERBS_LIBS=$pkg_cv_LIBIBVERBS_LIBS
-		LIBIBVERBS_LIBS_STATIC=$pkg_cv_LIBIBVERBS_LIBS_STATIC
-	        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
-$as_echo "found" >&6; }
-
-		found_libibverbs=yes
-		LIBIBVERBS_REQUIRES_PRIVATE="libibverbs"
-
-	fi
-else
-
-	#
-	# The package isn't present.
-	#
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-
-fi
-
-
-	if test "x$found_libibverbs" != "xyes"; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ibv_get_device_list in -libverbs" >&5
-$as_echo_n "checking for ibv_get_device_list in -libverbs... " >&6; }
-if ${ac_cv_lib_ibverbs_ibv_get_device_list+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-libverbs  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char ibv_get_device_list ();
-int
-main ()
-{
-return ibv_get_device_list ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_ibverbs_ibv_get_device_list=yes
-else
-  ac_cv_lib_ibverbs_ibv_get_device_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ibverbs_ibv_get_device_list" >&5
-$as_echo "$ac_cv_lib_ibverbs_ibv_get_device_list" >&6; }
-if test "x$ac_cv_lib_ibverbs_ibv_get_device_list" = xyes; then :
-
-			found_libibverbs=yes
-			LIBIBVERBS_CFLAGS=""
-			LIBIBVERBS_LIBS="-libverbs"
-			# XXX - at least on Ubuntu 20.04, there are many more
-			# libraries needed; is there any platform where
-			# libibverbs is available but where pkg-config isn't
-			# available or libibverbs doesn't use it?  If not,
-			# we should only use pkg-config for it.
-			LIBIBVERBS_LIBS_STATIC="-libverbs"
-			LIBIBVERBS_LIBS_PRIVATE="-libverbs"
-
-
-fi
-
-	fi
-
-	if test "x$found_libibverbs" = "xyes"; then
-
-	save_CFLAGS="$CFLAGS"
-	save_LIBS="$LIBS"
-	save_LDFLAGS="$LDFLAGS"
-
-		CFLAGS="$CFLAGS $LIBIBVERBS_CFLAGS"
-		LIBS="$LIBS $LIBIBVERBS_LIBS"
-		ac_fn_c_check_header_mongrel "$LINENO" "infiniband/verbs.h" "ac_cv_header_infiniband_verbs_h" "$ac_includes_default"
-if test "x$ac_cv_header_infiniband_verbs_h" = xyes; then :
-
-			#
-			# ibv_create_flow may be defined as a static inline
-			# function in infiniband/verbs.h, so we can't
-			# use AC_CHECK_LIB.
-			#
-			# Too bad autoconf has no AC_SYMBOL_EXISTS()
-			# macro that works like CMake's check_symbol_exists()
-			# function, to check do a compile check like
-			# this (they do a clever trick to avoid having
-			# to know the function's signature).
-			#
-			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether libibverbs defines ibv_create_flow" >&5
-$as_echo_n "checking whether libibverbs defines ibv_create_flow... " >&6; }
-			cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-					#include <infiniband/verbs.h>
-
-int
-main ()
-{
-
-					(void) ibv_create_flow((struct ibv_qp *) NULL,
-							       (struct ibv_flow_attr *) NULL);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-					{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-					found_usable_libibverbs=yes
-
-else
-
-					{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-
-
-
-	CFLAGS="$save_CFLAGS"
-	LIBS="$save_LIBS"
-	LDFLAGS="$save_LDFLAGS"
-
-	fi
-
-	if test "x$found_usable_libibverbs" = "xyes"
-	then
-
-$as_echo "#define PCAP_SUPPORT_RDMASNIFF /**/" >>confdefs.h
-
-		MODULE_C_SRC="$MODULE_C_SRC pcap-rdmasniff.c"
-		CFLAGS="$LIBIBVERBS_CFLAGS $CFLAGS"
-		ADDITIONAL_LIBS="$LIBIBVERBS_LIBS $ADDITIONAL_LIBS"
-		ADDITIONAL_LIBS_STATIC="$LIBIBVERBS_LIBS_STATIC $ADDITIONAL_LIBS_STATIC"
-		LIBS_PRIVATE="$LIBIBVERBS_LIBS_PRIVATE $LIBS_PRIVATE"
-		REQUIRES_PRIVATE="$REQUIRES_PRIVATE $LIBIBVERBS_REQUIRES_PRIVATE"
-	fi
-
-fi
-
-#
-# If this is a platform where we need to have the .pc file and
-# pcap-config script supply an rpath option to specify the directory
-# in which the libpcap shared library is installed, and the install
-# prefix /usr (meaning we're not installing a system library), provide
-# the rpath option.
-#
-# (We must check $prefix, as $libdir isn't necessarily /usr/lib in this
-# case - for example, Linux distributions for 64-bit platforms that
-# also provide support for binaries for a 32-bit version of the
-# platform may put the 64-bit libraries, the 32-bit libraries, or both
-# in directories other than /usr/lib.)
-#
-# In AIX, do we have to do this?
-#
-# In Darwin-based OSes, the full paths of the shared libraries with
-# which the program was linked are stored in the executable, so we don't
-# need to provide an rpath option.
-#
-# With the HP-UX linker, directories specified with -L are, by default,
-# added to the run-time search path, so we don't need to supply them.
-#
-# For Tru64 UNIX, "-rpath" works with DEC's^WCompaq's^WHP's C compiler
-# for Alpha, but isn't documented as working with GCC, and no GCC-
-# compatible option is documented as working with the DEC compiler.
-# If anybody needs this on Tru64/Alpha, they're welcome to figure out a
-# way to make it work.
-#
-# This must *not* depend on the compiler, as, on platforms where there's
-# a GCC-compatible compiler and a vendor compiler, we need to work with
-# both.
-#
-if test "$prefix" != "/usr"; then
-	case "$host_os" in
-
-	freebsd*|netbsd*|openbsd*|dragonfly*|linux*|haiku*|midipix*|gnu*)
-		#
-		# Platforms where the "native" C compiler is GCC or
-		# accepts compatible command-line arguments, and the
-		# "native" linker is the GNU linker or accepts
-		# compatible command-line arguments.
-		#
-		RPATH="-Wl,-rpath,\${libdir}"
-		;;
-
-	solaris*)
-		#
-		# Sun/Oracle's linker, the GNU linker, and
-		# GNU-compatible linkers all support -R.
-		#
-		RPATH="-Wl,-R,\${libdir}"
-		;;
-	esac
-fi
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-# Reject install programs that cannot install multiple files.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
-$as_echo_n "checking for a BSD-compatible install... " >&6; }
-if test -z "$INSTALL"; then
-if ${ac_cv_path_install+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in #((
-  ./ | .// | /[cC]/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    rm -rf conftest.one conftest.two conftest.dir
-	    echo one > conftest.one
-	    echo two > conftest.two
-	    mkdir conftest.dir
-	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
-	      test -s conftest.one && test -s conftest.two &&
-	      test -s conftest.dir/conftest.one &&
-	      test -s conftest.dir/conftest.two
-	    then
-	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	      break 3
-	    fi
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-
-  done
-IFS=$as_save_IFS
-
-rm -rf conftest.one conftest.two conftest.dir
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
-$as_echo "$INSTALL" >&6; }
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-
-ac_config_headers="$ac_config_headers config.h"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-#
-# We're done with configuration operations; add ADDITIONAL_LIBS and
-# ADDITIONAL_LIBS_STATIC to LIBS and LIBS_STATIC, respectively.
-#
-LIBS="$ADDITIONAL_LIBS $LIBS"
-LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $LIBS_STATIC"
-
-ac_config_commands="$ac_config_commands default-1"
-
-ac_config_files="$ac_config_files Makefile grammar.y pcap-filter.manmisc pcap-linktype.manmisc pcap-tstamp.manmisc pcap-savefile.manfile pcap.3pcap pcap_compile.3pcap pcap_datalink.3pcap pcap_dump_open.3pcap pcap_get_tstamp_precision.3pcap pcap_list_datalinks.3pcap pcap_list_tstamp_types.3pcap pcap_open_dead.3pcap pcap_open_offline.3pcap pcap_set_immediate_mode.3pcap pcap_set_tstamp_precision.3pcap pcap_set_tstamp_type.3pcap rpcapd/Makefile rpcapd/rpcapd.manadmin rpcapd/rpcapd-config.manfile testprogs/Makefile"
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes: double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \.
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    if test "x$cache_file" != "x/dev/null"; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
-      if test ! -f "$cache_file" || test -h "$cache_file"; then
-	cat confcache >"$cache_file"
-      else
-        case $cache_file in #(
-        */* | ?:*)
-	  mv -f confcache "$cache_file"$$ &&
-	  mv -f "$cache_file"$$ "$cache_file" ;; #(
-        *)
-	  mv -f confcache "$cache_file" ;;
-	esac
-      fi
-    fi
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-DEFS=-DHAVE_CONFIG_H
-
-ac_libobjs=
-ac_ltlibobjs=
-U=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
-
-: "${CONFIG_STATUS=./config.status}"
-ac_write_fail=0
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-as_write_fail=0
-cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-
-SHELL=\${CONFIG_SHELL-$SHELL}
-export SHELL
-_ASEOF
-cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
-  fi
-  $as_echo "$as_me: error: $2" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -pR'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -pR'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -pR'
-  fi
-else
-  as_ln_s='cp -pR'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-
-# as_fn_executable_p FILE
-# -----------------------
-# Test if FILE is an executable regular file.
-as_fn_executable_p ()
-{
-  test -f "$1" && test -x "$1"
-} # as_fn_executable_p
-as_test_x='test -x'
-as_executable_p=as_fn_executable_p
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-exec 6>&1
-## ----------------------------------- ##
-## Main body of $CONFIG_STATUS script. ##
-## ----------------------------------- ##
-_ASEOF
-test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# Save the log message, to keep $0 and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by pcap $as_me 1.10.4, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
-_ACEOF
-
-case $ac_config_files in *"
-"*) set x $ac_config_files; shift; ac_config_files=$*;;
-esac
-
-case $ac_config_headers in *"
-"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
-esac
-
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_headers="$ac_config_headers"
-config_commands="$ac_config_commands"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-ac_cs_usage="\
-\`$as_me' instantiates files and other configuration actions
-from templates according to the current configuration.  Unless the files
-and actions are specified as TAGs, all are instantiated by default.
-
-Usage: $0 [OPTION]... [TAG]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-      --config     print configuration, then exit
-  -q, --quiet, --silent
-                   do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-      --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
-      --header=FILE[:TEMPLATE]
-                   instantiate the configuration header FILE
-
-Configuration files:
-$config_files
-
-Configuration headers:
-$config_headers
-
-Configuration commands:
-$config_commands
-
-Report bugs to the package provider."
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
-ac_cs_version="\\
-pcap config.status 1.10.4
-configured by $0, generated by GNU Autoconf 2.69,
-  with options \\"\$ac_cs_config\\"
-
-Copyright (C) 2012 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-test -n "\$AWK" || AWK=awk
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# The default lists apply if the user does not specify any file.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=?*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  --*=)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
-  --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    '') as_fn_error $? "missing file argument" ;;
-    esac
-    as_fn_append CONFIG_FILES " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --he | --h)
-    # Conflict between --help and --header
-    as_fn_error $? "ambiguous option: \`$1'
-Try \`$0 --help' for more information.";;
-  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) as_fn_error $? "unrecognized option: \`$1'
-Try \`$0 --help' for more information." ;;
-
-  *) as_fn_append ac_config_targets " $1"
-     ac_need_defaults=false ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-if \$ac_cs_recheck; then
-  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-  shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
-  CONFIG_SHELL='$SHELL'
-  export CONFIG_SHELL
-  exec "\$@"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  $as_echo "$ac_log"
-} >&5
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-#
-# INIT-COMMANDS
-#
-
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "grammar.y") CONFIG_FILES="$CONFIG_FILES grammar.y" ;;
-    "pcap-filter.manmisc") CONFIG_FILES="$CONFIG_FILES pcap-filter.manmisc" ;;
-    "pcap-linktype.manmisc") CONFIG_FILES="$CONFIG_FILES pcap-linktype.manmisc" ;;
-    "pcap-tstamp.manmisc") CONFIG_FILES="$CONFIG_FILES pcap-tstamp.manmisc" ;;
-    "pcap-savefile.manfile") CONFIG_FILES="$CONFIG_FILES pcap-savefile.manfile" ;;
-    "pcap.3pcap") CONFIG_FILES="$CONFIG_FILES pcap.3pcap" ;;
-    "pcap_compile.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_compile.3pcap" ;;
-    "pcap_datalink.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_datalink.3pcap" ;;
-    "pcap_dump_open.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_dump_open.3pcap" ;;
-    "pcap_get_tstamp_precision.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_get_tstamp_precision.3pcap" ;;
-    "pcap_list_datalinks.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_list_datalinks.3pcap" ;;
-    "pcap_list_tstamp_types.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_list_tstamp_types.3pcap" ;;
-    "pcap_open_dead.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_open_dead.3pcap" ;;
-    "pcap_open_offline.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_open_offline.3pcap" ;;
-    "pcap_set_immediate_mode.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_set_immediate_mode.3pcap" ;;
-    "pcap_set_tstamp_precision.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_set_tstamp_precision.3pcap" ;;
-    "pcap_set_tstamp_type.3pcap") CONFIG_FILES="$CONFIG_FILES pcap_set_tstamp_type.3pcap" ;;
-    "rpcapd/Makefile") CONFIG_FILES="$CONFIG_FILES rpcapd/Makefile" ;;
-    "rpcapd/rpcapd.manadmin") CONFIG_FILES="$CONFIG_FILES rpcapd/rpcapd.manadmin" ;;
-    "rpcapd/rpcapd-config.manfile") CONFIG_FILES="$CONFIG_FILES rpcapd/rpcapd-config.manfile" ;;
-    "testprogs/Makefile") CONFIG_FILES="$CONFIG_FILES testprogs/Makefile" ;;
-
-  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
-  esac
-done
-
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
-{
-  tmp= ac_tmp=
-  trap 'exit_status=$?
-  : "${ac_tmp:=$tmp}"
-  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
-' 0
-  trap 'as_fn_exit 1' 1 2 13 15
-}
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
-ac_tmp=$tmp
-
-# Set up the scripts for CONFIG_FILES section.
-# No need to generate them if there are no CONFIG_FILES.
-# This happens for instance with `./config.status config.h'.
-if test -n "$CONFIG_FILES"; then
-
-
-ac_cr=`echo X | tr X '\015'`
-# On cygwin, bash can eat \r inside `` if the user requested igncr.
-# But we know of no other shell where ac_cr would be empty at this
-# point, so we can use a bashism as a fallback.
-if test "x$ac_cr" = x; then
-  eval ac_cr=\$\'\\r\'
-fi
-ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
-if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\\r'
-else
-  ac_cs_awk_cr=$ac_cr
-fi
-
-echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
-_ACEOF
-
-
-{
-  echo "cat >conf$$subs.awk <<_ACEOF" &&
-  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
-  echo "_ACEOF"
-} >conf$$subs.sh ||
-  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  . ./conf$$subs.sh ||
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-
-  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
-  if test $ac_delim_n = $ac_delim_num; then
-    break
-  elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-rm -f conf$$subs.sh
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
-_ACEOF
-sed -n '
-h
-s/^/S["/; s/!.*/"]=/
-p
-g
-s/^[^!]*!//
-:repl
-t repl
-s/'"$ac_delim"'$//
-t delim
-:nl
-h
-s/\(.\{148\}\)..*/\1/
-t more1
-s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
-p
-n
-b repl
-:more1
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t nl
-:delim
-h
-s/\(.\{148\}\)..*/\1/
-t more2
-s/["\\]/\\&/g; s/^/"/; s/$/"/
-p
-b
-:more2
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t delim
-' <conf$$subs.awk | sed '
-/^[^""]/{
-  N
-  s/\n//
-}
-' >>$CONFIG_STATUS || ac_write_fail=1
-rm -f conf$$subs.awk
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-_ACAWK
-cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
-  for (key in S) S_is_set[key] = 1
-  FS = ""
-
-}
-{
-  line = $ 0
-  nfields = split(line, field, "@")
-  substed = 0
-  len = length(field[1])
-  for (i = 2; i < nfields; i++) {
-    key = field[i]
-    keylen = length(key)
-    if (S_is_set[key]) {
-      value = S[key]
-      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
-      len += length(value) + length(field[++i])
-      substed = 1
-    } else
-      len += 1 + keylen
-  }
-
-  print line
-}
-
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
-  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
-else
-  cat
-fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
-  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
-_ACEOF
-
-# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
-# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
-h
-s///
-s/^/:/
-s/[	 ]*$/:/
-s/:\$(srcdir):/:/g
-s/:\${srcdir}:/:/g
-s/:@srcdir@:/:/g
-s/^:*//
-s/:*$//
-x
-s/\(=[	 ]*\).*/\1/
-G
-s/\n//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-fi # test -n "$CONFIG_FILES"
-
-# Set up the scripts for CONFIG_HEADERS section.
-# No need to generate them if there are no CONFIG_HEADERS.
-# This happens for instance with `./config.status Makefile'.
-if test -n "$CONFIG_HEADERS"; then
-cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
-BEGIN {
-_ACEOF
-
-# Transform confdefs.h into an awk script `defines.awk', embedded as
-# here-document in config.status, that substitutes the proper values into
-# config.h.in to produce config.h.
-
-# Create a delimiter string that does not exist in confdefs.h, to ease
-# handling of long lines.
-ac_delim='%!_!# '
-for ac_last_try in false false :; do
-  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_tt"; then
-    break
-  elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-
-# For the awk script, D is an array of macro values keyed by name,
-# likewise P contains macro parameters if any.  Preserve backslash
-# newline sequences.
-
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-sed -n '
-s/.\{148\}/&'"$ac_delim"'/g
-t rset
-:rset
-s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
-t def
-d
-:def
-s/\\$//
-t bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3"/p
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
-d
-:bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3\\\\\\n"\\/p
-t cont
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
-t cont
-d
-:cont
-n
-s/.\{148\}/&'"$ac_delim"'/g
-t clear
-:clear
-s/\\$//
-t bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/"/p
-d
-:bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
-b cont
-' <confdefs.h | sed '
-s/'"$ac_delim"'/"\\\
-"/g' >>$CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  for (key in D) D_is_set[key] = 1
-  FS = ""
-}
-/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
-  line = \$ 0
-  split(line, arg, " ")
-  if (arg[1] == "#") {
-    defundef = arg[2]
-    mac1 = arg[3]
-  } else {
-    defundef = substr(arg[1], 2)
-    mac1 = arg[2]
-  }
-  split(mac1, mac2, "(") #)
-  macro = mac2[1]
-  prefix = substr(line, 1, index(line, defundef) - 1)
-  if (D_is_set[macro]) {
-    # Preserve the white space surrounding the "#".
-    print prefix "define", macro P[macro] D[macro]
-    next
-  } else {
-    # Replace #undef with comments.  This is necessary, for example,
-    # in the case of _POSIX_SOURCE, which is predefined and required
-    # on some systems where configure will not decide to define it.
-    if (defundef == "undef") {
-      print "/*", prefix defundef, macro, "*/"
-      next
-    }
-  }
-}
-{ print }
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
-fi # test -n "$CONFIG_HEADERS"
-
-
-eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
-shift
-for ac_tag
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$ac_tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
-      esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      as_fn_append ac_file_inputs " '$ac_f'"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
-	`' by configure.'
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
-    fi
-    # Neutralize special characters interpreted by sed in replacement strings.
-    case $configure_input in #(
-    *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
-       sed 's/[\\\\&|]/\\\\&/g'`;; #(
-    *) ac_sed_conf_input=$configure_input;;
-    esac
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$ac_tmp/stdin" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
-    esac
-    ;;
-  esac
-
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  as_dir="$ac_dir"; as_fn_mkdir_p
-  ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-ac_sed_dataroot='
-/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p'
-case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-  s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_sed_extra="$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s|@configure_input@|$ac_sed_conf_input|;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@top_build_prefix@&$ac_top_build_prefix&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-$ac_datarootdir_hack
-"
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
-  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
-      "$ac_tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&2;}
-
-  rm -f "$ac_tmp/stdin"
-  case $ac_file in
-  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
-  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
-  esac \
-  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
- ;;
-  :H)
-  #
-  # CONFIG_HEADER
-  #
-  if test x"$ac_file" != x-; then
-    {
-      $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
-    } >"$ac_tmp/config.h" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
-$as_echo "$as_me: $ac_file is unchanged" >&6;}
-    else
-      rm -f "$ac_file"
-      mv "$ac_tmp/config.h" "$ac_file" \
-	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
-    fi
-  else
-    $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error $? "could not create -" "$LINENO" 5
-  fi
- ;;
-
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
- ;;
-  esac
-
-
-  case $ac_file$ac_mode in
-    "default-1":C) if test -f .devel; then
-	echo timestamp > stamp-h
-	cat $srcdir/Makefile-devel-adds >> Makefile
-	make depend || exit 1
-fi ;;
-
-  esac
-done # for ac_tag
-
-
-as_fn_exit 0
-_ACEOF
-ac_clean_files=$ac_clean_files_save
-
-test $ac_write_fail = 0 ||
-  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit 1
-fi
-if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
-fi
-
-exit 0
diff --git a/configure.ac b/configure.ac
index ec601c84..accb2589 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,17 +24,15 @@ AC_SUBST(PACKAGE_NAME)
 # These are the variables that are used in Makefile, pcap-config, and
 # libpcap.pc.
 #
-# CFLAGS: inherited from the environment, not modified by us (except
-# temporarily during tests that involve compilation).  Used only when
-# compiling C source.
-#
-# CXXFLAGS: inherited from the environment, not modified by us.  Used only
-# when compiling C++ source.
+# CFLAGS: inherited from the environment, not modified by us except
+# for flags required for the platform for which we're building (and
+# except temporarily during tests that involve compilation).  Used only
+# when compiling C source.
 #
 # LDFLAGS: inherited from the environment, not modified by us.
 #
 # LIBS: inherited from the environment; we add libraries required by
-# libpcap.  Librares that the core libpcap code requires are added
+# libpcap.  Libraries that the core libpcap code requires are added
 # first; libraries required by additional pcap modules are first
 # added to ADDITIONAL_LIBS, and only added to LIBS at the end, after
 # we're finished doing configuration tests for the modules.
@@ -62,7 +60,7 @@ AC_SUBST(PACKAGE_NAME)
 # libpcap.  Used in Makefile for both C and C++ source.
 #
 # ADDITIONAL_LIBS: additional libraries with which the libpcap dynamic
-# library needs to be linked.  Used in Makwfile; not used in pcap-config
+# library needs to be linked.  Used in Makefile; not used in pcap-config
 # or libpcap.pc, as, in all platforms on which we run, if a dynamic
 # library is linked with other dynamic libraries, a program using
 # that dynamic library doesn't have to link with those libraries -
@@ -121,39 +119,9 @@ AC_CHECK_SIZEOF([void *])
 ac_lbl_c_sizeof_void_p="$ac_cv_sizeof_void_p"
 
 #
-# We only need a C++ compiler for Haiku; all code except for its
-# pcap module is in C.
+# Get the size of a time_t, to know whether it's 32-bit or 64-bit.
 #
-case "$host_os" in
-haiku*)
-	AC_PROG_CXX
-
-	#
-	# Make sure C and C++ have the same pointer sizes with the flags
-	# they're given; if they don't, it means that the compilers for the
-	# languages will, with those flags, not produce code that can be
-	# linked together.
-	#
-	# We have to use different data types, because the results of
-	# a test are cached, so if we test for the size of a given type
-	# in C, the subsequent test in C++ will use the cached variable.
-	# We trick autoconf by testing the size of a "void *" in C and a
-	# "const void *" in C++.
-	#
-	AC_LANG_PUSH([C++])
-	AC_CHECK_SIZEOF([const void *])
-	ac_lbl_cxx_sizeof_void_p="$ac_cv_sizeof_const_void_p"
-	AC_LANG_POP([C++])
-	if test "$ac_lbl_cxx_sizeof_void_p" -eq 0; then
-		AC_MSG_ERROR([No C++ compiler was found])
-	fi
-	if test "$ac_lbl_c_sizeof_void_p" -ne "$ac_lbl_cxx_sizeof_void_p"; then
-		AC_MSG_ERROR([C compiler $CC produces code with $ac_lbl_c_sizeof_void_p-byte pointers
-while C++ compiler $CXX produces code with $ac_lbl_cxx_sizeof_void_p-byte pointers.  This prevents
-code in those languages from being combined.])
-	fi
-	;;
-esac
+AC_CHECK_SIZEOF([time_t],,[#include <time.h>])
 
 AC_LBL_C_INIT(V_CCOPT, V_INCLS)
 AC_LBL_SHLIBS_INIT
@@ -178,11 +146,16 @@ dnl
 AC_CHECK_HEADERS(sys/ioccom.h sys/sockio.h)
 AC_CHECK_HEADERS(netpacket/packet.h)
 
-AC_LBL_SAVE_CHECK_STATE
+#
+# Check whether the platform for which we're compiling requires extra
+# defines and libraries.  If so, add them to CFLAGS and LIBS, as we want
+# all subsequent tests to be done with those defines and libraries.
+#
 case "$host_os" in
 haiku*)
 	#
-	# Haiku needs _BSD_SOURCE for the _IO* macros because it doesn't use them.
+	# Haiku needs _BSD_SOURCE for the _IO* macros because it doesn't
+	# use them.
 	#
 	CFLAGS="$CFLAGS -D_BSD_SOURCE"
 	#
@@ -192,10 +165,10 @@ haiku*)
 	;;
 esac
 
+AC_LBL_SAVE_CHECK_STATE
 AC_LBL_FIXINCLUDES
 AC_LBL_RESTORE_CHECK_STATE
 
-AC_CHECK_FUNCS(strerror)
 AC_CHECK_FUNC(strerror_r,
     [
 	#
@@ -668,6 +641,26 @@ AC_CHECK_HEADER(pthread.h,
     ]
 )
 
+AC_MSG_CHECKING([whether to enable the instrument functions code])
+AC_ARG_ENABLE([instrument-functions],
+   [AS_HELP_STRING([--enable-instrument-functions],
+     [enable instrument functions code [default=no]])],
+   [],
+   [enableval=no])
+case "$enableval" in
+yes)	AC_MSG_RESULT(yes)
+	AC_DEFINE(ENABLE_INSTRUMENT_FUNCTIONS, 1,
+	    [define if you want to build the instrument functions code])
+	# Add '-finstrument-functions' instrumentation option to generate
+	# instrumentation calls for entry and exit to functions.
+	# Use '--enable-instrument-functions' also with tcpdump (or tcpslice)
+	# to see the output. See also https://www.tcpdump.org/faq.html#q17.
+	CFLAGS="$CFLAGS -O0 -ggdb -finstrument-functions"
+	;;
+*)	AC_MSG_RESULT(no)
+	;;
+esac
+
 dnl to pacify those who hate protochain insn
 AC_MSG_CHECKING(if --disable-protochain option is specified)
 AC_ARG_ENABLE(protochain,
@@ -819,11 +812,18 @@ else
 		V_PCAP=haiku
 	else
 		#
-		# Nothing we support.
-		#
-		V_PCAP=null
-		AC_MSG_WARN(cannot determine packet capture interface)
-		AC_MSG_WARN((see the INSTALL.md file for more info))
+		# We don't have any capture type we know about.
+		# Report an error, and tell the user to configure with
+		# --with-pcap=null if they want a libpcap that can't
+		# capture but that can read capture files.  That way,
+		# nobody gets surprised by getting a no-capture
+		# libpcap without asking for that.
+		#
+		AC_MSG_ERROR([No supported packet capture interface was found.
+ See the INSTALL.md file for information on packet capture support in
+ various operating systems.
+ If you want a libpcap that cannot capture packets but that can read
+ pcap and pcapng files, run configure with --with-pcap=null.])
 	fi
 fi
 AC_MSG_CHECKING(packet capture type)
@@ -844,7 +844,7 @@ AC_PATH_PROG([BREW], [brew])
 # Solaris pkg-config is annoying.  For at least one package (D-Bus, I'm
 # looking at *you*!), there are separate include files for 32-bit and
 # 64-bit builds (I guess using "unsigned long long" as a 64-bit integer
-# type on a 64-bit build is like crossing the beams or soething), and
+# type on a 64-bit build is like crossing the beams or something), and
 # there are two separate .pc files, so if we're doing a 32-bit build we
 # should make sure we look in /usr/lib/pkgconfig for .pc files and if
 # we're doing a 64-bit build we should make sure we look in
@@ -989,7 +989,7 @@ haiku)
 	#
 	# Capture module
 	#
-	PLATFORM_CXX_SRC="pcap-haiku.cpp"
+	PLATFORM_C_SRC="pcap-haiku.c"
 
 	#
 	# Just for the sake of it.
@@ -1030,7 +1030,7 @@ linux)
 		#
 		# Check for libnl-genl-3.0 with pkg-config.
 		#
-		PKG_CHECK_MODULES(LIBNL, libnl-genl-3.0,
+		PKG_CHECK_MODULE(LIBNL, libnl-genl-3.0,
 		    [
 			pkg_config_found_libnl=yes
 			V_INCLS="$V_INCLS $LIBNL_CFLAGS"
@@ -1121,6 +1121,25 @@ bpf)
 		#endif
 		#include <net/bpf.h>
 	    ])
+
+	#
+	# Check whether there's a net/ipnet.h header and,
+	# if so, whether it defines IPNET_ANY_LINK - if so,
+	# we assume we have the "any" device (that's a
+	# Solaris header, and later versions of Solaris
+	# have an "any" device).
+	#
+	# Attempting to include it at compile time could
+	# be a pain, as it's a kernel header.
+	#
+	AC_MSG_CHECKING(whether the Solaris "any" device is supported)
+	if test -e /usr/include/inet/ipnet.h &&
+	    grep -q IPNET_ANY_LINK /usr/include/inet/ipnet.h; then
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_SOLARIS_ANY_DEVICE, 1, [target host supports Solaris "any" device])
+	else
+		AC_MSG_RESULT(no)
+	fi
 	;;
 
 pf)
@@ -1795,7 +1814,7 @@ yes)	AC_MSG_RESULT(yes)
 		openssl_pkgconfig_dir=`$BREW --env --plain openssl | sed -n 's/PKG_CONFIG_PATH: //p'`
 		PKG_CONFIG_PATH="$openssl_pkgconfig_dir:$PKG_CONFIG_PATH"
 	fi
-	PKG_CHECK_MODULES(OPENSSL, openssl,
+	PKG_CHECK_MODULE(OPENSSL, openssl,
 	    [
 		#
 		# We found OpenSSL/libressl.
@@ -1921,13 +1940,14 @@ return 0;
 		ADDITIONAL_LIBS_STATIC="$ADDITIONAL_LIBS_STATIC $OPENSSL_LIBS_STATIC"
 		LIBS_PRIVATE="$LIBS_PRIVATE $OPENSSL_LIBS_PRIVATE"
 		REQUIRES_PRIVATE="$REQUIRES_PRIVATE $OPENSSL_REQUIRES_PRIVATE"
+		REMOTE_C_SRC="$REMOTE_C_SRC sslutils.c"
 	else
 		AC_MSG_NOTICE(OpenSSL not found)
 	fi
 
 	AC_DEFINE(ENABLE_REMOTE,,
 	    [Define to 1 if remote packet capture is to be supported])
-	REMOTE_C_SRC="$REMOTE_C_SRC pcap-new.c pcap-rpcap.c rpcap-protocol.c sockutils.c sslutils.c"
+	REMOTE_C_SRC="$REMOTE_C_SRC pcap-new.c pcap-rpcap.c rpcap-protocol.c sockutils.c"
 	BUILD_RPCAPD=build-rpcapd
 	INSTALL_RPCAPD=install-rpcapd
 	;;
@@ -2556,7 +2576,7 @@ if test "xxx_only" != yes; then
       # software that looks for /dev/null or /dev/tty, for example,
       # so doing that is *REALLY* not a good idea), please provide
       # some mechanism to determine that directory at *run time*,
-      # rather than *configure time*, so that it works when doinga
+      # rather than *configure time*, so that it works when doing
       # a cross-build, and that works with *multiple* distributions,
       # with our without udev, and with multiple versions of udev,
       # with udevinfo or udevadm or any other mechanism to get the
@@ -2639,7 +2659,7 @@ if test "x$enable_netmap" != "xno" ; then
 	#
 	# Check whether net/netmap_user.h is usable if NETMAP_WITH_LIBS is
 	# defined; it's not usable on DragonFly BSD 4.6 if NETMAP_WITH_LIBS
-	# is defined, for example, as it includes a non-existent malloc.h
+	# is defined, for example, as it includes a nonexistent malloc.h
 	# header.
 	#
 	AC_MSG_CHECKING(whether we can compile the netmap support)
@@ -2725,7 +2745,7 @@ if test "$want_dpdk" != no; then
 	if test -n "$dpdk_dir"; then
 		PKG_CONFIG_PATH="$dpdk_dir:$PKG_CONFIG_PATH"
 	fi
-	PKG_CHECK_MODULES(DPDK, libdpdk,
+	PKG_CHECK_MODULE(DPDK, libdpdk,
 	    [
 		found_dpdk=yes
 	    ])
@@ -2908,11 +2928,11 @@ if test "x$enable_bluetooth" != "xno" ; then
 					    #include <bluetooth/hci.h>
 					],
 					[
-					    u_int i = HCI_CHANNEL_MONITOR;
+					    int i = HCI_CHANNEL_MONITOR;
 					],
 					[
 					    AC_MSG_RESULT(yes)
-					    AC_DEFINE(PCAP_SUPPORT_BT_MONITOR,,
+					    AC_DEFINE(PCAP_SUPPORT_BT_MONITOR, 1,
 					      [target host supports Bluetooth Monitor])
 					    MODULE_C_SRC="$MODULE_C_SRC pcap-bt-monitor-linux.c"
 					],
@@ -2982,7 +3002,7 @@ if test "x$enable_dbus" != "xno"; then
 			#
 			# https://bugs.freedesktop.org/show_bug.cgi?id=74029
 			#
-			# The user dind't explicitly request it, so just
+			# The user didn't explicitly request it, so just
 			# silently refuse to enable it.
 			#
 			enable_dbus="no"
@@ -2992,7 +3012,7 @@ if test "x$enable_dbus" != "xno"; then
 fi
 
 if test "x$enable_dbus" != "xno"; then
-	PKG_CHECK_MODULES(DBUS, dbus-1,
+	PKG_CHECK_MODULE(DBUS, dbus-1,
 	    [
 		AC_LBL_SAVE_CHECK_STATE
 		CFLAGS="$CFLAGS $DBUS_CFLAGS"
@@ -3043,7 +3063,7 @@ if test "xxx_only" = yes; then
 fi
 
 if test "x$enable_rdma" != "xno"; then
-	PKG_CHECK_MODULES(LIBIBVERBS, libibverbs,
+	PKG_CHECK_MODULE(LIBIBVERBS, libibverbs,
 	    [
 		found_libibverbs=yes
 		LIBIBVERBS_REQUIRES_PRIVATE="libibverbs"
@@ -3105,7 +3125,7 @@ if test "x$enable_rdma" != "xno"; then
 
 	if test "x$found_usable_libibverbs" = "xyes"
 	then
-		AC_DEFINE(PCAP_SUPPORT_RDMASNIFF, , [target host supports RDMA sniffing])
+		AC_DEFINE(PCAP_SUPPORT_RDMASNIFF, 1, [target host supports RDMA sniffing])
 		MODULE_C_SRC="$MODULE_C_SRC pcap-rdmasniff.c"
 		CFLAGS="$LIBIBVERBS_CFLAGS $CFLAGS"
 		ADDITIONAL_LIBS="$LIBIBVERBS_LIBS $ADDITIONAL_LIBS"
@@ -3183,7 +3203,6 @@ AC_SUBST(RPATH)
 AC_SUBST(ADDLOBJS)
 AC_SUBST(ADDLARCHIVEOBJS)
 AC_SUBST(PLATFORM_C_SRC)
-AC_SUBST(PLATFORM_CXX_SRC)
 AC_SUBST(MODULE_C_SRC)
 AC_SUBST(REMOTE_C_SRC)
 AC_SUBST(PTHREAD_LIBS)
diff --git a/diag-control.h b/diag-control.h
index ae2641b4..d38f04ca 100644
--- a/diag-control.h
+++ b/diag-control.h
@@ -37,9 +37,11 @@
 
 #include "pcap/compiler-tests.h"
 
-#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8) || PCAP_IS_AT_LEAST_GNUC_VERSION(4,6)
+#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8) || \
+    PCAP_IS_AT_LEAST_GNUC_VERSION(4,6) || \
+    PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)
   /*
-   * Clang and GCC both support this way of putting pragmas into #defines.
+   * All these compilers support this way of putting pragmas into #defines.
    * We use it only if we have a compiler that supports it; see below
    * for the code that uses it and the #defines that control whether
    * that code is used.
@@ -62,9 +64,6 @@
     __pragma(warning(disable:4061))
   #define DIAG_ON_ENUM_SWITCH \
     __pragma(warning(pop))
-#else
-  #define DIAG_OFF_ENUM_SWITCH
-  #define DIAG_ON_ENUM_SWITCH
 #endif
 
 /*
@@ -78,9 +77,6 @@
     __pragma(warning(disable:4065))
   #define DIAG_ON_DEFAULT_ONLY_SWITCH \
     __pragma(warning(pop))
-#else
-  #define DIAG_OFF_DEFAULT_ONLY_SWITCH
-  #define DIAG_ON_DEFAULT_ONLY_SWITCH
 #endif
 
 /*
@@ -128,8 +124,31 @@
     PCAP_DO_PRAGMA(clang diagnostic ignored "-Wdeprecated-declarations")
   #define DIAG_ON_DEPRECATION \
     PCAP_DO_PRAGMA(clang diagnostic pop)
-  #define DIAG_OFF_FORMAT_TRUNCATION
-  #define DIAG_ON_FORMAT_TRUNCATION
+
+  /*
+   * When Clang correctly detects an old-style function prototype after
+   * preprocessing, the warning can be irrelevant to this source tree because
+   * the prototype comes from a system header macro.
+   */
+  #if PCAP_IS_AT_LEAST_CLANG_VERSION(5,0)
+    #define DIAG_OFF_STRICT_PROTOTYPES \
+      PCAP_DO_PRAGMA(clang diagnostic push) \
+      PCAP_DO_PRAGMA(clang diagnostic ignored "-Wstrict-prototypes")
+    #define DIAG_ON_STRICT_PROTOTYPES \
+      PCAP_DO_PRAGMA(clang diagnostic pop)
+  #endif
+
+  #define DIAG_OFF_DOCUMENTATION \
+    PCAP_DO_PRAGMA(clang diagnostic push) \
+    PCAP_DO_PRAGMA(clang diagnostic ignored "-Wdocumentation")
+  #define DIAG_ON_DOCUMENTATION \
+    PCAP_DO_PRAGMA(clang diagnostic pop)
+
+  #define DIAG_OFF_SIGN_COMPARE \
+    PCAP_DO_PRAGMA(clang diagnostic push) \
+    PCAP_DO_PRAGMA(clang diagnostic ignored "-Wsign-compare")
+  #define DIAG_ON_SIGN_COMPARE \
+    PCAP_DO_PRAGMA(clang diagnostic pop)
 #elif defined(_MSC_VER)
   /*
    * This is Microsoft Visual Studio; we can use __pragma(warning(disable:XXXX))
@@ -165,8 +184,6 @@
     __pragma(warning(disable:4996))
   #define DIAG_ON_DEPRECATION \
     __pragma(warning(pop))
-  #define DIAG_OFF_FORMAT_TRUNCATION
-  #define DIAG_ON_FORMAT_TRUNCATION
 #elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,6)
   /*
    * This is GCC 4.6 or later, or a compiler claiming to be that.
@@ -184,8 +201,6 @@
   /*
    * GCC currently doesn't issue any narrowing warnings.
    */
-  #define DIAG_OFF_NARROWING
-  #define DIAG_ON_NARROWING
 
   /*
    * Suppress deprecation warnings.
@@ -207,24 +222,16 @@
       PCAP_DO_PRAGMA(GCC diagnostic ignored "-Wformat-truncation=")
     #define DIAG_ON_FORMAT_TRUNCATION \
       PCAP_DO_PRAGMA(GCC diagnostic pop)
-  #else
-   #define DIAG_OFF_FORMAT_TRUNCATION
-   #define DIAG_ON_FORMAT_TRUNCATION
   #endif
-#else
+#elif PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)
   /*
-   * Neither Visual Studio, nor Clang 2.8 or later, nor GCC 4.6 or later
-   * or a compiler claiming to be that; there's nothing we know of that
-   * we can do.
+   * Sun C compiler version 5.5 (Studio version 8) and later supports "#pragma
+   * error_messages()".
    */
-  #define DIAG_OFF_FLEX
-  #define DIAG_ON_FLEX
-  #define DIAG_OFF_NARROWING
-  #define DIAG_ON_NARROWING
-  #define DIAG_OFF_DEPRECATION
-  #define DIAG_ON_DEPRECATION
-  #define DIAG_OFF_FORMAT_TRUNCATION
-  #define DIAG_ON_FORMAT_TRUNCATION
+  #define DIAG_OFF_FLEX \
+    PCAP_DO_PRAGMA(error_messages(off,E_STATEMENT_NOT_REACHED))
+  #define DIAG_ON_FLEX \
+    PCAP_DO_PRAGMA(error_messages(default,E_STATEMENT_NOT_REACHED))
 #endif
 
 #ifdef YYBYACC
@@ -268,12 +275,6 @@
     #define DIAG_OFF_BISON_BYACC \
       PCAP_DO_PRAGMA(GCC diagnostic ignored "-Wshadow") \
       PCAP_DO_PRAGMA(GCC diagnostic ignored "-Wunreachable-code")
-  #else
-    /*
-     * Neither Clang 2.8 or later nor GCC 4.6 or later or a compiler
-     * claiming to be that; there's nothing we know of that we can do.
-     */
-    #define DIAG_OFF_BISON_BYACC
   #endif
 #else
   /*
@@ -310,15 +311,38 @@
      */
     #define DIAG_OFF_BISON_BYACC \
       PCAP_DO_PRAGMA(GCC diagnostic ignored "-Wunreachable-code")
-  #else
+  #elif PCAP_IS_AT_LEAST_SUNC_VERSION(5,5)
     /*
-     * Neither Clang 2.8 or later nor GCC 4.6 or later or a compiler
-     * claiming to be that; there's nothing we know of that we can do.
+     * Same as for DIAG_OFF_FLEX above.
      */
-    #define DIAG_OFF_BISON_BYACC
+    #define DIAG_OFF_BISON_BYACC \
+      PCAP_DO_PRAGMA(error_messages(off,E_STATEMENT_NOT_REACHED))
   #endif
 #endif
 
+#if PCAP_IS_AT_LEAST_CLANG_VERSION(2,8)
+  /*
+   * Clang appears to let you ignore a result without a warning by
+   * casting the function result to void, so we don't appear to
+   * need this for Clang.
+   */
+#elif PCAP_IS_AT_LEAST_GNUC_VERSION(4,5)
+  /*
+   * GCC warns about unused return values if a function is marked as
+   * "warn about ignoring this function's return value".
+   */
+  #define DIAG_OFF_WARN_UNUSED_RESULT \
+    PCAP_DO_PRAGMA(GCC diagnostic push) \
+    PCAP_DO_PRAGMA(GCC diagnostic ignored "-Wunused-result")
+  #define DIAG_ON_WARN_UNUSED_RESULT \
+    PCAP_DO_PRAGMA(GCC diagnostic pop)
+
+  /*
+   * GCC does not currently generate any -Wstrict-prototypes warnings that
+   * would need silencing as is done for Clang above.
+   */
+#endif
+
 /*
  * GCC needs this on AIX for longjmp().
  */
@@ -331,8 +355,76 @@
    * So please remember to use this very carefully.
    */
   #define PCAP_UNREACHABLE __builtin_unreachable();
-#else
-  #define PCAP_UNREACHABLE
+#endif
+
+#ifndef DIAG_OFF_ENUM_SWITCH
+#define DIAG_OFF_ENUM_SWITCH
+#endif
+#ifndef DIAG_ON_ENUM_SWITCH
+#define DIAG_ON_ENUM_SWITCH
+#endif
+#ifndef DIAG_OFF_DEFAULT_ONLY_SWITCH
+#define DIAG_OFF_DEFAULT_ONLY_SWITCH
+#endif
+#ifndef DIAG_ON_DEFAULT_ONLY_SWITCH
+#define DIAG_ON_DEFAULT_ONLY_SWITCH
+#endif
+#ifndef DIAG_OFF_FLEX
+#define DIAG_OFF_FLEX
+#endif
+#ifndef DIAG_ON_FLEX
+#define DIAG_ON_FLEX
+#endif
+#ifndef DIAG_OFF_NARROWING
+#define DIAG_OFF_NARROWING
+#endif
+#ifndef DIAG_ON_NARROWING
+#define DIAG_ON_NARROWING
+#endif
+#ifndef DIAG_OFF_DEPRECATION
+#define DIAG_OFF_DEPRECATION
+#endif
+#ifndef DIAG_ON_DEPRECATION
+#define DIAG_ON_DEPRECATION
+#endif
+#ifndef DIAG_OFF_FORMAT_TRUNCATION
+#define DIAG_OFF_FORMAT_TRUNCATION
+#endif
+#ifndef DIAG_ON_FORMAT_TRUNCATION
+#define DIAG_ON_FORMAT_TRUNCATION
+#endif
+#ifndef DIAG_OFF_BISON_BYACC
+#define DIAG_OFF_BISON_BYACC
+#endif
+//
+// DIAG_ON_BISON_BYACC does not need to be defined.
+//
+#ifndef DIAG_OFF_WARN_UNUSED_RESULT
+#define DIAG_OFF_WARN_UNUSED_RESULT
+#endif
+#ifndef DIAG_ON_WARN_UNUSED_RESULT
+#define DIAG_ON_WARN_UNUSED_RESULT
+#endif
+#ifndef DIAG_OFF_STRICT_PROTOTYPES
+#define DIAG_OFF_STRICT_PROTOTYPES
+#endif
+#ifndef DIAG_ON_STRICT_PROTOTYPES
+#define DIAG_ON_STRICT_PROTOTYPES
+#endif
+#ifndef DIAG_OFF_DOCUMENTATION
+#define DIAG_OFF_DOCUMENTATION
+#endif
+#ifndef DIAG_ON_DOCUMENTATION
+#define DIAG_ON_DOCUMENTATION
+#endif
+#ifndef DIAG_OFF_SIGN_COMPARE
+#define DIAG_OFF_SIGN_COMPARE
+#endif
+#ifndef DIAG_ON_SIGN_COMPARE
+#define DIAG_ON_SIGN_COMPARE
+#endif
+#ifndef PCAP_UNREACHABLE
+#define PCAP_UNREACHABLE
 #endif
 
 #endif /* _diag_control_h */
diff --git a/dlpisubs.c b/dlpisubs.c
index 6815b0ec..e1a64492 100644
--- a/dlpisubs.c
+++ b/dlpisubs.c
@@ -11,9 +11,7 @@
  * by pcap-[dlpi,libdlpi].c.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #ifndef DL_IPATM
 #define DL_IPATM	0x12	/* ATM Classical IP interface */
@@ -195,7 +193,7 @@ pcap_process_pkts(pcap_t *p, pcap_handler callback, u_char *user,
 		bufp += caplen;
 #endif
 		++pd->stat.ps_recv;
-		if (pcap_filter(p->fcode.bf_insns, pk, origlen, caplen)) {
+		if (pcapint_filter(p->fcode.bf_insns, pk, origlen, caplen)) {
 #ifdef HAVE_SYS_BUFMOD_H
 			pkthdr.ts.tv_sec = sbp->sbh_timestamp.tv_sec;
 			pkthdr.ts.tv_usec = sbp->sbh_timestamp.tv_usec;
@@ -246,14 +244,14 @@ pcap_process_mactype(pcap_t *p, u_int mactype)
 		 * Ethernet framing).
 		 */
 		p->dlt_list = (u_int *)malloc(sizeof(u_int) * 2);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (p->dlt_list != NULL) {
-			p->dlt_list[0] = DLT_EN10MB;
-			p->dlt_list[1] = DLT_DOCSIS;
-			p->dlt_count = 2;
+		if (p->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			return (-1);
 		}
+		p->dlt_list[0] = DLT_EN10MB;
+		p->dlt_list[1] = DLT_DOCSIS;
+		p->dlt_count = 2;
 		break;
 
 	case DL_FDDI:
@@ -377,7 +375,7 @@ pcap_alloc_databuf(pcap_t *p)
 	p->bufsize = PKTBUFSIZE;
 	p->buffer = malloc(p->bufsize + p->offset);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (-1);
 	}
@@ -412,6 +410,6 @@ strioctl(int fd, int cmd, int len, char *dp)
 static void
 pcap_stream_err(const char *func, int err, char *errbuf)
 {
-	pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, err, "%s", func);
+	pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, err, "%s", func);
 }
 #endif
diff --git a/doc/README.haiku.md b/doc/README.haiku.md
new file mode 100644
index 00000000..b9b062bd
--- /dev/null
+++ b/doc/README.haiku.md
@@ -0,0 +1,57 @@
+# Compiling and using libpcap on Haiku
+
+Haiku R1/beta4 and earlier versions do not support packet capture on the
+loopback interface.  Using this version of libpcap, loopback capture works
+since Haiku revision hrev57585 and is expected to work in Haiku R1/beta5 when
+the latter becomes available.  Packet timestamping and filtering always occur
+in userland.  Wireless monitor mode is not supported.  The "any"
+pseudo-interface is not supported.
+[**pcap_set_buffer_size**](https://www.tcpdump.org/manpages/pcap_set_buffer_size.3pcap.html)(3PCAP)
+has no effect.
+[**pcap_setdirection**](https://www.tcpdump.org/manpages/pcap_setdirection.3pcap.html)(3PCAP)
+is not supported.
+[**pcap_inject**](https://www.tcpdump.org/manpages/pcap_inject.3pcap.html)(3PCAP)
+is not supported.
+
+The statistics reported by
+[**pcap_stats**](https://www.tcpdump.org/manpages/pcap_stats.3pcap.html)(3PCAP)
+on Haiku are as follows:
+* `ps_recv` is the number of packets successfully delivered by the kernel,
+  before libpcap applies a filter.
+* `ps_drop` is the number of packets rejected by the filter.
+* `ps_ifdrop` is the number of packets dropped by the network interface (as
+  seen via `SIOCGIFSTATS`) since the capture handle became active.
+
+## 64-bit x86 R1/beta4
+
+* Autoconf 2.71 works.
+* CMake 3.28.3 works.
+* GCC 13.2.0 works.
+* Clang 12.0.1 works with the latest llvm12_clang-12.0.1-5 version.
+* flex 2.6.4 works.
+* bison 3.8.2 works.
+
+The following command will install respective non-default packages:
+```
+pkgman install cmake llvm12_clang
+```
+
+For reference, the tests were done using a system installed from
+`haiku-r1beta4-x86_64-anyboot.iso`.
+
+## 32-bit x86 R1/beta4
+
+* Autoconf 2.71 works.
+* CMake 3.24.2 works.
+* GCC 11.2.0 works.
+* Clang does not work.
+* flex 2.6.4 works.
+* bison 3.0.5 works.
+
+The following command will install respective non-default packages:
+```
+pkgman install cmake_x86
+```
+
+For reference, the tests were done using a system installed from
+`haiku-r1beta4-x86_gcc2h-anyboot.iso`.
diff --git a/doc/README.hpux b/doc/README.hpux
index 4b3801b4..bf291f7a 100644
--- a/doc/README.hpux
+++ b/doc/README.hpux
@@ -155,7 +155,7 @@ promiscuous mode support.
 
 An additional note, from Jost Martin, for HP-UX 10.20:
 
-	Q: How do I get ethereral on HPUX to capture the _outgoing_ packets
+	Q: How do I get [Wireshark] on HPUX to capture the _outgoing_ packets
 	   of an interface
 	A: You need to get PHNE_20892,PHNE_20725 and PHCO_10947 (or
 	   newer, this is as of 4.4.00) and its dependencies.  Then you can
diff --git a/doc/README.Win32.md b/doc/README.windows.md
similarity index 100%
rename from doc/README.Win32.md
rename to doc/README.windows.md
diff --git a/etherent.c b/etherent.c
index 69da9a54..fd228b81 100644
--- a/etherent.c
+++ b/etherent.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 
@@ -33,6 +31,8 @@
 
 #include <pcap/namedb.h>
 
+#include "thread-local.h"
+
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
 #endif
@@ -87,7 +87,7 @@ pcap_next_etherent(FILE *fp)
 	u_char d;
 	char *bp;
 	size_t namesize;
-	static struct pcap_etherent e;
+	static thread_local struct pcap_etherent e;
 
 	memset((char *)&e, 0, sizeof(e));
 	for (;;) {
diff --git a/extract.h b/extract.h
index 33579b11..d31a40f3 100644
--- a/extract.h
+++ b/extract.h
@@ -229,7 +229,7 @@ EXTRACT_BE_S_8(const void *p)
  * quantities the hard way - fetch the bytes one at a time and
  * assemble them.
  *
- * XXX - ARM is a special case.  ARMv1 through ARMv5 didn't suppory
+ * XXX - ARM is a special case.  ARMv1 through ARMv5 didn't support
  * unaligned loads; ARMv6 and later support it *but* have a bit in
  * the system control register that the OS can set and that causes
  * unaligned loads to fault rather than succeeding.
diff --git a/fad-getad.c b/fad-getad.c
index ba8f9753..0df567c4 100644
--- a/fad-getad.c
+++ b/fad-getad.c
@@ -32,9 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -60,7 +58,7 @@
  * we end up including both the OS's <net/bpf.h> and our <pcap/bpf.h>,
  * and their definitions of some data structures collide.
  */
-#if (defined(linux) || defined(__Lynx__)) && defined(AF_PACKET)
+#if (defined(__linux__) || defined(__Lynx__)) && defined(AF_PACKET)
 # ifdef HAVE_NETPACKET_PACKET_H
 /* Linux distributions with newer glibc */
 #  include <netpacket/packet.h>
@@ -75,7 +73,7 @@
 #  include <linux/if_packet.h>
 # endif /* __Lynx__ */
 # endif /* HAVE_NETPACKET_PACKET_H */
-#endif /* (defined(linux) || defined(__Lynx__)) && defined(AF_PACKET) */
+#endif /* (defined(__linux__) || defined(__Lynx__)) && defined(AF_PACKET) */
 
 /*
  * This is fun.
@@ -99,6 +97,17 @@
  * but not in the final version).  On the latter systems, we explicitly
  * check the AF_ type to determine the length; we assume that on
  * all those systems we have "struct sockaddr_storage".
+ *
+ * OSes that use this file are:
+ * - FreeBSD (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - Haiku (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - Hurd (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - illumos (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)
+ * - Linux (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)
+ * - macOS (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - NetBSD (HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - OpenBSD (SA_LEN() is defined)
+ * - Solaris 11 (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)
  */
 #ifndef SA_LEN
 #ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
@@ -120,11 +129,16 @@ get_sa_len(struct sockaddr *addr)
 		return (sizeof (struct sockaddr_in6));
 #endif
 
-#if (defined(linux) || defined(__Lynx__)) && defined(AF_PACKET)
+#if (defined(__linux__) || defined(__Lynx__)) && defined(AF_PACKET)
 	case AF_PACKET:
 		return (sizeof (struct sockaddr_ll));
 #endif
 
+#ifdef AF_LINK
+	case AF_LINK:
+		return (sizeof (struct sockaddr_dl));
+#endif
+
 	default:
 		return (sizeof (struct sockaddr));
 	}
@@ -143,7 +157,7 @@ get_sa_len(struct sockaddr *addr)
  * could be opened.
  */
 int
-pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
+pcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
     int (*check_usable)(const char *), get_if_flags_func get_flags_func)
 {
 	struct ifaddrs *ifap, *ifa;
@@ -167,7 +181,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	 * those.
 	 */
 	if (getifaddrs(&ifap) != 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "getifaddrs");
 		return (-1);
 	}
@@ -263,7 +277,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		/*
 		 * Add information for this address to the list.
 		 */
-		if (add_addr_to_if(devlistp, ifa->ifa_name, ifa->ifa_flags,
+		if (pcapint_add_addr_to_if(devlistp, ifa->ifa_name, ifa->ifa_flags,
 		    get_flags_func,
 		    addr, addr_size, netmask, addr_size,
 		    broadaddr, broadaddr_size, dstaddr, dstaddr_size,
diff --git a/fad-gifc.c b/fad-gifc.c
index 8940876a..54834df8 100644
--- a/fad-gifc.c
+++ b/fad-gifc.c
@@ -32,9 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>
 #include <sys/ioctl.h>
@@ -87,6 +85,10 @@ struct rtentry;		/* declarations in <net/if.h> */
  * We assume that a UNIX that doesn't have "getifaddrs()" and doesn't have
  * SIOCGLIFCONF, but has SIOCGIFCONF, uses "struct sockaddr" for the
  * address in an entry returned by SIOCGIFCONF.
+ *
+ * OSes that use this file are:
+ * - AIX 7 (SA_LEN() is not defined, HAVE_STRUCT_SOCKADDR_SA_LEN is defined)
+ * - HP-UX 11 (HAVE_STRUCT_SOCKADDR_SA_LEN is not defined)
  */
 #ifndef SA_LEN
 #ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
@@ -132,7 +134,7 @@ struct rtentry;		/* declarations in <net/if.h> */
  * we already have that.
  */
 int
-pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
+pcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
     int (*check_usable)(const char *), get_if_flags_func get_flags_func)
 {
 	register int fd;
@@ -154,7 +156,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	 */
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket");
 		return (-1);
 	}
@@ -180,7 +182,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		}
 		buf = malloc(buf_size);
 		if (buf == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			(void)close(fd);
 			return (-1);
@@ -191,7 +193,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		memset(buf, 0, buf_size);
 		if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0
 		    && errno != EINVAL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGIFCONF");
 			(void)close(fd);
 			free(buf);
@@ -264,7 +266,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		if (ioctl(fd, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {
 			if (errno == ENXIO)
 				continue;
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGIFFLAGS: %.*s",
 			    (int)sizeof(ifrflags.ifr_name),
 			    ifrflags.ifr_name);
@@ -287,7 +289,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 				netmask = NULL;
 				netmask_size = 0;
 			} else {
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "SIOCGIFNETMASK: %.*s",
 				    (int)sizeof(ifrnetmask.ifr_name),
@@ -318,7 +320,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 					broadaddr = NULL;
 					broadaddr_size = 0;
 				} else {
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "SIOCGIFBRDADDR: %.*s",
 					    (int)sizeof(ifrbroadaddr.ifr_name),
@@ -357,7 +359,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 					dstaddr = NULL;
 					dstaddr_size = 0;
 				} else {
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "SIOCGIFDSTADDR: %.*s",
 					    (int)sizeof(ifrdstaddr.ifr_name),
@@ -409,7 +411,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		/*
 		 * Add information for this address to the list.
 		 */
-		if (add_addr_to_if(devlistp, ifrp->ifr_name,
+		if (pcapint_add_addr_to_if(devlistp, ifrp->ifr_name,
 		    ifrflags.ifr_flags, get_flags_func,
 		    &ifrp->ifr_addr, SA_LEN(&ifrp->ifr_addr),
 		    netmask, netmask_size, broadaddr, broadaddr_size,
diff --git a/fad-glifc.c b/fad-glifc.c
index 6b275eb3..28089d37 100644
--- a/fad-glifc.c
+++ b/fad-glifc.c
@@ -32,9 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>
 #include <sys/file.h>
@@ -63,6 +61,10 @@ struct rtentry;		/* declarations in <net/if.h> */
 #include "os-proto.h"
 #endif
 
+/*
+ * Only Solaris 10 uses this file.
+ */
+
 /*
  * Get a list of all interfaces that are up and that we can open.
  * Returns -1 on error, 0 otherwise.
@@ -74,7 +76,7 @@ struct rtentry;		/* declarations in <net/if.h> */
  * SIOCGLIFCONF rather than SIOCGIFCONF in order to get IPv6 addresses.)
  */
 int
-pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
+pcapint_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
     int (*check_usable)(const char *), get_if_flags_func get_flags_func)
 {
 	register int fd4, fd6, fd;
@@ -96,7 +98,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	 */
 	fd4 = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd4 < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket: AF_INET");
 		return (-1);
 	}
@@ -106,7 +108,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	 */
 	fd6 = socket(AF_INET6, SOCK_DGRAM, 0);
 	if (fd6 < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket: AF_INET6");
 		(void)close(fd4);
 		return (-1);
@@ -119,7 +121,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	ifn.lifn_flags = 0;
 	ifn.lifn_count = 0;
 	if (ioctl(fd4, SIOCGLIFNUM, (char *)&ifn) < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGLIFNUM");
 		(void)close(fd6);
 		(void)close(fd4);
@@ -132,7 +134,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	buf_size = ifn.lifn_count * sizeof (struct lifreq);
 	buf = malloc(buf_size);
 	if (buf == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		(void)close(fd6);
 		(void)close(fd4);
@@ -148,7 +150,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 	ifc.lifc_flags = 0;
 	memset(buf, 0, buf_size);
 	if (ioctl(fd4, SIOCGLIFCONF, (char *)&ifc) < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGLIFCONF");
 		(void)close(fd6);
 		(void)close(fd4);
@@ -197,7 +199,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		if (ioctl(fd, SIOCGLIFFLAGS, (char *)&ifrflags) < 0) {
 			if (errno == ENXIO)
 				continue;
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGLIFFLAGS: %.*s",
 			    (int)sizeof(ifrflags.lifr_name),
 			    ifrflags.lifr_name);
@@ -219,7 +221,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 				 */
 				netmask = NULL;
 			} else {
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "SIOCGLIFNETMASK: %.*s",
 				    (int)sizeof(ifrnetmask.lifr_name),
@@ -247,7 +249,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 					 */
 					broadaddr = NULL;
 				} else {
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "SIOCGLIFBRDADDR: %.*s",
 					    (int)sizeof(ifrbroadaddr.lifr_name),
@@ -282,7 +284,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 					 */
 					dstaddr = NULL;
 				} else {
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "SIOCGLIFDSTADDR: %.*s",
 					    (int)sizeof(ifrdstaddr.lifr_name),
@@ -326,7 +328,7 @@ pcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,
 		/*
 		 * Add information for this address to the list.
 		 */
-		if (add_addr_to_if(devlistp, ifrp->lifr_name,
+		if (pcapint_add_addr_to_if(devlistp, ifrp->lifr_name,
 		    ifrflags.lifr_flags, get_flags_func,
 		    (struct sockaddr *)&ifrp->lifr_addr,
 		    sizeof (struct sockaddr_storage),
diff --git a/fmtutils.c b/fmtutils.c
index 2d357624..a5a4fe62 100644
--- a/fmtutils.c
+++ b/fmtutils.c
@@ -35,9 +35,7 @@
  * Utilities for message formatting used both by libpcap and rpcapd.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 
@@ -62,19 +60,19 @@
  */
 #ifdef _WIN32
 /*
- * True if we shouold use UTF-8.
+ * True if we should use UTF-8.
  */
 static int use_utf_8;
 
 void
-pcap_fmt_set_encoding(unsigned int opts)
+pcapint_fmt_set_encoding(unsigned int opts)
 {
 	if (opts == PCAP_CHAR_ENC_UTF_8)
 		use_utf_8 = 1;
 }
 #else
 void
-pcap_fmt_set_encoding(unsigned int opts _U_)
+pcapint_fmt_set_encoding(unsigned int opts _U_)
 {
 	/*
 	 * Nothing to do here.
@@ -154,7 +152,7 @@ utf_16le_to_utf_8_truncated(const wchar_t *utf_16, char *utf_8,
 					uc = SURROGATE_VALUE(c, c2);
 				} else {
 					/*
-					 * Not a trailing surroage;
+					 * Not a trailing surrogate;
 					 * try to drop in a
 					 * REPLACEMENT CHARACTER.
 					 */
@@ -266,18 +264,18 @@ utf_16le_to_utf_8_truncated(const wchar_t *utf_16, char *utf_8,
  * errno, with a message for the errno after the formatted output.
  */
 void
-pcap_fmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
+pcapint_fmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
     const char *fmt, ...)
 {
 	va_list ap;
 
 	va_start(ap, fmt);
-	pcap_vfmt_errmsg_for_errno(errbuf, errbuflen, errnum, fmt, ap);
+	pcapint_vfmt_errmsg_for_errno(errbuf, errbuflen, errnum, fmt, ap);
 	va_end(ap);
 }
 
 void
-pcap_vfmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
+pcapint_vfmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
     const char *fmt, va_list ap)
 {
 	size_t msglen;
@@ -334,43 +332,10 @@ pcap_vfmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
 	 */
 	if (!use_utf_8)
 		utf_8_to_acp_truncated(errbuf);
-#elif defined(HAVE_GNU_STRERROR_R)
-	/*
-	 * We have a GNU-style strerror_r(), which is *not* guaranteed to
-	 * do anything to the buffer handed to it, and which returns a
-	 * pointer to the error string, which may or may not be in
-	 * the buffer.
-	 *
-	 * It is, however, guaranteed to succeed.
-	 */
-	char strerror_buf[PCAP_ERRBUF_SIZE];
-	char *errstring = strerror_r(errnum, strerror_buf, PCAP_ERRBUF_SIZE);
-	snprintf(p, errbuflen_remaining, "%s", errstring);
-#elif defined(HAVE_POSIX_STRERROR_R)
-	/*
-	 * We have a POSIX-style strerror_r(), which is guaranteed to fill
-	 * in the buffer, but is not guaranteed to succeed.
-	 */
-	int err = strerror_r(errnum, p, errbuflen_remaining);
-	if (err == EINVAL) {
-		/*
-		 * UNIX 03 says this isn't guaranteed to produce a
-		 * fallback error message.
-		 */
-		snprintf(p, errbuflen_remaining, "Unknown error: %d",
-		    errnum);
-	} else if (err == ERANGE) {
-		/*
-		 * UNIX 03 says this isn't guaranteed to produce a
-		 * fallback error message.
-		 */
-		snprintf(p, errbuflen_remaining,
-		    "Message for error %d is too long", errnum);
-	}
 #else
 	/*
-	 * We have neither _wcserror_s() nor strerror_r(), so we're
-	 * stuck with using pcap_strerror().
+	 * Either Windows without _wcserror_s() or not Windows.  Let pcap_strerror()
+	 * solve the non-UTF-16 part of this problem space.
 	 */
 	snprintf(p, errbuflen_remaining, "%s", pcap_strerror(errnum));
 #endif
@@ -382,18 +347,18 @@ pcap_vfmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,
  * Win32 error, with a message for the Win32 error after the formatted output.
  */
 void
-pcap_fmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,
+pcapint_fmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,
     const char *fmt, ...)
 {
 	va_list ap;
 
 	va_start(ap, fmt);
-	pcap_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errnum, fmt, ap);
+	pcapint_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errnum, fmt, ap);
 	va_end(ap);
 }
 
 void
-pcap_vfmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,
+pcapint_vfmt_errmsg_for_win32_err(char *errbuf, size_t errbuflen, DWORD errnum,
     const char *fmt, va_list ap)
 {
 	size_t msglen;
diff --git a/fmtutils.h b/fmtutils.h
index 4fa34486..d163e386 100644
--- a/fmtutils.h
+++ b/fmtutils.h
@@ -42,17 +42,17 @@
 extern "C" {
 #endif
 
-void	pcap_fmt_set_encoding(unsigned int);
+void	pcapint_fmt_set_encoding(unsigned int);
 
-void	pcap_fmt_errmsg_for_errno(char *, size_t, int,
+void	pcapint_fmt_errmsg_for_errno(char *, size_t, int,
     PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);
-void	pcap_vfmt_errmsg_for_errno(char *, size_t, int,
+void	pcapint_vfmt_errmsg_for_errno(char *, size_t, int,
     PCAP_FORMAT_STRING(const char *), va_list) PCAP_PRINTFLIKE(4, 0);
 
 #ifdef _WIN32
-void	pcap_fmt_errmsg_for_win32_err(char *, size_t, DWORD,
+void	pcapint_fmt_errmsg_for_win32_err(char *, size_t, DWORD,
     PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);
-void	pcap_vfmt_errmsg_for_win32_err(char *, size_t, DWORD,
+void	pcapint_vfmt_errmsg_for_win32_err(char *, size_t, DWORD,
     PCAP_FORMAT_STRING(const char *), va_list) PCAP_PRINTFLIKE(4, 0);
 #endif
 
diff --git a/ftmacros.h b/ftmacros.h
index 7975463b..a1488e12 100644
--- a/ftmacros.h
+++ b/ftmacros.h
@@ -64,7 +64,7 @@
   /*
    * We need this to get the versions of socket functions that
    * use socklen_t.  Define it only if it's not already defined,
-   * so we don't get redefiniton warnings.
+   * so we don't get redefinition warnings.
    */
   #ifndef _XOPEN_SOURCE_EXTENDED
     #define _XOPEN_SOURCE_EXTENDED
@@ -95,7 +95,7 @@
    *
    * Unfortunately, one thing it has to offer is a strerror_r()
    * that's not POSIX-compliant, but we deal with that in
-   * pcap_fmt_errmsg_for_errno().
+   * pcapint_fmt_errmsg_for_errno().
    *
    * We don't limit this to, for example, Linux and Cygwin, because
    * this might, for example, be GNU/HURD or one of Debian's kFreeBSD
diff --git a/gencode.c b/gencode.c
index 496e02f3..31c50a71 100644
--- a/gencode.c
+++ b/gencode.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #ifdef _WIN32
   #include <ws2tcpip.h>
@@ -67,7 +65,7 @@
 
 #include "scanner.h"
 
-#if defined(linux)
+#if defined(__linux__)
 #include <linux/types.h>
 #include <linux/if_packet.h>
 #include <linux/filter.h>
@@ -218,7 +216,7 @@ enum e_offrel {
 };
 
 /*
- * We divy out chunks of memory rather than call malloc each time so
+ * We divvy out chunks of memory rather than call malloc each time so
  * we don't have to worry about leaking memory.  It's probably
  * not a big deal if all this memory was wasted but if this ever
  * goes into a library that would probably not be a good idea.
@@ -670,7 +668,7 @@ sdup(compiler_state_t *cstate, const char *s)
 
 	if (cp == NULL)
 		return (NULL);
-	pcap_strlcpy(cp, s, n);
+	pcapint_strlcpy(cp, s, n);
 	return (cp);
 }
 
@@ -724,22 +722,23 @@ pcap_compile(pcap_t *p, struct bpf_program *program,
 	yyscan_t scanner = NULL;
 	volatile YY_BUFFER_STATE in_buffer = NULL;
 	u_int len;
-	int  rc;
+	int rc;
 
 	/*
 	 * If this pcap_t hasn't been activated, it doesn't have a
 	 * link-layer type, so we can't use it.
 	 */
 	if (!p->activated) {
-		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
+		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
 		    "not-yet-activated pcap_t passed to pcap_compile");
 		return (PCAP_ERROR);
 	}
 
 #ifdef _WIN32
-	if (!done)
+	if (!done) {
 		pcap_wsockinit();
-	done = 1;
+		done = 1;
+	}
 #endif
 
 #ifdef ENABLE_REMOTE
@@ -779,15 +778,18 @@ pcap_compile(pcap_t *p, struct bpf_program *program,
 
 	cstate.snaplen = pcap_snapshot(p);
 	if (cstate.snaplen == 0) {
-		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
+		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
 			 "snaplen of 0 rejects all packets");
 		rc = PCAP_ERROR;
 		goto quit;
 	}
 
-	if (pcap_lex_init(&scanner) != 0)
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+	if (pcap_lex_init(&scanner) != 0) {
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't initialize scanner");
+		rc = PCAP_ERROR;
+		goto quit;
+	}
 	in_buffer = pcap__scan_string(xbuf ? xbuf : "", scanner);
 
 	/*
@@ -871,7 +873,7 @@ quit:
 int
 pcap_compile_nopcap(int snaplen_arg, int linktype_arg,
 		    struct bpf_program *program,
-	     const char *buf, int optimize, bpf_u_int32 mask)
+		    const char *buf, int optimize, bpf_u_int32 mask)
 {
 	pcap_t *p;
 	int ret;
@@ -1707,15 +1709,15 @@ init_linktype(compiler_state_t *cstate, pcap_t *p)
 		 * For values in the range in which we've assigned new
 		 * DLT_ values, only raw "link[N:M]" filtering is supported.
 		 */
-		if (cstate->linktype >= DLT_MATCHING_MIN &&
-		    cstate->linktype <= DLT_MATCHING_MAX) {
+		if (cstate->linktype >= DLT_HIGH_MATCHING_MIN &&
+		    cstate->linktype <= DLT_HIGH_MATCHING_MAX) {
 			cstate->off_linktype.constant_part = OFFSET_NOT_SET;
 			cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
 			cstate->off_nl = OFFSET_NOT_SET;
 			cstate->off_nl_nosnap = OFFSET_NOT_SET;
 		} else {
 			bpf_set_error(cstate, "unknown data link type %d (min %d, max %d)",
-			    cstate->linktype, DLT_MATCHING_MIN, DLT_MATCHING_MAX);
+			    cstate->linktype, DLT_HIGH_MATCHING_MIN, DLT_HIGH_MATCHING_MAX);
 			return (-1);
 		}
 		break;
@@ -1834,7 +1836,7 @@ gen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
 		/*
 		 * Load the item at {offset of the link-layer payload} +
 		 * {offset, relative to the start of the link-layer
-		 * paylod, of the IPv4 header} + {length of the IPv4 header} +
+		 * payload, of the IPv4 header} + {length of the IPv4 header} +
 		 * {specified offset}.
 		 *
 		 * If the offset of the link-layer payload is variable,
@@ -1897,7 +1899,7 @@ gen_loadx_iphdrlen(compiler_state_t *cstate)
 	} else {
 		/*
 		 * The offset of the link-layer payload is a constant,
-		 * so no code was generated to load the (non-existent)
+		 * so no code was generated to load the (nonexistent)
 		 * variable part of that offset.
 		 *
 		 * This means we can use the 4*([k]&0xf) addressing
@@ -4087,7 +4089,16 @@ gen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,
 {
 	struct block *b0, *b1;
 	u_int offset;
-	uint32_t *a, *m;
+	/*
+	 * Code below needs to access four separate 32-bit parts of the 128-bit
+	 * IPv6 address and mask.  In some OSes this is as simple as using the
+	 * s6_addr32 pseudo-member of struct in6_addr, which contains a union of
+	 * 8-, 16- and 32-bit arrays.  In other OSes this is not the case, as
+	 * far as libpcap sees it.  Hence copy the data before use to avoid
+	 * potential unaligned memory access and the associated compiler
+	 * warnings (whether genuine or not).
+	 */
+	bpf_u_int32 a[4], m[4];
 
 	switch (dir) {
 
@@ -4141,8 +4152,8 @@ gen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,
 		/*NOTREACHED*/
 	}
 	/* this order is important */
-	a = (uint32_t *)addr;
-	m = (uint32_t *)mask;
+	memcpy(a, addr, sizeof(a));
+	memcpy(m, mask, sizeof(m));
 	b1 = gen_mcmp(cstate, OR_LINKPL, offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));
 	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));
 	gen_and(b0, b1);
@@ -5290,7 +5301,6 @@ gen_gateway(compiler_state_t *cstate, const u_char *eaddr,
 			 */
 			bpf_error(cstate,
 			    "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
-			break;
 		case DLT_IP_OVER_FC:
 			b0 = gen_ipfchostop(cstate, eaddr, Q_OR);
 			break;
@@ -6117,7 +6127,7 @@ gen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)
 	/*
 	 * To quote a comment in optimize.c:
 	 *
-	 * "These data structures are used in a Cocke and Shwarz style
+	 * "These data structures are used in a Cocke and Schwartz style
 	 * value numbering scheme.  Since the flowgraph is acyclic,
 	 * exit values can be propagated from a node's predecessors
 	 * provided it is uniquely defined."
@@ -6658,6 +6668,277 @@ gen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)
 	/*NOTREACHED*/
 }
 
+/*
+ * Convert a non-numeric name to a port number.
+ */
+static int
+nametoport(compiler_state_t *cstate, const char *name, int ipproto)
+{
+	struct addrinfo hints, *res, *ai;
+	int error;
+	struct sockaddr_in *in4;
+#ifdef INET6
+	struct sockaddr_in6 *in6;
+#endif
+	int port = -1;
+
+	/*
+	 * We check for both TCP and UDP in case there are
+	 * ambiguous entries.
+	 */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = (ipproto == IPPROTO_TCP) ? SOCK_STREAM : SOCK_DGRAM;
+	hints.ai_protocol = ipproto;
+	error = getaddrinfo(NULL, name, &hints, &res);
+	if (error != 0) {
+		switch (error) {
+
+		case EAI_NONAME:
+		case EAI_SERVICE:
+			/*
+			 * No such port.  Just return -1.
+			 */
+			break;
+
+#ifdef EAI_SYSTEM
+		case EAI_SYSTEM:
+			/*
+			 * We don't use strerror() because it's not
+			 * guaranteed to be thread-safe on all platforms
+			 * (probably because it might use a non-thread-local
+			 * buffer into which to format an error message
+			 * if the error code isn't one for which it has
+			 * a canned string; three cheers for C string
+			 * handling).
+			 */
+			bpf_set_error(cstate, "getaddrinfo(\"%s\" fails with system error: %d",
+			    name, errno);
+			port = -2;	/* a real error */
+			break;
+#endif
+
+		default:
+			/*
+			 * This is a real error, not just "there's
+			 * no such service name".
+			 *
+			 * We don't use gai_strerror() because it's not
+			 * guaranteed to be thread-safe on all platforms
+			 * (probably because it might use a non-thread-local
+			 * buffer into which to format an error message
+			 * if the error code isn't one for which it has
+			 * a canned string; three cheers for C string
+			 * handling).
+			 */
+			bpf_set_error(cstate, "getaddrinfo(\"%s\") fails with error: %d",
+			    name, error);
+			port = -2;	/* a real error */
+			break;
+		}
+	} else {
+		/*
+		 * OK, we found it.  Did it find anything?
+		 */
+		for (ai = res; ai != NULL; ai = ai->ai_next) {
+			/*
+			 * Does it have an address?
+			 */
+			if (ai->ai_addr != NULL) {
+				/*
+				 * Yes.  Get a port number; we're done.
+				 */
+				if (ai->ai_addr->sa_family == AF_INET) {
+					in4 = (struct sockaddr_in *)ai->ai_addr;
+					port = ntohs(in4->sin_port);
+					break;
+				}
+#ifdef INET6
+				if (ai->ai_addr->sa_family == AF_INET6) {
+					in6 = (struct sockaddr_in6 *)ai->ai_addr;
+					port = ntohs(in6->sin6_port);
+					break;
+				}
+#endif
+			}
+		}
+		freeaddrinfo(res);
+	}
+	return port;
+}
+
+/*
+ * Convert a string to a port number.
+ */
+static bpf_u_int32
+stringtoport(compiler_state_t *cstate, const char *string, size_t string_size,
+    int *proto)
+{
+	stoulen_ret ret;
+	char *cpy;
+	bpf_u_int32 val;
+	int tcp_port = -1;
+	int udp_port = -1;
+
+	/*
+	 * See if it's a number.
+	 */
+	ret = stoulen(string, string_size, &val, cstate);
+	switch (ret) {
+
+	case STOULEN_OK:
+		/* Unknown port type - it's just a number. */
+		*proto = PROTO_UNDEF;
+		break;
+
+	case STOULEN_NOT_OCTAL_NUMBER:
+	case STOULEN_NOT_HEX_NUMBER:
+	case STOULEN_NOT_DECIMAL_NUMBER:
+		/*
+		 * Not a valid number; try looking it up as a port.
+		 */
+		cpy = malloc(string_size + 1);	/* +1 for terminating '\0' */
+		memcpy(cpy, string, string_size);
+		cpy[string_size] = '\0';
+		tcp_port = nametoport(cstate, cpy, IPPROTO_TCP);
+		if (tcp_port == -2) {
+			/*
+			 * We got a hard error; the error string has
+			 * already been set.
+			 */
+			free(cpy);
+			longjmp(cstate->top_ctx, 1);
+			/*NOTREACHED*/
+		}
+		udp_port = nametoport(cstate, cpy, IPPROTO_UDP);
+		if (udp_port == -2) {
+			/*
+			 * We got a hard error; the error string has
+			 * already been set.
+			 */
+			free(cpy);
+			longjmp(cstate->top_ctx, 1);
+			/*NOTREACHED*/
+		}
+
+		/*
+		 * We need to check /etc/services for ambiguous entries.
+		 * If we find an ambiguous entry, and it has the
+		 * same port number, change the proto to PROTO_UNDEF
+		 * so both TCP and UDP will be checked.
+		 */
+		if (tcp_port >= 0) {
+			val = (bpf_u_int32)tcp_port;
+			*proto = IPPROTO_TCP;
+			if (udp_port >= 0) {
+				if (udp_port == tcp_port)
+					*proto = PROTO_UNDEF;
+#ifdef notdef
+				else
+					/* Can't handle ambiguous names that refer
+					   to different port numbers. */
+					warning("ambiguous port %s in /etc/services",
+						cpy);
+#endif
+			}
+			free(cpy);
+			break;
+		}
+		if (udp_port >= 0) {
+			val = (bpf_u_int32)udp_port;
+			*proto = IPPROTO_UDP;
+			free(cpy);
+			break;
+		}
+#if defined(ultrix) || defined(__osf__)
+		/* Special hack in case NFS isn't in /etc/services */
+		if (strcmp(cpy, "nfs") == 0) {
+			val = 2049;
+			*proto = PROTO_UNDEF;
+			free(cpy);
+			break;
+		}
+#endif
+		bpf_set_error(cstate, "'%s' is not a valid port", cpy);
+		free(cpy);
+		longjmp(cstate->top_ctx, 1);
+		/*NOTREACHED*/
+
+	case STOULEN_ERROR:
+		/* Error already set. */
+		longjmp(cstate->top_ctx, 1);
+		/*NOTREACHED*/
+
+	default:
+		/* Should not happen */
+		bpf_set_error(cstate, "stoulen returned %d - this should not happen", ret);
+		longjmp(cstate->top_ctx, 1);
+		/*NOTREACHED*/
+	}
+	return (val);
+}
+
+/*
+ * Convert a string in the form PPP-PPP, which correspond to ports, to
+ * a starting and ending port in a port range.
+ */
+static void
+stringtoportrange(compiler_state_t *cstate, const char *string,
+    bpf_u_int32 *port1, bpf_u_int32 *port2, int *proto)
+{
+	char *hyphen_off;
+	const char *first, *second;
+	size_t first_size, second_size;
+	int save_proto;
+
+	if ((hyphen_off = strchr(string, '-')) == NULL)
+		bpf_error(cstate, "port range '%s' contains no hyphen", string);
+
+	/*
+	 * Make sure there are no other hyphens.
+	 *
+	 * XXX - we support named ports, but there are some port names
+	 * in /etc/services that include hyphens, so this would rule
+	 * that out.
+	 */
+	if (strchr(hyphen_off + 1, '-') != NULL)
+		bpf_error(cstate, "port range '%s' contains more than one hyphen",
+		    string);
+
+	/*
+	 * Get the length of the first port.
+	 */
+	first = string;
+	first_size = hyphen_off - string;
+	if (first_size == 0) {
+		/* Range of "-port", which we don't support. */
+		bpf_error(cstate, "port range '%s' has no starting port", string);
+	}
+
+	/*
+	 * Try to convert it to a port.
+	 */
+	*port1 = stringtoport(cstate, first, first_size, proto);
+	save_proto = *proto;
+
+	/*
+	 * Get the length of the second port.
+	 */
+	second = hyphen_off + 1;
+	second_size = strlen(second);
+	if (second_size == 0) {
+		/* Range of "port-", which we don't support. */
+		bpf_error(cstate, "port range '%s' has no ending port", string);
+	}
+
+	/*
+	 * Try to convert it to a port.
+	 */
+	*port2 = stringtoport(cstate, second, second_size, proto);
+	if (*proto != save_proto)
+		*proto = PROTO_UNDEF;
+}
+
 struct block *
 gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
 {
@@ -6675,7 +6956,7 @@ gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
 #endif /*INET6*/
 	struct block *b, *tmp;
 	int port, real_proto;
-	int port1, port2;
+	bpf_u_int32 port1, port2;
 
 	/*
 	 * Catch errors reported by us and routines below us, and return NULL
@@ -6884,8 +7165,7 @@ gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
 		if (proto != Q_DEFAULT &&
 		    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)
 			bpf_error(cstate, "illegal qualifier of 'portrange'");
-		if (pcap_nametoportrange(name, &port1, &port2, &real_proto) == 0)
-			bpf_error(cstate, "unknown port in range '%s'", name);
+		stringtoportrange(cstate, name, &port1, &port2, &real_proto);
 		if (proto == Q_UDP) {
 			if (real_proto == IPPROTO_TCP)
 				bpf_error(cstate, "port in range '%s' is tcp", name);
@@ -6913,12 +7193,8 @@ gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
 				/* override PROTO_UNDEF */
 				real_proto = IPPROTO_SCTP;
 		}
-		if (port1 < 0)
-			bpf_error(cstate, "illegal port number %d < 0", port1);
 		if (port1 > 65535)
 			bpf_error(cstate, "illegal port number %d > 65535", port1);
-		if (port2 < 0)
-			bpf_error(cstate, "illegal port number %d < 0", port2);
 		if (port2 > 65535)
 			bpf_error(cstate, "illegal port number %d > 65535", port2);
 
@@ -7151,14 +7427,14 @@ gen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)
 
 #ifdef INET6
 struct block *
-gen_mcode6(compiler_state_t *cstate, const char *s1, const char *s2,
-    bpf_u_int32 masklen, struct qual q)
+gen_mcode6(compiler_state_t *cstate, const char *s, bpf_u_int32 masklen,
+    struct qual q)
 {
 	struct addrinfo *res;
 	struct in6_addr *addr;
 	struct in6_addr mask;
 	struct block *b;
-	uint32_t *a, *m;
+	bpf_u_int32 a[4], m[4]; /* Same as in gen_hostop6(). */
 
 	/*
 	 * Catch errors reported by us and routines below us, and return NULL
@@ -7167,19 +7443,16 @@ gen_mcode6(compiler_state_t *cstate, const char *s1, const char *s2,
 	if (setjmp(cstate->top_ctx))
 		return (NULL);
 
-	if (s2)
-		bpf_error(cstate, "no mask %s supported", s2);
-
-	res = pcap_nametoaddrinfo(s1);
+	res = pcap_nametoaddrinfo(s);
 	if (!res)
-		bpf_error(cstate, "invalid ip6 address %s", s1);
+		bpf_error(cstate, "invalid ip6 address %s", s);
 	cstate->ai = res;
 	if (res->ai_next)
-		bpf_error(cstate, "%s resolved to multiple address", s1);
+		bpf_error(cstate, "%s resolved to multiple address", s);
 	addr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
 
 	if (masklen > sizeof(mask.s6_addr) * 8)
-		bpf_error(cstate, "mask length must be <= %u", (unsigned int)(sizeof(mask.s6_addr) * 8));
+		bpf_error(cstate, "mask length must be <= %zu", sizeof(mask.s6_addr) * 8);
 	memset(&mask, 0, sizeof(mask));
 	memset(&mask.s6_addr, 0xff, masklen / 8);
 	if (masklen % 8) {
@@ -7187,11 +7460,11 @@ gen_mcode6(compiler_state_t *cstate, const char *s1, const char *s2,
 			(0xff << (8 - masklen % 8)) & 0xff;
 	}
 
-	a = (uint32_t *)addr;
-	m = (uint32_t *)&mask;
+	memcpy(a, addr, sizeof(a));
+	memcpy(m, &mask, sizeof(m));
 	if ((a[0] & ~m[0]) || (a[1] & ~m[1])
 	 || (a[2] & ~m[2]) || (a[3] & ~m[3])) {
-		bpf_error(cstate, "non-network bits set in \"%s/%d\"", s1, masklen);
+		bpf_error(cstate, "non-network bits set in \"%s/%d\"", s, masklen);
 	}
 
 	switch (q.addr) {
@@ -7524,58 +7797,54 @@ gen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,
 		inst->b = b;
 		break;
 	case Q_ICMPV6:
-        /*
-        * Do the computation only if the packet contains
-        * the protocol in question.
-        */
-        b = gen_proto_abbrev_internal(cstate, Q_IPV6);
-        if (inst->b) {
-            gen_and(inst->b, b);
-        }
-        inst->b = b;
-
-        /*
-        * Check if we have an icmp6 next header
-        */
-        b = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);
-        if (inst->b) {
-            gen_and(inst->b, b);
-        }
-        inst->b = b;
-
-
-        s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
-        /*
-        * If "s" is non-null, it has code to arrange that the
-        * X register contains the variable part of the offset
-        * of the link-layer payload.  Add to it the offset
-        * computed into the register specified by "index",
-        * and move that into the X register.  Otherwise, just
-        * load into the X register the offset computed into
-        * the register specified by "index".
-        */
-        if (s != NULL) {
-            sappend(s, xfer_to_a(cstate, inst));
-            sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
-            sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
-        } else {
-            s = xfer_to_x(cstate, inst);
-        }
+		/*
+		 * Do the computation only if the packet contains
+		 * the protocol in question.
+		 */
+		b = gen_proto_abbrev_internal(cstate, Q_IPV6);
+		if (inst->b)
+			gen_and(inst->b, b);
+		inst->b = b;
+
+		/*
+		 * Check if we have an icmp6 next header
+		 */
+		b = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);
+		if (inst->b)
+			gen_and(inst->b, b);
+		inst->b = b;
+
+		s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
+		/*
+		 * If "s" is non-null, it has code to arrange that the
+		 * X register contains the variable part of the offset
+		 * of the link-layer payload.  Add to it the offset
+		 * computed into the register specified by "index",
+		 * and move that into the X register.  Otherwise, just
+		 * load into the X register the offset computed into
+		 * the register specified by "index".
+		 */
+		if (s != NULL) {
+			sappend(s, xfer_to_a(cstate, inst));
+			sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
+			sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
+		} else
+			s = xfer_to_x(cstate, inst);
 
-        /*
-        * Load the item at the sum of the offset we've put in the
-        * X register, the offset of the start of the network
-        * layer header from the beginning of the link-layer
-        * payload, and the constant part of the offset of the
-        * start of the link-layer payload.
-        */
-        tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
-        tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;
+		/*
+		 * Load the item at the sum of the offset we've put in the
+		 * X register, the offset of the start of the network
+		 * layer header from the beginning of the link-layer
+		 * payload, and the constant part of the offset of the
+		 * start of the link-layer payload.
+		 */
+		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
+		tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;
 
-        sappend(s, tmp);
-        sappend(inst->s, s);
+		sappend(s, tmp);
+		sappend(inst->s, s);
 
-        break;
+		break;
 	}
 	inst->regno = regno;
 	s = new_stmt(cstate, BPF_ST);
@@ -8235,8 +8504,8 @@ gen_ifindex(compiler_state_t *cstate, int ifindex)
 		/* match packets on this interface */
 		b0 = gen_cmp(cstate, OR_LINKHDR, 4, BPF_W, ifindex);
 		break;
-        default:
-#if defined(linux)
+	default:
+#if defined(__linux__)
 		/*
 		 * This is Linux; we require PF_PACKET support.
 		 * If this is a *live* capture, we can look at
@@ -8247,17 +8516,16 @@ gen_ifindex(compiler_state_t *cstate, int ifindex)
 			/* We have a FILE *, so this is a savefile */
 			bpf_error(cstate, "ifindex not supported on %s when reading savefiles",
 			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
-			b0 = NULL;
 			/*NOTREACHED*/
 		}
 		/* match ifindex */
 		b0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_IFINDEX, BPF_W,
 		             ifindex);
-#else /* defined(linux) */
+#else /* defined(__linux__) */
 		bpf_error(cstate, "ifindex not supported on %s",
 		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
 		/*NOTREACHED*/
-#endif /* defined(linux) */
+#endif /* defined(__linux__) */
 	}
 	return (b0);
 }
@@ -8387,7 +8655,7 @@ gen_inbound(compiler_state_t *cstate, int dir)
 		 * with newer capture APIs, allowing it to be saved
 		 * in pcapng files.
 		 */
-#if defined(linux)
+#if defined(__linux__)
 		/*
 		 * This is Linux; we require PF_PACKET support.
 		 * If this is a *live* capture, we can look at
@@ -8407,11 +8675,11 @@ gen_inbound(compiler_state_t *cstate, int dir)
 			/* to filter on inbound traffic, invert the match */
 			gen_not(b0);
 		}
-#else /* defined(linux) */
+#else /* defined(__linux__) */
 		bpf_error(cstate, "inbound/outbound not supported on %s",
 		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
 		/*NOTREACHED*/
-#endif /* defined(linux) */
+#endif /* defined(__linux__) */
 	}
 	return (b0);
 }
@@ -8837,7 +9105,7 @@ gen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)
 
 	/* Jump to the test in b_vid. We need to jump one instruction before
 	 * the end of the b_vid block so that we only skip loading the TCI
-	 * from packet data and not the 'and' instruction extractging VID.
+	 * from packet data and not the 'and' instruction extracting VID.
 	 */
 	cnt = 0;
 	for (s2 = b_vid->stmts; s2; s2 = s2->next)
@@ -8977,7 +9245,7 @@ gen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)
 #endif
 			b0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,
 			    has_vlan_tag);
-                break;
+		break;
 
 	case DLT_IEEE802_11:
 	case DLT_PRISM_HEADER:
@@ -8992,7 +9260,7 @@ gen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)
 		/*NOTREACHED*/
 	}
 
-        cstate->vlan_stack_depth++;
+	cstate->vlan_stack_depth++;
 
 	return (b0);
 }
@@ -9018,38 +9286,38 @@ gen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,
 	if (setjmp(cstate->top_ctx))
 		return (NULL);
 
-        if (cstate->label_stack_depth > 0) {
-            /* just match the bottom-of-stack bit clear */
-            b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);
-        } else {
-            /*
-             * We're not in an MPLS stack yet, so check the link-layer
-             * type against MPLS.
-             */
-            switch (cstate->linktype) {
-
-            case DLT_C_HDLC: /* fall through */
-            case DLT_HDLC:
-            case DLT_EN10MB:
-            case DLT_NETANALYZER:
-            case DLT_NETANALYZER_TRANSPARENT:
-                    b0 = gen_linktype(cstate, ETHERTYPE_MPLS);
-                    break;
-
-            case DLT_PPP:
-                    b0 = gen_linktype(cstate, PPP_MPLS_UCAST);
-                    break;
-
-                    /* FIXME add other DLT_s ...
-                     * for Frame-Relay/and ATM this may get messy due to SNAP headers
-                     * leave it for now */
-
-            default:
-                    bpf_error(cstate, "no MPLS support for %s",
-                          pcap_datalink_val_to_description_or_dlt(cstate->linktype));
-                    /*NOTREACHED*/
-            }
-        }
+	if (cstate->label_stack_depth > 0) {
+		/* just match the bottom-of-stack bit clear */
+		b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);
+	} else {
+		/*
+		 * We're not in an MPLS stack yet, so check the link-layer
+		 * type against MPLS.
+		 */
+		switch (cstate->linktype) {
+
+		case DLT_C_HDLC: /* fall through */
+		case DLT_HDLC:
+		case DLT_EN10MB:
+		case DLT_NETANALYZER:
+		case DLT_NETANALYZER_TRANSPARENT:
+			b0 = gen_linktype(cstate, ETHERTYPE_MPLS);
+			break;
+
+		case DLT_PPP:
+			b0 = gen_linktype(cstate, PPP_MPLS_UCAST);
+			break;
+
+			/* FIXME add other DLT_s ...
+			 * for Frame-Relay/and ATM this may get messy due to SNAP headers
+			 * leave it for now */
+
+		default:
+			bpf_error(cstate, "no MPLS support for %s",
+			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
+			/*NOTREACHED*/
+		}
+	}
 
 	/* If a specific MPLS label is requested, check it */
 	if (has_label_num) {
@@ -9064,23 +9332,23 @@ gen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,
 		b0 = b1;
 	}
 
-        /*
-         * Change the offsets to point to the type and data fields within
-         * the MPLS packet.  Just increment the offsets, so that we
-         * can support a hierarchy, e.g. "mpls 100000 && mpls 1024" to
-         * capture packets with an outer label of 100000 and an inner
-         * label of 1024.
-         *
-         * Increment the MPLS stack depth as well; this indicates that
-         * we're checking MPLS-encapsulated headers, to make sure higher
-         * level code generators don't try to match against IP-related
-         * protocols such as Q_ARP, Q_RARP etc.
-         *
-         * XXX - this is a bit of a kludge.  See comments in gen_vlan().
-         */
-        cstate->off_nl_nosnap += 4;
-        cstate->off_nl += 4;
-        cstate->label_stack_depth++;
+	/*
+	 * Change the offsets to point to the type and data fields within
+	 * the MPLS packet.  Just increment the offsets, so that we
+	 * can support a hierarchy, e.g. "mpls 100000 && mpls 1024" to
+	 * capture packets with an outer label of 100000 and an inner
+	 * label of 1024.
+	 *
+	 * Increment the MPLS stack depth as well; this indicates that
+	 * we're checking MPLS-encapsulated headers, to make sure higher
+	 * level code generators don't try to match against IP-related
+	 * protocols such as Q_ARP, Q_RARP etc.
+	 *
+	 * XXX - this is a bit of a kludge.  See comments in gen_vlan().
+	 */
+	cstate->off_nl_nosnap += 4;
+	cstate->off_nl += 4;
+	cstate->label_stack_depth++;
 	return (b0);
 }
 
@@ -9795,8 +10063,8 @@ gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
 			bpf_error(cstate, "'sio' supported only on SS7");
 		/* sio coded on 1 byte so max value 255 */
 		if(jvalue > 255)
-		        bpf_error(cstate, "sio value %u too big; max value = 255",
-		            jvalue);
+			bpf_error(cstate, "sio value %u too big; max value = 255",
+			    jvalue);
 		b0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffffU,
 		    jtype, reverse, jvalue);
 		break;
@@ -9805,13 +10073,13 @@ gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
 		newoff_opc += 3;
 
 		/* FALLTHROUGH */
-        case M_OPC:
-	        if (cstate->off_opc == OFFSET_NOT_SET)
+	case M_OPC:
+		if (cstate->off_opc == OFFSET_NOT_SET)
 			bpf_error(cstate, "'opc' supported only on SS7");
 		/* opc coded on 14 bits so max value 16383 */
 		if (jvalue > 16383)
-		        bpf_error(cstate, "opc value %u too big; max value = 16383",
-		            jvalue);
+			bpf_error(cstate, "opc value %u too big; max value = 16383",
+			    jvalue);
 		/* the following instructions are made to convert jvalue
 		 * to the form used to write opc in an ss7 message*/
 		val1 = jvalue & 0x00003c00;
@@ -9830,12 +10098,12 @@ gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
 		/* FALLTHROUGH */
 
 	case M_DPC:
-	        if (cstate->off_dpc == OFFSET_NOT_SET)
+		if (cstate->off_dpc == OFFSET_NOT_SET)
 			bpf_error(cstate, "'dpc' supported only on SS7");
 		/* dpc coded on 14 bits so max value 16383 */
 		if (jvalue > 16383)
-		        bpf_error(cstate, "dpc value %u too big; max value = 16383",
-		            jvalue);
+			bpf_error(cstate, "dpc value %u too big; max value = 16383",
+			    jvalue);
 		/* the following instructions are made to convert jvalue
 		 * to the forme used to write dpc in an ss7 message*/
 		val1 = jvalue & 0x000000ff;
@@ -9852,12 +10120,12 @@ gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
 		/* FALLTHROUGH */
 
 	case M_SLS:
-	        if (cstate->off_sls == OFFSET_NOT_SET)
+		if (cstate->off_sls == OFFSET_NOT_SET)
 			bpf_error(cstate, "'sls' supported only on SS7");
 		/* sls coded on 4 bits so max value 15 */
 		if (jvalue > 15)
-		         bpf_error(cstate, "sls value %u too big; max value = 15",
-		             jvalue);
+			 bpf_error(cstate, "sls value %u too big; max value = 15",
+			     jvalue);
 		/* the following instruction is made to convert jvalue
 		 * to the forme used to write sls in an ss7 message*/
 		jvalue = jvalue << 4;
diff --git a/gencode.h b/gencode.h
index 93ca5216..b8296ab2 100644
--- a/gencode.h
+++ b/gencode.h
@@ -327,8 +327,8 @@ struct block *gen_acode(compiler_state_t *, const char *, struct qual);
 struct block *gen_mcode(compiler_state_t *, const char *, const char *,
     bpf_u_int32, struct qual);
 #ifdef INET6
-struct block *gen_mcode6(compiler_state_t *, const char *, const char *,
-    bpf_u_int32, struct qual);
+struct block *gen_mcode6(compiler_state_t *, const char *, bpf_u_int32,
+    struct qual);
 #endif
 struct block *gen_ncode(compiler_state_t *, const char *, bpf_u_int32,
     struct qual);
diff --git a/grammar.c b/grammar.c
index c5c0976d..d91f8d7d 100644
--- a/grammar.c
+++ b/grammar.c
@@ -96,9 +96,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
@@ -139,21 +137,31 @@ struct rtentry;
 #include "os-proto.h"
 #endif
 
-#ifdef YYBYACC
+/*
+ * Work around some bugs in Berkeley YACC prior to the 2017-07-09
+ * release.
+ *
+ * The 2005-05-05 release was the first one to define YYPATCH, so
+ * we treat any release that either 1) doesn't define YYPATCH or
+ * 2) defines it to a value < 20170709 as being buggy.
+ */
+#if defined(YYBYACC) && (!defined(YYPATCH) || YYPATCH < 20170709)
 /*
  * Both Berkeley YACC and Bison define yydebug (under whatever name
  * it has) as a global, but Bison does so only if YYDEBUG is defined.
- * Berkeley YACC define it even if YYDEBUG isn't defined; declare it
- * here to suppress a warning.
+ * Berkeley YACC, prior to the 2017-07-09 release, defines it even if
+ * YYDEBUG isn't defined; declare it here to suppress a warning.  The
+ * 2017-07-09 release fixes that.
  */
 #if !defined(YYDEBUG)
 extern int yydebug;
 #endif
 
 /*
- * In Berkeley YACC, yynerrs (under whatever name it has) is global,
- * even if it's building a reentrant parser.  In Bison, it's local
- * in reentrant parsers.
+ * In Berkeley YACC, prior to the 2017-07-09 release, yynerrs (under
+ * whatever name it has) is global, even if it's building a reentrant
+ * parser.  In Bison, and in the Berkeley YACC 2017-07-09 release and
+ * later, it's local in reentrant parsers.
  *
  * Declare it to squelch a warning.
  */
@@ -261,7 +269,7 @@ str2tok(const char *str, const struct tok *toks)
 	int i;
 
 	for (i = 0; toks[i].s != NULL; i++) {
-		if (pcap_strcasecmp(toks[i].s, str) == 0) {
+		if (pcapint_strcasecmp(toks[i].s, str) == 0) {
 			/*
 			 * Just in case somebody is using this to
 			 * generate values of -1/0xFFFFFFFF.
@@ -374,7 +382,7 @@ pfaction_to_num(compiler_state_t *cstate, const char *action)
 
 DIAG_OFF_BISON_BYACC
 
-#line 378 "grammar.c"
+#line 386 "grammar.c"
 
 # ifndef YY_CAST
 #  ifdef __cplusplus
@@ -987,29 +995,29 @@ static const yytype_uint8 yytranslate[] =
 /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_int16 yyrline[] =
 {
-       0,   423,   423,   427,   429,   431,   432,   433,   434,   435,
-     437,   439,   441,   442,   444,   446,   447,   449,   451,   470,
-     481,   492,   493,   494,   496,   498,   500,   501,   502,   504,
-     506,   508,   509,   511,   512,   513,   514,   515,   523,   525,
-     526,   527,   528,   530,   532,   533,   534,   535,   536,   537,
-     540,   541,   544,   545,   546,   547,   548,   549,   550,   551,
-     552,   553,   554,   555,   558,   559,   560,   561,   564,   566,
-     567,   568,   569,   570,   571,   572,   573,   574,   575,   576,
-     577,   578,   579,   580,   581,   582,   583,   584,   585,   586,
-     587,   588,   589,   590,   591,   592,   593,   594,   595,   596,
-     597,   598,   599,   600,   601,   602,   603,   604,   606,   607,
-     608,   609,   610,   611,   612,   613,   614,   615,   616,   617,
-     618,   619,   620,   621,   622,   623,   624,   625,   628,   629,
-     630,   631,   632,   633,   636,   641,   644,   648,   651,   657,
-     666,   672,   695,   712,   713,   737,   740,   741,   757,   758,
-     761,   764,   765,   766,   768,   769,   770,   772,   773,   775,
-     776,   777,   778,   779,   780,   781,   782,   783,   784,   785,
-     786,   787,   788,   789,   791,   792,   793,   794,   795,   797,
-     798,   800,   801,   802,   803,   804,   805,   806,   808,   809,
-     810,   811,   814,   815,   817,   818,   819,   820,   822,   829,
-     830,   833,   834,   835,   836,   837,   838,   841,   842,   843,
-     844,   845,   846,   847,   848,   850,   851,   852,   853,   855,
-     868,   869
+       0,   431,   431,   443,   445,   447,   448,   449,   450,   451,
+     453,   455,   457,   458,   460,   462,   463,   482,   501,   520,
+     545,   570,   571,   572,   574,   576,   578,   579,   580,   582,
+     584,   586,   587,   589,   590,   591,   592,   593,   601,   603,
+     604,   605,   606,   608,   610,   611,   612,   613,   614,   615,
+     618,   619,   622,   623,   624,   625,   626,   627,   628,   629,
+     630,   631,   632,   633,   636,   637,   638,   639,   642,   644,
+     645,   646,   647,   648,   649,   650,   651,   652,   653,   654,
+     655,   656,   657,   658,   659,   660,   661,   662,   663,   664,
+     665,   666,   667,   668,   669,   670,   671,   672,   673,   674,
+     675,   676,   677,   678,   679,   680,   681,   682,   684,   685,
+     686,   687,   688,   689,   690,   691,   692,   693,   694,   695,
+     696,   697,   698,   699,   700,   701,   702,   703,   706,   707,
+     708,   709,   710,   711,   714,   719,   722,   726,   729,   735,
+     744,   750,   773,   790,   791,   815,   818,   819,   835,   836,
+     839,   842,   843,   844,   846,   847,   848,   850,   851,   853,
+     854,   855,   856,   857,   858,   859,   860,   861,   862,   863,
+     864,   865,   866,   867,   869,   870,   871,   872,   873,   875,
+     876,   878,   879,   880,   881,   882,   883,   884,   886,   887,
+     888,   889,   892,   893,   895,   896,   897,   898,   900,   907,
+     908,   911,   912,   913,   914,   915,   916,   919,   920,   921,
+     922,   923,   924,   925,   926,   928,   929,   930,   931,   933,
+     946,   947
 };
 #endif
 
@@ -1898,225 +1906,295 @@ yyreduce:
   switch (yyn)
     {
   case 2: /* prog: null expr  */
-#line 424 "grammar.y"
+#line 432 "grammar.y"
 {
+	/*
+	 * I'm not sure we have a reason to use yynerrs, but it's
+	 * declared, and incremented, whether we need it or not,
+	 * which means that Clang 15 will give a "used but not
+	 * set" warning.  This should suppress the warning for
+	 * yynerrs without suppressing it for other variables.
+	 */
+	(void) yynerrs;
 	CHECK_INT_VAL(finish_parse(cstate, (yyvsp[0].blk).b));
 }
-#line 1906 "grammar.c"
+#line 1922 "grammar.c"
     break;
 
   case 4: /* null: %empty  */
-#line 429 "grammar.y"
+#line 445 "grammar.y"
                                 { (yyval.blk).q = qerr; }
-#line 1912 "grammar.c"
+#line 1928 "grammar.c"
     break;
 
   case 6: /* expr: expr and term  */
-#line 432 "grammar.y"
+#line 448 "grammar.y"
                                 { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 1918 "grammar.c"
+#line 1934 "grammar.c"
     break;
 
   case 7: /* expr: expr and id  */
-#line 433 "grammar.y"
+#line 449 "grammar.y"
                                 { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 1924 "grammar.c"
+#line 1940 "grammar.c"
     break;
 
   case 8: /* expr: expr or term  */
-#line 434 "grammar.y"
+#line 450 "grammar.y"
                                 { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 1930 "grammar.c"
+#line 1946 "grammar.c"
     break;
 
   case 9: /* expr: expr or id  */
-#line 435 "grammar.y"
+#line 451 "grammar.y"
                                 { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 1936 "grammar.c"
+#line 1952 "grammar.c"
     break;
 
   case 10: /* and: AND  */
-#line 437 "grammar.y"
+#line 453 "grammar.y"
                                 { (yyval.blk) = (yyvsp[-1].blk); }
-#line 1942 "grammar.c"
+#line 1958 "grammar.c"
     break;
 
   case 11: /* or: OR  */
-#line 439 "grammar.y"
+#line 455 "grammar.y"
                                 { (yyval.blk) = (yyvsp[-1].blk); }
-#line 1948 "grammar.c"
+#line 1964 "grammar.c"
     break;
 
   case 13: /* id: pnum  */
-#line 442 "grammar.y"
+#line 458 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, NULL, (yyvsp[0].h),
 						   (yyval.blk).q = (yyvsp[-1].blk).q))); }
-#line 1955 "grammar.c"
+#line 1971 "grammar.c"
     break;
 
   case 14: /* id: paren pid ')'  */
-#line 444 "grammar.y"
+#line 460 "grammar.y"
                                 { (yyval.blk) = (yyvsp[-1].blk); }
-#line 1961 "grammar.c"
+#line 1977 "grammar.c"
     break;
 
   case 15: /* nid: ID  */
-#line 446 "grammar.y"
+#line 462 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_scode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
-#line 1967 "grammar.c"
+#line 1983 "grammar.c"
     break;
 
   case 16: /* nid: HID '/' NUM  */
-#line 447 "grammar.y"
-                                { CHECK_PTR_VAL((yyvsp[-2].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), NULL, (yyvsp[0].h),
-				    (yyval.blk).q = (yyvsp[-3].blk).q))); }
-#line 1974 "grammar.c"
+#line 463 "grammar.y"
+                                {
+				  CHECK_PTR_VAL((yyvsp[-2].s));
+				  /* Check whether HID/NUM is being used when appropriate */
+				  (yyval.blk).q = (yyvsp[-3].blk).q;
+				  if ((yyval.blk).q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), NULL, (yyvsp[0].h), (yyval.blk).q)));
+				}
+#line 2007 "grammar.c"
     break;
 
   case 17: /* nid: HID NETMASK HID  */
-#line 449 "grammar.y"
-                                { CHECK_PTR_VAL((yyvsp[-2].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), (yyvsp[0].s), 0,
-				    (yyval.blk).q = (yyvsp[-3].blk).q))); }
-#line 1981 "grammar.c"
+#line 482 "grammar.y"
+                                {
+				  CHECK_PTR_VAL((yyvsp[-2].s));
+				  /* Check whether HID mask HID is being used when appropriate */
+				  (yyval.blk).q = (yyvsp[-3].blk).q;
+				  if ((yyval.blk).q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and netmask");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), (yyvsp[0].s), 0, (yyval.blk).q)));
+				}
+#line 2031 "grammar.c"
     break;
 
   case 18: /* nid: HID  */
-#line 451 "grammar.y"
+#line 501 "grammar.y"
                                 {
 				  CHECK_PTR_VAL((yyvsp[0].s));
-				  /* Decide how to parse HID based on proto */
+				  /* Check whether HID is being used when appropriate */
 				  (yyval.blk).q = (yyvsp[-1].blk).q;
 				  if ((yyval.blk).q.addr == Q_PORT) {
-					bpf_set_error(cstate, "'port' modifier applied to ip host");
+					bpf_set_error(cstate, "'port' modifier applied to IP address");
 					YYABORT;
 				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
-					bpf_set_error(cstate, "'portrange' modifier applied to ip host");
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
 					YYABORT;
 				  } else if ((yyval.blk).q.addr == Q_PROTO) {
-					bpf_set_error(cstate, "'proto' modifier applied to ip host");
+					bpf_set_error(cstate, "'proto' modifier applied to IP address");
 					YYABORT;
 				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
-					bpf_set_error(cstate, "'protochain' modifier applied to ip host");
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
 					YYABORT;
 				  }
 				  CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, (yyvsp[0].s), 0, (yyval.blk).q)));
 				}
-#line 2005 "grammar.c"
+#line 2055 "grammar.c"
     break;
 
   case 19: /* nid: HID6 '/' NUM  */
-#line 470 "grammar.y"
+#line 520 "grammar.y"
                                 {
 				  CHECK_PTR_VAL((yyvsp[-2].s));
 #ifdef INET6
-				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[-2].s), NULL, (yyvsp[0].h),
-				    (yyval.blk).q = (yyvsp[-3].blk).q)));
+				  /* Check whether HID6/NUM is being used when appropriate */
+				  (yyval.blk).q = (yyvsp[-3].blk).q;
+				  if ((yyval.blk).q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length ");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[-2].s), (yyvsp[0].h), (yyval.blk).q)));
 #else
-				  bpf_set_error(cstate, "'ip6addr/prefixlen' not supported "
+				  bpf_set_error(cstate, "IPv6 addresses not supported "
 					"in this configuration");
 				  YYABORT;
 #endif /*INET6*/
 				}
-#line 2021 "grammar.c"
+#line 2085 "grammar.c"
     break;
 
   case 20: /* nid: HID6  */
-#line 481 "grammar.y"
+#line 545 "grammar.y"
                                 {
 				  CHECK_PTR_VAL((yyvsp[0].s));
 #ifdef INET6
-				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[0].s), 0, 128,
-				    (yyval.blk).q = (yyvsp[-1].blk).q)));
+				  /* Check whether HID6 is being used when appropriate */
+				  (yyval.blk).q = (yyvsp[-1].blk).q;
+				  if ((yyval.blk).q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to 'ip6addr/prefixlen");
+					YYABORT;
+				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[0].s), 128, (yyval.blk).q)));
 #else
-				  bpf_set_error(cstate, "'ip6addr' not supported "
+				  bpf_set_error(cstate, "IPv6 addresses not supported "
 					"in this configuration");
 				  YYABORT;
 #endif /*INET6*/
 				}
-#line 2037 "grammar.c"
+#line 2115 "grammar.c"
     break;
 
   case 21: /* nid: EID  */
-#line 492 "grammar.y"
+#line 570 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_ecode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
-#line 2043 "grammar.c"
+#line 2121 "grammar.c"
     break;
 
   case 22: /* nid: AID  */
-#line 493 "grammar.y"
+#line 571 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_acode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
-#line 2049 "grammar.c"
+#line 2127 "grammar.c"
     break;
 
   case 23: /* nid: not id  */
-#line 494 "grammar.y"
+#line 572 "grammar.y"
                                 { gen_not((yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 2055 "grammar.c"
+#line 2133 "grammar.c"
     break;
 
   case 24: /* not: '!'  */
-#line 496 "grammar.y"
+#line 574 "grammar.y"
                                 { (yyval.blk) = (yyvsp[-1].blk); }
-#line 2061 "grammar.c"
+#line 2139 "grammar.c"
     break;
 
   case 25: /* paren: '('  */
-#line 498 "grammar.y"
+#line 576 "grammar.y"
                                 { (yyval.blk) = (yyvsp[-1].blk); }
-#line 2067 "grammar.c"
+#line 2145 "grammar.c"
     break;
 
   case 27: /* pid: qid and id  */
-#line 501 "grammar.y"
+#line 579 "grammar.y"
                                 { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 2073 "grammar.c"
+#line 2151 "grammar.c"
     break;
 
   case 28: /* pid: qid or id  */
-#line 502 "grammar.y"
+#line 580 "grammar.y"
                                 { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 2079 "grammar.c"
+#line 2157 "grammar.c"
     break;
 
   case 29: /* qid: pnum  */
-#line 504 "grammar.y"
+#line 582 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, NULL, (yyvsp[0].h),
 						   (yyval.blk).q = (yyvsp[-1].blk).q))); }
-#line 2086 "grammar.c"
+#line 2164 "grammar.c"
     break;
 
   case 32: /* term: not term  */
-#line 509 "grammar.y"
+#line 587 "grammar.y"
                                 { gen_not((yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 2092 "grammar.c"
+#line 2170 "grammar.c"
     break;
 
   case 33: /* head: pqual dqual aqual  */
-#line 511 "grammar.y"
+#line 589 "grammar.y"
                                 { QSET((yyval.blk).q, (yyvsp[-2].i), (yyvsp[-1].i), (yyvsp[0].i)); }
-#line 2098 "grammar.c"
+#line 2176 "grammar.c"
     break;
 
   case 34: /* head: pqual dqual  */
-#line 512 "grammar.y"
+#line 590 "grammar.y"
                                 { QSET((yyval.blk).q, (yyvsp[-1].i), (yyvsp[0].i), Q_DEFAULT); }
-#line 2104 "grammar.c"
+#line 2182 "grammar.c"
     break;
 
   case 35: /* head: pqual aqual  */
-#line 513 "grammar.y"
+#line 591 "grammar.y"
                                 { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, (yyvsp[0].i)); }
-#line 2110 "grammar.c"
+#line 2188 "grammar.c"
     break;
 
   case 36: /* head: pqual PROTO  */
-#line 514 "grammar.y"
+#line 592 "grammar.y"
                                 { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, Q_PROTO); }
-#line 2116 "grammar.c"
+#line 2194 "grammar.c"
     break;
 
   case 37: /* head: pqual PROTOCHAIN  */
-#line 515 "grammar.y"
+#line 593 "grammar.y"
                                 {
 #ifdef NO_PROTOCHAIN
 				  bpf_set_error(cstate, "protochain not supported");
@@ -2125,626 +2203,626 @@ yyreduce:
 				  QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, Q_PROTOCHAIN);
 #endif
 				}
-#line 2129 "grammar.c"
+#line 2207 "grammar.c"
     break;
 
   case 38: /* head: pqual ndaqual  */
-#line 523 "grammar.y"
+#line 601 "grammar.y"
                                 { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, (yyvsp[0].i)); }
-#line 2135 "grammar.c"
+#line 2213 "grammar.c"
     break;
 
   case 39: /* rterm: head id  */
-#line 525 "grammar.y"
+#line 603 "grammar.y"
                                 { (yyval.blk) = (yyvsp[0].blk); }
-#line 2141 "grammar.c"
+#line 2219 "grammar.c"
     break;
 
   case 40: /* rterm: paren expr ')'  */
-#line 526 "grammar.y"
+#line 604 "grammar.y"
                                 { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = (yyvsp[-2].blk).q; }
-#line 2147 "grammar.c"
+#line 2225 "grammar.c"
     break;
 
   case 41: /* rterm: pname  */
-#line 527 "grammar.y"
+#line 605 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_proto_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
-#line 2153 "grammar.c"
+#line 2231 "grammar.c"
     break;
 
   case 42: /* rterm: arth relop arth  */
-#line 528 "grammar.y"
+#line 606 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_relation(cstate, (yyvsp[-1].i), (yyvsp[-2].a), (yyvsp[0].a), 0)));
 				  (yyval.blk).q = qerr; }
-#line 2160 "grammar.c"
+#line 2238 "grammar.c"
     break;
 
   case 43: /* rterm: arth irelop arth  */
-#line 530 "grammar.y"
+#line 608 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_relation(cstate, (yyvsp[-1].i), (yyvsp[-2].a), (yyvsp[0].a), 1)));
 				  (yyval.blk).q = qerr; }
-#line 2167 "grammar.c"
+#line 2245 "grammar.c"
     break;
 
   case 44: /* rterm: other  */
-#line 532 "grammar.y"
+#line 610 "grammar.y"
                                 { (yyval.blk).b = (yyvsp[0].rblk); (yyval.blk).q = qerr; }
-#line 2173 "grammar.c"
+#line 2251 "grammar.c"
     break;
 
   case 45: /* rterm: atmtype  */
-#line 533 "grammar.y"
+#line 611 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_atmtype_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
-#line 2179 "grammar.c"
+#line 2257 "grammar.c"
     break;
 
   case 46: /* rterm: atmmultitype  */
-#line 534 "grammar.y"
+#line 612 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_atmmulti_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
-#line 2185 "grammar.c"
+#line 2263 "grammar.c"
     break;
 
   case 47: /* rterm: atmfield atmvalue  */
-#line 535 "grammar.y"
+#line 613 "grammar.y"
                                 { (yyval.blk).b = (yyvsp[0].blk).b; (yyval.blk).q = qerr; }
-#line 2191 "grammar.c"
+#line 2269 "grammar.c"
     break;
 
   case 48: /* rterm: mtp2type  */
-#line 536 "grammar.y"
+#line 614 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp2type_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
-#line 2197 "grammar.c"
+#line 2275 "grammar.c"
     break;
 
   case 49: /* rterm: mtp3field mtp3value  */
-#line 537 "grammar.y"
+#line 615 "grammar.y"
                                 { (yyval.blk).b = (yyvsp[0].blk).b; (yyval.blk).q = qerr; }
-#line 2203 "grammar.c"
+#line 2281 "grammar.c"
     break;
 
   case 51: /* pqual: %empty  */
-#line 541 "grammar.y"
+#line 619 "grammar.y"
                                 { (yyval.i) = Q_DEFAULT; }
-#line 2209 "grammar.c"
+#line 2287 "grammar.c"
     break;
 
   case 52: /* dqual: SRC  */
-#line 544 "grammar.y"
+#line 622 "grammar.y"
                                 { (yyval.i) = Q_SRC; }
-#line 2215 "grammar.c"
+#line 2293 "grammar.c"
     break;
 
   case 53: /* dqual: DST  */
-#line 545 "grammar.y"
+#line 623 "grammar.y"
                                 { (yyval.i) = Q_DST; }
-#line 2221 "grammar.c"
+#line 2299 "grammar.c"
     break;
 
   case 54: /* dqual: SRC OR DST  */
-#line 546 "grammar.y"
+#line 624 "grammar.y"
                                 { (yyval.i) = Q_OR; }
-#line 2227 "grammar.c"
+#line 2305 "grammar.c"
     break;
 
   case 55: /* dqual: DST OR SRC  */
-#line 547 "grammar.y"
+#line 625 "grammar.y"
                                 { (yyval.i) = Q_OR; }
-#line 2233 "grammar.c"
+#line 2311 "grammar.c"
     break;
 
   case 56: /* dqual: SRC AND DST  */
-#line 548 "grammar.y"
+#line 626 "grammar.y"
                                 { (yyval.i) = Q_AND; }
-#line 2239 "grammar.c"
+#line 2317 "grammar.c"
     break;
 
   case 57: /* dqual: DST AND SRC  */
-#line 549 "grammar.y"
+#line 627 "grammar.y"
                                 { (yyval.i) = Q_AND; }
-#line 2245 "grammar.c"
+#line 2323 "grammar.c"
     break;
 
   case 58: /* dqual: ADDR1  */
-#line 550 "grammar.y"
+#line 628 "grammar.y"
                                 { (yyval.i) = Q_ADDR1; }
-#line 2251 "grammar.c"
+#line 2329 "grammar.c"
     break;
 
   case 59: /* dqual: ADDR2  */
-#line 551 "grammar.y"
+#line 629 "grammar.y"
                                 { (yyval.i) = Q_ADDR2; }
-#line 2257 "grammar.c"
+#line 2335 "grammar.c"
     break;
 
   case 60: /* dqual: ADDR3  */
-#line 552 "grammar.y"
+#line 630 "grammar.y"
                                 { (yyval.i) = Q_ADDR3; }
-#line 2263 "grammar.c"
+#line 2341 "grammar.c"
     break;
 
   case 61: /* dqual: ADDR4  */
-#line 553 "grammar.y"
+#line 631 "grammar.y"
                                 { (yyval.i) = Q_ADDR4; }
-#line 2269 "grammar.c"
+#line 2347 "grammar.c"
     break;
 
   case 62: /* dqual: RA  */
-#line 554 "grammar.y"
+#line 632 "grammar.y"
                                 { (yyval.i) = Q_RA; }
-#line 2275 "grammar.c"
+#line 2353 "grammar.c"
     break;
 
   case 63: /* dqual: TA  */
-#line 555 "grammar.y"
+#line 633 "grammar.y"
                                 { (yyval.i) = Q_TA; }
-#line 2281 "grammar.c"
+#line 2359 "grammar.c"
     break;
 
   case 64: /* aqual: HOST  */
-#line 558 "grammar.y"
+#line 636 "grammar.y"
                                 { (yyval.i) = Q_HOST; }
-#line 2287 "grammar.c"
+#line 2365 "grammar.c"
     break;
 
   case 65: /* aqual: NET  */
-#line 559 "grammar.y"
+#line 637 "grammar.y"
                                 { (yyval.i) = Q_NET; }
-#line 2293 "grammar.c"
+#line 2371 "grammar.c"
     break;
 
   case 66: /* aqual: PORT  */
-#line 560 "grammar.y"
+#line 638 "grammar.y"
                                 { (yyval.i) = Q_PORT; }
-#line 2299 "grammar.c"
+#line 2377 "grammar.c"
     break;
 
   case 67: /* aqual: PORTRANGE  */
-#line 561 "grammar.y"
+#line 639 "grammar.y"
                                 { (yyval.i) = Q_PORTRANGE; }
-#line 2305 "grammar.c"
+#line 2383 "grammar.c"
     break;
 
   case 68: /* ndaqual: GATEWAY  */
-#line 564 "grammar.y"
+#line 642 "grammar.y"
                                 { (yyval.i) = Q_GATEWAY; }
-#line 2311 "grammar.c"
+#line 2389 "grammar.c"
     break;
 
   case 69: /* pname: LINK  */
-#line 566 "grammar.y"
+#line 644 "grammar.y"
                                 { (yyval.i) = Q_LINK; }
-#line 2317 "grammar.c"
+#line 2395 "grammar.c"
     break;
 
   case 70: /* pname: IP  */
-#line 567 "grammar.y"
+#line 645 "grammar.y"
                                 { (yyval.i) = Q_IP; }
-#line 2323 "grammar.c"
+#line 2401 "grammar.c"
     break;
 
   case 71: /* pname: ARP  */
-#line 568 "grammar.y"
+#line 646 "grammar.y"
                                 { (yyval.i) = Q_ARP; }
-#line 2329 "grammar.c"
+#line 2407 "grammar.c"
     break;
 
   case 72: /* pname: RARP  */
-#line 569 "grammar.y"
+#line 647 "grammar.y"
                                 { (yyval.i) = Q_RARP; }
-#line 2335 "grammar.c"
+#line 2413 "grammar.c"
     break;
 
   case 73: /* pname: SCTP  */
-#line 570 "grammar.y"
+#line 648 "grammar.y"
                                 { (yyval.i) = Q_SCTP; }
-#line 2341 "grammar.c"
+#line 2419 "grammar.c"
     break;
 
   case 74: /* pname: TCP  */
-#line 571 "grammar.y"
+#line 649 "grammar.y"
                                 { (yyval.i) = Q_TCP; }
-#line 2347 "grammar.c"
+#line 2425 "grammar.c"
     break;
 
   case 75: /* pname: UDP  */
-#line 572 "grammar.y"
+#line 650 "grammar.y"
                                 { (yyval.i) = Q_UDP; }
-#line 2353 "grammar.c"
+#line 2431 "grammar.c"
     break;
 
   case 76: /* pname: ICMP  */
-#line 573 "grammar.y"
+#line 651 "grammar.y"
                                 { (yyval.i) = Q_ICMP; }
-#line 2359 "grammar.c"
+#line 2437 "grammar.c"
     break;
 
   case 77: /* pname: IGMP  */
-#line 574 "grammar.y"
+#line 652 "grammar.y"
                                 { (yyval.i) = Q_IGMP; }
-#line 2365 "grammar.c"
+#line 2443 "grammar.c"
     break;
 
   case 78: /* pname: IGRP  */
-#line 575 "grammar.y"
+#line 653 "grammar.y"
                                 { (yyval.i) = Q_IGRP; }
-#line 2371 "grammar.c"
+#line 2449 "grammar.c"
     break;
 
   case 79: /* pname: PIM  */
-#line 576 "grammar.y"
+#line 654 "grammar.y"
                                 { (yyval.i) = Q_PIM; }
-#line 2377 "grammar.c"
+#line 2455 "grammar.c"
     break;
 
   case 80: /* pname: VRRP  */
-#line 577 "grammar.y"
+#line 655 "grammar.y"
                                 { (yyval.i) = Q_VRRP; }
-#line 2383 "grammar.c"
+#line 2461 "grammar.c"
     break;
 
   case 81: /* pname: CARP  */
-#line 578 "grammar.y"
+#line 656 "grammar.y"
                                 { (yyval.i) = Q_CARP; }
-#line 2389 "grammar.c"
+#line 2467 "grammar.c"
     break;
 
   case 82: /* pname: ATALK  */
-#line 579 "grammar.y"
+#line 657 "grammar.y"
                                 { (yyval.i) = Q_ATALK; }
-#line 2395 "grammar.c"
+#line 2473 "grammar.c"
     break;
 
   case 83: /* pname: AARP  */
-#line 580 "grammar.y"
+#line 658 "grammar.y"
                                 { (yyval.i) = Q_AARP; }
-#line 2401 "grammar.c"
+#line 2479 "grammar.c"
     break;
 
   case 84: /* pname: DECNET  */
-#line 581 "grammar.y"
+#line 659 "grammar.y"
                                 { (yyval.i) = Q_DECNET; }
-#line 2407 "grammar.c"
+#line 2485 "grammar.c"
     break;
 
   case 85: /* pname: LAT  */
-#line 582 "grammar.y"
+#line 660 "grammar.y"
                                 { (yyval.i) = Q_LAT; }
-#line 2413 "grammar.c"
+#line 2491 "grammar.c"
     break;
 
   case 86: /* pname: SCA  */
-#line 583 "grammar.y"
+#line 661 "grammar.y"
                                 { (yyval.i) = Q_SCA; }
-#line 2419 "grammar.c"
+#line 2497 "grammar.c"
     break;
 
   case 87: /* pname: MOPDL  */
-#line 584 "grammar.y"
+#line 662 "grammar.y"
                                 { (yyval.i) = Q_MOPDL; }
-#line 2425 "grammar.c"
+#line 2503 "grammar.c"
     break;
 
   case 88: /* pname: MOPRC  */
-#line 585 "grammar.y"
+#line 663 "grammar.y"
                                 { (yyval.i) = Q_MOPRC; }
-#line 2431 "grammar.c"
+#line 2509 "grammar.c"
     break;
 
   case 89: /* pname: IPV6  */
-#line 586 "grammar.y"
+#line 664 "grammar.y"
                                 { (yyval.i) = Q_IPV6; }
-#line 2437 "grammar.c"
+#line 2515 "grammar.c"
     break;
 
   case 90: /* pname: ICMPV6  */
-#line 587 "grammar.y"
+#line 665 "grammar.y"
                                 { (yyval.i) = Q_ICMPV6; }
-#line 2443 "grammar.c"
+#line 2521 "grammar.c"
     break;
 
   case 91: /* pname: AH  */
-#line 588 "grammar.y"
+#line 666 "grammar.y"
                                 { (yyval.i) = Q_AH; }
-#line 2449 "grammar.c"
+#line 2527 "grammar.c"
     break;
 
   case 92: /* pname: ESP  */
-#line 589 "grammar.y"
+#line 667 "grammar.y"
                                 { (yyval.i) = Q_ESP; }
-#line 2455 "grammar.c"
+#line 2533 "grammar.c"
     break;
 
   case 93: /* pname: ISO  */
-#line 590 "grammar.y"
+#line 668 "grammar.y"
                                 { (yyval.i) = Q_ISO; }
-#line 2461 "grammar.c"
+#line 2539 "grammar.c"
     break;
 
   case 94: /* pname: ESIS  */
-#line 591 "grammar.y"
+#line 669 "grammar.y"
                                 { (yyval.i) = Q_ESIS; }
-#line 2467 "grammar.c"
+#line 2545 "grammar.c"
     break;
 
   case 95: /* pname: ISIS  */
-#line 592 "grammar.y"
+#line 670 "grammar.y"
                                 { (yyval.i) = Q_ISIS; }
-#line 2473 "grammar.c"
+#line 2551 "grammar.c"
     break;
 
   case 96: /* pname: L1  */
-#line 593 "grammar.y"
+#line 671 "grammar.y"
                                 { (yyval.i) = Q_ISIS_L1; }
-#line 2479 "grammar.c"
+#line 2557 "grammar.c"
     break;
 
   case 97: /* pname: L2  */
-#line 594 "grammar.y"
+#line 672 "grammar.y"
                                 { (yyval.i) = Q_ISIS_L2; }
-#line 2485 "grammar.c"
+#line 2563 "grammar.c"
     break;
 
   case 98: /* pname: IIH  */
-#line 595 "grammar.y"
+#line 673 "grammar.y"
                                 { (yyval.i) = Q_ISIS_IIH; }
-#line 2491 "grammar.c"
+#line 2569 "grammar.c"
     break;
 
   case 99: /* pname: LSP  */
-#line 596 "grammar.y"
+#line 674 "grammar.y"
                                 { (yyval.i) = Q_ISIS_LSP; }
-#line 2497 "grammar.c"
+#line 2575 "grammar.c"
     break;
 
   case 100: /* pname: SNP  */
-#line 597 "grammar.y"
+#line 675 "grammar.y"
                                 { (yyval.i) = Q_ISIS_SNP; }
-#line 2503 "grammar.c"
+#line 2581 "grammar.c"
     break;
 
   case 101: /* pname: PSNP  */
-#line 598 "grammar.y"
+#line 676 "grammar.y"
                                 { (yyval.i) = Q_ISIS_PSNP; }
-#line 2509 "grammar.c"
+#line 2587 "grammar.c"
     break;
 
   case 102: /* pname: CSNP  */
-#line 599 "grammar.y"
+#line 677 "grammar.y"
                                 { (yyval.i) = Q_ISIS_CSNP; }
-#line 2515 "grammar.c"
+#line 2593 "grammar.c"
     break;
 
   case 103: /* pname: CLNP  */
-#line 600 "grammar.y"
+#line 678 "grammar.y"
                                 { (yyval.i) = Q_CLNP; }
-#line 2521 "grammar.c"
+#line 2599 "grammar.c"
     break;
 
   case 104: /* pname: STP  */
-#line 601 "grammar.y"
+#line 679 "grammar.y"
                                 { (yyval.i) = Q_STP; }
-#line 2527 "grammar.c"
+#line 2605 "grammar.c"
     break;
 
   case 105: /* pname: IPX  */
-#line 602 "grammar.y"
+#line 680 "grammar.y"
                                 { (yyval.i) = Q_IPX; }
-#line 2533 "grammar.c"
+#line 2611 "grammar.c"
     break;
 
   case 106: /* pname: NETBEUI  */
-#line 603 "grammar.y"
+#line 681 "grammar.y"
                                 { (yyval.i) = Q_NETBEUI; }
-#line 2539 "grammar.c"
+#line 2617 "grammar.c"
     break;
 
   case 107: /* pname: RADIO  */
-#line 604 "grammar.y"
+#line 682 "grammar.y"
                                 { (yyval.i) = Q_RADIO; }
-#line 2545 "grammar.c"
+#line 2623 "grammar.c"
     break;
 
   case 108: /* other: pqual TK_BROADCAST  */
-#line 606 "grammar.y"
+#line 684 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_broadcast(cstate, (yyvsp[-1].i)))); }
-#line 2551 "grammar.c"
+#line 2629 "grammar.c"
     break;
 
   case 109: /* other: pqual TK_MULTICAST  */
-#line 607 "grammar.y"
+#line 685 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_multicast(cstate, (yyvsp[-1].i)))); }
-#line 2557 "grammar.c"
+#line 2635 "grammar.c"
     break;
 
   case 110: /* other: LESS NUM  */
-#line 608 "grammar.y"
+#line 686 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_less(cstate, (yyvsp[0].h)))); }
-#line 2563 "grammar.c"
+#line 2641 "grammar.c"
     break;
 
   case 111: /* other: GREATER NUM  */
-#line 609 "grammar.y"
+#line 687 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_greater(cstate, (yyvsp[0].h)))); }
-#line 2569 "grammar.c"
+#line 2647 "grammar.c"
     break;
 
   case 112: /* other: CBYTE NUM byteop NUM  */
-#line 610 "grammar.y"
+#line 688 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_byteop(cstate, (yyvsp[-1].i), (yyvsp[-2].h), (yyvsp[0].h)))); }
-#line 2575 "grammar.c"
+#line 2653 "grammar.c"
     break;
 
   case 113: /* other: INBOUND  */
-#line 611 "grammar.y"
+#line 689 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_inbound(cstate, 0))); }
-#line 2581 "grammar.c"
+#line 2659 "grammar.c"
     break;
 
   case 114: /* other: OUTBOUND  */
-#line 612 "grammar.y"
+#line 690 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_inbound(cstate, 1))); }
-#line 2587 "grammar.c"
+#line 2665 "grammar.c"
     break;
 
   case 115: /* other: IFINDEX NUM  */
-#line 613 "grammar.y"
+#line 691 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_ifindex(cstate, (yyvsp[0].h)))); }
-#line 2593 "grammar.c"
+#line 2671 "grammar.c"
     break;
 
   case 116: /* other: VLAN pnum  */
-#line 614 "grammar.y"
+#line 692 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_vlan(cstate, (yyvsp[0].h), 1))); }
-#line 2599 "grammar.c"
+#line 2677 "grammar.c"
     break;
 
   case 117: /* other: VLAN  */
-#line 615 "grammar.y"
+#line 693 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_vlan(cstate, 0, 0))); }
-#line 2605 "grammar.c"
+#line 2683 "grammar.c"
     break;
 
   case 118: /* other: MPLS pnum  */
-#line 616 "grammar.y"
+#line 694 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_mpls(cstate, (yyvsp[0].h), 1))); }
-#line 2611 "grammar.c"
+#line 2689 "grammar.c"
     break;
 
   case 119: /* other: MPLS  */
-#line 617 "grammar.y"
+#line 695 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_mpls(cstate, 0, 0))); }
-#line 2617 "grammar.c"
+#line 2695 "grammar.c"
     break;
 
   case 120: /* other: PPPOED  */
-#line 618 "grammar.y"
+#line 696 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoed(cstate))); }
-#line 2623 "grammar.c"
+#line 2701 "grammar.c"
     break;
 
   case 121: /* other: PPPOES pnum  */
-#line 619 "grammar.y"
+#line 697 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoes(cstate, (yyvsp[0].h), 1))); }
-#line 2629 "grammar.c"
+#line 2707 "grammar.c"
     break;
 
   case 122: /* other: PPPOES  */
-#line 620 "grammar.y"
+#line 698 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoes(cstate, 0, 0))); }
-#line 2635 "grammar.c"
+#line 2713 "grammar.c"
     break;
 
   case 123: /* other: GENEVE pnum  */
-#line 621 "grammar.y"
+#line 699 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_geneve(cstate, (yyvsp[0].h), 1))); }
-#line 2641 "grammar.c"
+#line 2719 "grammar.c"
     break;
 
   case 124: /* other: GENEVE  */
-#line 622 "grammar.y"
+#line 700 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_geneve(cstate, 0, 0))); }
-#line 2647 "grammar.c"
+#line 2725 "grammar.c"
     break;
 
   case 125: /* other: pfvar  */
-#line 623 "grammar.y"
+#line 701 "grammar.y"
                                 { (yyval.rblk) = (yyvsp[0].rblk); }
-#line 2653 "grammar.c"
+#line 2731 "grammar.c"
     break;
 
   case 126: /* other: pqual p80211  */
-#line 624 "grammar.y"
+#line 702 "grammar.y"
                                 { (yyval.rblk) = (yyvsp[0].rblk); }
-#line 2659 "grammar.c"
+#line 2737 "grammar.c"
     break;
 
   case 127: /* other: pllc  */
-#line 625 "grammar.y"
+#line 703 "grammar.y"
                                 { (yyval.rblk) = (yyvsp[0].rblk); }
-#line 2665 "grammar.c"
+#line 2743 "grammar.c"
     break;
 
   case 128: /* pfvar: PF_IFNAME ID  */
-#line 628 "grammar.y"
+#line 706 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.rblk) = gen_pf_ifname(cstate, (yyvsp[0].s)))); }
-#line 2671 "grammar.c"
+#line 2749 "grammar.c"
     break;
 
   case 129: /* pfvar: PF_RSET ID  */
-#line 629 "grammar.y"
+#line 707 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.rblk) = gen_pf_ruleset(cstate, (yyvsp[0].s)))); }
-#line 2677 "grammar.c"
+#line 2755 "grammar.c"
     break;
 
   case 130: /* pfvar: PF_RNR NUM  */
-#line 630 "grammar.y"
+#line 708 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_rnr(cstate, (yyvsp[0].h)))); }
-#line 2683 "grammar.c"
+#line 2761 "grammar.c"
     break;
 
   case 131: /* pfvar: PF_SRNR NUM  */
-#line 631 "grammar.y"
+#line 709 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_srnr(cstate, (yyvsp[0].h)))); }
-#line 2689 "grammar.c"
+#line 2767 "grammar.c"
     break;
 
   case 132: /* pfvar: PF_REASON reason  */
-#line 632 "grammar.y"
+#line 710 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_reason(cstate, (yyvsp[0].i)))); }
-#line 2695 "grammar.c"
+#line 2773 "grammar.c"
     break;
 
   case 133: /* pfvar: PF_ACTION action  */
-#line 633 "grammar.y"
+#line 711 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_action(cstate, (yyvsp[0].i)))); }
-#line 2701 "grammar.c"
+#line 2779 "grammar.c"
     break;
 
   case 134: /* p80211: TYPE type SUBTYPE subtype  */
-#line 637 "grammar.y"
+#line 715 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[-2].i) | (yyvsp[0].i),
 					IEEE80211_FC0_TYPE_MASK |
 					IEEE80211_FC0_SUBTYPE_MASK)));
 				}
-#line 2710 "grammar.c"
+#line 2788 "grammar.c"
     break;
 
   case 135: /* p80211: TYPE type  */
-#line 641 "grammar.y"
+#line 719 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[0].i),
 					IEEE80211_FC0_TYPE_MASK)));
 				}
-#line 2718 "grammar.c"
+#line 2796 "grammar.c"
     break;
 
   case 136: /* p80211: SUBTYPE type_subtype  */
-#line 644 "grammar.y"
+#line 722 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[0].i),
 					IEEE80211_FC0_TYPE_MASK |
 					IEEE80211_FC0_SUBTYPE_MASK)));
 				}
-#line 2727 "grammar.c"
+#line 2805 "grammar.c"
     break;
 
   case 137: /* p80211: DIR dir  */
-#line 648 "grammar.y"
+#line 726 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_fcdir(cstate, (yyvsp[0].i)))); }
-#line 2733 "grammar.c"
+#line 2811 "grammar.c"
     break;
 
   case 138: /* type: NUM  */
-#line 651 "grammar.y"
+#line 729 "grammar.y"
                                 { if (((yyvsp[0].h) & (~IEEE80211_FC0_TYPE_MASK)) != 0) {
 					bpf_set_error(cstate, "invalid 802.11 type value 0x%02x", (yyvsp[0].h));
 					YYABORT;
 				  }
 				  (yyval.i) = (int)(yyvsp[0].h);
 				}
-#line 2744 "grammar.c"
+#line 2822 "grammar.c"
     break;
 
   case 139: /* type: ID  */
-#line 657 "grammar.y"
+#line 735 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s));
 				  (yyval.i) = str2tok((yyvsp[0].s), ieee80211_types);
 				  if ((yyval.i) == -1) {
@@ -2752,22 +2830,22 @@ yyreduce:
 					YYABORT;
 				  }
 				}
-#line 2756 "grammar.c"
+#line 2834 "grammar.c"
     break;
 
   case 140: /* subtype: NUM  */
-#line 666 "grammar.y"
+#line 744 "grammar.y"
                                 { if (((yyvsp[0].h) & (~IEEE80211_FC0_SUBTYPE_MASK)) != 0) {
 					bpf_set_error(cstate, "invalid 802.11 subtype value 0x%02x", (yyvsp[0].h));
 					YYABORT;
 				  }
 				  (yyval.i) = (int)(yyvsp[0].h);
 				}
-#line 2767 "grammar.c"
+#line 2845 "grammar.c"
     break;
 
   case 141: /* subtype: ID  */
-#line 672 "grammar.y"
+#line 750 "grammar.y"
                                 { const struct tok *types = NULL;
 				  int i;
 				  CHECK_PTR_VAL((yyvsp[0].s));
@@ -2789,11 +2867,11 @@ yyreduce:
 					YYABORT;
 				  }
 				}
-#line 2793 "grammar.c"
+#line 2871 "grammar.c"
     break;
 
   case 142: /* type_subtype: ID  */
-#line 695 "grammar.y"
+#line 773 "grammar.y"
                                 { int i;
 				  CHECK_PTR_VAL((yyvsp[0].s));
 				  for (i = 0;; i++) {
@@ -2809,23 +2887,23 @@ yyreduce:
 					}
 				  }
 				}
-#line 2813 "grammar.c"
+#line 2891 "grammar.c"
     break;
 
   case 143: /* pllc: LLC  */
-#line 712 "grammar.y"
+#line 790 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_llc(cstate))); }
-#line 2819 "grammar.c"
+#line 2897 "grammar.c"
     break;
 
   case 144: /* pllc: LLC ID  */
-#line 713 "grammar.y"
+#line 791 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s));
-				  if (pcap_strcasecmp((yyvsp[0].s), "i") == 0) {
+				  if (pcapint_strcasecmp((yyvsp[0].s), "i") == 0) {
 					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_i(cstate)));
-				  } else if (pcap_strcasecmp((yyvsp[0].s), "s") == 0) {
+				  } else if (pcapint_strcasecmp((yyvsp[0].s), "s") == 0) {
 					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_s(cstate)));
-				  } else if (pcap_strcasecmp((yyvsp[0].s), "u") == 0) {
+				  } else if (pcapint_strcasecmp((yyvsp[0].s), "u") == 0) {
 					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_u(cstate)));
 				  } else {
 					int subtype;
@@ -2843,443 +2921,443 @@ yyreduce:
 					}
 				  }
 				}
-#line 2847 "grammar.c"
+#line 2925 "grammar.c"
     break;
 
   case 145: /* pllc: LLC PF_RNR  */
-#line 737 "grammar.y"
+#line 815 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.rblk) = gen_llc_s_subtype(cstate, LLC_RNR))); }
-#line 2853 "grammar.c"
+#line 2931 "grammar.c"
     break;
 
   case 146: /* dir: NUM  */
-#line 740 "grammar.y"
+#line 818 "grammar.y"
                                 { (yyval.i) = (int)(yyvsp[0].h); }
-#line 2859 "grammar.c"
+#line 2937 "grammar.c"
     break;
 
   case 147: /* dir: ID  */
-#line 741 "grammar.y"
+#line 819 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s));
-				  if (pcap_strcasecmp((yyvsp[0].s), "nods") == 0)
+				  if (pcapint_strcasecmp((yyvsp[0].s), "nods") == 0)
 					(yyval.i) = IEEE80211_FC1_DIR_NODS;
-				  else if (pcap_strcasecmp((yyvsp[0].s), "tods") == 0)
+				  else if (pcapint_strcasecmp((yyvsp[0].s), "tods") == 0)
 					(yyval.i) = IEEE80211_FC1_DIR_TODS;
-				  else if (pcap_strcasecmp((yyvsp[0].s), "fromds") == 0)
+				  else if (pcapint_strcasecmp((yyvsp[0].s), "fromds") == 0)
 					(yyval.i) = IEEE80211_FC1_DIR_FROMDS;
-				  else if (pcap_strcasecmp((yyvsp[0].s), "dstods") == 0)
+				  else if (pcapint_strcasecmp((yyvsp[0].s), "dstods") == 0)
 					(yyval.i) = IEEE80211_FC1_DIR_DSTODS;
 				  else {
 					bpf_set_error(cstate, "unknown 802.11 direction");
 					YYABORT;
 				  }
 				}
-#line 2878 "grammar.c"
+#line 2956 "grammar.c"
     break;
 
   case 148: /* reason: NUM  */
-#line 757 "grammar.y"
+#line 835 "grammar.y"
                                 { (yyval.i) = (yyvsp[0].h); }
-#line 2884 "grammar.c"
+#line 2962 "grammar.c"
     break;
 
   case 149: /* reason: ID  */
-#line 758 "grammar.y"
+#line 836 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_INT_VAL(((yyval.i) = pfreason_to_num(cstate, (yyvsp[0].s)))); }
-#line 2890 "grammar.c"
+#line 2968 "grammar.c"
     break;
 
   case 150: /* action: ID  */
-#line 761 "grammar.y"
+#line 839 "grammar.y"
                                 { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_INT_VAL(((yyval.i) = pfaction_to_num(cstate, (yyvsp[0].s)))); }
-#line 2896 "grammar.c"
+#line 2974 "grammar.c"
     break;
 
   case 151: /* relop: '>'  */
-#line 764 "grammar.y"
+#line 842 "grammar.y"
                                 { (yyval.i) = BPF_JGT; }
-#line 2902 "grammar.c"
+#line 2980 "grammar.c"
     break;
 
   case 152: /* relop: GEQ  */
-#line 765 "grammar.y"
+#line 843 "grammar.y"
                                 { (yyval.i) = BPF_JGE; }
-#line 2908 "grammar.c"
+#line 2986 "grammar.c"
     break;
 
   case 153: /* relop: '='  */
-#line 766 "grammar.y"
+#line 844 "grammar.y"
                                 { (yyval.i) = BPF_JEQ; }
-#line 2914 "grammar.c"
+#line 2992 "grammar.c"
     break;
 
   case 154: /* irelop: LEQ  */
-#line 768 "grammar.y"
+#line 846 "grammar.y"
                                 { (yyval.i) = BPF_JGT; }
-#line 2920 "grammar.c"
+#line 2998 "grammar.c"
     break;
 
   case 155: /* irelop: '<'  */
-#line 769 "grammar.y"
+#line 847 "grammar.y"
                                 { (yyval.i) = BPF_JGE; }
-#line 2926 "grammar.c"
+#line 3004 "grammar.c"
     break;
 
   case 156: /* irelop: NEQ  */
-#line 770 "grammar.y"
+#line 848 "grammar.y"
                                 { (yyval.i) = BPF_JEQ; }
-#line 2932 "grammar.c"
+#line 3010 "grammar.c"
     break;
 
   case 157: /* arth: pnum  */
-#line 772 "grammar.y"
+#line 850 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.a) = gen_loadi(cstate, (yyvsp[0].h)))); }
-#line 2938 "grammar.c"
+#line 3016 "grammar.c"
     break;
 
   case 159: /* narth: pname '[' arth ']'  */
-#line 775 "grammar.y"
+#line 853 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_load(cstate, (yyvsp[-3].i), (yyvsp[-1].a), 1))); }
-#line 2944 "grammar.c"
+#line 3022 "grammar.c"
     break;
 
   case 160: /* narth: pname '[' arth ':' NUM ']'  */
-#line 776 "grammar.y"
+#line 854 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_load(cstate, (yyvsp[-5].i), (yyvsp[-3].a), (yyvsp[-1].h)))); }
-#line 2950 "grammar.c"
+#line 3028 "grammar.c"
     break;
 
   case 161: /* narth: arth '+' arth  */
-#line 777 "grammar.y"
+#line 855 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_ADD, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2956 "grammar.c"
+#line 3034 "grammar.c"
     break;
 
   case 162: /* narth: arth '-' arth  */
-#line 778 "grammar.y"
+#line 856 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_SUB, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2962 "grammar.c"
+#line 3040 "grammar.c"
     break;
 
   case 163: /* narth: arth '*' arth  */
-#line 779 "grammar.y"
+#line 857 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_MUL, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2968 "grammar.c"
+#line 3046 "grammar.c"
     break;
 
   case 164: /* narth: arth '/' arth  */
-#line 780 "grammar.y"
+#line 858 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_DIV, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2974 "grammar.c"
+#line 3052 "grammar.c"
     break;
 
   case 165: /* narth: arth '%' arth  */
-#line 781 "grammar.y"
+#line 859 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_MOD, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2980 "grammar.c"
+#line 3058 "grammar.c"
     break;
 
   case 166: /* narth: arth '&' arth  */
-#line 782 "grammar.y"
+#line 860 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_AND, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2986 "grammar.c"
+#line 3064 "grammar.c"
     break;
 
   case 167: /* narth: arth '|' arth  */
-#line 783 "grammar.y"
+#line 861 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_OR, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2992 "grammar.c"
+#line 3070 "grammar.c"
     break;
 
   case 168: /* narth: arth '^' arth  */
-#line 784 "grammar.y"
+#line 862 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_XOR, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 2998 "grammar.c"
+#line 3076 "grammar.c"
     break;
 
   case 169: /* narth: arth LSH arth  */
-#line 785 "grammar.y"
+#line 863 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_LSH, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 3004 "grammar.c"
+#line 3082 "grammar.c"
     break;
 
   case 170: /* narth: arth RSH arth  */
-#line 786 "grammar.y"
+#line 864 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_RSH, (yyvsp[-2].a), (yyvsp[0].a)))); }
-#line 3010 "grammar.c"
+#line 3088 "grammar.c"
     break;
 
   case 171: /* narth: '-' arth  */
-#line 787 "grammar.y"
+#line 865 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_neg(cstate, (yyvsp[0].a)))); }
-#line 3016 "grammar.c"
+#line 3094 "grammar.c"
     break;
 
   case 172: /* narth: paren narth ')'  */
-#line 788 "grammar.y"
+#line 866 "grammar.y"
                                         { (yyval.a) = (yyvsp[-1].a); }
-#line 3022 "grammar.c"
+#line 3100 "grammar.c"
     break;
 
   case 173: /* narth: LEN  */
-#line 789 "grammar.y"
+#line 867 "grammar.y"
                                         { CHECK_PTR_VAL(((yyval.a) = gen_loadlen(cstate))); }
-#line 3028 "grammar.c"
+#line 3106 "grammar.c"
     break;
 
   case 174: /* byteop: '&'  */
-#line 791 "grammar.y"
+#line 869 "grammar.y"
                                 { (yyval.i) = '&'; }
-#line 3034 "grammar.c"
+#line 3112 "grammar.c"
     break;
 
   case 175: /* byteop: '|'  */
-#line 792 "grammar.y"
+#line 870 "grammar.y"
                                 { (yyval.i) = '|'; }
-#line 3040 "grammar.c"
+#line 3118 "grammar.c"
     break;
 
   case 176: /* byteop: '<'  */
-#line 793 "grammar.y"
+#line 871 "grammar.y"
                                 { (yyval.i) = '<'; }
-#line 3046 "grammar.c"
+#line 3124 "grammar.c"
     break;
 
   case 177: /* byteop: '>'  */
-#line 794 "grammar.y"
+#line 872 "grammar.y"
                                 { (yyval.i) = '>'; }
-#line 3052 "grammar.c"
+#line 3130 "grammar.c"
     break;
 
   case 178: /* byteop: '='  */
-#line 795 "grammar.y"
+#line 873 "grammar.y"
                                 { (yyval.i) = '='; }
-#line 3058 "grammar.c"
+#line 3136 "grammar.c"
     break;
 
   case 180: /* pnum: paren pnum ')'  */
-#line 798 "grammar.y"
+#line 876 "grammar.y"
                                 { (yyval.h) = (yyvsp[-1].h); }
-#line 3064 "grammar.c"
+#line 3142 "grammar.c"
     break;
 
   case 181: /* atmtype: LANE  */
-#line 800 "grammar.y"
+#line 878 "grammar.y"
                                 { (yyval.i) = A_LANE; }
-#line 3070 "grammar.c"
+#line 3148 "grammar.c"
     break;
 
   case 182: /* atmtype: METAC  */
-#line 801 "grammar.y"
+#line 879 "grammar.y"
                                 { (yyval.i) = A_METAC;	}
-#line 3076 "grammar.c"
+#line 3154 "grammar.c"
     break;
 
   case 183: /* atmtype: BCC  */
-#line 802 "grammar.y"
+#line 880 "grammar.y"
                                 { (yyval.i) = A_BCC; }
-#line 3082 "grammar.c"
+#line 3160 "grammar.c"
     break;
 
   case 184: /* atmtype: OAMF4EC  */
-#line 803 "grammar.y"
+#line 881 "grammar.y"
                                 { (yyval.i) = A_OAMF4EC; }
-#line 3088 "grammar.c"
+#line 3166 "grammar.c"
     break;
 
   case 185: /* atmtype: OAMF4SC  */
-#line 804 "grammar.y"
+#line 882 "grammar.y"
                                 { (yyval.i) = A_OAMF4SC; }
-#line 3094 "grammar.c"
+#line 3172 "grammar.c"
     break;
 
   case 186: /* atmtype: SC  */
-#line 805 "grammar.y"
+#line 883 "grammar.y"
                                 { (yyval.i) = A_SC; }
-#line 3100 "grammar.c"
+#line 3178 "grammar.c"
     break;
 
   case 187: /* atmtype: ILMIC  */
-#line 806 "grammar.y"
+#line 884 "grammar.y"
                                 { (yyval.i) = A_ILMIC; }
-#line 3106 "grammar.c"
+#line 3184 "grammar.c"
     break;
 
   case 188: /* atmmultitype: OAM  */
-#line 808 "grammar.y"
+#line 886 "grammar.y"
                                 { (yyval.i) = A_OAM; }
-#line 3112 "grammar.c"
+#line 3190 "grammar.c"
     break;
 
   case 189: /* atmmultitype: OAMF4  */
-#line 809 "grammar.y"
+#line 887 "grammar.y"
                                 { (yyval.i) = A_OAMF4; }
-#line 3118 "grammar.c"
+#line 3196 "grammar.c"
     break;
 
   case 190: /* atmmultitype: CONNECTMSG  */
-#line 810 "grammar.y"
+#line 888 "grammar.y"
                                 { (yyval.i) = A_CONNECTMSG; }
-#line 3124 "grammar.c"
+#line 3202 "grammar.c"
     break;
 
   case 191: /* atmmultitype: METACONNECT  */
-#line 811 "grammar.y"
+#line 889 "grammar.y"
                                 { (yyval.i) = A_METACONNECT; }
-#line 3130 "grammar.c"
+#line 3208 "grammar.c"
     break;
 
   case 192: /* atmfield: VPI  */
-#line 814 "grammar.y"
+#line 892 "grammar.y"
                                 { (yyval.blk).atmfieldtype = A_VPI; }
-#line 3136 "grammar.c"
+#line 3214 "grammar.c"
     break;
 
   case 193: /* atmfield: VCI  */
-#line 815 "grammar.y"
+#line 893 "grammar.y"
                                 { (yyval.blk).atmfieldtype = A_VCI; }
-#line 3142 "grammar.c"
+#line 3220 "grammar.c"
     break;
 
   case 195: /* atmvalue: relop NUM  */
-#line 818 "grammar.y"
+#line 896 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyvsp[-2].blk).atmfieldtype, (yyvsp[0].h), (yyvsp[-1].i), 0))); }
-#line 3148 "grammar.c"
+#line 3226 "grammar.c"
     break;
 
   case 196: /* atmvalue: irelop NUM  */
-#line 819 "grammar.y"
+#line 897 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyvsp[-2].blk).atmfieldtype, (yyvsp[0].h), (yyvsp[-1].i), 1))); }
-#line 3154 "grammar.c"
+#line 3232 "grammar.c"
     break;
 
   case 197: /* atmvalue: paren atmlistvalue ')'  */
-#line 820 "grammar.y"
+#line 898 "grammar.y"
                                  { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = qerr; }
-#line 3160 "grammar.c"
+#line 3238 "grammar.c"
     break;
 
   case 198: /* atmfieldvalue: NUM  */
-#line 822 "grammar.y"
+#line 900 "grammar.y"
                    {
 	(yyval.blk).atmfieldtype = (yyvsp[-1].blk).atmfieldtype;
 	if ((yyval.blk).atmfieldtype == A_VPI ||
 	    (yyval.blk).atmfieldtype == A_VCI)
 		CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyval.blk).atmfieldtype, (yyvsp[0].h), BPF_JEQ, 0)));
 	}
-#line 3171 "grammar.c"
+#line 3249 "grammar.c"
     break;
 
   case 200: /* atmlistvalue: atmlistvalue or atmfieldvalue  */
-#line 830 "grammar.y"
+#line 908 "grammar.y"
                                         { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 3177 "grammar.c"
+#line 3255 "grammar.c"
     break;
 
   case 201: /* mtp2type: FISU  */
-#line 833 "grammar.y"
+#line 911 "grammar.y"
                                 { (yyval.i) = M_FISU; }
-#line 3183 "grammar.c"
+#line 3261 "grammar.c"
     break;
 
   case 202: /* mtp2type: LSSU  */
-#line 834 "grammar.y"
+#line 912 "grammar.y"
                                 { (yyval.i) = M_LSSU; }
-#line 3189 "grammar.c"
+#line 3267 "grammar.c"
     break;
 
   case 203: /* mtp2type: MSU  */
-#line 835 "grammar.y"
+#line 913 "grammar.y"
                                 { (yyval.i) = M_MSU; }
-#line 3195 "grammar.c"
+#line 3273 "grammar.c"
     break;
 
   case 204: /* mtp2type: HFISU  */
-#line 836 "grammar.y"
+#line 914 "grammar.y"
                                 { (yyval.i) = MH_FISU; }
-#line 3201 "grammar.c"
+#line 3279 "grammar.c"
     break;
 
   case 205: /* mtp2type: HLSSU  */
-#line 837 "grammar.y"
+#line 915 "grammar.y"
                                 { (yyval.i) = MH_LSSU; }
-#line 3207 "grammar.c"
+#line 3285 "grammar.c"
     break;
 
   case 206: /* mtp2type: HMSU  */
-#line 838 "grammar.y"
+#line 916 "grammar.y"
                                 { (yyval.i) = MH_MSU; }
-#line 3213 "grammar.c"
+#line 3291 "grammar.c"
     break;
 
   case 207: /* mtp3field: SIO  */
-#line 841 "grammar.y"
+#line 919 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = M_SIO; }
-#line 3219 "grammar.c"
+#line 3297 "grammar.c"
     break;
 
   case 208: /* mtp3field: OPC  */
-#line 842 "grammar.y"
+#line 920 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = M_OPC; }
-#line 3225 "grammar.c"
+#line 3303 "grammar.c"
     break;
 
   case 209: /* mtp3field: DPC  */
-#line 843 "grammar.y"
+#line 921 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = M_DPC; }
-#line 3231 "grammar.c"
+#line 3309 "grammar.c"
     break;
 
   case 210: /* mtp3field: SLS  */
-#line 844 "grammar.y"
+#line 922 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = M_SLS; }
-#line 3237 "grammar.c"
+#line 3315 "grammar.c"
     break;
 
   case 211: /* mtp3field: HSIO  */
-#line 845 "grammar.y"
+#line 923 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = MH_SIO; }
-#line 3243 "grammar.c"
+#line 3321 "grammar.c"
     break;
 
   case 212: /* mtp3field: HOPC  */
-#line 846 "grammar.y"
+#line 924 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = MH_OPC; }
-#line 3249 "grammar.c"
+#line 3327 "grammar.c"
     break;
 
   case 213: /* mtp3field: HDPC  */
-#line 847 "grammar.y"
+#line 925 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = MH_DPC; }
-#line 3255 "grammar.c"
+#line 3333 "grammar.c"
     break;
 
   case 214: /* mtp3field: HSLS  */
-#line 848 "grammar.y"
+#line 926 "grammar.y"
                                 { (yyval.blk).mtp3fieldtype = MH_SLS; }
-#line 3261 "grammar.c"
+#line 3339 "grammar.c"
     break;
 
   case 216: /* mtp3value: relop NUM  */
-#line 851 "grammar.y"
+#line 929 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyvsp[-2].blk).mtp3fieldtype, (yyvsp[0].h), (yyvsp[-1].i), 0))); }
-#line 3267 "grammar.c"
+#line 3345 "grammar.c"
     break;
 
   case 217: /* mtp3value: irelop NUM  */
-#line 852 "grammar.y"
+#line 930 "grammar.y"
                                 { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyvsp[-2].blk).mtp3fieldtype, (yyvsp[0].h), (yyvsp[-1].i), 1))); }
-#line 3273 "grammar.c"
+#line 3351 "grammar.c"
     break;
 
   case 218: /* mtp3value: paren mtp3listvalue ')'  */
-#line 853 "grammar.y"
+#line 931 "grammar.y"
                                   { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = qerr; }
-#line 3279 "grammar.c"
+#line 3357 "grammar.c"
     break;
 
   case 219: /* mtp3fieldvalue: NUM  */
-#line 855 "grammar.y"
+#line 933 "grammar.y"
                     {
 	(yyval.blk).mtp3fieldtype = (yyvsp[-1].blk).mtp3fieldtype;
 	if ((yyval.blk).mtp3fieldtype == M_SIO ||
@@ -3292,17 +3370,17 @@ yyreduce:
 	    (yyval.blk).mtp3fieldtype == MH_SLS)
 		CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyval.blk).mtp3fieldtype, (yyvsp[0].h), BPF_JEQ, 0)));
 	}
-#line 3296 "grammar.c"
+#line 3374 "grammar.c"
     break;
 
   case 221: /* mtp3listvalue: mtp3listvalue or mtp3fieldvalue  */
-#line 869 "grammar.y"
+#line 947 "grammar.y"
                                           { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
-#line 3302 "grammar.c"
+#line 3380 "grammar.c"
     break;
 
 
-#line 3306 "grammar.c"
+#line 3384 "grammar.c"
 
       default: break;
     }
@@ -3495,5 +3573,5 @@ yyreturnlab:
   return yyresult;
 }
 
-#line 871 "grammar.y"
+#line 949 "grammar.y"
 
diff --git a/grammar.h b/grammar.h
index 97f546a5..df67a931 100644
--- a/grammar.h
+++ b/grammar.h
@@ -183,7 +183,7 @@ extern int pcap_debug;
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 union YYSTYPE
 {
-#line 349 "grammar.y"
+#line 357 "grammar.y"
 
 	int i;
 	bpf_u_int32 h;
diff --git a/grammar.y.in b/grammar.y.in
index b6a3d183..87706fa8 100644
--- a/grammar.y.in
+++ b/grammar.y.in
@@ -67,9 +67,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
@@ -110,21 +108,31 @@ struct rtentry;
 #include "os-proto.h"
 #endif
 
-#ifdef YYBYACC
+/*
+ * Work around some bugs in Berkeley YACC prior to the 2017-07-09
+ * release.
+ *
+ * The 2005-05-05 release was the first one to define YYPATCH, so
+ * we treat any release that either 1) doesn't define YYPATCH or
+ * 2) defines it to a value < 20170709 as being buggy.
+ */
+#if defined(YYBYACC) && (!defined(YYPATCH) || YYPATCH < 20170709)
 /*
  * Both Berkeley YACC and Bison define yydebug (under whatever name
  * it has) as a global, but Bison does so only if YYDEBUG is defined.
- * Berkeley YACC define it even if YYDEBUG isn't defined; declare it
- * here to suppress a warning.
+ * Berkeley YACC, prior to the 2017-07-09 release, defines it even if
+ * YYDEBUG isn't defined; declare it here to suppress a warning.  The
+ * 2017-07-09 release fixes that.
  */
 #if !defined(YYDEBUG)
 extern int yydebug;
 #endif
 
 /*
- * In Berkeley YACC, yynerrs (under whatever name it has) is global,
- * even if it's building a reentrant parser.  In Bison, it's local
- * in reentrant parsers.
+ * In Berkeley YACC, prior to the 2017-07-09 release, yynerrs (under
+ * whatever name it has) is global, even if it's building a reentrant
+ * parser.  In Bison, and in the Berkeley YACC 2017-07-09 release and
+ * later, it's local in reentrant parsers.
  *
  * Declare it to squelch a warning.
  */
@@ -232,7 +240,7 @@ str2tok(const char *str, const struct tok *toks)
 	int i;
 
 	for (i = 0; toks[i].s != NULL; i++) {
-		if (pcap_strcasecmp(toks[i].s, str) == 0) {
+		if (pcapint_strcasecmp(toks[i].s, str) == 0) {
 			/*
 			 * Just in case somebody is using this to
 			 * generate values of -1/0xFFFFFFFF.
@@ -422,6 +430,14 @@ DIAG_OFF_BISON_BYACC
 %%
 prog:	  null expr
 {
+	/*
+	 * I'm not sure we have a reason to use yynerrs, but it's
+	 * declared, and incremented, whether we need it or not,
+	 * which means that Clang 15 will give a "used but not
+	 * set" warning.  This should suppress the warning for
+	 * yynerrs without suppressing it for other variables.
+	 */
+	(void) yynerrs;
 	CHECK_INT_VAL(finish_parse(cstate, $2.b));
 }
 	| null
@@ -444,25 +460,59 @@ id:	  nid
 	| paren pid ')'		{ $$ = $2; }
 	;
 nid:	  ID			{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_scode(cstate, $1, $$.q = $<blk>0.q))); }
-	| HID '/' NUM		{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, NULL, $3,
-				    $$.q = $<blk>0.q))); }
-	| HID NETMASK HID	{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, $3, 0,
-				    $$.q = $<blk>0.q))); }
+	| HID '/' NUM		{
+				  CHECK_PTR_VAL($1);
+				  /* Check whether HID/NUM is being used when appropriate */
+				  $$.q = $<blk>0.q;
+				  if ($$.q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, NULL, $3, $$.q)));
+				}
+	| HID NETMASK HID	{
+				  CHECK_PTR_VAL($1);
+				  /* Check whether HID mask HID is being used when appropriate */
+				  $$.q = $<blk>0.q;
+				  if ($$.q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and netmask");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and netmask");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(($$.b = gen_mcode(cstate, $1, $3, 0, $$.q)));
+				}
 	| HID			{
 				  CHECK_PTR_VAL($1);
-				  /* Decide how to parse HID based on proto */
+				  /* Check whether HID is being used when appropriate */
 				  $$.q = $<blk>0.q;
 				  if ($$.q.addr == Q_PORT) {
-					bpf_set_error(cstate, "'port' modifier applied to ip host");
+					bpf_set_error(cstate, "'port' modifier applied to IP address");
 					YYABORT;
 				  } else if ($$.q.addr == Q_PORTRANGE) {
-					bpf_set_error(cstate, "'portrange' modifier applied to ip host");
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
 					YYABORT;
 				  } else if ($$.q.addr == Q_PROTO) {
-					bpf_set_error(cstate, "'proto' modifier applied to ip host");
+					bpf_set_error(cstate, "'proto' modifier applied to IP address");
 					YYABORT;
 				  } else if ($$.q.addr == Q_PROTOCHAIN) {
-					bpf_set_error(cstate, "'protochain' modifier applied to ip host");
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
 					YYABORT;
 				  }
 				  CHECK_PTR_VAL(($$.b = gen_ncode(cstate, $1, 0, $$.q)));
@@ -470,10 +520,24 @@ nid:	  ID			{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_scode(cstate, $1, $$.
 	| HID6 '/' NUM		{
 				  CHECK_PTR_VAL($1);
 #ifdef INET6
-				  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, NULL, $3,
-				    $$.q = $<blk>0.q)));
+				  /* Check whether HID6/NUM is being used when appropriate */
+				  $$.q = $<blk>0.q;
+				  if ($$.q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length ");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, $3, $$.q)));
 #else
-				  bpf_set_error(cstate, "'ip6addr/prefixlen' not supported "
+				  bpf_set_error(cstate, "IPv6 addresses not supported "
 					"in this configuration");
 				  YYABORT;
 #endif /*INET6*/
@@ -481,10 +545,24 @@ nid:	  ID			{ CHECK_PTR_VAL($1); CHECK_PTR_VAL(($$.b = gen_scode(cstate, $1, $$.
 	| HID6			{
 				  CHECK_PTR_VAL($1);
 #ifdef INET6
-				  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, 0, 128,
-				    $$.q = $<blk>0.q)));
+				  /* Check whether HID6 is being used when appropriate */
+				  $$.q = $<blk>0.q;
+				  if ($$.q.addr == Q_PORT) {
+					bpf_set_error(cstate, "'port' modifier applied to IP address");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PORTRANGE) {
+					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTO) {
+					bpf_set_error(cstate, "'proto' modifier applied to 'ip6addr/prefixlen");
+					YYABORT;
+				  } else if ($$.q.addr == Q_PROTOCHAIN) {
+					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
+					YYABORT;
+				  }
+				  CHECK_PTR_VAL(($$.b = gen_mcode6(cstate, $1, 128, $$.q)));
 #else
-				  bpf_set_error(cstate, "'ip6addr' not supported "
+				  bpf_set_error(cstate, "IPv6 addresses not supported "
 					"in this configuration");
 				  YYABORT;
 #endif /*INET6*/
@@ -711,11 +789,11 @@ type_subtype:	ID		{ int i;
 
 pllc:	LLC			{ CHECK_PTR_VAL(($$ = gen_llc(cstate))); }
 	| LLC ID		{ CHECK_PTR_VAL($2);
-				  if (pcap_strcasecmp($2, "i") == 0) {
+				  if (pcapint_strcasecmp($2, "i") == 0) {
 					CHECK_PTR_VAL(($$ = gen_llc_i(cstate)));
-				  } else if (pcap_strcasecmp($2, "s") == 0) {
+				  } else if (pcapint_strcasecmp($2, "s") == 0) {
 					CHECK_PTR_VAL(($$ = gen_llc_s(cstate)));
-				  } else if (pcap_strcasecmp($2, "u") == 0) {
+				  } else if (pcapint_strcasecmp($2, "u") == 0) {
 					CHECK_PTR_VAL(($$ = gen_llc_u(cstate)));
 				  } else {
 					int subtype;
@@ -739,13 +817,13 @@ pllc:	LLC			{ CHECK_PTR_VAL(($$ = gen_llc(cstate))); }
 
 dir:	  NUM			{ $$ = (int)$1; }
 	| ID			{ CHECK_PTR_VAL($1);
-				  if (pcap_strcasecmp($1, "nods") == 0)
+				  if (pcapint_strcasecmp($1, "nods") == 0)
 					$$ = IEEE80211_FC1_DIR_NODS;
-				  else if (pcap_strcasecmp($1, "tods") == 0)
+				  else if (pcapint_strcasecmp($1, "tods") == 0)
 					$$ = IEEE80211_FC1_DIR_TODS;
-				  else if (pcap_strcasecmp($1, "fromds") == 0)
+				  else if (pcapint_strcasecmp($1, "fromds") == 0)
 					$$ = IEEE80211_FC1_DIR_FROMDS;
-				  else if (pcap_strcasecmp($1, "dstods") == 0)
+				  else if (pcapint_strcasecmp($1, "dstods") == 0)
 					$$ = IEEE80211_FC1_DIR_DSTODS;
 				  else {
 					bpf_set_error(cstate, "unknown 802.11 direction");
diff --git a/install-sh b/install-sh
index b44de098..ec298b53 100755
--- a/install-sh
+++ b/install-sh
@@ -1,250 +1,541 @@
-#! /bin/sh
-#
+#!/bin/sh
 # install - install a program, script, or datafile
-# This comes from X11R5 (mit/util/scripts/install.sh).
+
+scriptversion=2020-11-14.01; # UTC
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
-# Copyright 1991 by the Massachusetts Institute of Technology
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
 #
-# Permission to use, copy, modify, distribute, and sell this software and its
-# documentation for any purpose is hereby granted without fee, provided that
-# the above copyright notice appear in all copies and that both that
-# copyright notice and this permission notice appear in supporting
-# documentation, and that the name of M.I.T. not be used in advertising or
-# publicity pertaining to distribution of the software without specific,
-# written prior permission.  M.I.T. makes no representations about the
-# suitability of this software for any purpose.  It is provided "as is"
-# without express or implied warranty.
+#
+# FSF changes to this file are in the public domain.
 #
 # Calling this script install-sh is preferred over install.sh, to prevent
-# `make' implicit rules from creating a file called install from it
+# 'make' implicit rules from creating a file called install from it
 # when there is no Makefile.
 #
 # This script is compatible with the BSD install script, but was written
-# from scratch.  It can only install one file at a time, a restriction
-# shared with many OS's install programs.
+# from scratch.
+
+tab='	'
+nl='
+'
+IFS=" $tab$nl"
 
+# Set DOITPROG to "echo" to test this script.
 
-# set DOITPROG to echo to test this script
+doit=${DOITPROG-}
+doit_exec=${doit:-exec}
 
-# Don't use :- since 4.3BSD and earlier shells don't like it.
-doit="${DOITPROG-}"
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
 
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
 
-# put in absolute paths if you don't have them in your path; or use env. vars.
+posix_mkdir=
 
-mvprog="${MVPROG-mv}"
-cpprog="${CPPROG-cp}"
-chmodprog="${CHMODPROG-chmod}"
-chownprog="${CHOWNPROG-chown}"
-chgrpprog="${CHGRPPROG-chgrp}"
-stripprog="${STRIPPROG-strip}"
-rmprog="${RMPROG-rm}"
-mkdirprog="${MKDIRPROG-mkdir}"
+# Desired mode of installed file.
+mode=0755
 
-transformbasename=""
-transform_arg=""
-instcmd="$mvprog"
-chmodcmd="$chmodprog 0755"
-chowncmd=""
-chgrpcmd=""
-stripcmd=""
+# Create dirs (including intermediate dirs) using mode 755.
+# This is like GNU 'install' as of coreutils 8.32 (2020).
+mkdir_umask=22
+
+backupsuffix=
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
 rmcmd="$rmprog -f"
-mvcmd="$mvprog"
-src=""
-dst=""
-dir_arg=""
-
-while [ x"$1" != x ]; do
-    case $1 in
-	-c) instcmd="$cpprog"
-	    shift
-	    continue;;
-
-	-d) dir_arg=true
-	    shift
-	    continue;;
-
-	-m) chmodcmd="$chmodprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-o) chowncmd="$chownprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-g) chgrpcmd="$chgrpprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-s) stripcmd="$stripprog"
-	    shift
-	    continue;;
-
-	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
-	    shift
-	    continue;;
-
-	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
-	    shift
-	    continue;;
-
-	*)  if [ x"$src" = x ]
-	    then
-		src=$1
-	    else
-		# this colon is to work around a 386BSD /bin/sh bug
-		:
-		dst=$1
-	    fi
-	    shift
-	    continue;;
-    esac
-done
+stripcmd=
 
-if [ x"$src" = x ]
-then
-	echo "install:	no input file specified"
-	exit 1
-else
-	true
-fi
+src=
+dst=
+dir_arg=
+dst_arg=
 
-if [ x"$dir_arg" != x ]; then
-	dst=$src
-	src=""
+copy_on_change=false
+is_target_a_directory=possibly
 
-	if [ -d $dst ]; then
-		instcmd=:
-	else
-		instcmd=mkdir
-	fi
-else
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
 
-# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
-# might cause directories to be created, which would be especially bad
-# if $src (and thus $dsttmp) contains '*'.
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
 
-	if [ -f $src -o -d $src ]
-	then
-		true
-	else
-		echo "install:  $src does not exist"
-		exit 1
-	fi
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
 
-	if [ x"$dst" = x ]
-	then
-		echo "install:	no destination specified"
-		exit 1
-	else
-		true
-	fi
+  -c            (ignored)
+  -C            install only if different (preserve data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -p            pass -p to $cpprog.
+  -s            $stripprog installed files.
+  -S SUFFIX     attempt to back up existing files, with suffix SUFFIX.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
 
-# If destination is a directory, append the input filename; if your system
-# does not like double slashes in filenames, you may need to add some logic
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
 
-	if [ -d $dst ]
-	then
-		dst="$dst"/`basename $src`
-	else
-		true
-	fi
-fi
+By default, rm is invoked with -f; when overridden with RMPROG,
+it's up to you to specify -f if you want it.
 
-## this sed command emulates the dirname command
-dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+If -S is not specified, no backups are attempted.
 
-# Make sure that the destination directory exists.
-#  this part is taken from Noah Friedman's mkinstalldirs script
+Email bug reports to bug-automake@gnu.org.
+Automake home page: https://www.gnu.org/software/automake/
+"
 
-# Skip lots of stat calls in the usual case.
-if [ ! -d "$dstdir" ]; then
-defaultIFS='	
-'
-IFS="${IFS-${defaultIFS}}"
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
 
-oIFS="${IFS}"
-# Some sh's can't handle IFS=/ for some reason.
-IFS='%'
-set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
-IFS="${oIFS}"
+    -C) copy_on_change=true;;
 
-pathcomp=''
+    -d) dir_arg=true;;
 
-while [ $# -ne 0 ] ; do
-	pathcomp="${pathcomp}${1}"
-	shift
+    -g) chgrpcmd="$chgrpprog $2"
+        shift;;
 
-	if [ ! -d "${pathcomp}" ] ;
-        then
-		$mkdirprog "${pathcomp}"
-	else
-		true
-	fi
+    --help) echo "$usage"; exit $?;;
 
-	pathcomp="${pathcomp}/"
-done
-fi
+    -m) mode=$2
+        case $mode in
+          *' '* | *"$tab"* | *"$nl"* | *'*'* | *'?'* | *'['*)
+            echo "$0: invalid mode: $mode" >&2
+            exit 1;;
+        esac
+        shift;;
 
-if [ x"$dir_arg" != x ]
-then
-	$doit $instcmd $dst &&
+    -o) chowncmd="$chownprog $2"
+        shift;;
 
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
-else
+    -p) cpprog="$cpprog -p";;
 
-# If we're going to rename the final executable, determine the name now.
+    -s) stripcmd=$stripprog;;
 
-	if [ x"$transformarg" = x ]
-	then
-		dstfile=`basename $dst`
-	else
-		dstfile=`basename $dst $transformbasename |
-			sed $transformarg`$transformbasename
-	fi
+    -S) backupsuffix="$2"
+        shift;;
 
-# don't allow the sed command to completely eliminate the filename
+    -t)
+        is_target_a_directory=always
+        dst_arg=$2
+        # Protect names problematic for 'test' and other utilities.
+        case $dst_arg in
+          -* | [=\(\)!]) dst_arg=./$dst_arg;;
+        esac
+        shift;;
 
-	if [ x"$dstfile" = x ]
-	then
-		dstfile=`basename $dst`
-	else
-		true
-	fi
+    -T) is_target_a_directory=never;;
 
-# Make a temp file name in the proper directory.
+    --version) echo "$0 $scriptversion"; exit $?;;
 
-	dsttmp=$dstdir/#inst.$$#
+    --) shift
+        break;;
 
-# Move or copy the file name to the temp name
+    -*) echo "$0: invalid option: $1" >&2
+        exit 1;;
 
-	$doit $instcmd $src $dsttmp &&
+    *)  break;;
+  esac
+  shift
+done
 
-	trap "rm -f ${dsttmp}" 0 &&
+# We allow the use of options -d and -T together, by making -d
+# take the precedence; this is for compatibility with GNU install.
 
-# and set any options; do chmod last to preserve setuid bits
+if test -n "$dir_arg"; then
+  if test -n "$dst_arg"; then
+    echo "$0: target directory not allowed when installing a directory." >&2
+    exit 1
+  fi
+fi
 
-# If any of these fail, we abort the whole thing.  If we want to
-# ignore errors from any of these, just make sure not to ignore
-# errors from the above "$doit $instcmd $src $dsttmp" command.
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+    # Protect names problematic for 'test' and other utilities.
+    case $dst_arg in
+      -* | [=\(\)!]) dst_arg=./$dst_arg;;
+    esac
+  done
+fi
 
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call 'install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
 
-# Now rename the file to the real destination.
+if test -z "$dir_arg"; then
+  if test $# -gt 1 || test "$is_target_a_directory" = always; then
+    if test ! -d "$dst_arg"; then
+      echo "$0: $dst_arg: Is not a directory." >&2
+      exit 1
+    fi
+  fi
+fi
 
-	$doit $rmcmd -f $dstdir/$dstfile &&
-	$doit $mvcmd $dsttmp $dstdir/$dstfile
+if test -z "$dir_arg"; then
+  do_exit='(exit $ret); exit $ret'
+  trap "ret=129; $do_exit" 1
+  trap "ret=130; $do_exit" 2
+  trap "ret=141; $do_exit" 13
+  trap "ret=143; $do_exit" 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+        u_plus_rw=
+      else
+        u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+        u_plus_rw=
+      else
+        u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
 
-fi &&
+for src
+do
+  # Protect names problematic for 'test' and other utilities.
+  case $src in
+    -* | [=\(\)!]) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+    # Don't chown directories that already exist.
+    if test $dstdir_status = 0; then
+      chowncmd=""
+    fi
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+    dst=$dst_arg
+
+    # If destination is a directory, append the input filename.
+    if test -d "$dst"; then
+      if test "$is_target_a_directory" = never; then
+        echo "$0: $dst_arg: Is a directory" >&2
+        exit 1
+      fi
+      dstdir=$dst
+      dstbase=`basename "$src"`
+      case $dst in
+	*/) dst=$dst$dstbase;;
+	*)  dst=$dst/$dstbase;;
+      esac
+      dstdir_status=0
+    else
+      dstdir=`dirname "$dst"`
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  case $dstdir in
+    */) dstdirslash=$dstdir;;
+    *)  dstdirslash=$dstdir/;;
+  esac
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+        # With -d, create the new directory with the user-specified mode.
+        # Otherwise, rely on $mkdir_umask.
+        if test -n "$dir_arg"; then
+          mkdir_mode=-m$mode
+        else
+          mkdir_mode=
+        fi
+
+        posix_mkdir=false
+	# The $RANDOM variable is not portable (e.g., dash).  Use it
+	# here however when possible just to lower collision chance.
+	tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+
+	trap '
+	  ret=$?
+	  rmdir "$tmpdir/a/b" "$tmpdir/a" "$tmpdir" 2>/dev/null
+	  exit $ret
+	' 0
+
+	# Because "mkdir -p" follows existing symlinks and we likely work
+	# directly in world-writeable /tmp, make sure that the '$tmpdir'
+	# directory is successfully created first before we actually test
+	# 'mkdir -p'.
+	if (umask $mkdir_umask &&
+	    $mkdirprog $mkdir_mode "$tmpdir" &&
+	    exec $mkdirprog $mkdir_mode -p -- "$tmpdir/a/b") >/dev/null 2>&1
+	then
+	  if test -z "$dir_arg" || {
+	       # Check for POSIX incompatibilities with -m.
+	       # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+	       # other-writable bit of parent directory when it shouldn't.
+	       # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+	       test_tmpdir="$tmpdir/a"
+	       ls_ld_tmpdir=`ls -ld "$test_tmpdir"`
+	       case $ls_ld_tmpdir in
+		 d????-?r-*) different_mode=700;;
+		 d????-?--*) different_mode=755;;
+		 *) false;;
+	       esac &&
+	       $mkdirprog -m$different_mode -p -- "$test_tmpdir" && {
+		 ls_ld_tmpdir_1=`ls -ld "$test_tmpdir"`
+		 test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+	       }
+	     }
+	  then posix_mkdir=:
+	  fi
+	  rmdir "$tmpdir/a/b" "$tmpdir/a" "$tmpdir"
+	else
+	  # Remove any dirs left behind by ancient mkdir implementations.
+	  rmdir ./$mkdir_mode ./-p ./-- "$tmpdir" 2>/dev/null
+	fi
+	trap '' 0;;
+    esac
 
+    if
+      $posix_mkdir && (
+        umask $mkdir_umask &&
+        $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+        /*) prefix='/';;
+        [-=\(\)!]*) prefix='./';;
+        *)  prefix='';;
+      esac
+
+      oIFS=$IFS
+      IFS=/
+      set -f
+      set fnord $dstdir
+      shift
+      set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+        test X"$d" = X && continue
+
+        prefix=$prefix$d
+        if test -d "$prefix"; then
+          prefixes=
+        else
+          if $posix_mkdir; then
+            (umask $mkdir_umask &&
+             $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+            # Don't fail if two instances are running concurrently.
+            test -d "$prefix" || exit 1
+          else
+            case $prefix in
+              *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+              *) qprefix=$prefix;;
+            esac
+            prefixes="$prefixes '$qprefix'"
+          fi
+        fi
+        prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+        # Don't fail if two instances are running concurrently.
+        (umask $mkdir_umask &&
+         eval "\$doit_exec \$mkdirprog $prefixes") ||
+          test -d "$dstdir" || exit 1
+        obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=${dstdirslash}_inst.$$_
+    rmtmp=${dstdirslash}_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask &&
+     { test -z "$stripcmd" || {
+	 # Create $dsttmp read-write so that cp doesn't create it read-only,
+	 # which would cause strip to fail.
+	 if test -z "$doit"; then
+	   : >"$dsttmp" # No need to fork-exec 'touch'.
+	 else
+	   $doit touch "$dsttmp"
+	 fi
+       }
+     } &&
+     $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"     2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"  2>/dev/null` &&
+       set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       set +f &&
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # If $backupsuffix is set, and the file being installed
+      # already exists, attempt a backup.  Don't worry if it fails,
+      # e.g., if mv doesn't support -f.
+      if test -n "$backupsuffix" && test -f "$dst"; then
+        $doit $mvcmd -f "$dst" "$dst$backupsuffix" 2>/dev/null
+      fi
+
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+        # Now remove or move aside any old file at destination location.
+        # We try this two ways since rm can't unlink itself on some
+        # systems and the destination file might be busy for other
+        # reasons.  In this case, the final cleanup might fail but the new
+        # file should still install successfully.
+        {
+          test ! -f "$dst" ||
+          $doit $rmcmd "$dst" 2>/dev/null ||
+          { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+            { $doit $rmcmd "$rmtmp" 2>/dev/null; :; }
+          } ||
+          { echo "$0: cannot unlink or rename $dst" >&2
+            (exit 1); exit 1
+          }
+        } &&
+
+        # Now rename the file to the real destination.
+        $doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
 
-exit 0
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC0"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/instrument-functions.c b/instrument-functions.c
new file mode 100644
index 00000000..ba0a56a5
--- /dev/null
+++ b/instrument-functions.c
@@ -0,0 +1,250 @@
+/*
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code
+ * distributions retain the above copyright notice and this paragraph
+ * in its entirety, and (2) distributions including binary code include
+ * the above copyright notice and this paragraph in its entirety in
+ * the documentation or other materials provided with the distribution.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
+ * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
+ * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <bfd.h>
+
+/*
+ * Generate instrumentation calls for entry and exit to functions.
+ * Just after function entry and just before function exit, the
+ * following profiling functions are called with the address of the
+ * current function and its call site (currently not use).
+ *
+ * The attribute 'no_instrument_function' causes this instrumentation is
+ * not done.
+ *
+ * These profiling functions call print_debug(). This function prints the
+ * current function name with indentation and call level.
+ * If entering in a function it prints also the calling function name with
+ * file name and line number.
+ *
+ * If the environment variable INSTRUMENT is
+ * unset or set to an empty string, print nothing, like with no instrumentation
+ * set to "all" or "a", print all the functions names
+ * set to "global" or "g", print only the global functions names
+ */
+
+#define ND_NO_INSTRUMENT __attribute__((no_instrument_function))
+
+/* Store the function call level, used also in pretty_print_packet() */
+extern int profile_func_level;
+int profile_func_level = -1;
+
+typedef enum {
+	ENTER,
+	EXIT
+} action_type;
+
+void __cyg_profile_func_enter(void *this_fn, void *call_site) ND_NO_INSTRUMENT;
+
+void __cyg_profile_func_exit(void *this_fn, void *call_site) ND_NO_INSTRUMENT;
+
+static void print_debug(void *this_fn, void *call_site, action_type action)
+	ND_NO_INSTRUMENT;
+
+void
+__cyg_profile_func_enter(void *this_fn, void *call_site)
+{
+	print_debug(this_fn, call_site, ENTER);
+}
+
+void
+__cyg_profile_func_exit(void *this_fn, void *call_site)
+{
+	print_debug(this_fn, call_site, EXIT);
+}
+
+static void print_debug(void *this_fn, void *call_site, action_type action)
+{
+	static bfd* abfd;
+	static asymbol **symtab;
+	static long symcount;
+	static asection *text;
+	static bfd_vma vma;
+	static int instrument_set;
+	static int instrument_off;
+	static int instrument_global;
+
+	if (!instrument_set) {
+		static char *instrument_type;
+
+		/* Get the configuration environment variable INSTRUMENT value if any */
+		instrument_type = getenv("INSTRUMENT");
+		/* unset or set to an empty string ? */
+		if (instrument_type == NULL ||
+			!strncmp(instrument_type, "", sizeof(""))) {
+			instrument_off = 1;
+		} else {
+			/* set to "global" or "g" ? */
+			if (!strncmp(instrument_type, "global", sizeof("global")) ||
+				!strncmp(instrument_type, "g", sizeof("g")))
+				instrument_global = 1;
+			else if (strncmp(instrument_type, "all", sizeof("all")) &&
+					 strncmp(instrument_type, "a", sizeof("a"))) {
+				fprintf(stderr, "INSTRUMENT can be only \"\", \"all\", \"a\", "
+						"\"global\" or \"g\".\n");
+				exit(1);
+			}
+		}
+		instrument_set = 1;
+	}
+
+	if (instrument_off)
+			return;
+
+	/* If no errors, this block should be executed one time */
+	if (!abfd) {
+		char pgm_name[1024];
+		long symsize;
+
+		ssize_t ret = readlink("/proc/self/exe", pgm_name, sizeof(pgm_name));
+		if (ret == -1) {
+			perror("failed to find executable");
+			return;
+		}
+		if (ret == sizeof(pgm_name)) {
+			/* no space for the '\0' */
+			printf("truncation may have occurred\n");
+			return;
+		}
+		pgm_name[ret] = '\0';
+
+		bfd_init();
+
+		abfd = bfd_openr(pgm_name, NULL);
+		if (!abfd) {
+			bfd_perror("bfd_openr");
+			return;
+		}
+
+		if (!bfd_check_format(abfd, bfd_object)) {
+			bfd_perror("bfd_check_format");
+			return;
+		}
+
+		if((symsize = bfd_get_symtab_upper_bound(abfd)) == -1) {
+			bfd_perror("bfd_get_symtab_upper_bound");
+			return;
+		}
+
+		symtab = (asymbol **)malloc((size_t)symsize);
+		symcount = bfd_canonicalize_symtab(abfd, symtab);
+		if (symcount < 0) {
+			free(symtab);
+			bfd_perror("bfd_canonicalize_symtab");
+			return;
+		}
+
+		if ((text = bfd_get_section_by_name(abfd, ".text")) == NULL) {
+			bfd_perror("bfd_get_section_by_name");
+			return;
+		}
+		vma = text->vma;
+	}
+
+	if (instrument_global) {
+		symbol_info syminfo;
+		int found;
+		long i;
+
+		i = 0;
+		found = 0;
+		while (i < symcount && !found) {
+			bfd_get_symbol_info(abfd, symtab[i], &syminfo);
+			if ((void *)syminfo.value == this_fn) {
+				found = 1;
+			}
+			i++;
+		}
+		/* type == 'T' for a global function */
+		if (found == 1 && syminfo.type != 'T')
+			return;
+	}
+
+	/* Current function */
+	if ((bfd_vma)this_fn < vma) {
+		printf("[ERROR address this_fn]");
+	} else {
+		const char *file;
+		const char *func;
+		unsigned int line;
+
+		if (!bfd_find_nearest_line(abfd, text, symtab, (bfd_vma)this_fn - vma,
+								   &file, &func, &line)) {
+			printf("[ERROR bfd_find_nearest_line this_fn]");
+		} else {
+			int i;
+
+			if (action == ENTER)
+				profile_func_level += 1;
+			/* Indentation */
+			for (i = 0 ; i < profile_func_level ; i++)
+				putchar(' ');
+			if (action == ENTER)
+				printf("[>> ");
+			else
+				printf("[<< ");
+			/* Function name */
+			if (func == NULL || *func == '\0')
+				printf("???");
+			else
+				printf("%s", func);
+			printf(" (%d)", profile_func_level);
+			/* Print the "from" part except for the main function) */
+			if (action == ENTER && func != NULL &&
+				strncmp(func, "main", sizeof("main"))) {
+				/* Calling function */
+				if ((bfd_vma)call_site < vma) {
+					printf("[ERROR address call_site]");
+				} else {
+					if (!bfd_find_nearest_line(abfd, text, symtab,
+											   (bfd_vma)call_site - vma, &file,
+											   &func, &line)) {
+						printf("[ERROR bfd_find_nearest_line call_site]");
+					} else {
+						printf(" from ");
+						/* Function name */
+						if (func == NULL || *func == '\0')
+							printf("???");
+						else
+							printf("%s", func);
+						/* File name */
+						if (file == NULL || *file == '\0')
+							printf(" ??:");
+						else {
+							char *slashp = strrchr(file, '/');
+							if (slashp != NULL)
+								file = slashp + 1;
+							printf(" %s:", file);
+						}
+						/* Line number */
+						if (line == 0)
+							printf("?");
+						else
+							printf("%u", line);
+						printf("]");
+					}
+				}
+			}
+			putchar('\n');
+			if (action == EXIT)
+				profile_func_level -= 1;
+		}
+	}
+	fflush(stdout);
+}
+
+/* vi: set tabstop=4 softtabstop=0 shiftwidth=4 smarttab autoindent : */
diff --git a/missing/asprintf.c b/missing/asprintf.c
index b65310e1..7c636927 100644
--- a/missing/asprintf.c
+++ b/missing/asprintf.c
@@ -11,7 +11,7 @@
  * it been given an infinite-sized buffer.
  */
 int
-pcap_vasprintf(char **strp, const char *format, va_list args)
+pcapint_vasprintf(char **strp, const char *format, va_list args)
 {
 	char buf;
 	int len;
@@ -21,7 +21,7 @@ pcap_vasprintf(char **strp, const char *format, va_list args)
 
 	/*
 	 * XXX - the C99 standard says, in section 7.19.6.5 "The
-	 * nprintf function":
+	 * snprintf function":
 	 *
 	 *    The snprintf function is equivalent to fprintf, except that
 	 *    the output is written into an array (specified by argument s)
@@ -88,13 +88,13 @@ pcap_vasprintf(char **strp, const char *format, va_list args)
 }
 
 int
-pcap_asprintf(char **strp, const char *format, ...)
+pcapint_asprintf(char **strp, const char *format, ...)
 {
 	va_list args;
 	int ret;
 
 	va_start(args, format);
-	ret = pcap_vasprintf(strp, format, args);
+	ret = pcapint_vasprintf(strp, format, args);
 	va_end(args);
 	return (ret);
 }
diff --git a/missing/strlcat.c b/missing/strlcat.c
index bb78a3d0..f96d37b3 100644
--- a/missing/strlcat.c
+++ b/missing/strlcat.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pcap_strlcat.c,v 1.15 2015/03/02 21:41:08 millert Exp $	*/
+/*	$OpenBSD: strlcat.c,v 1.15 2015/03/02 21:41:08 millert Exp $	*/
 
 /*
  * Copyright (c) 1998, 2015 Todd C. Miller <Todd.Miller@courtesan.com>
@@ -16,9 +16,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stddef.h>
 #include <string.h>
@@ -33,7 +31,7 @@
  * If retval >= dsize, truncation occurred.
  */
 size_t
-pcap_strlcat(char * restrict dst, const char * restrict src, size_t dsize)
+pcapint_strlcat(char * restrict dst, const char * restrict src, size_t dsize)
 {
 	const char *odst = dst;
 	const char *osrc = src;
diff --git a/missing/strlcpy.c b/missing/strlcpy.c
index c552e0d5..494ff773 100644
--- a/missing/strlcpy.c
+++ b/missing/strlcpy.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pcap_strlcpy.c,v 1.12 2015/01/15 03:54:12 millert Exp $	*/
+/*	$OpenBSD: strlcpy.c,v 1.12 2015/01/15 03:54:12 millert Exp $	*/
 
 /*
  * Copyright (c) 1998, 2015 Todd C. Miller <Todd.Miller@courtesan.com>
@@ -16,9 +16,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stddef.h>
 #include <string.h>
@@ -31,7 +29,7 @@
  * Returns strlen(src); if retval >= dsize, truncation occurred.
  */
 size_t
-pcap_strlcpy(char * restrict dst, const char * restrict src, size_t dsize)
+pcapint_strlcpy(char * restrict dst, const char * restrict src, size_t dsize)
 {
 	const char *osrc = src;
 	size_t nleft = dsize;
diff --git a/missing/strtok_r.c b/missing/strtok_r.c
index 5fca2f3d..0534e49a 100644
--- a/missing/strtok_r.c
+++ b/missing/strtok_r.c
@@ -34,14 +34,12 @@
  * From: @(#)strtok.c	8.1 (Berkeley) 6/4/93
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "portability.h"
 
 char *
-pcap_strtok_r(char *s, const char *delim, char **last)
+pcapint_strtok_r(char *s, const char *delim, char **last)
 {
 	char *spanp, *tok;
 	int c, sc;
diff --git a/missing/win_asprintf.c b/missing/win_asprintf.c
index e4bd13c6..076bc562 100644
--- a/missing/win_asprintf.c
+++ b/missing/win_asprintf.c
@@ -5,7 +5,7 @@
 #include "portability.h"
 
 int
-pcap_vasprintf(char **strp, const char *format, va_list args)
+pcapint_vasprintf(char **strp, const char *format, va_list args)
 {
 	int len;
 	size_t str_size;
@@ -39,13 +39,13 @@ pcap_vasprintf(char **strp, const char *format, va_list args)
 }
 
 int
-pcap_asprintf(char **strp, const char *format, ...)
+pcapint_asprintf(char **strp, const char *format, ...)
 {
 	va_list args;
 	int ret;
 
 	va_start(args, format);
-	ret = pcap_vasprintf(strp, format, args);
+	ret = pcapint_vasprintf(strp, format, args);
 	va_end(args);
 	return (ret);
 }
diff --git a/mkdep b/mkdep
index f85a447a..1bc1d0cf 100755
--- a/mkdep
+++ b/mkdep
@@ -1,4 +1,4 @@
-#!/bin/sh -
+#!/bin/sh -e
 #
 # Copyright (c) 1994, 1996
 #	The Regents of the University of California.  All rights reserved.
@@ -68,20 +68,20 @@ if [ $# = 0 ] ; then
 	exit 1
 fi
 
-if [ ! -w $MAKE ]; then
+if [ ! -w "$MAKE" ]; then
 	echo "mkdep: no writeable file \"$MAKE\""
 	exit 1
 fi
 
-TMP=/tmp/mkdep$$
+TMP=${TMPDIR:-/tmp}/mkdep$$
 
-trap 'rm -f $TMP ; exit 1' 1 2 3 13 15
+trap 'rm -f "$TMP" ; exit 1' HUP INT QUIT PIPE TERM
 
-cp $MAKE ${MAKE}.bak
+cp "$MAKE" "${MAKE}.bak"
 
-sed -e '/DO NOT DELETE THIS LINE/,$d' < $MAKE > $TMP
+sed -e '/DO NOT DELETE THIS LINE/,$d' < "$MAKE" > "$TMP"
 
-cat << _EOF_ >> $TMP
+cat << _EOF_ >> "$TMP"
 # DO NOT DELETE THIS LINE -- mkdep uses it.
 # DO NOT PUT ANYTHING AFTER THIS LINE, IT WILL GO AWAY.
 
@@ -99,23 +99,25 @@ _EOF_
 # Construct a list of source files with paths relative to the source directory.
 #
 sources=""
-for srcfile in $*
+for srcfile in "$@"
 do
 	sources="$sources $SOURCE_DIRECTORY/$srcfile"
 done
 
 # XXX this doesn't work with things like "-DDECLWAITSTATUS=union\ wait"
-$CC $DEPENDENCY_CFLAG $flags $sources |
+# $flags and $sources are meant to expand
+# shellcheck disable=SC2086
+"$CC" "$DEPENDENCY_CFLAG" $flags $sources |
 sed "
 	s; \./; ;g
-	$SED" >> $TMP
+	$SED" >> "$TMP"
 
-cat << _EOF_ >> $TMP
+cat << _EOF_ >> "$TMP"
 
 # IF YOU PUT ANYTHING HERE IT WILL GO AWAY
 _EOF_
 
 # copy to preserve permissions
-cp $TMP $MAKE
-rm -f ${MAKE}.bak $TMP
+cp "$TMP" "$MAKE"
+rm -f "${MAKE}.bak" "$TMP"
 exit 0
diff --git a/msdos/makefile b/msdos/makefile
index 84819aae..f14ed1ec 100644
--- a/msdos/makefile
+++ b/msdos/makefile
@@ -84,7 +84,7 @@ hc386.arg:  msdos\Makefile
               -Hnocopyr
               -Hpragma=Offwarn(491,553,572)
               -Hon=Recognize_library  # make memcpy/strlen etc. inline
-              -Hoff=Behaved           # turn off some optimiser warnings
+              -Hoff=Behaved           # turn off some optimizer warnings
 | $<
 
 clean:
diff --git a/msdos/makefile.dj b/msdos/makefile.dj
index 190db007..3b6f31bd 100644
--- a/msdos/makefile.dj
+++ b/msdos/makefile.dj
@@ -9,7 +9,7 @@
 # Note: you should do a "set LFN=y" before running this makefile.
 #
 
-VPATH = missing msdos bpf/net
+VPATH = missing msdos
 
 PREREQUISITES = scanner.c grammar.c tokdefs.h version.h msdos/pkt_stub.inc
 
@@ -22,7 +22,7 @@ CFLAGS += -DDEBUG -DNDIS_DEBUG -DHAVE_LIMITS_H -DHAVE_STRERROR -DHAVE_SNPRINTF -
 
 CFLAGS += -Dyylval=pcap_lval # -DBDEBUG -DNDEBUG
 
-SOURCES = grammar.c scanner.c bpf/net/bpf_filter.c bpf_image.c bpf_dump.c \
+SOURCES = grammar.c scanner.c bpf_filter.c bpf_image.c bpf_dump.c \
           etherent.c gencode.c nametoaddr.c pcap-common.c pcap-dos.c optimize.c \
           savefile.c pcap.c sf-pcap.c sf-pcapng.c \
           msdos/pktdrvr.c msdos/ndis2.c # missing/snprintf.c
diff --git a/msdos/makefile.wc b/msdos/makefile.wc
index 02460120..a0aa71fc 100644
--- a/msdos/makefile.wc
+++ b/msdos/makefile.wc
@@ -52,8 +52,8 @@ $(OBJDIR)\pktdrvr.obj: msdos\pkt_stub.inc msdos\pktdrvr.c &
   pcap-dos.h pcap-int.h pcap.h msdos\pktdrvr.h
           *$(CC) $(CFLAGS) msdos\pktdrvr.c -fo=$@
 
-$(OBJDIR)\bpf_filter.obj: bpf\net\bpf_filter.c
-          *$(CC) $(CFLAGS) bpf\net\bpf_filter.c -fo=$@
+$(OBJDIR)\bpf_filter.obj: bpf_filter.c
+          *$(CC) $(CFLAGS) bpf_filter.c -fo=$@
 
 $(OBJDIR)\ndis2.obj: msdos\ndis2.c
           *$(CC) $(CFLAGS) msdos\ndis2.c -fo=$@
@@ -94,7 +94,7 @@ clean realclean vclean: .SYMBOLIC
 #
 # dependencies
 #
-$(OBJDIR)\bpf_filter.obj: bpf\net\bpf_filter.c pcap-int.h pcap.h pcap-bpf.h
+$(OBJDIR)\bpf_filter.obj: bpf_filter.c pcap-int.h pcap.h pcap-bpf.h
 
 $(OBJDIR)\bpf_imag.obj: bpf_imag.c pcap-int.h pcap.h pcap-bpf.h
 
diff --git a/msdos/pktdrvr.c b/msdos/pktdrvr.c
index 37fc8a41..8ee5f920 100644
--- a/msdos/pktdrvr.c
+++ b/msdos/pktdrvr.c
@@ -294,7 +294,7 @@ PUBLIC char const *PktRXmodeStr (PKT_RX_MODE mode)
                     "Receive direct & broadcast packets",
                     "Receive direct,broadcast and limited multicast packets",
                     "Receive direct,broadcast and all multicast packets",
-                    "Receive all packets (promiscuouos mode)"
+                    "Receive all packets (promiscuous mode)"
                   };
 
   if (mode > DIM(modeStr))
diff --git a/msdos/pktdrvr.h b/msdos/pktdrvr.h
index 3e0cfe01..82a10265 100644
--- a/msdos/pktdrvr.h
+++ b/msdos/pktdrvr.h
@@ -47,7 +47,7 @@ typedef struct {
 
 
 typedef struct {
-        BYTE  class;        /* = 1 for DEC/Interl/Xerox Ethernet */
+        BYTE  class;        /* = 1 for DEC/Intel/Xerox Ethernet  */
         BYTE  number;       /* = 0 for single LAN adapter        */
         WORD  type;         /* = 13 for 3C523                    */
         BYTE  funcs;        /* Basic/Extended/HiPerf functions   */
diff --git a/msdos/readme.dos b/msdos/readme.dos
index ec056dd0..d2bb2112 100644
--- a/msdos/readme.dos
+++ b/msdos/readme.dos
@@ -13,7 +13,7 @@ supported:
 Note: the files in the libpcap.zip contains short truncated filenames.
   So for djgpp to work with these, disable the use of long file names by
   setting "LFN=n" in the environment. On the other hand, if you get libpcap
-  from Github or the official libpcap.tar.gz, some filenames are beyond 8+3.
+  from GitHub or the official libpcap.tar.gz, some filenames are beyond 8+3.
   In this case set "LFN=y".
 
 Files specific to DOS are pcap-dos.[ch] and the assembly and C files in
@@ -53,7 +53,7 @@ The following packages and tools must be present for all targets.
 
      https://www.watt-32.net
 
-2. Exception handler and disassember library (libexc.a) is needed if
+2. Exception handler and disassembler library (libexc.a) is needed if
    "USE_EXCEPT = 1" in common.dj. Available at:
 
      https://www.watt-32.net/misc/exc_dx07.zip
diff --git a/nametoaddr.c b/nametoaddr.c
index 7a04a61d..d5cb981c 100644
--- a/nametoaddr.c
+++ b/nametoaddr.c
@@ -22,9 +22,7 @@
  * These functions are not time critical.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #ifdef DECNETLIB
 #include <sys/types.h>
@@ -140,6 +138,8 @@
 #include <pcap/namedb.h>
 #include "nametoaddr.h"
 
+#include "thread-local.h"
+
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
 #endif
@@ -470,40 +470,33 @@ pcap_nametoport(const char *name, int *port, int *proto)
 int
 pcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)
 {
-	u_int p1, p2;
 	char *off, *cpy;
 	int save_proto;
 
-	if (sscanf(name, "%d-%d", &p1, &p2) != 2) {
-		if ((cpy = strdup(name)) == NULL)
-			return 0;
+	if ((cpy = strdup(name)) == NULL)
+		return 0;
 
-		if ((off = strchr(cpy, '-')) == NULL) {
-			free(cpy);
-			return 0;
-		}
+	if ((off = strchr(cpy, '-')) == NULL) {
+		free(cpy);
+		return 0;
+	}
 
-		*off = '\0';
+	*off = '\0';
 
-		if (pcap_nametoport(cpy, port1, proto) == 0) {
-			free(cpy);
-			return 0;
-		}
-		save_proto = *proto;
+	if (pcap_nametoport(cpy, port1, proto) == 0) {
+		free(cpy);
+		return 0;
+	}
+	save_proto = *proto;
 
-		if (pcap_nametoport(off + 1, port2, proto) == 0) {
-			free(cpy);
-			return 0;
-		}
+	if (pcap_nametoport(off + 1, port2, proto) == 0) {
 		free(cpy);
+		return 0;
+	}
+	free(cpy);
 
-		if (*proto != save_proto)
-			*proto = PROTO_UNDEF;
-	} else {
-		*port1 = p1;
-		*port2 = p2;
+	if (*proto != save_proto)
 		*proto = PROTO_UNDEF;
-	}
 
 	return 1;
 }
@@ -742,16 +735,18 @@ pcap_ether_aton(const char *s)
 #ifndef HAVE_ETHER_HOSTTON
 /*
  * Roll our own.
- * XXX - not thread-safe, because pcap_next_etherent() isn't thread-
- * safe!  Needs a mutex or a thread-safe pcap_next_etherent().
+ *
+ * This should be thread-safe, as we define the static variables
+ * we use to be thread-local, and as pcap_next_etherent() does so
+ * as well.
  */
 u_char *
 pcap_ether_hostton(const char *name)
 {
 	register struct pcap_etherent *ep;
 	register u_char *ap;
-	static FILE *fp = NULL;
-	static int init = 0;
+	static thread_local FILE *fp = NULL;
+	static thread_local int init = 0;
 
 	if (!init) {
 		fp = fopen(PCAP_ETHERS_FILE, "r");
@@ -790,7 +785,7 @@ pcap_ether_hostton(const char *name)
 	/*
 	 * In AIX 7.1 and 7.2: int ether_hostton(char *, struct ether_addr *);
 	 */
-	pcap_strlcpy(namebuf, name, sizeof(namebuf));
+	pcapint_strlcpy(namebuf, name, sizeof(namebuf));
 	ap = NULL;
 	if (ether_hostton(namebuf, (struct ether_addr *)a) == 0) {
 		ap = (u_char *)malloc(6);
diff --git a/nlpid.h b/nlpid.h
index 9dfa752b..b730d3d4 100644
--- a/nlpid.h
+++ b/nlpid.h
@@ -19,7 +19,7 @@
 /* Types missing from some systems */
 
 /*
- * Network layer prototocol identifiers
+ * Network layer protocol identifiers
  */
 #ifndef ISO8473_CLNP
 #define ISO8473_CLNP		0x81
diff --git a/optimize.c b/optimize.c
index 9af4c15d..d7094934 100644
--- a/optimize.c
+++ b/optimize.c
@@ -21,9 +21,7 @@
  *  Optimization module for BPF code intermediate representation.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 
@@ -207,7 +205,7 @@ lowest_set_bit(int mask)
 #define AX_ATOM N_ATOMS
 
 /*
- * These data structures are used in a Cocke and Shwarz style
+ * These data structures are used in a Cocke and Schwartz style
  * value numbering scheme.  Since the flowgraph is acyclic,
  * exit values can be propagated from a node's predecessors
  * provided it is uniquely defined.
@@ -1467,6 +1465,12 @@ opt_deadstores(opt_state_t *opt_state, register struct block *b)
 	for (atom = 0; atom < N_ATOMS; ++atom)
 		if (last[atom] && !ATOMELEM(b->out_use, atom)) {
 			last[atom]->code = NOP;
+			/*
+			 * The store was removed as it's dead,
+			 * so the value stored into now has
+			 * an unknown value.
+			 */
+			vstore(0, &b->val[atom], VAL_UNKNOWN, 0);
 			/*
 			 * XXX - optimizer loop detection.
 			 */
@@ -1815,7 +1819,7 @@ opt_j(opt_state_t *opt_state, struct edge *ep)
  *
  */
 static void
-or_pullup(opt_state_t *opt_state, struct block *b)
+or_pullup(opt_state_t *opt_state, struct block *b, struct block *root)
 {
 	bpf_u_int32 val;
 	int at_top;
@@ -1976,10 +1980,15 @@ or_pullup(opt_state_t *opt_state, struct block *b)
 	 * optimizer gets into one of those infinite loops.
 	 */
 	opt_state->done = 0;
+
+	/*
+	 * Recompute dominator sets as control flow graph has changed.
+	 */
+	find_dom(opt_state, root);
 }
 
 static void
-and_pullup(opt_state_t *opt_state, struct block *b)
+and_pullup(opt_state_t *opt_state, struct block *b, struct block *root)
 {
 	bpf_u_int32 val;
 	int at_top;
@@ -2072,6 +2081,11 @@ and_pullup(opt_state_t *opt_state, struct block *b)
 	 * optimizer gets into one of those infinite loops.
 	 */
 	opt_state->done = 0;
+
+	/*
+	 * Recompute dominator sets as control flow graph has changed.
+	 */
+	find_dom(opt_state, root);
 }
 
 static void
@@ -2118,8 +2132,8 @@ opt_blks(opt_state_t *opt_state, struct icode *ic, int do_stmts)
 	find_inedges(opt_state, ic->root);
 	for (i = 1; i <= maxlevel; ++i) {
 		for (p = opt_state->levels[i]; p; p = p->link) {
-			or_pullup(opt_state, p);
-			and_pullup(opt_state, p);
+			or_pullup(opt_state, p, ic->root);
+			and_pullup(opt_state, p, ic->root);
 		}
 	}
 }
@@ -2942,14 +2956,14 @@ conv_error(conv_state_t *conv_state, const char *fmt, ...)
  * otherwise, return 0.
  */
 int
-install_bpf_program(pcap_t *p, struct bpf_program *fp)
+pcapint_install_bpf_program(pcap_t *p, struct bpf_program *fp)
 {
 	size_t prog_size;
 
 	/*
 	 * Validate the program.
 	 */
-	if (!pcap_validate_filter(fp->bf_insns, fp->bf_len)) {
+	if (!pcapint_validate_filter(fp->bf_insns, fp->bf_len)) {
 		snprintf(p->errbuf, sizeof(p->errbuf),
 			"BPF program is not valid");
 		return (-1);
@@ -2964,7 +2978,7 @@ install_bpf_program(pcap_t *p, struct bpf_program *fp)
 	p->fcode.bf_len = fp->bf_len;
 	p->fcode.bf_insns = (struct bpf_insn *)malloc(prog_size);
 	if (p->fcode.bf_insns == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "malloc");
 		return (-1);
 	}
diff --git a/pcap-airpcap.c b/pcap-airpcap.c
index 510e4c4e..6d5d2508 100644
--- a/pcap-airpcap.c
+++ b/pcap-airpcap.c
@@ -31,9 +31,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "pcap-int.h"
 
@@ -169,27 +167,27 @@ load_airpcap_functions(void)
 	 */
 	current_status = AIRPCAP_API_CANNOT_LOAD;
 
-	airpcap_lib = pcap_load_code("airpcap.dll");
+	airpcap_lib = pcapint_load_code("airpcap.dll");
 	if (airpcap_lib != NULL) {
 		/*
 		 * OK, we've loaded the library; now try to find the
 		 * functions we need in it.
 		 */
-		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
-		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
-		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
-		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
-		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
-		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
-		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
-		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
-		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
-		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
-		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
-		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
-		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
-		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
-		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
+		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcapint_find_function(airpcap_lib, "AirpcapGetLastError");
+		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcapint_find_function(airpcap_lib, "AirpcapGetDeviceList");
+		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcapint_find_function(airpcap_lib, "AirpcapFreeDeviceList");
+		p_AirpcapOpen = (AirpcapOpenHandler) pcapint_find_function(airpcap_lib, "AirpcapOpen");
+		p_AirpcapClose = (AirpcapCloseHandler) pcapint_find_function(airpcap_lib, "AirpcapClose");
+		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcapint_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
+		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcapint_find_function(airpcap_lib, "AirpcapSetLinkType");
+		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcapint_find_function(airpcap_lib, "AirpcapGetLinkType");
+		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcapint_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
+		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcapint_find_function(airpcap_lib, "AirpcapSetFilter");
+		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcapint_find_function(airpcap_lib, "AirpcapSetMinToCopy");
+		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcapint_find_function(airpcap_lib, "AirpcapGetReadEvent");
+		p_AirpcapRead = (AirpcapReadHandler) pcapint_find_function(airpcap_lib, "AirpcapRead");
+		p_AirpcapWrite = (AirpcapWriteHandler) pcapint_find_function(airpcap_lib, "AirpcapWrite");
+		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcapint_find_function(airpcap_lib, "AirpcapGetStats");
 
 		//
 		// Make sure that we found everything
@@ -275,11 +273,11 @@ airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
 		 */
 
 		/*
-		 * install_bpf_program() validates the program.
+		 * pcapint_install_bpf_program() validates the program.
 		 *
 		 * XXX - what if we already have a filter in the kernel?
 		 */
-		if (install_bpf_program(p, fp) < 0)
+		if (pcapint_install_bpf_program(p, fp) < 0)
 			return (-1);
 		pa->filtering_in_kernel = 0;	/* filtering in userland */
 		return (0);
@@ -670,7 +668,7 @@ airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		 */
 		if (pa->filtering_in_kernel ||
 		    p->fcode.bf_insns == NULL ||
-		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
+		    pcapint_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
 			struct pcap_pkthdr pkthdr;
 
 			pkthdr.ts.tv_sec = bhp->TsSec;
@@ -732,7 +730,7 @@ airpcap_cleanup(pcap_t *p)
 		p_AirpcapClose(pa->adapter);
 		pa->adapter = NULL;
 	}
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static void
@@ -740,7 +738,7 @@ airpcap_breakloop(pcap_t *p)
 {
 	HANDLE read_event;
 
-	pcap_breakloop_common(p);
+	pcapint_breakloop_common(p);
 	struct pcap_airpcap *pa = p->priv;
 
 	/* XXX - what if either of these fail? */
@@ -822,7 +820,7 @@ airpcap_activate(pcap_t *p)
 	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		goto bad;
 	}
@@ -896,8 +894,11 @@ airpcap_activate(pcap_t *p)
 	 * followed by PPI, followed by "no radio metadata".
 	 */
 	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
-	if (p->dlt_list == NULL)
+	if (p->dlt_list == NULL) {
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		    errno, "malloc");
 		goto bad;
+	}
 	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
 	p->dlt_list[1] = DLT_PPI;
 	p->dlt_list[2] = DLT_IEEE802_11;
@@ -1040,7 +1041,7 @@ airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 
 	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
 	    airpcap_device = airpcap_device->next) {
-		if (add_dev(devlistp, airpcap_device->Name, 0,
+		if (pcapint_add_dev(devlistp, airpcap_device->Name, 0,
 		    airpcap_device->Description, errbuf) == NULL) {
 			/*
 			 * Failure.
diff --git a/pcap-bpf.c b/pcap-bpf.c
index 2898e598..b9e84e65 100644
--- a/pcap-bpf.c
+++ b/pcap-bpf.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>			/* optionally get BSD define */
 #include <sys/socket.h>
@@ -122,6 +120,7 @@ static int bpf_load(char *errbuf);
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stddef.h>
 
 #ifdef SIOCGIFMEDIA
 # include <net/if_media.h>
@@ -263,7 +262,7 @@ pcap_getnonblock_bpf(pcap_t *p)
 	if (pb->zerocopy)
 		return (pb->nonblock);
 #endif
-	return (pcap_getnonblock_fd(p));
+	return (pcapint_getnonblock_fd(p));
 }
 
 static int
@@ -277,7 +276,7 @@ pcap_setnonblock_bpf(pcap_t *p, int nonblock)
 		return (0);
 	}
 #endif
-	return (pcap_setnonblock_fd(p, nonblock));
+	return (pcapint_setnonblock_fd(p, nonblock));
 }
 
 #ifdef HAVE_ZEROCOPY_BPF
@@ -352,7 +351,7 @@ pcap_next_zbuf(pcap_t *p, int *cc)
 	 * sure that the timeout gets adjusted accordingly.  This requires
 	 * that we analyze when the timeout should be been expired, and
 	 * subtract the current time from that.  If after this operation,
-	 * our timeout is less then or equal to zero, handle it like a
+	 * our timeout is less than or equal to zero, handle it like a
 	 * regular timeout.
 	 */
 	tmout = p->opt.timeout;
@@ -368,7 +367,7 @@ pcap_next_zbuf(pcap_t *p, int *cc)
 			if (data)
 				return (data);
 			if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "BIOCROTZBUF");
 				return (PCAP_ERROR);
 			}
@@ -396,7 +395,7 @@ pcap_next_zbuf(pcap_t *p, int *cc)
 			}
 			return (0);
 		} else if (r < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "select");
 			return (PCAP_ERROR);
 		}
@@ -415,7 +414,7 @@ pcap_next_zbuf(pcap_t *p, int *cc)
 	 * data.
 	 */
 	if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCROTZBUF");
 		return (PCAP_ERROR);
 	}
@@ -440,7 +439,7 @@ pcap_ack_zbuf(pcap_t *p)
 #endif /* HAVE_ZEROCOPY_BPF */
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -457,7 +456,7 @@ pcap_create_interface(const char *device _U_, char *ebuf)
 	 */
 	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
 	if (p->tstamp_precision_list == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
 		    "malloc");
 		free(p);
 		return (NULL);
@@ -510,7 +509,7 @@ bpf_open(char *errbuf)
 				    cloning_device);
 			} else {
 				fd = PCAP_ERROR;
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "(cannot open device) %s", cloning_device);
 			}
@@ -554,13 +553,13 @@ bpf_open(char *errbuf)
 		switch (errno) {
 
 		case ENOENT:
-			fd = PCAP_ERROR;
 			if (n == 1) {
 				/*
 				 * /dev/bpf0 doesn't exist, which
 				 * means we probably have no BPF
 				 * devices.
 				 */
+				fd = PCAP_ERROR_CAPTURE_NOTSUP;
 				snprintf(errbuf, PCAP_ERRBUF_SIZE,
 				    "(there are no BPF devices)");
 			} else {
@@ -570,6 +569,7 @@ bpf_open(char *errbuf)
 				 * devices, but all the ones
 				 * that exist are busy.
 				 */
+				fd = PCAP_ERROR;
 				snprintf(errbuf, PCAP_ERRBUF_SIZE,
 				    "(all BPF devices are busy)");
 			}
@@ -592,7 +592,7 @@ bpf_open(char *errbuf)
 			 * Some other problem.
 			 */
 			fd = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "(cannot open BPF device) %s", device);
 			break;
 		}
@@ -606,7 +606,7 @@ bpf_open(char *errbuf)
  * BPF device and the name of the network adapter.
  *
  * Use BIOCSETLIF if available (meaning "on Solaris"), as it supports
- * longer device names.
+ * longer device names and binding to devices in other zones.
  *
  * If the name is longer than will fit, return PCAP_ERROR_NO_SUCH_DEVICE
  * before trying to bind the interface, as there cannot be such a device.
@@ -615,18 +615,13 @@ bpf_open(char *errbuf)
  *
  * If the attempt fails:
  *
- *    if it fails with ENXIO, return PCAP_ERROR_NO_SUCH_DEVICE, as
- *    the device doesn't exist;
- *
- *    if it fails with ENETDOWN, return PCAP_ERROR_IFACE_NOT_UP, as
- *    the interface exists but isn't up and the OS doesn't allow
- *    binding to an interface that isn't up;
- *
  *    if it fails with ENOBUFS, return BPF_BIND_BUFFER_TOO_BIG, and
  *    fill in an error message, as the buffer being requested is too
- *    large;
+ *    large - our caller may try a smaller buffer if no buffer size
+ *    was explicitly specified.
  *
- *    otherwise, return PCAP_ERROR and fill in an error message.
+ *    otherwise, return the appropriate PCAP_ERROR_ code and
+ *    fill in an error message.
  */
 #define BPF_BIND_SUCCEEDED	0
 #define BPF_BIND_BUFFER_TOO_BIG	1
@@ -637,12 +632,118 @@ bpf_bind(int fd, const char *name, char *errbuf)
 	int status;
 #ifdef LIFNAMSIZ
 	struct lifreq ifr;
+	const char *ifname = name;
+
+  #if defined(ZONENAME_MAX) && defined(lifr_zoneid)
+	char *zonesep;
+
+	/*
+	 * We have support for zones.
+	 * Retrieve the zoneid of the zone we are currently executing in.
+	 */
+	if ((ifr.lifr_zoneid = getzoneid()) == -1) {
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		    errno, "getzoneid()");
+		return (PCAP_ERROR);
+	}
+
+	/*
+	 * Check if the given source datalink name has a '/' separated
+	 * zonename prefix string.  The zonename prefixed source datalink can
+	 * be used by pcap consumers in the Solaris global zone to capture
+	 * traffic on datalinks in non-global zones.  Non-global zones
+	 * do not have access to datalinks outside of their own namespace.
+	 */
+	if ((zonesep = strchr(name, '/')) != NULL) {
+		char *zname;
+		ptrdiff_t znamelen;
+
+		if (ifr.lifr_zoneid != GLOBAL_ZONEID) {
+			/*
+			 * We treat this as a generic error rather
+			 * than as "permission denied" because
+			 * this isn't a case of "you don't have
+			 * enough permission to capture on this
+			 * device, so you'll have to do something
+			 * to get that permission" (such as
+			 * configuring the system to allow non-root
+			 * users to capture traffic), it's a case
+			 * of "nobody has permission to do this,
+			 * so there's nothing to do to fix it
+			 * other than running the capture program
+			 * in the global zone or the zone containing
+			 * the adapter".
+			 *
+			 * (And, yes, this is a real issue; for example,
+			 * Wireshark might make platform-specific suggestions
+			 * on how to fix a PCAP_ERROR_PERM_DENIED problem,
+			 * none of which will help here.)
+			 */
+			snprintf(errbuf, PCAP_ERRBUF_SIZE,
+			    "zonename/linkname only valid in global zone.");
+			return (PCAP_ERROR);
+		}
+		znamelen = zonesep - name;
+		zname = malloc(znamelen + 1);
+		if (zname == NULL) {
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			return (PCAP_ERROR);
+		}
+		memcpy(zname, name, znamelen + 1);
+		zname[znamelen] = '\0';
+		ifr.lifr_zoneid = getzoneidbyname(zname);
+		if (ifr.lifr_zoneid == -1) {
+			switch (errno) {
+
+			case EINVAL:
+			case ENAMETOOLONG:
+				/*
+				 * If the name's length exceeds
+				 * ZONENAMEMAX, clearly there cannot
+				 * be such a zone; it's not clear that
+				 * "that name's too long for a zone"
+				 * is more informative than "there's
+				 * no such zone".
+				 */
+				snprintf(errbuf, PCAP_ERRBUF_SIZE,
+				    "There is no zone named \"%s\"",
+				    zname);
 
-	if (strlen(name) >= sizeof(ifr.lifr_name)) {
+				/*
+				 * No such zone means the name
+				 * refers to a non-existent interface.
+				 */
+				status = PCAP_ERROR_NO_SUCH_DEVICE;
+				break;
+
+			default:
+				pcapint_fmt_errmsg_for_errno(errbuf,
+				    PCAP_ERRBUF_SIZE, errno,
+				    "getzoneidbyname(%s)", zname);
+				status = PCAP_ERROR;
+				break;
+			}
+			free(zname);
+			return (status);
+		}
+		free(zname);
+
+		/*
+		 * To bind to this interface, we set the ifr.lifr_zoneid
+		 * to the zone ID of its zone (done above), and we set
+		 * ifr.lifr_name to the name of the interface within that
+		 * zone (done below, using ifname).
+		 */
+		ifname = zonesep + 1;
+	}
+  #endif
+
+	if (strlen(ifname) >= sizeof(ifr.lifr_name)) {
 		/* The name is too long, so it can't possibly exist. */
 		return (PCAP_ERROR_NO_SUCH_DEVICE);
 	}
-	(void)pcap_strlcpy(ifr.lifr_name, name, sizeof(ifr.lifr_name));
+	(void)pcapint_strlcpy(ifr.lifr_name, ifname, sizeof(ifr.lifr_name));
 	status = ioctl(fd, BIOCSETLIF, (caddr_t)&ifr);
 #else
 	struct ifreq ifr;
@@ -651,14 +752,26 @@ bpf_bind(int fd, const char *name, char *errbuf)
 		/* The name is too long, so it can't possibly exist. */
 		return (PCAP_ERROR_NO_SUCH_DEVICE);
 	}
-	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
+	(void)pcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 	status = ioctl(fd, BIOCSETIF, (caddr_t)&ifr);
 #endif
 
 	if (status < 0) {
 		switch (errno) {
 
+#if defined(HAVE_SOLARIS)
+		/*
+		 * For some reason, Solaris 11 appears to return ESRCH
+		 * for unknown devices.
+		 */
+		case ESRCH:
+#else
+		/*
+		 * The *BSDs (including CupertinoBSD a/k/a Darwin)
+		 * return ENXIO for unknown devices.
+		 */
 		case ENXIO:
+#endif
 			/*
 			 * There's no such device.
 			 *
@@ -686,13 +799,13 @@ bpf_bind(int fd, const char *name, char *errbuf)
 			 * we have to continue; add an error message that
 			 * tells the user what needs to be fixed.
 			 */
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "The requested buffer size for %s is too large",
 			    name);
 			return (BPF_BIND_BUFFER_TOO_BIG);
 
 		default:
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "Binding interface %s to BPF device failed",
 			    name);
 			return (PCAP_ERROR);
@@ -756,7 +869,7 @@ device_exists(int fd, const char *name, char *errbuf)
 		/* The name is too long, so it can't possibly exist. */
 		return (PCAP_ERROR_NO_SUCH_DEVICE);
 	}
-	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
+	(void)pcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 	status = ioctl(fd, SIOCGIFFLAGS, (caddr_t)&ifr);
 
 	if (status < 0) {
@@ -774,7 +887,7 @@ device_exists(int fd, const char *name, char *errbuf)
 		 * Some other error - provide a message for it, as
 		 * it's "unexpected".
 		 */
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
 		    "Can't get interface flags on %s", name);
 		return (PCAP_ERROR);
 	}
@@ -797,13 +910,13 @@ get_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)
 
 		bdlp->bfl_list = (u_int *) malloc(sizeof(u_int) * (bdlp->bfl_len + 1));
 		if (bdlp->bfl_list == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return (PCAP_ERROR);
 		}
 
 		if (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) < 0) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCGDLTLIST");
 			free(bdlp->bfl_list);
 			return (PCAP_ERROR);
@@ -858,7 +971,7 @@ get_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)
 		 * this device"; don't treat it as an error.
 		 */
 		if (errno != EINVAL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCGDLTLIST");
 			return (PCAP_ERROR);
 		}
@@ -928,12 +1041,12 @@ pcap_can_set_rfmon_bpf(pcap_t *p)
 		}
 		fd = socket(AF_INET, SOCK_DGRAM, 0);
 		if (fd == -1) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "socket");
 			return (PCAP_ERROR);
 		}
-		if (pcap_asprintf(&wlt_name, "wlt%s", p->opt.device + 2) == -1) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		if (pcapint_asprintf(&wlt_name, "wlt%s", p->opt.device + 2) == -1) {
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			close(fd);
 			return (PCAP_ERROR);
@@ -1046,13 +1159,17 @@ pcap_stats_bpf(pcap_t *p, struct pcap_stat *ps)
 	 * by libpcap, and thus not yet seen by the application.
 	 */
 	if (ioctl(p->fd, BIOCGSTATS, (caddr_t)&s) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCGSTATS");
 		return (PCAP_ERROR);
 	}
 
-	ps->ps_recv = s.bs_recv;
-	ps->ps_drop = s.bs_drop;
+	/*
+	 * On illumos, NetBSD and Solaris these values are 64-bit, but struct
+	 * pcap_stat is what it is, so the integer precision loss is expected.
+	 */
+	ps->ps_recv = (u_int)s.bs_recv;
+	ps->ps_drop = (u_int)s.bs_drop;
 	ps->ps_ifdrop = 0;
 	return (0);
 }
@@ -1061,7 +1178,7 @@ static int
 pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 {
 	struct pcap_bpf *pb = p->priv;
-	int cc;
+	ssize_t cc;
 	int n = 0;
 	register u_char *bp, *ep;
 	u_char *datap;
@@ -1107,7 +1224,7 @@ pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		} else
 #endif
 		{
-			cc = (int)read(p->fd, p->buffer, p->bufsize);
+			cc = read(p->fd, p->buffer, p->bufsize);
 		}
 		if (cc < 0) {
 			/* Don't choke when we get ptraced */
@@ -1177,7 +1294,7 @@ pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 				/* fall through */
 #endif
 			}
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "read");
 			return (PCAP_ERROR);
 		}
@@ -1255,7 +1372,7 @@ pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 #endif
 		 */
 		if (pb->filtering_in_kernel ||
-		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
+		    pcapint_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
 			struct pcap_pkthdr pkthdr;
 #ifdef BIOCSTSTAMP
 			struct bintime bt;
@@ -1284,7 +1401,13 @@ pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 			 */
 			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec/1000;
 #else
-			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec;
+			/*
+			 * On NetBSD the former (timeval.tv_usec) is an int via
+			 * suseconds_t and the latter (bpf_timeval.tv_usec) is
+			 * a long.  In any case, the value is supposed to be
+			 * within the [0 .. 999999] interval.
+			 */
+			pkthdr.ts.tv_usec = (suseconds_t)bhp->bh_tstamp.tv_usec;
 #endif
 #endif /* BIOCSTSTAMP */
 #ifdef PCAP_FDDIPAD
@@ -1354,7 +1477,7 @@ pcap_inject_bpf(pcap_t *p, const void *buf, int size)
 		u_int spoof_eth_src = 0;
 
 		if (ioctl(p->fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "send: can't turn off BIOCSHDRCMPLT");
 			return (PCAP_ERROR);
 		}
@@ -1366,7 +1489,7 @@ pcap_inject_bpf(pcap_t *p, const void *buf, int size)
 	}
 #endif /* __APPLE__ */
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (PCAP_ERROR);
 	}
@@ -1455,7 +1578,7 @@ bpf_load(char *errbuf)
 
 	major = genmajor(BPF_NAME);
 	if (major == -1) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "bpf_load: genmajor failed");
 		(void)bpf_odmcleanup(NULL);
 		return (PCAP_ERROR);
@@ -1465,7 +1588,7 @@ bpf_load(char *errbuf)
 	if (!minors) {
 		minors = genminor("bpf", major, 0, BPF_MINORS, 1, 1);
 		if (!minors) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "bpf_load: genminor failed");
 			(void)bpf_odmcleanup(NULL);
 			return (PCAP_ERROR);
@@ -1477,7 +1600,7 @@ bpf_load(char *errbuf)
 
 	rc = stat(BPF_NODE "0", &sbuf);
 	if (rc == -1 && errno != ENOENT) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "bpf_load: can't stat %s", BPF_NODE "0");
 		return (PCAP_ERROR);
 	}
@@ -1487,7 +1610,7 @@ bpf_load(char *errbuf)
 			snprintf(buf, sizeof(buf), "%s%d", BPF_NODE, i);
 			unlink(buf);
 			if (mknod(buf, S_IRUSR | S_IFCHR, domakedev(major, i)) == -1) {
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "bpf_load: can't mknod %s", buf);
 				return (PCAP_ERROR);
@@ -1503,7 +1626,7 @@ bpf_load(char *errbuf)
 	    (cfg_ld.kmid == 0)) {
 		/* Driver isn't loaded, load it now */
 		if (sysconfig(SYS_SINGLELOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "bpf_load: could not load driver");
 			return (PCAP_ERROR);
 		}
@@ -1517,7 +1640,7 @@ bpf_load(char *errbuf)
 	for (i = 0; i < BPF_MINORS; i++) {
 		cfg_bpf.devno = domakedev(major, i);
 		if (sysconfig(SYS_CFGKMOD, (void *)&cfg_km, sizeof(cfg_km)) == -1) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "bpf_load: could not configure driver");
 			return (PCAP_ERROR);
 		}
@@ -1565,7 +1688,7 @@ pcap_cleanup_bpf(pcap_t *p)
 				    strerror(errno));
 			} else {
 				memset(&req, 0, sizeof(req));
-				pcap_strlcpy(req.ifm_name, pb->device,
+				pcapint_strlcpy(req.ifm_name, pb->device,
 				    sizeof(req.ifm_name));
 				if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
 					fprintf(stderr,
@@ -1579,7 +1702,7 @@ pcap_cleanup_bpf(pcap_t *p)
 						 * turn it off.
 						 */
 						memset(&ifr, 0, sizeof(ifr));
-						(void)pcap_strlcpy(ifr.ifr_name,
+						(void)pcapint_strlcpy(ifr.ifr_name,
 						    pb->device,
 						    sizeof(ifr.ifr_name));
 						ifr.ifr_media =
@@ -1608,7 +1731,7 @@ pcap_cleanup_bpf(pcap_t *p)
 
 				s = socket(AF_LOCAL, SOCK_DGRAM, 0);
 				if (s >= 0) {
-					pcap_strlcpy(ifr.ifr_name, pb->device,
+					pcapint_strlcpy(ifr.ifr_name, pb->device,
 					    sizeof(ifr.ifr_name));
 					ioctl(s, SIOCIFDESTROY, &ifr);
 					close(s);
@@ -1620,7 +1743,7 @@ pcap_cleanup_bpf(pcap_t *p)
 		 * Take this pcap out of the list of pcaps for which we
 		 * have to take the interface out of some mode.
 		 */
-		pcap_remove_from_pcaps_to_close(p);
+		pcapint_remove_from_pcaps_to_close(p);
 		pb->must_do_on_close = 0;
 	}
 
@@ -1630,7 +1753,7 @@ pcap_cleanup_bpf(pcap_t *p)
 		 * Delete the mappings.  Note that p->buffer gets
 		 * initialized to one of the mmapped regions in
 		 * this case, so do not try and free it directly;
-		 * null it out so that pcap_cleanup_live_common()
+		 * null it out so that pcapint_cleanup_live_common()
 		 * doesn't try to free it.
 		 */
 		if (pb->zbuf1 != MAP_FAILED && pb->zbuf1 != NULL)
@@ -1644,7 +1767,7 @@ pcap_cleanup_bpf(pcap_t *p)
 		free(pb->device);
 		pb->device = NULL;
 	}
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 #ifdef __APPLE__
@@ -1670,14 +1793,14 @@ check_setif_failure(pcap_t *p, int error)
 			if (fd != -1) {
 				char *en_name;
 
-				if (pcap_asprintf(&en_name, "en%s",
+				if (pcapint_asprintf(&en_name, "en%s",
 				    p->opt.device + 3) == -1) {
 					/*
 					 * We can't find out whether there's
 					 * an underlying "enN" device, so
 					 * just report "no such device".
 					 */
-					pcap_fmt_errmsg_for_errno(p->errbuf,
+					pcapint_fmt_errmsg_for_errno(p->errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "malloc");
 					close(fd);
@@ -1709,7 +1832,7 @@ check_setif_failure(pcap_t *p, int error)
 				 * just report "no such device".
 				 */
 				err = PCAP_ERROR_NO_SUCH_DEVICE;
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    errno, PCAP_ERRBUF_SIZE,
 				    "socket() failed");
 			}
@@ -1764,10 +1887,6 @@ pcap_activate_bpf(pcap_t *p)
 	int retv;
 #endif
 	int fd;
-#if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
-	struct lifreq ifr;
-	char *zonesep;
-#endif
 	struct bpf_version bv;
 #ifdef __APPLE__
 	int sockfd;
@@ -1801,7 +1920,7 @@ pcap_activate_bpf(pcap_t *p)
 	p->fd = fd;
 
 	if (ioctl(fd, BIOCVERSION, (caddr_t)&bv) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCVERSION");
 		status = PCAP_ERROR;
 		goto bad;
@@ -1825,58 +1944,9 @@ pcap_activate_bpf(pcap_t *p)
 	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
 		p->snapshot = MAXIMUM_SNAPLEN;
 
-#if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
-	/*
-	 * Retrieve the zoneid of the zone we are currently executing in.
-	 */
-	if ((ifr.lifr_zoneid = getzoneid()) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
-		    errno, "getzoneid()");
-		status = PCAP_ERROR;
-		goto bad;
-	}
-	/*
-	 * Check if the given source datalink name has a '/' separated
-	 * zonename prefix string.  The zonename prefixed source datalink can
-	 * be used by pcap consumers in the Solaris global zone to capture
-	 * traffic on datalinks in non-global zones.  Non-global zones
-	 * do not have access to datalinks outside of their own namespace.
-	 */
-	if ((zonesep = strchr(p->opt.device, '/')) != NULL) {
-		char path_zname[ZONENAME_MAX];
-		int  znamelen;
-		char *lnamep;
-
-		if (ifr.lifr_zoneid != GLOBAL_ZONEID) {
-			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
-			    "zonename/linkname only valid in global zone.");
-			status = PCAP_ERROR;
-			goto bad;
-		}
-		znamelen = zonesep - p->opt.device;
-		(void) pcap_strlcpy(path_zname, p->opt.device, znamelen + 1);
-		ifr.lifr_zoneid = getzoneidbyname(path_zname);
-		if (ifr.lifr_zoneid == -1) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
-			    errno, "getzoneidbyname(%s)", path_zname);
-			status = PCAP_ERROR;
-			goto bad;
-		}
-		lnamep = strdup(zonesep + 1);
-		if (lnamep == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
-			    errno, "strdup");
-			status = PCAP_ERROR;
-			goto bad;
-		}
-		free(p->opt.device);
-		p->opt.device = lnamep;
-	}
-#endif
-
 	pb->device = strdup(p->opt.device);
 	if (pb->device == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "strdup");
 		status = PCAP_ERROR;
 		goto bad;
@@ -1940,7 +2010,7 @@ pcap_activate_bpf(pcap_t *p)
 						 * report "no such device".
 						 */
 						status = PCAP_ERROR_NO_SUCH_DEVICE;
-						pcap_fmt_errmsg_for_errno(p->errbuf,
+						pcapint_fmt_errmsg_for_errno(p->errbuf,
 						    PCAP_ERRBUF_SIZE, errno,
 						    "socket() failed");
 					}
@@ -1948,7 +2018,7 @@ pcap_activate_bpf(pcap_t *p)
 				}
 				wltdev = malloc(strlen(p->opt.device) + 2);
 				if (wltdev == NULL) {
-					pcap_fmt_errmsg_for_errno(p->errbuf,
+					pcapint_fmt_errmsg_for_errno(p->errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "malloc");
 					status = PCAP_ERROR;
@@ -1991,7 +2061,7 @@ pcap_activate_bpf(pcap_t *p)
 			 */
 			s = socket(AF_LOCAL, SOCK_DGRAM, 0);
 			if (s < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "Can't open socket");
 				status = PCAP_ERROR;
@@ -2002,7 +2072,7 @@ pcap_activate_bpf(pcap_t *p)
 			 * If we haven't already done so, arrange to have
 			 * "pcap_close_all()" called when we exit.
 			 */
-			if (!pcap_do_addexit(p)) {
+			if (!pcapint_do_addexit(p)) {
 				/*
 				 * "atexit()" failed; don't create the
 				 * interface, just give up.
@@ -2017,14 +2087,14 @@ pcap_activate_bpf(pcap_t *p)
 			/*
 			 * Create the interface.
 			 */
-			pcap_strlcpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
+			pcapint_strlcpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
 			if (ioctl(s, SIOCIFCREATE2, &ifr) < 0) {
 				if (errno == EINVAL) {
 					snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
 					    "Invalid USB bus interface %s",
 					    p->opt.device);
 				} else {
-					pcap_fmt_errmsg_for_errno(p->errbuf,
+					pcapint_fmt_errmsg_for_errno(p->errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "Can't create interface for %s",
 					    p->opt.device);
@@ -2042,7 +2112,7 @@ pcap_activate_bpf(pcap_t *p)
 			/*
 			 * Add this to the list of pcaps to close when we exit.
 			 */
-			pcap_add_to_pcaps_to_close(p);
+			pcapint_add_to_pcaps_to_close(p);
 		}
 	}
 #endif /* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */
@@ -2070,7 +2140,7 @@ pcap_activate_bpf(pcap_t *p)
 		 * size.
 		 */
 		if (ioctl(fd, BIOCGETZMAX, (caddr_t)&zbufmax) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCGETZMAX");
 			status = PCAP_ERROR;
 			goto bad;
@@ -2097,7 +2167,7 @@ pcap_activate_bpf(pcap_t *p)
 		pb->zbuf2 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,
 		    MAP_ANON, -1, 0);
 		if (pb->zbuf1 == MAP_FAILED || pb->zbuf2 == MAP_FAILED) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "mmap");
 			status = PCAP_ERROR;
 			goto bad;
@@ -2107,7 +2177,7 @@ pcap_activate_bpf(pcap_t *p)
 		bz.bz_bufb = pb->zbuf2;
 		bz.bz_buflen = pb->zbufsize;
 		if (ioctl(fd, BIOCSETZBUF, (caddr_t)&bz) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCSETZBUF");
 			status = PCAP_ERROR;
 			goto bad;
@@ -2141,7 +2211,7 @@ pcap_activate_bpf(pcap_t *p)
 			 */
 			if (ioctl(fd, BIOCSBLEN,
 			    (caddr_t)&p->opt.buffer_size) < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "BIOCSBLEN: %s", p->opt.device);
 				status = PCAP_ERROR;
@@ -2227,7 +2297,7 @@ pcap_activate_bpf(pcap_t *p)
 
 	/* Get the data link layer type. */
 	if (ioctl(fd, BIOCGDLT, (caddr_t)&v) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCGDLT");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2266,7 +2336,7 @@ pcap_activate_bpf(pcap_t *p)
 		goto bad;
 	}
 #endif
-#if _BSDI_VERSION - 0 >= 199510
+#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199510
 	/* The SLIP and PPP link layer header changed in BSD/OS 2.1 */
 	switch (v) {
 
@@ -2444,14 +2514,15 @@ pcap_activate_bpf(pcap_t *p)
 	 */
 	if (v == DLT_EN10MB && p->dlt_count == 0) {
 		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (p->dlt_list != NULL) {
-			p->dlt_list[0] = DLT_EN10MB;
-			p->dlt_list[1] = DLT_DOCSIS;
-			p->dlt_count = 2;
+		if (p->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			status = PCAP_ERROR;
+			goto bad;
 		}
+		p->dlt_list[0] = DLT_EN10MB;
+		p->dlt_list[1] = DLT_DOCSIS;
+		p->dlt_count = 2;
 	}
 #ifdef PCAP_FDDIPAD
 	if (v == DLT_FDDI)
@@ -2472,7 +2543,7 @@ pcap_activate_bpf(pcap_t *p)
 	 * BSDs - check CVS log for "bpf.c"?
 	 */
 	if (ioctl(fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCSHDRCMPLT");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2514,7 +2585,7 @@ pcap_activate_bpf(pcap_t *p)
 			bpf_to.tv_sec = p->opt.timeout / 1000;
 			bpf_to.tv_usec = (p->opt.timeout * 1000) % 1000000;
 			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&bpf_to) < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
 				status = PCAP_ERROR;
 				goto bad;
@@ -2524,7 +2595,7 @@ pcap_activate_bpf(pcap_t *p)
 			to.tv_sec = p->opt.timeout / 1000;
 			to.tv_usec = (p->opt.timeout * 1000) % 1000000;
 			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
 				status = PCAP_ERROR;
 				goto bad;
@@ -2559,7 +2630,7 @@ pcap_activate_bpf(pcap_t *p)
 #endif /* _AIX */
 		v = 1;
 		if (ioctl(p->fd, BIOCIMMEDIATE, &v) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCIMMEDIATE");
 			status = PCAP_ERROR;
 			goto bad;
@@ -2581,7 +2652,7 @@ pcap_activate_bpf(pcap_t *p)
 	if (p->opt.promisc) {
 		/* set promiscuous mode, just warn if it fails */
 		if (ioctl(p->fd, BIOCPROMISC, NULL) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "BIOCPROMISC");
 			status = PCAP_WARNING_PROMISC_NOTSUP;
 		}
@@ -2590,7 +2661,7 @@ pcap_activate_bpf(pcap_t *p)
 #ifdef BIOCSTSTAMP
 	v = BPF_T_BINTIME;
 	if (ioctl(p->fd, BIOCSTSTAMP, &v) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCSTSTAMP");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2598,7 +2669,7 @@ pcap_activate_bpf(pcap_t *p)
 #endif /* BIOCSTSTAMP */
 
 	if (ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCGBLEN");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2609,7 +2680,7 @@ pcap_activate_bpf(pcap_t *p)
 #endif
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2640,7 +2711,7 @@ pcap_activate_bpf(pcap_t *p)
 	total_prog.bf_len = 1;
 	total_prog.bf_insns = &total_insn;
 	if (ioctl(p->fd, BIOCSETF, (caddr_t)&total_prog) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCSETF");
 		status = PCAP_ERROR;
 		goto bad;
@@ -2731,7 +2802,7 @@ check_bpf_bindable(const char *name)
 	 * adapter, rather than by implementing the ioctls that
 	 * {Free,Net,Open,DragonFly}BSD provide. Opening that device
 	 * puts the adapter into monitor mode, which, at least for
-	 * some adapters, causes them to deassociate from the network
+	 * some adapters, causes them to disassociate from the network
 	 * with which they're associated.
 	 *
 	 * Instead, we try to open the corresponding "en" device (so
@@ -2751,7 +2822,7 @@ check_bpf_bindable(const char *name)
 		en_name_len = strlen(name) - 1;
 		en_name = malloc(en_name_len + 1);
 		if (en_name == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return (-1);
 		}
@@ -2868,7 +2939,7 @@ finddevs_usb(pcap_if_list_t *devlistp, char *errbuf)
 		 * so we need to avoid adding multiple capture devices
 		 * for each bus.
 		 */
-		if (find_or_add_dev(devlistp, name, PCAP_IF_UP,
+		if (pcapint_find_or_add_dev(devlistp, name, PCAP_IF_UP,
 		    get_usb_if_flags, NULL, errbuf) == NULL) {
 			free(name);
 			closedir(usbdir);
@@ -2893,13 +2964,13 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 
 	sock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (sock == -1) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
 		    "Can't create socket to get media information for %s",
 		    name);
 		return (-1);
 	}
 	memset(&req, 0, sizeof(req));
-	pcap_strlcpy(req.ifm_name, name, sizeof(req.ifm_name));
+	pcapint_strlcpy(req.ifm_name, name, sizeof(req.ifm_name));
 	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
 		if (errno == EOPNOTSUPP || errno == EINVAL || errno == ENOTTY ||
 		    errno == ENODEV || errno == EPERM
@@ -2938,7 +3009,7 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 			close(sock);
 			return (0);
 		}
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
 		    "SIOCGIFMEDIA on %s failed", name);
 		close(sock);
 		return (-1);
@@ -3005,15 +3076,23 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)
 #endif
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 	/*
 	 * Get the list of regular interfaces first.
 	 */
-	if (pcap_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,
+	if (pcapint_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,
 	    get_if_flags) == -1)
 		return (-1);	/* failure */
 
+#if defined(HAVE_SOLARIS_ANY_DEVICE)
+	/*
+	 * Add the "any" device.
+	 */
+	if (pcap_add_any_dev(devlistp, errbuf) == NULL)
+		return (-1);
+#endif
+
 #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
 	if (finddevs_usb(devlistp, errbuf) == -1)
 		return (-1);
@@ -3036,13 +3115,13 @@ monitor_mode(pcap_t *p, int set)
 
 	sock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (sock == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't open socket");
 		return (PCAP_ERROR);
 	}
 
 	memset(&req, 0, sizeof req);
-	pcap_strlcpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);
+	pcapint_strlcpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);
 
 	/*
 	 * Find out how many media types we have.
@@ -3072,7 +3151,7 @@ monitor_mode(pcap_t *p, int set)
 			return (PCAP_ERROR_RFMON_NOTSUP);
 
 		default:
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGIFMEDIA");
 			close(sock);
 			return (PCAP_ERROR);
@@ -3092,14 +3171,14 @@ monitor_mode(pcap_t *p, int set)
 	 */
 	media_list = malloc(req.ifm_count * sizeof(*media_list));
 	if (media_list == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		close(sock);
 		return (PCAP_ERROR);
 	}
 	req.ifm_ulist = media_list;
 	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGIFMEDIA");
 		free(media_list);
 		close(sock);
@@ -3147,7 +3226,7 @@ monitor_mode(pcap_t *p, int set)
 			 * If we haven't already done so, arrange to have
 			 * "pcap_close_all()" called when we exit.
 			 */
-			if (!pcap_do_addexit(p)) {
+			if (!pcapint_do_addexit(p)) {
 				/*
 				 * "atexit()" failed; don't put the interface
 				 * in monitor mode, just give up.
@@ -3156,11 +3235,11 @@ monitor_mode(pcap_t *p, int set)
 				return (PCAP_ERROR);
 			}
 			memset(&ifr, 0, sizeof(ifr));
-			(void)pcap_strlcpy(ifr.ifr_name, p->opt.device,
+			(void)pcapint_strlcpy(ifr.ifr_name, p->opt.device,
 			    sizeof(ifr.ifr_name));
 			ifr.ifr_media = req.ifm_current | IFM_IEEE80211_MONITOR;
 			if (ioctl(sock, SIOCSIFMEDIA, &ifr) == -1) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "SIOCSIFMEDIA");
 				close(sock);
 				return (PCAP_ERROR);
@@ -3171,7 +3250,7 @@ monitor_mode(pcap_t *p, int set)
 			/*
 			 * Add this to the list of pcaps to close when we exit.
 			 */
-			pcap_add_to_pcaps_to_close(p);
+			pcapint_add_to_pcaps_to_close(p);
 		}
 	}
 	return (0);
@@ -3397,17 +3476,17 @@ pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)
 	 * some kernels.
 	 */
 	if (errno != EINVAL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "BIOCSETF");
 		return (-1);
 	}
 
 	/*
-	 * install_bpf_program() validates the program.
+	 * pcapint_install_bpf_program() validates the program.
 	 *
 	 * XXX - what if we already have a filter in the kernel?
 	 */
-	if (install_bpf_program(p, fp) < 0)
+	if (pcapint_install_bpf_program(p, fp) < 0)
 		return (-1);
 	pb->filtering_in_kernel = 0;	/* filtering in userland */
 	return (0);
@@ -3462,7 +3541,7 @@ pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
 	}
 
 	if (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "Cannot set direction to %s", direction_name);
 		return (-1);
 	}
@@ -3515,7 +3594,7 @@ pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
 		break;
 	}
 	if (ioctl(p->fd, BIOCSDIRFILT, &dirfilt) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "Cannot set direction to %s", direction_name);
 		return (-1);
 	}
@@ -3565,7 +3644,7 @@ pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
 	}
 
 	if (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "Cannot set direction to %s", direction_name);
 		return (-1);
 	}
@@ -3586,7 +3665,7 @@ static int
 pcap_set_datalink_bpf(pcap_t *p, int dlt)
 {
 	if (ioctl(p->fd, BIOCSDLT, &dlt) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "Cannot set DLT %d", dlt);
 		return (-1);
 	}
diff --git a/pcap-bt-linux.c b/pcap-bt-linux.c
index c7bfef1d..2fc51665 100644
--- a/pcap-bt-linux.c
+++ b/pcap-bt-linux.c
@@ -32,13 +32,12 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "pcap-int.h"
 #include "pcap-bt-linux.h"
 #include "pcap/bluetooth.h"
+#include "diag-control.h"
 
 #include <errno.h>
 #include <stdlib.h>
@@ -84,9 +83,9 @@ bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 		/* if bluetooth is not supported this is not fatal*/
 		if (errno == EAFNOSUPPORT)
 			return 0;
-		pcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
 		    errno, "Can't open raw Bluetooth socket");
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	dev_list = malloc(HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));
@@ -94,7 +93,7 @@ bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 	{
 		snprintf(err_str, PCAP_ERRBUF_SIZE, "Can't allocate %zu bytes for Bluetooth device list",
 			HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));
-		ret = -1;
+		ret = PCAP_ERROR;
 		goto done;
 	}
 
@@ -110,9 +109,9 @@ bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 
 	if (ioctl(sock, HCIGETDEVLIST, (void *) dev_list) < 0)
 	{
-		pcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
 		    errno, "Can't get Bluetooth device list via ioctl");
-		ret = -1;
+		ret = PCAP_ERROR;
 		goto free;
 	}
 
@@ -131,9 +130,9 @@ bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 		 * the status to PCAP_IF_CONNECTION_STATUS_CONNECTED
 		 * or PCAP_IF_CONNECTION_STATUS_DISCONNECTED.
 		 */
-		if (add_dev(devlistp, dev_name, PCAP_IF_WIRELESS, dev_descr, err_str)  == NULL)
+		if (pcapint_add_dev(devlistp, dev_name, PCAP_IF_WIRELESS, dev_descr, err_str)  == NULL)
 		{
-			ret = -1;
+			ret = PCAP_ERROR;
 			break;
 		}
 	}
@@ -225,39 +224,39 @@ bt_activate(pcap_t* handle)
 
 	handle->read_op = bt_read_linux;
 	handle->inject_op = bt_inject_linux;
-	handle->setfilter_op = install_bpf_program; /* no kernel filtering */
+	handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */
 	handle->setdirection_op = bt_setdirection_linux;
 	handle->set_datalink_op = NULL;	/* can't change data link type */
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
 	handle->stats_op = bt_stats_linux;
 	handlep->dev_id = dev_id;
 
 	/* Create HCI socket */
 	handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
 	if (handle->fd < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't create raw socket");
 		return PCAP_ERROR;
 	}
 
 	handle->buffer = malloc(handle->bufsize);
 	if (!handle->buffer) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't allocate dump buffer");
 		goto close_fail;
 	}
 
 	opt = 1;
 	if (setsockopt(handle->fd, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt)) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't enable data direction info");
 		goto close_fail;
 	}
 
 	opt = 1;
 	if (setsockopt(handle->fd, SOL_HCI, HCI_TIME_STAMP, &opt, sizeof(opt)) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't enable time stamp");
 		goto close_fail;
 	}
@@ -268,7 +267,7 @@ bt_activate(pcap_t* handle)
 	memset((void *) &flt.type_mask, 0xff, sizeof(flt.type_mask));
 	memset((void *) &flt.event_mask, 0xff, sizeof(flt.event_mask));
 	if (setsockopt(handle->fd, SOL_HCI, HCI_FILTER, &flt, sizeof(flt)) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't set filter");
 		goto close_fail;
 	}
@@ -281,7 +280,7 @@ bt_activate(pcap_t* handle)
 	addr.hci_channel = HCI_CHANNEL_RAW;
 #endif
 	if (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't attach to device %d", handlep->dev_id);
 		goto close_fail;
 	}
@@ -301,7 +300,7 @@ bt_activate(pcap_t* handle)
 		if (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,
 		    &handle->opt.buffer_size,
 		    sizeof(handle->opt.buffer_size)) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    errno, PCAP_ERRBUF_SIZE, "SO_RCVBUF");
 			goto close_fail;
 		}
@@ -311,7 +310,7 @@ bt_activate(pcap_t* handle)
 	return 0;
 
 close_fail:
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 	return err;
 }
 
@@ -340,12 +339,12 @@ bt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char
 
 	/* ignore interrupt system call error */
 	do {
-		ret = recvmsg(handle->fd, &msg, 0);
 		if (handle->break_loop)
 		{
 			handle->break_loop = 0;
-			return -2;
+			return PCAP_ERROR_BREAK;
 		}
+		ret = recvmsg(handle->fd, &msg, 0);
 	} while ((ret == -1) && (errno == EINTR));
 
 	if (ret < 0) {
@@ -353,9 +352,9 @@ bt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char
 			/* Nonblocking mode, no data */
 			return 0;
 		}
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't receive packet");
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	pkth.caplen = (bpf_u_int32)ret;
@@ -372,7 +371,10 @@ bt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char
 					sizeof pkth.ts);
 				break;
 		}
+		// for musl libc CMSG_NXTHDR()
+DIAG_OFF_SIGN_COMPARE
 		cmsg = CMSG_NXTHDR(&msg, cmsg);
+DIAG_ON_SIGN_COMPARE
 	}
 	switch (handle->direction) {
 
@@ -394,7 +396,7 @@ bt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char
 	pkth.caplen+=sizeof(pcap_bluetooth_h4_header);
 	pkth.len = pkth.caplen;
 	if (handle->fcode.bf_insns == NULL ||
-	    pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
+	    pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
 		callback(user, &pkth, pktd);
 		return 1;
 	}
@@ -425,13 +427,13 @@ bt_stats_linux(pcap_t *handle, struct pcap_stat *stats)
 	} while ((ret == -1) && (errno == EINTR));
 
 	if (ret < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't get stats via ioctl");
 		return (-1);
 
 	}
 
-	/* we receive both rx and tx frames, so comulate all stats */
+	/* we receive both rx and tx frames, so cumulate all stats */
 	stats->ps_recv = s->evt_rx + s->acl_rx + s->sco_rx + s->cmd_tx +
 		s->acl_tx +s->sco_tx;
 	stats->ps_drop = s->err_rx + s->err_tx;
diff --git a/pcap-bt-monitor-linux.c b/pcap-bt-monitor-linux.c
index 206e65b5..dfba8051 100644
--- a/pcap-bt-monitor-linux.c
+++ b/pcap-bt-monitor-linux.c
@@ -29,9 +29,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <errno.h>
 #include <stdint.h>
@@ -43,6 +41,7 @@
 
 #include "pcap/bluetooth.h"
 #include "pcap-int.h"
+#include "diag-control.h"
 
 #include "pcap-bt-monitor-linux.h"
 
@@ -80,11 +79,11 @@ bt_monitor_findalldevs(pcap_if_list_t *devlistp, char *err_str)
      * more than there's a notion of "connected" or "disconnected"
      * for the "any" device.
      */
-    if (add_dev(devlistp, INTERFACE_NAME,
+    if (pcapint_add_dev(devlistp, INTERFACE_NAME,
                 PCAP_IF_WIRELESS|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
                 "Bluetooth Linux Monitor", err_str) == NULL)
     {
-        ret = -1;
+        ret = PCAP_ERROR;
     }
 
     return ret;
@@ -118,12 +117,12 @@ bt_monitor_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_ch
     msg.msg_controllen = BT_CONTROL_SIZE;
 
     do {
-        ret = recvmsg(handle->fd, &msg, 0);
         if (handle->break_loop)
         {
             handle->break_loop = 0;
-            return -2;
+            return PCAP_ERROR_BREAK;
         }
+        ret = recvmsg(handle->fd, &msg, 0);
     } while ((ret == -1) && (errno == EINTR));
 
     if (ret < 0) {
@@ -131,15 +130,18 @@ bt_monitor_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_ch
             /* Nonblocking mode, no data */
             return 0;
         }
-        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
             errno, "Can't receive packet");
-        return -1;
+        return PCAP_ERROR;
     }
 
     pkth.caplen = (bpf_u_int32)(ret - sizeof(hdr) + sizeof(pcap_bluetooth_linux_monitor_header));
     pkth.len = pkth.caplen;
 
+    // for musl libc CMSG_NXTHDR()
+DIAG_OFF_SIGN_COMPARE
     for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+DIAG_ON_SIGN_COMPARE
         if (cmsg->cmsg_level != SOL_SOCKET) continue;
 
         if (cmsg->cmsg_type == SCM_TIMESTAMP) {
@@ -151,7 +153,7 @@ bt_monitor_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_ch
     bthdr->opcode = htons(hdr.opcode);
 
     if (handle->fcode.bf_insns == NULL ||
-        pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
+        pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
         callback(user, &pkth, pktd);
         return 1;
     }
@@ -163,7 +165,7 @@ bt_monitor_inject(pcap_t *handle, const void *buf _U_, int size _U_)
 {
     snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
         "Packet injection is not supported yet on Bluetooth monitor devices");
-    return -1;
+    return PCAP_ERROR;
 }
 
 static int
@@ -204,23 +206,23 @@ bt_monitor_activate(pcap_t* handle)
 
     handle->read_op = bt_monitor_read;
     handle->inject_op = bt_monitor_inject;
-    handle->setfilter_op = install_bpf_program; /* no kernel filtering */
+    handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */
     handle->setdirection_op = NULL; /* Not implemented */
     handle->set_datalink_op = NULL; /* can't change data link type */
-    handle->getnonblock_op = pcap_getnonblock_fd;
-    handle->setnonblock_op = pcap_setnonblock_fd;
+    handle->getnonblock_op = pcapint_getnonblock_fd;
+    handle->setnonblock_op = pcapint_setnonblock_fd;
     handle->stats_op = bt_monitor_stats;
 
     handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
     if (handle->fd < 0) {
-        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
             errno, "Can't create raw socket");
         return PCAP_ERROR;
     }
 
     handle->buffer = malloc(handle->bufsize);
     if (!handle->buffer) {
-        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
             errno, "Can't allocate dump buffer");
         goto close_fail;
     }
@@ -231,14 +233,14 @@ bt_monitor_activate(pcap_t* handle)
     addr.hci_channel = HCI_CHANNEL_MONITOR;
 
     if (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
             errno, "Can't attach to interface");
         goto close_fail;
     }
 
     opt = 1;
     if (setsockopt(handle->fd, SOL_SOCKET, SO_TIMESTAMP, &opt, sizeof(opt)) < 0) {
-        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+        pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
             errno, "Can't enable time stamp");
         goto close_fail;
     }
@@ -248,7 +250,7 @@ bt_monitor_activate(pcap_t* handle)
     return 0;
 
 close_fail:
-    pcap_cleanup_live_common(handle);
+    pcapint_cleanup_live_common(handle);
     return err;
 }
 
diff --git a/pcap-common.c b/pcap-common.c
index 75461b12..26042d95 100644
--- a/pcap-common.c
+++ b/pcap-common.c
@@ -21,9 +21,7 @@
  * pcap-common.c - common code for pcap and pcapng files
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 
@@ -99,6 +97,17 @@
  *	defining DLT_* values that collide with those
  *	LINKTYPE_* values, either).
  */
+
+/*
+ * These values the DLT_ values for which are the same on all platforms,
+ * and that have been defined by <net/bpf.h> for ages.
+ *
+ * For those, the LINKTYPE_ values are equal to the DLT_ values.
+ *
+ * LINKTYPE_LOW_MATCHING_MIN is the lowest such value;
+ * LINKTYPE_LOW_MATCHING_MAX is the highest such value.
+ */
+#define LINKTYPE_LOW_MATCHING_MIN	0		/* lowest value in this "matching" range */
 #define LINKTYPE_NULL		DLT_NULL
 #define LINKTYPE_ETHERNET	DLT_EN10MB	/* also for 100Mb and up */
 #define LINKTYPE_EXP_ETHERNET	DLT_EN3MB	/* 3Mb experimental Ethernet */
@@ -111,6 +120,8 @@
 #define LINKTYPE_PPP		DLT_PPP
 #define LINKTYPE_FDDI		DLT_FDDI
 
+#define LINKTYPE_LOW_MATCHING_MAX	LINKTYPE_FDDI	/* highest value in this "matching" range */
+
 /*
  * LINKTYPE_PPP is for use when there might, or might not, be an RFC 1662
  * PPP in HDLC-like framing header (with 0xff 0x03 before the PPP protocol
@@ -150,10 +161,10 @@
  * and the LINKTYPE_ value that appears in capture files, are the
  * same.
  *
- * LINKTYPE_MATCHING_MIN is the lowest such value; LINKTYPE_MATCHING_MAX
- * is the highest such value.
+ * LINKTYPE_HIGH_MATCHING_MIN is the lowest such value;
+ * LINKTYPE_HIGH_MATCHING_MAX is the highest such value.
  */
-#define LINKTYPE_MATCHING_MIN	104		/* lowest value in the "matching" range */
+#define LINKTYPE_HIGH_MATCHING_MIN	104		/* lowest value in the "matching" range */
 
 #define LINKTYPE_C_HDLC		104		/* Cisco HDLC */
 #define LINKTYPE_IEEE802_11	105		/* IEEE 802.11 (wireless) */
@@ -693,9 +704,9 @@
 #define LINKTYPE_AOS		222
 
 /*
- * Wireless HART (Highway Addressable Remote Transducer)
+ * WirelessHART (Highway Addressable Remote Transducer)
  * From the HART Communication Foundation
- * IES/PAS 62591
+ * IEC/PAS 62591
  *
  * Requested by Sam Roberts <vieuxtech@gmail.com>.
  */
@@ -917,7 +928,6 @@
  * shiny new link-layer header type value that doesn't collide with
  * anything, in the hopes that future pfsync savefiles, if any,
  * won't require special hacks to distinguish from other savefiles.
- *
  */
 #define LINKTYPE_PFSYNC		246
 
@@ -1197,168 +1207,335 @@
  */
 #define LINKTYPE_ATSC_ALP	289
 
-#define LINKTYPE_MATCHING_MAX	289		/* highest value in the "matching" range */
+#define LINKTYPE_HIGH_MATCHING_MAX	289		/* highest value in the "matching" range */
 
 /*
  * The DLT_ and LINKTYPE_ values in the "matching" range should be the
- * same, so DLT_MATCHING_MAX and LINKTYPE_MATCHING_MAX should be the
+ * same, so DLT_HIGH_MATCHING_MAX and LINKTYPE_HIGH_MATCHING_MAX should be the
  * same.
  */
-#if LINKTYPE_MATCHING_MAX != DLT_MATCHING_MAX
-#error The LINKTYPE_ matching range does not match the DLT_ matching range
+#if LINKTYPE_HIGH_MATCHING_MAX != DLT_HIGH_MATCHING_MAX
+#error The LINKTYPE_ high matching range does not match the DLT_ matching range
 #endif
 
-static struct linktype_map {
-	int	dlt;
-	int	linktype;
-} map[] = {
+/*
+ * Map a DLT_* code to the corresponding LINKTYPE_* code.
+ * Used to generate link-layer types written to savefiles.
+ */
+int
+dlt_to_linktype(int dlt)
+{
 	/*
-	 * These DLT_* codes have LINKTYPE_* codes with values identical
-	 * to the values of the corresponding DLT_* code.
+	 * All values in the low matching range were handed out before
+	 * assigning DLT_* codes became a free-for-all, so they're the
+	 * same on all platforms, and thus are given LINKTYPE_* codes
+	 * with the same numerical values as the corresponding DLT_*
+	 * code.
 	 */
-	{ DLT_NULL,		LINKTYPE_NULL },
-	{ DLT_EN10MB,		LINKTYPE_ETHERNET },
-	{ DLT_EN3MB,		LINKTYPE_EXP_ETHERNET },
-	{ DLT_AX25,		LINKTYPE_AX25 },
-	{ DLT_PRONET,		LINKTYPE_PRONET },
-	{ DLT_CHAOS,		LINKTYPE_CHAOS },
-	{ DLT_IEEE802,		LINKTYPE_IEEE802_5 },
-	{ DLT_ARCNET,		LINKTYPE_ARCNET_BSD },
-	{ DLT_SLIP,		LINKTYPE_SLIP },
-	{ DLT_PPP,		LINKTYPE_PPP },
-	{ DLT_FDDI,		LINKTYPE_FDDI },
-	{ DLT_SYMANTEC_FIREWALL, LINKTYPE_SYMANTEC_FIREWALL },
+	if (dlt >= DLT_LOW_MATCHING_MIN && dlt <= DLT_LOW_MATCHING_MAX)
+		return (dlt);
 
+#if DLT_PFSYNC != LINKTYPE_PFSYNC
 	/*
-	 * These DLT_* codes have different values on different
-	 * platforms; we map them to LINKTYPE_* codes that
-	 * have values that should never be equal to any DLT_*
-	 * code.
+	 * DLT_PFSYNC has a code on several platforms that's in the
+	 * non-matching range, a code on FreeBSD that's in the high
+	 * matching range and that's *not* equal to LINKTYPE_PFSYNC,
+	 * and has a code on the rmaining platforms that's equal
+	 * to LINKTYPE_PFSYNC, which is in the high matching range.
+	 *
+	 * Map it to LINKTYPE_PFSYNC if it's not equal to LINKTYPE_PFSYNC.
 	 */
-#ifdef DLT_FR
-	/* BSD/OS Frame Relay */
-	{ DLT_FR,		LINKTYPE_FRELAY },
+	if (dlt == DLT_PFSYNC)
+		return (LINKTYPE_PFSYNC);
 #endif
 
-	{ DLT_ATM_RFC1483,	LINKTYPE_ATM_RFC1483 },
-	{ DLT_RAW,		LINKTYPE_RAW },
-	{ DLT_SLIP_BSDOS,	LINKTYPE_SLIP_BSDOS },
-	{ DLT_PPP_BSDOS,	LINKTYPE_PPP_BSDOS },
-	{ DLT_HDLC,		LINKTYPE_NETBSD_HDLC },
-
-	/* BSD/OS Cisco HDLC */
-	{ DLT_C_HDLC,		LINKTYPE_C_HDLC },
-
 	/*
-	 * These DLT_* codes are not on all platforms, but, so far,
-	 * there don't appear to be any platforms that define
-	 * other codes with those values; we map them to
-	 * different LINKTYPE_* values anyway, just in case.
+	 * DLT_PKTAP is defined as DLT_USER2 - which is in the high
+	 * matching range - on Darwin because Apple used DLT_USER2
+	 * on systems that users ran, not just as an internal thing.
+	 *
+	 * We map it to LINKTYPE_PKTAP if it's not equal to LINKTYPE_PKTAP
+	 * so that DLT_PKTAP captures from Apple machines can be read by
+	 * software that either doesn't handle DLT_USER2 or that handles it
+	 * as something other than Apple PKTAP.
 	 */
-
-	/* Linux ATM Classical IP */
-	{ DLT_ATM_CLIP,		LINKTYPE_ATM_CLIP },
-
-	/* NetBSD sync/async serial PPP (or Cisco HDLC) */
-	{ DLT_PPP_SERIAL,	LINKTYPE_PPP_HDLC },
-
-	/* NetBSD PPP over Ethernet */
-	{ DLT_PPP_ETHER,	LINKTYPE_PPP_ETHER },
+#if DLT_PKTAP != LINKTYPE_PKTAP
+	if (dlt == DLT_PKTAP)
+		return (LINKTYPE_PKTAP);
+#endif
 
 	/*
-	 * All LINKTYPE_ values between LINKTYPE_MATCHING_MIN
-	 * and LINKTYPE_MATCHING_MAX are mapped to identical
-	 * DLT_ values.
+	 * For all other DLT_* codes in the high matching range, the DLT
+	 * code value is the same as the LINKTYPE_* code value.
 	 */
+	if (dlt >= DLT_HIGH_MATCHING_MIN && dlt <= DLT_HIGH_MATCHING_MAX)
+		return (dlt);
 
-	{ -1,			-1 }
-};
-
-int
-dlt_to_linktype(int dlt)
-{
-	int i;
+	/*
+	 * These DLT_* codes have different values on different
+	 * platforms, so we assigned them LINKTYPE_* codes just
+	 * below the lower bound of the high matchig range;
+	 * those values should never be equal to any DLT_*
+	 * code, so that should avoid collisions.
+	 *
+	 * That way, for example, "raw IP" packets will have
+	 * LINKTYPE_RAW as the code in all savefiles for
+	 * which the code that writes them maps to that
+	 * value, regardless of the platform on which they
+	 * were written, so they should be readable on all
+	 * platforms without having to determine on which
+	 * platform they were written.
+	 *
+	 * We map the DLT_* codes on this platform, whatever
+	 * it might be, to the corresponding LINKTYPE_* codes.
+	 */
+	if (dlt == DLT_ATM_RFC1483)
+		return (LINKTYPE_ATM_RFC1483);
+	if (dlt == DLT_RAW)
+		return (LINKTYPE_RAW);
+	if (dlt == DLT_SLIP_BSDOS)
+		return (LINKTYPE_SLIP_BSDOS);
+	if (dlt == DLT_PPP_BSDOS)
+		return (LINKTYPE_PPP_BSDOS);
 
 	/*
-	 * DLTs that, on some platforms, have values in the matching range
-	 * but that *don't* have the same value as the corresponding
-	 * LINKTYPE because, for some reason, not all OSes have the
-	 * same value for that DLT (note that the DLT's value might be
-	 * outside the matching range on some of those OSes).
+	 * These DLT_* codes were originally defined on some platform,
+	 * and weren't defined on other platforms.
+	 *
+	 * At least some of them have values, on at least one platform,
+	 * that collide with other DLT_* codes on other platforms, e.g.
+	 * DLT_LOOP, so we don't just define them, on all platforms,
+	 * as having the same value as on the original platform.
+	 *
+	 * Therefore, we assigned new LINKTYPE_* codes to them, and,
+	 * on the platforms where they weren't originally defined,
+	 * define the DLT_* codes to have the same value as the
+	 * corresponding LINKTYPE_* codes.
+	 *
+	 * This means that, for capture files with the original
+	 * platform's DLT_* code rather than the LINKTYPE_* code
+	 * as a link-layer type, we will recognize those types
+	 * on that platform, but not on other platforms.
 	 */
-	if (dlt == DLT_PFSYNC)
-		return (LINKTYPE_PFSYNC);
-	if (dlt == DLT_PKTAP)
-		return (LINKTYPE_PKTAP);
+#ifdef DLT_FR
+	/* BSD/OS Frame Relay */
+	if (dlt == DLT_FR)
+		return (LINKTYPE_FRELAY);
+#endif
+#if DLT_HDLC != LINKTYPE_NETBSD_HDLC
+	/* NetBSD HDLC */
+	if (dlt == DLT_HDLC)
+		return (LINKTYPE_NETBSD_HDLC);
+#endif
+#if DLT_C_HDLC != LINKTYPE_C_HDLC
+	/* BSD/OS Cisco HDLC */
+	if (dlt == DLT_C_HDLC)
+		return (LINKTYPE_C_HDLC);
+#endif
+#if DLT_LOOP != LINKTYPE_LOOP
+	/* OpenBSD DLT_LOOP */
+	if (dlt == DLT_LOOP)
+		return (LINKTYPE_LOOP);
+#endif
+#if DLT_ENC != LINKTYPE_ENC
+	/* OpenBSD DLT_ENC */
+	if (dlt == DLT_ENC)
+		return (LINKTYPE_ENC);
+#endif
 
 	/*
-	 * For all other values in the matching range, the DLT
-	 * value is the same as the LINKTYPE value.
+	 * These DLT_* codes are not on all platforms, but, so far,
+	 * there don't appear to be any platforms that define
+	 * other codes with those values; we map them to
+	 * different LINKTYPE_* codes anyway, just in case.
 	 */
-	if (dlt >= DLT_MATCHING_MIN && dlt <= DLT_MATCHING_MAX)
-		return (dlt);
+	/* Linux ATM Classical IP */
+	if (dlt == DLT_ATM_CLIP)
+		return (LINKTYPE_ATM_CLIP);
 
 	/*
-	 * Map the values outside that range.
+	 * A few other values, defined on some platforms, not in
+	 * either matching range, but not colliding with anything
+	 * else, so they're given the same LINKTYPE_* code as
+	 * their DLT_* code.
 	 */
-	for (i = 0; map[i].dlt != -1; i++) {
-		if (map[i].dlt == dlt)
-			return (map[i].linktype);
-	}
+	if (dlt == DLT_REDBACK_SMARTEDGE || dlt == DLT_PPP_SERIAL ||
+	    dlt == DLT_PPP_ETHER || dlt == DLT_SYMANTEC_FIREWALL)
+		return (dlt);
 
 	/*
-	 * If we don't have a mapping for this DLT, return an
-	 * error; that means that this is a value with no corresponding
-	 * LINKTYPE, and we need to assign one.
+	 * If we don't have a mapping for this DLT_* code, return an
+	 * error; that means that this is a DLT_* value with no
+	 * corresponding LINKTYPE_ value, and we need to assign one.
 	 */
 	return (-1);
 }
 
+/*
+ * Map a LINKTYPE_* code to the corresponding DLT_* code.
+ * Used to translate link-layer types in savefiles to the
+ * DLT_* codes to provide to callers of libpcap.
+ */
 int
 linktype_to_dlt(int linktype)
 {
-	int i;
+	/*
+	 * All values in the low matching range were handed out before
+	 * assigning DLT_* codes became a free-for-all, so they're the
+	 * same on all platforms, and are thus used as the LINKTYPE_*
+	 * codes in capture files.
+	 */
+	if (linktype >= LINKTYPE_LOW_MATCHING_MIN &&
+	    linktype <= LINKTYPE_LOW_MATCHING_MAX)
+		return (linktype);
 
+#if LINKTYPE_PFSYNC != DLT_PFSYNC
 	/*
-	 * LINKTYPEs in the matching range that *don't*
-	 * have the same value as the corresponding DLTs
-	 * because, for some reason, not all OSes have the
-	 * same value for that DLT.
+	 * DLT_PFSYNC has a code on several platforms that's in the
+	 * non-matching range, a code on FreeBSD that's in the high
+	 * matching range and that's *not* equal to LINKTYPE_PFSYNC,
+	 * and has a code on the rmaining platforms that's equal
+	 * to LINKTYPE_PFSYNC, which is in the high matching range.
+	 *
+	 * Map LINKTYPE_PFSYNC to whatever DLT_PFSYNC is on this
+	 * platform, if the two aren't equal.
 	 */
 	if (linktype == LINKTYPE_PFSYNC)
 		return (DLT_PFSYNC);
+#endif
+
+	/*
+	 * DLT_PKTAP is defined as DLT_USER2 - which is in the high
+	 * matching range - on Darwin because Apple used DLT_USER2
+	 * on systems that users ran, not just as an internal thing.
+	 *
+	 * We map LINKTYPE_PKTAP to the platform's DLT_PKTAP for
+	 * the benefit of software that's expecting DLT_PKTAP
+	 * (even if that's DLT_USER2) for an Apple PKTAP capture.
+	 *
+	 * (Yes, this is an annoyance if you want to read a
+	 * LINKTYPE_USER2 packet as something other than DLT_PKTAP
+	 * on a Darwin-based OS, as, on that OS, DLT_PKTAP and DLT_USER2
+	 * are the same.  Feel free to complain to Apple about this.)
+	 */
+#if LINKTYPE_PKTAP != DLT_PKTAP
 	if (linktype == LINKTYPE_PKTAP)
 		return (DLT_PKTAP);
+#endif
+
+	/*
+	 * These DLT_* codes have different values on different
+	 * platforms, so we assigned them LINKTYPE_* codes just
+	 * below the lower bound of the high matchig range;
+	 * those values should never be equal to any DLT_*
+	 * code, so that should avoid collisions.
+	 *
+	 * That way, for example, "raw IP" packets will have
+	 * LINKTYPE_RAW as the code in all savefiles for
+	 * which the code that writes them maps to that
+	 * value, regardless of the platform on which they
+	 * were written, so they should be readable on all
+	 * platforms without having to determine on which
+	 * platform they were written.
+	 *
+	 * We map the LINKTYPE_* codes to the corresponding
+	 * DLT_* code on this platform.
+	 */
+	if (linktype == LINKTYPE_ATM_RFC1483)
+		return (DLT_ATM_RFC1483);
+	if (linktype == LINKTYPE_RAW)
+		return (DLT_RAW);
+	if (linktype == LINKTYPE_SLIP_BSDOS)
+		return (DLT_SLIP_BSDOS);
+	if (linktype == LINKTYPE_PPP_BSDOS)
+		return (DLT_PPP_BSDOS);
 
 	/*
-	 * For all other values in the matching range, except for
-	 * LINKTYPE_ATM_CLIP, the LINKTYPE value is the same as
-	 * the DLT value.
+	 * These DLT_* codes were originally defined on some platform,
+	 * and weren't defined on other platforms.
+	 *
+	 * At least some of them have values, on at least one platform,
+	 * that collide with other DLT_* codes on other platforms, e.g.
+	 * DLT_LOOP, so we don't just define them, on all platforms,
+	 * as having the same value as on the original platform.
+	 *
+	 * Therefore, we assigned new LINKTYPE_* codes to them, and,
+	 * on the platforms where they weren't originally defined,
+	 * define the DLT_* codes to have the same value as the
+	 * corresponding LINKTYPE_* codes.
+	 *
+	 * This means that, for capture files with the original
+	 * platform's DLT_* code rather than the LINKTYPE_* code
+	 * as a link-layer type, we will recognize those types
+	 * on that platform, but not on other platforms.
+	 *
+	 * We map the LINKTYPE_* codes to the corresponding
+	 * DLT_* code on platforms where the two codes differ..
+	 */
+#ifdef DLT_FR
+	/* BSD/OS Frame Relay */
+	if (linktype == LINKTYPE_FRELAY)
+		return (DLT_FR);
+#endif
+#if LINKTYPE_NETBSD_HDLC != DLT_HDLC
+	/* NetBSD HDLC */
+	if (linktype == LINKTYPE_NETBSD_HDLC)
+		return (DLT_HDLC);
+#endif
+#if LINKTYPE_C_HDLC != DLT_C_HDLC
+	/* BSD/OS Cisco HDLC */
+	if (linktype == LINKTYPE_C_HDLC)
+		return (DLT_C_HDLC);
+#endif
+#if LINKTYPE_LOOP != DLT_LOOP
+	/* OpenBSD DLT_LOOP */
+	if (linktype == LINKTYPE_LOOP)
+		return (DLT_LOOP);
+#endif
+#if LINKTYPE_ENC != DLT_ENC
+	/* OpenBSD DLT_ENC */
+	if (linktype == LINKTYPE_ENC)
+		return (DLT_ENC);
+#endif
+
+	/*
+	 * These DLT_* codes are not on all platforms, but, so far,
+	 * there don't appear to be any platforms that define
+	 * other codes with those values; we map them to
+	 * different LINKTYPE_* values anyway, just in case.
 	 *
 	 * LINKTYPE_ATM_CLIP is a special case.  DLT_ATM_CLIP is
 	 * not on all platforms, but, so far, there don't appear
 	 * to be any platforms that define it as anything other
 	 * than 19; we define LINKTYPE_ATM_CLIP as something
 	 * other than 19, just in case.  That value is in the
-	 * matching range, so we have to check for it.
-	 */
-	if (linktype >= LINKTYPE_MATCHING_MIN &&
-	    linktype <= LINKTYPE_MATCHING_MAX &&
-	    linktype != LINKTYPE_ATM_CLIP)
-		return (linktype);
-
-	/*
-	 * Map the values outside that range.
+	 * high matching range, so we have to check for it.
 	 */
-	for (i = 0; map[i].linktype != -1; i++) {
-		if (map[i].linktype == linktype)
-			return (map[i].dlt);
-	}
+	/* Linux ATM Classical IP */
+	if (linktype == LINKTYPE_ATM_CLIP)
+		return (DLT_ATM_CLIP);
 
 	/*
-	 * If we don't have an entry for this LINKTYPE, return
-	 * the link type value; it may be a DLT from an newer
-	 * version of libpcap.
+	 * For all other values, return the linktype code as the
+	 * DLT_* code.
+	 *
+	 * If the code is in the high matching range, the
+	 * DLT_* code is the same as the LINKTYPE_* code.
+	 *
+	 * If the code is greater than the maximum value in
+	 * the high matching range, it may be a value from
+	 * a newer version of libpcap; we provide it in case
+	 * the program' capable of handling it.
+	 *
+	 * If the code is less than the minimum value in the
+	 * high matching range, it might be from a capture
+	 * written by code that doesn't map non-matching range
+	 * DLT_* codes to the appropriate LINKTYPE_* code, so
+	 * we'll just pass it through, so that *if it was written
+	 * on this platform* it will be interpreted correctly.
+	 * (We don't know whether it was written on this platform,
+	 * but at least this way there's *some* chance that it
+	 * can be read.)
 	 */
 	return linktype;
 }
diff --git a/pcap-config.1 b/pcap-config.1
index 87ab0acc..66af140b 100644
--- a/pcap-config.1
+++ b/pcap-config.1
@@ -18,55 +18,115 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP-CONFIG 1 "15 February 2015"
+.TH PCAP\-CONFIG 1 "17 April 2023"
 .SH NAME
 pcap-config \- write libpcap compiler and linker flags to standard output
 .SH SYNOPSIS
 .na
 .B pcap-config
 [
-.B \-\-static
+.B \-\-help
 ]
 [
-.B \-\-cflags | \-\-libs | \-\-additional-libs
+.B \-\-version
+]
+[
+.B \-\-cflags
+]
+.ti +12
+[
+.B \-\-libs
+|
+.B \-\-additional\-libs
+]
+.ti +12
+[
+.B \-\-static
+|
+.B \-\-static\-pcap\-only
 ]
 .ad
+
 .SH DESCRIPTION
 .LP
-When run with the
+.I pcap\-config
+writes to the standard output various compiler and linker flags required to
+build a user program with libpcap.  By default, it writes flags appropriate
+for building with a dynamically\-linked version of libpcap; see below
+for static linking.  Depending on the manner of libpcap installation, some
+options or their combinations may produce empty output \- this is by design.
+
+.SH OPTIONS
+.TP
+.B \-\-help
+Produce a help message and exit.
+
+.TP
+.B \-\-version
+Produce libpcap version and exit.  The version is the contents of
+.I VERSION
+file in libpcap source tree rather than the result of
+.BR \%pcap_lib_version (3PCAP).
+
+.TP
 .B \-\-cflags
-option,
-.I pcap-config
-writes to the standard output the
+Produce the
 .B \-I
-compiler flags required to include libpcap's header files.
-When run with the
+compiler flag required to include libpcap's header files.
+
+.TP
 .B \-\-libs
-option,
-.I pcap-config
-writes to the standard output the
+Produce the
 .B \-L
 and
 .B \-l
 linker flags required to link with libpcap, including
 .B \-l
 flags for libraries required by libpcap.
-When run with the
-.B \-\-additional-libs
-option,
-.I pcap-config
-writes to the standard output the
+
+.TP
+.B \-\-additional\-libs
+Produce the
 .B \-L
 and
 .B \-l
-flags for libraries required by libpcap, but not the
-.B \-lpcap
+linker flags for libraries required by libpcap, but not the
+.B \-l
 flag to link with libpcap itself.
-.LP
-By default, it writes flags appropriate for compiling with a
-dynamically-linked version of libpcap; the
+
+.TP
+.B \-\-static
+This option causes
+.B \-\-libs
+and
+.B \-\-additional\-libs
+to produce linker flags appropriate for static linking with libpcap.
+
+.TP
+.B \-\-static\-pcap\-only
+This option causes
+.B \-\-libs
+and
+.B \-\-additional\-libs
+to produce linker flags appropriate for static linking with libpcap and
+dynamic linking with all other libraries, including libraries required by
+libpcap.
+
+.SH EXIT STATUS
+.I pcap\-config
+exits with a non-zero status when invoked with an invalid command\-line
+option, and with status 0 otherwise.
+
+.SH BACKWARD COMPATIBILITY
+.PP
+Before libpcap release 1.10.2
+.I pcap\-config
+did not treat invalid command\-line options as an error. The
+.B \-\-static\-pcap\-only
+flag became available in libpcap release 1.10.2.  The
 .B \-\-static
-flag causes it to write flags appropriate for compiling with a
-statically-linked version of libpcap.
+flag became available in libpcap release 1.1.0.
+
 .SH SEE ALSO
+.BR pkg\-config (1),
 .BR pcap (3PCAP)
diff --git a/pcap-config.in b/pcap-config.in
index 6039ef33..28427047 100644
--- a/pcap-config.in
+++ b/pcap-config.in
@@ -16,6 +16,13 @@ LIBS="@LIBS@"
 LIBS_STATIC="@LIBS_STATIC@"
 VERSION="@PACKAGE_VERSION@"
 
+usage()
+{
+	echo "Usage: pcap-config [ --help ] [ --version ] [ --cflags ]"
+	echo "                   [ --libs | --additional-libs ]"
+	echo "                   [ --static | --static-pcap-only ]"
+}
+
 static=0
 static_pcap_only=0
 show_cflags=0
@@ -46,7 +53,7 @@ do
 		;;
 
 	-h|--help)
-		echo "Usage: pcap-config [ --help ] [--version] [ --static | --static-pcap-only ] [ --libs | --additional-libs ]"
+		usage
 		exit 0
 		;;
 
@@ -57,7 +64,7 @@ do
 
 	*)
 		echo "pcap-config: Invalid command-line option $1 specified" 1>&2
-		echo "Usage: pcap-config [ --help ] [ --static | --static-pcap-only ] [ --libs | --additional-libs ]" 1>&2
+		usage 1>&2
 		exit 1
 		;;
 	esac
diff --git a/pcap-dag.c b/pcap-dag.c
index f261ead0..b21c2e3c 100644
--- a/pcap-dag.c
+++ b/pcap-dag.c
@@ -7,9 +7,7 @@
  *                Stephen Donnelly <stephen.donnelly@endace.com>
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>			/* optionally get BSD define */
 
@@ -259,7 +257,7 @@ dag_platform_cleanup(pcap_t *p)
 		pd->dag_ref = NULL;
 	}
 	delete_pcap_dag(p);
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static void
@@ -424,7 +422,7 @@ dag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		rlen = ntohs(header->rlen);
 		if (rlen < dag_record_size)
 		{
-			pcap_strlcpy(p->errbuf, "dag_read: record too small",
+			pcapint_strlcpy(p->errbuf, "dag_read: record too small",
 			    PCAP_ERRBUF_SIZE);
 			return -1;
 		}
@@ -668,7 +666,7 @@ dag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 			caplen = p->snapshot;
 
 		/* Run the packet filter if there is one. */
-		if ((p->fcode.bf_insns == NULL) || pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {
+		if ((p->fcode.bf_insns == NULL) || pcapint_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {
 
 			/* convert between timestamp formats */
 			register unsigned long long ts;
@@ -724,7 +722,7 @@ dag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 static int
 dag_inject(pcap_t *p, const void *buf _U_, int size _U_)
 {
-	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on DAG cards",
+	pcapint_strlcpy(p->errbuf, "Sending packets isn't supported on DAG cards",
 	    PCAP_ERRBUF_SIZE);
 	return (-1);
 }
@@ -762,7 +760,7 @@ static int dag_activate(pcap_t* p)
 	newDev = (char *)malloc(strlen(device) + 16);
 	if (newDev == NULL) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't allocate string for device name");
 		goto fail;
 	}
@@ -776,7 +774,7 @@ static int dag_activate(pcap_t* p)
 		 * cases?
 		 */
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_parse_name");
 		goto fail;
 	}
@@ -807,7 +805,7 @@ static int dag_activate(pcap_t* p)
 			    device, (errno == EPERM) ? "EPERM" : "EACCES");
 		} else {
 			ret = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "dag_config_init %s", device);
 		}
 		goto fail;
@@ -818,7 +816,7 @@ static int dag_activate(pcap_t* p)
 		 * XXX - does this reliably set errno?
 		 */
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_config_get_card_fd %s", device);
 		goto failclose;
 	}
@@ -826,7 +824,7 @@ static int dag_activate(pcap_t* p)
 	/* Open requested stream. Can fail if already locked or on error */
 	if (dag_attach_stream64(p->fd, pd->dag_stream, 0, 0) < 0) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_attach_stream");
 		goto failclose;
 	}
@@ -845,7 +843,7 @@ static int dag_activate(pcap_t* p)
 	if (dag_get_stream_poll64(p->fd, pd->dag_stream,
 				&mindata, &maxwait, &poll) < 0) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_get_stream_poll");
 		goto faildetach;
 	}
@@ -890,7 +888,7 @@ static int dag_activate(pcap_t* p)
 	if (dag_set_stream_poll64(p->fd, pd->dag_stream,
 				mindata, &maxwait, &poll) < 0) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_set_stream_poll");
 		goto faildetach;
 	}
@@ -913,7 +911,7 @@ static int dag_activate(pcap_t* p)
 
 	if(dag_start_stream(p->fd, pd->dag_stream) < 0) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_start_stream %s", device);
 		goto faildetach;
 	}
@@ -980,7 +978,7 @@ static int dag_activate(pcap_t* p)
 
 	if (new_pcap_dag(p) < 0) {
 		ret = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "new_pcap_dag %s", device);
 		goto failstop;
 	}
@@ -996,10 +994,10 @@ static int dag_activate(pcap_t* p)
 
 	p->read_op = dag_read;
 	p->inject_op = dag_inject;
-	p->setfilter_op = install_bpf_program;
+	p->setfilter_op = pcapint_install_bpf_program;
 	p->setdirection_op = NULL; /* Not implemented.*/
 	p->set_datalink_op = dag_set_datalink;
-	p->getnonblock_op = pcap_getnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
 	p->setnonblock_op = dag_setnonblock;
 	p->stats_op = dag_stats;
 	p->cleanup_op = dag_platform_cleanup;
@@ -1030,7 +1028,7 @@ failclose:
 	delete_pcap_dag(p);
 
 fail:
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 	if (newDev != NULL) {
 		free((char *)newDev);
 	}
@@ -1100,7 +1098,7 @@ pcap_t *dag_create(const char *device, char *ebuf, int *is_ours)
 	 */
 	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
 	if (p->tstamp_precision_list == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		pcap_close(p);
 		return NULL;
@@ -1179,7 +1177,7 @@ dag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 			 *
 			 * Also, are there notions of "up" and "running"?
 			 */
-			if (add_dev(devlistp, name, 0, description, errbuf) == NULL) {
+			if (pcapint_add_dev(devlistp, name, 0, description, errbuf) == NULL) {
 				/*
 				 * Failure.
 				 */
@@ -1191,7 +1189,7 @@ dag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 					dag_detach_stream(dagfd, stream);
 
 					snprintf(name,  10, "dag%d:%d", c, stream);
-					if (add_dev(devlistp, name, 0, description, errbuf) == NULL) {
+					if (pcapint_add_dev(devlistp, name, 0, description, errbuf) == NULL) {
 						/*
 						 * Failure.
 						 */
@@ -1233,12 +1231,12 @@ dag_setnonblock(pcap_t *p, int nonblock)
 	 * and have a "dag_getnonblock()" function that looks at
 	 * "pd->dag_flags".
 	 */
-	if (pcap_setnonblock_fd(p, nonblock) < 0)
+	if (pcapint_setnonblock_fd(p, nonblock) < 0)
 		return (-1);
 
 	if (dag_get_stream_poll64(p->fd, pd->dag_stream,
 				&mindata, &maxwait, &poll) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_get_stream_poll");
 		return -1;
 	}
@@ -1254,7 +1252,7 @@ dag_setnonblock(pcap_t *p, int nonblock)
 
 	if (dag_set_stream_poll64(p->fd, pd->dag_stream,
 				mindata, &maxwait, &poll) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "dag_set_stream_poll");
 		return -1;
 	}
@@ -1277,7 +1275,7 @@ dag_get_datalink(pcap_t *p)
 	memset(types, 0, 255);
 
 	if (p->dlt_list == NULL && (p->dlt_list = malloc(255*sizeof(*(p->dlt_list)))) == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "malloc");
 		return (-1);
 	}
@@ -1287,7 +1285,7 @@ dag_get_datalink(pcap_t *p)
 #ifdef HAVE_DAG_GET_STREAM_ERF_TYPES
 	/* Get list of possible ERF types for this card */
 	if (dag_get_stream_erf_types(p->fd, pd->dag_stream, types, 255) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "dag_get_stream_erf_types");
 		return (-1);
 	}
@@ -1297,7 +1295,7 @@ dag_get_datalink(pcap_t *p)
 #elif defined HAVE_DAG_GET_ERF_TYPES
 	/* Get list of possible ERF types for this card */
 	if (dag_get_erf_types(p->fd, types, 255) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "dag_get_erf_types");
 		return (-1);
 	}
@@ -1315,12 +1313,9 @@ dag_get_datalink(pcap_t *p)
 		case ERF_TYPE_COLOR_HDLC_POS:
 		case ERF_TYPE_DSM_COLOR_HDLC_POS:
 		case ERF_TYPE_COLOR_HASH_POS:
-
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_CHDLC;
-				p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
-				p->dlt_list[dlt_index++] = DLT_FRELAY;
-			}
+			p->dlt_list[dlt_index++] = DLT_CHDLC;
+			p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
+			p->dlt_list[dlt_index++] = DLT_FRELAY;
 			if(!p->linktype)
 				p->linktype = DLT_CHDLC;
 			break;
@@ -1339,10 +1334,8 @@ dag_get_datalink(pcap_t *p)
 			 * DOCSIS frames out on the wire inside the low-level
 			 * Ethernet framing).
 			 */
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_EN10MB;
-				p->dlt_list[dlt_index++] = DLT_DOCSIS;
-			}
+			p->dlt_list[dlt_index++] = DLT_EN10MB;
+			p->dlt_list[dlt_index++] = DLT_DOCSIS;
 			if(!p->linktype)
 				p->linktype = DLT_EN10MB;
 			break;
@@ -1351,42 +1344,34 @@ dag_get_datalink(pcap_t *p)
 		case ERF_TYPE_AAL5:
 		case ERF_TYPE_MC_ATM:
 		case ERF_TYPE_MC_AAL5:
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_ATM_RFC1483;
-				p->dlt_list[dlt_index++] = DLT_SUNATM;
-			}
+			p->dlt_list[dlt_index++] = DLT_ATM_RFC1483;
+			p->dlt_list[dlt_index++] = DLT_SUNATM;
 			if(!p->linktype)
 				p->linktype = DLT_ATM_RFC1483;
 			break;
 
 		case ERF_TYPE_COLOR_MC_HDLC_POS:
 		case ERF_TYPE_MC_HDLC:
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_CHDLC;
-				p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
-				p->dlt_list[dlt_index++] = DLT_FRELAY;
-				p->dlt_list[dlt_index++] = DLT_MTP2;
-				p->dlt_list[dlt_index++] = DLT_MTP2_WITH_PHDR;
-				p->dlt_list[dlt_index++] = DLT_LAPD;
-			}
+			p->dlt_list[dlt_index++] = DLT_CHDLC;
+			p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
+			p->dlt_list[dlt_index++] = DLT_FRELAY;
+			p->dlt_list[dlt_index++] = DLT_MTP2;
+			p->dlt_list[dlt_index++] = DLT_MTP2_WITH_PHDR;
+			p->dlt_list[dlt_index++] = DLT_LAPD;
 			if(!p->linktype)
 				p->linktype = DLT_CHDLC;
 			break;
 
 		case ERF_TYPE_IPV4:
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_RAW;
-				p->dlt_list[dlt_index++] = DLT_IPV4;
-			}
+			p->dlt_list[dlt_index++] = DLT_RAW;
+			p->dlt_list[dlt_index++] = DLT_IPV4;
 			if(!p->linktype)
 				p->linktype = DLT_RAW;
 			break;
 
 		case ERF_TYPE_IPV6:
-			if (p->dlt_list != NULL) {
-				p->dlt_list[dlt_index++] = DLT_RAW;
-				p->dlt_list[dlt_index++] = DLT_IPV6;
-			}
+			p->dlt_list[dlt_index++] = DLT_RAW;
+			p->dlt_list[dlt_index++] = DLT_IPV6;
 			if(!p->linktype)
 				p->linktype = DLT_RAW;
 			break;
@@ -1429,7 +1414,7 @@ dag_get_datalink(pcap_t *p)
  * There are no regular interfaces, just DAG interfaces.
  */
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
 {
 	return (0);
 }
@@ -1438,7 +1423,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
  * Attempts to open a regular interface fail.
  */
 pcap_t *
-pcap_create_interface(const char *device, char *errbuf)
+pcapint_create_interface(const char *device, char *errbuf)
 {
 	snprintf(errbuf, PCAP_ERRBUF_SIZE,
 	    "This version of libpcap only supports DAG cards");
diff --git a/pcap-dbus.c b/pcap-dbus.c
index 506f150f..df7eca78 100644
--- a/pcap-dbus.c
+++ b/pcap-dbus.c
@@ -28,9 +28,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <string.h>
 
@@ -91,7 +89,7 @@ dbus_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *us
 
 		gettimeofday(&pkth.ts, NULL);
 		if (handle->fcode.bf_insns == NULL ||
-		    pcap_filter(handle->fcode.bf_insns, (u_char *)raw_msg, pkth.len, pkth.caplen)) {
+		    pcapint_filter(handle->fcode.bf_insns, (u_char *)raw_msg, pkth.len, pkth.caplen)) {
 			handlep->packets_read++;
 			callback(user, &pkth, (u_char *)raw_msg);
 			count++;
@@ -142,7 +140,7 @@ dbus_cleanup(pcap_t *handle)
 
 	dbus_connection_unref(handlep->conn);
 
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 }
 
 /*
@@ -227,7 +225,7 @@ dbus_activate(pcap_t *handle)
 	handle->linktype = DLT_DBUS;
 	handle->read_op = dbus_read;
 	handle->inject_op = dbus_write;
-	handle->setfilter_op = install_bpf_program; /* XXX, later add support for dbus_bus_add_match() */
+	handle->setfilter_op = pcapint_install_bpf_program; /* XXX, later add support for dbus_bus_add_match() */
 	handle->setdirection_op = NULL;
 	handle->set_datalink_op = NULL;      /* can't change data link type */
 	handle->getnonblock_op = dbus_getnonblock;
@@ -338,11 +336,11 @@ dbus_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 	 * The notion of "connected" vs. "disconnected" doesn't apply.
 	 * XXX - what about the notions of "up" and "running"?
 	 */
-	if (add_dev(devlistp, "dbus-system",
+	if (pcapint_add_dev(devlistp, "dbus-system",
 	    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, "D-Bus system bus",
 	    err_str) == NULL)
 		return -1;
-	if (add_dev(devlistp, "dbus-session",
+	if (pcapint_add_dev(devlistp, "dbus-session",
 	    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, "D-Bus session bus",
 	    err_str) == NULL)
 		return -1;
diff --git a/pcap-dlpi.c b/pcap-dlpi.c
index 16ed52da..081f96a5 100644
--- a/pcap-dlpi.c
+++ b/pcap-dlpi.c
@@ -68,9 +68,7 @@
  *      DL_HP_RAWDLS?
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -232,7 +230,7 @@ pcap_read_dlpi(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 				case EAGAIN:
 					return (0);
 				}
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    sizeof(p->errbuf), errno, "getmsg");
 				return (-1);
 			}
@@ -256,7 +254,7 @@ pcap_inject_dlpi(pcap_t *p, const void *buf, int size)
 #if defined(DLIOCRAW)
 	ret = write(p->fd, buf, size);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -268,7 +266,7 @@ pcap_inject_dlpi(pcap_t *p, const void *buf, int size)
 	}
 	ret = dlrawdatareq(pd->send_fd, buf, size);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -301,7 +299,7 @@ pcap_inject_dlpi(pcap_t *p, const void *buf, int size)
 	 * it should check "p->linktype" and reject the send request if
 	 * it's anything other than DLT_EN10MB.
 	 */
-	pcap_strlcpy(p->errbuf, "send: Not supported on this version of this OS",
+	pcapint_strlcpy(p->errbuf, "send: Not supported on this version of this OS",
 	    PCAP_ERRBUF_SIZE);
 	ret = -1;
 #endif /* raw mode */
@@ -335,7 +333,7 @@ pcap_cleanup_dlpi(pcap_t *p)
 		pd->send_fd = -1;
 	}
 #endif
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static int
@@ -357,9 +355,9 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 	*/
 	cp = strrchr(name, '/');
 	if (cp == NULL)
-		pcap_strlcpy(dname, name, sizeof(dname));
+		pcapint_strlcpy(dname, name, sizeof(dname));
 	else
-		pcap_strlcpy(dname, cp + 1, sizeof(dname));
+		pcapint_strlcpy(dname, cp + 1, sizeof(dname));
 
 	/*
 	 * Split the device name into a device type name and a unit number;
@@ -394,7 +392,7 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 			    cp, (errno == EPERM) ? "EPERM" : "EACCES");
 		} else {
 			status = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "Attempt to open %s failed", cp);
 		}
 		return (status);
@@ -417,7 +415,7 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 	 * device name.
 	 */
 	if (*name == '/')
-		pcap_strlcpy(dname, name, sizeof(dname));
+		pcapint_strlcpy(dname, name, sizeof(dname));
 	else
 		snprintf(dname, sizeof(dname), "%s/%s", PCAP_DEV_PREFIX,
 		    name);
@@ -438,7 +436,7 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 	 * Make a copy of the device pathname, and then remove the unit
 	 * number from the device pathname.
 	 */
-	pcap_strlcpy(dname2, dname, sizeof(dname));
+	pcapint_strlcpy(dname2, dname, sizeof(dname));
 	*cp = '\0';
 
 	/* Try device without unit number */
@@ -452,7 +450,7 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 				    (errno == EPERM) ? "EPERM" : "EACCES");
 			} else {
 				status = PCAP_ERROR;
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "Attempt to open %s failed", dname);
 			}
@@ -498,7 +496,7 @@ open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
 					    (errno == EPERM) ? "EPERM" : "EACCES");
 				} else {
 					status = PCAP_ERROR;
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "Attempt to open %s failed",
 					    dname2);
@@ -685,7 +683,7 @@ pcap_activate_dlpi(pcap_t *p)
 		*/
 		if (strioctl(p->fd, A_PROMISCON_REQ, 0, NULL) < 0) {
 			status = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "A_PROMISCON_REQ");
 			goto bad;
 		}
@@ -803,7 +801,7 @@ pcap_activate_dlpi(pcap_t *p)
 	*/
 	if (strioctl(p->fd, DLIOCRAW, 0, NULL) < 0) {
 		status = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "DLIOCRAW");
 		goto bad;
 	}
@@ -844,7 +842,7 @@ pcap_activate_dlpi(pcap_t *p)
 	*/
 	if (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {
 		status = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "FLUSHR");
 		goto bad;
 	}
@@ -865,11 +863,11 @@ pcap_activate_dlpi(pcap_t *p)
 
 	p->read_op = pcap_read_dlpi;
 	p->inject_op = pcap_inject_dlpi;
-	p->setfilter_op = install_bpf_program;	/* no kernel filtering */
+	p->setfilter_op = pcapint_install_bpf_program;	/* no kernel filtering */
 	p->setdirection_op = NULL;	/* Not implemented.*/
 	p->set_datalink_op = NULL;	/* can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_dlpi;
 	p->cleanup_op = pcap_cleanup_dlpi;
 
@@ -987,7 +985,7 @@ dl_dohpuxbind(int fd, char *ebuf)
 		*ebuf = '\0';
 		hpsap++;
 		if (hpsap > 100) {
-			pcap_strlcpy(ebuf,
+			pcapint_strlcpy(ebuf,
 			    "All SAPs from 22 through 100 are in use",
 			    PCAP_ERRBUF_SIZE);
 			return (-1);
@@ -1100,7 +1098,7 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 #ifdef HAVE_SOLARIS
 	int fd;
@@ -1116,7 +1114,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 	/*
 	 * Get the list of regular interfaces first.
 	 */
-	if (pcap_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,
+	if (pcapint_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,
 	    get_if_flags) == -1)
 		return (-1);	/* failure */
 
@@ -1137,7 +1135,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 	}
 
 	if (strioctl(fd, A_GET_UNITS, sizeof(buf), (char *)&buf) < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "A_GET_UNITS");
 		return (-1);
 	}
@@ -1148,7 +1146,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 		 * And is there a way to determine whether the
 		 * interface is plugged into a network?
 		 */
-		if (add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)
+		if (pcapint_add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)
 			return (-1);
 	}
 #endif
@@ -1168,7 +1166,7 @@ send_request(int fd, char *ptr, int len, char *what, char *ebuf)
 
 	flags = 0;
 	if (putmsg(fd, &ctl, (struct strbuf *) NULL, flags) < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "send_request: putmsg \"%s\"", what);
 		return (-1);
 	}
@@ -1197,7 +1195,7 @@ recv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror
 
 	flags = 0;
 	if (getmsg(fd, &ctl, (struct strbuf*)NULL, &flags) < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "recv_ack: %s getmsg", what);
 		return (PCAP_ERROR);
 	}
@@ -1220,7 +1218,7 @@ recv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror
 		case DL_SYSERR:
 			if (uerror != NULL)
 				*uerror = dlp->error_ack.dl_unix_errno;
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    dlp->error_ack.dl_unix_errno,
 			    "recv_ack: %s: UNIX error", what);
 			if (dlp->error_ack.dl_unix_errno == EPERM ||
@@ -1577,7 +1575,7 @@ get_release(char *buf, size_t bufsize, bpf_u_int32 *majorp,
 	*minorp = 0;
 	*microp = 0;
 	if (sysinfo(SI_RELEASE, buf, bufsize) < 0) {
-		pcap_strlcpy(buf, "?", bufsize);
+		pcapint_strlcpy(buf, "?", bufsize);
 		return;
 	}
 	cp = buf;
@@ -1676,7 +1674,7 @@ get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
 	 */
 	/* get the head first */
 	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "get_dlpi_ppa: hpppa getmsg");
 		return (PCAP_ERROR);
 	}
@@ -1703,7 +1701,7 @@ get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
 
 	/* allocate buffer */
 	if ((ppa_data_buf = (char *)malloc(dlp->dl_length)) == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "get_dlpi_ppa: hpppa malloc");
 		return (PCAP_ERROR);
 	}
@@ -1712,7 +1710,7 @@ get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
 	ctl.buf = (char *)ppa_data_buf;
 	/* get the data */
 	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "get_dlpi_ppa: hpppa getmsg");
 		free(ppa_data_buf);
 		return (PCAP_ERROR);
@@ -1782,7 +1780,7 @@ get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
 		 */
 		snprintf(dname, sizeof(dname), "/dev/%s%u", device, unit);
 		if (stat(dname, &statbuf) < 0) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "stat: %s", dname);
 			return (PCAP_ERROR);
 		}
@@ -1855,7 +1853,7 @@ get_dlpi_ppa(register int fd, register const char *ifname, register u_int unit,
 	}
 	kd = open("/dev/kmem", O_RDONLY);
 	if (kd < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "kmem open");
 		return (PCAP_ERROR);
 	}
@@ -1890,13 +1888,13 @@ dlpi_kread(register int fd, register off_t addr,
 	register int cc;
 
 	if (lseek(fd, addr, SEEK_SET) < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "lseek");
 		return (-1);
 	}
 	cc = read(fd, buf, len);
 	if (cc < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "read");
 		return (-1);
 	} else if (cc != len) {
@@ -1909,7 +1907,7 @@ dlpi_kread(register int fd, register off_t addr,
 #endif
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 #ifdef DL_HP_RAWDLS
diff --git a/pcap-dos.c b/pcap-dos.c
index 897118b1..5093c5f0 100644
--- a/pcap-dos.c
+++ b/pcap-dos.c
@@ -92,7 +92,7 @@ static int ref_count = 0;
 static u_long mac_count    = 0;
 static u_long filter_count = 0;
 
-static volatile BOOL exc_occured = 0;
+static volatile BOOL exc_occurred = 0;
 
 static struct device *handle_to_device [20];
 
@@ -250,7 +250,7 @@ pcap_read_one (pcap_t *p, pcap_handler callback, u_char *data)
     }
   }
 
-  while (!exc_occured)
+  while (!exc_occurred)
   {
     volatile struct device *dev; /* might be reset by sig_handler */
 
@@ -480,7 +480,7 @@ static void pcap_cleanup_dos (pcap_t *p)
 {
   struct pcap_dos *pd;
 
-  if (!exc_occured)
+  if (!exc_occurred)
   {
     pd = p->priv;
     if (pcap_stats(p,NULL) < 0)
@@ -599,7 +599,7 @@ int pcap_platform_finddevs  (pcap_if_list_t *devlistp, char *errbuf)
      * a wired device, and set PCAP_IF_CONNECTION_STATUS_CONNECTED
      * or PCAP_IF_CONNECTION_STATUS_DISCONNECTED?
      */
-    if ((curdev = add_dev(devlistp, dev->name, 0,
+    if ((curdev = pcap_add_dev(devlistp, dev->name, 0,
                 dev->long_name, errbuf)) == NULL)
     {
       ret = -1;
@@ -618,7 +618,7 @@ int pcap_platform_finddevs  (pcap_if_list_t *devlistp, char *errbuf)
     broadaddr = (struct sockaddr*) &sa_ll_2;
     memset (&sa_ll_2.sin_addr, 0xFF, sizeof(sa_ll_2.sin_addr));
 
-    if (add_addr_to_dev(curdev, addr, sizeof(*addr),
+    if (pcap_add_addr_to_dev(curdev, addr, sizeof(*addr),
                         netmask, sizeof(*netmask),
                         broadaddr, sizeof(*broadaddr),
                         dstaddr, sizeof(*dstaddr), errbuf) < 0)
@@ -663,7 +663,7 @@ void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait)
 }
 
 /*
- * Initialise a named network device.
+ * Initialize a named network device.
  */
 static struct device *
 open_driver (const char *dev_name, char *ebuf, int promisc)
@@ -741,7 +741,7 @@ not_probed:
 }
 
 /*
- * Deinitialise MAC driver.
+ * Deinitialize MAC driver.
  * Set receive mode back to default mode.
  */
 static void close_driver (void)
@@ -803,7 +803,7 @@ static void exc_handler (int sig)
     default:
          fprintf (stderr, "Catching signal %d.\n", sig);
   }
-  exc_occured = 1;
+  exc_occurred = 1;
   close_driver();
 }
 #endif  /* __DJGPP__ */
@@ -850,7 +850,7 @@ static int first_init (const char *name, char *ebuf, int promisc)
 #ifdef USE_32BIT_DRIVERS
   /*
    * If driver is NOT a 16-bit "pkt/ndis" driver (having a 'copy_rx_buf'
-   * set in it's probe handler), initialise near-memory ring-buffer for
+   * set in it's probe handler), initialize near-memory ring-buffer for
    * the 32-bit device.
    */
   if (dev->copy_rx_buf == NULL)
@@ -1001,7 +1001,7 @@ static int init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf)
   has_ip_addr = (rc != 8);  /* IP-address assignment failed */
 
   /* if pcap is using a 32-bit driver w/o a pktdrvr loaded, we
-   * just pretend Watt-32 is initialised okay.
+   * just pretend Watt-32 is initialized okay.
    *
    * !! fix-me: The Watt-32 config isn't done if no pktdrvr
    *            was found. In that case my_ip_addr + sin_mask
@@ -1295,7 +1295,7 @@ struct device tc90xbc_dev LOCKED_VAR = {
 
 struct device wd_dev LOCKED_VAR = {
               "wd",
-              "Westen Digital",
+              "Western Digital",
               0,
               0,0,0,0,0,0,
               &tc90xbc_dev,
diff --git a/pcap-dpdk.c b/pcap-dpdk.c
index 025a6748..794fae39 100644
--- a/pcap-dpdk.c
+++ b/pcap-dpdk.c
@@ -70,14 +70,12 @@ mkdir -p build && cd build && cmake -DDPDK_DIR=$RTE_SDK/$RTE_TARGET ../ && make
 
 4. Link your own program with libpcap, and use DPDK with the device name as dpdk:{portid}, such as dpdk:0.
 And you shall set DPDK configure options by environment variable DPDK_CFG
-For example, the testprogs/capturetest could be lanched by:
+For example, the testprogs/capturetest could be launched by:
 
 env DPDK_CFG="--log-level=debug -l0 -dlibrte_pmd_e1000.so -dlibrte_pmd_ixgbe.so -dlibrte_mempool_ring.so" ./capturetest -i dpdk:0
 */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <errno.h>
 #include <netdb.h>
@@ -407,7 +405,7 @@ static int pcap_dpdk_dispatch(pcap_t *p, int max_cnt, pcap_handler cb, u_char *c
 
 			}
 			if (bp){
-				if (p->fcode.bf_insns==NULL || pcap_filter(p->fcode.bf_insns, bp, pcap_header.len, pcap_header.caplen)){
+				if (p->fcode.bf_insns==NULL || pcapint_filter(p->fcode.bf_insns, bp, pcap_header.len, pcap_header.caplen)){
 					cb(cb_arg, &pcap_header, bp);
 				}else{
 					pd->bpf_drop++;
@@ -427,7 +425,7 @@ static int pcap_dpdk_dispatch(pcap_t *p, int max_cnt, pcap_handler cb, u_char *c
 static int pcap_dpdk_inject(pcap_t *p, const void *buf _U_, int size _U_)
 {
 	//not implemented yet
-	pcap_strlcpy(p->errbuf,
+	pcapint_strlcpy(p->errbuf,
 	    "dpdk error: Inject function has not been implemented yet",
 	    PCAP_ERRBUF_SIZE);
 	return PCAP_ERROR;
@@ -446,7 +444,7 @@ static void pcap_dpdk_close(pcap_t *p)
 	}
 	rte_eth_dev_stop(pd->portid);
 	rte_eth_dev_close(pd->portid);
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static void nic_stats_display(struct pcap_dpdk *pd)
@@ -529,8 +527,8 @@ static void eth_addr_str(ETHER_ADDR_TYPE *addrp, char* mac_str, int len)
 static uint16_t portid_by_device(char * device)
 {
 	uint16_t ret = DPDK_PORTID_MAX;
-	int len = strlen(device);
-	int prefix_len = strlen(DPDK_PREFIX);
+	size_t len = strlen(device);
+	size_t prefix_len = strlen(DPDK_PREFIX);
 	unsigned long ret_ul = 0L;
 	char *pEnd;
 	if (len<=prefix_len || strncmp(device, DPDK_PREFIX, prefix_len)) // check prefix dpdk:
@@ -570,7 +568,7 @@ static int parse_dpdk_cfg(char* dpdk_cfg,char** dargv)
 			skip_space=!skip_space; // skip normal char
 			dargv[cnt++] = dpdk_cfg+i;
 		}
-		if (!skip_space && dpdk_cfg[i]==' '){ // fint a space
+		if (!skip_space && dpdk_cfg[i]==' '){ // find a space
 			dpdk_cfg[i]=0x00; // end of this opt
 			skip_space=!skip_space; // skip space char
 		}
@@ -600,7 +598,7 @@ static int dpdk_pre_init(char * ebuf, int eaccess_not_fatal)
 	char *dargv[DPDK_ARGC_MAX];
 	char *ptr_dpdk_cfg = NULL;
 	int ret;
-	// globale var
+	// global var
 	if (is_dpdk_pre_inited != 0)
 	{
 		// already inited; did that succeed?
@@ -948,15 +946,15 @@ static int pcap_dpdk_activate(pcap_t *p)
 		p->selectable_fd = p->fd;
 		p->read_op = pcap_dpdk_dispatch;
 		p->inject_op = pcap_dpdk_inject;
-		// using pcap_filter currently, though DPDK provides their own BPF function. Because DPDK BPF needs load a ELF file as a filter.
-		p->setfilter_op = install_bpf_program;
+		// using pcapint_filter currently, though DPDK provides their own BPF function. Because DPDK BPF needs load a ELF file as a filter.
+		p->setfilter_op = pcapint_install_bpf_program;
 		p->setdirection_op = NULL;
 		p->set_datalink_op = NULL;
 		p->getnonblock_op = pcap_dpdk_getnonblock;
 		p->setnonblock_op = pcap_dpdk_setnonblock;
 		p->stats_op = pcap_dpdk_stats;
 		p->cleanup_op = pcap_dpdk_close;
-		p->breakloop_op = pcap_breakloop_common;
+		p->breakloop_op = pcapint_breakloop_common;
 		// set default timeout
 		pd->required_select_timeout.tv_sec = 0;
 		pd->required_select_timeout.tv_usec = DPDK_DEF_MIN_SLEEP_MS*1000;
@@ -966,7 +964,7 @@ static int pcap_dpdk_activate(pcap_t *p)
 
 	if (ret <= PCAP_ERROR) // all kinds of error code
 	{
-		pcap_cleanup_live_common(p);
+		pcapint_cleanup_live_common(p);
 	}else{
 		rte_eth_dev_get_name_by_port(portid,pd->pci_addr);
 		RTE_LOG(INFO, USER1,"Port %d device: %s, MAC:%s, PCI:%s\n", portid, p->opt.device, pd->mac_addr, pd->pci_addr);
@@ -1041,7 +1039,7 @@ int pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *ebuf)
 			// PCI addr
 			rte_eth_dev_get_name_by_port(i,pci_addr);
 			snprintf(dpdk_desc,DPDK_DEV_DESC_MAX-1,"%s %s, MAC:%s, PCI:%s", DPDK_DESC, dpdk_name, mac_addr, pci_addr);
-			if (add_dev(devlistp, dpdk_name, 0, dpdk_desc, ebuf)==NULL){
+			if (pcapint_add_dev(devlistp, dpdk_name, 0, dpdk_desc, ebuf)==NULL){
 				ret = PCAP_ERROR;
 				break;
 			}
@@ -1059,7 +1057,7 @@ int pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *ebuf)
  * There are no regular interfaces, just DPDK interfaces.
  */
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
 {
 	return (0);
 }
@@ -1068,7 +1066,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
  * Attempts to open a regular interface fail.
  */
 pcap_t *
-pcap_create_interface(const char *device, char *errbuf)
+pcapint_create_interface(const char *device, char *errbuf)
 {
 	snprintf(errbuf, PCAP_ERRBUF_SIZE,
 	    "This version of libpcap only supports DPDK");
diff --git a/pcap-enet.c b/pcap-enet.c
index 6f0512f3..6b16c4d0 100644
--- a/pcap-enet.c
+++ b/pcap-enet.c
@@ -7,9 +7,7 @@
  * Rayan Zachariassen, CA*Net
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -75,7 +73,7 @@ readloop(int cnt, int if_fd, struct bpf_program *fp, printfunc printit)
 			ph = (struct packet_header *)bp;
 			caplen = ph->tap.th_wirelen > snaplen ? snaplen : ph->tap
 .th_wirelen ;
-			if (pcap_filter(fcode, (char *)ph->packet,
+			if (pcapint_filter(fcode, (char *)ph->packet,
 						ph->tap.th_wirelen, caplen)) {
 				if (cnt >= 0 && --cnt < 0)
 					goto out;
@@ -89,7 +87,7 @@ readloop(int cnt, int if_fd, struct bpf_program *fp, printfunc printit)
 		}
 #else	/* !IBMRTPC */
 		caplen = cc > snaplen ? snaplen : cc ;
-		if (pcap_filter(fcode, buf.hdr.packet, cc, caplen)) {
+		if (pcapint_filter(fcode, buf.hdr.packet, cc, caplen)) {
 			if (cnt >= 0 && --cnt < 0)
 				goto out;
 			(*printit)(buf.hdr.packet, &tv, cc, caplen);
diff --git a/pcap-filter.manmisc.in b/pcap-filter.manmisc.in
index 4b44cee9..bfb692ff 100644
--- a/pcap-filter.manmisc.in
+++ b/pcap-filter.manmisc.in
@@ -18,7 +18,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP-FILTER @MAN_MISC_INFO@ "19 November 2022"
+.TH PCAP-FILTER @MAN_MISC_INFO@ "13 June 2023"
 .SH NAME
 pcap-filter \- packet filter syntax
 .br
@@ -107,7 +107,7 @@ E.g., `\fBether src\fP foo', `\fBarp net\fP 128.3', `\fBtcp port\fP 21',
 If there is no
 .I proto
 qualifier, all protocols consistent with the type are assumed.
-E.g., `\fBsrc\fP foo' means `\fB(ip or arp or rarp) src\fP foo',
+E.g., `\fBsrc\fP foo' means `\fB(ip6 or ip or arp or rarp) src\fP foo',
 `\fBnet\fP bar' means `\fB(ip or arp or rarp) net\fP bar' and
 `\fBport\fP 53' means `\fB(tcp or udp or sctp) port\fP 53'
 (note that these examples use invalid syntax to illustrate the principle).
@@ -212,7 +212,7 @@ number (e.g., 10); the netmask is 255.255.255.255 for a dotted quad
 (which means that it's really a host match), 255.255.255.0 for a dotted
 triple, 255.255.0.0 for a dotted pair, or 255.0.0.0 for a single number.
 An IPv6 network number must be written out fully; the netmask is
-ff:ff:ff:ff:ff:ff:ff:ff, so IPv6 "network" matches are really always
+ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff, so IPv6 "network" matches are really always
 host matches, and a network match requires a netmask length.
 .IP "\fBsrc net \fInetnameaddr\fR"
 True if the IPv4/v6 source address of the packet has a network
@@ -555,6 +555,9 @@ Packet was sent by the host performing the capture rather than being
 received by that host.  This is only supported for certain link-layer types,
 such as SLIP and the ``cooked'' Linux capture mode
 used for the ``any'' device and for some other device types.
+.IP "\fBifindex \fIinterface_index\fR"
+True if the packet was logged via the specified interface (applies only to
+packets logged by the Linux "any" cooked v2 interface).
 .IP "\fBifname \fIinterface\fR"
 True if the packet was logged as coming from the specified interface (applies
 only to packets logged by OpenBSD's or FreeBSD's
@@ -1042,8 +1045,6 @@ Alternation (`\fB||\fP' or `\fBor\fP').
 Negation has the highest precedence.
 Alternation and concatenation have equal precedence and associate
 left to right.
-Note that explicit \fBand\fR tokens, not juxtaposition,
-are now required for concatenation.
 .LP
 If an identifier is given without a keyword, the most recent keyword
 is assumed.
@@ -1174,6 +1175,10 @@ TCP flag names became available in libpcap 1.9.0.
 The
 .B geneve
 keyword became available in libpcap 1.8.0.
+.PP
+The
+.B ifindex
+keyword became available in libpcap 1.10.0.
 .SH SEE ALSO
 .BR pcap (3PCAP)
 .SH BUGS
diff --git a/pcap-haiku.c b/pcap-haiku.c
new file mode 100644
index 00000000..6cb0e71a
--- /dev/null
+++ b/pcap-haiku.c
@@ -0,0 +1,504 @@
+/*
+ * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Axel Drfler, axeld@pinc-software.de
+ *		James Woodcock
+ */
+
+
+#include <config.h>
+#include "pcap-int.h"
+
+#include <OS.h>
+
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/utsname.h>
+
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+#include <net/if_media.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdint.h>
+
+
+// IFT_TUN was renamed to IFT_TUNNEL in the master branch after R1/beta4 (the
+// integer value didn't change).  Even though IFT_TUN is a no-op in versions
+// that define it, for the time being it is desirable to support compiling
+// libpcap on versions with the old macro and using it on later versions that
+// support tunnel interfaces.
+#ifndef IFT_TUNNEL
+#define IFT_TUNNEL IFT_TUN
+#endif
+
+/*
+ * Private data for capturing on Haiku sockets.
+ */
+struct pcap_haiku {
+	struct pcap_stat	stat;
+	int aux_socket;
+	struct ifreq ifreq;
+	// The original state of the promiscuous mode at the activation time,
+	// if the capture should be run in promiscuous mode.
+	int orig_promisc;
+};
+
+
+static int
+pcap_read_haiku(pcap_t* handle, int maxPackets _U_, pcap_handler callback,
+	u_char* userdata)
+{
+	// Receive a single packet
+
+	u_char* buffer = (u_char*)handle->buffer;
+	ssize_t bytesReceived;
+	do {
+		if (handle->break_loop) {
+			handle->break_loop = 0;
+			return PCAP_ERROR_BREAK;
+		}
+		bytesReceived = recvfrom(handle->fd, buffer, handle->bufsize, MSG_TRUNC,
+		                         NULL, NULL);
+	} while (bytesReceived < 0 && errno == B_INTERRUPTED);
+
+	// The kernel does not implement timestamping of network packets, so
+	// doing it ASAP in userland is the best that can be done.
+	bigtime_t ts = real_time_clock_usecs();
+
+	if (bytesReceived < 0) {
+		if (errno == B_WOULD_BLOCK) {
+			// there is no packet for us
+			return 0;
+		}
+
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		    errno, "recvfrom");
+		return PCAP_ERROR;
+	}
+
+	struct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;
+	// BPF is 32-bit, which is more than sufficient for any realistic
+	// packet size.
+	if (bytesReceived > UINT32_MAX)
+		goto drop;
+	// At this point, if the recvfrom() call populated its struct sockaddr
+	// and socklen_t arguments, it would be the right time to drop packets
+	// that have .sa_family not valid for the current DLT.  But in the
+	// current master branch (hrev57588) this would erroneously drop some
+	// valid packets: recvfrom(), at least for tap mode tunnels, sets the
+	// address length to 0 for all incoming packets and sets .sa_len and
+	// .sa_family to 0 for packets that are broadcast or multicast.  So it
+	// cannot be done yet, if there is a good reason to do it in the first
+	// place.
+	handlep->stat.ps_recv++;
+
+	bpf_u_int32 wireLength = (bpf_u_int32)bytesReceived;
+	// As long as the buffer is large enough, the captured length is equal
+	// to the wire length, but let's get the lengths right anyway in case
+	// packets grow bigger or the buffer grows smaller in future and the
+	// MSG_TRUNC effect kicks in.
+	bpf_u_int32 captureLength =
+		wireLength <= handle->bufsize ? wireLength : handle->bufsize;
+
+	// run the packet filter
+	if (handle->fcode.bf_insns) {
+		// NB: pcapint_filter() takes the wire length and the captured
+		// length, not the snapshot length of the pcap_t handle.
+		if (pcapint_filter(handle->fcode.bf_insns, buffer, wireLength,
+		                   captureLength) == 0)
+			goto drop;
+	}
+
+	// fill in pcap_header
+	struct pcap_pkthdr header;
+	header.caplen = captureLength <= (bpf_u_int32)handle->snapshot ?
+	                captureLength :
+	                (bpf_u_int32)handle->snapshot;
+	header.len = wireLength;
+	header.ts.tv_usec = ts % 1000000;
+	header.ts.tv_sec = ts / 1000000;
+
+	/* Call the user supplied callback function */
+	callback(userdata, &header, buffer);
+	return 1;
+drop:
+	handlep->stat.ps_drop++;
+	return 0;
+}
+
+
+static int
+dgram_socket(const int af, char *errbuf)
+{
+	int ret = socket(af, SOCK_DGRAM, 0);
+	if (ret < 0) {
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		    "socket");
+		return PCAP_ERROR;
+	}
+	return ret;
+}
+
+
+static int
+ioctl_ifreq(const int fd, const unsigned long op, const char *name,
+             struct ifreq *ifreq, char *errbuf)
+{
+	if (ioctl(fd, op, ifreq, sizeof(struct ifreq)) < 0) {
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		    "%s", name);
+		return PCAP_ERROR;
+	}
+	return 0;
+}
+
+
+static int
+get_promisc(pcap_t *handle)
+{
+	struct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;
+	// SIOCGIFFLAGS would work fine for AF_LINK too.
+	if (ioctl_ifreq(handlep->aux_socket, SIOCGIFFLAGS, "SIOCGIFFLAGS",
+	                &handlep->ifreq, handle->errbuf) < 0)
+		return PCAP_ERROR;
+	return (handlep->ifreq.ifr_flags & IFF_PROMISC) != 0;
+}
+
+
+static int
+set_promisc(pcap_t *handle, const int enable)
+{
+	struct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;
+	if (enable)
+		handlep->ifreq.ifr_flags |= IFF_PROMISC;
+	else
+		handlep->ifreq.ifr_flags &= ~IFF_PROMISC;
+	// SIOCSIFFLAGS works for AF_INET, but not for AF_LINK.
+	return ioctl_ifreq(handlep->aux_socket, SIOCSIFFLAGS, "SIOCSIFFLAGS",
+	                   &handlep->ifreq, handle->errbuf);
+}
+
+
+static void
+pcap_cleanup_haiku(pcap_t *handle)
+{
+	struct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;
+	if (handlep->aux_socket >= 0) {
+		// Closing the sockets has no effect on IFF_PROMISC, hence the
+		// need to restore the original state on one hand and the
+		// possibility of clash with other processes managing the same
+		// interface flag.  Unset promiscuous mode iff the activation
+		// function had set it and it is still set now.
+		if (handle->opt.promisc && ! handlep->orig_promisc &&
+		    get_promisc(handle))
+			(void)set_promisc(handle, 0);
+		close(handlep->aux_socket);
+		handlep->aux_socket = -1;
+	}
+	pcapint_cleanup_live_common(handle);
+}
+
+
+static int
+pcap_inject_haiku(pcap_t *handle, const void *buffer _U_, int size _U_)
+{
+	// Haiku currently (hrev57588) does not support sending raw packets.
+	// https://dev.haiku-os.org/ticket/18810
+	strlcpy(handle->errbuf, "Sending packets isn't supported yet",
+		PCAP_ERRBUF_SIZE);
+	return PCAP_ERROR;
+}
+
+
+static int
+pcap_stats_haiku(pcap_t *handle, struct pcap_stat *stats)
+{
+	struct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;
+	*stats = handlep->stat;
+	// Now ps_recv and ps_drop are accurate, but ps_ifdrop still equals to
+	// the snapshot value from the activation time.
+	if (ioctl_ifreq(handlep->aux_socket, SIOCGIFSTATS, "SIOCGIFSTATS",
+	                &handlep->ifreq, handle->errbuf) < 0)
+		return PCAP_ERROR;
+	// The result is subject to wrapping around the 32-bit integer space,
+	// but that cannot be significantly improved as long as it has to fit
+	// into a 32-bit member of pcap_stats.
+	stats->ps_ifdrop = handlep->ifreq.ifr_stats.receive.dropped - stats->ps_ifdrop;
+	return 0;
+}
+
+
+static int
+pcap_activate_haiku(pcap_t *handle)
+{
+	struct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;
+	int ret = PCAP_ERROR;
+
+	// we need a socket to talk to the networking stack
+	if ((handlep->aux_socket = dgram_socket(AF_INET, handle->errbuf)) < 0)
+		goto error;
+
+	// pcap_stats_haiku() will need a baseline for ps_ifdrop.
+	// At the time of this writing SIOCGIFSTATS returns EINVAL for AF_LINK
+	// sockets.
+	if (ioctl_ifreq(handlep->aux_socket, SIOCGIFSTATS, "SIOCGIFSTATS",
+	                &handlep->ifreq, handle->errbuf) < 0) {
+		// Detect a non-existent network interface at least at the
+		// first ioctl() use.
+		if (errno == EINVAL)
+			ret = PCAP_ERROR_NO_SUCH_DEVICE;
+		goto error;
+	}
+	handlep->stat.ps_ifdrop = handlep->ifreq.ifr_stats.receive.dropped;
+
+	// get link level interface for this interface
+	if ((handle->fd = dgram_socket(AF_LINK, handle->errbuf)) < 0)
+		goto error;
+
+	// Derive a DLT from the interface type.
+	// At the time of this writing SIOCGIFTYPE cannot be used for this
+	// purpose: it returns EINVAL for AF_LINK sockets and sets ifr_type to
+	// 0 for AF_INET sockets.  Use the same method as Haiku ifconfig does
+	// (SIOCGIFADDR and AF_LINK).
+	if (ioctl_ifreq(handle->fd, SIOCGIFADDR, "SIOCGIFADDR",
+	                &handlep->ifreq, handle->errbuf) < 0)
+		goto error;
+	struct sockaddr_dl *sdl = (struct sockaddr_dl *)&handlep->ifreq.ifr_addr;
+	if (sdl->sdl_family != AF_LINK) {
+		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
+		         "Got AF %d instead of AF_LINK for interface \"%s\".",
+		         sdl->sdl_family, handle->opt.device);
+		goto error;
+	}
+	switch (sdl->sdl_type) {
+	case IFT_ETHER:
+		// Ethernet on all versions, also tap (L2) mode tunnels on
+		// versions after R1/beta4.
+		handle->linktype = DLT_EN10MB;
+		break;
+	case IFT_TUNNEL:
+		// Unused on R1/beta4 and earlier versions, tun (L3) mode
+		// tunnels on later versions.
+	case IFT_LOOP:
+		// The loopback interface on all versions.
+		// Both IFT_TUNNEL and IFT_LOOP prepended a dummy Ethernet
+		// header until hrev57585: https://dev.haiku-os.org/ticket/18801
+		handle->linktype = DLT_RAW;
+		break;
+	default:
+		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
+		         "Unknown interface type 0x%0x for interface \"%s\".",
+		         sdl->sdl_type, handle->opt.device);
+		goto error;
+	}
+
+	// start monitoring
+	if (ioctl_ifreq(handle->fd, SIOCSPACKETCAP, "SIOCSPACKETCAP",
+	                &handlep->ifreq, handle->errbuf) < 0)
+		goto error;
+
+	handle->selectable_fd = handle->fd;
+	handle->read_op = pcap_read_haiku;
+	handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */
+	handle->inject_op = pcap_inject_haiku;
+	handle->stats_op = pcap_stats_haiku;
+	handle->cleanup_op = pcap_cleanup_haiku;
+
+	// use default hooks where possible
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
+
+	/*
+	 * Turn a negative snapshot value (invalid), a snapshot value of
+	 * 0 (unspecified), or a value bigger than the normal maximum
+	 * value, into the maximum allowed value.
+	 *
+	 * If some application really *needs* a bigger snapshot
+	 * length, we should just increase MAXIMUM_SNAPLEN.
+	 */
+	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
+		handle->snapshot = MAXIMUM_SNAPLEN;
+
+	// Although it would be trivial to size the buffer at the kernel end of
+	// the capture socket using setsockopt() and SO_RCVBUF, there seems to
+	// be no point in doing so: setting the size low silently drops some
+	// packets in the kernel, setting it high does not result in a visible
+	// improvement.  Let's leave this buffer as it is until it is clear why
+	// it would need resizing.  Meanwhile pcap_set_buffer_size() will have
+	// no effect on Haiku.
+
+	// It would be wrong to size the buffer at the libpcap end of the
+	// capture socket to the interface MTU, which limits only outgoing
+	// packets and only at layer 3.  For example, an Ethernet interface
+	// with ifconfig/ioctl() MTU set to 1500 ordinarily sends layer 2
+	// packets as large as 1514 bytes and receives layer 2 packets as large
+	// as the NIC and the driver happen to accept (e.g. 9018 bytes for
+	// ipro1000).  This way, valid packets larger than the MTU can occur in
+	// a capture and will arrive truncated to pcap_read_haiku() if the
+	// buffer is not large enough.  So let's keep it large enough for most
+	// if not all practical use cases, then pcap_read_haiku() can handle
+	// the unlikely truncation as and if necessary.
+	handle->bufsize = 65536;
+
+	// allocate buffer for monitoring the device
+	handle->buffer = (u_char*)malloc(handle->bufsize);
+	if (handle->buffer == NULL) {
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+			errno, "buffer malloc");
+		goto error;
+	}
+
+	if (handle->opt.promisc) {
+		// Set promiscuous mode iff required, in any case remember the
+		// original state.
+		if ((handlep->orig_promisc = get_promisc(handle)) < 0)
+			goto error;
+		if (! handlep->orig_promisc && set_promisc(handle, 1) < 0)
+			return PCAP_WARNING_PROMISC_NOTSUP;
+	}
+	return 0;
+error:
+	pcap_cleanup_haiku(handle);
+	return ret;
+}
+
+
+static int
+validate_ifname(const char *device, char *errbuf)
+{
+	if (strlen(device) >= IF_NAMESIZE) {
+		snprintf(errbuf, PCAP_ERRBUF_SIZE,
+		         "Interface name \"%s\" is too long.", device);
+		return PCAP_ERROR;
+	}
+	return 0;
+}
+
+
+//	#pragma mark - pcap API
+
+
+static int
+can_be_bound(const char *name)
+{
+	if (strcmp(name, "loop") != 0)
+		return 1;
+
+	// In Haiku versions before hrev57010 the loopback interface allows to
+	// start a capture, but the capture never receives any packets.
+	//
+	// Since compiling libpcap on one Haiku version and using the binary on
+	// another seems to be commonplace, comparing B_HAIKU_VERSION at the
+	// compile time would not always work as intended.  Let's at least
+	// remove unsuitable well-known 64-bit versions (with or without
+	// updates) from the problem space at run time.
+	const char *badversions[] = {
+		"hrev56578", // R1/beta4
+		"hrev55182", // R1/beta3
+		"hrev54154", // R1/beta2
+		"hrev52295", // R1/beta1
+		"hrev44702", // R1/alpha4
+		NULL
+	};
+	struct utsname uts;
+	(void)uname(&uts);
+	for (const char **s = badversions; *s; s++)
+		if (! strncmp(uts.version, *s, strlen(*s)))
+			return 0;
+	return 1;
+}
+
+
+pcap_t *
+pcapint_create_interface(const char *device, char *errorBuffer)
+{
+	if (validate_ifname(device, errorBuffer) < 0)
+		return NULL;
+	if (! can_be_bound(device)) {
+		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
+		         "Interface \"%s\" does not support capturing traffic.", device);
+		return NULL;
+	}
+
+	pcap_t* handle = PCAP_CREATE_COMMON(errorBuffer, struct pcap_haiku);
+	if (handle == NULL)
+		return NULL;
+	handle->activate_op = pcap_activate_haiku;
+
+	struct pcap_haiku *handlep = (struct pcap_haiku *)handle->priv;
+	handlep->aux_socket = -1;
+	strcpy(handlep->ifreq.ifr_name, device);
+
+	return handle;
+}
+
+
+static int
+get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
+{
+	if (validate_ifname(name, errbuf) < 0)
+		return PCAP_ERROR;
+
+	if (*flags & PCAP_IF_LOOPBACK ||
+	    ! strncmp(name, "tun", strlen("tun")) ||
+	    ! strncmp(name, "tap", strlen("tap"))) {
+		/*
+		 * Loopback devices aren't wireless, and "connected"/
+		 * "disconnected" doesn't apply to them.
+		 *
+		 * Neither does it to tunnel interfaces.  A tun mode tunnel
+		 * can be identified by the IFT_TUNNEL value, but tap mode
+		 * tunnels and Ethernet interfaces both use IFT_ETHER, so let's
+		 * use the interface name prefix until there is a better
+		 * solution.
+		 */
+		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
+		return (0);
+	}
+
+	int fd = dgram_socket(AF_LINK, errbuf);
+	if (fd < 0)
+		return PCAP_ERROR;
+	struct ifreq ifreq;
+	strcpy(ifreq.ifr_name, name);
+	if (ioctl_ifreq(fd, SIOCGIFFLAGS, "SIOCGIFFLAGS", &ifreq, errbuf) < 0) {
+		close(fd);
+		return PCAP_ERROR;
+	}
+	*flags |= (ifreq.ifr_flags & IFF_LINK) ?
+	          PCAP_IF_CONNECTION_STATUS_CONNECTED :
+	          PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
+	if (ioctl_ifreq(fd, SIOCGIFMEDIA, "SIOCGIFMEDIA", &ifreq, errbuf) < 0) {
+		close(fd);
+		return PCAP_ERROR;
+	}
+	if (IFM_TYPE(ifreq.ifr_media) == IFM_IEEE80211)
+		*flags |= PCAP_IF_WIRELESS;
+	close(fd);
+
+	return (0);
+}
+
+int
+pcapint_platform_finddevs(pcap_if_list_t* _allDevices, char* errorBuffer)
+{
+	return pcapint_findalldevs_interfaces(_allDevices, errorBuffer, can_be_bound,
+		get_if_flags);
+}
+
+/*
+ * Libpcap version string.
+ */
+const char *
+pcap_lib_version(void)
+{
+	return (PCAP_VERSION_STRING);
+}
diff --git a/pcap-haiku.cpp b/pcap-haiku.cpp
deleted file mode 100644
index 8ae9119c..00000000
--- a/pcap-haiku.cpp
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.
- * Distributed under the terms of the MIT License.
- *
- * Authors:
- *		Axel Drfler, axeld@pinc-software.de
- *		James Woodcock
- */
-
-
-#include "config.h"
-#include "pcap-int.h"
-
-#include <OS.h>
-
-#include <sys/socket.h>
-#include <sys/sockio.h>
-
-#include <net/if.h>
-#include <net/if_dl.h>
-#include <net/if_types.h>
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-/*
- * Private data for capturing on Haiku sockets.
- */
-struct pcap_haiku {
-	struct pcap_stat	stat;
-	char	*device;	/* device name */
-};
-
-
-bool
-prepare_request(struct ifreq& request, const char* name)
-{
-	if (strlen(name) >= IF_NAMESIZE)
-		return false;
-
-	strcpy(request.ifr_name, name);
-	return true;
-}
-
-
-static int
-pcap_read_haiku(pcap_t* handle, int maxPackets _U_, pcap_handler callback,
-	u_char* userdata)
-{
-	// Receive a single packet
-
-	u_char* buffer = (u_char*)handle->buffer + handle->offset;
-	struct sockaddr_dl from;
-	ssize_t bytesReceived;
-	do {
-		if (handle->break_loop) {
-			// Clear the break loop flag, and return -2 to indicate our
-			// reasoning
-			handle->break_loop = 0;
-			return -2;
-		}
-
-		socklen_t fromLength = sizeof(from);
-		bytesReceived = recvfrom(handle->fd, buffer, handle->bufsize, MSG_TRUNC,
-			(struct sockaddr*)&from, &fromLength);
-	} while (bytesReceived < 0 && errno == B_INTERRUPTED);
-
-	if (bytesReceived < 0) {
-		if (errno == B_WOULD_BLOCK) {
-			// there is no packet for us
-			return 0;
-		}
-
-		snprintf(handle->errbuf, sizeof(handle->errbuf),
-			"recvfrom: %s", strerror(errno));
-		return -1;
-	}
-
-	int32 captureLength = bytesReceived;
-	if (captureLength > handle->snapshot)
-		captureLength = handle->snapshot;
-
-	// run the packet filter
-	if (handle->fcode.bf_insns) {
-		if (pcap_filter(handle->fcode.bf_insns, buffer, bytesReceived,
-				captureLength) == 0) {
-			// packet got rejected
-			return 0;
-		}
-	}
-
-	// fill in pcap_header
-	pcap_pkthdr header;
-	header.caplen = captureLength;
-	header.len = bytesReceived;
-	header.ts.tv_usec = system_time() % 1000000;
-	header.ts.tv_sec = system_time() / 1000000;
-	// TODO: get timing from packet!!!
-
-	/* Call the user supplied callback function */
-	callback(userdata, &header, buffer);
-	return 1;
-}
-
-
-static int
-pcap_inject_haiku(pcap_t *handle, const void *buffer, int size)
-{
-	// we don't support injecting packets yet
-	// TODO: use the AF_LINK protocol (we need another socket for this) to
-	// inject the packets
-	strlcpy(handle->errbuf, "Sending packets isn't supported yet",
-		PCAP_ERRBUF_SIZE);
-	return -1;
-}
-
-
-static int
-pcap_stats_haiku(pcap_t *handle, struct pcap_stat *stats)
-{
-	struct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;
-	ifreq request;
-	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);
-	if (socket < 0) {
-		return -1;
-	}
-	prepare_request(request, handlep->device);
-	if (ioctl(socket, SIOCGIFSTATS, &request, sizeof(struct ifreq)) < 0) {
-		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, "pcap_stats: %s",
-			strerror(errno));
-		close(socket);
-		return -1;
-	}
-
-	close(socket);
-	handlep->stat.ps_recv += request.ifr_stats.receive.packets;
-	handlep->stat.ps_drop += request.ifr_stats.receive.dropped;
-	*stats = handlep->stat;
-	return 0;
-}
-
-
-static int
-pcap_activate_haiku(pcap_t *handle)
-{
-	struct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;
-
-	const char* device = handle->opt.device;
-
-	handle->read_op = pcap_read_haiku;
-	handle->setfilter_op = install_bpf_program; /* no kernel filtering */
-	handle->inject_op = pcap_inject_haiku;
-	handle->stats_op = pcap_stats_haiku;
-
-	// use default hooks where possible
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
-
-	/*
-	 * Turn a negative snapshot value (invalid), a snapshot value of
-	 * 0 (unspecified), or a value bigger than the normal maximum
-	 * value, into the maximum allowed value.
-	 *
-	 * If some application really *needs* a bigger snapshot
-	 * length, we should just increase MAXIMUM_SNAPLEN.
-	 */
-	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
-		handle->snapshot = MAXIMUM_SNAPLEN;
-
-	handlep->device	= strdup(device);
-	if (handlep->device == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
-			errno, "strdup");
-		return PCAP_ERROR;
-	}
-
-	handle->bufsize = 65536;
-	// TODO: should be determined by interface MTU
-
-	// allocate buffer for monitoring the device
-	handle->buffer = (u_char*)malloc(handle->bufsize);
-	if (handle->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
-			errno, "buffer malloc");
-		return PCAP_ERROR;
-	}
-
-	handle->offset = 0;
-	handle->linktype = DLT_EN10MB;
-	// TODO: check interface type!
-
-	return 0;
-}
-
-
-//	#pragma mark - pcap API
-
-
-extern "C" pcap_t *
-pcap_create_interface(const char *device, char *errorBuffer)
-{
-	// TODO: handle promiscuous mode!
-
-	// we need a socket to talk to the networking stack
-	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);
-	if (socket < 0) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
-			"The networking stack doesn't seem to be available.\n");
-		return NULL;
-	}
-
-	struct ifreq request;
-	if (!prepare_request(request, device)) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
-			"Interface name \"%s\" is too long.", device);
-		close(socket);
-		return NULL;
-	}
-
-	// check if the interface exist
-	if (ioctl(socket, SIOCGIFINDEX, &request, sizeof(request)) < 0) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
-			"Interface \"%s\" does not exist.\n", device);
-		close(socket);
-		return NULL;
-	}
-
-	close(socket);
-	// no longer needed after this point
-
-	// get link level interface for this interface
-
-	socket = ::socket(AF_LINK, SOCK_DGRAM, 0);
-	if (socket < 0) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, "No link level: %s\n",
-			strerror(errno));
-		return NULL;
-	}
-
-	// start monitoring
-	if (ioctl(socket, SIOCSPACKETCAP, &request, sizeof(struct ifreq)) < 0) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, "Cannot start monitoring: %s\n",
-			strerror(errno));
-		close(socket);
-		return NULL;
-	}
-
-	struct wrapper_struct { pcap_t __common; struct pcap_haiku __private; };
-	pcap_t* handle = pcap_create_common(errorBuffer,
-		sizeof (struct wrapper_struct),
-		offsetof (struct wrapper_struct, __private));
-
-	if (handle == NULL) {
-		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, "malloc: %s", strerror(errno));
-		close(socket);
-		return NULL;
-	}
-
-	handle->selectable_fd = socket;
-	handle->fd = socket;
-
-	handle->activate_op = pcap_activate_haiku;
-
-	return handle;
-}
-
-static int
-can_be_bound(const char *name _U_)
-{
-	return 1;
-}
-
-static int
-get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
-{
-	/* TODO */
-	if (*flags & PCAP_IF_LOOPBACK) {
-		/*
-		 * Loopback devices aren't wireless, and "connected"/
-		 * "disconnected" doesn't apply to them.
-		 */
-		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
-		return (0);
-	}
-	return (0);
-}
-
-extern "C" int
-pcap_platform_finddevs(pcap_if_list_t* _allDevices, char* errorBuffer)
-{
-	return pcap_findalldevs_interfaces(_allDevices, errorBuffer, can_be_bound,
-		get_if_flags);
-}
-
-/*
- * Libpcap version string.
- */
-extern "C" const char *
-pcap_lib_version(void)
-{
-	return (PCAP_VERSION_STRING);
-}
diff --git a/pcap-int.h b/pcap-int.h
index 894e74af..ed0c6829 100644
--- a/pcap-int.h
+++ b/pcap-int.h
@@ -52,6 +52,8 @@
 
 #include "portability.h"
 
+#define PCAP_DEBUG {printf(" [%s:%d %s] ", __FILE__, __LINE__, __func__); fflush(stdout);}
+
 /*
  * If we're compiling with Visual Studio, make sure we have at least
  * VS 2015 or later, so we have sufficient C99 support.
@@ -81,7 +83,7 @@ extern "C" {
 #endif
 
 /*
- * If pcap_new_api is set, we disable pcap_lookupdev(), because:
+ * If pcapint_new_api is set, we disable pcap_lookupdev(), because:
  *
  *    it's not thread-safe, and is marked as deprecated, on all
  *    platforms;
@@ -97,15 +99,15 @@ extern "C" {
  *
  * We also disable the aforementioned hack in pcap_create().
  */
-extern int pcap_new_api;
+extern int pcapint_new_api;
 
 /*
- * If pcap_utf_8_mode is set, on Windows we treat strings as UTF-8.
+ * If pcapint_utf_8_mode is set, on Windows we treat strings as UTF-8.
  *
  * On UN*Xes, we assume all strings are and should be in UTF-8, regardless
  * of the setting of this flag.
  */
-extern int pcap_utf_8_mode;
+extern int pcapint_utf_8_mode;
 
 /*
  * Swap byte ordering of unsigned long long timestamp on a big endian
@@ -369,76 +371,6 @@ struct pcap {
  */
 #define BPF_SPECIAL_VLAN_HANDLING	0x00000001	/* special VLAN handling for Linux */
 
-/*
- * This is a timeval as stored in a savefile.
- * It has to use the same types everywhere, independent of the actual
- * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some
- * platforms and 64-bit tv_sec values on other platforms, and writing
- * out native `struct timeval' values would mean files could only be
- * read on systems with the same tv_sec size as the system on which
- * the file was written.
- */
-
-struct pcap_timeval {
-    bpf_int32 tv_sec;		/* seconds */
-    bpf_int32 tv_usec;		/* microseconds */
-};
-
-/*
- * This is a `pcap_pkthdr' as actually stored in a savefile.
- *
- * Do not change the format of this structure, in any way (this includes
- * changes that only affect the length of fields in this structure),
- * and do not make the time stamp anything other than seconds and
- * microseconds (e.g., seconds and nanoseconds).  Instead:
- *
- *	introduce a new structure for the new format;
- *
- *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting
- *	a new magic number for your new capture file format, and, when
- *	you get the new magic number, put it in "savefile.c";
- *
- *	use that magic number for save files with the changed record
- *	header;
- *
- *	make the code in "savefile.c" capable of reading files with
- *	the old record header as well as files with the new record header
- *	(using the magic number to determine the header format).
- *
- * Then supply the changes by forking the branch at
- *
- *	https://github.com/the-tcpdump-group/libpcap/tree/master
- *
- * and issuing a pull request, so that future versions of libpcap and
- * programs that use it (such as tcpdump) will be able to read your new
- * capture file format.
- */
-
-struct pcap_sf_pkthdr {
-    struct pcap_timeval ts;	/* time stamp */
-    bpf_u_int32 caplen;		/* length of portion present */
-    bpf_u_int32 len;		/* length of this packet (off wire) */
-};
-
-/*
- * How a `pcap_pkthdr' is actually stored in savefiles written
- * by some patched versions of libpcap (e.g. the ones in Red
- * Hat Linux 6.1 and 6.2).
- *
- * Do not change the format of this structure, in any way (this includes
- * changes that only affect the length of fields in this structure).
- * Instead, introduce a new structure, as per the above.
- */
-
-struct pcap_sf_patched_pkthdr {
-    struct pcap_timeval ts;	/* time stamp */
-    bpf_u_int32 caplen;		/* length of portion present */
-    bpf_u_int32 len;		/* length of this packet (off wire) */
-    int		index;
-    unsigned short protocol;
-    unsigned char pkt_type;
-};
-
 /*
  * User data structure for the one-shot callback used for pcap_next()
  * and pcap_next_ex().
@@ -453,7 +385,7 @@ struct oneshot_userdata {
 #define min(a, b) ((a) > (b) ? (b) : (a))
 #endif
 
-int	pcap_offline_read(pcap_t *, int, pcap_handler, u_char *);
+int	pcapint_offline_read(pcap_t *, int, pcap_handler, u_char *);
 
 /*
  * Does the packet count argument to a module's read routine say
@@ -465,41 +397,41 @@ int	pcap_offline_read(pcap_t *, int, pcap_handler, u_char *);
  * Routines that most pcap implementations can use for non-blocking mode.
  */
 #if !defined(_WIN32) && !defined(MSDOS)
-int	pcap_getnonblock_fd(pcap_t *);
-int	pcap_setnonblock_fd(pcap_t *p, int);
+int	pcapint_getnonblock_fd(pcap_t *);
+int	pcapint_setnonblock_fd(pcap_t *p, int);
 #endif
 
 /*
  * Internal interfaces for "pcap_create()".
  *
- * "pcap_create_interface()" is the routine to do a pcap_create on
+ * "pcapint_create_interface()" is the routine to do a pcap_create on
  * a regular network interface.  There are multiple implementations
  * of this, one for each platform type (Linux, BPF, DLPI, etc.),
  * with the one used chosen by the configure script.
  *
- * "pcap_create_common()" allocates and fills in a pcap_t, for use
+ * "pcapint_create_common()" allocates and fills in a pcap_t, for use
  * by pcap_create routines.
  */
-pcap_t	*pcap_create_interface(const char *, char *);
+pcap_t	*pcapint_create_interface(const char *, char *);
 
 /*
  * This wrapper takes an error buffer pointer and a type to use for the
- * private data, and calls pcap_create_common(), passing it the error
+ * private data, and calls pcapint_create_common(), passing it the error
  * buffer pointer, the size for the private data type, in bytes, and the
  * offset of the private data from the beginning of the structure, in
  * bytes.
  */
 #define PCAP_CREATE_COMMON(ebuf, type) \
-	pcap_create_common(ebuf, \
+	pcapint_create_common(ebuf, \
 	    sizeof (struct { pcap_t __common; type __private; }), \
 	    offsetof (struct { pcap_t __common; type __private; }, __private))
-pcap_t	*pcap_create_common(char *, size_t, size_t);
-int	pcap_do_addexit(pcap_t *);
-void	pcap_add_to_pcaps_to_close(pcap_t *);
-void	pcap_remove_from_pcaps_to_close(pcap_t *);
-void	pcap_cleanup_live_common(pcap_t *);
-int	pcap_check_activated(pcap_t *);
-void	pcap_breakloop_common(pcap_t *);
+pcap_t	*pcapint_create_common(char *, size_t, size_t);
+int	pcapint_do_addexit(pcap_t *);
+void	pcapint_add_to_pcaps_to_close(pcap_t *);
+void	pcapint_remove_from_pcaps_to_close(pcap_t *);
+void	pcapint_cleanup_live_common(pcap_t *);
+int	pcapint_check_activated(pcap_t *);
+void	pcapint_breakloop_common(pcap_t *);
 
 /*
  * Internal interfaces for "pcap_findalldevs()".
@@ -509,39 +441,42 @@ void	pcap_breakloop_common(pcap_t *);
  * A get_if_flags_func is a platform-dependent function called to get
  * additional interface flags.
  *
- * "pcap_platform_finddevs()" is the platform-dependent routine to
+ * "pcapint_platform_finddevs()" is the platform-dependent routine to
  * find local network interfaces.
  *
- * "pcap_findalldevs_interfaces()" is a helper to find those interfaces
+ * "pcapint_findalldevs_interfaces()" is a helper to find those interfaces
  * using the "standard" mechanisms (SIOCGIFCONF, "getifaddrs()", etc.).
  *
- * "add_dev()" adds an entry to a pcap_if_list_t.
+ * "pcapint_add_dev()" adds an entry to a pcap_if_list_t.
+ *
+ * "pcap_add_any_dev()" adds an entry for the "any" device to a pcap_if_list_t.
  *
- * "find_dev()" tries to find a device, by name, in a pcap_if_list_t.
+ * "pcapint_find_dev()" tries to find a device, by name, in a pcap_if_list_t.
  *
- * "find_or_add_dev()" checks whether a device is already in a pcap_if_list_t
- * and, if not, adds an entry for it.
+ * "pcapint_find_or_add_dev()" checks whether a device is already in a
+ * pcap_if_list_t and, if not, adds an entry for it.
  */
 struct pcap_if_list;
 typedef struct pcap_if_list pcap_if_list_t;
 typedef int (*get_if_flags_func)(const char *, bpf_u_int32 *, char *);
-int	pcap_platform_finddevs(pcap_if_list_t *, char *);
+int	pcapint_platform_finddevs(pcap_if_list_t *, char *);
 #if !defined(_WIN32) && !defined(MSDOS)
-int	pcap_findalldevs_interfaces(pcap_if_list_t *, char *,
+int	pcapint_findalldevs_interfaces(pcap_if_list_t *, char *,
 	    int (*)(const char *), get_if_flags_func);
 #endif
-pcap_if_t *find_or_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,
+pcap_if_t *pcapint_find_or_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,
 	    get_if_flags_func, const char *, char *);
-pcap_if_t *find_dev(pcap_if_list_t *, const char *);
-pcap_if_t *add_dev(pcap_if_list_t *, const char *, bpf_u_int32, const char *,
-	    char *);
-int	add_addr_to_dev(pcap_if_t *, struct sockaddr *, size_t,
+pcap_if_t *pcapint_find_dev(pcap_if_list_t *, const char *);
+pcap_if_t *pcapint_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,
+	    const char *, char *);
+pcap_if_t *pcap_add_any_dev(pcap_if_list_t *, char *);
+int	pcapint_add_addr_to_dev(pcap_if_t *, struct sockaddr *, size_t,
 	    struct sockaddr *, size_t, struct sockaddr *, size_t,
 	    struct sockaddr *dstaddr, size_t, char *errbuf);
 #ifndef _WIN32
-pcap_if_t *find_or_add_if(pcap_if_list_t *, const char *, bpf_u_int32,
+pcap_if_t *pcapint_find_or_add_if(pcap_if_list_t *, const char *, uint64_t,
 	    get_if_flags_func, char *);
-int	add_addr_to_if(pcap_if_list_t *, const char *, bpf_u_int32,
+int	pcapint_add_addr_to_if(pcap_if_list_t *, const char *, uint64_t,
 	    get_if_flags_func,
 	    struct sockaddr *, size_t, struct sockaddr *, size_t,
 	    struct sockaddr *, size_t, struct sockaddr *, size_t, char *);
@@ -551,43 +486,43 @@ int	add_addr_to_if(pcap_if_list_t *, const char *, bpf_u_int32,
  * Internal interfaces for "pcap_open_offline()" and other savefile
  * I/O routines.
  *
- * "pcap_open_offline_common()" allocates and fills in a pcap_t, for use
+ * "pcapint_open_offline_common()" allocates and fills in a pcap_t, for use
  * by pcap_open_offline routines.
  *
- * "pcap_adjust_snapshot()" adjusts the snapshot to be non-zero and
+ * "pcapint_adjust_snapshot()" adjusts the snapshot to be non-zero and
  * fit within an int.
  *
- * "sf_cleanup()" closes the file handle associated with a pcap_t, if
+ * "pcapint_sf_cleanup()" closes the file handle associated with a pcap_t, if
  * appropriate, and frees all data common to all modules for handling
  * savefile types.
  *
- * "charset_fopen()", in UTF-8 mode on Windows, does an fopen() that
+ * "pcapint_charset_fopen()", in UTF-8 mode on Windows, does an fopen() that
  * treats the pathname as being in UTF-8, rather than the local
  * code page, on Windows.
  */
 
 /*
  * This wrapper takes an error buffer pointer and a type to use for the
- * private data, and calls pcap_create_common(), passing it the error
+ * private data, and calls pcapint_create_common(), passing it the error
  * buffer pointer, the size for the private data type, in bytes, and the
  * offset of the private data from the beginning of the structure, in
  * bytes.
  */
 #define PCAP_OPEN_OFFLINE_COMMON(ebuf, type) \
-	pcap_open_offline_common(ebuf, \
+	pcapint_open_offline_common(ebuf, \
 	    sizeof (struct { pcap_t __common; type __private; }), \
 	    offsetof (struct { pcap_t __common; type __private; }, __private))
-pcap_t	*pcap_open_offline_common(char *ebuf, size_t total_size,
+pcap_t	*pcapint_open_offline_common(char *ebuf, size_t total_size,
     size_t private_data);
-bpf_u_int32 pcap_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen);
-void	sf_cleanup(pcap_t *p);
+bpf_u_int32 pcapint_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen);
+void	pcapint_sf_cleanup(pcap_t *p);
 #ifdef _WIN32
-FILE	*charset_fopen(const char *path, const char *mode);
+FILE	*pcapint_charset_fopen(const char *path, const char *mode);
 #else
 /*
  * On other OSes, just use Boring Old fopen().
  */
-#define charset_fopen(path, mode)	fopen((path), (mode))
+#define pcapint_charset_fopen(path, mode)	fopen((path), (mode))
 #endif
 
 /*
@@ -597,8 +532,8 @@ FILE	*charset_fopen(const char *path, const char *mode);
 #define pcap_code_handle_t	HMODULE
 #define pcap_funcptr_t		FARPROC
 
-pcap_code_handle_t	pcap_load_code(const char *);
-pcap_funcptr_t		pcap_find_function(pcap_code_handle_t, const char *);
+pcap_code_handle_t	pcapint_load_code(const char *);
+pcap_funcptr_t		pcapint_find_function(pcap_code_handle_t, const char *);
 #endif
 
 /*
@@ -619,40 +554,40 @@ struct pcap_bpf_aux_data {
  * Filtering routine that takes the auxiliary data as an additional
  * argument.
  */
-u_int	pcap_filter_with_aux_data(const struct bpf_insn *,
+u_int	pcapint_filter_with_aux_data(const struct bpf_insn *,
     const u_char *, u_int, u_int, const struct pcap_bpf_aux_data *);
 
 /*
  * Filtering routine that doesn't.
  */
-u_int	pcap_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
+u_int	pcapint_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
 
 /*
  * Routine to validate a BPF program.
  */
-int	pcap_validate_filter(const struct bpf_insn *, int);
+int	pcapint_validate_filter(const struct bpf_insn *, int);
 
 /*
  * Internal interfaces for both "pcap_create()" and routines that
  * open savefiles.
  *
- * "pcap_oneshot()" is the standard one-shot callback for "pcap_next()"
+ * "pcapint_oneshot()" is the standard one-shot callback for "pcap_next()"
  * and "pcap_next_ex()".
  */
-void	pcap_oneshot(u_char *, const struct pcap_pkthdr *, const u_char *);
+void	pcapint_oneshot(u_char *, const struct pcap_pkthdr *, const u_char *);
 
-int	install_bpf_program(pcap_t *, struct bpf_program *);
+int	pcapint_install_bpf_program(pcap_t *, struct bpf_program *);
 
-int	pcap_strcasecmp(const char *, const char *);
+int	pcapint_strcasecmp(const char *, const char *);
 
 /*
  * Internal interfaces for pcap_createsrcstr and pcap_parsesrcstr with
  * the additional bit of information regarding SSL support (rpcap:// vs.
  * rpcaps://).
  */
-int	pcap_createsrcstr_ex(char *, int, const char *, const char *,
+int	pcapint_createsrcstr_ex(char *, int, const char *, const char *,
     const char *, unsigned char, char *);
-int	pcap_parsesrcstr_ex(const char *, int *, char *, char *,
+int	pcapint_parsesrcstr_ex(const char *, int *, char *, char *,
     char *, unsigned char *, char *);
 
 #ifdef YYDEBUG
diff --git a/pcap-libdlpi.c b/pcap-libdlpi.c
index f281fb93..b5ee339f 100644
--- a/pcap-libdlpi.c
+++ b/pcap-libdlpi.c
@@ -24,9 +24,7 @@
  * Packet capture routines for DLPI using libdlpi under SunOS 5.11.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -80,7 +78,7 @@ list_interfaces(const char *linkname, void *arg)
 		lwp->lw_err = ENOMEM;
 		return (B_TRUE);
 	}
-	(void) pcap_strlcpy(entry->linkname, linkname, DLPI_LINKNAME_MAX);
+	(void) pcapint_strlcpy(entry->linkname, linkname, DLPI_LINKNAME_MAX);
 
 	if (lwp->lw_list == NULL) {
 		lwp->lw_list = entry;
@@ -229,7 +227,7 @@ pcap_activate_libdlpi(pcap_t *p)
 	 */
 	if (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {
 		status = PCAP_ERROR;
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "FLUSHR");
 		goto bad;
 	}
@@ -248,11 +246,11 @@ pcap_activate_libdlpi(pcap_t *p)
 
 	p->read_op = pcap_read_libdlpi;
 	p->inject_op = pcap_inject_libdlpi;
-	p->setfilter_op = install_bpf_program;	/* No kernel filtering */
+	p->setfilter_op = pcapint_install_bpf_program;	/* No kernel filtering */
 	p->setdirection_op = NULL;	/* Not implemented */
 	p->set_datalink_op = NULL;	/* Can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_dlpi;
 	p->cleanup_op = pcap_cleanup_libdlpi;
 
@@ -338,7 +336,7 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
  * additional network links present in the system.
  */
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 	int retv = 0;
 
@@ -349,7 +347,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 	/*
 	 * Get the list of regular interfaces first.
 	 */
-	if (pcap_findalldevs_interfaces(devlistp, errbuf,
+	if (pcapint_findalldevs_interfaces(devlistp, errbuf,
 	    is_dlpi_interface, get_if_flags) == -1)
 		return (-1);	/* failure */
 
@@ -358,14 +356,14 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 	/*
 	 * Find all DLPI devices in the current zone.
 	 *
-	 * XXX - will pcap_findalldevs_interfaces() find any devices
+	 * XXX - will pcapint_findalldevs_interfaces() find any devices
 	 * outside the current zone?  If not, the only reason to call
 	 * it would be to get the interface addresses.
 	 */
 	dlpi_walk(list_interfaces, &lw, 0);
 
 	if (lw.lw_err != 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    lw.lw_err, "dlpi_walk");
 		retv = -1;
 		goto done;
@@ -377,7 +375,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 		 * If it isn't already in the list of devices, try to
 		 * add it.
 		 */
-		if (find_or_add_dev(devlistp, entry->linkname, 0, get_if_flags,
+		if (pcapint_find_or_add_dev(devlistp, entry->linkname, 0, get_if_flags,
 		    NULL, errbuf) == NULL)
 			retv = -1;
 	}
@@ -481,7 +479,7 @@ pcap_cleanup_libdlpi(pcap_t *p)
 		pd->dlpi_hd = NULL;
 		p->fd = -1;
 	}
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 /*
@@ -495,7 +493,7 @@ pcap_libdlpi_err(const char *linkname, const char *func, int err, char *errbuf)
 }
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
diff --git a/pcap-linux.c b/pcap-linux.c
index 13bd8529..e0fe1d3e 100644
--- a/pcap-linux.c
+++ b/pcap-linux.c
@@ -70,9 +70,7 @@
 
 #define _GNU_SOURCE
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <errno.h>
 #include <stdio.h>
@@ -81,6 +79,7 @@
 #include <fcntl.h>
 #include <string.h>
 #include <limits.h>
+#include <endian.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/ioctl.h>
@@ -98,6 +97,7 @@
 #include <sys/eventfd.h>
 
 #include "pcap-int.h"
+#include "pcap-util.h"
 #include "pcap/sll.h"
 #include "pcap/vlan.h"
 #include "pcap/can_socketcan.h"
@@ -111,7 +111,7 @@
 #error "Libpcap will only work if TPACKET_V2 is supported; you must build for a 2.6.27 or later kernel"
 #endif
 
-/* check for memory mapped access avaibility. We assume every needed
+/* check for memory mapped access availability. We assume every needed
  * struct is defined if the macro TPACKET_HDRLEN is defined, because it
  * uses many ring related structs and macros */
 #ifdef TPACKET3_HDRLEN
@@ -221,10 +221,10 @@ struct pcap_linux {
  */
 static int get_if_flags(const char *, bpf_u_int32 *, char *);
 static int is_wifi(const char *);
-static void map_arphrd_to_dlt(pcap_t *, int, const char *, int);
+static int map_arphrd_to_dlt(pcap_t *, int, const char *, int);
 static int pcap_activate_linux(pcap_t *);
 static int setup_socket(pcap_t *, int);
-static int setup_mmapped(pcap_t *, int *);
+static int setup_mmapped(pcap_t *);
 static int pcap_can_set_rfmon_linux(pcap_t *);
 static int pcap_inject_linux(pcap_t *, const void *, int);
 static int pcap_stats_linux(pcap_t *, struct pcap_stat *);
@@ -245,7 +245,7 @@ union thdr {
 #define RING_GET_CURRENT_FRAME(h) RING_GET_FRAME_AT(h, h->offset)
 
 static void destroy_ring(pcap_t *handle);
-static int create_ring(pcap_t *handle, int *status);
+static int create_ring(pcap_t *handle);
 static int prepare_tpacket_socket(pcap_t *handle);
 static int pcap_read_linux_mmap_v2(pcap_t *, int, pcap_handler , u_char *);
 #ifdef HAVE_TPACKET3
@@ -253,7 +253,7 @@ static int pcap_read_linux_mmap_v3(pcap_t *, int, pcap_handler , u_char *);
 #endif
 static int pcap_setnonblock_linux(pcap_t *p, int nonblock);
 static int pcap_getnonblock_linux(pcap_t *p);
-static void pcap_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
+static void pcapint_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
     const u_char *bytes);
 
 /*
@@ -287,7 +287,7 @@ static void pcap_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
 #else
   /*
    * This is being compiled on a system that lacks TP_STATUS_VLAN_VALID,
-   * so we testwith the value it has in the 3.0 and later kernels, so
+   * so we test with the value it has in the 3.0 and later kernels, so
    * we can test it if we're running on a system that has it.  (If we're
    * running on a system that doesn't have it, it won't be set in the
    * tp_status field, so the tests of it will always fail; that means
@@ -336,7 +336,7 @@ static struct sock_fprog	total_fcode
 static int	iface_dsa_get_proto_info(const char *device, pcap_t *handle);
 
 pcap_t *
-pcap_create_interface(const char *device, char *ebuf)
+pcapint_create_interface(const char *device, char *ebuf)
 {
 	pcap_t *handle;
 
@@ -365,7 +365,7 @@ pcap_create_interface(const char *device, char *ebuf)
 	 */
 	handle->tstamp_precision_list = malloc(2 * sizeof(u_int));
 	if (handle->tstamp_precision_list == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		pcap_close(handle);
 		return NULL;
@@ -374,8 +374,12 @@ pcap_create_interface(const char *device, char *ebuf)
 	handle->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
 	handle->tstamp_precision_count = 2;
 
+	/*
+	 * Start out with the breakloop handle not open; we don't
+	 * need it until we're activated and ready to capture.
+	 */
 	struct pcap_linux *handlep = handle->priv;
-	handlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK);
+	handlep->poll_breakloop_fd = -1;
 
 	return handle;
 }
@@ -461,7 +465,7 @@ get_mac80211_phydev(pcap_t *handle, const char *device, char *phydev_path,
 			free(pathstr);
 			return 0;
 		}
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "%s: Can't readlink %s", device, pathstr);
 		free(pathstr);
 		return PCAP_ERROR;
@@ -618,7 +622,7 @@ DIAG_ON_NARROWING
 	 */
 	handlep->mondevice = strdup(mondevice);
 	if (handlep->mondevice == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "strdup");
 		/*
 		 * Get rid of the monitor device.
@@ -742,7 +746,7 @@ pcap_can_set_rfmon_linux(pcap_t *handle)
  *
  * Compared to /proc/net/dev this avoids counting software drops,
  * but may be unimplemented and just return 0.
- * The author has found no straigthforward way to check for support.
+ * The author has found no straightforward way to check for support.
  */
 static long long int
 linux_get_stat(const char * if_name, const char * stat) {
@@ -817,7 +821,7 @@ static void	pcap_cleanup_linux( pcap_t *handle )
 		 * Take this pcap out of the list of pcaps for which we
 		 * have to take the interface out of some mode.
 		 */
-		pcap_remove_from_pcaps_to_close(handle);
+		pcapint_remove_from_pcaps_to_close(handle);
 	}
 
 	if (handle->fd != -1) {
@@ -846,7 +850,7 @@ static void	pcap_cleanup_linux( pcap_t *handle )
 		close(handlep->poll_breakloop_fd);
 		handlep->poll_breakloop_fd = -1;
 	}
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 }
 
 #ifdef HAVE_TPACKET3
@@ -939,13 +943,20 @@ set_poll_timeout(struct pcap_linux *handlep)
 
 static void pcap_breakloop_linux(pcap_t *handle)
 {
-	pcap_breakloop_common(handle);
+	pcapint_breakloop_common(handle);
 	struct pcap_linux *handlep = handle->priv;
 
 	uint64_t value = 1;
-	/* XXX - what if this fails? */
-	if (handlep->poll_breakloop_fd != -1)
+
+	if (handlep->poll_breakloop_fd != -1) {
+		/*
+		 * XXX - pcap_breakloop() doesn't have a return value,
+		 * so we can't indicate an error.
+		 */
+DIAG_OFF_WARN_UNUSED_RESULT
 		(void)write(handlep->poll_breakloop_fd, &value, sizeof(value));
+DIAG_ON_WARN_UNUSED_RESULT
+	}
 }
 
 /*
@@ -996,12 +1007,16 @@ pcap_activate_linux(pcap_t *handle)
 	const char	*device;
 	int		is_any_device;
 	struct ifreq	ifr;
-	int		status = 0;
-	int		status2 = 0;
+	int		status;
 	int		ret;
 
 	device = handle->opt.device;
 
+	/*
+	 * Start out assuming no warnings.
+	 */
+	status = 0;
+
 	/*
 	 * Make sure the name we were handed will fit into the ioctls we
 	 * might perform on the device; if not, return a "No such device"
@@ -1036,7 +1051,7 @@ pcap_activate_linux(pcap_t *handle)
 
 	handlep->device	= strdup(device);
 	if (handlep->device == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "strdup");
 		status = PCAP_ERROR;
 		goto fail;
@@ -1084,22 +1099,57 @@ pcap_activate_linux(pcap_t *handle)
 		status = ret;
 		goto fail;
 	}
+	if (ret > 0) {
+		/*
+		 * We got a warning; return that, as handle->errbuf
+		 * might have been overwritten by this warning.
+		 */
+		status = ret;
+	}
+
 	/*
-	 * Success.
+	 * Success (possibly with a warning).
+	 *
+	 * First, try to allocate an event FD for breakloop, if
+	 * we're not going to start in non-blocking mode.
+	 */
+	if (!handle->opt.nonblock) {
+		handlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK);
+		if (handlep->poll_breakloop_fd == -1) {
+			/*
+			 * Failed.
+			 */
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
+			    PCAP_ERRBUF_SIZE, errno, "could not open eventfd");
+			status = PCAP_ERROR;
+			goto fail;
+		}
+	}
+
+	/*
+	 * Succeeded.
 	 * Try to set up memory-mapped access.
 	 */
-	ret = setup_mmapped(handle, &status);
-	if (ret == -1) {
+	ret = setup_mmapped(handle);
+	if (ret < 0) {
 		/*
 		 * We failed to set up to use it, or the
 		 * kernel supports it, but we failed to
-		 * enable it.  status has been set to the
+		 * enable it.  The return value is the
 		 * error status to return and, if it's
 		 * PCAP_ERROR, handle->errbuf contains
 		 * the error message.
 		 */
+		status = ret;
 		goto fail;
 	}
+	if (ret > 0) {
+		/*
+		 * We got a warning; return that, as handle->errbuf
+		 * might have been overwritten by this warning.
+		 */
+		status = ret;
+	}
 
 	/*
 	 * We succeeded.  status has been set to the status to return,
@@ -1109,9 +1159,9 @@ pcap_activate_linux(pcap_t *handle)
 	 * Now that we have activated the mmap ring, we can
 	 * set the correct protocol.
 	 */
-	if ((status2 = iface_bind(handle->fd, handlep->ifindex,
+	if ((ret = iface_bind(handle->fd, handlep->ifindex,
 	    handle->errbuf, pcap_protocol(handle))) != 0) {
-		status = status2;
+		status = ret;
 		goto fail;
 	}
 
@@ -1136,7 +1186,7 @@ pcap_activate_linux(pcap_t *handle)
 		break;
 #endif
 	}
-	handle->oneshot_callback = pcap_oneshot_linux;
+	handle->oneshot_callback = pcapint_oneshot_linux;
 	handle->selectable_fd = handle->fd;
 
 	return status;
@@ -1245,7 +1295,7 @@ device_still_exists(pcap_t *handle)
 		/*
 		 * Error - report an error and return -1.
 		 */
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "getsockname failed");
 		return (-1);
 	}
@@ -1272,7 +1322,7 @@ pcap_inject_linux(pcap_t *handle, const void *buf, int size)
 		/*
 		 * We don't support sending on the "any" device.
 		 */
-		pcap_strlcpy(handle->errbuf,
+		pcapint_strlcpy(handle->errbuf,
 		    "Sending packets isn't supported on the \"any\" device",
 		    PCAP_ERRBUF_SIZE);
 		return (-1);
@@ -1286,7 +1336,7 @@ pcap_inject_linux(pcap_t *handle, const void *buf, int size)
 		 * socket?
 		 * Is a "sendto()" required there?
 		 */
-		pcap_strlcpy(handle->errbuf,
+		pcapint_strlcpy(handle->errbuf,
 		    "Sending packets isn't supported in cooked mode",
 		    PCAP_ERRBUF_SIZE);
 		return (-1);
@@ -1294,7 +1344,7 @@ pcap_inject_linux(pcap_t *handle, const void *buf, int size)
 
 	ret = (int)send(handle->fd, buf, size, 0);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -1425,16 +1475,11 @@ pcap_stats_linux(pcap_t *handle, struct pcap_stat *stats)
 		return 0;
 	}
 
-	pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE, errno,
+	pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE, errno,
 	    "failed to get statistics from socket");
 	return -1;
 }
 
-/*
- * Description string for the "any" device.
- */
-static const char any_descr[] = "Pseudo-device that captures on all interfaces";
-
 /*
  * A PF_PACKET socket can be bound to any network interface.
  */
@@ -1587,7 +1632,7 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 
 	sock = get_if_ioctl_socket();
 	if (sock == -1) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
 		    "Can't create socket to get ethtool information for %s",
 		    name);
 		return -1;
@@ -1667,7 +1712,7 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 
 #ifdef ETHTOOL_GLINK
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
 	info.cmd = ETHTOOL_GLINK;
 	/*
 	 * XXX - while Valgrind handles SIOCETHTOOL and knows that
@@ -1715,7 +1760,7 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 			/*
 			 * Other error.
 			 */
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    save_errno,
 			    "%s: SIOCETHTOOL(ETHTOOL_GLINK) ioctl failed",
 			    name);
@@ -1745,24 +1790,19 @@ get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 	/*
 	 * Get the list of regular interfaces first.
 	 */
-	if (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
+	if (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
 	    get_if_flags) == -1)
 		return (-1);	/* failure */
 
 	/*
 	 * Add the "any" device.
-	 * As it refers to all network devices, not to any particular
-	 * network device, the notion of "connected" vs. "disconnected"
-	 * doesn't apply.
 	 */
-	if (add_dev(devlistp, "any",
-	    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
-	    any_descr, errbuf) == NULL)
+	if (pcap_add_any_dev(devlistp, errbuf) == NULL)
 		return (-1);
 
 	return (0);
@@ -1825,9 +1865,11 @@ is_wifi(const char *device)
  *  to pick some type that works in raw mode, or fail.
  *
  *  Sets the link type to -1 if unable to map the type.
+ *
+ *  Returns 0 on success or a PCAP_ERROR_ value on error.
  */
-static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
-			      const char *device, int cooked_ok)
+static int map_arphrd_to_dlt(pcap_t *handle, int arptype,
+			     const char *device, int cooked_ok)
 {
 	static const char cdma_rmnet[] = "cdma_rmnet";
 
@@ -1848,7 +1890,7 @@ static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
 		 */
 		if (strncmp(device, cdma_rmnet, sizeof cdma_rmnet - 1) == 0) {
 			handle->linktype = DLT_RAW;
-			return;
+			return 0;
 		}
 
 		/*
@@ -1878,7 +1920,7 @@ static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
 			 */
 			ret = iface_dsa_get_proto_info(device, handle);
 			if (ret < 0)
-				return;
+				return ret;
 
 			if (ret == 1) {
 				/*
@@ -1895,14 +1937,14 @@ static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
 			 * It's not a Wi-Fi device; offer DOCSIS.
 			 */
 			handle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-			/*
-			 * If that fails, just leave the list empty.
-			 */
-			if (handle->dlt_list != NULL) {
-				handle->dlt_list[0] = DLT_EN10MB;
-				handle->dlt_list[1] = DLT_DOCSIS;
-				handle->dlt_count = 2;
+			if (handle->dlt_list == NULL) {
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
+				    PCAP_ERRBUF_SIZE, errno, "malloc");
+				return (PCAP_ERROR);
 			}
+			handle->dlt_list[0] = DLT_EN10MB;
+			handle->dlt_list[1] = DLT_DOCSIS;
+			handle->dlt_count = 2;
 		}
 		/* FALLTHROUGH */
 
@@ -2191,17 +2233,17 @@ static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
 		 * IP-over-FC on which somebody wants to capture
 		 * packets.
 		 */
+		handle->linktype = DLT_FC_2;
 		handle->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (handle->dlt_list != NULL) {
-			handle->dlt_list[0] = DLT_FC_2;
-			handle->dlt_list[1] = DLT_FC_2_WITH_FRAME_DELIMS;
-			handle->dlt_list[2] = DLT_IP_OVER_FC;
-			handle->dlt_count = 3;
+		if (handle->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
+			    PCAP_ERRBUF_SIZE, errno, "malloc");
+			return (PCAP_ERROR);
 		}
-		handle->linktype = DLT_FC_2;
+		handle->dlt_list[0] = DLT_FC_2;
+		handle->dlt_list[1] = DLT_FC_2_WITH_FRAME_DELIMS;
+		handle->dlt_list[2] = DLT_IP_OVER_FC;
+		handle->dlt_count = 3;
 		break;
 
 #ifndef ARPHRD_IRDA
@@ -2271,29 +2313,13 @@ static void map_arphrd_to_dlt(pcap_t *handle, int arptype,
 		handle->linktype = -1;
 		break;
 	}
-}
-
-static void
-set_dlt_list_cooked(pcap_t *handle)
-{
-	/*
-	 * Support both DLT_LINUX_SLL and DLT_LINUX_SLL2.
-	 */
-	handle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-
-	/*
-	 * If that failed, just leave the list empty.
-	 */
-	if (handle->dlt_list != NULL) {
-		handle->dlt_list[0] = DLT_LINUX_SLL;
-		handle->dlt_list[1] = DLT_LINUX_SLL2;
-		handle->dlt_count = 2;
-	}
+	return (0);
 }
 
 /*
  * Try to set up a PF_PACKET socket.
- * Returns 0 on success and a PCAP_ERROR_ value on failure.
+ * Returns 0 or a PCAP_WARNING_ value on success and a PCAP_ERROR_ value
+ * on failure.
  */
 static int
 setup_socket(pcap_t *handle, int is_any_device)
@@ -2333,13 +2359,23 @@ setup_socket(pcap_t *handle, int is_any_device)
 			status = PCAP_ERROR_PERM_DENIED;
 			snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 			    "Attempt to create packet socket failed - CAP_NET_RAW may be required");
+		} else if (errno == EAFNOSUPPORT) {
+			/*
+			 * PF_PACKET sockets not supported.
+			 * Perhaps we're running on the WSL1 module
+			 * in the Windows NT kernel rather than on
+			 * a real Linux kernel.
+			 */
+			status = PCAP_ERROR_CAPTURE_NOTSUP;
+			snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
+			    "PF_PACKET sockets not supported - is this WSL1?");
 		} else {
 			/*
 			 * Other error.
 			 */
 			status = PCAP_ERROR;
 		}
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket");
 		return status;
 	}
@@ -2391,6 +2427,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 				 * on.
 				 */
 				close(sock_fd);
+
 				return PCAP_ERROR_RFMON_NOTSUP;
 			}
 
@@ -2408,7 +2445,11 @@ setup_socket(pcap_t *handle, int is_any_device)
 			close(sock_fd);
 			return arptype;
 		}
-		map_arphrd_to_dlt(handle, arptype, device, 1);
+		status = map_arphrd_to_dlt(handle, arptype, device, 1);
+		if (status < 0) {
+			close(sock_fd);
+			return status;
+		}
 		if (handle->linktype == -1 ||
 		    handle->linktype == DLT_LINUX_SLL ||
 		    handle->linktype == DLT_LINUX_IRDA ||
@@ -2431,7 +2472,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 			 * warning message.
 			 */
 			if (close(sock_fd) == -1) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "close");
 				return PCAP_ERROR;
 			}
@@ -2445,7 +2486,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 				 * any failure is a "this shouldn't
 				 * happen" case.
 				 */
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "socket");
 				return PCAP_ERROR;
 			}
@@ -2460,7 +2501,6 @@ setup_socket(pcap_t *handle, int is_any_device)
 				free(handle->dlt_list);
 				handle->dlt_list = NULL;
 				handle->dlt_count = 0;
-				set_dlt_list_cooked(handle);
 			}
 
 			if (handle->linktype == -1) {
@@ -2476,6 +2516,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 					"falling back to cooked "
 					"socket",
 					arptype);
+				status = PCAP_WARNING;
 			}
 
 			/*
@@ -2487,12 +2528,6 @@ setup_socket(pcap_t *handle, int is_any_device)
 			    handle->linktype != DLT_LINUX_LAPD &&
 			    handle->linktype != DLT_NETLINK)
 				handle->linktype = DLT_LINUX_SLL;
-			if (handle->linktype == -1) {
-				snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
-				    "unknown arptype %d, defaulting to cooked mode",
-				    arptype);
-				status = PCAP_WARNING;
-			}
 		}
 
 		handlep->ifindex = iface_get_id(sock_fd, device,
@@ -2521,12 +2556,19 @@ setup_socket(pcap_t *handle, int is_any_device)
 
 		/*
 		 * It uses cooked mode.
+		 * Support both DLT_LINUX_SLL and DLT_LINUX_SLL2.
 		 */
 		handlep->cooked = 1;
 		handle->linktype = DLT_LINUX_SLL;
-		handle->dlt_list = NULL;
-		handle->dlt_count = 0;
-		set_dlt_list_cooked(handle);
+		handle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
+		if (handle->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
+			    PCAP_ERRBUF_SIZE, errno, "malloc");
+			return (PCAP_ERROR);
+		}
+		handle->dlt_list[0] = DLT_LINUX_SLL;
+		handle->dlt_list[1] = DLT_LINUX_SLL2;
+		handle->dlt_count = 2;
 
 		/*
 		 * We're not bound to a device.
@@ -2566,7 +2608,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 		mr.mr_type    = PACKET_MR_PROMISC;
 		if (setsockopt(sock_fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,
 		    &mr, sizeof(mr)) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "setsockopt (PACKET_ADD_MEMBERSHIP)");
 			close(sock_fd);
 			return PCAP_ERROR;
@@ -2585,7 +2627,7 @@ setup_socket(pcap_t *handle, int is_any_device)
 	val = 1;
 	if (setsockopt(sock_fd, SOL_PACKET, PACKET_AUXDATA, &val,
 		       sizeof(val)) == -1 && errno != ENOPROTOOPT) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "setsockopt (PACKET_AUXDATA)");
 		close(sock_fd);
 		return PCAP_ERROR;
@@ -2651,17 +2693,17 @@ setup_socket(pcap_t *handle, int is_any_device)
 /*
  * Attempt to setup memory-mapped access.
  *
- * On success, returns 1, and sets *status to 0 if there are no warnings
- * or to a PCAP_WARNING_ code if there is a warning.
+ * On success, returns 0 if there are no warnings or a PCAP_WARNING_ code
+ * if there is a warning.
  *
- * On error, returns -1, and sets *status to the appropriate error code;
- * if that is PCAP_ERROR, sets handle->errbuf to the appropriate message.
+ * On error, returns the appropriate error code; if that is PCAP_ERROR,
+ * sets handle->errbuf to the appropriate message.
  */
 static int
-setup_mmapped(pcap_t *handle, int *status)
+setup_mmapped(pcap_t *handle)
 {
 	struct pcap_linux *handlep = handle->priv;
-	int ret;
+	int status;
 
 	/*
 	 * Attempt to allocate a buffer to hold the contents of one
@@ -2669,36 +2711,34 @@ setup_mmapped(pcap_t *handle, int *status)
 	 */
 	handlep->oneshot_buffer = malloc(handle->snapshot);
 	if (handlep->oneshot_buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't allocate oneshot buffer");
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	if (handle->opt.buffer_size == 0) {
 		/* by default request 2M for the ring buffer */
 		handle->opt.buffer_size = 2*1024*1024;
 	}
-	ret = prepare_tpacket_socket(handle);
-	if (ret == -1) {
+	status = prepare_tpacket_socket(handle);
+	if (status == -1) {
 		free(handlep->oneshot_buffer);
 		handlep->oneshot_buffer = NULL;
-		*status = PCAP_ERROR;
-		return ret;
+		return PCAP_ERROR;
 	}
-	ret = create_ring(handle, status);
-	if (ret == -1) {
+	status = create_ring(handle);
+	if (status < 0) {
 		/*
 		 * Error attempting to enable memory-mapped capture;
-		 * fail.  create_ring() has set *status.
+		 * fail.  The return value is the status to return.
 		 */
 		free(handlep->oneshot_buffer);
 		handlep->oneshot_buffer = NULL;
-		return -1;
+		return status;
 	}
 
 	/*
-	 * Success.  *status has been set either to 0 if there are no
+	 * Success.  status has been set either to 0 if there are no
 	 * warnings or to a PCAP_WARNING_ value if there is a warning.
 	 *
 	 * handle->offset is used to get the current position into the rx ring.
@@ -2710,7 +2750,7 @@ setup_mmapped(pcap_t *handle, int *status)
 	 */
 	set_poll_timeout(handlep);
 
-	return 1;
+	return status;
 }
 
 /*
@@ -2761,7 +2801,7 @@ init_tpacket(pcap_t *handle, int version, const char *version_str)
 			/*
 			 * Some unexpected error.
 			 */
-			pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "can't get %s header len on packet socket",
 			    version_str);
 		}
@@ -2772,7 +2812,7 @@ init_tpacket(pcap_t *handle, int version, const char *version_str)
 	val = version;
 	if (setsockopt(handle->fd, SOL_PACKET, PACKET_VERSION, &val,
 			   sizeof(val)) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't activate %s on packet socket", version_str);
 		return -1;
 	}
@@ -2859,14 +2899,14 @@ prepare_tpacket_socket(pcap_t *handle)
 /*
  * Attempt to set up memory-mapped access.
  *
- * On success, returns 1, and sets *status to 0 if there are no warnings
- * or to a PCAP_WARNING_ code if there is a warning.
+ * On success, returns 0 if there are no warnings or to a PCAP_WARNING_ code
+ * if there is a warning.
  *
- * On error, returns -1, and sets *status to the appropriate error code;
- * if that is PCAP_ERROR, sets handle->errbuf to the appropriate message.
+ * On error, returns the appropriate error code; if that is PCAP_ERROR,
+ * sets handle->errbuf to the appropriate message.
  */
 static int
-create_ring(pcap_t *handle, int *status)
+create_ring(pcap_t *handle)
 {
 	struct pcap_linux *handlep = handle->priv;
 	unsigned i, j, frames_per_block;
@@ -2883,11 +2923,12 @@ create_ring(pcap_t *handle, int *status)
 	socklen_t len;
 	unsigned int sk_type, tp_reserve, maclen, tp_hdrlen, netoff, macoff;
 	unsigned int frame_size;
+	int status;
 
 	/*
-	 * Start out assuming no warnings or errors.
+	 * Start out assuming no warnings.
 	 */
-	*status = 0;
+	status = 0;
 
 	/*
 	 * Reserve space for VLAN tag reconstruction.
@@ -2919,11 +2960,10 @@ create_ring(pcap_t *handle, int *status)
 	len = sizeof(tp_reserve);
 	if (setsockopt(handle->fd, SOL_PACKET, PACKET_RESERVE,
 	    &tp_reserve, len) < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf,
 		    PCAP_ERRBUF_SIZE, errno,
 		    "setsockopt (PACKET_RESERVE)");
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	switch (handlep->tp_version) {
@@ -2968,15 +3008,11 @@ create_ring(pcap_t *handle, int *status)
 
 			mtu = iface_get_mtu(handle->fd, handle->opt.device,
 			    handle->errbuf);
-			if (mtu == -1) {
-				*status = PCAP_ERROR;
-				return -1;
-			}
+			if (mtu == -1)
+				return PCAP_ERROR;
 			offload = iface_get_offload(handle);
-			if (offload == -1) {
-				*status = PCAP_ERROR;
-				return -1;
-			}
+			if (offload == -1)
+				return PCAP_ERROR;
 			if (offload)
 				max_frame_len = MAX(mtu, 65535);
 			else
@@ -2993,10 +3029,9 @@ create_ring(pcap_t *handle, int *status)
 		len = sizeof(sk_type);
 		if (getsockopt(handle->fd, SOL_SOCKET, SO_TYPE, &sk_type,
 		    &len) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "getsockopt (SO_TYPE)");
-			*status = PCAP_ERROR;
-			return -1;
+			return PCAP_ERROR;
 		}
 		maclen = (sk_type == SOCK_DGRAM) ? 0 : MAX_LINKHEADER_SIZE;
 			/* XXX: in the kernel maclen is calculated from
@@ -3061,8 +3096,7 @@ create_ring(pcap_t *handle, int *status)
 		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    "Internal error: unknown TPACKET_ value %u",
 		    handlep->tp_version);
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	/* compute the minimum block size that will handle this frame.
@@ -3111,7 +3145,7 @@ create_ring(pcap_t *handle, int *status)
 		hwconfig.rx_filter = HWTSTAMP_FILTER_ALL;
 
 		memset(&ifr, 0, sizeof(ifr));
-		pcap_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));
+		pcapint_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));
 		ifr.ifr_data = (void *)&hwconfig;
 
 		/*
@@ -3128,10 +3162,9 @@ create_ring(pcap_t *handle, int *status)
 				 * and, if they can't, shouldn't
 				 * try requesting hardware time stamps.
 				 */
-				*status = PCAP_ERROR_PERM_DENIED;
 				snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 				    "Attempt to set hardware timestamp failed - CAP_NET_ADMIN may be required");
-				return -1;
+				return PCAP_ERROR_PERM_DENIED;
 
 			case EOPNOTSUPP:
 			case ERANGE:
@@ -3149,15 +3182,14 @@ create_ring(pcap_t *handle, int *status)
 				 * We'll just fall back on the standard
 				 * host time stamps.
 				 */
-				*status = PCAP_WARNING_TSTAMP_TYPE_NOTSUP;
+				status = PCAP_WARNING_TSTAMP_TYPE_NOTSUP;
 				break;
 
 			default:
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "SIOCSHWTSTAMP failed");
-				*status = PCAP_ERROR;
-				return -1;
+				return PCAP_ERROR;
 			}
 		} else {
 			/*
@@ -3181,11 +3213,10 @@ create_ring(pcap_t *handle, int *status)
 			}
 			if (setsockopt(handle->fd, SOL_PACKET, PACKET_TIMESTAMP,
 				(void *)&timesource, sizeof(timesource))) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "can't set PACKET_TIMESTAMP");
-				*status = PCAP_ERROR;
-				return -1;
+				return PCAP_ERROR;
 			}
 		}
 	}
@@ -3244,10 +3275,9 @@ retry:
 				req.tp_frame_nr -= req.tp_frame_nr/20;
 			goto retry;
 		}
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't create rx ring on packet socket");
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	/* memory map the rx ring */
@@ -3255,25 +3285,23 @@ retry:
 	handlep->mmapbuf = mmap(0, handlep->mmapbuflen,
 	    PROT_READ|PROT_WRITE, MAP_SHARED, handle->fd, 0);
 	if (handlep->mmapbuf == MAP_FAILED) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't mmap rx ring");
 
 		/* clear the allocated ring on error*/
 		destroy_ring(handle);
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	/* allocate a ring for each frame header pointer*/
 	handle->cc = req.tp_frame_nr;
 	handle->buffer = malloc(handle->cc * sizeof(union thdr *));
 	if (!handle->buffer) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "can't allocate ring of frame headers");
 
 		destroy_ring(handle);
-		*status = PCAP_ERROR;
-		return -1;
+		return PCAP_ERROR;
 	}
 
 	/* fill the header ring with proper frame ptr*/
@@ -3288,7 +3316,7 @@ retry:
 
 	handle->bufsize = req.tp_frame_size;
 	handle->offset = 0;
-	return 1;
+	return status;
 }
 
 /* free all ring related resources*/
@@ -3334,7 +3362,7 @@ destroy_ring(pcap_t *handle)
  * pcap_next() or pcap_next_ex().
  */
 static void
-pcap_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
+pcapint_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
     const u_char *bytes)
 {
 	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
@@ -3361,10 +3389,10 @@ pcap_setnonblock_linux(pcap_t *handle, int nonblock)
 	struct pcap_linux *handlep = handle->priv;
 
 	/*
-	 * Set the file descriptor to non-blocking mode, as we use
+	 * Set the file descriptor to the requested mode, as we use
 	 * it for sending packets.
 	 */
-	if (pcap_setnonblock_fd(handle, nonblock) == -1)
+	if (pcapint_setnonblock_fd(handle, nonblock) == -1)
 		return -1;
 
 	/*
@@ -3372,6 +3400,9 @@ pcap_setnonblock_linux(pcap_t *handle, int nonblock)
 	 * preserve the timeout value provided with pcap_set_timeout.
 	 */
 	if (nonblock) {
+		/*
+		 * We're setting the mode to non-blocking mode.
+		 */
 		if (handlep->timeout >= 0) {
 			/*
 			 * Indicate that we're switching to
@@ -3385,14 +3416,15 @@ pcap_setnonblock_linux(pcap_t *handle, int nonblock)
 			handlep->poll_breakloop_fd = -1;
 		}
 	} else {
+		/*
+		 * We're setting the mode to blocking mode.
+		 */
 		if (handlep->poll_breakloop_fd == -1) {
 			/* If we did not have an eventfd, open one now that we are blocking. */
 			if ( ( handlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK) ) == -1 ) {
-				int save_errno = errno;
-				snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
-						"Could not open eventfd: %s",
-						strerror(errno));
-				errno = save_errno;
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
+				    PCAP_ERRBUF_SIZE, errno,
+				    "could not open eventfd");
 				return -1;
 			}
 		}
@@ -3527,7 +3559,7 @@ static int pcap_wait_for_frames_mmap(pcap_t *handle)
 			 * Error.  If it's not EINTR, report it.
 			 */
 			if (errno != EINTR) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "can't poll on packet socket");
 				return PCAP_ERROR;
@@ -3629,7 +3661,7 @@ static int pcap_wait_for_frames_mmap(pcap_t *handle)
 						    "Error condition on packet socket: Reported error was 0");
 						return PCAP_ERROR;
 					} else {
-						pcap_fmt_errmsg_for_errno(handle->errbuf,
+						pcapint_fmt_errmsg_for_errno(handle->errbuf,
 						    PCAP_ERRBUF_SIZE,
 						    err,
 						    "Error condition on packet socket");
@@ -3651,7 +3683,7 @@ static int pcap_wait_for_frames_mmap(pcap_t *handle)
 				nread = read(handlep->poll_breakloop_fd, &value,
 				    sizeof(value));
 				if (nread == -1) {
-					pcap_fmt_errmsg_for_errno(handle->errbuf,
+					pcapint_fmt_errmsg_for_errno(handle->errbuf,
 					    PCAP_ERRBUF_SIZE,
 					    errno,
 					    "Error reading from event FD");
@@ -3738,7 +3770,7 @@ static int pcap_wait_for_frames_mmap(pcap_t *handle)
 			 * The device still exists; try to see if it's up.
 			 */
 			memset(&ifr, 0, sizeof(ifr));
-			pcap_strlcpy(ifr.ifr_name, handlep->device,
+			pcapint_strlcpy(ifr.ifr_name, handlep->device,
 			    sizeof(ifr.ifr_name));
 			if (ioctl(handle->fd, SIOCGIFFLAGS, &ifr) == -1) {
 				if (errno == ENXIO || errno == ENODEV) {
@@ -3752,7 +3784,7 @@ static int pcap_wait_for_frames_mmap(pcap_t *handle)
 					    "The interface disappeared");
 					return PCAP_ERROR;
 				} else {
-					pcap_fmt_errmsg_for_errno(handle->errbuf,
+					pcapint_fmt_errmsg_for_errno(handle->errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "%s: Can't get flags",
 					    handlep->device);
@@ -3803,7 +3835,6 @@ static int pcap_handle_packet_mmap(
 	unsigned char *bp;
 	struct sockaddr_ll *sll;
 	struct pcap_pkthdr pcaphdr;
-	pcap_can_socketcan_hdr *canhdr;
 	unsigned int snaplen = tp_snaplen;
 	struct utsname utsname;
 
@@ -3932,56 +3963,173 @@ static int pcap_handle_packet_mmap(
 		 * DLT_CAN_SOCKETCAN is expected to provide.
 		 */
 		if (sll->sll_hatype == ARPHRD_CAN) {
-			/*
-			 * DLT_CAN_SOCKETCAN is specified as having the
-			 * CAN ID and flags in network byte order, but
-			 * capturing on a CAN device provides it in host
-			 * byte order.  Convert it to network byte order.
-			 */
-			canhdr = (pcap_can_socketcan_hdr *)bp;
-			canhdr->can_id = htonl(canhdr->can_id);
+			pcap_can_socketcan_hdr *canhdr = (pcap_can_socketcan_hdr *)bp;
+			uint16_t protocol = ntohs(sll->sll_protocol);
 
 			/*
-			 * In addition, set the CANFD_FDF flag if
-			 * the protocol is LINUX_SLL_P_CANFD, as
-			 * the protocol field itself isn't in
-			 * the packet to indicate that it's a
-			 * CAN FD packet.
+			 * Check the protocol field from the sll header.
+			 * If it's one of the known CAN protocol types,
+			 * make sure the appropriate flags are set, so
+			 * that a program can tell what type of frame
+			 * it is.
+			 *
+			 * The two flags are:
+			 *
+			 *   CANFD_FDF, which is in the fd_flags field
+			 *   of the CAN classic/CAN FD header;
+			 *
+			 *   CANXL_XLF, which is in the flags field
+			 *   of the CAN XL header, which overlaps
+			 *   the payload_length field of the CAN
+			 *   classic/CAN FD header.
 			 */
-			uint16_t protocol = ntohs(sll->sll_protocol);
-			if (protocol == LINUX_SLL_P_CANFD) {
+			switch (protocol) {
+
+			case LINUX_SLL_P_CAN:
+				/*
+				 * CAN classic.
+				 *
+				 * Zero out the fd_flags and reserved
+				 * fields, in case they're uninitialized
+				 * crap, and clear the CANXL_XLF bit in
+				 * the payload_length field.
+				 *
+				 * This means that the CANFD_FDF flag isn't
+				 * set in the fd_flags field, and that
+				 * the CANXL_XLF bit isn't set in the
+				 * payload_length field, so this frame
+				 * will appear to be a CAN classic frame.
+				 */
+				canhdr->payload_length &= ~CANXL_XLF;
+				canhdr->fd_flags = 0;
+				canhdr->reserved1 = 0;
+				canhdr->reserved2 = 0;
+				break;
+
+			case LINUX_SLL_P_CANFD:
+				/*
+				 * Set CANFD_FDF in the fd_flags field,
+				 * and clear the CANXL_XLF bit in the
+				 * payload_length field, so this frame
+				 * will appear to be a CAN FD frame.
+				 */
+				canhdr->payload_length &= ~CANXL_XLF;
 				canhdr->fd_flags |= CANFD_FDF;
 
 				/*
-				 * Zero out all the unknown bits in
-				 * fd_flags and clear the reserved
-				 * fields, so that a program reading
-				 * this can assume that CANFD_FDF
-				 * is set because we set it, not
-				 * because some uninitialized crap
-				 * was provided in the fd_flags
-				 * field.
+				 * Zero out all the unknown bits in fd_flags
+				 * and clear the reserved fields, so that
+				 * a program reading this can assume that
+				 * CANFD_FDF is set because we set it, not
+				 * because some uninitialized crap was
+				 * provided in the fd_flags field.
 				 *
 				 * (At least some LINKTYPE_CAN_SOCKETCAN
-				 * files attached to Wireshark bugs
-				 * had uninitialized junk there, so it
-				 * does happen.)
+				 * files attached to Wireshark bugs had
+				 * uninitialized junk there, so it does
+				 * happen.)
 				 *
-				 * Update this if Linux adds more flag
-				 * bits to the fd_flags field or uses
-				 * either of the reserved fields for
-				 * FD frames.
+				 * Update this if Linux adds more flag bits
+				 * to the fd_flags field or uses either of
+				 * the reserved fields for FD frames.
 				 */
-				canhdr->fd_flags &= ~(CANFD_FDF|CANFD_ESI|CANFD_BRS);
+				canhdr->fd_flags &= (CANFD_FDF|CANFD_ESI|CANFD_BRS);
 				canhdr->reserved1 = 0;
 				canhdr->reserved2 = 0;
+				break;
+
+			case LINUX_SLL_P_CANXL:
+				/*
+				 * CAN XL frame.
+				 *
+				 * Make sure the CANXL_XLF bit is set in
+				 * the payload_length field, so that
+				 * this frame will appear to be a
+				 * CAN XL frame.
+				 */
+				canhdr->payload_length |= CANXL_XLF;
+				break;
+			}
+
+			/*
+			 * Put multi-byte header fields in a byte-order
+			 *-independent format.
+			 */
+			if (canhdr->payload_length & CANXL_XLF) {
+				/*
+				 * This is a CAN XL frame.
+				 *
+				 * DLT_CAN_SOCKETCAN is specified as having
+				 * the Priority ID/VCID field in big--
+				 * endian byte order, and the payload length
+				 * and Acceptance Field in little-endian byte
+				 * order. but capturing on a CAN device
+				 * provides them in host byte order.
+				 * Convert them to the appropriate byte
+				 * orders.
+				 *
+				 * The reason we put the first field
+				 * into big-endian byte order is that
+				 * older libpcap code, ignorant of
+				 * CAN XL, treated it as the CAN ID
+				 * field and put it into big-endian
+				 * byte order, and we don't want to
+				 * break code that understands CAN XL
+				 * headers, and treats that field as
+				 * being big-endian.
+				 *
+				 * The other fields are put in little-
+				 * endian byte order is that older
+				 * libpcap code, ignorant of CAN XL,
+				 * left those fields alone, and the
+				 * processors on which the CAN XL
+				 * frames were captured are likely
+				 * to be little-endian processors.
+				 */
+				pcap_can_socketcan_xl_hdr *canxl_hdr = (pcap_can_socketcan_xl_hdr *)bp;
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+				/*
+				 * We're capturing on a little-endian
+				 * machine, so we put the priority/VCID
+				 * field into big-endian byte order, and
+				 * leave the payload length and acceptance
+				 * field in little-endian byte order.
+				 */
+				/* Byte-swap priority/VCID. */
+				canxl_hdr->priority_vcid = SWAPLONG(canxl_hdr->priority_vcid);
+#elif __BYTE_ORDER == __BIG_ENDIAN
+				/*
+				 * We're capturing on a big-endian
+				 * machine, so we want to leave the
+				 * priority/VCID field alone, and byte-swap
+				 * the payload length and acceptance
+				 * fields to little-endian.
+				 */
+				/* Byte-swap the payload length */
+				canxl_hdr->payload_length = SWAPSHORT(canxl_hdr->payload_length);
+
+				/*
+				 * Byte-swap the acceptance field.
+				 *
+				 * XXX - is it just a 4-octet string,
+				 * not in any byte order?
+				 */
+				canxl_hdr->acceptance_field = SWAPLONG(canxl_hdr->acceptance_field);
+#else
+#error "Unknown byte order"
+#endif
 			} else {
 				/*
-				 * Clear CANFD_FDF if it's set (probably
-				 * again meaning that this field is
-				 * uninitialized junk).
+				 * CAN or CAN FD frame.
+				 *
+				 * DLT_CAN_SOCKETCAN is specified as having
+				 * the CAN ID and flags in network byte
+				 * order, but capturing on a CAN device
+				 * provides it in host byte order.  Convert
+				 * it to network byte order.
 				 */
-				canhdr->fd_flags &= ~CANFD_FDF;
+				canhdr->can_id = htonl(canhdr->can_id);
 			}
 		}
 	}
@@ -3992,7 +4140,7 @@ static int pcap_handle_packet_mmap(
 		aux_data.vlan_tag_present = tp_vlan_tci_valid;
 		aux_data.vlan_tag = tp_vlan_tci & 0x0fff;
 
-		if (pcap_filter_with_aux_data(handle->fcode.bf_insns,
+		if (pcapint_filter_with_aux_data(handle->fcode.bf_insns,
 					      bp,
 					      tp_len,
 					      snaplen,
@@ -4324,7 +4472,7 @@ pcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)
 	if (!handle)
 		return -1;
 	if (!filter) {
-	        pcap_strlcpy(handle->errbuf, "setfilter: No filter specified",
+	        pcapint_strlcpy(handle->errbuf, "setfilter: No filter specified",
 			PCAP_ERRBUF_SIZE);
 		return -1;
 	}
@@ -4333,8 +4481,8 @@ pcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)
 
 	/* Make our private copy of the filter */
 
-	if (install_bpf_program(handle, filter) < 0)
-		/* install_bpf_program() filled in errbuf */
+	if (pcapint_install_bpf_program(handle, filter) < 0)
+		/* pcapint_install_bpf_program() filled in errbuf */
 		return -1;
 
 	/*
@@ -4471,7 +4619,7 @@ pcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)
 	 */
 	if (handlep->filter_in_userland) {
 		if (reset_kernel_filter(handle) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "can't remove kernel filter");
 			err = -2;	/* fatal error */
@@ -4558,10 +4706,10 @@ iface_get_id(int fd, const char *device, char *ebuf)
 	struct ifreq	ifr;
 
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
 
 	if (ioctl(fd, SIOCGIFINDEX, &ifr) == -1) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGIFINDEX");
 		return -1;
 	}
@@ -4605,7 +4753,7 @@ iface_bind(int fd, int ifindex, char *ebuf, int protocol)
 			ret = PCAP_ERROR_NO_SUCH_DEVICE;
 		} else {
 			ret = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "bind");
 		}
 		return ret;
@@ -4614,7 +4762,7 @@ iface_bind(int fd, int ifindex, char *ebuf, int protocol)
 	/* Any pending errors, e.g., network is down? */
 
 	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "getsockopt (SO_ERROR)");
 		return PCAP_ERROR;
 	}
@@ -4629,7 +4777,7 @@ iface_bind(int fd, int ifindex, char *ebuf, int protocol)
 		 */
 		return PCAP_ERROR_IFACE_NOT_UP;
 	} else if (err > 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    err, "bind");
 		return PCAP_ERROR;
 	}
@@ -4719,7 +4867,7 @@ added:
 	 * If we haven't already done so, arrange to have
 	 * "pcap_close_all()" called when we exit.
 	 */
-	if (!pcap_do_addexit(handle)) {
+	if (!pcapint_do_addexit(handle)) {
 		/*
 		 * "atexit()" failed; don't put the interface
 		 * in rfmon mode, just give up.
@@ -4734,9 +4882,9 @@ added:
 	 * Now configure the monitor interface up.
 	 */
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, handlep->mondevice, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, handlep->mondevice, sizeof(ifr.ifr_name));
 	if (ioctl(sock_fd, SIOCGIFFLAGS, &ifr) == -1) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "%s: Can't get flags for %s", device,
 		    handlep->mondevice);
 		del_mon_if(handle, sock_fd, &nlstate, device,
@@ -4746,7 +4894,7 @@ added:
 	}
 	ifr.ifr_flags |= IFF_UP|IFF_RUNNING;
 	if (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "%s: Can't set flags for %s", device,
 		    handlep->mondevice);
 		del_mon_if(handle, sock_fd, &nlstate, device,
@@ -4769,7 +4917,7 @@ added:
 	/*
 	 * Add this to the list of pcaps to close when we exit.
 	 */
-	pcap_add_to_pcaps_to_close(handle);
+	pcapint_add_to_pcaps_to_close(handle);
 
 	return 1;
 }
@@ -4808,7 +4956,7 @@ iface_set_all_ts_types(pcap_t *handle, char *ebuf)
 
 	handle->tstamp_type_list = malloc(NUM_SOF_TIMESTAMPING_TYPES * sizeof(u_int));
 	if (handle->tstamp_type_list == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return -1;
 	}
@@ -4848,13 +4996,13 @@ iface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)
 	 */
 	fd = get_if_ioctl_socket();
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket for SIOCETHTOOL(ETHTOOL_GET_TS_INFO)");
 		return -1;
 	}
 
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
 	memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GET_TS_INFO;
 	ifr.ifr_data = (caddr_t)&info;
@@ -4889,7 +5037,7 @@ iface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)
 			/*
 			 * Other error.
 			 */
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    save_errno,
 			    "%s: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed",
 			    device);
@@ -4925,7 +5073,7 @@ iface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)
 	if (num_ts_types != 0) {
 		handle->tstamp_type_list = malloc(num_ts_types * sizeof(u_int));
 		if (handle->tstamp_type_list == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return -1;
 		}
@@ -5006,7 +5154,7 @@ iface_ethtool_flag_ioctl(pcap_t *handle, int cmd, const char *cmdname,
 	struct ethtool_value eval;
 
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));
 	eval.cmd = cmd;
 	eval.data = 0;
 	ifr.ifr_data = (caddr_t)&eval;
@@ -5021,7 +5169,7 @@ iface_ethtool_flag_ioctl(pcap_t *handle, int cmd, const char *cmdname,
 			 */
 			return 0;
 		}
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "%s: SIOCETHTOOL(%s) ioctl failed",
 		    handle->opt.device, cmdname);
 		return -1;
@@ -5153,7 +5301,7 @@ iface_dsa_get_proto_info(const char *device, pcap_t *handle)
 
 	fd = asprintf(&pathstr, "/sys/class/net/%s/dsa/tagging", device);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 					  fd, "asprintf");
 		return PCAP_ERROR;
 	}
@@ -5168,7 +5316,7 @@ iface_dsa_get_proto_info(const char *device, pcap_t *handle)
 
 	r = read(fd, buf, sizeof(buf) - 1);
 	if (r <= 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 					  errno, "read");
 		close(fd);
 		return PCAP_ERROR;
@@ -5213,10 +5361,10 @@ iface_get_mtu(int fd, const char *device, char *ebuf)
 		return BIGGER_THAN_ALL_MTUS;
 
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
 
 	if (ioctl(fd, SIOCGIFMTU, &ifr) == -1) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGIFMTU");
 		return -1;
 	}
@@ -5234,7 +5382,7 @@ iface_get_arptype(int fd, const char *device, char *ebuf)
 	int		ret;
 
 	memset(&ifr, 0, sizeof(ifr));
-	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
 
 	if (ioctl(fd, SIOCGIFHWADDR, &ifr) == -1) {
 		if (errno == ENODEV) {
@@ -5248,7 +5396,7 @@ iface_get_arptype(int fd, const char *device, char *ebuf)
 			ebuf[0] = '\0';
 		} else {
 			ret = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGIFHWADDR");
 		}
 		return ret;
@@ -5275,7 +5423,7 @@ fix_program(pcap_t *handle, struct sock_fprog *fcode)
 	len = handle->fcode.bf_len;
 	f = (struct bpf_insn *)malloc(prog_size);
 	if (f == NULL) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return -1;
 	}
@@ -5467,13 +5615,13 @@ set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)
 		 */
 		save_mode = fcntl(handle->fd, F_GETFL, 0);
 		if (save_mode == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "can't get FD flags when changing filter");
 			return -2;
 		}
 		if (fcntl(handle->fd, F_SETFL, save_mode | O_NONBLOCK) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "can't set nonblocking mode when changing filter");
 			return -2;
@@ -5490,13 +5638,13 @@ set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)
 			 */
 			(void)fcntl(handle->fd, F_SETFL, save_mode);
 			(void)reset_kernel_filter(handle);
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, save_errno,
 			    "recv failed when changing filter");
 			return -2;
 		}
 		if (fcntl(handle->fd, F_SETFL, save_mode) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "can't restore FD flags when changing filter");
 			return -2;
@@ -5527,7 +5675,7 @@ set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)
 		 * Report it as a fatal error.
 		 */
 		if (reset_kernel_filter(handle) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "can't remove kernel total filter");
 			return -2;	/* fatal error */
@@ -5567,7 +5715,7 @@ reset_kernel_filter(pcap_t *handle)
 int
 pcap_set_protocol_linux(pcap_t *p, int protocol)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->opt.protocol = protocol;
 	return (0);
diff --git a/pcap-netfilter-linux.c b/pcap-netfilter-linux.c
index 2eb0fc8c..344bae47 100644
--- a/pcap-netfilter-linux.c
+++ b/pcap-netfilter-linux.c
@@ -28,9 +28,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "pcap-int.h"
 #include "diag-control.h"
@@ -61,7 +59,7 @@
  *       It took me quite some time to debug ;/
  *
  *       Sending any data to nfnetlink socket requires CAP_NET_ADMIN privileges,
- *       and in nfqueue we need to send verdict reply after recving packet.
+ *       and in nfqueue we need to send verdict reply after receiving packet.
  *
  *       In tcpdump you can disable dropping privileges with -Z root
  */
@@ -123,12 +121,12 @@ netfilter_read_linux(pcap_t *handle, int max_packets, pcap_handler callback, u_c
 				handle->break_loop = 0;
 				return PCAP_ERROR_BREAK;
 			}
-			if (errno == ENOBUFS)
+			if (len == -1 && errno == ENOBUFS)
 				handlep->packets_nobufs++;
 		} while ((len == -1) && (errno == EINTR || errno == ENOBUFS));
 
 		if (len < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "Can't receive packet");
 			return PCAP_ERROR;
 		}
@@ -259,7 +257,7 @@ netfilter_read_linux(pcap_t *handle, int max_packets, pcap_handler callback, u_c
 
 				gettimeofday(&pkth.ts, NULL);
 				if (handle->fcode.bf_insns == NULL ||
-						pcap_filter(handle->fcode.bf_insns, payload, pkth.len, pkth.caplen))
+						pcapint_filter(handle->fcode.bf_insns, payload, pkth.len, pkth.caplen))
 				{
 					handlep->packets_read++;
 					callback(user, &pkth, payload);
@@ -595,17 +593,17 @@ netfilter_activate(pcap_t* handle)
 	handle->offset = 0;
 	handle->read_op = netfilter_read_linux;
 	handle->inject_op = netfilter_inject_linux;
-	handle->setfilter_op = install_bpf_program; /* no kernel filtering */
+	handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */
 	handle->setdirection_op = NULL;
 	handle->set_datalink_op = netfilter_set_datalink;
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
 	handle->stats_op = netfilter_stats_linux;
 
 	/* Create netlink socket */
 	handle->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
 	if (handle->fd < 0) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't create raw socket");
 		return PCAP_ERROR;
 	}
@@ -613,32 +611,35 @@ netfilter_activate(pcap_t* handle)
 	if (type == NFLOG) {
 		handle->linktype = DLT_NFLOG;
 		handle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-		if (handle->dlt_list != NULL) {
-			handle->dlt_list[0] = DLT_NFLOG;
-			handle->dlt_list[1] = DLT_IPV4;
-			handle->dlt_count = 2;
+		if (handle->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
+			    PCAP_ERRBUF_SIZE, errno,
+			    "Can't allocate DLT list");
+			goto close_fail;
 		}
-
+		handle->dlt_list[0] = DLT_NFLOG;
+		handle->dlt_list[1] = DLT_IPV4;
+		handle->dlt_count = 2;
 	} else
 		handle->linktype = DLT_IPV4;
 
 	handle->buffer = malloc(handle->bufsize);
 	if (!handle->buffer) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't allocate dump buffer");
 		goto close_fail;
 	}
 
 	if (type == NFLOG) {
 		if (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "NFULNL_CFG_CMD_PF_UNBIND");
 			goto close_fail;
 		}
 
 		if (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_BIND, AF_INET) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "NFULNL_CFG_CMD_PF_BIND");
 			goto close_fail;
 		}
@@ -646,14 +647,14 @@ netfilter_activate(pcap_t* handle)
 		/* Bind socket to the nflog groups */
 		for (i = 0; i < group_count; i++) {
 			if (nflog_send_config_cmd(handle, groups[i], NFULNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "Can't listen on group index");
 				goto close_fail;
 			}
 
 			if (nflog_send_config_mode(handle, groups[i], NFULNL_COPY_PACKET, handle->snapshot) < 0) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "NFULNL_COPY_PACKET");
 				goto close_fail;
@@ -662,13 +663,13 @@ netfilter_activate(pcap_t* handle)
 
 	} else {
 		if (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "NFQNL_CFG_CMD_PF_UNBIND");
 			goto close_fail;
 		}
 
 		if (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_BIND, AF_INET) < 0) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "NFQNL_CFG_CMD_PF_BIND");
 			goto close_fail;
 		}
@@ -676,14 +677,14 @@ netfilter_activate(pcap_t* handle)
 		/* Bind socket to the nfqueue groups */
 		for (i = 0; i < group_count; i++) {
 			if (nfqueue_send_config_cmd(handle, groups[i], NFQNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "Can't listen on group index");
 				goto close_fail;
 			}
 
 			if (nfqueue_send_config_mode(handle, groups[i], NFQNL_COPY_PACKET, handle->snapshot) < 0) {
-				pcap_fmt_errmsg_for_errno(handle->errbuf,
+				pcapint_fmt_errmsg_for_errno(handle->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "NFQNL_COPY_PACKET");
 				goto close_fail;
@@ -695,7 +696,7 @@ netfilter_activate(pcap_t* handle)
 		/*
 		 * Monitor mode doesn't apply to netfilter devices.
 		 */
-		pcap_cleanup_live_common(handle);
+		pcapint_cleanup_live_common(handle);
 		return PCAP_ERROR_RFMON_NOTSUP;
 	}
 
@@ -704,7 +705,7 @@ netfilter_activate(pcap_t* handle)
 		 * Set the socket buffer size to the specified value.
 		 */
 		if (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF, &handle->opt.buffer_size, sizeof(handle->opt.buffer_size)) == -1) {
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "SO_RCVBUF");
 			goto close_fail;
 		}
@@ -714,7 +715,7 @@ netfilter_activate(pcap_t* handle)
 	return 0;
 
 close_fail:
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 	return PCAP_ERROR;
 }
 
@@ -771,7 +772,7 @@ netfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 		/* if netlink is not supported this is not fatal */
 		if (errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT)
 			return 0;
-		pcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,
 		    errno, "Can't open netlink socket");
 		return -1;
 	}
@@ -781,11 +782,11 @@ netfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 	 * The notion of "connected" vs. "disconnected" doesn't apply.
 	 * XXX - what about "up" and "running"?
 	 */
-	if (add_dev(devlistp, NFLOG_IFACE,
+	if (pcapint_add_dev(devlistp, NFLOG_IFACE,
 	    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
 	    "Linux netfilter log (NFLOG) interface", err_str) == NULL)
 		return -1;
-	if (add_dev(devlistp, NFQUEUE_IFACE,
+	if (pcapint_add_dev(devlistp, NFQUEUE_IFACE,
 	    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
 	    "Linux netfilter queue (NFQUEUE) interface", err_str) == NULL)
 		return -1;
diff --git a/pcap-netmap.c b/pcap-netmap.c
index 27d36e5b..f17f36ca 100644
--- a/pcap-netmap.c
+++ b/pcap-netmap.c
@@ -24,9 +24,7 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <poll.h>
 #include <errno.h>
@@ -81,7 +79,7 @@ pcap_netmap_filter(u_char *arg, struct pcap_pkthdr *h, const u_char *buf)
 	const struct bpf_insn *pc = p->fcode.bf_insns;
 
 	++pn->rx_pkts;
-	if (pc == NULL || pcap_filter(pc, buf, h->len, h->caplen))
+	if (pc == NULL || pcapint_filter(pc, buf, h->len, h->caplen))
 		pn->cb(pn->cb_arg, h, buf);
 }
 
@@ -133,13 +131,13 @@ pcap_netmap_ioctl(pcap_t *p, u_long what, uint32_t *if_flags)
 	struct ifreq ifr;
 	int error, fd = d->fd;
 
-#ifdef linux
+#ifdef __linux__
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
 		fprintf(stderr, "Error: cannot get device control socket.\n");
 		return -1;
 	}
-#endif /* linux */
+#endif /* __linux__ */
 	bzero(&ifr, sizeof(ifr));
 	strncpy(ifr.ifr_name, d->req.nr_name, sizeof(ifr.ifr_name));
 	switch (what) {
@@ -194,9 +192,9 @@ pcap_netmap_ioctl(pcap_t *p, u_long what, uint32_t *if_flags)
 #endif /* __FreeBSD__ */
 		}
 	}
-#ifdef linux
+#ifdef __linux__
 	close(fd);
-#endif /* linux */
+#endif /* __linux__ */
 	return error ? -1 : 0;
 }
 
@@ -216,7 +214,7 @@ pcap_netmap_close(pcap_t *p)
 		}
 	}
 	nm_close(d);
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 
@@ -229,10 +227,10 @@ pcap_netmap_activate(pcap_t *p)
 
 	d = nm_open(p->opt.device, NULL, 0, NULL);
 	if (d == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "netmap open: cannot access %s",
 		    p->opt.device);
-		pcap_cleanup_live_common(p);
+		pcapint_cleanup_live_common(p);
 		return (PCAP_ERROR);
 	}
 #if 0
@@ -266,11 +264,11 @@ pcap_netmap_activate(pcap_t *p)
 	p->selectable_fd = p->fd;
 	p->read_op = pcap_netmap_dispatch;
 	p->inject_op = pcap_netmap_inject;
-	p->setfilter_op = install_bpf_program;
+	p->setfilter_op = pcapint_install_bpf_program;
 	p->setdirection_op = NULL;
 	p->set_datalink_op = NULL;
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_netmap_stats;
 	p->cleanup_op = pcap_netmap_close;
 
diff --git a/pcap-new.c b/pcap-new.c
index 76388a99..822bc903 100644
--- a/pcap-new.c
+++ b/pcap-new.c
@@ -31,9 +31,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 #include "diag-control.h"
@@ -144,7 +142,7 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 			dev->name = strdup(tmpstring);
 			if (dev->name == NULL)
 			{
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "malloc() failed");
 				pcap_freealldevs(*alldevs);
@@ -158,11 +156,11 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 				localdesc = dev->name;
 			else
 				localdesc = dev->description;
-			if (pcap_asprintf(&desc, "%s '%s' %s",
+			if (pcapint_asprintf(&desc, "%s '%s' %s",
 			    PCAP_TEXT_SOURCE_ADAPTER, localdesc,
 			    PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1)
 			{
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "malloc() failed");
 				pcap_freealldevs(*alldevs);
@@ -232,14 +230,23 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 #else
 		/* opening the folder */
 		unixdir= opendir(path);
+		if (unixdir == NULL) {
+			DIAG_OFF_FORMAT_TRUNCATION
+			snprintf(errbuf, PCAP_ERRBUF_SIZE,
+			    "Error when listing files in '%s': %s", path, pcap_strerror(errno));
+			DIAG_ON_FORMAT_TRUNCATION
+			return -1;
+		}
 
 		/* get the first file into it */
+		errno = 0;
 		filedata= readdir(unixdir);
 
 		if (filedata == NULL)
 		{
 			DIAG_OFF_FORMAT_TRUNCATION
-			snprintf(errbuf, PCAP_ERRBUF_SIZE, "Error when listing files: does folder '%s' exist?", path);
+			snprintf(errbuf, PCAP_ERRBUF_SIZE,
+			    "Error when listing files in '%s': %s", path, pcap_strerror(errno));
 			DIAG_ON_FORMAT_TRUNCATION
 			closedir(unixdir);
 			return -1;
@@ -270,7 +277,7 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 				dev = (pcap_if_t *)malloc(sizeof(pcap_if_t));
 				if (dev == NULL)
 				{
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "malloc() failed");
 					pcap_freealldevs(*alldevs);
@@ -319,7 +326,7 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 				dev->name = strdup(tmpstring);
 				if (dev->name == NULL)
 				{
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "malloc() failed");
 					pcap_freealldevs(*alldevs);
@@ -334,11 +341,11 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 				/*
 				 * Create the description.
 				 */
-				if (pcap_asprintf(&dev->description,
+				if (pcapint_asprintf(&dev->description,
 				    "%s '%s' %s", PCAP_TEXT_SOURCE_FILE,
 				    filename, PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1)
 				{
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "malloc() failed");
 					pcap_freealldevs(*alldevs);
@@ -374,7 +381,7 @@ int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t
 		return pcap_findalldevs_ex_remote(source, auth, alldevs, errbuf);
 
 	default:
-		pcap_strlcpy(errbuf, "Source type not supported", PCAP_ERRBUF_SIZE);
+		pcapint_strlcpy(errbuf, "Source type not supported", PCAP_ERRBUF_SIZE);
 		return -1;
 	}
 }
@@ -428,7 +435,7 @@ pcap_t *pcap_open(const char *source, int snaplen, int flags, int read_timeout,
 		return pcap_open_rpcap(source, snaplen, flags, read_timeout, auth, errbuf);
 
 	default:
-		pcap_strlcpy(errbuf, "Source type not supported", PCAP_ERRBUF_SIZE);
+		pcapint_strlcpy(errbuf, "Source type not supported", PCAP_ERRBUF_SIZE);
 		return NULL;
 	}
 
diff --git a/pcap-nit.c b/pcap-nit.c
index 6f4f8dd8..a26caba5 100644
--- a/pcap-nit.c
+++ b/pcap-nit.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -113,7 +111,7 @@ pcap_read_nit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		if (cc < 0) {
 			if (errno == EWOULDBLOCK)
 				return (0);
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "pcap_read");
 			return (-1);
 		}
@@ -181,7 +179,7 @@ pcap_read_nit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		caplen = nh->nh_wirelen;
 		if (caplen > p->snapshot)
 			caplen = p->snapshot;
-		if (pcap_filter(p->fcode.bf_insns, cp, nh->nh_wirelen, caplen)) {
+		if (pcapint_filter(p->fcode.bf_insns, cp, nh->nh_wirelen, caplen)) {
 			struct pcap_pkthdr h;
 			h.ts = nh->nh_timestamp;
 			h.len = nh->nh_wirelen;
@@ -208,7 +206,7 @@ pcap_inject_nit(pcap_t *p, const void *buf, int size)
 	strncpy(sa.sa_data, device, sizeof(sa.sa_data));
 	ret = sendto(p->fd, buf, size, 0, &sa, sizeof(sa));
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -251,7 +249,7 @@ nit_setflags(pcap_t *p)
 		nioc.nioc_flags |= NF_PROMISC;
 
 	if (ioctl(p->fd, SIOCSNIT, &nioc) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCSNIT");
 		return (-1);
 	}
@@ -293,7 +291,7 @@ pcap_activate_nit(pcap_t *p)
 	memset(p, 0, sizeof(*p));
 	p->fd = fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket");
 		goto bad;
 	}
@@ -308,7 +306,7 @@ pcap_activate_nit(pcap_t *p)
 		 * they might be the same error, if they both end up
 		 * meaning "NIT doesn't know about that device".
 		 */
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "bind: %s", snit.snit_ifname);
 		goto bad;
 	}
@@ -323,7 +321,7 @@ pcap_activate_nit(pcap_t *p)
 	p->bufsize = BUFSPACE;
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		goto bad;
 	}
@@ -344,32 +342,32 @@ pcap_activate_nit(pcap_t *p)
 	 * Ethernet framing).
 	 */
 	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-	/*
-	 * If that fails, just leave the list empty.
-	 */
-	if (p->dlt_list != NULL) {
-		p->dlt_list[0] = DLT_EN10MB;
-		p->dlt_list[1] = DLT_DOCSIS;
-		p->dlt_count = 2;
+	if (p->dlt_list == NULL) {
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		    errno, "malloc");
+		goto bad;
 	}
+	p->dlt_list[0] = DLT_EN10MB;
+	p->dlt_list[1] = DLT_DOCSIS;
+	p->dlt_count = 2;
 
 	p->read_op = pcap_read_nit;
 	p->inject_op = pcap_inject_nit;
-	p->setfilter_op = install_bpf_program;	/* no kernel filtering */
+	p->setfilter_op = pcapint_install_bpf_program;	/* no kernel filtering */
 	p->setdirection_op = NULL;	/* Not implemented. */
 	p->set_datalink_op = NULL;	/* can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_nit;
 
 	return (0);
  bad:
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 	return (PCAP_ERROR);
 }
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -403,9 +401,9 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
-	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
+	return (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
 	    get_if_flags));
 }
 
diff --git a/pcap-npf.c b/pcap-npf.c
index 99b5981e..76346f57 100644
--- a/pcap-npf.c
+++ b/pcap-npf.c
@@ -31,9 +31,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <errno.h>
 #include <limits.h> /* for INT_MAX */
@@ -143,14 +141,56 @@ PacketGetMonitorMode(PCHAR AdapterName _U_)
 #endif
 
 /*
- * Sigh.  PacketRequest() will have made a DeviceIoControl()
- * call to the NPF driver to perform the OID request, with a
- * BIOCQUERYOID ioctl.  The kernel code should get back one
- * of NDIS_STATUS_INVALID_OID, NDIS_STATUS_NOT_SUPPORTED,
- * or NDIS_STATUS_NOT_RECOGNIZED if the OID request isn't
- * supported by the OS or the driver, but that doesn't seem
- * to make it to the caller of PacketRequest() in a
- * reliable fashion.
+ * If a driver returns an NTSTATUS value:
+ *
+ *    https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781
+ *
+ * with the "Customer" bit set, it will not be mapped to a Windows error
+ * value in userland, so it will be returned by GetLastError().
+ *
+ * Note that "driver" here includes the Npcap NPF driver, as various
+ * versions would take NT status values and set the "Customer" bit
+ * before returning the status code.  The commit message for the
+ * change that started doing that is
+ *
+ *    Returned a customer-defined NTSTATUS in OID requests to avoid
+ *    NTSTATUS-to-Win32 Error code translation.
+ *
+ * but I don't know why the goal was to avoid that translation.  For
+ * a while, I suspected that the NT status STATUS_NOT_SUPPORTED was
+ * getting mapped to ERROR_GEN_FAILURE, but, in the cases where
+ * attempts to set promiscuous mode on regular Ethernet devices were
+ * failing with ERROR_GEN_FAILURE, it turns out that the drivers for
+ * those devices were NetAdapterCx drivers, and Microsoft's NetAdapterCx
+ * mechanism wasn't providing the correct "bytes processed" value on
+ * attempts to set OIDs, and the Npcap NPF driver was checking for
+ * that and returning STATUS_UNSUCCESSFUL, which gets mapped to
+ * ERROR_GEN_FAILURE, so perhaps there's no need to avoid that
+ * translation.
+ *
+ * Attempting to set the hardware filter on a Microsoft Surface Pro's
+ * Mobile Broadband Adapter returns an error that appears to be
+ * NDIS_STATUS_NOT_SUPPORTED ORed with the "Customer" bit, so it's
+ * probably indicating that it doesn't support that.  It was probably
+ * the NPF driver setting that bit.
+ */
+#define NT_STATUS_CUSTOMER_DEFINED	0x20000000
+
+/*
+ * PacketRequest() makes a DeviceIoControl() call to the NPF driver to
+ * perform the OID request, with a BIOCQUERYOID ioctl.  The kernel code
+ * should get back one of NDIS_STATUS_INVALID_OID, NDIS_STATUS_NOT_SUPPORTED,
+ * or NDIS_STATUS_NOT_RECOGNIZED if the OID request isn't supported by
+ * the OS or the driver.
+ *
+ * Currently, that code may be returned by the Npcap NPF driver with the
+ * NT_STATUS_CUSTOMER_DEFINED bit.  That prevents the return status from
+ * being mapped to a Windows error code; if the NPF driver were to stop
+ * ORing in the NT_STATUS_CUSTOMER_DEFINED bit, it's not obvious how those
+ * the NDIS_STATUS_ values that don't correspond to NTSTATUS values would
+ * be translated to Windows error values (NDIS_STATUS_NOT_SUPPORTED is
+ * the same as STATUS_NOT_SUPPORTED, which is an NTSTATUS value that is
+ * mapped to ERROR_NOT_SUPPORTED).
  */
 #define NDIS_STATUS_INVALID_OID		0xc0010017
 #define NDIS_STATUS_NOT_SUPPORTED	0xc00000bb	/* STATUS_NOT_SUPPORTED */
@@ -182,7 +222,7 @@ oid_get_request(ADAPTER *adapter, bpf_u_int32 oid, void *data, size_t *lenp,
 	oid_data_arg->Oid = oid;
 	oid_data_arg->Length = (ULONG)(*lenp);	/* XXX - check for ridiculously large value? */
 	if (!PacketRequest(adapter, FALSE, oid_data_arg)) {
-		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "Error calling PacketRequest");
 		free(oid_data_arg);
 		return (-1);
@@ -221,7 +261,7 @@ pcap_stats_npf(pcap_t *p, struct pcap_stat *ps)
 	 * to us.
 	 */
 	if (!PacketGetStats(pw->adapter, &bstats)) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "PacketGetStats error");
 		return (-1);
 	}
@@ -278,7 +318,7 @@ pcap_stats_ex_npf(pcap_t *p, int *pcap_stat_size)
 	 * same layout, but let's not cheat.)
 	 */
 	if (!PacketGetStatsEx(pw->adapter, &bstats)) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "PacketGetStatsEx error");
 		return (NULL);
 	}
@@ -380,7 +420,7 @@ pcap_oid_set_request_npf(pcap_t *p, bpf_u_int32 oid, const void *data,
 	oid_data_arg->Length = (ULONG)(*lenp);	/* XXX - check for ridiculously large value? */
 	memcpy(oid_data_arg->Data, data, *lenp);
 	if (!PacketRequest(pw->adapter, TRUE, oid_data_arg)) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "Error calling PacketRequest");
 		free(oid_data_arg);
 		return (PCAP_ERROR);
@@ -410,7 +450,7 @@ pcap_sendqueue_transmit_npf(pcap_t *p, pcap_send_queue *queue, int sync)
 		(BOOLEAN)sync);
 
 	if(res != queue->len){
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "Error queueing packets");
 	}
 
@@ -618,7 +658,7 @@ pcap_read_npf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 				    "The interface disappeared (error code %s)",
 				    errcode_msg);
 			} else {
-				pcap_fmt_errmsg_for_win32_err(p->errbuf,
+				pcapint_fmt_errmsg_for_win32_err(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errcode,
 				    "PacketReceivePacket error");
 			}
@@ -676,13 +716,13 @@ pcap_read_npf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		 * in kernel, no need to do it now - we already know
 		 * the packet passed the filter.
 		 *
-		 * XXX - pcap_filter() should always return TRUE if
+		 * XXX - pcapint_filter() should always return TRUE if
 		 * handed a null pointer for the program, but it might
 		 * just try to "run" the filter, so we check here.
 		 */
 		if (pw->filtering_in_kernel ||
 		    p->fcode.bf_insns == NULL ||
-		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
+		    pcapint_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
 #ifdef ENABLE_REMOTE
 			switch (p->rmt_samp.method) {
 
@@ -904,7 +944,7 @@ pcap_read_win32_dag(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		/* No underlying filtering system. We need to filter on our own */
 		if (p->fcode.bf_insns)
 		{
-			if (pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen) == 0)
+			if (pcapint_filter(p->fcode.bf_insns, dp, packet_len, caplen) == 0)
 			{
 				/* Move to next packet */
 				header = (dag_record_t*)((char*)header + erf_record_len);
@@ -945,7 +985,7 @@ pcap_inject_npf(pcap_t *p, const void *buf, int size)
 
 	PacketInitPacket(&pkt, (PVOID)buf, size);
 	if(PacketSendPacket(pw->adapter,&pkt,TRUE) == FALSE) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "send error: PacketSendPacket failed");
 		return (-1);
 	}
@@ -971,51 +1011,19 @@ pcap_cleanup_npf(pcap_t *p)
 	{
 		PacketSetMonitorMode(p->opt.device, 0);
 	}
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static void
 pcap_breakloop_npf(pcap_t *p)
 {
-	pcap_breakloop_common(p);
+	pcapint_breakloop_common(p);
 	struct pcap_win *pw = p->priv;
 
 	/* XXX - what if this fails? */
 	SetEvent(PacketGetReadEvent(pw->adapter));
 }
 
-/*
- * These are NTSTATUS values:
- *
- *    https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/87fba13e-bf06-450e-83b1-9241dc81e781
- *
- * with the "Customer" bit set.  If a driver returns them, they are not
- * mapped to Windows error values in userland; they're returned by
- * GetLastError().
- *
- * Note that "driver" here includes the Npcap NPF driver, as various
- * versions would take NT status values and set the "Customer" bit
- * before returning the status code.  The commit message for the
- * change that started doing that is
- *
- *    Returned a customer-defined NTSTATUS in OID requests to avoid
- *    NTSTATUS-to-Win32 Error code translation.
- *
- * but I don't know why the goal was to avoid that translation.
- *
- * Attempting to set the hardware filter on a Microsoft Surface Pro's
- * Mobile Broadband Adapter returns an error that appears to be
- * NDIS_STATUS_NOT_SUPPORTED ORed with the "Customer" bit, so it's
- * probably indicating that it doesn't support that.
- *
- * It is likely that there are other devices which throw spurious errors,
- * at which point this will need refactoring to efficiently check against
- * a list, but for now we can just check this one value.  Perhaps the
- * right way to do this is compare against various NDIS errors with
- * the "customer" bit ORed in.
- */
-#define NT_STATUS_CUSTOMER_DEFINED	0x20000000
-
 static int
 pcap_activate_npf(pcap_t *p)
 {
@@ -1095,7 +1103,7 @@ pcap_activate_npf(pcap_t *p)
 			/*
 			 * Unknown - report details.
 			 */
-			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errcode, "Error opening adapter");
 			if (pw->rfmon_selfstart)
 			{
@@ -1108,7 +1116,7 @@ pcap_activate_npf(pcap_t *p)
 	/*get network type*/
 	if(PacketGetNetType (pw->adapter,&type) == FALSE)
 	{
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "Cannot determine the network type");
 		goto bad;
 	}
@@ -1132,14 +1140,15 @@ pcap_activate_npf(pcap_t *p)
 		 * Ethernet framing).
 		 */
 		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (p->dlt_list != NULL) {
-			p->dlt_list[0] = DLT_EN10MB;
-			p->dlt_list[1] = DLT_DOCSIS;
-			p->dlt_count = 2;
+		if (p->dlt_list == NULL)
+		{
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			goto bad;
 		}
+		p->dlt_list[0] = DLT_EN10MB;
+		p->dlt_list[1] = DLT_DOCSIS;
+		p->dlt_count = 2;
 		break;
 
 	case NdisMedium802_5:
@@ -1243,7 +1252,7 @@ pcap_activate_npf(pcap_t *p)
 		 */
 		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_SINGLE_SYNCHRONIZATION))
 		{
-			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_SINGLE_SYNCHRONIZATION");
 			goto bad;
 		}
@@ -1255,7 +1264,7 @@ pcap_activate_npf(pcap_t *p)
 		 */
 		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME))
 		{
-			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME");
 			goto bad;
 		}
@@ -1267,7 +1276,7 @@ pcap_activate_npf(pcap_t *p)
 		 */
 		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE))
 		{
-			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE");
 			goto bad;
 		}
@@ -1297,13 +1306,18 @@ pcap_activate_npf(pcap_t *p)
 	/* Set promiscuous mode */
 	if (p->opt.promisc)
 	{
-
+		/*
+		 * For future reference, in case we ever want to query
+		 * whether an adapter supports promiscuous mode, that
+		 * would be done on Windows by querying the value
+		 * of the OID_GEN_SUPPORTED_PACKET_FILTERS OID.
+		 */
 		if (PacketSetHwFilter(pw->adapter,NDIS_PACKET_TYPE_PROMISCUOUS) == FALSE)
 		{
 			DWORD errcode = GetLastError();
 
 			/*
-			 * Suppress spurious error generated by non-compiant
+			 * Suppress spurious error generated by non-compliant
 			 * MS Surface mobile adapters that appear to
 			 * return NDIS_STATUS_NOT_SUPPORTED for attempts
 			 * to set the hardware filter.
@@ -1341,10 +1355,18 @@ pcap_activate_npf(pcap_t *p)
 			 * value, so that old incorrect programs that
 			 * assume a non-zero return from pcap_activate()
 			 * is an error don't break.)
+			 *
+			 * We check here for ERROR_NOT_SUPPORTED, which
+			 * is what NDIS_STATUS_NOT_SUPPORTED (which is
+			 * the same value as the NTSTATUS value
+			 * STATUS_NOT_SUPPORTED) gets mapped to, as
+			 * well as NDIS_STATUS_NOT_SUPPORTED with the
+			 * "Customer" bit set.
 			 */
-			if (errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))
+			if (errcode != ERROR_NOT_SUPPORTED &&
+			    errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))
 			{
-				pcap_fmt_errmsg_for_win32_err(p->errbuf,
+				pcapint_fmt_errmsg_for_win32_err(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errcode,
 				    "failed to set hardware filter to promiscuous mode");
 				goto bad;
@@ -1370,12 +1392,12 @@ pcap_activate_npf(pcap_t *p)
 			DWORD errcode = GetLastError();
 
 			/*
-			 * Suppress spurious error generated by non-compiant
+			 * Suppress spurious error generated by non-compliant
 			 * MS Surface mobile adapters.
 			 */
 			if (errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))
 			{
-				pcap_fmt_errmsg_for_win32_err(p->errbuf,
+				pcapint_fmt_errmsg_for_win32_err(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errcode,
 				    "failed to set hardware filter to non-promiscuous mode");
 				goto bad;
@@ -1407,7 +1429,7 @@ pcap_activate_npf(pcap_t *p)
 		p->buffer = malloc(p->bufsize);
 		if (p->buffer == NULL)
 		{
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			goto bad;
 		}
@@ -1417,7 +1439,7 @@ pcap_activate_npf(pcap_t *p)
 			/* tell the driver to copy the buffer as soon as data arrives */
 			if(PacketSetMinToCopy(pw->adapter,0)==FALSE)
 			{
-				pcap_fmt_errmsg_for_win32_err(p->errbuf,
+				pcapint_fmt_errmsg_for_win32_err(p->errbuf,
 				    PCAP_ERRBUF_SIZE, GetLastError(),
 				    "Error calling PacketSetMinToCopy");
 				goto bad;
@@ -1428,7 +1450,7 @@ pcap_activate_npf(pcap_t *p)
 			/* tell the driver to copy the buffer only if it contains at least 16K */
 			if(PacketSetMinToCopy(pw->adapter,16000)==FALSE)
 			{
-				pcap_fmt_errmsg_for_win32_err(p->errbuf,
+				pcapint_fmt_errmsg_for_win32_err(p->errbuf,
 				    PCAP_ERRBUF_SIZE, GetLastError(),
 				    "Error calling PacketSetMinToCopy");
 				goto bad;
@@ -1505,7 +1527,7 @@ pcap_activate_npf(pcap_t *p)
 	total_prog.bf_len = 1;
 	total_prog.bf_insns = &total_insn;
 	if (!PacketSetBpf(pw->adapter, &total_prog)) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "PacketSetBpf");
 		status = PCAP_ERROR;
 		goto bad;
@@ -1569,7 +1591,7 @@ pcap_activate_npf(pcap_t *p)
 	 * that the caller can do anything useful with it.
 	 *
 	 * (Not that we make any general guarantee of that
-	 * sort on UN*X, either, any more, given that not
+	 * sort on UN*X, either, anymore, given that not
 	 * all capture devices are regular OS network
 	 * interfaces.)
 	 */
@@ -1600,6 +1622,11 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 	char *device_copy = NULL;
 	ADAPTER *adapter = NULL;
 	ULONG num_ts_modes;
+	/* Npcap 1.00 driver is buggy and will write 16 bytes regardless of
+	 * buffer size. Using a sufficient stack buffer avoids overflow and
+	 * avoids a heap allocation in most (currently all) cases.
+	 */
+	ULONG ts_modes[4];
 	BOOL ret;
 	DWORD error = ERROR_SUCCESS;
 	ULONG *modes = NULL;
@@ -1616,7 +1643,7 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 		 */
 		device_copy = strdup(device);
 		if (device_copy == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
 			status = -1;
 			break;
 		}
@@ -1660,7 +1687,7 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 				p->tstamp_type_list = NULL;
 				status = 0;
 			} else {
-				pcap_fmt_errmsg_for_win32_err(ebuf,
+				pcapint_fmt_errmsg_for_win32_err(ebuf,
 				    PCAP_ERRBUF_SIZE, error,
 				    "Error opening adapter");
 				status = -1;
@@ -1690,8 +1717,8 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 		 * happen), and that ULONG should be set to the
 		 * number of modes.
 		 */
-		num_ts_modes = 1;
-		ret = PacketGetTimestampModes(adapter, &num_ts_modes);
+		ts_modes[0] = sizeof(ts_modes) / sizeof(ULONG);
+		ret = PacketGetTimestampModes(adapter, ts_modes);
 		if (!ret) {
 			/*
 			 * OK, it failed.  Did it fail with
@@ -1725,60 +1752,61 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 				/*
 				 * No, some other error.  Fail.
 				 */
-				pcap_fmt_errmsg_for_win32_err(ebuf,
+				pcapint_fmt_errmsg_for_win32_err(ebuf,
 				    PCAP_ERRBUF_SIZE, error,
 				    "Error calling PacketGetTimestampModes");
 				status = -1;
 				break;
 			}
+
+			/*
+			 * Yes, so we now know how many types to fetch.
+			 *
+			 * The buffer needs to have one ULONG for the
+			 * count and num_ts_modes ULONGs for the
+			 * num_ts_modes time stamp types.
+			 */
+			num_ts_modes = ts_modes[0];
+			modes = (ULONG *)malloc((1 + num_ts_modes) * sizeof(ULONG));
+			if (modes == NULL) {
+				/* Out of memory. */
+				pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
+				status = -1;
+				break;
+			}
+			modes[0] = 1 + num_ts_modes;
+			if (!PacketGetTimestampModes(adapter, modes)) {
+				pcapint_fmt_errmsg_for_win32_err(ebuf,
+						PCAP_ERRBUF_SIZE, GetLastError(),
+						"Error calling PacketGetTimestampModes");
+				status = -1;
+				break;
+			}
+			if (modes[0] != num_ts_modes) {
+				snprintf(ebuf, PCAP_ERRBUF_SIZE,
+						"First PacketGetTimestampModes() call gives %lu modes, second call gives %lu modes",
+						num_ts_modes, modes[0]);
+				status = -1;
+				break;
+			}
+		}
+		else {
+			modes = ts_modes;
+			num_ts_modes = ts_modes[0];
 		}
-		/* else (ret == TRUE)
-		 * Unexpected success. Let's act like we got ERROR_MORE_DATA.
-		 * If it doesn't work, we'll hit some other error condition farther on.
-		 */
 
 		/* If the driver reports no modes supported *and*
 		 * ERROR_MORE_DATA, something is seriously wrong.
 		 * We *could* ignore the error and continue without supporting
 		 * settable timestamp modes, but that would hide a bug.
 		 */
-		if (num_ts_modes == 0) {
+		if (modes[0] == 0) {
 			snprintf(ebuf, PCAP_ERRBUF_SIZE,
 			    "PacketGetTimestampModes() reports 0 modes supported.");
 			status = -1;
 			break;
 		}
 
-		/*
-		 * Yes, so we now know how many types to fetch.
-		 *
-		 * The buffer needs to have one ULONG for the
-		 * count and num_ts_modes ULONGs for the
-		 * num_ts_modes time stamp types.
-		 */
-		modes = (ULONG *)malloc((1 + num_ts_modes) * sizeof(ULONG));
-		if (modes == NULL) {
-			/* Out of memory. */
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
-			status = -1;
-			break;
-		}
-		modes[0] = 1 + num_ts_modes;
-		if (!PacketGetTimestampModes(adapter, modes)) {
-			pcap_fmt_errmsg_for_win32_err(ebuf,
-			    PCAP_ERRBUF_SIZE, GetLastError(),
-			    "Error calling PacketGetTimestampModes");
-			status = -1;
-			break;
-		}
-		if (modes[0] != num_ts_modes) {
-			snprintf(ebuf, PCAP_ERRBUF_SIZE,
-			    "First PacketGetTimestampModes() call gives %lu modes, second call gives %lu modes",
-			    num_ts_modes, modes[0]);
-			status = -1;
-			break;
-		}
-
 		/*
 		 * Allocate a buffer big enough for
 		 * PCAP_TSTAMP_HOST (default) plus
@@ -1786,7 +1814,7 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 		 */
 		p->tstamp_type_list = malloc((1 + num_ts_modes) * sizeof(u_int));
 		if (p->tstamp_type_list == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
 			status = -1;
 			break;
 		}
@@ -1843,7 +1871,7 @@ get_ts_types(const char *device, pcap_t *p, char *ebuf)
 	if (device_copy != NULL) {
 		free(device_copy);
 	}
-	if (modes != NULL) {
+	if (modes != NULL && modes != ts_modes) {
 		free(modes);
 	}
 	if (adapter != NULL) {
@@ -1864,7 +1892,7 @@ get_ts_types(const char *device _U_, pcap_t *p _U_, char *ebuf _U_)
 #endif /* HAVE_PACKET_GET_TIMESTAMP_MODES */
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -1915,11 +1943,11 @@ pcap_setfilter_npf(pcap_t *p, struct bpf_program *fp)
 		 */
 
 		/*
-		 * install_bpf_program() validates the program.
+		 * pcapint_install_bpf_program() validates the program.
 		 *
 		 * XXX - what if we already have a filter in the kernel?
 		 */
-		if (install_bpf_program(p, fp) < 0)
+		if (pcapint_install_bpf_program(p, fp) < 0)
 			return (-1);
 		pw->filtering_in_kernel = 0;	/* filtering in userland */
 		return (0);
@@ -1948,12 +1976,12 @@ pcap_setfilter_win32_dag(pcap_t *p, struct bpf_program *fp) {
 
 	if(!fp)
 	{
-		pcap_strlcpy(p->errbuf, "setfilter: No filter specified", sizeof(p->errbuf));
+		pcapint_strlcpy(p->errbuf, "setfilter: No filter specified", sizeof(p->errbuf));
 		return (-1);
 	}
 
 	/* Install a user level filter */
-	if (install_bpf_program(p, fp) < 0)
+	if (pcapint_install_bpf_program(p, fp) < 0)
 		return (-1);
 
 	return (0);
@@ -1996,7 +2024,7 @@ pcap_setnonblock_npf(pcap_t *p, int nonblock)
 		newtimeout = p->opt.timeout;
 	}
 	if (!PacketSetReadTimeout(pw->adapter, newtimeout)) {
-		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "PacketSetReadTimeout");
 		return (-1);
 	}
@@ -2018,7 +2046,7 @@ pcap_add_if_npf(pcap_if_list_t *devlistp, char *name, bpf_u_int32 flags,
 	/*
 	 * Add an entry for this interface, with no addresses.
 	 */
-	curdev = add_dev(devlistp, name, flags, description, errbuf);
+	curdev = pcapint_add_dev(devlistp, name, flags, description, errbuf);
 	if (curdev == NULL) {
 		/*
 		 * Failure.
@@ -2050,7 +2078,7 @@ pcap_add_if_npf(pcap_if_list_t *devlistp, char *name, bpf_u_int32 flags,
 		 * "curdev" is an entry for this interface; add an entry for
 		 * this address to its list of addresses.
 		 */
-		res = add_addr_to_dev(curdev,
+		res = pcapint_add_addr_to_dev(curdev,
 		    (struct sockaddr *)&if_addrs[if_addr_size].IPAddress,
 		    sizeof (struct sockaddr_storage),
 		    (struct sockaddr *)&if_addrs[if_addr_size].SubnetMask,
@@ -2327,7 +2355,7 @@ DIAG_ON_ENUM_SWITCH
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 	int ret = 0;
 	const char *desc;
@@ -2359,7 +2387,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 
 		if (last_error != ERROR_INSUFFICIENT_BUFFER)
 		{
-			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 			    last_error, "PacketGetAdapterNames");
 			return (-1);
 		}
@@ -2375,7 +2403,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 	}
 
 	if (!PacketGetAdapterNames(AdaptersName, &NameLength)) {
-		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "PacketGetAdapterNames");
 		free(AdaptersName);
 		return (-1);
@@ -2490,7 +2518,7 @@ pcap_lookupdev(char *errbuf)
 	 * In addition, it's not thread-safe, so we've marked it as
 	 * deprecated.
 	 */
-	if (pcap_new_api) {
+	if (pcapint_new_api) {
 		snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()");
 		return (NULL);
@@ -2536,7 +2564,7 @@ DIAG_ON_DEPRECATION
 
 		if ( !PacketGetAdapterNames((PTSTR)TAdaptersName,&NameLength) )
 		{
-			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 			    GetLastError(), "PacketGetAdapterNames");
 			free(TAdaptersName);
 			return NULL;
@@ -2710,7 +2738,7 @@ pcap_lib_version(void)
 			 */
 			char *full_pcap_version_string;
 
-			if (pcap_asprintf(&full_pcap_version_string,
+			if (pcapint_asprintf(&full_pcap_version_string,
 			    WINPCAP_PRODUCT_NAME " version " WINPCAP_VER_STRING " (packet.dll version %s), based on " PCAP_VERSION_STRING,
 			    packet_version_string) != -1) {
 				/* Success */
@@ -2737,7 +2765,7 @@ pcap_lib_version(void)
 		 */
 		char *full_pcap_version_string;
 
-		if (pcap_asprintf(&full_pcap_version_string,
+		if (pcapint_asprintf(&full_pcap_version_string,
 		    PCAP_VERSION_STRING " (packet.dll version %s)",
 		    PacketGetVersion()) != -1) {
 			/* Success */
diff --git a/pcap-null.c b/pcap-null.c
index 2ae27bf8..f0e35ec8 100644
--- a/pcap-null.c
+++ b/pcap-null.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <string.h>
 
@@ -30,14 +28,14 @@
 static char nosup[] = "live packet capture not supported on this system";
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
-	(void)pcap_strlcpy(ebuf, nosup, PCAP_ERRBUF_SIZE);
+	(void)pcapint_strlcpy(ebuf, nosup, PCAP_ERRBUF_SIZE);
 	return (NULL);
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf _U_)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf _U_)
 {
 	/*
 	 * There are no interfaces on which we can capture.
@@ -50,7 +48,7 @@ int
 pcap_lookupnet(const char *device _U_, bpf_u_int32 *netp _U_,
     bpf_u_int32 *maskp _U_, char *errbuf)
 {
-	(void)pcap_strlcpy(errbuf, nosup, PCAP_ERRBUF_SIZE);
+	(void)pcapint_strlcpy(errbuf, nosup, PCAP_ERRBUF_SIZE);
 	return (-1);
 }
 #endif
diff --git a/pcap-pf.c b/pcap-pf.c
index bd27933e..cdad9882 100644
--- a/pcap-pf.c
+++ b/pcap-pf.c
@@ -22,9 +22,7 @@
  *	Extraction/creation by Jeffrey Mogul, DECWRL
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -79,7 +77,7 @@ struct rtentry;
  */
 struct pcap_pf {
 	int	filtering_in_kernel; /* using kernel filter */
-	u_long	TotPkts;	/* can't oflow for 79 hrs on ether */
+	u_long	TotPkts;	/* can't overflow for 79 hrs on ether */
 	u_long	TotAccepted;	/* count accepted by filter */
 	u_long	TotDrops;	/* count of dropped packets */
 	long	TotMissed;	/* missed by i/f during this run */
@@ -124,7 +122,7 @@ pcap_read_pf(pcap_t *pc, int cnt, pcap_handler callback, u_char *user)
 				(void)lseek(pc->fd, 0L, SEEK_SET);
 				goto again;
 			}
-			pcap_fmt_errmsg_for_errno(pc->errbuf,
+			pcapint_fmt_errmsg_for_errno(pc->errbuf,
 			    sizeof(pc->errbuf), errno, "pf read");
 			return (-1);
 		}
@@ -203,7 +201,7 @@ pcap_read_pf(pcap_t *pc, int cnt, pcap_handler callback, u_char *user)
 		 * skipping that padding.
 		 */
 		if (pf->filtering_in_kernel ||
-		    pcap_filter(pc->fcode.bf_insns, p, sp->ens_count, buflen)) {
+		    pcapint_filter(pc->fcode.bf_insns, p, sp->ens_count, buflen)) {
 			struct pcap_pkthdr h;
 			pf->TotAccepted++;
 			h.ts = sp->ens_tstamp;
@@ -230,7 +228,7 @@ pcap_inject_pf(pcap_t *p, const void *buf, int size)
 
 	ret = write(p->fd, buf, size);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -335,7 +333,7 @@ pcap_activate_pf(pcap_t *p)
 			    p->opt.device);
 			err = PCAP_ERROR_PERM_DENIED;
 		} else {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "pf open: %s", p->opt.device);
 			err = PCAP_ERROR;
 		}
@@ -360,7 +358,7 @@ pcap_activate_pf(pcap_t *p)
 	if (p->opt.promisc)
 		enmode |= ENPROMISC;
 	if (ioctl(p->fd, EIOCMBIS, (caddr_t)&enmode) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "EIOCMBIS");
 		err = PCAP_ERROR;
 		goto bad;
@@ -372,14 +370,14 @@ pcap_activate_pf(pcap_t *p)
 #endif
 	/* set the backlog */
 	if (ioctl(p->fd, EIOCSETW, (caddr_t)&backlog) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "EIOCSETW");
 		err = PCAP_ERROR;
 		goto bad;
 	}
 	/* discover interface type */
 	if (ioctl(p->fd, EIOCDEVP, (caddr_t)&devparams) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "EIOCDEVP");
 		err = PCAP_ERROR;
 		goto bad;
@@ -404,14 +402,15 @@ pcap_activate_pf(pcap_t *p)
 		 * Ethernet framing).
 		 */
 		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (p->dlt_list != NULL) {
-			p->dlt_list[0] = DLT_EN10MB;
-			p->dlt_list[1] = DLT_DOCSIS;
-			p->dlt_count = 2;
+		if (p->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			err = PCAP_ERROR;
+			goto bad;
 		}
+		p->dlt_list[0] = DLT_EN10MB;
+		p->dlt_list[1] = DLT_DOCSIS;
+		p->dlt_count = 2;
 		break;
 
 	case ENDT_FDDI:
@@ -476,7 +475,7 @@ pcap_activate_pf(pcap_t *p)
 	} else
 		p->fddipad = 0;
 	if (ioctl(p->fd, EIOCTRUNCATE, (caddr_t)&p->snapshot) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "EIOCTRUNCATE");
 		err = PCAP_ERROR;
 		goto bad;
@@ -486,7 +485,7 @@ pcap_activate_pf(pcap_t *p)
 	Filter.enf_Priority = 37;	/* anything > 2 */
 	Filter.enf_FilterLen = 0;	/* means "always true" */
 	if (ioctl(p->fd, EIOCSETF, (caddr_t)&Filter) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "EIOCSETF");
 		err = PCAP_ERROR;
 		goto bad;
@@ -497,7 +496,7 @@ pcap_activate_pf(pcap_t *p)
 		timeout.tv_sec = p->opt.timeout / 1000;
 		timeout.tv_usec = (p->opt.timeout * 1000) % 1000000;
 		if (ioctl(p->fd, EIOCSRTIMEOUT, (caddr_t)&timeout) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "EIOCSRTIMEOUT");
 			err = PCAP_ERROR;
 			goto bad;
@@ -507,7 +506,7 @@ pcap_activate_pf(pcap_t *p)
 	p->bufsize = BUFSPACE;
 	p->buffer = malloc(p->bufsize + p->offset);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		err = PCAP_ERROR;
 		goto bad;
@@ -523,18 +522,18 @@ pcap_activate_pf(pcap_t *p)
 	p->setfilter_op = pcap_setfilter_pf;
 	p->setdirection_op = NULL;	/* Not implemented. */
 	p->set_datalink_op = NULL;	/* can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_pf;
 
 	return (0);
  bad:
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 	return (err);
 }
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -578,9 +577,9 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
-	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
+	return (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
 	    get_if_flags));
 }
 
@@ -593,7 +592,7 @@ pcap_setfilter_pf(pcap_t *p, struct bpf_program *fp)
 	/*
 	 * See if BIOCVERSION works.  If not, we assume the kernel doesn't
 	 * support BPF-style filters (it's not documented in the bpf(7)
-	 * or packetfiler(7) man pages, but the code used to fail if
+	 * or packetfilter(7) man pages, but the code used to fail if
 	 * BIOCSETF worked but BIOCVERSION didn't, and I've seen it do
 	 * kernel filtering in DU 4.0, so presumably BIOCVERSION works
 	 * there, at least).
@@ -610,7 +609,7 @@ pcap_setfilter_pf(pcap_t *p, struct bpf_program *fp)
 			 * Yes.  Try to install the filter.
 			 */
 			if (ioctl(p->fd, BIOCSETF, (caddr_t)fp) < 0) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    sizeof(p->errbuf), errno, "BIOCSETF");
 				return (-1);
 			}
@@ -659,7 +658,7 @@ pcap_setfilter_pf(pcap_t *p, struct bpf_program *fp)
 	/*
 	 * We couldn't do filtering in the kernel; do it in userland.
 	 */
-	if (install_bpf_program(p, fp) < 0)
+	if (pcapint_install_bpf_program(p, fp) < 0)
 		return (-1);
 
 	/*
diff --git a/pcap-rdmasniff.c b/pcap-rdmasniff.c
index d63ca898..fd6d6fa6 100644
--- a/pcap-rdmasniff.c
+++ b/pcap-rdmasniff.c
@@ -28,9 +28,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+#include <config.h>
 
 #include "pcap-int.h"
 #include "pcap-rdmasniff.h"
@@ -89,7 +87,7 @@ rdmasniff_cleanup(pcap_t *handle)
 	ibv_close_device(priv->context);
 	free(priv->oneshot_buffer);
 
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 }
 
 static void
@@ -172,7 +170,7 @@ rdmasniff_read(pcap_t *handle, int max_packets, pcap_handler callback, u_char *u
 		pktd = (u_char *) handle->buffer + wc.wr_id * RDMASNIFF_RECEIVE_SIZE;
 
 		if (handle->fcode.bf_insns == NULL ||
-		    pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
+		    pcapint_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {
 			callback(user, &pkth, pktd);
 			++priv->packets_recv;
 			++count;
@@ -323,11 +321,11 @@ rdmasniff_activate(pcap_t *handle)
 	handle->read_op = rdmasniff_read;
 	handle->stats_op = rdmasniff_stats;
 	handle->cleanup_op = rdmasniff_cleanup;
-	handle->setfilter_op = install_bpf_program;
+	handle->setfilter_op = pcapint_install_bpf_program;
 	handle->setdirection_op = NULL;
 	handle->set_datalink_op = NULL;
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
 	handle->oneshot_callback = rdmasniff_oneshot;
 	handle->selectable_fd = priv->channel->fd;
 
@@ -444,7 +442,7 @@ rdmasniff_findalldevs(pcap_if_list_t *devlistp, char *err_str)
 		 * XXX - do the notions of "up", "running", or
 		 * "connected" apply here?
 		 */
-		if (!add_dev(devlistp, dev_list[i]->name, 0, "RDMA sniffer", err_str)) {
+		if (!pcapint_add_dev(devlistp, dev_list[i]->name, 0, "RDMA sniffer", err_str)) {
 			ret = -1;
 			break;
 		}
diff --git a/pcap-rpcap-int.h b/pcap-rpcap-int.h
deleted file mode 100644
index e707a85f..00000000
--- a/pcap-rpcap-int.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)
- * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the Politecnico di Torino, CACE Technologies
- * nor the names of its contributors may be used to endorse or promote
- * products derived from this software without specific prior written
- * permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __PCAP_RPCAP_INT_H__
-#define __PCAP_RPCAP_INT_H__
-
-#include "pcap.h"
-#include "sockutils.h"	/* Needed for some structures (like SOCKET, sockaddr_in) which are used here */
-
-/*
- * \file pcap-rpcap-int.h
- *
- * This file keeps all the definitions used by the RPCAP client and server,
- * other than the protocol definitions.
- *
- * \warning All the RPCAP functions that are allowed to return a buffer containing
- * the error description can return max PCAP_ERRBUF_SIZE characters.
- * However there is no guarantees that the string will be zero-terminated.
- * Best practice is to define the errbuf variable as a char of size 'PCAP_ERRBUF_SIZE+1'
- * and to insert manually the termination char at the end of the buffer. This will
- * guarantee that no buffer overflows occur even if we use the printf() to show
- * the error on the screen.
- */
-
-/*********************************************************
- *                                                       *
- * General definitions / typedefs for the RPCAP protocol *
- *                                                       *
- *********************************************************/
-
-/*
- * \brief Buffer used by socket functions to send-receive packets.
- * In case you plan to have messages larger than this value, you have to increase it.
- */
-#define RPCAP_NETBUF_SIZE 64000
-
-/*********************************************************
- *                                                       *
- * Exported function prototypes                          *
- *                                                       *
- *********************************************************/
-void rpcap_createhdr(struct rpcap_header *header, uint8 type, uint16 value, uint32 length);
-int rpcap_senderror(SOCKET sock, char *error, unsigned short errcode, char *errbuf);
-
-#endif
diff --git a/pcap-rpcap.c b/pcap-rpcap.c
index 22fc7363..408d453f 100644
--- a/pcap-rpcap.c
+++ b/pcap-rpcap.c
@@ -31,9 +31,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 #include "diag-control.h"
@@ -93,7 +91,7 @@
 struct activehosts
 {
 	struct sockaddr_storage host;
-	SOCKET sockctrl;
+	PCAP_SOCKET sockctrl;
 	SSL *ssl;
 	uint8 protocol_version;
 	int byte_swapped;
@@ -109,7 +107,7 @@ static struct activehosts *activeHosts;
  * See the documentation of pcap_remoteact_accept() and
  * pcap_remoteact_cleanup() for more details.
  */
-static SOCKET sockmain;
+static PCAP_SOCKET sockmain;
 static SSL *ssl_main;
 
 /*
@@ -123,11 +121,11 @@ struct pcap_rpcap {
 	 */
 	int rmt_clientside;
 
-	SOCKET rmt_sockctrl;		/* socket ID of the socket used for the control connection */
-	SOCKET rmt_sockdata;		/* socket ID of the socket used for the data connection */
+	PCAP_SOCKET rmt_sockctrl;	/* socket ID of the socket used for the control connection */
+	PCAP_SOCKET rmt_sockdata;	/* socket ID of the socket used for the data connection */
 	SSL *ctrl_ssl, *data_ssl;	/* optional transport of rmt_sockctrl and rmt_sockdata via TLS */
 	int rmt_flags;			/* we have to save flags, since they are passed by the pcap_open_live(), but they are used by the pcap_startcapture() */
-	int rmt_capstarted;		/* 'true' if the capture is already started (needed to knoe if we have to call the pcap_startcapture() */
+	int rmt_capstarted;		/* 'true' if the capture is already started (needed to know if we have to call the pcap_startcapture() */
 	char *currentfilter;		/* Pointer to a buffer (allocated at run-time) that stores the current filter. Needed when flag PCAP_OPENFLAG_NOCAPTURE_RPCAP is turned on. */
 
 	uint8 protocol_version;		/* negotiated protocol version */
@@ -172,13 +170,13 @@ static void pcap_save_current_filter_rpcap(pcap_t *fp, const char *filter);
 static int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog);
 static int pcap_setsampling_remote(pcap_t *fp);
 static int pcap_startcapture_remote(pcap_t *fp);
-static int rpcap_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *header, char *errbuf);
-static int rpcap_check_msg_ver(SOCKET sock, SSL *, uint8 expected_ver, struct rpcap_header *header, char *errbuf);
-static int rpcap_check_msg_type(SOCKET sock, SSL *, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf);
-static int rpcap_process_msg_header(SOCKET sock, SSL *, uint8 ver, uint8 request_type, struct rpcap_header *header, char *errbuf);
-static int rpcap_recv(SOCKET sock, SSL *, void *buffer, size_t toread, uint32 *plen, char *errbuf);
-static void rpcap_msg_err(SOCKET sockctrl, SSL *, uint32 plen, char *remote_errbuf);
-static int rpcap_discard(SOCKET sock, SSL *, uint32 len, char *errbuf);
+static int rpcap_recv_msg_header(PCAP_SOCKET sock, SSL *, struct rpcap_header *header, char *errbuf);
+static int rpcap_check_msg_ver(PCAP_SOCKET sock, SSL *, uint8 expected_ver, struct rpcap_header *header, char *errbuf);
+static int rpcap_check_msg_type(PCAP_SOCKET sock, SSL *, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf);
+static int rpcap_process_msg_header(PCAP_SOCKET sock, SSL *, uint8 ver, uint8 request_type, struct rpcap_header *header, char *errbuf);
+static int rpcap_recv(PCAP_SOCKET sock, SSL *, void *buffer, size_t toread, uint32 *plen, char *errbuf);
+static void rpcap_msg_err(PCAP_SOCKET sockctrl, SSL *, uint32 plen, char *remote_errbuf);
+static int rpcap_discard(PCAP_SOCKET sock, SSL *, uint32 len, char *errbuf);
 static int rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t size);
 
 /****************************************************
@@ -269,7 +267,10 @@ static int rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t si
 
 /*
  * Possible IPv4 family values other than the designated over-the-wire value,
- * which is 2 (because everybody uses 2 for AF_INET4).
+ * which is 2 (because everybody, except for Haiku uses 2 for AF_INET,
+ * and Haiku has probably never run the old rpcapd code that put address
+ * structures directly on the wire, rather than the new rpcapd code
+ * that serializes addresses, using 2 for AF_INET).
  */
 #define SOCKADDR_IN_LEN		16	/* length of struct sockaddr_in */
 #define SOCKADDR_IN6_LEN	28	/* length of struct sockaddr_in6 */
@@ -295,7 +296,7 @@ static int rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t si
 #define SOLARIS_AF_INET6		26
 
 static int
-rpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr_storage **sockaddrout, char *errbuf)
+rpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr **sockaddrout, char *errbuf)
 {
 	/* Warning: we support only AF_INET and AF_INET6 */
 	switch (ntohs(sockaddrin->family))
@@ -307,10 +308,10 @@ rpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr_storage **soc
 		struct rpcap_sockaddr_in *sockaddrin_ipv4;
 		struct sockaddr_in *sockaddrout_ipv4;
 
-		(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in));
+		(*sockaddrout) = (struct sockaddr *) malloc(sizeof(struct sockaddr_in));
 		if ((*sockaddrout) == NULL)
 		{
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc() failed");
 			return -1;
 		}
@@ -337,10 +338,10 @@ rpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr_storage **soc
 		struct rpcap_sockaddr_in6 *sockaddrin_ipv6;
 		struct sockaddr_in6 *sockaddrout_ipv6;
 
-		(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in6));
+		(*sockaddrout) = (struct sockaddr *) malloc(sizeof(struct sockaddr_in6));
 		if ((*sockaddrout) == NULL)
 		{
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc() failed");
 			return -1;
 		}
@@ -693,7 +694,7 @@ static int pcap_read_rpcap(pcap_t *p, int cnt, pcap_handler callback, u_char *us
 			 * it to the callback, and count it so we can
 			 * return the count.
 			 */
-			pcap_post_process(p->linktype, pr->byte_swapped,
+			pcapint_post_process(p->linktype, pr->byte_swapped,
 			    &pkt_header, pkt_data);
 			(*callback)(user, &pkt_header, pkt_data);
 			n++;
@@ -834,7 +835,7 @@ static void pcap_cleanup_rpcap(pcap_t *fp)
 		pr->currentfilter = NULL;
 	}
 
-	pcap_cleanup_live_common(fp);
+	pcapint_cleanup_live_common(fp);
 
 	/* To avoid inconsistencies in the number of sock_init() */
 	sock_cleanup();
@@ -1021,7 +1022,6 @@ rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)
 {
 	struct activehosts *temp;			/* temp var needed to scan the host list chain */
 	struct addrinfo hints, *addrinfo, *ai_next;	/* temp var needed to translate between hostname to its address */
-	int retval;
 
 	/* retrieve the network address corresponding to 'host' */
 	addrinfo = NULL;
@@ -1029,9 +1029,9 @@ rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)
 	hints.ai_family = PF_UNSPEC;
 	hints.ai_socktype = SOCK_STREAM;
 
-	retval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,
+	addrinfo = sock_initaddress(host, NULL, &hints, errbuf,
 	    PCAP_ERRBUF_SIZE);
-	if (retval != 0)
+	if (addrinfo == NULL)
 	{
 		*error = 1;
 		return NULL;
@@ -1094,7 +1094,7 @@ static int pcap_startcapture_remote(pcap_t *fp)
 	/* socket-related variables*/
 	struct addrinfo hints;			/* temp, needed to open a socket connection */
 	struct addrinfo *addrinfo;		/* temp, needed to open a socket connection */
-	SOCKET sockdata = 0;			/* socket descriptor of the data connection */
+	PCAP_SOCKET sockdata = 0;		/* socket descriptor of the data connection */
 	struct sockaddr_storage saddr;		/* temp, needed to retrieve the network data port chosen on the local machine */
 	socklen_t saddrlen;			/* temp, needed to retrieve the network data port chosen on the local machine */
 	int ai_family;				/* temp, keeps the address family used by the control connection */
@@ -1183,7 +1183,9 @@ static int pcap_startcapture_remote(pcap_t *fp)
 		hints.ai_flags = AI_PASSIVE;	/* Data connection is opened by the server toward the client */
 
 		/* Let's the server pick up a free network port for us */
-		if (sock_initaddress(NULL, NULL, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)
+		addrinfo = sock_initaddress(NULL, NULL, &hints, fp->errbuf,
+		    PCAP_ERRBUF_SIZE);
+		if (addrinfo == NULL)
 			goto error_nodiscard;
 
 		if ((sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER,
@@ -1308,7 +1310,9 @@ static int pcap_startcapture_remote(pcap_t *fp)
 			snprintf(portstring, PCAP_BUF_SIZE, "%d", ntohs(startcapreply.portdata));
 
 			/* Let's the server pick up a free network port for us */
-			if (sock_initaddress(host, portstring, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)
+			addrinfo = sock_initaddress(host, portstring, &hints,
+			    fp->errbuf, PCAP_ERRBUF_SIZE);
+			if (addrinfo == NULL)
 				goto error;
 
 			if ((sockdata = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
@@ -1320,7 +1324,7 @@ static int pcap_startcapture_remote(pcap_t *fp)
 		}
 		else
 		{
-			SOCKET socktemp;	/* We need another socket, since we're going to accept() a connection */
+			PCAP_SOCKET socktemp;	/* We need another socket, since we're going to accept() a connection */
 
 			/* Connection creation */
 			saddrlen = sizeof(struct sockaddr_storage);
@@ -1427,7 +1431,7 @@ static int pcap_startcapture_remote(pcap_t *fp)
 	fp->buffer = (u_char *)malloc(fp->bufsize);
 	if (fp->buffer == NULL)
 	{
-		pcap_fmt_errmsg_for_errno(fp->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(fp->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		goto error;
 	}
@@ -1545,7 +1549,7 @@ error_nodiscard:
  *
  * \param sendbuf: the buffer on which the serialized data has to copied.
  *
- * \param sendbufidx: it is used to return the abounf of bytes copied into the buffer.
+ * \param sendbufidx: it is used to return the amount of bytes copied into the buffer.
  *
  * \param prog: the bpf program we have to copy.
  *
@@ -1701,7 +1705,7 @@ static int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog)
 	if (!pr->rmt_capstarted)
 	{
 		/* copy filter into the pcap_t structure */
-		if (install_bpf_program(fp, prog) == -1)
+		if (pcapint_install_bpf_program(fp, prog) == -1)
 			return -1;
 		return 0;
 	}
@@ -1797,7 +1801,7 @@ static int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)
 			 * We have a current filter; add items to it to
 			 * filter out this rpcap session.
 			 */
-			if (pcap_asprintf(&newfilter,
+			if (pcapint_asprintf(&newfilter,
 			    "(%s) and not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)",
 			    pr->currentfilter, myaddress, peeraddress,
 			    myctrlport, peerctrlport, myaddress, peeraddress,
@@ -1815,7 +1819,7 @@ static int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)
 			 * We have no current filter; construct a filter to
 			 * filter out this rpcap session.
 			 */
-			if (pcap_asprintf(&newfilter,
+			if (pcapint_asprintf(&newfilter,
 			    "not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)",
 			    myaddress, peeraddress, myctrlport, peerctrlport,
 			    myaddress, peeraddress, mydataport) == -1)
@@ -1867,7 +1871,7 @@ static int pcap_setsampling_remote(pcap_t *fp)
 	struct rpcap_header header;		/* To keep the reply message */
 	struct rpcap_sampling *sampling_pars;	/* Structure that is needed to send sampling parameters to the remote host */
 
-	/* If no samping is requested, return 'ok' */
+	/* If no sampling is requested, return 'ok' */
 	if (fp->rmt_samp.method == PCAP_SAMP_NOSAMP)
 		return 0;
 
@@ -1967,7 +1971,7 @@ static int pcap_setsampling_remote(pcap_t *fp)
  * \return '0' if everything is fine, '-1' for an error.  For errors,
  * an error message string is returned in the 'errbuf' variable.
  */
-static int rpcap_doauth(SOCKET sockctrl, SSL *ssl, uint8 *ver,
+static int rpcap_doauth(PCAP_SOCKET sockctrl, SSL *ssl, uint8 *ver,
     int *byte_swapped, struct pcap_rmtauth *auth, char *errbuf)
 {
 	char sendbuf[RPCAP_NETBUF_SIZE];	/* temporary buffer in which data that has to be sent is buffered */
@@ -2093,7 +2097,7 @@ static int rpcap_doauth(SOCKET sockctrl, SSL *ssl, uint8 *ver,
 		{
 			/* No - discard it and fail. */
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
-			    "Authenticaton reply from server is too short");
+			    "Authentication reply from server is too short");
 			(void)rpcap_discard(sockctrl, ssl, plen, NULL);
 			return -1;
 		}
@@ -2118,7 +2122,7 @@ static int rpcap_doauth(SOCKET sockctrl, SSL *ssl, uint8 *ver,
 			 * Discard it and fail.
 			 */
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
-			    "Authenticaton reply from server is too short");
+			    "Authentication reply from server is too short");
 			(void)rpcap_discard(sockctrl, ssl, plen, NULL);
 			return -1;
 		}
@@ -2258,7 +2262,7 @@ pcap_setnonblock_rpcap(pcap_t *p, int nonblock _U_)
 
 static int
 rpcap_setup_session(const char *source, struct pcap_rmtauth *auth,
-    int *activep, SOCKET *sockctrlp, uint8 *uses_sslp, SSL **sslp,
+    int *activep, PCAP_SOCKET *sockctrlp, uint8 *uses_sslp, SSL **sslp,
     int rmt_flags, uint8 *protocol_versionp, int *byte_swappedp,
     char *host, char *port, char *iface, char *errbuf)
 {
@@ -2271,7 +2275,7 @@ rpcap_setup_session(const char *source, struct pcap_rmtauth *auth,
 	 * You must have a valid source string even if we're in active mode,
 	 * because otherwise the call to the following function will fail.
 	 */
-	if (pcap_parsesrcstr_ex(source, &type, host, port, iface, uses_sslp,
+	if (pcapint_parsesrcstr_ex(source, &type, host, port, iface, uses_sslp,
 	    errbuf) == -1)
 		return -1;
 
@@ -2337,16 +2341,16 @@ rpcap_setup_session(const char *source, struct pcap_rmtauth *auth,
 		if (port[0] == 0)
 		{
 			/* the user chose not to specify the port */
-			if (sock_initaddress(host, RPCAP_DEFAULT_NETPORT,
-			    &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
-				return -1;
+			addrinfo = sock_initaddress(host, RPCAP_DEFAULT_NETPORT,
+			    &hints, errbuf, PCAP_ERRBUF_SIZE);
 		}
 		else
 		{
-			if (sock_initaddress(host, port, &hints, &addrinfo,
-			    errbuf, PCAP_ERRBUF_SIZE) == -1)
-				return -1;
+			addrinfo = sock_initaddress(host, port, &hints,
+			    errbuf, PCAP_ERRBUF_SIZE);
 		}
+		if (addrinfo == NULL)
+			return -1;
 
 		if ((*sockctrlp = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0,
 		    errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
@@ -2441,7 +2445,7 @@ pcap_t *pcap_open_rpcap(const char *source, int snaplen, int flags, int read_tim
 	char *source_str;
 	struct pcap_rpcap *pr;		/* structure used when doing a remote live capture */
 	char host[PCAP_BUF_SIZE], ctrlport[PCAP_BUF_SIZE], iface[PCAP_BUF_SIZE];
-	SOCKET sockctrl;
+	PCAP_SOCKET sockctrl;
 	SSL *ssl = NULL;
 	uint8 protocol_version;			/* negotiated protocol version */
 	int byte_swapped;			/* server is known to be byte-swapped */
@@ -2461,7 +2465,7 @@ pcap_t *pcap_open_rpcap(const char *source, int snaplen, int flags, int read_tim
 	}
 	source_str = strdup(source);
 	if (source_str == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return NULL;
 	}
@@ -2613,7 +2617,7 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 {
 	uint8 protocol_version;		/* protocol version */
 	int byte_swapped;		/* Server byte order is swapped from ours */
-	SOCKET sockctrl;		/* socket descriptor of the control connection */
+	PCAP_SOCKET sockctrl;		/* socket descriptor of the control connection */
 	SSL *ssl = NULL;		/* optional SSL handler for sockctrl */
 	uint32 plen;
 	struct rpcap_header header;	/* structure that keeps the general header of the rpcap protocol */
@@ -2681,7 +2685,7 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 		dev = (pcap_if_t *)malloc(sizeof(pcap_if_t));
 		if (dev == NULL)
 		{
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc() failed");
 			goto error;
 		}
@@ -2725,14 +2729,14 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 			tmpstring[findalldevs_if.namelen] = 0;
 
 			/* Create the new device identifier */
-			if (pcap_createsrcstr_ex(tmpstring2, PCAP_SRC_IFREMOTE,
+			if (pcapint_createsrcstr_ex(tmpstring2, PCAP_SRC_IFREMOTE,
 			    host, port, tmpstring, uses_ssl, errbuf) == -1)
 				goto error;
 
 			dev->name = strdup(tmpstring2);
 			if (dev->name == NULL)
 			{
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
 				goto error;
 			}
@@ -2753,11 +2757,11 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 
 			tmpstring[findalldevs_if.desclen] = 0;
 
-			if (pcap_asprintf(&dev->description,
+			if (pcapint_asprintf(&dev->description,
 			    "%s '%s' %s %s", PCAP_TEXT_SOURCE_ADAPTER,
 			    tmpstring, PCAP_TEXT_SOURCE_ON_REMOTE_HOST, host) == -1)
 			{
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
 				goto error;
 			}
@@ -2783,7 +2787,7 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 			addr = (struct pcap_addr *) malloc(sizeof(struct pcap_addr));
 			if (addr == NULL)
 			{
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
 				goto error;
 			}
@@ -2793,26 +2797,26 @@ pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_i
 			addr->broadaddr = NULL;
 			addr->dstaddr = NULL;
 
-			if (rpcap_deseraddr(&ifaddr.addr,
-				(struct sockaddr_storage **) &addr->addr, errbuf) == -1)
+			if (rpcap_deseraddr(&ifaddr.addr, &addr->addr,
+				errbuf) == -1)
 			{
 				freeaddr(addr);
 				goto error;
 			}
-			if (rpcap_deseraddr(&ifaddr.netmask,
-				(struct sockaddr_storage **) &addr->netmask, errbuf) == -1)
+			if (rpcap_deseraddr(&ifaddr.netmask, &addr->netmask,
+				errbuf) == -1)
 			{
 				freeaddr(addr);
 				goto error;
 			}
-			if (rpcap_deseraddr(&ifaddr.broadaddr,
-				(struct sockaddr_storage **) &addr->broadaddr, errbuf) == -1)
+			if (rpcap_deseraddr(&ifaddr.broadaddr, &addr->broadaddr,
+				errbuf) == -1)
 			{
 				freeaddr(addr);
 				goto error;
 			}
-			if (rpcap_deseraddr(&ifaddr.dstaddr,
-				(struct sockaddr_storage **) &addr->dstaddr, errbuf) == -1)
+			if (rpcap_deseraddr(&ifaddr.dstaddr, &addr->dstaddr,
+				errbuf) == -1)
 			{
 				freeaddr(addr);
 				goto error;
@@ -2917,14 +2921,14 @@ error_nodiscard:
  * to implement; we provide some APIs for it that work only with rpcap.
  */
 
-SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)
+PCAP_SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)
 {
 	/* socket-related variables */
 	struct addrinfo hints;			/* temporary struct to keep settings needed to open the new socket */
 	struct addrinfo *addrinfo;		/* keeps the addrinfo chain; required to open a new socket */
 	struct sockaddr_storage from;	/* generic sockaddr_storage variable */
 	socklen_t fromlen;				/* keeps the length of the sockaddr_storage variable */
-	SOCKET sockctrl;				/* keeps the main socket identifier */
+	PCAP_SOCKET sockctrl;			/* keeps the main socket identifier */
 	SSL *ssl = NULL;				/* Optional SSL handler for sockctrl */
 	uint8 protocol_version;			/* negotiated protocol version */
 	int byte_swapped;			/* 1 if server byte order is known to be the reverse of ours */
@@ -2942,29 +2946,29 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 	/* Warning: this call can be the first one called by the user. */
 	/* For this reason, we have to initialize the Winsock support. */
 	if (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)
-		return (SOCKET)-1;
+		return (PCAP_SOCKET)-1;
 
 	/* Do the work */
 	if ((port == NULL) || (port[0] == 0))
 	{
-		if (sock_initaddress(address, RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
-		{
-			return (SOCKET)-2;
-		}
+		addrinfo = sock_initaddress(address,
+		    RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, errbuf,
+		    PCAP_ERRBUF_SIZE);
 	}
 	else
 	{
-		if (sock_initaddress(address, port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
-		{
-			return (SOCKET)-2;
-		}
+		addrinfo = sock_initaddress(address, port, &hints, errbuf,
+		    PCAP_ERRBUF_SIZE);
+	}
+	if (addrinfo == NULL)
+	{
+		return (PCAP_SOCKET)-2;
 	}
-
 
 	if ((sockmain = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
 	{
 		freeaddrinfo(addrinfo);
-		return (SOCKET)-2;
+		return (PCAP_SOCKET)-2;
 	}
 	freeaddrinfo(addrinfo);
 
@@ -2981,7 +2985,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 	if (sockctrl == INVALID_SOCKET)
 	{
 		sock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE, "accept() failed");
-		return (SOCKET)-2;
+		return (PCAP_SOCKET)-2;
 	}
 
 	/* Promote to SSL early before any error message may be sent */
@@ -2992,12 +2996,12 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 		if (! ssl)
 		{
 			sock_close(sockctrl, NULL, 0);
-			return (SOCKET)-1;
+			return (PCAP_SOCKET)-1;
 		}
 #else
 		snprintf(errbuf, PCAP_ERRBUF_SIZE, "No TLS support");
 		sock_close(sockctrl, NULL, 0);
-		return (SOCKET)-1;
+		return (PCAP_SOCKET)-1;
 #endif
 	}
 
@@ -3016,11 +3020,11 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 		}
 #endif
 		sock_close(sockctrl, NULL, 0);
-		return (SOCKET)-1;
+		return (PCAP_SOCKET)-1;
 	}
 
 	/* checks if the connecting host is among the ones allowed */
-	if (sock_check_hostlist((char *)hostlist, RPCAP_HOSTLIST_SEP, &from, errbuf, PCAP_ERRBUF_SIZE) < 0)
+	if (sock_check_hostlist(hostlist, RPCAP_HOSTLIST_SEP, &from, errbuf, PCAP_ERRBUF_SIZE) < 0)
 	{
 		rpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
 #ifdef HAVE_OPENSSL
@@ -3032,7 +3036,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 		}
 #endif
 		sock_close(sockctrl, NULL, 0);
-		return (SOCKET)-1;
+		return (PCAP_SOCKET)-1;
 	}
 
 	/*
@@ -3052,7 +3056,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 		}
 #endif
 		sock_close(sockctrl, NULL, 0);
-		return (SOCKET)-3;
+		return (PCAP_SOCKET)-3;
 	}
 
 	/* Checks that this host does not already have a cntrl connection in place */
@@ -3085,7 +3089,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 
 	if (temp == NULL)
 	{
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc() failed");
 		rpcap_senderror(sockctrl, ssl, protocol_version, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
 #ifdef HAVE_OPENSSL
@@ -3097,7 +3101,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 		}
 #endif
 		sock_close(sockctrl, NULL, 0);
-		return (SOCKET)-1;
+		return (PCAP_SOCKET)-1;
 	}
 
 	memcpy(&temp->host, &from, fromlen);
@@ -3110,7 +3114,7 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha
 	return sockctrl;
 }
 
-SOCKET pcap_remoteact_accept(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)
+PCAP_SOCKET pcap_remoteact_accept(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)
 {
 	return pcap_remoteact_accept_ex(address, port, hostlist, connectinghost, auth, 0, errbuf);
 }
@@ -3119,7 +3123,6 @@ int pcap_remoteact_close(const char *host, char *errbuf)
 {
 	struct activehosts *temp, *prev;	/* temp var needed to scan the host list chain */
 	struct addrinfo hints, *addrinfo, *ai_next;	/* temp var needed to translate between hostname to its address */
-	int retval;
 
 	temp = activeHosts;
 	prev = NULL;
@@ -3130,9 +3133,9 @@ int pcap_remoteact_close(const char *host, char *errbuf)
 	hints.ai_family = PF_UNSPEC;
 	hints.ai_socktype = SOCK_STREAM;
 
-	retval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,
+	addrinfo = sock_initaddress(host, NULL, &hints, errbuf,
 	    PCAP_ERRBUF_SIZE);
-	if (retval != 0)
+	if (addrinfo == NULL)
 	{
 		return -1;
 	}
@@ -3287,7 +3290,7 @@ int pcap_remoteact_list(char *hostlist, char sep, int size, char *errbuf)
 			return -1;
 		}
 
-		pcap_strlcat(hostlist, hoststr, PCAP_ERRBUF_SIZE);
+		pcapint_strlcat(hostlist, hoststr, PCAP_ERRBUF_SIZE);
 		hostlist[len - 1] = sep;
 		hostlist[len] = 0;
 
@@ -3300,7 +3303,7 @@ int pcap_remoteact_list(char *hostlist, char sep, int size, char *errbuf)
 /*
  * Receive the header of a message.
  */
-static int rpcap_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *header, char *errbuf)
+static int rpcap_recv_msg_header(PCAP_SOCKET sock, SSL *ssl, struct rpcap_header *header, char *errbuf)
 {
 	int nrecv;
 
@@ -3320,7 +3323,7 @@ static int rpcap_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *hea
  * Make sure the protocol version of a received message is what we were
  * expecting.
  */
-static int rpcap_check_msg_ver(SOCKET sock, SSL *ssl, uint8 expected_ver, struct rpcap_header *header, char *errbuf)
+static int rpcap_check_msg_ver(PCAP_SOCKET sock, SSL *ssl, uint8 expected_ver, struct rpcap_header *header, char *errbuf)
 {
 	/*
 	 * Did the server specify the version we negotiated?
@@ -3351,7 +3354,7 @@ static int rpcap_check_msg_ver(SOCKET sock, SSL *ssl, uint8 expected_ver, struct
  * Check the message type of a received message, which should either be
  * the expected message type or RPCAP_MSG_ERROR.
  */
-static int rpcap_check_msg_type(SOCKET sock, SSL *ssl, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf)
+static int rpcap_check_msg_type(PCAP_SOCKET sock, SSL *ssl, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf)
 {
 	const char *request_type_string;
 	const char *msg_type_string;
@@ -3421,7 +3424,7 @@ static int rpcap_check_msg_type(SOCKET sock, SSL *ssl, uint8 request_type, struc
 /*
  * Receive and process the header of a message.
  */
-static int rpcap_process_msg_header(SOCKET sock, SSL *ssl, uint8 expected_ver, uint8 request_type, struct rpcap_header *header, char *errbuf)
+static int rpcap_process_msg_header(PCAP_SOCKET sock, SSL *ssl, uint8 expected_ver, uint8 request_type, struct rpcap_header *header, char *errbuf)
 {
 	uint16 errcode;
 
@@ -3453,7 +3456,7 @@ static int rpcap_process_msg_header(SOCKET sock, SSL *ssl, uint8 expected_ver, u
  * Returns 0 on success, logs a message and returns -1 on a network
  * error.
  */
-static int rpcap_recv(SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32 *plen, char *errbuf)
+static int rpcap_recv(PCAP_SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32 *plen, char *errbuf)
 {
 	int nread;
 
@@ -3476,7 +3479,7 @@ static int rpcap_recv(SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32
 /*
  * This handles the RPCAP_MSG_ERROR message.
  */
-static void rpcap_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen, char *remote_errbuf)
+static void rpcap_msg_err(PCAP_SOCKET sockctrl, SSL *ssl, uint32 plen, char *remote_errbuf)
 {
 	char errbuf[PCAP_ERRBUF_SIZE];
 
@@ -3507,7 +3510,7 @@ static void rpcap_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen, char *remote_e
 		 * If we're not in UTF-8 mode, convert it to the local
 		 * code page.
 		 */
-		if (!pcap_utf_8_mode)
+		if (!pcapint_utf_8_mode)
 			utf_8_to_acp_truncated(remote_errbuf);
 #endif
 
@@ -3547,7 +3550,7 @@ static void rpcap_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen, char *remote_e
  * Returns 0 on success, logs a message and returns -1 on a network
  * error.
  */
-static int rpcap_discard(SOCKET sock, SSL *ssl, uint32 len, char *errbuf)
+static int rpcap_discard(PCAP_SOCKET sock, SSL *ssl, uint32 len, char *errbuf)
 {
 	if (len != 0)
 	{
diff --git a/pcap-savefile.manfile.in b/pcap-savefile.manfile.in
index a7ae9afb..e903ba81 100644
--- a/pcap-savefile.manfile.in
+++ b/pcap-savefile.manfile.in
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP-SAVEFILE @MAN_FILE_FORMATS@ "24 April 2020"
+.TH PCAP-SAVEFILE @MAN_FILE_FORMATS@ "16 Aug 2023"
 .SH NAME
 pcap-savefile \- libpcap savefile format
 .SH DESCRIPTION
@@ -41,13 +41,13 @@ Magic number
 _
 Major version	Minor version
 _
-Time zone offset
+Reserved1
 _
-Time stamp accuracy
+Reserved2
 _
 Snapshot length
 _
-Link-layer header type
+Link-layer header type and additional information
 .TE
 .RE
 .PP
@@ -80,10 +80,15 @@ A 2-byte file format major version number; the current version number is
 A 2-byte file format minor version number; the current version number is
 4.
 .IP
-A 4-byte time zone offset; this is always 0.
+A 4-byte not used - SHOULD be filled with 0 by pcap file writers, and MUST
+be ignored by pcap file readers.  This value was documented by some older
+implementations as "gmt to local correction" or "time zone offset".
+Some older pcap file writers stored non-zero values in this field.
 .IP
-A 4-byte number giving the accuracy of time stamps in the file; this is
-always 0.
+A 4-byte not used - SHOULD be filled with 0 by pcap file writers, and MUST
+be ignored by pcap file readers.  This value was documented by some older
+implementations as "accuracy of timestamps".  Some older pcap file
+writers stored non-zero values in this field.
 .IP
 A 4-byte number giving the "snapshot length" of the capture; packets
 longer than the snapshot length are truncated to the snapshot length, so
@@ -95,12 +100,53 @@ bytes of a packet longer than
 .I N
 bytes will be saved in the capture.
 .IP
-a 4-byte number giving the link-layer header type for packets in the
-capture; see
+A 4-byte number giving the link-layer header type for packets in the
+capture and optional additional information.
+.IP
+This format of this field is:
+.PP
+.nf
+                     1                   2                   3
+ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+|FCS len|R|P|     Reserved3     |        Link-layer type        |
++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+.fi
+.IP
+The field is shown as if it were in the byte order of the host reading
+or writing the file, with bit 0 being the most-significant bit of the
+field and bit 31 being the least-significant bit of the field.
+.IP
+Link-layer type (16 bits):
+A 16-bit value giving the link-layer header type for packets in the file;
+see
 .BR pcap-linktype (@MAN_MISC_INFO@)
 for the
 .B LINKTYPE_
 values that can appear in this field.
+.IP
+Reserved3 (10 bits):
+not used - MUST be set to zero by pcap writers, and MUST NOT be
+interpreted by pcap readers; a reader SHOULD treat a non-zero value as
+an error.
+.IP
+P (1 bit):
+A bit that, if set, indicates that the Frame Check Sequence (FCS)
+length value is present and, if not set, indicates that the FCS value is
+not present.
+.IP
+R (1 bit):
+not used - MUST be set to zero by pcap writers, and MUST NOT be
+interpreted by pcap readers; a reader SHOULD treat a non-zero value as
+an error.
+.IP
+FCS len (4 bits):
+A 4-bit unsigned value giving the number of 16-bit (2-octet) words
+of FCS that are appended to each packet, if the P bit is set; if the P
+bit is not set, and the FCS length is not indicated by the link-layer
+type value, the FCS length is unknown.  The valid values of the FCS len
+field are between 0 and 15; Ethernet, for example, would have an FCS
+length value of 2, corresponding to a 4-octet FCS.
 .PP
 Following the per-file header are zero or more packets; each packet
 begins with a per-packet header, which is immediately followed by the
diff --git a/pcap-septel.c b/pcap-septel.c
index 6d1d9047..35f5ec54 100644
--- a/pcap-septel.c
+++ b/pcap-septel.c
@@ -5,9 +5,7 @@
  * (+961 3 485243)
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>
 
@@ -124,7 +122,7 @@ loop:
         caplen = packet_len;
       }
       /* Run the packet filter if there is one. */
-      if ((p->fcode.bf_insns == NULL) || pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {
+      if ((p->fcode.bf_insns == NULL) || pcapint_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {
 
 
         /*  get a time stamp , consisting of :
@@ -171,7 +169,7 @@ loop:
 static int
 septel_inject(pcap_t *handle, const void *buf _U_, int size _U_)
 {
-  pcap_strlcpy(handle->errbuf, "Sending packets isn't supported on Septel cards",
+  pcapint_strlcpy(handle->errbuf, "Sending packets isn't supported on Septel cards",
           PCAP_ERRBUF_SIZE);
   return (-1);
 }
@@ -207,7 +205,7 @@ static pcap_t *septel_activate(pcap_t* handle) {
 
   handle->read_op = septel_read;
   handle->inject_op = septel_inject;
-  handle->setfilter_op = install_bpf_program;
+  handle->setfilter_op = pcapint_install_bpf_program;
   handle->set_datalink_op = NULL; /* can't change data link type */
   handle->getnonblock_op = septel_getnonblock;
   handle->setnonblock_op = septel_setnonblock;
@@ -267,7 +265,7 @@ septel_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
   /*
    * XXX - do the notions of "up", "running", or "connected" apply here?
    */
-  if (add_dev(devlistp,"septel",0,"Intel/Septel device",errbuf) == NULL)
+  if (pcapint_add_dev(devlistp,"septel",0,"Intel/Septel device",errbuf) == NULL)
     return -1;
   return 0;
 }
@@ -303,7 +301,7 @@ septel_setnonblock(pcap_t *p, int nonblock _U_)
  * There are no regular interfaces, just Septel interfaces.
  */
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
   return (0);
 }
@@ -312,7 +310,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
  * Attempts to open a regular interface fail.
  */
 pcap_t *
-pcap_create_interface(const char *device, char *errbuf)
+pcapint_create_interface(const char *device, char *errbuf)
 {
   snprintf(errbuf, PCAP_ERRBUF_SIZE,
                 "This version of libpcap only supports Septel cards");
diff --git a/pcap-sita.c b/pcap-sita.c
index 70a36471..8cee5740 100644
--- a/pcap-sita.c
+++ b/pcap-sita.c
@@ -24,9 +24,7 @@
  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stdio.h>
 #include <string.h>
@@ -42,7 +40,7 @@
 
 #include "pcap-sita.h"
 
-	/* non-configureable manifests follow */
+	/* non-configurable manifests follow */
 
 #define IOP_SNIFFER_PORT	49152			/* TCP port on the IOP used for 'distributed pcap' usage */
 #define MAX_LINE_SIZE		255				/* max size of a buffer/line in /etc/hosts we allow */
@@ -302,7 +300,7 @@ int acn_parse_hosts_file(char *errbuf) {				/* returns: -1 = error, 0 = OK */
 		}
 		ptr2 = strdup(ptr);					/* copy the IP address into our malloc'ed memory */
 		if (ptr2 == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			continue;
 		}
@@ -372,7 +370,7 @@ static void pcap_cleanup_acn(pcap_t *handle) {
 	close_with_IOP(chassis, geoslot, LIVE);
 	if (u)
 		u->first_time = 0;
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 }
 
 static void send_to_fd(int fd, int len, unsigned char *str) {
@@ -584,7 +582,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 			ptr = u->imsg;													/* point to the start of the msg for this IOP */
 			while (ptr < (u->imsg + u->len)) {
 				if ((iff = malloc(sizeof(pcap_if_t))) == NULL) {
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno, "malloc");
 					return -1;
 				}
@@ -594,7 +592,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 
 				if (*ptr) {													/* if there is a count for the name */
 					if ((iff->name = malloc(*ptr + 1)) == NULL) {			/* get that amount of space */
-						pcap_fmt_errmsg_for_errno(errbuf,
+						pcapint_fmt_errmsg_for_errno(errbuf,
 						    PCAP_ERRBUF_SIZE, errno,
 						    "malloc");
 						return -1;
@@ -607,7 +605,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 
 				if (*ptr) {													/* if there is a count for the description */
 					if ((iff->description = malloc(*ptr + 1)) == NULL) {	/* get that amount of space */
-						pcap_fmt_errmsg_for_errno(errbuf,
+						pcapint_fmt_errmsg_for_errno(errbuf,
 						    PCAP_ERRBUF_SIZE, errno,
 						    "malloc");
 						return -1;
@@ -629,7 +627,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 				prev_addr = 0;
 				while (address_count--) {
 					if ((addr = malloc(sizeof(pcap_addr_t))) == NULL) {
-						pcap_fmt_errmsg_for_errno(errbuf,
+						pcapint_fmt_errmsg_for_errno(errbuf,
 						    PCAP_ERRBUF_SIZE, errno,
 						    "malloc");
 						return -1;
@@ -639,7 +637,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 					if (prev_addr) prev_addr->next = addr;							/* insert a forward link */
 					if (*ptr) {														/* if there is a count for the address */
 						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {		/* get that amount of space */
-							pcap_fmt_errmsg_for_errno(errbuf,
+							pcapint_fmt_errmsg_for_errno(errbuf,
 							    PCAP_ERRBUF_SIZE,
 							    errno, "malloc");
 							return -1;
@@ -653,7 +651,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 					ptr++;													/* then forwards one more for the 'length of the address' field */
 					if (*ptr) {												/* process any netmask */
 						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
-							pcap_fmt_errmsg_for_errno(errbuf,
+							pcapint_fmt_errmsg_for_errno(errbuf,
 							    PCAP_ERRBUF_SIZE,
 							    errno, "malloc");
 							return -1;
@@ -669,7 +667,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 					ptr++;
 					if (*ptr) {												/* process any broadcast address */
 						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
-							pcap_fmt_errmsg_for_errno(errbuf,
+							pcapint_fmt_errmsg_for_errno(errbuf,
 							    PCAP_ERRBUF_SIZE,
 							    errno, "malloc");
 							return -1;
@@ -685,7 +683,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 					ptr++;
 					if (*ptr) {												/* process any destination address */
 						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
-							pcap_fmt_errmsg_for_errno(errbuf,
+							pcapint_fmt_errmsg_for_errno(errbuf,
 							    PCAP_ERRBUF_SIZE,
 							    errno, "malloc");
 							return -1;
@@ -706,7 +704,7 @@ static int process_client_data (char *errbuf) {								/* returns: -1 = error, 0
 				newname = translate_IOP_to_pcap_name(u, iff->name, interfaceType);		/* add a translation entry and get a point to the mangled name */
 				bigger_buffer = realloc(iff->name, strlen(newname) + 1);
 				if (bigger_buffer == NULL) {	/* we now re-write the name stored in the interface list */
-					pcap_fmt_errmsg_for_errno(errbuf,
+					pcapint_fmt_errmsg_for_errno(errbuf,
 					    PCAP_ERRBUF_SIZE, errno, "realloc");
 					return -1;
 				}
@@ -841,7 +839,7 @@ static int acn_open_live(const char *name, char *errbuf, int *linktype) {		/* re
 	iface_t		*p;
 	pcap_if_list_t	devlist;
 
-	pcap_platform_finddevs(&devlist, errbuf);
+	pcapint_platform_finddevs(&devlist, errbuf);
 	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {										/* scan the table... */
 		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
 			u = &units[chassis][geoslot];
@@ -885,7 +883,7 @@ static void acn_start_monitor(int fd, int snaplen, int timeout, int promiscuous,
 }
 
 static int pcap_inject_acn(pcap_t *p, const void *buf _U_, int size _U_) {
-	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on ACN adapters",
+	pcapint_strlcpy(p->errbuf, "Sending packets isn't supported on ACN adapters",
 	    PCAP_ERRBUF_SIZE);
 	return (-1);
 }
@@ -994,8 +992,8 @@ static int pcap_activate_sita(pcap_t *handle) {
 	handle->setfilter_op = pcap_setfilter_acn;
 	handle->setdirection_op = NULL; /* Not implemented */
 	handle->set_datalink_op = NULL;	/* can't change data link type */
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
 	handle->cleanup_op = pcap_cleanup_acn;
 	handle->read_op = pcap_read_acn;
 	handle->stats_op = pcap_stats_acn;
@@ -1023,7 +1021,7 @@ static int pcap_activate_sita(pcap_t *handle) {
 
 	handle->buffer	 = malloc(handle->bufsize + handle->offset);
 	if (!handle->buffer) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		pcap_cleanup_acn(handle);
 		return PCAP_ERROR;
@@ -1038,7 +1036,7 @@ static int pcap_activate_sita(pcap_t *handle) {
 	return 0;
 }
 
-pcap_t *pcap_create_interface(const char *device _U_, char *ebuf) {
+pcap_t *pcapint_create_interface(const char *device _U_, char *ebuf) {
 	pcap_t *p;
 
 	p = PCAP_CREATE_COMMON(ebuf, struct pcap_sita);
@@ -1049,7 +1047,7 @@ pcap_t *pcap_create_interface(const char *device _U_, char *ebuf) {
 	return (p);
 }
 
-int pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf) {
+int pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf) {
 
 	//printf("pcap_findalldevs()\n");				// fulko
 
@@ -1057,7 +1055,7 @@ int pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf) {
 	strcpy(errbuf, "");
 	if (acn_parse_hosts_file(errbuf))							/* scan the hosts file for potential IOPs */
 		{
-		//printf("pcap_findalldevs() returning BAD after parsehosts\n");				// fulko
+		//printf("pcap_findalldevs() returning BAD after parse_hosts\n");				// fulko
 		return -1;
 		}
 	//printf("pcap_findalldevs() got hostlist now finding devs\n");				// fulko
diff --git a/pcap-sita.html b/pcap-sita.html
index 04f51292..6afad09c 100644
--- a/pcap-sita.html
+++ b/pcap-sita.html
@@ -597,7 +597,7 @@ A { text-decoration:none }
 					<TR>
 						<TD VALIGN=TOP>direction</TD>
 						<TD VALIGN=TOP ALIGN=CENTER>1</TD>
-						<TD VALIGN=TOP>A flag indicating the direction of traffic that should be captuted [both(0) / in(1) / out(2)]</TD>
+						<TD VALIGN=TOP>A flag indicating the direction of traffic that should be captured [both(0) / in(1) / out(2)]</TD>
 					</TR>
 				</TABLE>
 			</TD>
@@ -803,8 +803,6 @@ A { text-decoration:none }
 					this is also known as a UN*X time_t. You can use the ANSI C
 					<em>time()</em> function from <em>time.h</em> to get this value,
 					but you might use a more optimized way to get this timestamp value.
-					If this timestamp isn't based on GMT (UTC), use <em>thiszone</em>
-					from the global header for adjustments.</TD>
 			</TR>
 			<TR>
 				<TD VALIGN=TOP>tv_usec</TD>
diff --git a/pcap-snf.c b/pcap-snf.c
index fe9cc9c8..272f7df6 100644
--- a/pcap-snf.c
+++ b/pcap-snf.c
@@ -1,6 +1,4 @@
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #ifndef _WIN32
 #include <sys/param.h>
@@ -55,7 +53,7 @@ snf_pcap_stats(pcap_t *p, struct pcap_stat *ps)
 	int rc;
 
 	if ((rc = snf_ring_getstats(snfps->snf_ring, &stats))) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    rc, "snf_get_stats");
 		return -1;
 	}
@@ -76,7 +74,7 @@ snf_platform_cleanup(pcap_t *p)
 #endif
 	snf_ring_close(ps->snf_ring);
 	snf_close(ps->snf_handle);
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 static int
@@ -181,7 +179,7 @@ snf_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 				continue;
 			}
 			else {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, err, "snf_read");
 				return -1;
 			}
@@ -192,7 +190,7 @@ snf_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 			caplen = p->snapshot;
 
 		if ((p->fcode.bf_insns == NULL) ||
-		     pcap_filter(p->fcode.bf_insns, req.pkt_addr, req.length, caplen)) {
+		     pcapint_filter(p->fcode.bf_insns, req.pkt_addr, req.length, caplen)) {
 			hdr.ts = snf_timestamp_to_timeval(req.timestamp, p->opt.tstamp_precision);
 			hdr.caplen = caplen;
 			hdr.len = req.length;
@@ -217,7 +215,7 @@ snf_inject(pcap_t *p, const void *buf _U_, int size _U_)
 	if (ps->snf_inj == NULL) {
 		rc = snf_inject_open(ps->snf_boardnum, 0, &ps->snf_inj);
 		if (rc) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    rc, "snf_inject_open");
 			return (-1);
 		}
@@ -228,12 +226,12 @@ snf_inject(pcap_t *p, const void *buf _U_, int size _U_)
 		return (size);
 	}
 	else {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    rc, "snf_inject_send");
 		return (-1);
 	}
 #else
-	pcap_strlcpy(p->errbuf, "Sending packets isn't supported with this snf version",
+	pcapint_strlcpy(p->errbuf, "Sending packets isn't supported with this snf version",
 	    PCAP_ERRBUF_SIZE);
 	return (-1);
 #endif
@@ -276,7 +274,7 @@ snf_activate(pcap_t* p)
 			flags, /* may want pshared */
 			&ps->snf_handle);
 	if (err != 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    err, "snf_open failed");
 		return -1;
 	}
@@ -286,7 +284,7 @@ snf_activate(pcap_t* p)
 	}
 	err = snf_ring_open_id(ps->snf_handle, ring_id, &ps->snf_ring);
 	if (err != 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    err, "snf_ring_open_id(ring=%d) failed", ring_id);
 		return -1;
 	}
@@ -309,7 +307,7 @@ snf_activate(pcap_t* p)
 
 	err = snf_start(ps->snf_handle);
 	if (err != 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    err, "snf_start failed");
 		return -1;
 	}
@@ -323,7 +321,7 @@ snf_activate(pcap_t* p)
 	p->linktype = DLT_EN10MB;
 	p->read_op = snf_read;
 	p->inject_op = snf_inject;
-	p->setfilter_op = install_bpf_program;
+	p->setfilter_op = pcapint_install_bpf_program;
 	p->setdirection_op = NULL; /* Not implemented.*/
 	p->set_datalink_op = snf_set_datalink;
 	p->getnonblock_op = snf_getnonblock;
@@ -358,7 +356,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 
 	if (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL)
 	{
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "snf_getifaddrs");
 		return (-1);
 	}
@@ -377,7 +375,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 		/*
 		 * Myricom SNF adapter ports may appear as regular
 		 * network interfaces, which would already have been
-		 * added to the list of adapters by pcap_platform_finddevs()
+		 * added to the list of adapters by pcapint_platform_finddevs()
 		 * if this isn't an SNF-only version of libpcap.
 		 *
 		 * Our create routine intercepts pcap_create() calls for
@@ -416,7 +414,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 		 * See if there's already an entry for the device
 		 * with the name ifa->snf_ifa_name.
 		 */
-		dev = find_dev(devlistp, ifa->snf_ifa_name);
+		dev = pcapint_find_dev(devlistp, ifa->snf_ifa_name);
 		if (dev != NULL) {
 			/*
 			 * Yes.  Update its description.
@@ -425,7 +423,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 
 			desc_str = strdup(desc);
 			if (desc_str == NULL) {
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "snf_findalldevs strdup");
 				return -1;
@@ -442,7 +440,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 			 * PCAP_IF_CONNECTION_STATUS_CONNECTED or
 			 * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?
 			 */
-			dev = add_dev(devlistp, ifa->snf_ifa_name, 0, desc,
+			dev = pcapint_add_dev(devlistp, ifa->snf_ifa_name, 0, desc,
 			    errbuf);
 			if (dev == NULL)
 				return -1;
@@ -457,14 +455,14 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 				 * to IPv4 address.
 				 */
 				addr.sin_family = AF_INET;
-				if (add_addr_to_dev(dev, &addr, sizeof(addr),
+				if (pcapint_add_addr_to_dev(dev, &addr, sizeof(addr),
 				    NULL, 0, NULL, 0, NULL, 0, errbuf) == -1)
 					return -1;
                         } else if (ret == -1) {
 				/*
 				 * Error.
 				 */
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "sinf_findalldevs inet_pton");
                                 return -1;
@@ -492,7 +490,7 @@ snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
 		 * "disconnected", as "is this plugged into a network?"
 		 * would be a per-port property.
 		 */
-		if (add_dev(devlistp, name,
+		if (pcapint_add_dev(devlistp, name,
 		    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, desc,
 		    errbuf) == NULL)
 			return (-1);
@@ -566,7 +564,7 @@ snf_create(const char *device, char *ebuf, int *is_ours)
 	 */
 	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
 	if (p->tstamp_precision_list == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
 		    "malloc");
 		pcap_close(p);
 		return NULL;
@@ -590,7 +588,7 @@ snf_create(const char *device, char *ebuf, int *is_ours)
  * There are no regular interfaces, just SNF interfaces.
  */
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
 	return (0);
 }
@@ -599,7 +597,7 @@ pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
  * Attempts to open a regular interface fail.
  */
 pcap_t *
-pcap_create_interface(const char *device, char *errbuf)
+pcapint_create_interface(const char *device, char *errbuf)
 {
 	snprintf(errbuf, PCAP_ERRBUF_SIZE,
 	    "This version of libpcap only supports SNF cards");
diff --git a/pcap-snit.c b/pcap-snit.c
index 3f4e69d7..377f70bf 100644
--- a/pcap-snit.c
+++ b/pcap-snit.c
@@ -23,9 +23,7 @@
  * This module now handles the STREAMS based NIT.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -129,7 +127,7 @@ pcap_read_snit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		if (cc < 0) {
 			if (errno == EWOULDBLOCK)
 				return (0);
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "pcap_read");
 			return (-1);
 		}
@@ -192,7 +190,7 @@ pcap_read_snit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		if (caplen > p->snapshot)
 			caplen = p->snapshot;
 
-		if (pcap_filter(p->fcode.bf_insns, cp, nlp->nh_pktlen, caplen)) {
+		if (pcapint_filter(p->fcode.bf_insns, cp, nlp->nh_pktlen, caplen)) {
 			struct pcap_pkthdr h;
 			h.ts = ntp->nh_timestamp;
 			h.len = nlp->nh_pktlen;
@@ -225,7 +223,7 @@ pcap_inject_snit(pcap_t *p, const void *buf, int size)
 	data.len = size;
 	ret = putmsg(p->fd, &ctl, &data);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -249,7 +247,7 @@ nit_setflags(pcap_t *p)
 		si.ic_len = sizeof(zero);
 		si.ic_dp = (char *)&zero;
 		if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "NIOCSCHUNK");
 			return (-1);
 		}
@@ -262,7 +260,7 @@ nit_setflags(pcap_t *p)
 		si.ic_len = sizeof(timeout);
 		si.ic_dp = (char *)&timeout;
 		if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "NIOCSTIME");
 			return (-1);
 		}
@@ -274,7 +272,7 @@ nit_setflags(pcap_t *p)
 	si.ic_len = sizeof(flags);
 	si.ic_dp = (char *)&flags;
 	if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "NIOCSFLAGS");
 		return (-1);
 	}
@@ -341,7 +339,7 @@ pcap_activate_snit(pcap_t *p)
 			    dev);
 		} else {
 			err = PCAP_ERROR;
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "%s", dev);
 		}
 		goto bad;
@@ -349,13 +347,13 @@ pcap_activate_snit(pcap_t *p)
 
 	/* arrange to get discrete messages from the STREAM and use NIT_BUF */
 	if (ioctl(fd, I_SRDOPT, (char *)RMSGD) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "I_SRDOPT");
 		err = PCAP_ERROR;
 		goto bad;
 	}
 	if (ioctl(fd, I_PUSH, "nbuf") < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "push nbuf");
 		err = PCAP_ERROR;
 		goto bad;
@@ -366,7 +364,7 @@ pcap_activate_snit(pcap_t *p)
 	si.ic_len = sizeof(chunksize);
 	si.ic_dp = (char *)&chunksize;
 	if (ioctl(fd, I_STR, (char *)&si) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "NIOCSCHUNK");
 		err = PCAP_ERROR;
 		goto bad;
@@ -384,7 +382,7 @@ pcap_activate_snit(pcap_t *p)
 		 * Is there one that means "that device doesn't support
 		 * STREAMS NIT"?
 		 */
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "NIOCBIND: %s", ifr.ifr_name);
 		err = PCAP_ERROR;
 		goto bad;
@@ -395,7 +393,7 @@ pcap_activate_snit(pcap_t *p)
 	si.ic_len = sizeof(p->snapshot);
 	si.ic_dp = (char *)&p->snapshot;
 	if (ioctl(fd, I_STR, (char *)&si) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "NIOCSSNAP");
 		err = PCAP_ERROR;
 		goto bad;
@@ -414,7 +412,7 @@ pcap_activate_snit(pcap_t *p)
 	p->bufsize = BUFSPACE;
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		err = PCAP_ERROR;
 		goto bad;
@@ -437,32 +435,33 @@ pcap_activate_snit(pcap_t *p)
 	 * Ethernet framing).
 	 */
 	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-	/*
-	 * If that fails, just leave the list empty.
-	 */
-	if (p->dlt_list != NULL) {
-		p->dlt_list[0] = DLT_EN10MB;
-		p->dlt_list[1] = DLT_DOCSIS;
-		p->dlt_count = 2;
+	if (p->dlt_list == NULL) {
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		    errno, "malloc");
+		err = PCAP_ERROR;
+		goto bad;
 	}
+	p->dlt_list[0] = DLT_EN10MB;
+	p->dlt_list[1] = DLT_DOCSIS;
+	p->dlt_count = 2;
 
 	p->read_op = pcap_read_snit;
 	p->inject_op = pcap_inject_snit;
-	p->setfilter_op = install_bpf_program;	/* no kernel filtering */
+	p->setfilter_op = pcapint_install_bpf_program;	/* no kernel filtering */
 	p->setdirection_op = NULL;	/* Not implemented. */
 	p->set_datalink_op = NULL;	/* can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_snit;
 
 	return (0);
  bad:
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 	return (err);
 }
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -496,9 +495,9 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
-	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
+	return (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
 	    get_if_flags));
 }
 
diff --git a/pcap-snoop.c b/pcap-snoop.c
index 2f44b1dd..84ddd9e9 100644
--- a/pcap-snoop.c
+++ b/pcap-snoop.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <sys/param.h>
 #include <sys/file.h>
@@ -95,7 +93,7 @@ again:
 		case EWOULDBLOCK:
 			return (0);			/* XXX */
 		}
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "read");
 		return (-1);
 	}
@@ -104,7 +102,7 @@ again:
 
 	/*
 	 * XXX - Sigh, snoop_packetlen is a 16 bit quantity.  If we
-	 * got a short length, but read a full sized snoop pakcet,
+	 * got a short length, but read a full sized snoop packet,
 	 * assume we overflowed and add back the 64K...
 	 */
 	if (cc == (p->snapshot + sizeof(struct snoopheader)) &&
@@ -126,7 +124,7 @@ again:
 	}
 
 	if (p->fcode.bf_insns == NULL ||
-	    pcap_filter(p->fcode.bf_insns, cp, datalen, caplen)) {
+	    pcapint_filter(p->fcode.bf_insns, cp, datalen, caplen)) {
 		struct pcap_pkthdr h;
 		++psn->stat.ps_recv;
 		h.ts.tv_sec = sh->snoop_timestamp.tv_sec;
@@ -150,7 +148,7 @@ pcap_inject_snoop(pcap_t *p, const void *buf, int size)
 	 */
 	ret = write(p->fd, buf, size);
 	if (ret == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "send");
 		return (-1);
 	}
@@ -167,7 +165,7 @@ pcap_stats_snoop(pcap_t *p, struct pcap_stat *ps)
 	rs = &rawstats;
 	memset(rs, 0, sizeof(*rs));
 	if (ioctl(p->fd, SIOCRAWSTATS, (char *)rs) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+		pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 		    errno, "SIOCRAWSTATS");
 		return (-1);
 	}
@@ -212,7 +210,7 @@ pcap_activate_snoop(pcap_t *p)
 
 	fd = socket(PF_RAW, SOCK_RAW, RAWPROTO_SNOOP);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "snoop socket");
 		goto bad;
 	}
@@ -228,13 +226,13 @@ pcap_activate_snoop(pcap_t *p)
 		 * they might be the same error, if they both end up
 		 * meaning "snoop doesn't know about that device".
 		 */
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "snoop bind");
 		goto bad;
 	}
 	memset(&sf, 0, sizeof(sf));
 	if (ioctl(fd, SIOCADDSNOOP, &sf) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCADDSNOOP");
 		goto bad;
 	}
@@ -283,14 +281,14 @@ pcap_activate_snoop(pcap_t *p)
 		 * Classical IP devices?
 		 */
 		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-		/*
-		 * If that fails, just leave the list empty.
-		 */
-		if (p->dlt_list != NULL) {
-			p->dlt_list[0] = DLT_EN10MB;
-			p->dlt_list[1] = DLT_DOCSIS;
-			p->dlt_count = 2;
+		if (p->dlt_list == NULL) {
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			    errno, "malloc");
+			goto bad;
 		}
+		p->dlt_list[0] = DLT_EN10MB;
+		p->dlt_list[1] = DLT_DOCSIS;
+		p->dlt_count = 2;
 	} else if (strncmp("ipg", p->opt.device, 3) == 0 ||
 		   strncmp("rns", p->opt.device, 3) == 0 ||	/* O2/200/2000 FDDI */
 		   strncmp("xpi", p->opt.device, 3) == 0) {
@@ -343,7 +341,7 @@ pcap_activate_snoop(pcap_t *p)
 	 */
 	(void)strncpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
 	if (ioctl(fd, SIOCGIFMTU, (char *)&ifr) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGIFMTU");
 		goto bad;
 	}
@@ -377,13 +375,13 @@ pcap_activate_snoop(pcap_t *p)
 	if (snooplen < 0)
 		snooplen = 0;
 	if (ioctl(fd, SIOCSNOOPLEN, &snooplen) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCSNOOPLEN");
 		goto bad;
 	}
 	v = 1;
 	if (ioctl(fd, SIOCSNOOPING, &v) < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCSNOOPING");
 		goto bad;
 	}
@@ -391,7 +389,7 @@ pcap_activate_snoop(pcap_t *p)
 	p->bufsize = 4096;				/* XXX */
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		goto bad;
 	}
@@ -403,21 +401,21 @@ pcap_activate_snoop(pcap_t *p)
 
 	p->read_op = pcap_read_snoop;
 	p->inject_op = pcap_inject_snoop;
-	p->setfilter_op = install_bpf_program;	/* no kernel filtering */
+	p->setfilter_op = pcapint_install_bpf_program;	/* no kernel filtering */
 	p->setdirection_op = NULL;	/* Not implemented. */
 	p->set_datalink_op = NULL;	/* can't change data link type */
-	p->getnonblock_op = pcap_getnonblock_fd;
-	p->setnonblock_op = pcap_setnonblock_fd;
+	p->getnonblock_op = pcapint_getnonblock_fd;
+	p->setnonblock_op = pcapint_setnonblock_fd;
 	p->stats_op = pcap_stats_snoop;
 
 	return (0);
  bad:
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 	return (PCAP_ERROR);
 }
 
 pcap_t *
-pcap_create_interface(const char *device _U_, char *ebuf)
+pcapint_create_interface(const char *device _U_, char *ebuf)
 {
 	pcap_t *p;
 
@@ -451,9 +449,9 @@ get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
 }
 
 int
-pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
+pcapint_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
 {
-	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
+	return (pcapint_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
 	    get_if_flags));
 }
 
diff --git a/pcap-tc.c b/pcap-tc.c
index 1d753b54..4c6599d2 100644
--- a/pcap-tc.c
+++ b/pcap-tc.c
@@ -29,9 +29,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap.h>
 #include <pcap-int.h>
@@ -288,34 +286,34 @@ TC_API_LOAD_STATUS LoadTcFunctions(void)
 
 		currentStatus = TC_API_CANNOT_LOAD;
 
-		g_TcFunctions.hTcApiDllHandle = pcap_load_code("TcApi.dll");
+		g_TcFunctions.hTcApiDllHandle = pcapint_load_code("TcApi.dll");
 		if (g_TcFunctions.hTcApiDllHandle == NULL)	break;
 
-		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcQueryPortList");
-		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcFreePortList");
+		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcQueryPortList");
+		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcFreePortList");
 
-		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatusGetString");
+		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatusGetString");
 
-		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetName");
-		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetDescription");
+		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetName");
+		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetDescription");
 
-		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceOpenByName");
-		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceClose");
-		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceSetFeature");
-		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryFeature");
-		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceReceivePackets");
-		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceGetReceiveWaitHandle");
-		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceTransmitPackets");
-		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryStatistics");
+		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceOpenByName");
+		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceClose");
+		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceSetFeature");
+		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryFeature");
+		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceReceivePackets");
+		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceGetReceiveWaitHandle");
+		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceTransmitPackets");
+		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryStatistics");
 
-		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCreate");
-		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferDestroy");
-		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferQueryNextPacket");
-		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCommitNextPacket");
+		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCreate");
+		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferDestroy");
+		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferQueryNextPacket");
+		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCommitNextPacket");
 
-		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsDestroy");
-		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsUpdate");
-		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsQueryValue");
+		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsDestroy");
+		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsUpdate");
+		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcapint_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsQueryValue");
 
 		if (   g_TcFunctions.QueryPortList == NULL
 			|| g_TcFunctions.FreePortList == NULL
@@ -419,7 +417,7 @@ TcFindAllDevs(pcap_if_list_t *devlist, char *errbuf)
 			dev = TcCreatePcapIfFromPort(pPorts[i]);
 
 			if (dev != NULL)
-				add_dev(devlist, dev->name, dev->flags, dev->description, errbuf);
+				pcapint_add_dev(devlist, dev->name, dev->flags, dev->description, errbuf);
 		}
 
 		if (numPorts > 0)
@@ -540,14 +538,14 @@ TcActivate(pcap_t *p)
 
 	p->linktype = DLT_EN10MB;
 	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
-	/*
-	 * If that fails, just leave the list empty.
-	 */
-	if (p->dlt_list != NULL) {
-		p->dlt_list[0] = DLT_EN10MB;
-		p->dlt_list[1] = DLT_PPI;
-		p->dlt_count = 2;
+	if (p->dlt_list == NULL)
+	{
+		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Error allocating memory");
+		return PCAP_ERROR;
 	}
+	p->dlt_list[0] = DLT_EN10MB;
+	p->dlt_list[1] = DLT_PPI;
+	p->dlt_count = 2;
 
 	/*
 	 * ignore promiscuous mode
@@ -610,7 +608,7 @@ TcActivate(pcap_t *p)
 	}
 
 	p->read_op = TcRead;
-	p->setfilter_op = install_bpf_program;
+	p->setfilter_op = pcapint_install_bpf_program;
 	p->setdirection_op = NULL;	/* Not implemented. */
 	p->set_datalink_op = TcSetDatalink;
 	p->getnonblock_op = TcGetNonBlock;
@@ -774,7 +772,7 @@ static void TcCleanup(pcap_t *p)
 		pt->PpiPacket = NULL;
 	}
 
-	pcap_cleanup_live_common(p);
+	pcapint_cleanup_live_common(p);
 }
 
 /* Send a packet to the network */
@@ -917,7 +915,7 @@ static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		/* No underlying filtering system. We need to filter on our own */
 		if (p->fcode.bf_insns)
 		{
-			filterResult = pcap_filter(p->fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);
+			filterResult = pcapint_filter(p->fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);
 
 			if (filterResult == 0)
 			{
diff --git a/pcap-tstamp.manmisc.in b/pcap-tstamp.manmisc.in
index eea8c1d2..2044be00 100644
--- a/pcap-tstamp.manmisc.in
+++ b/pcap-tstamp.manmisc.in
@@ -107,11 +107,12 @@ routine can be used after a
 call and before a
 .BR pcap_activate ()
 call to specify the type of time stamp to be used on the device.
-The time stamp types are listed here; the first value is the #define to
-use in code, the second value is the value returned by
+The time stamp types are listed here; the first value is the
+.B #define
+to use in code, the second value is the value returned by
 .BR pcap_tstamp_type_val_to_name (3PCAP)
 and accepted by
-.BR pcap_tstamp_type_name_to_val (3PCAP) .
+.BR pcap_tstamp_type_name_to_val (3PCAP).
 .RS 5
 .TP 5
 .BR PCAP_TSTAMP_HOST " - " host
diff --git a/pcap-usb-linux-common.c b/pcap-usb-linux-common.c
deleted file mode 100644
index fb4a8c19..00000000
--- a/pcap-usb-linux-common.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 1993, 1994, 1995, 1996, 1997
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that: (1) source code distributions
- * retain the above copyright notice and this paragraph in its entirety, (2)
- * distributions including binary code include the above copyright notice and
- * this paragraph in its entirety in the documentation or other materials
- * provided with the distribution, and (3) all advertising materials mentioning
- * features or use of this software display the following acknowledgement:
- * ``This product includes software developed by the University of California,
- * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
- * the University nor the names of its contributors may be used to endorse
- * or promote products derived from this software without specific prior
- * written permission.
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * pcap-usb-linux-common.c - common code for everything that needs to
- * deal with Linux USB captures.
- */
-
-#include "pcap/pcap.h"
-#include "pcap/usb.h"
-
-#include "pcap-usb-linux-common.h"
-
-/*
- * Compute, from the data provided by the Linux USB memory-mapped capture
- * mechanism, the amount of packet data that would have been provided
- * had the capture mechanism not chopped off any data at the end, if, in
- * fact, it did so.
- *
- * Set the "unsliced length" field of the packet header to that value.
- */
-void
-fix_linux_usb_mmapped_length(struct pcap_pkthdr *pkth, const u_char *bp)
-{
-	const pcap_usb_header_mmapped *hdr;
-	u_int bytes_left;
-
-	/*
-	 * All callers of this routine must ensure that pkth->caplen is
-	 * >= sizeof (pcap_usb_header_mmapped).
-	 */
-	bytes_left = pkth->caplen;
-	bytes_left -= sizeof (pcap_usb_header_mmapped);
-
-	hdr = (const pcap_usb_header_mmapped *) bp;
-	if (!hdr->data_flag && hdr->transfer_type == URB_ISOCHRONOUS &&
-	    hdr->event_type == URB_COMPLETE &&
-	    (hdr->endpoint_number & URB_TRANSFER_IN) &&
-	    pkth->len == sizeof(pcap_usb_header_mmapped) +
-	                 (hdr->ndesc * sizeof (usb_isodesc)) + hdr->urb_len) {
-		usb_isodesc *descs;
-		u_int pre_truncation_data_len, pre_truncation_len;
-
-		descs = (usb_isodesc *) (bp + sizeof(pcap_usb_header_mmapped));
-
-		/*
-		 * We have data (yes, data_flag is 0 if we *do* have data),
-		 * and this is a "this is complete" incoming isochronous
-		 * transfer event, and the length was calculated based
-		 * on the URB length.
-		 *
-		 * That's not correct, because the data isn't contiguous,
-		 * and the isochronous descriptos show how it's scattered.
-		 *
-		 * Find the end of the last chunk of data in the buffer
-		 * referred to by the isochronous descriptors; that indicates
-		 * how far into the buffer the data would have gone.
-		 *
-		 * Make sure we don't run past the end of the captured data
-		 * while processing the isochronous descriptors.
-		 */
-		pre_truncation_data_len = 0;
-		for (uint32_t desc = 0;
-		    desc < hdr->ndesc && bytes_left >= sizeof (usb_isodesc);
-		    desc++, bytes_left -= sizeof (usb_isodesc)) {
-			u_int desc_end;
-
-			if (descs[desc].len != 0) {
-				desc_end = descs[desc].offset + descs[desc].len;
-				if (desc_end > pre_truncation_data_len)
-					pre_truncation_data_len = desc_end;
-			}
-		}
-
-		/*
-		 * Now calculate the total length based on that data
-		 * length.
-		 */
-		pre_truncation_len = sizeof(pcap_usb_header_mmapped) +
-		    (hdr->ndesc * sizeof (usb_isodesc)) +
-		    pre_truncation_data_len;
-
-		/*
-		 * If that's greater than or equal to the captured length,
-		 * use that as the length.
-		 */
-		if (pre_truncation_len >= pkth->caplen)
-			pkth->len = pre_truncation_len;
-
-		/*
-		 * If the captured length is greater than the length,
-		 * use the captured length.
-		 *
-		 * For completion events for incoming isochronous transfers,
-		 * it's based on data_len, which is calculated the same way
-		 * we calculated pre_truncation_data_len above, except that
-		 * it has access to all the isochronous descriptors, not
-		 * just the ones that the kernel were able to provide us or,
-		 * for a capture file, that weren't sliced off by a snapshot
-		 * length.
-		 *
-		 * However, it might have been reduced by the USB capture
-		 * mechanism arbitrarily limiting the amount of data it
-		 * provides to userland, or by the libpcap capture code
-		 * limiting it to being no more than the snapshot, so
-		 * we don't want to just use it all the time; we only
-		 * do so to try to get a better estimate of the actual
-		 * length - and to make sure the on-the-network length
-		 * is always >= the captured length.
-		 */
-		if (pkth->caplen > pkth->len)
-			pkth->len = pkth->caplen;
-	}
-}
diff --git a/pcap-usb-linux-common.h b/pcap-usb-linux-common.h
index 8cff7ba1..333c6b6e 100644
--- a/pcap-usb-linux-common.h
+++ b/pcap-usb-linux-common.h
@@ -19,8 +19,109 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  *
  * pcap-usb-linux-common.h - common code for everything that needs to
- * deal with Linux USB captures.
+ * deal with Linux USB captures, whether live or in a capture file;
+ * the later means that this is *not* Linux-only.
  */
 
-extern void fix_linux_usb_mmapped_length(struct pcap_pkthdr *pkth,
-    const u_char *bp);
+#include <limits.h>
+
+/*
+ * Return the sum of the two u_int arguments if that sum fits in a u_int,
+ * and return UINT_MAX otherwise.
+ */
+static inline u_int
+u_int_sum(u_int a, u_int b)
+{
+	return (((b) <= UINT_MAX - (a)) ? (a) + (b) : UINT_MAX);
+}
+
+/*
+ * Is this a completion event for an isochronous transfer?
+ */
+static inline int
+is_isochronous_transfer_completion(const pcap_usb_header_mmapped *hdr)
+{
+	return (hdr->transfer_type == URB_ISOCHRONOUS &&
+	    hdr->event_type == URB_COMPLETE &&
+	    (hdr->endpoint_number & URB_TRANSFER_IN));
+}
+
+/*
+ * Total length of the pseudo-header, including the isochronous
+ * descriptors.
+ */
+static inline uint32_t
+iso_pseudo_header_len(const pcap_usb_header_mmapped *usb_hdr)
+{
+	return (sizeof(pcap_usb_header_mmapped) +
+	    usb_hdr->ndesc * sizeof (usb_isodesc));
+}
+
+/*
+ * Calculate the packet length for a "this is complete" incoming
+ * isochronous transfer event.
+ *
+ * Calculating that from hdr->urb_len is not correct, because the
+ * data is not contiguous, and the isochroous descriptors show how
+ * it's scattered.
+ */
+static inline u_int
+incoming_isochronous_transfer_completed_len(struct pcap_pkthdr *phdr,
+    const u_char *bp)
+{
+	const pcap_usb_header_mmapped *hdr;
+	u_int bytes_left;
+	const usb_isodesc *descs;
+	u_int pre_truncation_data_len;
+
+	/*
+	 * All callers of this routine must ensure that pkth->caplen is
+	 * >= sizeof (pcap_usb_header_mmapped).
+	 */
+	bytes_left = phdr->caplen;
+	bytes_left -= sizeof (pcap_usb_header_mmapped);
+
+	hdr = (const pcap_usb_header_mmapped *) bp;
+	descs = (const usb_isodesc *) (bp + sizeof(pcap_usb_header_mmapped));
+
+	/*
+	 * Find the end of the last chunk of data in the buffer
+	 * referred to by the isochronous descriptors; that indicates
+	 * how far into the buffer the data would have gone.
+	 *
+	 * Make sure we don't run past the end of the captured data
+	 * while processing the isochronous descriptors.
+	 */
+	pre_truncation_data_len = 0;
+	for (uint32_t desc = 0;
+	    desc < hdr->ndesc && bytes_left >= sizeof (usb_isodesc);
+	    desc++, bytes_left -= sizeof (usb_isodesc)) {
+		u_int desc_end;
+
+		if (descs[desc].len != 0) {
+			/*
+			 * Compute the end offset of the data
+			 * for this descriptor, i.e. the offset
+			 * of the byte after the data.  Clamp
+			 * the sum at UINT_MAX, so that it fits
+			 * in a u_int.
+			 */
+			desc_end = u_int_sum(descs[desc].offset,
+			    descs[desc].len);
+			if (desc_end > pre_truncation_data_len)
+				pre_truncation_data_len = desc_end;
+		}
+	}
+
+	/*
+	 * Return the sum of the total header length (memory-mapped
+	 * header and ISO descriptors) and the data length, clamped
+	 * to UINT_MAX.
+	 *
+	 * We've made sure that the number of descriptors is
+	 * <= USB_MAXDESC, so we know that the total size,
+	 * in bytes, of the descriptors fits in a 32-bit
+	 * integer.
+	 */
+	return (u_int_sum(iso_pseudo_header_len(hdr), pre_truncation_data_len));
+}
diff --git a/pcap-usb-linux.c b/pcap-usb-linux.c
index 726e4a8a..bc39b1db 100644
--- a/pcap-usb-linux.c
+++ b/pcap-usb-linux.c
@@ -33,14 +33,12 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
+#include "pcap/usb.h"
 #include "pcap-int.h"
 #include "pcap-usb-linux.h"
 #include "pcap-usb-linux-common.h"
-#include "pcap/usb.h"
 
 #include "extract.h"
 
@@ -157,7 +155,7 @@ usb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)
 		 * "connected" vs. "disconnected", as that's a property
 		 * that would apply to a particular USB interface.
 		 */
-		if (add_dev(devlistp, dev_name,
+		if (pcapint_add_dev(devlistp, dev_name,
 		    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
 		    "Raw USB traffic, all USB buses", err_str) == NULL)
 			return -1;
@@ -169,7 +167,7 @@ usb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)
 		 * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?
 		 */
 		snprintf(dev_descr, 30, "Raw USB traffic, bus number %d", n);
-		if (add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)
+		if (pcapint_add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)
 			return -1;
 	}
 
@@ -254,7 +252,7 @@ usb_set_ring_size(pcap_t* handle, int header_size)
 
 	/*
 	 * Will this get an error?
-	 * (There's no wqy to query the minimum or maximum, so we just
+	 * (There's no way to query the minimum or maximum, so we just
 	 * copy the value from the kernel source.  We don't round it
 	 * up to a multiple of the page size.)
 	 */
@@ -277,7 +275,7 @@ usb_set_ring_size(pcap_t* handle, int header_size)
 	}
 
 	if (ioctl(handle->fd, MON_IOCT_RING_SIZE, ring_size) == -1) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't set ring size from fd %d", handle->fd);
 		return -1;
 	}
@@ -482,11 +480,11 @@ usb_activate(pcap_t* handle)
 	handle->linktype = DLT_USB_LINUX;
 
 	handle->inject_op = usb_inject_linux;
-	handle->setfilter_op = install_bpf_program; /* no kernel filtering */
+	handle->setfilter_op = pcapint_install_bpf_program; /* no kernel filtering */
 	handle->setdirection_op = usb_setdirection_linux;
 	handle->set_datalink_op = NULL;	/* can't change data link type */
-	handle->getnonblock_op = pcap_getnonblock_fd;
-	handle->setnonblock_op = pcap_setnonblock_fd;
+	handle->getnonblock_op = pcapint_getnonblock_fd;
+	handle->setnonblock_op = pcapint_setnonblock_fd;
 
 	/*get usb bus index from device name */
 	if (sscanf(handle->opt.device, USB_IFACE"%d", &handlep->bus_index) != 1)
@@ -544,7 +542,7 @@ DIAG_ON_FORMAT_TRUNCATION
 			/*
 			 * Something went wrong.
 			 */
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno,
 			    "Can't open USB bus file %s", full_path);
 			return PCAP_ERROR;
@@ -609,7 +607,7 @@ DIAG_ON_FORMAT_TRUNCATION
 	 * buffer */
 	handle->buffer = malloc(handle->bufsize);
 	if (!handle->buffer) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		close(handle->fd);
 		return PCAP_ERROR;
@@ -645,7 +643,7 @@ usb_stats_linux_bin(pcap_t *handle, struct pcap_stat *stats)
 	ret = ioctl(handle->fd, MON_IOCG_STATS, &st);
 	if (ret < 0)
 	{
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't read stats from fd %d", handle->fd);
 		return -1;
 	}
@@ -688,7 +686,7 @@ usb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u
 		if (errno == EAGAIN)
 			return 0;	/* no data there */
 
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't read from fd %d", handle->fd);
 		return -1;
 	}
@@ -717,14 +715,14 @@ usb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u
 	pkth.caplen = sizeof(pcap_usb_header) + clen;
 	if (info.hdr->data_flag) {
 		/*
-		 * No data; just base the on-the-wire length on
+		 * No data; just base the original length on
 		 * info.hdr->data_len (so that it's >= the captured
 		 * length).
 		 */
 		pkth.len = sizeof(pcap_usb_header) + info.hdr->data_len;
 	} else {
 		/*
-		 * We got data; base the on-the-wire length on
+		 * We got data; base the original length on
 		 * info.hdr->urb_len, so that it includes data
 		 * discarded by the USB monitor device due to
 		 * its buffer being too small.
@@ -735,7 +733,7 @@ usb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u
 	pkth.ts.tv_usec = info.hdr->ts_usec;
 
 	if (handle->fcode.bf_insns == NULL ||
-	    pcap_filter(handle->fcode.bf_insns, handle->buffer,
+	    pcapint_filter(handle->fcode.bf_insns, handle->buffer,
 	      pkth.len, pkth.caplen)) {
 		handlep->packets_read++;
 		callback(user, &pkth, handle->buffer);
@@ -818,7 +816,7 @@ usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_ch
 			if (errno == EAGAIN)
 				return 0;	/* no data there */
 
-			pcap_fmt_errmsg_for_errno(handle->errbuf,
+			pcapint_fmt_errmsg_for_errno(handle->errbuf,
 			    PCAP_ERRBUF_SIZE, errno, "Can't mfetch fd %d",
 			    handle->fd);
 			return -1;
@@ -877,34 +875,53 @@ usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_ch
 			pkth.caplen = sizeof(pcap_usb_header_mmapped) + clen;
 			if (hdr->data_flag) {
 				/*
-				 * No data; just base the on-the-wire length
+				 * No data; just base the original length
 				 * on hdr->data_len (so that it's >= the
-				 * captured length).
+				 * captured length).  Clamp the result
+				 * at UINT_MAX, so it fits in an unsigned
+				 * int.
 				 */
-				pkth.len = sizeof(pcap_usb_header_mmapped) +
-				    hdr->data_len;
+				pkth.len = u_int_sum(sizeof(pcap_usb_header_mmapped),
+				    hdr->data_len);
 			} else {
 				/*
-				 * We got data; base the on-the-wire length
-				 * on hdr->urb_len, so that it includes
-				 * data discarded by the USB monitor device
-				 * due to its buffer being too small.
-				 */
-				pkth.len = sizeof(pcap_usb_header_mmapped) +
-				    (hdr->ndesc * sizeof (usb_isodesc)) + hdr->urb_len;
-
-				/*
-				 * Now clean it up if it's a completion
-				 * event for an incoming isochronous
-				 * transfer.
+				 * We got data.
 				 */
-				fix_linux_usb_mmapped_length(&pkth, bp);
+				if (is_isochronous_transfer_completion(hdr)) {
+					/*
+					 * For isochronous transfer completion
+					 * events, hdr->urb_len doesn't take
+					 * into account the way the data is
+					 * put into the buffer, as it doesn't
+					 * count any padding between the
+					 * chunks of isochronous data, so
+					 * we have to calculate the amount
+					 * of data from the isochronous
+					 * descriptors.
+					 */
+					pkth.len = incoming_isochronous_transfer_completed_len(&pkth, bp);
+				} else {
+					/*
+					 * For everything else, the original
+					 * data length is just the length of
+					 * the memory-mapped Linux USB header
+					 * plus hdr->urb_len; we use
+					 * hdr->urb_len so that it includes
+					 * data discarded by the USB monitor
+					 * device due to its buffer being
+					 * too small.  Clamp the result at
+					 * UINT_MAX, so it fits in an
+					 * unsigned int.
+					 */
+					pkth.len = u_int_sum(sizeof(pcap_usb_header_mmapped),
+					    hdr->urb_len);
+				}
 			}
 			pkth.ts.tv_sec = (time_t)hdr->ts_sec;
 			pkth.ts.tv_usec = hdr->ts_usec;
 
 			if (handle->fcode.bf_insns == NULL ||
-			    pcap_filter(handle->fcode.bf_insns, (u_char*) hdr,
+			    pcapint_filter(handle->fcode.bf_insns, (u_char*) hdr,
 			      pkth.len, pkth.caplen)) {
 				handlep->packets_read++;
 				callback(user, &pkth, (u_char*) hdr);
@@ -913,7 +930,7 @@ usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_ch
 		}
 
 		/*
-		 * If max_packets specifiesg "unlimited", we stop after
+		 * If max_packets specifies "unlimited", we stop after
 		 * the first chunk.
 		 */
 		if (PACKET_COUNT_IS_UNLIMITED(max_packets) ||
@@ -923,7 +940,7 @@ usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_ch
 
 	/* flush pending events*/
 	if (ioctl(handle->fd, MON_IOCH_MFLUSH, nflush) == -1) {
-		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't mflush fd %d", handle->fd);
 		return -1;
 	}
@@ -940,5 +957,5 @@ usb_cleanup_linux_mmap(pcap_t* handle)
 		munmap(handlep->mmapbuf, handlep->mmapbuflen);
 		handlep->mmapbuf = NULL;
 	}
-	pcap_cleanup_live_common(handle);
+	pcapint_cleanup_live_common(handle);
 }
diff --git a/pcap-util.c b/pcap-util.c
index 8b5669e9..1aa8e13e 100644
--- a/pcap-util.c
+++ b/pcap-util.c
@@ -18,26 +18,24 @@
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  *
- * pcap-common.c - common code for pcap and pcapng files
+ * pcap-util.c - common code for various files
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 
+#include "pcap/can_socketcan.h"
+#include "pcap/sll.h"
+#include "pcap/usb.h"
+#include "pcap/nflog.h"
+
 #include "pcap-int.h"
 #include "extract.h"
 #include "pcap-usb-linux-common.h"
 
 #include "pcap-util.h"
-
 #include "pflog.h"
-#include "pcap/can_socketcan.h"
-#include "pcap/sll.h"
-#include "pcap/usb.h"
-#include "pcap/nflog.h"
 
 /*
  * Most versions of the DLT_PFLOG pseudo-header have UID and PID fields
@@ -103,6 +101,80 @@ swap_pflog_header(const struct pcap_pkthdr *hdr, u_char *buf)
 	pflhdr->rule_pid = SWAPLONG(pflhdr->rule_pid);
 }
 
+/*
+ * Linux cooked capture packets with a protocol type of LINUX_SLL_P_CAN or
+ * LINUX_SLL_P_CANFD have SocketCAN CAN classic/CAN FD headers in front
+ * of the payload,with the CAN ID being in the byte order of the host
+ * that wrote the packet, and Linux cooked capture packets with a protocol
+ * type of LINUX_SLL_P_CANXL have SocketCAN CAN XL headers in front of the
+ * payload with the protocol/VCID field, the payload length, and the
+ * acceptance field in the byte order of the host that wrote the packet.
+ *
+ * When reading a Linux cooked capture packet, we need to check for those
+ * packets and, if the byte order host that wrote the packet, as
+ * indicated by the byte order of the pcap file or pcapng section
+ * containing the packet, is the opposite of our byte order, convert
+ * the header files to our byte order by byte-swapping them.
+ */
+static void
+swap_socketcan_header(uint16_t protocol, u_int caplen, u_int length,
+    u_char *buf)
+{
+	pcap_can_socketcan_hdr *hdrp;
+	pcap_can_socketcan_xl_hdr *xl_hdrp;
+
+	switch (protocol) {
+
+	case LINUX_SLL_P_CAN:
+	case LINUX_SLL_P_CANFD:
+		/*
+		 * CAN classic/CAN FD packet; fix up the packet's header
+		 * by byte-swapping the CAN ID field.
+		 */
+		hdrp = (pcap_can_socketcan_hdr *)buf;
+		if (caplen < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id) ||
+		    length < (u_int) (offsetof(pcap_can_socketcan_hdr, can_id) + sizeof hdrp->can_id)) {
+			/* Not enough data to have the can_id field */
+			return;
+		}
+		hdrp->can_id = SWAPLONG(hdrp->can_id);
+		break;
+
+	case LINUX_SLL_P_CANXL:
+		/*
+		 * CAN XL packet; fix up the packet's header by
+		 * byte-swapping the priority/VCID field, the
+		 * payload length, and the acceptance field.
+		 */
+		xl_hdrp = (pcap_can_socketcan_xl_hdr *)buf;
+		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid) ||
+		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, priority_vcid) + sizeof xl_hdrp->priority_vcid)) {
+			/* Not enough data to have the priority_vcid field */
+			return;
+		}
+		xl_hdrp->priority_vcid = SWAPLONG(xl_hdrp->priority_vcid);
+		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length) ||
+		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, payload_length) + sizeof xl_hdrp->payload_length)) {
+			/* Not enough data to have the payload_length field */
+			return;
+		}
+		xl_hdrp->payload_length = SWAPSHORT(xl_hdrp->payload_length);
+		if (caplen < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field) ||
+		    length < (u_int) (offsetof(pcap_can_socketcan_xl_hdr, acceptance_field) + sizeof xl_hdrp->acceptance_field)) {
+			/* Not enough data to have the acceptance_field field */
+			return;
+		}
+		xl_hdrp->acceptance_field = SWAPLONG(xl_hdrp->acceptance_field);
+		break;
+
+	default:
+		/*
+		 * Not a CAN packet; nothing to do.
+		 */
+		break;
+	}
+}
+
 /*
  * DLT_LINUX_SLL packets with a protocol type of LINUX_SLL_P_CAN or
  * LINUX_SLL_P_CANFD have SocketCAN headers in front of the payload,
@@ -113,13 +185,11 @@ swap_pflog_header(const struct pcap_pkthdr *hdr, u_char *buf)
  * wrote the file to this host's byte order.
  */
 static void
-swap_linux_sll_header(const struct pcap_pkthdr *hdr, u_char *buf)
+swap_linux_sll_socketcan_header(const struct pcap_pkthdr *hdr, u_char *buf)
 {
 	u_int caplen = hdr->caplen;
 	u_int length = hdr->len;
 	struct sll_header *shdr = (struct sll_header *)buf;
-	uint16_t protocol;
-	pcap_can_socketcan_hdr *chdr;
 
 	if (caplen < (u_int) sizeof(struct sll_header) ||
 	    length < (u_int) sizeof(struct sll_header)) {
@@ -127,33 +197,24 @@ swap_linux_sll_header(const struct pcap_pkthdr *hdr, u_char *buf)
 		return;
 	}
 
-	protocol = EXTRACT_BE_U_2(&shdr->sll_protocol);
-	if (protocol != LINUX_SLL_P_CAN && protocol != LINUX_SLL_P_CANFD)
-		return;
-
 	/*
-	 * SocketCAN packet; fix up the packet's header.
+	 * Byte-swap what needs to be byte-swapped.
 	 */
-	chdr = (pcap_can_socketcan_hdr *)(buf + sizeof(struct sll_header));
-	if (caplen < (u_int) sizeof(struct sll_header) + sizeof(chdr->can_id) ||
-	    length < (u_int) sizeof(struct sll_header) + sizeof(chdr->can_id)) {
-		/* Not enough data to have the CAN ID */
-		return;
-	}
-	chdr->can_id = SWAPLONG(chdr->can_id);
+	swap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll_protocol),
+	    caplen - (u_int) sizeof(struct sll_header),
+	    length - (u_int) sizeof(struct sll_header),
+	    buf + sizeof(struct sll_header));
 }
 
 /*
  * The same applies for DLT_LINUX_SLL2.
  */
 static void
-swap_linux_sll2_header(const struct pcap_pkthdr *hdr, u_char *buf)
+swap_linux_sll2_socketcan_header(const struct pcap_pkthdr *hdr, u_char *buf)
 {
 	u_int caplen = hdr->caplen;
 	u_int length = hdr->len;
 	struct sll2_header *shdr = (struct sll2_header *)buf;
-	uint16_t protocol;
-	pcap_can_socketcan_hdr *chdr;
 
 	if (caplen < (u_int) sizeof(struct sll2_header) ||
 	    length < (u_int) sizeof(struct sll2_header)) {
@@ -161,20 +222,13 @@ swap_linux_sll2_header(const struct pcap_pkthdr *hdr, u_char *buf)
 		return;
 	}
 
-	protocol = EXTRACT_BE_U_2(&shdr->sll2_protocol);
-	if (protocol != LINUX_SLL_P_CAN && protocol != LINUX_SLL_P_CANFD)
-		return;
-
 	/*
-	 * SocketCAN packet; fix up the packet's header.
+	 * Byte-swap what needs to be byte-swapped.
 	 */
-	chdr = (pcap_can_socketcan_hdr *)(buf + sizeof(struct sll2_header));
-	if (caplen < (u_int) sizeof(struct sll2_header) + sizeof(chdr->can_id) ||
-	    length < (u_int) sizeof(struct sll2_header) + sizeof(chdr->can_id)) {
-		/* Not enough data to have the CAN ID */
-		return;
-	}
-	chdr->can_id = SWAPLONG(chdr->can_id);
+	swap_socketcan_header(EXTRACT_BE_U_2(&shdr->sll2_protocol),
+	    caplen - (u_int) sizeof(struct sll2_header),
+	    length - (u_int) sizeof(struct sll2_header),
+	    buf + sizeof(struct sll2_header));
 }
 
 /*
@@ -344,7 +398,7 @@ swap_nflog_header(const struct pcap_pkthdr *hdr, u_char *buf)
 	nflog_tlv_t *tlv;
 	u_int caplen = hdr->caplen;
 	u_int length = hdr->len;
-	uint16_t size;
+	u_int size;
 
 	if (caplen < (u_int) sizeof(nflog_hdr_t) ||
 	    length < (u_int) sizeof(nflog_hdr_t)) {
@@ -407,11 +461,11 @@ swap_pseudo_headers(int linktype, struct pcap_pkthdr *hdr, u_char *data)
 		break;
 
 	case DLT_LINUX_SLL:
-		swap_linux_sll_header(hdr, data);
+		swap_linux_sll_socketcan_header(hdr, data);
 		break;
 
 	case DLT_LINUX_SLL2:
-		swap_linux_sll2_header(hdr, data);
+		swap_linux_sll2_socketcan_header(hdr, data);
 		break;
 
 	case DLT_USB_LINUX:
@@ -428,47 +482,146 @@ swap_pseudo_headers(int linktype, struct pcap_pkthdr *hdr, u_char *data)
 	}
 }
 
-void
-pcap_post_process(int linktype, int swapped, struct pcap_pkthdr *hdr,
-    u_char *data)
+static inline int
+packet_length_might_be_wrong(struct pcap_pkthdr *hdr,
+    const pcap_usb_header_mmapped *usb_hdr)
 {
-	if (swapped)
-		swap_pseudo_headers(linktype, hdr, data);
+	uint32_t old_style_packet_length;
 
-	fixup_pcap_pkthdr(linktype, hdr, data);
+	/*
+	 * Calculate the packet length the old way.
+	 * We know that the multiplication won't overflow, but
+	 * we don't know that the additions won't.  Calculate
+	 * it with no overflow checks, as that's how it
+	 * would have been calculated when it was captured.
+	 */
+	old_style_packet_length = iso_pseudo_header_len(usb_hdr) +
+	    usb_hdr->urb_len;
+	return (hdr->len == old_style_packet_length);
 }
 
 void
-fixup_pcap_pkthdr(int linktype, struct pcap_pkthdr *hdr, const u_char *data)
+pcapint_post_process(int linktype, int swapped, struct pcap_pkthdr *hdr,
+    u_char *data)
 {
-	const pcap_usb_header_mmapped *usb_hdr;
+	if (swapped)
+		swap_pseudo_headers(linktype, hdr, data);
 
-	usb_hdr = (const pcap_usb_header_mmapped *) data;
-	if (linktype == DLT_USB_LINUX_MMAPPED &&
-	    hdr->caplen >= sizeof (pcap_usb_header_mmapped)) {
+	/*
+	 * Is this a memory-mapped Linux USB capture?
+	 */
+	if (linktype == DLT_USB_LINUX_MMAPPED) {
 		/*
-		 * In older versions of libpcap, in memory-mapped captures,
-		 * the "on-the-bus length" for completion events for
-		 * incoming isochronous transfers was miscalculated; it
-		 * needed to be calculated based on the* offsets and lengths
-		 * in the descriptors, not on the raw URB length, but it
-		 * wasn't.
+		 * Yes.
+		 *
+		 * In older versions of libpcap, in memory-mapped Linux
+		 * USB captures, the original length of completion events
+		 * for incoming isochronous transfers was miscalculated;
+		 * it needed to be calculated based on the offsets and
+		 * lengths in the descriptors, not on the raw URB length,
+		 * but it wasn't.
 		 *
 		 * If this packet contains transferred data (yes, data_flag
-		 * is 0 if we *do* have data), and the total on-the-network
-		 * length is equal to the value calculated from the raw URB
-		 * length, then it might be one of those transfers.
+		 * is 0 if we *do* have data), it's a completion event
+		 * for an incoming isochronous transfer, and the
+		 * transfer length appears to have been calculated
+		 * from the raw URB length, fix it.
 		 *
-		 * We only do this if we have the full USB pseudo-header.
+		 * We only do this if we have the full USB pseudo-header,
+		 * because we will have to look at that header and at
+		 * all of the isochronous descriptors.
 		 */
+		if (hdr->caplen < sizeof (pcap_usb_header_mmapped)) {
+			/*
+			 * We don't have the full pseudo-header.
+			 */
+			return;
+		}
+
+		const pcap_usb_header_mmapped *usb_hdr =
+		    (const pcap_usb_header_mmapped *) data;
+
+		/*
+		 * Make sure the number of descriptors is sane.
+		 *
+		 * The Linux binary USB monitor code limits the number of
+		 * isochronous descriptors to 128; if the number in the file
+		 * is larger than that, either 1) the file's been damaged
+		 * or 2) the file was produced after the number was raised
+		 * in the kernel.
+		 *
+		 * In case 1), the number can't be trusted, so don't rely on
+		 * it to attempt to fix the original length field in the pcap
+		 * or pcapng header.
+		 *
+		 * In case 2), the system was probably running a version of
+		 * libpcap that didn't miscalculate the original length, so
+		 * it probably doesn't need to be fixed.
+		 *
+		 * This avoids the possibility of the product of the number of
+		 * descriptors and the size of descriptors won't overflow an
+		 * unsigned 32-bit integer.
+		 */
+		if (usb_hdr->ndesc > USB_MAXDESC)
+			return;
+
 		if (!usb_hdr->data_flag &&
-		    hdr->len == sizeof(pcap_usb_header_mmapped) +
-		      (usb_hdr->ndesc * sizeof (usb_isodesc)) + usb_hdr->urb_len) {
+		    is_isochronous_transfer_completion(usb_hdr) &&
+		    packet_length_might_be_wrong(hdr, usb_hdr)) {
+			u_int len;
+
+			/*
+			 * Make sure we have all of the descriptors,
+			 * as we will have to look at all of them.
+			 *
+			 * If not, we don't bother trying to fix
+			 * anything.
+			 */
+			if (hdr->caplen < iso_pseudo_header_len(usb_hdr))
+				return;
+
+			/*
+			 * Calculate what the length should have been.
+			 */
+			len = incoming_isochronous_transfer_completed_len(hdr,
+			    data);
+
+			/*
+			 * len is the smaller of UINT_MAX and the total
+			 * header plus data length.  That's guaranteed
+			 * to fit in a UINT_MAX.
+			 *
+			 * Don't reduce the original length to a value
+			 * below the captured length, however, as that
+			 * is bogus.
+			 */
+			if (len >= hdr->caplen)
+				hdr->len = len;
+
 			/*
-			 * It might need fixing; fix it if it's a completion
-			 * event for an incoming isochronous transfer.
+			 * If the captured length is greater than the
+			 * length, use the captured length.
+			 *
+			 * For completion events for incoming isochronous
+			 * transfers, it's based on data_len, which is
+			 * calculated the same way we calculated
+			 * pre_truncation_data_len above, except that
+			 * it has access to all the isochronous descriptors,
+			 * not just the ones that the kernel were able to
+			 * provide us or, for a capture file, that weren't
+			 * sliced off by a snapshot length.
+			 *
+			 * However, it might have been reduced by the USB
+			 * capture mechanism arbitrarily limiting the amount
+			 * of data it provides to userland, or by the libpcap
+			 * capture code limiting it to being no more than the
+			 * snapshot, so we don't want to just use it all the
+			 * time; we only do so to try to get a better estimate
+			 * of the actual length - and to make sure the
+			 * original length is always >= the captured length.
 			 */
-			fix_linux_usb_mmapped_length(hdr, data);
+			if (hdr->caplen > hdr->len)
+				hdr->len = hdr->caplen;
 		}
 	}
 }
diff --git a/pcap-util.h b/pcap-util.h
index de958191..5b40e45b 100644
--- a/pcap-util.h
+++ b/pcap-util.h
@@ -47,9 +47,5 @@
      ((u_short)(((((u_int)(y))&0xff)<<8) | \
                 ((((u_int)(y))&0xff00)>>8)))
 
-extern void pcap_post_process(int linktype, int swapped,
+extern void pcapint_post_process(int linktype, int swapped,
     struct pcap_pkthdr *hdr, u_char *data);
-
-extern void fixup_pcap_pkthdr(int linktype, struct pcap_pkthdr *hdr,
-    const u_char *data);
-
diff --git a/pcap.3pcap.in b/pcap.3pcap.in
index e98932d8..6336c3a8 100644
--- a/pcap.3pcap.in
+++ b/pcap.3pcap.in
@@ -598,35 +598,35 @@ The callback for
 and
 .BR pcap_loop ()
 is supplied a pointer to a
-.IR "struct pcap_pkthdr" ,
+.BR "struct pcap_pkthdr" ,
 which includes the following members:
 .RS
 .TP
 .B ts
 a
-.I struct timeval
+.B struct timeval
 containing the time when the packet was captured
 .TP
 .B caplen
 a
-.I bpf_u_int32
+.B bpf_u_int32
 giving the number of bytes of the packet that are available from the
 capture
 .TP
 .B len
 a
-.I bpf_u_int32
+.B bpf_u_int32
 giving the length of the packet, in bytes (which might be more than the
 number of bytes available from the capture, if the length of the packet
 is larger than the maximum number of bytes to capture).
 .RE
 .PP
 The callback is also supplied a
-.I const u_char
+.B const u_char
 pointer to the first
 .B caplen
 (as given in the
-.I struct pcap_pkthdr
+.B struct pcap_pkthdr
 mentioned above)
 bytes of data from the packet.  This won't necessarily be the entire
 packet; to capture the entire packet, you will have to provide a value
@@ -641,10 +641,10 @@ performed will limit the amount of packet data available.
 .PP
 .BR pcap_next ()
 is passed an argument that points to a
-.I struct pcap_pkthdr
+.B struct pcap_pkthdr
 structure, and fills it in with the time stamp and length values for the
 packet.  It returns a
-.I const u_char
+.B const u_char *
 to the first
 .B caplen
 bytes of the packet on success, and
@@ -653,11 +653,11 @@ on error.
 .PP
 .BR pcap_next_ex ()
 is passed two pointer arguments, one of which points to a
-.IR struct pcap_pkthdr *
-and one of which points to a
-.IR "const u_char" *.
+.B struct pcap_pkthdr *
+and the other points to a
+.BR "const u_char *" .
 It sets the first pointer to point to a
-.I struct pcap_pkthdr
+.B struct pcap_pkthdr
 structure with the time stamp and length values for the packet, and sets
 the second pointer to point to the first
 .B caplen
diff --git a/pcap.c b/pcap.c
index ef1bbb71..d7850f12 100644
--- a/pcap.c
+++ b/pcap.c
@@ -31,9 +31,10 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
+
+/* Get the same variety of strerror_r() as Autoconf/CMake has detected. */
+#include "ftmacros.h"
 
 #include <pcap-types.h>
 #ifndef _WIN32
@@ -65,6 +66,8 @@ struct rtentry;		/* declarations in <net/if.h> */
 
 #include "diag-control.h"
 
+#include "thread-local.h"
+
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
 #endif
@@ -152,6 +155,19 @@ struct rtentry;		/* declarations in <net/if.h> */
  * initialized as needed if pcap_init() hasn't been called.)
  */
 
+/*
+ * Shut down Winsock.
+ *
+ * Ignores the return value of WSACleanup(); given that this is
+ * an atexit() routine, there's nothing much we can do about
+ * a failure.
+ */
+static void
+internal_wsockfini(void)
+{
+	WSACleanup();
+}
+
 /*
  * Start Winsock.
  * Internal routine.
@@ -177,12 +193,12 @@ internal_wsockinit(char *errbuf)
 	done = 1;
 	if (status != 0) {
 		if (errbuf != NULL) {
-			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 			    status, "WSAStartup() failed");
 		}
 		return (err);
 	}
-	atexit ((void(*)(void))WSACleanup);
+	atexit(internal_wsockfini);
 	err = 0;
 	return (err);
 }
@@ -228,8 +244,8 @@ pcap_wsockinit(void)
  *
  * Returns 0 on success, -1 on error.
  */
-int pcap_new_api;		/* pcap_lookupdev() always fails */
-int pcap_utf_8_mode;		/* Strings should be in UTF-8. */
+int pcapint_new_api;		/* pcap_lookupdev() always fails */
+int pcapint_utf_8_mode;		/* Strings should be in UTF-8. */
 
 int
 pcap_init(unsigned int opts, char *errbuf)
@@ -247,7 +263,7 @@ pcap_init(unsigned int opts, char *errbuf)
 	case PCAP_CHAR_ENC_LOCAL:
 		/* Leave "UTF-8 mode" off. */
 		if (initialized) {
-			if (pcap_utf_8_mode) {
+			if (pcapint_utf_8_mode) {
 				snprintf(errbuf, PCAP_ERRBUF_SIZE,
 				    "Multiple pcap_init calls with different character encodings");
 				return (PCAP_ERROR);
@@ -258,13 +274,13 @@ pcap_init(unsigned int opts, char *errbuf)
 	case PCAP_CHAR_ENC_UTF_8:
 		/* Turn on "UTF-8 mode". */
 		if (initialized) {
-			if (!pcap_utf_8_mode) {
+			if (!pcapint_utf_8_mode) {
 				snprintf(errbuf, PCAP_ERRBUF_SIZE,
 				    "Multiple pcap_init calls with different character encodings");
 				return (PCAP_ERROR);
 			}
 		}
-		pcap_utf_8_mode = 1;
+		pcapint_utf_8_mode = 1;
 		break;
 
 	default:
@@ -278,7 +294,7 @@ pcap_init(unsigned int opts, char *errbuf)
 	 * UTF-8 mode flag, so we have to call a routine to set its
 	 * UTF-8 mode flag.
 	 */
-	pcap_fmt_set_encoding(opts);
+	pcapint_fmt_set_encoding(opts);
 
 	if (initialized) {
 		/*
@@ -302,7 +318,7 @@ pcap_init(unsigned int opts, char *errbuf)
 	 * We're done.
 	 */
 	initialized = 1;
-	pcap_new_api = 1;
+	pcapint_new_api = 1;
 	return (0);
 }
 
@@ -524,17 +540,17 @@ pcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp)
 		 */
 		*tstamp_typesp = (int*)malloc(sizeof(**tstamp_typesp));
 		if (*tstamp_typesp == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "malloc");
 			return (PCAP_ERROR);
 		}
 		**tstamp_typesp = PCAP_TSTAMP_HOST;
 		return (1);
 	} else {
-		*tstamp_typesp = (int*)calloc(sizeof(**tstamp_typesp),
-		    p->tstamp_type_count);
+		*tstamp_typesp = (int*)calloc(p->tstamp_type_count,
+					      sizeof(**tstamp_typesp));
 		if (*tstamp_typesp == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "malloc");
 			return (PCAP_ERROR);
 		}
@@ -567,7 +583,7 @@ pcap_free_tstamp_types(int *tstamp_type_list)
  * returns, so that a copy must be made.
  */
 void
-pcap_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)
+pcapint_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)
 {
 	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
 
@@ -606,11 +622,11 @@ pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,
 		int status;
 
 		/* We are on an offline capture */
-		status = pcap_offline_read(p, 1, p->oneshot_callback,
+		status = pcapint_offline_read(p, 1, p->oneshot_callback,
 		    (u_char *)&s);
 
 		/*
-		 * Return codes for pcap_offline_read() are:
+		 * Return codes for pcapint_offline_read() are:
 		 *   -  0: EOF
 		 *   - -1: error
 		 *   - >0: OK - result is number of packets read, so
@@ -638,7 +654,7 @@ pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,
 	 *         it will be 1 in this case, as we've passed
 	 *         a maximum packet count of 1
 	 * The first one ('0') conflicts with the return code of 0 from
-	 * pcap_offline_read() meaning "end of file".
+	 * pcapint_offline_read() meaning "end of file".
 	*/
 	return (p->read_op(p, 1, p->oneshot_callback, (u_char *)&s));
 }
@@ -713,7 +729,7 @@ pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
 	 * can capture.
 	 */
 	devlist.beginning = NULL;
-	if (pcap_platform_finddevs(&devlist, errbuf) == -1) {
+	if (pcapint_platform_finddevs(&devlist, errbuf) == -1) {
 		/*
 		 * Failed - free all of the entries we were given
 		 * before we failed.
@@ -831,7 +847,7 @@ get_figure_of_merit(pcap_if_t *dev)
 #ifndef _WIN32
 /*
  * Try to get a description for a given device.
- * Returns a mallocated description if it could and NULL if it couldn't.
+ * Returns a malloced description if it could and NULL if it couldn't.
  *
  * XXX - on FreeBSDs that support it, should it get the sysctl named
  * "dev.{adapter family name}.{adapter unit}.%desc" to get a description
@@ -895,7 +911,7 @@ get_if_description(const char *name)
 	 * Get the description for the interface.
 	 */
 	memset(&ifrdesc, 0, sizeof ifrdesc);
-	pcap_strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);
+	pcapint_strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s >= 0) {
 #ifdef __FreeBSD__
@@ -980,7 +996,7 @@ get_if_description(const char *name)
 				 * (If that fails, we don't worry about
 				 * it, we just return NULL.)
 				 */
-				if (pcap_asprintf(&description,
+				if (pcapint_asprintf(&description,
 				    "USB bus number %ld", busnum) == -1) {
 					/* Failed. */
 					description = NULL;
@@ -1007,8 +1023,8 @@ get_if_description(const char *name _U_)
  * the new entry, otherwise return NULL and set errbuf to an error message.
  */
 pcap_if_t *
-find_or_add_if(pcap_if_list_t *devlistp, const char *name,
-    bpf_u_int32 if_flags, get_if_flags_func get_flags_func, char *errbuf)
+pcapint_find_or_add_if(pcap_if_list_t *devlistp, const char *name,
+    uint64_t if_flags, get_if_flags_func get_flags_func, char *errbuf)
 {
 	bpf_u_int32 pcap_flags;
 
@@ -1041,7 +1057,7 @@ find_or_add_if(pcap_if_list_t *devlistp, const char *name,
 	 * Attempt to find an entry for this device; if we don't find one,
 	 * attempt to add one.
 	 */
-	return (find_or_add_dev(devlistp, name, pcap_flags,
+	return (pcapint_find_or_add_dev(devlistp, name, pcap_flags,
 	    get_flags_func, get_if_description(name), errbuf));
 }
 
@@ -1064,8 +1080,8 @@ find_or_add_if(pcap_if_list_t *devlistp, const char *name,
  * add interfaces even if they have no addresses.)
  */
 int
-add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
-    bpf_u_int32 if_flags, get_if_flags_func get_flags_func,
+pcapint_add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
+    uint64_t if_flags, get_if_flags_func get_flags_func,
     struct sockaddr *addr, size_t addr_size,
     struct sockaddr *netmask, size_t netmask_size,
     struct sockaddr *broadaddr, size_t broadaddr_size,
@@ -1077,7 +1093,7 @@ add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
 	/*
 	 * Check whether the device exists and, if not, add it.
 	 */
-	curdev = find_or_add_if(devlistp, name, if_flags, get_flags_func,
+	curdev = pcapint_find_or_add_if(devlistp, name, if_flags, get_flags_func,
 	    errbuf);
 	if (curdev == NULL) {
 		/*
@@ -1099,7 +1115,7 @@ add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
 	 * address for it; add an entry for that address to the
 	 * interface's list of addresses.
 	 */
-	return (add_addr_to_dev(curdev, addr, addr_size, netmask,
+	return (pcapint_add_addr_to_dev(curdev, addr, addr_size, netmask,
 	    netmask_size, broadaddr, broadaddr_size, dstaddr,
 	    dstaddr_size, errbuf));
 }
@@ -1110,7 +1126,7 @@ add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
  * "curdev" is the entry for that interface.
  */
 int
-add_addr_to_dev(pcap_if_t *curdev,
+pcapint_add_addr_to_dev(pcap_if_t *curdev,
     struct sockaddr *addr, size_t addr_size,
     struct sockaddr *netmask, size_t netmask_size,
     struct sockaddr *broadaddr, size_t broadaddr_size,
@@ -1124,7 +1140,7 @@ add_addr_to_dev(pcap_if_t *curdev,
 	 */
 	curaddr = (pcap_addr_t *)malloc(sizeof(pcap_addr_t));
 	if (curaddr == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (-1);
 	}
@@ -1133,7 +1149,7 @@ add_addr_to_dev(pcap_if_t *curdev,
 	if (addr != NULL && addr_size != 0) {
 		curaddr->addr = (struct sockaddr *)dup_sockaddr(addr, addr_size);
 		if (curaddr->addr == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			free(curaddr);
 			return (-1);
@@ -1144,7 +1160,7 @@ add_addr_to_dev(pcap_if_t *curdev,
 	if (netmask != NULL && netmask_size != 0) {
 		curaddr->netmask = (struct sockaddr *)dup_sockaddr(netmask, netmask_size);
 		if (curaddr->netmask == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			if (curaddr->addr != NULL)
 				free(curaddr->addr);
@@ -1157,7 +1173,7 @@ add_addr_to_dev(pcap_if_t *curdev,
 	if (broadaddr != NULL && broadaddr_size != 0) {
 		curaddr->broadaddr = (struct sockaddr *)dup_sockaddr(broadaddr, broadaddr_size);
 		if (curaddr->broadaddr == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			if (curaddr->netmask != NULL)
 				free(curaddr->netmask);
@@ -1172,7 +1188,7 @@ add_addr_to_dev(pcap_if_t *curdev,
 	if (dstaddr != NULL && dstaddr_size != 0) {
 		curaddr->dstaddr = (struct sockaddr *)dup_sockaddr(dstaddr, dstaddr_size);
 		if (curaddr->dstaddr == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			if (curaddr->broadaddr != NULL)
 				free(curaddr->broadaddr);
@@ -1225,7 +1241,7 @@ add_addr_to_dev(pcap_if_t *curdev,
  * return -1 and set errbuf to an error message.
  */
 pcap_if_t *
-find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
+pcapint_find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
     get_if_flags_func get_flags_func, const char *description, char *errbuf)
 {
 	pcap_if_t *curdev;
@@ -1233,7 +1249,7 @@ find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 	/*
 	 * Is there already an entry in the list for this device?
 	 */
-	curdev = find_dev(devlistp, name);
+	curdev = pcapint_find_dev(devlistp, name);
 	if (curdev != NULL) {
 		/*
 		 * Yes, return it.
@@ -1258,7 +1274,7 @@ find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 	/*
 	 * Now, try to add it to the list of devices.
 	 */
-	return (add_dev(devlistp, name, flags, description, errbuf));
+	return (pcapint_add_dev(devlistp, name, flags, description, errbuf));
 }
 
 /*
@@ -1266,7 +1282,7 @@ find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
  * the entry for it if we find it or NULL if we don't.
  */
 pcap_if_t *
-find_dev(pcap_if_list_t *devlistp, const char *name)
+pcapint_find_dev(pcap_if_list_t *devlistp, const char *name)
 {
 	pcap_if_t *curdev;
 
@@ -1300,7 +1316,7 @@ find_dev(pcap_if_list_t *devlistp, const char *name)
  * If we weren't given a description, try to get one.
  */
 pcap_if_t *
-add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
+pcapint_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
     const char *description, char *errbuf)
 {
 	pcap_if_t *curdev, *prevdev, *nextdev;
@@ -1308,7 +1324,7 @@ add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 
 	curdev = malloc(sizeof(pcap_if_t));
 	if (curdev == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (NULL);
 	}
@@ -1319,7 +1335,7 @@ add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 	curdev->next = NULL;
 	curdev->name = strdup(name);
 	if (curdev->name == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		free(curdev);
 		return (NULL);
@@ -1335,7 +1351,7 @@ add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 		 */
 		curdev->description = strdup(description);
 		if (curdev->description == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			free(curdev->name);
 			free(curdev);
@@ -1419,6 +1435,24 @@ add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
 	return (curdev);
 }
 
+/*
+ * Add an entry for the "any" device.
+ */
+pcap_if_t *
+pcap_add_any_dev(pcap_if_list_t *devlistp, char *errbuf)
+{
+	static const char any_descr[] = "Pseudo-device that captures on all interfaces";
+
+	/*
+	 * As it refers to all network devices, not to any particular
+	 * network device, the notion of "connected" vs. "disconnected"
+	 * doesn't apply to the "any" device.
+	 */
+	return pcapint_add_dev(devlistp, "any",
+	    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
+	    any_descr, errbuf);
+}
+
 /*
  * Free a list of interfaces.
  */
@@ -1516,7 +1550,7 @@ pcap_lookupdev(char *errbuf)
 	 * In addition, it's not thread-safe, so we've marked it as
 	 * deprecated.
 	 */
-	if (pcap_new_api) {
+	if (pcapint_new_api) {
 		snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()");
 		return (NULL);
@@ -1537,14 +1571,14 @@ pcap_lookupdev(char *errbuf)
 		 * on the list, there aren't any non-loopback devices,
 		 * so why not just supply it as the default device?
 		 */
-		(void)pcap_strlcpy(errbuf, "no suitable device found",
+		(void)pcapint_strlcpy(errbuf, "no suitable device found",
 		    PCAP_ERRBUF_SIZE);
 		ret = NULL;
 	} else {
 		/*
 		 * Return the name of the first device on the list.
 		 */
-		(void)pcap_strlcpy(device, alldevs->name, sizeof(device));
+		(void)pcapint_strlcpy(device, alldevs->name, sizeof(device));
 		ret = device;
 	}
 
@@ -1605,22 +1639,34 @@ pcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,
 
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "socket");
 		return (-1);
 	}
 	memset(&ifr, 0, sizeof(ifr));
-#ifdef linux
+#ifdef __linux__
 	/* XXX Work around Linux kernel bug */
 	ifr.ifr_addr.sa_family = AF_INET;
 #endif
-	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	(void)pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+#if defined(__HAIKU__) && defined(__clang__)
+	/*
+	 * In Haiku R1/beta4 <unistd.h> ioctl() is a macro that needs to take 4
+	 * arguments to initialize its intermediate 2-member structure fully so
+	 * that Clang does not generate a -Wmissing-field-initializers warning
+	 * (which manifests only when it runs with -Werror).  This workaround
+	 * can be removed as soon as there is a Haiku release that fixes the
+	 * problem.  See also https://review.haiku-os.org/c/haiku/+/6369
+	 */
+	if (ioctl(fd, SIOCGIFADDR, (char *)&ifr, sizeof(ifr)) < 0) {
+#else
 	if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {
+#endif /* __HAIKU__ && __clang__ */
 		if (errno == EADDRNOTAVAIL) {
 			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 			    "%s: no IPv4 address assigned", device);
 		} else {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "SIOCGIFADDR: %s", device);
 		}
 		(void)close(fd);
@@ -1629,13 +1675,18 @@ pcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,
 	sin4 = (struct sockaddr_in *)&ifr.ifr_addr;
 	*netp = sin4->sin_addr.s_addr;
 	memset(&ifr, 0, sizeof(ifr));
-#ifdef linux
+#ifdef __linux__
 	/* XXX Work around Linux kernel bug */
 	ifr.ifr_addr.sa_family = AF_INET;
 #endif
-	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	(void)pcapint_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+#if defined(__HAIKU__) && defined(__clang__)
+	/* Same as above. */
+	if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr, sizeof(ifr)) < 0) {
+#else
 	if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+#endif /* __HAIKU__ && __clang__ */
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "SIOCGIFNETMASK: %s", device);
 		(void)close(fd);
 		return (-1);
@@ -1673,7 +1724,7 @@ get_substring(const char *p, size_t len, char *ebuf)
 
 	token = malloc(len + 1);
 	if (token == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (NULL);
 	}
@@ -1768,7 +1819,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 		 */
 		*pathp = strdup(source);
 		if (*pathp == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return (-1);
 		}
@@ -1793,7 +1844,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 		 */
 		*pathp = strdup(source);
 		if (*pathp == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return (-1);
 		}
@@ -1811,7 +1862,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 	scheme_len = colonp - source;
 	scheme = malloc(scheme_len + 1);
 	if (scheme == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (-1);
 	}
@@ -1822,10 +1873,10 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 	 * Treat file: specially - take everything after file:// as
 	 * the pathname.
 	 */
-	if (pcap_strcasecmp(scheme, "file") == 0) {
+	if (pcapint_strcasecmp(scheme, "file") == 0) {
 		*pathp = strdup(colonp + 3);
 		if (*pathp == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			free(scheme);
 			return (-1);
@@ -1842,8 +1893,8 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 	 *
 	 * XXX - %-escaping?
 	 */
-	if ((pcap_strcasecmp(scheme, "rpcap") == 0 ||
-	    pcap_strcasecmp(scheme, "rpcaps") == 0) &&
+	if ((pcapint_strcasecmp(scheme, "rpcap") == 0 ||
+	    pcapint_strcasecmp(scheme, "rpcaps") == 0) &&
 	    strchr(colonp + 3, '/') == NULL) {
 		/*
 		 * Local device.
@@ -1854,7 +1905,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 		free(scheme);
 		*pathp = strdup(colonp + 3);
 		if (*pathp == NULL) {
-			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 			    errno, "malloc");
 			return (-1);
 		}
@@ -1931,7 +1982,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 		if (*parsep == '[') {
 			/*
 			 * Yes.
-			 * Treat verything up to the closing square
+			 * Treat everything up to the closing square
 			 * bracket as the IP-Literal; we don't worry
 			 * about whether it's a valid IPv6address or
 			 * IPvFuture (or an IPv4address, for that
@@ -1957,7 +2008,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 			    *(bracketp + 1) != ':') {
 				/*
 				 * There's extra crud after the
-				 * closing square bracketn.
+				 * closing square bracket.
 				 */
 				snprintf(ebuf, PCAP_ERRBUF_SIZE,
 				    "Extra text after IP-literal in URL");
@@ -2037,7 +2088,7 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 	else
 		path = strdup(endp + 1);
 	if (path == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		free(port);
 		free(host);
@@ -2054,15 +2105,15 @@ pcap_parse_source(const char *source, char **schemep, char **userinfop,
 }
 
 int
-pcap_createsrcstr_ex(char *source, int type, const char *host, const char *port,
+pcapint_createsrcstr_ex(char *source, int type, const char *host, const char *port,
     const char *name, unsigned char uses_ssl, char *errbuf)
 {
 	switch (type) {
 
 	case PCAP_SRC_FILE:
-		pcap_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);
+		pcapint_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);
 		if (name != NULL && *name != '\0') {
-			pcap_strlcat(source, name, PCAP_BUF_SIZE);
+			pcapint_strlcat(source, name, PCAP_BUF_SIZE);
 			return (0);
 		} else {
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
@@ -2071,7 +2122,7 @@ pcap_createsrcstr_ex(char *source, int type, const char *host, const char *port,
 		}
 
 	case PCAP_SRC_IFREMOTE:
-		pcap_strlcpy(source,
+		pcapint_strlcpy(source,
 		    (uses_ssl ? "rpcaps://" : PCAP_SRC_IF_STRING),
 		    PCAP_BUF_SIZE);
 		if (host != NULL && *host != '\0') {
@@ -2081,18 +2132,18 @@ pcap_createsrcstr_ex(char *source, int type, const char *host, const char *port,
 				 * probably an IPv6 address, and needs to
 				 * be included in square brackets.
 				 */
-				pcap_strlcat(source, "[", PCAP_BUF_SIZE);
-				pcap_strlcat(source, host, PCAP_BUF_SIZE);
-				pcap_strlcat(source, "]", PCAP_BUF_SIZE);
+				pcapint_strlcat(source, "[", PCAP_BUF_SIZE);
+				pcapint_strlcat(source, host, PCAP_BUF_SIZE);
+				pcapint_strlcat(source, "]", PCAP_BUF_SIZE);
 			} else
-				pcap_strlcat(source, host, PCAP_BUF_SIZE);
+				pcapint_strlcat(source, host, PCAP_BUF_SIZE);
 
 			if (port != NULL && *port != '\0') {
-				pcap_strlcat(source, ":", PCAP_BUF_SIZE);
-				pcap_strlcat(source, port, PCAP_BUF_SIZE);
+				pcapint_strlcat(source, ":", PCAP_BUF_SIZE);
+				pcapint_strlcat(source, port, PCAP_BUF_SIZE);
 			}
 
-			pcap_strlcat(source, "/", PCAP_BUF_SIZE);
+			pcapint_strlcat(source, "/", PCAP_BUF_SIZE);
 		} else {
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
 			    "The host name cannot be NULL.");
@@ -2100,15 +2151,15 @@ pcap_createsrcstr_ex(char *source, int type, const char *host, const char *port,
 		}
 
 		if (name != NULL && *name != '\0')
-			pcap_strlcat(source, name, PCAP_BUF_SIZE);
+			pcapint_strlcat(source, name, PCAP_BUF_SIZE);
 
 		return (0);
 
 	case PCAP_SRC_IFLOCAL:
-		pcap_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);
+		pcapint_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);
 
 		if (name != NULL && *name != '\0')
-			pcap_strlcat(source, name, PCAP_BUF_SIZE);
+			pcapint_strlcat(source, name, PCAP_BUF_SIZE);
 
 		return (0);
 
@@ -2124,11 +2175,11 @@ int
 pcap_createsrcstr(char *source, int type, const char *host, const char *port,
     const char *name, char *errbuf)
 {
-	return (pcap_createsrcstr_ex(source, type, host, port, name, 0, errbuf));
+	return (pcapint_createsrcstr_ex(source, type, host, port, name, 0, errbuf));
 }
 
 int
-pcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
+pcapint_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
     char *name, unsigned char *uses_ssl, char *errbuf)
 {
 	char *scheme, *tmpuserinfo, *tmphost, *tmpport, *tmppath;
@@ -2157,7 +2208,7 @@ pcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
 		 * Local device.
 		 */
 		if (name && tmppath)
-			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
+			pcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);
 		if (type)
 			*type = PCAP_SRC_IFLOCAL;
 		free(tmppath);
@@ -2187,12 +2238,12 @@ pcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
 				snprintf(host, PCAP_BUF_SIZE, "%s@%s",
 				    tmpuserinfo, tmphost);
 			else
-				pcap_strlcpy(host, tmphost, PCAP_BUF_SIZE);
+				pcapint_strlcpy(host, tmphost, PCAP_BUF_SIZE);
 		}
 		if (port && tmpport)
-			pcap_strlcpy(port, tmpport, PCAP_BUF_SIZE);
+			pcapint_strlcpy(port, tmpport, PCAP_BUF_SIZE);
 		if (name && tmppath)
-			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
+			pcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);
 		if (type)
 			*type = PCAP_SRC_IFREMOTE;
 		free(tmppath);
@@ -2208,7 +2259,7 @@ pcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
 		 * file://
 		 */
 		if (name && tmppath)
-			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
+			pcapint_strlcpy(name, tmppath, PCAP_BUF_SIZE);
 		if (type)
 			*type = PCAP_SRC_FILE;
 		free(tmppath);
@@ -2224,7 +2275,7 @@ pcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,
 	 * as a local device.
 	 */
 	if (name)
-		pcap_strlcpy(name, source, PCAP_BUF_SIZE);
+		pcapint_strlcpy(name, source, PCAP_BUF_SIZE);
 	if (type)
 		*type = PCAP_SRC_IFLOCAL;
 	free(tmppath);
@@ -2239,7 +2290,7 @@ int
 pcap_parsesrcstr(const char *source, int *type, char *host, char *port,
     char *name, char *errbuf)
 {
-	return (pcap_parsesrcstr_ex(source, type, host, port, name, NULL, errbuf));
+	return (pcapint_parsesrcstr_ex(source, type, host, port, name, NULL, errbuf));
 }
 #endif
 
@@ -2298,13 +2349,13 @@ pcap_create(const char *device, char *errbuf)
 		 * We keep it around in legacy mode for backwards
 		 * compatibility.
 		 */
-		if (!pcap_new_api && device[0] != '\0' && device[1] == '\0') {
+		if (!pcapint_new_api && device[0] != '\0' && device[1] == '\0') {
 			size_t length;
 
 			length = wcslen((wchar_t *)device);
 			device_str = (char *)malloc(length + 1);
 			if (device_str == NULL) {
-				pcap_fmt_errmsg_for_errno(errbuf,
+				pcapint_fmt_errmsg_for_errno(errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "malloc");
 				return (NULL);
@@ -2317,7 +2368,7 @@ pcap_create(const char *device, char *errbuf)
 			device_str = strdup(device);
 	}
 	if (device_str == NULL) {
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (NULL);
 	}
@@ -2356,7 +2407,7 @@ pcap_create(const char *device, char *errbuf)
 	/*
 	 * OK, try it as a regular network interface.
 	 */
-	p = pcap_create_interface(device_str, errbuf);
+	p = pcapint_create_interface(device_str, errbuf);
 	if (p == NULL) {
 		/*
 		 * We assume the caller filled in errbuf.
@@ -2412,23 +2463,23 @@ initialize_ops(pcap_t *p)
 
 	/*
 	 * Default cleanup operation - implementations can override
-	 * this, but should call pcap_cleanup_live_common() after
+	 * this, but should call pcapint_cleanup_live_common() after
 	 * doing their own additional cleanup.
 	 */
-	p->cleanup_op = pcap_cleanup_live_common;
+	p->cleanup_op = pcapint_cleanup_live_common;
 
 	/*
 	 * In most cases, the standard one-shot callback can
 	 * be used for pcap_next()/pcap_next_ex().
 	 */
-	p->oneshot_callback = pcap_oneshot;
+	p->oneshot_callback = pcapint_oneshot;
 
 	/*
 	 * Default breakloop operation - implementations can override
-	 * this, but should call pcap_breakloop_common() before doing
+	 * this, but should call pcapint_breakloop_common() before doing
 	 * their own logic.
 	 */
-	p->breakloop_op = pcap_breakloop_common;
+	p->breakloop_op = pcapint_breakloop_common;
 }
 
 static pcap_t *
@@ -2443,7 +2494,7 @@ pcap_alloc_pcap_t(char *ebuf, size_t total_size, size_t private_offset)
 	 */
 	chunk = calloc(total_size, 1);
 	if (chunk == NULL) {
-		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc");
 		return (NULL);
 	}
@@ -2476,7 +2527,7 @@ pcap_alloc_pcap_t(char *ebuf, size_t total_size, size_t private_offset)
 }
 
 pcap_t *
-pcap_create_common(char *ebuf, size_t total_size, size_t private_offset)
+pcapint_create_common(char *ebuf, size_t total_size, size_t private_offset)
 {
 	pcap_t *p;
 
@@ -2529,7 +2580,7 @@ pcap_create_common(char *ebuf, size_t total_size, size_t private_offset)
 }
 
 int
-pcap_check_activated(pcap_t *p)
+pcapint_check_activated(pcap_t *p)
 {
 	if (p->activated) {
 		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "can't perform "
@@ -2542,7 +2593,7 @@ pcap_check_activated(pcap_t *p)
 int
 pcap_set_snaplen(pcap_t *p, int snaplen)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->snapshot = snaplen;
 	return (0);
@@ -2551,7 +2602,7 @@ pcap_set_snaplen(pcap_t *p, int snaplen)
 int
 pcap_set_promisc(pcap_t *p, int promisc)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->opt.promisc = promisc;
 	return (0);
@@ -2560,7 +2611,7 @@ pcap_set_promisc(pcap_t *p, int promisc)
 int
 pcap_set_rfmon(pcap_t *p, int rfmon)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->opt.rfmon = rfmon;
 	return (0);
@@ -2569,7 +2620,7 @@ pcap_set_rfmon(pcap_t *p, int rfmon)
 int
 pcap_set_timeout(pcap_t *p, int timeout_ms)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->opt.timeout = timeout_ms;
 	return (0);
@@ -2580,7 +2631,7 @@ pcap_set_tstamp_type(pcap_t *p, int tstamp_type)
 {
 	int i;
 
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 
 	/*
@@ -2623,7 +2674,7 @@ pcap_set_tstamp_type(pcap_t *p, int tstamp_type)
 int
 pcap_set_immediate_mode(pcap_t *p, int immediate)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	p->opt.immediate = immediate;
 	return (0);
@@ -2632,7 +2683,7 @@ pcap_set_immediate_mode(pcap_t *p, int immediate)
 int
 pcap_set_buffer_size(pcap_t *p, int buffer_size)
 {
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	if (buffer_size <= 0) {
 		/*
@@ -2649,7 +2700,7 @@ pcap_set_tstamp_precision(pcap_t *p, int tstamp_precision)
 {
 	int i;
 
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 
 	/*
@@ -2711,7 +2762,7 @@ pcap_activate(pcap_t *p)
 	 * as some code that showed up in a Stack Exchange
 	 * question did.
 	 */
-	if (pcap_check_activated(p))
+	if (pcapint_check_activated(p))
 		return (PCAP_ERROR_ACTIVATED);
 	status = p->activate_op(p);
 	if (status >= 0) {
@@ -2851,7 +2902,7 @@ fail:
 		 */
 		char trimbuf[PCAP_ERRBUF_SIZE - 5]; /* 2 bytes shorter */
 
-		pcap_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
+		pcapint_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
 		snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %.*s", device,
 		    PCAP_ERRBUF_SIZE - 3, trimbuf);
 	} else if (status == PCAP_ERROR_NO_SUCH_DEVICE ||
@@ -2867,7 +2918,7 @@ fail:
 			 */
 			char trimbuf[PCAP_ERRBUF_SIZE - 8]; /* 2 bytes shorter */
 
-			pcap_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
+			pcapint_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
 			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s (%.*s)",
 			    device, pcap_statustostr(status),
 			    PCAP_ERRBUF_SIZE - 6, trimbuf);
@@ -2884,7 +2935,7 @@ fail:
 }
 
 pcap_t *
-pcap_open_offline_common(char *ebuf, size_t total_size, size_t private_offset)
+pcapint_open_offline_common(char *ebuf, size_t total_size, size_t private_offset)
 {
 	pcap_t *p;
 
@@ -2913,7 +2964,7 @@ pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 			/*
 			 * 0 means EOF, so don't loop if we get 0.
 			 */
-			n = pcap_offline_read(p, cnt, callback, user);
+			n = pcapint_offline_read(p, cnt, callback, user);
 		} else {
 			/*
 			 * XXX keep reading until we get something
@@ -2972,16 +3023,16 @@ pcap_list_datalinks(pcap_t *p, int **dlt_buffer)
 		 */
 		*dlt_buffer = (int*)malloc(sizeof(**dlt_buffer));
 		if (*dlt_buffer == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "malloc");
 			return (PCAP_ERROR);
 		}
 		**dlt_buffer = p->linktype;
 		return (1);
 	} else {
-		*dlt_buffer = (int*)calloc(sizeof(**dlt_buffer), p->dlt_count);
+		*dlt_buffer = (int*)calloc(p->dlt_count, sizeof(**dlt_buffer));
 		if (*dlt_buffer == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
+			pcapint_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
 			    errno, "malloc");
 			return (PCAP_ERROR);
 		}
@@ -3146,7 +3197,7 @@ static const u_char charmap[] = {
 };
 
 int
-pcap_strcasecmp(const char *s1, const char *s2)
+pcapint_strcasecmp(const char *s1, const char *s2)
 {
 	register const u_char	*cm = charmap,
 				*us1 = (const u_char *)s1,
@@ -3257,7 +3308,7 @@ static struct dlt_choice dlt_choices[] = {
 	DLT_CHOICE(USB_LINUX_MMAPPED, "USB with padded Linux header"),
 	DLT_CHOICE(DECT, "DECT"),
 	DLT_CHOICE(AOS, "AOS Space Data Link protocol"),
-	DLT_CHOICE(WIHART, "Wireless HART"),
+	DLT_CHOICE(WIHART, "WirelessHART"),
 	DLT_CHOICE(FC_2, "Fibre Channel FC-2"),
 	DLT_CHOICE(FC_2_WITH_FRAME_DELIMS, "Fibre Channel FC-2 with frame delimiters"),
 	DLT_CHOICE(IPNET, "Solaris ipnet"),
@@ -3329,7 +3380,7 @@ pcap_datalink_name_to_val(const char *name)
 	int i;
 
 	for (i = 0; dlt_choices[i].name != NULL; i++) {
-		if (pcap_strcasecmp(dlt_choices[i].name, name) == 0)
+		if (pcapint_strcasecmp(dlt_choices[i].name, name) == 0)
 			return (dlt_choices[i].dlt);
 	}
 	return (-1);
@@ -3362,7 +3413,7 @@ pcap_datalink_val_to_description(int dlt)
 const char *
 pcap_datalink_val_to_description_or_dlt(int dlt)
 {
-        static char unkbuf[40];
+        static thread_local char unkbuf[40];
         const char *description;
 
         description = pcap_datalink_val_to_description(dlt);
@@ -3396,7 +3447,7 @@ pcap_tstamp_type_name_to_val(const char *name)
 	int i;
 
 	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
-		if (pcap_strcasecmp(tstamp_type_choices[i].name, name) == 0)
+		if (pcapint_strcasecmp(tstamp_type_choices[i].name, name) == 0)
 			return (tstamp_type_choices[i].type);
 	}
 	return (PCAP_ERROR);
@@ -3480,7 +3531,7 @@ pcap_fileno(pcap_t *p)
 		/*
 		 * This is a bogus and now-deprecated API; we
 		 * squelch the narrowing warning for the cast
-		 * from HANDLE to intptr_t.  If Windows programmmers
+		 * from HANDLE to intptr_t.  If Windows programmers
 		 * need to get at the HANDLE for a pcap_t, *if*
 		 * there is one, they should request such a
 		 * routine (and be prepared for it to return
@@ -3542,7 +3593,7 @@ pcap_getnonblock(pcap_t *p, char *errbuf)
 		 * We copy the error message to errbuf, so callers
 		 * can find it in either place.
 		 */
-		pcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
+		pcapint_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
 	}
 	return (ret);
 }
@@ -3553,13 +3604,13 @@ pcap_getnonblock(pcap_t *p, char *errbuf)
  */
 #if !defined(_WIN32) && !defined(MSDOS)
 int
-pcap_getnonblock_fd(pcap_t *p)
+pcapint_getnonblock_fd(pcap_t *p)
 {
 	int fdflags;
 
 	fdflags = fcntl(p->fd, F_GETFL, 0);
 	if (fdflags == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "F_GETFL");
 		return (-1);
 	}
@@ -3586,7 +3637,7 @@ pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)
 		 * We copy the error message to errbuf, so callers
 		 * can find it in either place.
 		 */
-		pcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
+		pcapint_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
 	}
 	return (ret);
 }
@@ -3599,13 +3650,13 @@ pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)
  * needs to do some additional work.)
  */
 int
-pcap_setnonblock_fd(pcap_t *p, int nonblock)
+pcapint_setnonblock_fd(pcap_t *p, int nonblock)
 {
 	int fdflags;
 
 	fdflags = fcntl(p->fd, F_GETFL, 0);
 	if (fdflags == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "F_GETFL");
 		return (-1);
 	}
@@ -3614,7 +3665,7 @@ pcap_setnonblock_fd(pcap_t *p, int nonblock)
 	else
 		fdflags &= ~O_NONBLOCK;
 	if (fcntl(p->fd, F_SETFL, fdflags) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "F_SETFL");
 		return (-1);
 	}
@@ -3628,7 +3679,7 @@ pcap_setnonblock_fd(pcap_t *p, int nonblock)
 const char *
 pcap_statustostr(int errnum)
 {
-	static char ebuf[15+10+1];
+	static thread_local char ebuf[15+10+1];
 
 	switch (errnum) {
 
@@ -3676,38 +3727,106 @@ pcap_statustostr(int errnum)
 
 	case PCAP_ERROR_TSTAMP_PRECISION_NOTSUP:
 		return ("That device doesn't support that time stamp precision");
+
+	case PCAP_ERROR_CAPTURE_NOTSUP:
+		return ("Packet capture is not supported on that device");
 	}
 	(void)snprintf(ebuf, sizeof ebuf, "Unknown error: %d", errnum);
 	return(ebuf);
 }
 
 /*
- * Not all systems have strerror().
+ * A long time ago the purpose of this function was to hide the difference
+ * between those Unix-like OSes that implemented strerror() and those that
+ * didn't.  All the currently supported OSes implement strerror(), which is in
+ * POSIX.1-2001, uniformly and that particular problem no longer exists.  But
+ * now they implement a few incompatible thread-safe variants of strerror(),
+ * and hiding that difference is the current purpose of this function.
  */
 const char *
 pcap_strerror(int errnum)
 {
-#ifdef HAVE_STRERROR
 #ifdef _WIN32
-	static char errbuf[PCAP_ERRBUF_SIZE];
+	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
 	errno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);
 
 	if (err != 0) /* err = 0 if successful */
-		pcap_strlcpy(errbuf, "strerror_s() error", PCAP_ERRBUF_SIZE);
+		pcapint_strlcpy(errbuf, "strerror_s() error", PCAP_ERRBUF_SIZE);
 	return (errbuf);
+#elif defined(HAVE_GNU_STRERROR_R)
+	/*
+	 * We have a GNU-style strerror_r(), which is *not* guaranteed to
+	 * do anything to the buffer handed to it, and which returns a
+	 * pointer to the error string, which may or may not be in
+	 * the buffer.
+	 *
+	 * It is, however, guaranteed to succeed.
+	 *
+	 * At the time of this writing this applies to the following cases,
+	 * each of which allows to use either the GNU implementation or the
+	 * POSIX implementation, and this source tree defines _GNU_SOURCE to
+	 * use the GNU implementation:
+	 * - Hurd
+	 * - Linux with GNU libc
+	 * - Linux with uClibc-ng
+	 */
+	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
+	return strerror_r(errnum, errbuf, PCAP_ERRBUF_SIZE);
+#elif defined(HAVE_POSIX_STRERROR_R)
+	/*
+	 * We have a POSIX-style strerror_r(), which is guaranteed to fill
+	 * in the buffer, but is not guaranteed to succeed.
+	 *
+	 * At the time of this writing this applies to the following cases:
+	 * - AIX 7
+	 * - FreeBSD
+	 * - Haiku
+	 * - HP-UX 11
+	 * - illumos
+	 * - Linux with musl libc
+	 * - macOS
+	 * - NetBSD
+	 * - OpenBSD
+	 * - Solaris 10 & 11
+	 */
+	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
+	int err = strerror_r(errnum, errbuf, PCAP_ERRBUF_SIZE);
+	switch (err) {
+	case 0:
+		/* That worked. */
+		break;
+
+	case EINVAL:
+		/*
+		 * UNIX 03 says this isn't guaranteed to produce a
+		 * fallback error message.
+		 */
+		snprintf(errbuf, PCAP_ERRBUF_SIZE,
+		         "Unknown error: %d", errnum);
+		break;
+	case ERANGE:
+		/*
+		 * UNIX 03 says this isn't guaranteed to produce a
+		 * fallback error message.
+		 */
+		snprintf(errbuf, PCAP_ERRBUF_SIZE,
+		         "Message for error %d is too long", errnum);
+		break;
+	default:
+		snprintf(errbuf, PCAP_ERRBUF_SIZE,
+		         "strerror_r(%d, ...) unexpectedly returned %d",
+		         errnum, err);
+	}
+	return errbuf;
 #else
+	/*
+	 * At the time of this writing every supported OS implements strerror()
+	 * and at least one thread-safe variant thereof, so this is a very
+	 * unlikely last-resort branch.  Particular implementations of strerror()
+	 * may be thread-safe, but this is neither required nor guaranteed.
+	 */
 	return (strerror(errnum));
 #endif /* _WIN32 */
-#else
-	extern int sys_nerr;
-	extern const char *const sys_errlist[];
-	static char errbuf[PCAP_ERRBUF_SIZE];
-
-	if ((unsigned int)errnum < sys_nerr)
-		return ((char *)sys_errlist[errnum]);
-	(void)snprintf(errbuf, sizeof errbuf, "Unknown error: %d", errnum);
-	return (errbuf);
-#endif
 }
 
 int
@@ -3890,7 +4009,7 @@ pcap_get_airpcap_handle(pcap_t *p)
 /*
  * On some platforms, we need to clean up promiscuous or monitor mode
  * when we close a device - and we want that to happen even if the
- * application just exits without explicitl closing devices.
+ * application just exits without explicitly closing devices.
  * On those platforms, we need to register a "close all the pcaps"
  * routine to be called when we exit, and need to maintain a list of
  * pcaps that need to be closed to clean up modes.
@@ -3922,9 +4041,9 @@ pcap_close_all(void)
 
 		/*
 		 * If a pcap module adds a pcap_t to the "close all"
-		 * list by calling pcap_add_to_pcaps_to_close(), it
+		 * list by calling pcapint_add_to_pcaps_to_close(), it
 		 * must have a cleanup routine that removes it from the
-		 * list, by calling pcap_remove_from_pcaps_to_close(),
+		 * list, by calling pcapint_remove_from_pcaps_to_close(),
 		 * and must make that cleanup routine the cleanup_op
 		 * for the pcap_t.
 		 *
@@ -3942,7 +4061,7 @@ pcap_close_all(void)
 }
 
 int
-pcap_do_addexit(pcap_t *p)
+pcapint_do_addexit(pcap_t *p)
 {
 	/*
 	 * If we haven't already done so, arrange to have
@@ -3953,7 +4072,7 @@ pcap_do_addexit(pcap_t *p)
 			/*
 			 * "atexit()" failed; let our caller know.
 			 */
-			pcap_strlcpy(p->errbuf, "atexit failed", PCAP_ERRBUF_SIZE);
+			pcapint_strlcpy(p->errbuf, "atexit failed", PCAP_ERRBUF_SIZE);
 			return (0);
 		}
 		did_atexit = 1;
@@ -3962,14 +4081,14 @@ pcap_do_addexit(pcap_t *p)
 }
 
 void
-pcap_add_to_pcaps_to_close(pcap_t *p)
+pcapint_add_to_pcaps_to_close(pcap_t *p)
 {
 	p->next = pcaps_to_close;
 	pcaps_to_close = p;
 }
 
 void
-pcap_remove_from_pcaps_to_close(pcap_t *p)
+pcapint_remove_from_pcaps_to_close(pcap_t *p)
 {
 	pcap_t *pc, *prevpc;
 
@@ -3996,14 +4115,14 @@ pcap_remove_from_pcaps_to_close(pcap_t *p)
 }
 
 void
-pcap_breakloop_common(pcap_t *p)
+pcapint_breakloop_common(pcap_t *p)
 {
 	p->break_loop = 1;
 }
 
 
 void
-pcap_cleanup_live_common(pcap_t *p)
+pcapint_cleanup_live_common(pcap_t *p)
 {
 	if (p->opt.device != NULL) {
 		free(p->opt.device);
@@ -4048,7 +4167,7 @@ int
 pcap_sendpacket(pcap_t *p, const u_char *buf, int size)
 {
 	if (size <= 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "The number of bytes to be sent must be positive");
 		return (PCAP_ERROR);
 	}
@@ -4070,13 +4189,13 @@ pcap_inject(pcap_t *p, const void *buf, size_t size)
 	 * bytes to write must fit in an int.
 	 */
 	if (size > INT_MAX) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "More than %d bytes cannot be injected", INT_MAX);
 		return (PCAP_ERROR);
 	}
 
 	if (size == 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "The number of bytes to be injected must not be zero");
 		return (PCAP_ERROR);
 	}
@@ -4115,7 +4234,7 @@ pcap_close(pcap_t *p)
 // https://web.archive.org/web/20100828112111/http://blog.rapid7.com/?p=5325
 //
 pcap_code_handle_t
-pcap_load_code(const char *name)
+pcapint_load_code(const char *name)
 {
 	/*
 	 * XXX - should this work in UTF-16LE rather than in the local
@@ -4160,7 +4279,7 @@ pcap_load_code(const char *name)
 }
 
 pcap_funcptr_t
-pcap_find_function(pcap_code_handle_t code, const char *func)
+pcapint_find_function(pcap_code_handle_t code, const char *func)
 {
 	return (GetProcAddress(code, func));
 }
@@ -4179,7 +4298,7 @@ pcap_offline_filter(const struct bpf_program *fp, const struct pcap_pkthdr *h,
 	const struct bpf_insn *fcode = fp->bf_insns;
 
 	if (fcode != NULL)
-		return (pcap_filter(fcode, pkt, h->len, h->caplen));
+		return (pcapint_filter(fcode, pkt, h->len, h->caplen));
 	else
 		return (0);
 }
diff --git a/pcap/can_socketcan.h b/pcap/can_socketcan.h
index 0cb3584a..662bfe22 100644
--- a/pcap/can_socketcan.h
+++ b/pcap/can_socketcan.h
@@ -42,8 +42,8 @@
 #include <pcap/pcap-inttypes.h>
 
 /*
- * SocketCAN header, as per Documentation/networking/can.txt in the
- * Linux source.
+ * SocketCAN header for CAN and CAN FD frames, as per
+ * Documentation/networking/can.rst in the Linux source.
  */
 typedef struct {
 	uint32_t can_id;
@@ -58,4 +58,25 @@ typedef struct {
 #define CANFD_ESI   0x02 /* error state indicator of the transmitting node */
 #define CANFD_FDF   0x04 /* mark CAN FD for dual use of CAN format */
 
+/*
+ * SocketCAN header for CAN XL frames, as per Linux's can.h header.
+ * This is different from pcap_can_socketcan_hdr; the flags field
+ * overlaps with the payload_length field in pcap_can_socketcan_hdr -
+ * the payload_length field in a CAN or CAN FD frame never has the
+ * 0x80 bit set, and the flags field in a CAN XL frame always has
+ * it set, allowing code reading the frame to determine whether
+ * it's CAN XL or not.
+ */
+typedef struct {
+	uint32_t priority_vcid;
+	uint8_t flags;
+	uint8_t sdu_type;
+	uint16_t payload_length;
+	uint32_t acceptance_field;
+} pcap_can_socketcan_xl_hdr;
+
+/* Bits in the flags field */
+#define CANXL_SEC   0x01 /* Simple Extended Context */
+#define CANXL_XLF   0x80 /* mark to distinguish CAN XL from CAN/CAN FD frames */
+
 #endif
diff --git a/pcap/dlt.h b/pcap/dlt.h
index 0da6de23..7f5f5aa4 100644
--- a/pcap/dlt.h
+++ b/pcap/dlt.h
@@ -58,7 +58,12 @@
 /*
  * These are the types that are the same on all platforms, and that
  * have been defined by <net/bpf.h> for ages.
+ *
+ * DLT_LOW_MATCHING_MIN is the lowest such value; DLT_LOW_MATCHING_MAX
+ * is the highest such value.
  */
+#define DLT_LOW_MATCHING_MIN	0
+
 #define DLT_NULL	0	/* BSD loopback encapsulation */
 #define DLT_EN10MB	1	/* Ethernet (10Mb) */
 #define DLT_EN3MB	2	/* Experimental Ethernet (3Mb) */
@@ -71,6 +76,25 @@
 #define DLT_PPP		9	/* Point-to-point Protocol */
 #define DLT_FDDI	10	/* FDDI */
 
+/*
+ * In case the code that includes this file (directly or indirectly)
+ * has also included OS files that happen to define DLT_LOW_MATCHING_MAX,
+ * with a different value (perhaps because that OS hasn't picked up
+ * the latest version of our DLT definitions), we undefine the
+ * previous value of DLT_LOW_MATCHING_MAX.
+ *
+ * (They shouldn't, because only those 10 values were assigned in
+ * the Good Old Days, before DLT_ code assignment became a bit of
+ * a free-for-all.  Perhaps 11 is DLT_ATM_RFC1483 everywhere 11
+ * is used at all, but 12 is DLT_RAW on some platforms but not
+ * OpenBSD, and the fun continues for several other values.)
+ */
+#ifdef DLT_LOW_MATCHING_MAX
+#undef DLT_LOW_MATCHING_MAX
+#endif
+
+#define DLT_LOW_MATCHING_MAX	DLT_FDDI	/* highest value in this "matching" range */
+
 /*
  * These are types that are different on some platforms, and that
  * have been defined by <net/bpf.h> for ages.  We use #ifdefs to
@@ -78,7 +102,9 @@
  * libpcap <net/bpf.h>
  *
  * XXX - DLT_ATM_RFC1483 is 13 in BSD/OS, and DLT_RAW is 14 in BSD/OS,
- * but I don't know what the right #define is for BSD/OS.
+ * but I don't know what the right #define is for BSD/OS.  The last
+ * release was in October 2003; if anybody cares about making this
+ * work on BSD/OS, give us a pull request for a change to make it work.
  */
 #define DLT_ATM_RFC1483	11	/* LLC-encapsulated ATM */
 
@@ -186,12 +212,10 @@
  * anything and doesn't appear to have ever used it for anything.)
  *
  * We define it as 18 on those platforms; it is, unfortunately, used
- * for DLT_CIP in Suse 6.3, so we don't define it as DLT_PFSYNC
- * in general.  As the packet format for it, like that for
- * DLT_PFLOG, is not only OS-dependent but OS-version-dependent,
- * we don't support printing it in tcpdump except on OSes that
- * have the relevant header files, so it's not that useful on
- * other platforms.
+ * for DLT_CIP in SUSE 6.3, so we don't define it as 18 on all
+ * platforms. We define it as 121 on FreeBSD and as the same
+ * value that we assigned to LINKTYPE_PFSYNC on all remaining
+ * platforms.
  */
 #if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__APPLE__)
 #define DLT_PFSYNC	18
@@ -236,10 +260,10 @@
  * and the LINKTYPE_ value that appears in capture files, are the
  * same.
  *
- * DLT_MATCHING_MIN is the lowest such value; DLT_MATCHING_MAX is
+ * DLT_HIGH_MATCHING_MIN is the lowest such value; DLT_HIGH_MATCHING_MAX is
  * the highest such value.
  */
-#define DLT_MATCHING_MIN	104
+#define DLT_HIGH_MATCHING_MIN	104
 
 /*
  * This value was defined by libpcap 0.5; platforms that have defined
@@ -1019,9 +1043,9 @@
 #define DLT_AOS                 222
 
 /*
- * Wireless HART (Highway Addressable Remote Transducer)
+ * WirelessHART (Highway Addressable Remote Transducer)
  * From the HART Communication Foundation
- * IES/PAS 62591
+ * IEC/PAS 62591
  *
  * Requested by Sam Roberts <vieuxtech@gmail.com>.
  */
@@ -1556,33 +1580,14 @@
 
 /*
  * In case the code that includes this file (directly or indirectly)
- * has also included OS files that happen to define DLT_MATCHING_MAX,
+ * has also included OS files that happen to define DLT_HIGH_MATCHING_MAX,
  * with a different value (perhaps because that OS hasn't picked up
  * the latest version of our DLT definitions), we undefine the
- * previous value of DLT_MATCHING_MAX.
+ * previous value of DLT_HIGH_MATCHING_MAX.
  */
-#ifdef DLT_MATCHING_MAX
-#undef DLT_MATCHING_MAX
+#ifdef DLT_HIGH_MATCHING_MAX
+#undef DLT_HIGH_MATCHING_MAX
 #endif
-#define DLT_MATCHING_MAX	289	/* highest value in the "matching" range */
-
-/*
- * DLT and savefile link type values are split into a class and
- * a member of that class.  A class value of 0 indicates a regular
- * DLT_/LINKTYPE_ value.
- */
-#define DLT_CLASS(x)		((x) & 0x03ff0000)
-
-/*
- * NetBSD-specific generic "raw" link type.  The class value indicates
- * that this is the generic raw type, and the lower 16 bits are the
- * address family we're dealing with.  Those values are NetBSD-specific;
- * do not assume that they correspond to AF_ values for your operating
- * system.
- */
-#define	DLT_CLASS_NETBSD_RAWAF	0x02240000
-#define	DLT_NETBSD_RAWAF(af)	(DLT_CLASS_NETBSD_RAWAF | (af))
-#define	DLT_NETBSD_RAWAF_AF(x)	((x) & 0x0000ffff)
-#define	DLT_IS_NETBSD_RAWAF(x)	(DLT_CLASS(x) == DLT_CLASS_NETBSD_RAWAF)
+#define DLT_HIGH_MATCHING_MAX	289	/* highest value in the "matching" range */
 
 #endif /* !defined(lib_pcap_dlt_h) */
diff --git a/pcap/funcattrs.h b/pcap/funcattrs.h
index 37409499..f6baf851 100644
--- a/pcap/funcattrs.h
+++ b/pcap/funcattrs.h
@@ -152,26 +152,16 @@
  * APIs to be designated as "first available in this release" to do so
  * by appropriately defining them.
  *
- * Yes, that's you, Apple. :-)  Please define PCAP_AVAILABLE_MACOS()
- * as necessary to make various APIs "weak exports" to make it easier
- * for software that's distributed in binary form and that uses libpcap
- * to run on multiple macOS versions and use new APIs when available.
- * (Yes, such third-party software exists - Wireshark provides binary
- * packages for macOS, for example.  tcpdump doesn't count, as that's
- * provided by Apple, so each release can come with a version compiled
- * to use the APIs present in that release.)
+ * On macOS, Apple can tweak this to make various APIs "weakly exported
+ * symbols" to make it easier for software that's distributed in binary
+ * form and that uses libpcap to run on multiple macOS versions and use
+ * new APIs when available.  (Yes, such third-party software exists -
+ * Wireshark provides binary packages for macOS, for example.  tcpdump
+ * doesn't count, as that's provided by Apple, so each release can
+ * come with a version compiled to use the APIs present in that release.)
  *
- * The non-macOS versioning is based on
- *
- *    https://en.wikipedia.org/wiki/Darwin_(operating_system)#Release_history
- *
- * If there are any corrections, please submit it upstream to the
- * libpcap maintainers, preferably as a pull request on
- *
- *    https://github.com/the-tcpdump-group/libpcap
- *
- * We don't define it ourselves because, if you're building and
- * installing libpcap on macOS yourself, the APIs will be available
+ * We don't tweak it that way ourselves because, if you're building
+ * and installing libpcap on macOS yourself, the APIs will be available
  * no matter what OS version you're installing it on.
  *
  * For other platforms, we don't define them, leaving it up to
@@ -181,31 +171,58 @@
  * I've never seen earlier releases.
  */
 #ifdef __APPLE__
-#include <Availability.h>
 /*
- * When building as part of macOS, define this as __API_AVAILABLE(__VA_ARGS__).
+ * Apple - insert #include <os/availability.h> here, and replace the two
+ * #defines below with:
+ *
+ *   #define PCAP_API_AVAILABLE	API_AVAILABLE
  *
- * XXX - if there's some #define to indicate that this is being built
- * as part of the macOS build process, we could make that Just Work.
+ * and adjust availabilities as necessary, including adding information
+ * about operating systems other than macOS.
  */
-#define PCAP_AVAILABLE(...)
-#define PCAP_AVAILABLE_0_4	PCAP_AVAILABLE(macos(10.0)) /* Did any version of Mac OS X ship with this? */
-#define PCAP_AVAILABLE_0_5	PCAP_AVAILABLE(macos(10.0)) /* Did any version of Mac OS X ship with this? */
-#define PCAP_AVAILABLE_0_6	PCAP_AVAILABLE(macos(10.1))
-#define PCAP_AVAILABLE_0_7	PCAP_AVAILABLE(macos(10.4))
-#define PCAP_AVAILABLE_0_8	PCAP_AVAILABLE(macos(10.4))
-#define PCAP_AVAILABLE_0_9	PCAP_AVAILABLE(macos(10.5), ios(1.0))
-#define PCAP_AVAILABLE_1_0	PCAP_AVAILABLE(macos(10.6), ios(4.0))
+#define PCAP_API_AVAILABLE(...)
+#define PCAP_AVAILABLE_0_4	PCAP_API_AVAILABLE(macos(10.0))
+#define PCAP_AVAILABLE_0_5	PCAP_API_AVAILABLE(macos(10.0))
+#define PCAP_AVAILABLE_0_6	PCAP_API_AVAILABLE(macos(10.1))
+#define PCAP_AVAILABLE_0_7	PCAP_API_AVAILABLE(macos(10.4))
+#define PCAP_AVAILABLE_0_8	PCAP_API_AVAILABLE(macos(10.4))
+#define PCAP_AVAILABLE_0_9	PCAP_API_AVAILABLE(macos(10.5))
+#define PCAP_AVAILABLE_1_0	PCAP_API_AVAILABLE(macos(10.6))
 /* #define PCAP_AVAILABLE_1_1	no routines added to the API */
-#define PCAP_AVAILABLE_1_2	PCAP_AVAILABLE(macos(10.9), ios(6.0))
+#define PCAP_AVAILABLE_1_2	PCAP_API_AVAILABLE(macos(10.9))
 /* #define PCAP_AVAILABLE_1_3	no routines added to the API */
 /* #define PCAP_AVAILABLE_1_4	no routines added to the API */
-#define PCAP_AVAILABLE_1_5	PCAP_AVAILABLE(macos(10.10), ios(7.0), watchos(1.0))
+#define PCAP_AVAILABLE_1_5	PCAP_API_AVAILABLE(macos(10.10))
 /* #define PCAP_AVAILABLE_1_6	no routines added to the API */
-#define PCAP_AVAILABLE_1_7	PCAP_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-#define PCAP_AVAILABLE_1_8	PCAP_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0)) /* only Windows adds routines to the API; XXX - what version first had it? */
-#define PCAP_AVAILABLE_1_9	PCAP_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-#define PCAP_AVAILABLE_1_10	/* not in macOS yet */
+#define PCAP_AVAILABLE_1_7	PCAP_API_AVAILABLE(macos(10.12))
+#define PCAP_AVAILABLE_1_8	PCAP_API_AVAILABLE(macos(10.13))
+#define PCAP_AVAILABLE_1_9	PCAP_API_AVAILABLE(macos(10.13))
+/*
+ * The remote capture APIs are, in 1.9 and 1.10, usually only
+ * available in the library if the library was built with
+ * remote capture enabled.
+ *
+ * However, macOS Sonoma provides stub versions of those routine,
+ * which return an error.  This means that we need a separate
+ * availability indicator macro for those routines, so that
+ * progras built on macOS Sonoma that attempt to use weak
+ * importing and availability tests to use those routines
+ * if they're available will get those routines weakly imported,
+ * so that if they're run on releases prior to Sonoma, they
+ * won't get an error from dyld about those routines being
+ * missing in libpcap.  (If they don't use run-time availability
+ * tests, they will, instead, get crashes if they call one of
+ * those routines, as the addresses of those routines will be
+ * set to 0 by dyld, meaning the program will dereference a
+ * null pointer and crash when trying to call them.)
+ *
+ * (Not that it's useful to use those routines *anyway*, as they're
+ * stubs that always fail.  The stubs were necessary in order to
+ * support weak exporting at all.)
+ */
+#define PCAP_AVAILABLE_1_9_REMOTE	PCAP_API_AVAILABLE(macos(14.0))
+#define PCAP_AVAILABLE_1_10	PCAP_API_AVAILABLE(macos(12.1))
+#define PCAP_AVAILABLE_1_10_REMOTE	PCAP_API_AVAILABLE(macos(14.0))
 #define PCAP_AVAILABLE_1_11	/* not released yet, so not in macOS yet */
 #else /* __APPLE__ */
 #define PCAP_AVAILABLE_0_4
@@ -224,7 +241,9 @@
 #define PCAP_AVAILABLE_1_7
 #define PCAP_AVAILABLE_1_8
 #define PCAP_AVAILABLE_1_9
+#define PCAP_AVAILABLE_1_9_REMOTE
 #define PCAP_AVAILABLE_1_10
+#define PCAP_AVAILABLE_1_10_REMOTE
 #define PCAP_AVAILABLE_1_11
 #endif /* __APPLE__ */
 
@@ -243,14 +262,15 @@
 #if __has_attribute(noreturn) \
     || PCAP_IS_AT_LEAST_GNUC_VERSION(2,5) \
     || PCAP_IS_AT_LEAST_SUNC_VERSION(5,9) \
-    || PCAP_IS_AT_LEAST_XL_C_VERSION(10,1) \
-    || PCAP_IS_AT_LEAST_HP_C_VERSION(6,10)
+    || PCAP_IS_AT_LEAST_XL_C_VERSION(7,0) \
+    || PCAP_IS_AT_LEAST_HP_C_VERSION(6,10) \
+    || __TINYC__
   /*
    * Compiler with support for __attribute((noreturn)), or GCC 2.5 and
    * later, or some compiler asserting compatibility with GCC 2.5 and
-   * later, or Solaris Studio 12 (Sun C 5.9) and later, or IBM XL C 10.1
+   * later, or Solaris Studio 12 (Sun C 5.9) and later, or IBM XL C 7.0
    * and later (do any earlier versions of XL C support this?), or HP aCC
-   * A.06.10 and later.
+   * A.06.10 and later, or current TinyCC.
    */
   #define PCAP_NORETURN __attribute((noreturn))
   #define PCAP_NORETURN_DEF __attribute((noreturn))
@@ -273,11 +293,11 @@
  */
 #if __has_attribute(__format__) \
     || PCAP_IS_AT_LEAST_GNUC_VERSION(2,3) \
-    || PCAP_IS_AT_LEAST_XL_C_VERSION(10,1) \
+    || PCAP_IS_AT_LEAST_XL_C_VERSION(7,0) \
     || PCAP_IS_AT_LEAST_HP_C_VERSION(6,10)
   /*
    * Compiler with support for it, or GCC 2.3 and later, or some compiler
-   * asserting compatibility with GCC 2.3 and later, or IBM XL C 10.1
+   * asserting compatibility with GCC 2.3 and later, or IBM XL C 7.0
    * and later (do any earlier versions of XL C support this?),
    * or HP aCC A.06.10 and later.
    */
diff --git a/pcap/namedb.h b/pcap/namedb.h
index 51d1e318..28a60a4c 100644
--- a/pcap/namedb.h
+++ b/pcap/namedb.h
@@ -34,6 +34,10 @@
 #ifndef lib_pcap_namedb_h
 #define lib_pcap_namedb_h
 
+#include <stdio.h>		/* FILE */
+
+#include <pcap/funcattrs.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -55,25 +59,46 @@ struct pcap_etherent {
 #ifndef PCAP_ETHERS_FILE
 #define PCAP_ETHERS_FILE "/etc/ethers"
 #endif
+
+PCAP_AVAILABLE_0_4
 PCAP_API struct	pcap_etherent *pcap_next_etherent(FILE *);
+
+PCAP_AVAILABLE_0_4
 PCAP_API u_char *pcap_ether_hostton(const char*);
+
+PCAP_AVAILABLE_0_4
 PCAP_API u_char *pcap_ether_aton(const char *);
 
+PCAP_AVAILABLE_0_4
 PCAP_API
 PCAP_DEPRECATED("this is not reentrant; use 'pcap_nametoaddrinfo' instead")
 bpf_u_int32 **pcap_nametoaddr(const char *);
+
+PCAP_AVAILABLE_0_7
 PCAP_API struct addrinfo *pcap_nametoaddrinfo(const char *);
+
+PCAP_AVAILABLE_0_4
 PCAP_API bpf_u_int32 pcap_nametonetaddr(const char *);
 
+PCAP_AVAILABLE_0_4
 PCAP_API int	pcap_nametoport(const char *, int *, int *);
+
+PCAP_AVAILABLE_0_9
 PCAP_API int	pcap_nametoportrange(const char *, int *, int *, int *);
+
+PCAP_AVAILABLE_0_4
 PCAP_API int	pcap_nametoproto(const char *);
+
+PCAP_AVAILABLE_0_4
 PCAP_API int	pcap_nametoeproto(const char *);
+
+PCAP_AVAILABLE_0_9
 PCAP_API int	pcap_nametollc(const char *);
+
 /*
  * If a protocol is unknown, PROTO_UNDEF is returned.
  * Also, pcap_nametoport() returns the protocol along with the port number.
- * If there are ambiguous entried in /etc/services (i.e. domain
+ * If there are ambiguous entries in /etc/services (i.e. domain
  * can be either tcp or udp) PROTO_UNDEF is returned.
  */
 #define PROTO_UNDEF		-1
diff --git a/pcap/nflog.h b/pcap/nflog.h
index f7c85b54..919c88d2 100644
--- a/pcap/nflog.h
+++ b/pcap/nflog.h
@@ -85,7 +85,7 @@ typedef struct nflog_timestamp {
 #define NFULA_PREFIX			10	/* text string - null-terminated, count includes NUL */
 #define NFULA_UID			11	/* UID owning socket on which packet was sent/received */
 #define NFULA_SEQ			12	/* sequence number of packets on this NFLOG socket */
-#define NFULA_SEQ_GLOBAL		13	/* sequence number of pakets on all NFLOG sockets */
+#define NFULA_SEQ_GLOBAL		13	/* sequence number of packets on all NFLOG sockets */
 #define NFULA_GID			14	/* GID owning socket on which packet was sent/received */
 #define NFULA_HWTYPE			15	/* ARPHRD_ type of skbuff's device */
 #define NFULA_HWHEADER			16	/* skbuff's MAC-layer header */
diff --git a/pcap/pcap-inttypes.h b/pcap/pcap-inttypes.h
index 8c7b4f65..efaf6081 100644
--- a/pcap/pcap-inttypes.h
+++ b/pcap/pcap-inttypes.h
@@ -74,7 +74,7 @@
 #else /* defined(_MSC_VER) */
   /*
    * Not Visual Studio.
-   * Include <inttypes.h> to get the integer types and PRi[doux]64 values
+   * Include <inttypes.h> to get the integer types and PRI[doux]64 values
    * defined.
    *
    * If the compiler is MinGW, we assume we have <inttypes.h> - and
diff --git a/pcap/pcap.h b/pcap/pcap.h
index 6894b3cd..e014335b 100644
--- a/pcap/pcap.h
+++ b/pcap/pcap.h
@@ -127,7 +127,7 @@
   #include <sys/time.h>
 #endif /* _WIN32/MSDOS/UN*X */
 
-#include <pcap/socket.h>	/* for SOCKET, as the active-mode rpcap APIs use it */
+#include <pcap/socket.h>	/* for PCAP_SOCKET, as the active-mode rpcap APIs use it */
 
 #ifndef PCAP_DONT_INCLUDE_PCAP_BPF_H
 #include <pcap/bpf.h>
@@ -208,18 +208,66 @@ struct pcap_file_header {
 	bpf_u_int32 magic;
 	u_short version_major;
 	u_short version_minor;
-	bpf_int32 thiszone;	/* gmt to local correction; this is always 0 */
-	bpf_u_int32 sigfigs;	/* accuracy of timestamps; this is always 0 */
+	bpf_int32 thiszone;	/* not used - SHOULD be filled with 0 */
+	bpf_u_int32 sigfigs;	/* not used - SHOULD be filled with 0 */
 	bpf_u_int32 snaplen;	/* max length saved portion of each pkt */
 	bpf_u_int32 linktype;	/* data link type (LINKTYPE_*) */
 };
 
 /*
- * Macros for the value returned by pcap_datalink_ext().
- *
- * If LT_FCS_LENGTH_PRESENT(x) is true, the LT_FCS_LENGTH(x) macro
- * gives the FCS length of packets in the capture.
+ * Subfields of the field containing the link-layer header type.
+ *
+ * Link-layer header types are assigned for both pcap and
+ * pcapng, and the same value must work with both.  In pcapng,
+ * the link-layer header type field in an Interface Description
+ * Block is 16 bits, so only the bottommost 16 bits of the
+ * link-layer header type in a pcap file can be used for the
+ * header type value.
+ *
+ * In libpcap, the upper 16 bits, from the top down, are divided into:
+ *
+ *    A 4-bit "FCS length" field, to allow the FCS length to
+ *    be specified, just as it can be specified in the if_fcslen
+ *    field of the pcapng IDB.  The field is in units of 16 bits,
+ *    i.e. 1 means 16 bits of FCS, 2 means 32 bits of FCS, etc..
+ *
+ *    A reserved bit, which must be zero.
+ *
+ *    An "FCS length present" flag; if 0, the "FCS length" field
+ *    should be ignored, and if 1, the "FCS length" field should
+ *    be used.
+ *
+ *    10 reserved bits, which must be zero.  They were originally
+ *    intended to be used as a "class" field, allowing additional
+ *    classes of link-layer types to be defined, with a class value
+ *    of 0 indicating that the link-layer type is a LINKTYPE_ value.
+ *    A value of 0x224 was, at one point, used by NetBSD to define
+ *    "raw" packet types, with the lower 16 bits containing a
+ *    NetBSD AF_ value; see
+ *
+ *        https://marc.info/?l=tcpdump-workers&m=98296750229149&w=2
+ *
+ *    It's unknown whether those were ever used in capture files,
+ *    or if the intent was just to use it as a link-layer type
+ *    for BPF programs; NetBSD's libpcap used to support them in
+ *    the BPF code generator, but it no longer does so.  If it
+ *    was ever used in capture files, or if classes other than
+ *    "LINKTYPE_ value" are ever useful in capture files, we could
+ *    re-enable this, and use the reserved 16 bits following the
+ *    link-layer type in pcapng files to hold the class information
+ *    there.  (Note, BTW, that LINKTYPE_RAW/DLT_RAW is now being
+ *    interpreted by libpcap, tcpdump, and Wireshark as "raw IP",
+ *    including both IPv4 and IPv6, with the version number in the
+ *    header being checked to see which it is, not just "raw IPv4";
+ *    there are LINKTYPE_IPV4/DLT_IPV4 and LINKTYPE_IPV6/DLT_IPV6
+ *    values if "these are IPv{4,6} and only IPv{4,6} packets"
+ *    types are needed.)
+ *
+ *    Or we might be able to use it for other purposes.
  */
+#define LT_LINKTYPE(x)			((x) & 0x0000FFFF)
+#define LT_LINKTYPE_EXT(x)		((x) & 0xFFFF0000)
+#define LT_RESERVED1(x)			((x) & 0x03FF0000)
 #define LT_FCS_LENGTH_PRESENT(x)	((x) & 0x04000000)
 #define LT_FCS_LENGTH(x)		(((x) & 0xF0000000) >> 28)
 #define LT_FCS_DATALINK_EXT(x)		((((x) & 0xF) << 28) | 0x04000000)
@@ -348,6 +396,7 @@ typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,
 #define PCAP_ERROR_CANTSET_TSTAMP_TYPE	-10	/* this device doesn't support setting the time stamp type */
 #define PCAP_ERROR_PROMISC_PERM_DENIED	-11	/* you don't have permission to capture in promiscuous mode */
 #define PCAP_ERROR_TSTAMP_PRECISION_NOTSUP -12  /* the requested time stamp precision is not supported */
+#define PCAP_ERROR_CAPTURE_NOTSUP	-13	/* capture mechanism not available */
 
 /*
  * Warning codes for the pcap API.
@@ -650,7 +699,7 @@ PCAP_API const char *pcap_datalink_val_to_name(int);
 PCAP_AVAILABLE_0_8
 PCAP_API const char *pcap_datalink_val_to_description(int);
 
-PCAP_AVAILABLE_1_10
+PCAP_AVAILABLE_1_9
 PCAP_API const char *pcap_datalink_val_to_description_or_dlt(int);
 
 PCAP_AVAILABLE_0_4
@@ -1082,15 +1131,15 @@ struct pcap_rmtauth
  * For opening a remote capture, pcap_open() is currently the only
  * API available.
  */
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API pcap_t	*pcap_open(const char *source, int snaplen, int flags,
 	    int read_timeout, struct pcap_rmtauth *auth, char *errbuf);
 
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API int	pcap_createsrcstr(char *source, int type, const char *host,
 	    const char *port, const char *name, char *errbuf);
 
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API int	pcap_parsesrcstr(const char *source, int *type, char *host,
 	    char *port, char *name, char *errbuf);
 
@@ -1113,7 +1162,7 @@ PCAP_API int	pcap_parsesrcstr(const char *source, int *type, char *host,
  * For listing remote capture devices, pcap_findalldevs_ex() is currently
  * the only API available.
  */
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API int	pcap_findalldevs_ex(const char *source,
 	    struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf);
 
@@ -1184,7 +1233,7 @@ struct pcap_samp
 /*
  * New functions.
  */
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API struct pcap_samp *pcap_setsampling(pcap_t *p);
 
 /*
@@ -1194,24 +1243,24 @@ PCAP_API struct pcap_samp *pcap_setsampling(pcap_t *p);
 /* Maximum length of an host name (needed for the RPCAP active mode) */
 #define RPCAP_HOSTLIST_SIZE 1024
 
-PCAP_AVAILABLE_1_9
-PCAP_API SOCKET	pcap_remoteact_accept(const char *address, const char *port,
+PCAP_AVAILABLE_1_9_REMOTE
+PCAP_API PCAP_SOCKET	pcap_remoteact_accept(const char *address, const char *port,
 	    const char *hostlist, char *connectinghost,
 	    struct pcap_rmtauth *auth, char *errbuf);
 
-PCAP_AVAILABLE_1_10
-PCAP_API SOCKET	pcap_remoteact_accept_ex(const char *address, const char *port,
+PCAP_AVAILABLE_1_10_REMOTE
+PCAP_API PCAP_SOCKET	pcap_remoteact_accept_ex(const char *address, const char *port,
 	    const char *hostlist, char *connectinghost,
 	    struct pcap_rmtauth *auth, int uses_ssl, char *errbuf);
 
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API int	pcap_remoteact_list(char *hostlist, char sep, int size,
 	    char *errbuf);
 
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API int	pcap_remoteact_close(const char *host, char *errbuf);
 
-PCAP_AVAILABLE_1_9
+PCAP_AVAILABLE_1_9_REMOTE
 PCAP_API void	pcap_remoteact_cleanup(void);
 
 #ifdef __cplusplus
diff --git a/pcap/sll.h b/pcap/sll.h
index 392faae4..3d8c9020 100644
--- a/pcap/sll.h
+++ b/pcap/sll.h
@@ -145,5 +145,6 @@ struct sll2_header {
 #define LINUX_SLL_P_802_2	0x0004	/* 802.2 frames (not D/I/X Ethernet) */
 #define LINUX_SLL_P_CAN		0x000C	/* CAN frames, with SocketCAN pseudo-headers */
 #define LINUX_SLL_P_CANFD	0x000D	/* CAN FD frames, with SocketCAN pseudo-headers */
+#define LINUX_SLL_P_CANXL	0x000E	/* CAN XL frames, with SocketCAN pseudo-headers */
 
 #endif
diff --git a/pcap/socket.h b/pcap/socket.h
index ee2e393e..b1a864b5 100644
--- a/pcap/socket.h
+++ b/pcap/socket.h
@@ -48,6 +48,26 @@
   #include <winsock2.h>
   #include <ws2tcpip.h>
 
+  /*!
+   * \brief In Winsock, a socket handle is of type SOCKET; in UN*X, it's
+   * a file descriptor, and therefore a signed integer.
+   * We define PCAP_SOCKET to be a signed integer on UN*X and a
+   * SOCKET on Windows, so that it can be used on both platforms.
+   *
+   * We used to use SOCKET rather than PCAP_SOCKET, but that collided
+   * with other software, such as barnyard2, which had their own
+   * definitions of SOCKET, so we changed it to PCAP_SOCKET.
+   *
+   * On Windows, this shouldn't break any APIs, as any code using
+   * the two active-mode APIs that return a socket handle would
+   * probably be assigning their return values to a SOCKET, and
+   * as, on Windows, we're defining PCAP_SOCKET as SOCKET, there
+   * would be no type clash.
+   */
+  #ifndef PCAP_SOCKET
+    #define PCAP_SOCKET SOCKET
+  #endif
+
   /*
    * Winsock doesn't have this POSIX type; it's used for the
    * tv_usec value of struct timeval.
@@ -61,13 +81,37 @@
   #include <arpa/inet.h>
 
   /*!
-   * \brief In Winsock, a socket handle is of type SOCKET; in UN*X, it's
-   * a file descriptor, and therefore a signed integer.
-   * We define SOCKET to be a signed integer on UN*X, so that it can
-   * be used on both platforms.
+   * \brief In Winsock, a socket handle is of type SOCKET; in UN*Xes,
+   * it's a file descriptor, and therefore a signed integer.
+   * We define PCAP_SOCKET to be a signed integer on UN*X and a
+   * SOCKET on Windows, so that it can be used on both platforms.
+   *
+   * We used to use SOCKET rather than PCAP_SOCKET, but that collided
+   * with other software, such as barnyard2, which had their own
+   * definitions of SOCKET, so we changed it to PCAP_SOCKET.
+   *
+   * On UN*Xes, this might break code that uses one of the two
+   * active-mode APIs that return a socket handle if those programs
+   * were written to assign the return values of those APIs to a
+   * SOCKET, as we're no longer defining SOCKET.  However, as
+   * those APIs are only provided if libpcap is built with remote
+   * capture support - which is not the default - and as they're
+   * somewhat painful to use, there's probably little if any code
+   * that needs to compile for UN*X and that uses them.  If there
+   * *is* any such code, it could do
+   *
+   *    #ifndef PCAP_SOCKET
+   *        #ifdef _WIN32
+   *            #define PCAP_SOCKET SOCKET
+   *        #else
+   *            #defube PCAP_SOCKET int
+   *        #endif
+   *    #endif
+   *
+   * and use PCAP_SOCKET.
    */
-  #ifndef SOCKET
-    #define SOCKET int
+  #ifndef PCAP_SOCKET
+    #define PCAP_SOCKET int
   #endif
 
   /*!
diff --git a/pcap/usb.h b/pcap/usb.h
index e485ec85..48dc9064 100644
--- a/pcap/usb.h
+++ b/pcap/usb.h
@@ -125,6 +125,12 @@ typedef struct _usb_header_mmapped {
 	uint32_t ndesc;	/* number of isochronous descriptors */
 } pcap_usb_header_mmapped;
 
+/*
+ * Maximum number of descriptors supported.
+ * It's currently 128 in the Linux binary USB monitoring code.
+ */
+#define USB_MAXDESC	128
+
 /*
  * Isochronous descriptors; for isochronous transfers there might be
  * one or more of these at the beginning of the packet data.  The
diff --git a/pcap_activate.3pcap b/pcap_activate.3pcap
index 169a7565..95946413 100644
--- a/pcap_activate.3pcap
+++ b/pcap_activate.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_ACTIVATE 3PCAP "24 November 2019"
+.TH PCAP_ACTIVATE 3PCAP "3 June 2024"
 .SH NAME
 pcap_activate \- activate a capture handle
 .SH SYNOPSIS
@@ -89,6 +89,9 @@ monitor mode.
 .B PCAP_ERROR_IFACE_NOT_UP
 The capture source device is not up.
 .TP
+.B PCAP_ERROR_CAPTURE_NOTSUP
+Packet capture is not supported on the capture source.
+.TP
 .B PCAP_ERROR
 Another error occurred.
 .BR pcap_geterr ()
@@ -101,8 +104,9 @@ as an argument to fetch or display a message describing the error.
 If
 .BR PCAP_WARNING_PROMISC_NOTSUP ,
 .BR PCAP_ERROR_NO_SUCH_DEVICE ,
+.BR PCAP_ERROR_PERM_DENIED ,
 or
-.B PCAP_ERROR_PERM_DENIED
+.B PCAP_ERROR_CAPTURE_NOTSUP
 is returned,
 .BR pcap_geterr ()
 or
@@ -124,8 +128,8 @@ message describing the warning or error code.
 If
 .BR pcap_activate ()
 fails, the
-.I pcap_t *
+.B pcap_t *
 is not closed and freed; it should be closed using
-.BR pcap_close ().
+.BR pcap_close (3PCAP).
 .SH SEE ALSO
 .BR pcap (3PCAP)
diff --git a/pcap_breakloop.3pcap b/pcap_breakloop.3pcap
index 3cd74db2..b5e59883 100644
--- a/pcap_breakloop.3pcap
+++ b/pcap_breakloop.3pcap
@@ -77,6 +77,7 @@ blocked in pcap_dispatch(), pcap_loop(), pcap_next(3PCAP), or
 pcap_next_ex(3PCAP), a call to pcap_breakloop() in a different thread
 will only unblock that thread on the platforms and capture devices
 listed above.
+.ft R
 .PP
 If a non-zero packet buffer timeout is set on the
 .BR pcap_t ,
@@ -91,7 +92,6 @@ network interface, you will need to use whatever mechanism the OS
 provides for breaking a thread out of blocking calls in order to unblock
 the thread, such as thread cancellation or thread signalling in systems
 that support POSIX threads.
-.ft R
 .PP
 .ft B
 Note that if pcap_breakloop() unblocks the thread capturing packets, and
diff --git a/pcap_compile.3pcap.in b/pcap_compile.3pcap.in
index 67001fa4..12aa8fe6 100644
--- a/pcap_compile.3pcap.in
+++ b/pcap_compile.3pcap.in
@@ -28,8 +28,7 @@ pcap_compile \- compile a filter expression
 .LP
 .ft B
 int pcap_compile(pcap_t *p, struct bpf_program *fp,
-.ti +8
-const char *str, int optimize, bpf_u_int32 netmask);
+    const char *str, int optimize, bpf_u_int32 netmask);
 .ft
 .fi
 .SH DESCRIPTION
diff --git a/pcap_create.3pcap b/pcap_create.3pcap
index bd42d733..f08ac5c2 100644
--- a/pcap_create.3pcap
+++ b/pcap_create.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_CREATE 3PCAP "3 January 2014"
+.TH PCAP_CREATE 3PCAP "30 November 2023"
 .SH NAME
 pcap_create \- create a live capture handle
 .SH SYNOPSIS
@@ -46,6 +46,10 @@ with 2.2 or later kernels, a
 argument of "any" or
 .B NULL
 can be used to capture packets from all interfaces.
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
 .PP
 The returned handle must be activated with
 .BR pcap_activate (3PCAP)
@@ -55,7 +59,7 @@ on the handle before activating it.
 .SH RETURN VALUE
 .BR pcap_create ()
 returns a
-.I pcap_t *
+.B pcap_t *
 on success and
 .B NULL
 on failure.
@@ -64,9 +68,5 @@ If
 is returned,
 .I errbuf
 is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH SEE ALSO
 .BR pcap (3PCAP)
diff --git a/pcap_dump.3pcap b/pcap_dump.3pcap
index ba7f75ad..e38c96ce 100644
--- a/pcap_dump.3pcap
+++ b/pcap_dump.3pcap
@@ -28,8 +28,7 @@ pcap_dump \- write a packet to a capture file
 .LP
 .ft B
 void pcap_dump(u_char *user, struct pcap_pkthdr *h,
-.ti +8
-u_char *sp);
+    u_char *sp);
 .ft
 .fi
 .SH DESCRIPTION
diff --git a/pcap_findalldevs.3pcap b/pcap_findalldevs.3pcap
index 0dcc0af6..987d2a74 100644
--- a/pcap_findalldevs.3pcap
+++ b/pcap_findalldevs.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_FINDALLDEVS 3PCAP "23 August 2018"
+.TH PCAP_FINDALLDEVS 3PCAP "9 August 2024"
 .SH NAME
 pcap_findalldevs, pcap_freealldevs \- get a list of capture devices, and
 free that list
@@ -51,6 +51,14 @@ process calling
 because, for example, that process does not have sufficient privileges
 to open them for capturing; if so, those devices will not appear on the
 list.)
+.I alldevsp
+is a pointer to a
+.BR "pcap_if_t *" ;
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
+.PP
 If
 .BR pcap_findalldevs ()
 succeeds, the pointer pointed to by
@@ -158,7 +166,9 @@ a pointer to a
 that contains the broadcast address corresponding to the address pointed
 to by
 .BR addr ;
-may be null if the device doesn't support broadcasts
+may be
+.B NULL
+if the device doesn't support broadcasts
 .TP
 .B dstaddr
 if not
@@ -168,7 +178,9 @@ a pointer to a
 that contains the destination address corresponding to the address pointed
 to by
 .BR addr ;
-may be null if the device isn't a point-to-point interface
+may be
+.B NULL
+if the device isn't a point-to-point interface
 .RE
 .PP
 Note that the addresses in the list of addresses might be IPv4
@@ -186,12 +198,27 @@ IPv6 addresses have the value
 (which older operating systems that don't support IPv6 might not
 define), and other addresses have other values.  Whether other addresses
 are returned, and what types they might have is platform-dependent.
+Namely, link-layer addresses, such as Ethernet MAC addresses, have the value
+.B AF_PACKET
+(on Linux) or
+.B AF_LINK
+(on AIX, FreeBSD, Haiku, illumos, macOS, NetBSD and OpenBSD) or are not
+returned at all (on GNU/Hurd and Solaris).
+.PP
 For IPv4 addresses, the
 .B "struct sockaddr"
 pointer can be interpreted as if it pointed to a
 .BR "struct sockaddr_in" ;
 for IPv6 addresses, it can be interpreted as if it pointed to a
 .BR "struct sockaddr_in6".
+For link-layer addresses, it can be interpreted as if it pointed to a
+.B "struct sockaddr_ll"
+(for
+.BR AF_PACKET )
+or a
+.B "struct sockaddr_dl"
+(for
+.BR AF_LINK ).
 .PP
 The list of devices must be freed with
 .BR pcap_freealldevs (3PCAP),
@@ -211,11 +238,11 @@ returned in that case. If
 .B PCAP_ERROR
 is returned,
 .I errbuf
-is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
+is filled in with an appropriate error message,
+and the pointer pointed to by
+.I alldevsp
+is set to
+.BR NULL .
 .SH BACKWARD COMPATIBILITY
 .PP
 The
diff --git a/pcap_init.3pcap b/pcap_init.3pcap
index a807d0ec..3bef7dcd 100644
--- a/pcap_init.3pcap
+++ b/pcap_init.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_INIT 3PCAP "4 May 2022"
+.TH PCAP_INIT 3PCAP "30 November 2023"
 .SH NAME
 pcap_init \- initialize the library
 .SH SYNOPSIS
@@ -40,7 +40,14 @@ int pcap_init(unsigned int opts, char *errbuf);
 is used to initialize the Packet Capture library.
 .I opts
 specifies options for the library;
-currently, the options are:
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
+.PP
+Currently, the options that can be specified in
+.I opts
+are:
 .TP
 .B PCAP_CHAR_ENC_LOCAL
 Treat all strings supplied as arguments, and return all strings to the
@@ -87,10 +94,6 @@ If
 is returned,
 .I errbuf
 is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH BACKWARD COMPATIBILITY
 This function became available in libpcap release 1.9.0.  In previous
 releases, on Windows, all strings supplied as arguments, and all strings
diff --git a/pcap_lookupdev.3pcap b/pcap_lookupdev.3pcap
index b5d548f0..b4a305da 100644
--- a/pcap_lookupdev.3pcap
+++ b/pcap_lookupdev.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_LOOKUPDEV 3PCAP "8 September 2017"
+.TH PCAP_LOOKUPDEV 3PCAP "30 November 2023"
 .SH NAME
 pcap_lookupdev \- find the default device on which to capture
 .SH SYNOPSIS
@@ -43,6 +43,10 @@ To find a default device on which to capture, call
 and, if the list it returns is not empty, use the first device in the
 list.  (If the list is empty, there are no devices on which capture is
 possible.)
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
 .LP
 .B If
 .BR pcap_init (3PCAP)
@@ -67,10 +71,6 @@ has been called,
 is returned and
 .I errbuf
 is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH SEE ALSO
 .BR pcap (3PCAP)
 .SH BUGS
diff --git a/pcap_lookupnet.3pcap b/pcap_lookupnet.3pcap
index c12fa55e..5decea57 100644
--- a/pcap_lookupnet.3pcap
+++ b/pcap_lookupnet.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_LOOKUPNET 3PCAP "25 July 2018"
+.TH PCAP_LOOKUPNET 3PCAP "13 March 2024"
 .SH NAME
 pcap_lookupnet \- find the IPv4 network number and netmask for a device
 .SH SYNOPSIS
@@ -33,8 +33,7 @@ char errbuf[PCAP_ERRBUF_SIZE];
 .LP
 .ft B
 int pcap_lookupnet(const char *device, bpf_u_int32 *netp,
-.ti +8
-bpf_u_int32 *maskp, char *errbuf);
+    bpf_u_int32 *maskp, char *errbuf);
 .ft
 .fi
 .SH DESCRIPTION
@@ -47,8 +46,18 @@ Both
 and
 .I maskp
 are
-.I bpf_u_int32
+.B bpf_u_int32
 pointers.
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
+.LP
+This function is not available on Windows.  It supports neither IPv6 nor
+multiple IPv4 addresses per interface, which obviously is not practical in
+modern networks.  See
+.BR pcap_findalldevs (3PCAP)
+for a more elaborate solution to the problem.
 .SH RETURN VALUE
 .BR pcap_lookupnet ()
 returns
@@ -60,9 +69,5 @@ on failure. If
 is returned,
 .I errbuf
 is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH SEE ALSO
 .BR pcap (3PCAP)
diff --git a/pcap_loop.3pcap b/pcap_loop.3pcap
index 0c595262..3f2fe312 100644
--- a/pcap_loop.3pcap
+++ b/pcap_loop.3pcap
@@ -28,17 +28,11 @@ pcap_loop, pcap_dispatch \- process packets from a live capture or savefile
 .LP
 .ft B
 typedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h,
-.ti +8
-			     const u_char *bytes);
-.ft
-.LP
-.ft B
+    const u_char *bytes);
 int pcap_loop(pcap_t *p, int cnt,
-.ti +8
-pcap_handler callback, u_char *user);
+    pcap_handler callback, u_char *user);
 int pcap_dispatch(pcap_t *p, int cnt,
-.ti +8
-pcap_handler callback, u_char *user);
+    pcap_handler callback, u_char *user);
 .ft
 .fi
 .SH DESCRIPTION
@@ -94,10 +88,10 @@ but must not rely on it happening.
 .PP
 .I callback
 specifies a
-.I pcap_handler
+.B pcap_handler
 routine to be called with three arguments:
 a
-.I u_char
+.B u_char
 pointer which is passed in the
 .I user
 argument to
@@ -105,16 +99,16 @@ argument to
 or
 .BR pcap_dispatch (),
 a
-.I const struct pcap_pkthdr
+.B const struct pcap_pkthdr
 pointer pointing to the packet time stamp and lengths, and a
-.I const u_char
+.B const u_char
 pointer to the first
 .B caplen
 (as given in the
-.I struct pcap_pkthdr
+.BR "struct pcap_pkthdr" ,
 a pointer to which is passed to the callback routine)
 bytes of data from the packet.  The
-.I struct pcap_pkthdr
+.B struct pcap_pkthdr
 and the packet data are not to be freed by the callback routine, and are
 not guaranteed to be valid after the callback routine returns; if the
 code needs them to be valid after the callback, it must make a copy of
diff --git a/pcap_next_ex.3pcap b/pcap_next_ex.3pcap
index 4d2c43e8..c6143eed 100644
--- a/pcap_next_ex.3pcap
+++ b/pcap_next_ex.3pcap
@@ -28,8 +28,7 @@ pcap_next_ex, pcap_next \- read the next packet from a pcap_t
 .LP
 .ft B
 int pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,
-.ti +8
-const u_char **pkt_data);
+    const u_char **pkt_data);
 const u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h);
 .ft
 .fi
@@ -39,12 +38,12 @@ reads the next packet and returns a success/failure indication.
 If the packet was read without problems, the pointer pointed to by the
 .I pkt_header
 argument is set to point to the
-.I pcap_pkthdr
+.B pcap_pkthdr
 struct for the packet, and the
 pointer pointed to by the
 .I pkt_data
 argument is set to point to the data in the packet.  The
-.I struct pcap_pkthdr
+.B struct pcap_pkthdr
 and the packet data are not to be freed by the caller, and are not
 guaranteed to be valid after the next call to
 .BR pcap_next_ex (),
@@ -60,7 +59,7 @@ reads the next packet (by calling
 with a
 .I cnt
 of 1) and returns a
-.I u_char
+.B u_char
 pointer to the data in that packet.  The
 packet data is not to be freed by the caller, and is not
 guaranteed to be valid after the next call to
@@ -71,7 +70,7 @@ or
 .BR pcap_dispatch ();
 if the code needs it to remain valid, it must make a copy of it.
 The
-.I pcap_pkthdr
+.B pcap_pkthdr
 structure pointed to by
 .I h
 is filled in with the appropriate values for the packet.
diff --git a/pcap_offline_filter.3pcap b/pcap_offline_filter.3pcap
index dbb6e966..94b9a719 100644
--- a/pcap_offline_filter.3pcap
+++ b/pcap_offline_filter.3pcap
@@ -28,8 +28,7 @@ pcap_offline_filter \- check whether a filter matches a packet
 .LP
 .ft B
 int pcap_offline_filter(const struct bpf_program *fp,
-.ti +8
-const struct pcap_pkthdr *h, const u_char *pkt)
+    const struct pcap_pkthdr *h, const u_char *pkt);
 .ft
 .fi
 .SH DESCRIPTION
diff --git a/pcap_open_live.3pcap b/pcap_open_live.3pcap
index b8c17299..11308518 100644
--- a/pcap_open_live.3pcap
+++ b/pcap_open_live.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_OPEN_LIVE 3PCAP "6 December 2017"
+.TH PCAP_OPEN_LIVE 3PCAP "4 March 2024"
 .SH NAME
 pcap_open_live \- open a device for capturing
 .SH SYNOPSIS
@@ -33,8 +33,7 @@ char errbuf[PCAP_ERRBUF_SIZE];
 .LP
 .ft B
 pcap_t *pcap_open_live(const char *device, int snaplen,
-.ti +8
-int promisc, int to_ms, char *errbuf);
+    int promisc, int to_ms, char *errbuf);
 .ft
 .fi
 .SH DESCRIPTION
@@ -42,15 +41,21 @@ int promisc, int to_ms, char *errbuf);
 is used to obtain a packet capture handle to look
 at packets on the network.
 .I device
-is a string that specifies the network device to open; on Linux systems
-with 2.2 or later kernels, a
+is a string that specifies the network device to open; on all supported Linux
+systems, as well as on recent versions of macOS and Solaris, a
 .I device
 argument of "any" or
 .B NULL
-can be used to capture packets from all interfaces.
+can be used to capture packets from all network interfaces.  The latter should
+not be confused with all available capture devices as seen by
+.BR pcap_findalldevs (3PCAP),
+which may also include D-Bus, USB etc.
 .PP
 .I snaplen
-specifies the snapshot length to be set on the handle.
+specifies the snapshot length to be set on the handle.  If the packet
+data should not be truncated at the end, a value of 262144 should be
+sufficient for most devices, but D-Bus devices require a value of 128MB
+(128*1024*1024).
 .PP
 .I promisc
 specifies whether the interface is to be put into promiscuous mode.
@@ -63,10 +68,15 @@ specifies the packet buffer timeout, as a non-negative value, in
 milliseconds.  (See
 .BR pcap (3PCAP)
 for an explanation of the packet buffer timeout.)
+.PP
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
 .SH RETURN VALUE
 .BR pcap_open_live ()
 returns a
-.I pcap_t *
+.B pcap_t *
 on success and
 .B NULL
 on failure.
@@ -85,10 +95,6 @@ before calling
 and display the warning to the user if
 .I errbuf
 is no longer a zero-length string.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH SEE ALSO
 .BR pcap_create (3PCAP),
 .BR pcap_activate (3PCAP)
diff --git a/pcap_open_offline.3pcap.in b/pcap_open_offline.3pcap.in
index e48bf25e..eca22660 100644
--- a/pcap_open_offline.3pcap.in
+++ b/pcap_open_offline.3pcap.in
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_OPEN_OFFLINE 3PCAP "23 August 2018"
+.TH PCAP_OPEN_OFFLINE 3PCAP "30 November 2023"
 .SH NAME
 pcap_open_offline, pcap_open_offline_with_tstamp_precision,
 pcap_fopen_offline, pcap_fopen_offline_with_tstamp_precision \- open a saved capture file for reading
@@ -86,6 +86,11 @@ takes an additional
 .I precision
 argument as described above.
 Note that on Windows, that stream should be opened in binary mode.
+.PP
+.I errbuf
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
 .SH RETURN VALUE
 .BR pcap_open_offline (),
 .BR pcap_open_offline_with_tstamp_precision (),
@@ -93,7 +98,7 @@ Note that on Windows, that stream should be opened in binary mode.
 and
 .BR pcap_fopen_offline_with_tstamp_precision ()
 return a
-.I pcap_t *
+.B pcap_t *
 on success and
 .B NULL
 on failure.
@@ -102,10 +107,6 @@ If
 is returned,
 .I errbuf
 is filled in with an appropriate error message.
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH BACKWARD COMPATIBILITY
 .BR pcap_open_offline_with_tstamp_precision ()
 and
diff --git a/pcap_set_tstamp_precision.3pcap.in b/pcap_set_tstamp_precision.3pcap.in
index 1889f43d..ab27ce59 100644
--- a/pcap_set_tstamp_precision.3pcap.in
+++ b/pcap_set_tstamp_precision.3pcap.in
@@ -44,7 +44,8 @@ that has not yet been activated by
 .BR pcap_activate (3PCAP).
 Two time stamp precisions are supported, microseconds and nanoseconds. One can
 use options
-.B PCAP_TSTAMP_PRECISION_MICRO and
+.B PCAP_TSTAMP_PRECISION_MICRO
+and
 .B PCAP_TSTAMP_PRECISION_NANO
 to request desired precision. By default, time stamps are in microseconds.
 .SH RETURN VALUE
diff --git a/pcap_setnonblock.3pcap b/pcap_setnonblock.3pcap
index 1f336474..67228191 100644
--- a/pcap_setnonblock.3pcap
+++ b/pcap_setnonblock.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_SETNONBLOCK 3PCAP "5 March 2022"
+.TH PCAP_SETNONBLOCK 3PCAP "30 November 2023"
 .SH NAME
 pcap_setnonblock, pcap_getnonblock \- set or get the state of
 non-blocking mode on a capture device
@@ -43,13 +43,10 @@ puts a capture handle into ``non-blocking'' mode, or takes it out
 of ``non-blocking'' mode, depending on whether the
 .I nonblock
 argument is non-zero or zero.  It has no effect on ``savefiles''.
-If there is an error,
-.B PCAP_ERROR
-is returned and
 .I errbuf
-is filled in with an appropriate error message; otherwise,
-.B 0
-is returned.
+is a buffer large enough to hold at least
+.B PCAP_ERRBUF_SIZE
+chars.
 .PP
 In
 ``non-blocking'' mode, an attempt to read from the capture descriptor
@@ -77,29 +74,34 @@ should be used instead.
 When first activated with
 .BR pcap_activate (3PCAP)
 or opened with
-.BR pcap_open_live (3PCAP) ,
+.BR pcap_open_live (3PCAP),
 a capture handle is not in ``non-blocking mode''; a call to
 .BR pcap_setnonblock ()
 is required in order to put it into ``non-blocking'' mode.
 .SH RETURN VALUE
+.BR pcap_setnonblock()
+return 0 on success,
+.B PCAP_ERROR_NOT_ACTIVATED
+if called on a capture handle that has been created but not activated,
+and
+.B PCAP_ERROR
+for other errors.
 .BR pcap_getnonblock ()
-returns the current ``non-blocking'' state of the capture descriptor; it
-always returns
+returns the current ``non-blocking'' state of the capture descriptor on
+success; it always returns
 .B 0
 on ``savefiles''.
-If called on a capture handle that has been created but not activated,
+It returns
 .B PCAP_ERROR_NOT_ACTIVATED
-is returned.
-If there is another error,
+if called on a capture handle that has been created but not activated,
+and
+.B PCAP_ERROR
+for other errors.
+If
 .B PCAP_ERROR
-is returned and
+is returned,
 .I errbuf
 is filled in with an appropriate error message.
-.PP
-.I errbuf
-is assumed to be able to hold at least
-.B PCAP_ERRBUF_SIZE
-chars.
 .SH SEE ALSO
 .BR pcap (3PCAP),
 .BR pcap_next_ex (3PCAP),
diff --git a/pcap_strerror.3pcap b/pcap_strerror.3pcap
index dedfa406..2add6cc1 100644
--- a/pcap_strerror.3pcap
+++ b/pcap_strerror.3pcap
@@ -17,7 +17,7 @@
 .\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 .\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 .\"
-.TH PCAP_STRERROR 3PCAP "3 January 2014"
+.TH PCAP_STRERROR 3PCAP "26 August 2024"
 .SH NAME
 pcap_strerror \- convert an errno value to a string
 .SH SYNOPSIS
@@ -31,10 +31,14 @@ const char *pcap_strerror(int error);
 .ft
 .fi
 .SH DESCRIPTION
-.BR pcap_strerror ()
-is provided in case
-.BR strerror (3)
-isn't available.  It returns an error message string corresponding to
+This function returns an error message string corresponding to
 .IR error .
+It uses either
+.BR strerror (3)
+or its thread-safe variant if one is available, which currently is the case in
+every supported OS.
+.SH BACKWARD COMPATIBILITY
+This function was not thread-safe in libpcap before 1.8.1 on Windows and
+in libpcap before 1.10.5 on all other OSes.
 .SH SEE ALSO
 .BR pcap (3PCAP)
diff --git a/portability.h b/portability.h
index 84d0778a..5a2496c9 100644
--- a/portability.h
+++ b/portability.h
@@ -47,38 +47,38 @@ extern "C" {
 #endif
 
 #ifdef HAVE_STRLCAT
-  #define pcap_strlcat	strlcat
+  #define pcapint_strlcat	strlcat
 #else
   #if defined(_MSC_VER) || defined(__MINGW32__)
     /*
      * strncat_s() is supported at least back to Visual
      * Studio 2005; we require Visual Studio 2015 or later.
      */
-    #define pcap_strlcat(x, y, z) \
+    #define pcapint_strlcat(x, y, z) \
 	strncat_s((x), (z), (y), _TRUNCATE)
   #else
     /*
      * Define it ourselves.
      */
-    extern size_t pcap_strlcat(char * restrict dst, const char * restrict src, size_t dstsize);
+    extern size_t pcapint_strlcat(char * restrict dst, const char * restrict src, size_t dstsize);
   #endif
 #endif
 
 #ifdef HAVE_STRLCPY
-  #define pcap_strlcpy	strlcpy
+  #define pcapint_strlcpy	strlcpy
 #else
   #if defined(_MSC_VER) || defined(__MINGW32__)
     /*
      * strncpy_s() is supported at least back to Visual
      * Studio 2005; we require Visual Studio 2015 or later.
      */
-    #define pcap_strlcpy(x, y, z) \
+    #define pcapint_strlcpy(x, y, z) \
 	strncpy_s((x), (z), (y), _TRUNCATE)
   #else
     /*
      * Define it ourselves.
      */
-    extern size_t pcap_strlcpy(char * restrict dst, const char * restrict src, size_t dstsize);
+    extern size_t pcapint_strlcpy(char * restrict dst, const char * restrict src, size_t dstsize);
   #endif
 #endif
 
@@ -100,16 +100,17 @@ extern "C" {
  * some, but not all, platforms.
  */
 #ifdef HAVE_ASPRINTF
-#define pcap_asprintf asprintf
+#define pcapint_asprintf asprintf
 #else
-extern int pcap_asprintf(char **, PCAP_FORMAT_STRING(const char *), ...)
+extern int pcapint_asprintf(char **, PCAP_FORMAT_STRING(const char *), ...)
     PCAP_PRINTFLIKE(2, 3);
 #endif
 
 #ifdef HAVE_VASPRINTF
-#define pcap_vasprintf vasprintf
+#define pcapint_vasprintf vasprintf
 #else
-extern int pcap_vasprintf(char **, const char *, va_list ap);
+extern int pcapint_vasprintf(char **, PCAP_FORMAT_STRING(const char *), va_list ap)
+    PCAP_PRINTFLIKE(2, 0);
 #endif
 
 /* For Solaris before 11. */
@@ -137,18 +138,18 @@ extern int pcap_vasprintf(char **, const char *, va_list ap);
 #endif /* timersub */
 
 #ifdef HAVE_STRTOK_R
-  #define pcap_strtok_r	strtok_r
+  #define pcapint_strtok_r	strtok_r
 #else
   #ifdef _WIN32
     /*
      * Microsoft gives it a different name.
      */
-    #define pcap_strtok_r	strtok_s
+    #define pcapint_strtok_r	strtok_s
   #else
     /*
      * Define it ourselves.
      */
-    extern char *pcap_strtok_r(char *, const char *, char **);
+    extern char *pcapint_strtok_r(char *, const char *, char **);
   #endif
 #endif /* HAVE_STRTOK_R */
 
diff --git a/ppp.h b/ppp.h
index d6e70c15..d8fcc6fe 100644
--- a/ppp.h
+++ b/ppp.h
@@ -46,7 +46,7 @@
 #define PPP_DECNETCP	0x8027	/* DECnet Control Protocol */
 #define PPP_APPLECP	0x8029	/* Appletalk Control Protocol */
 #define PPP_IPXCP	0x802b	/* Novell IPX Control Protocol */
-#define PPP_STIICP	0x8033	/* Strean Protocol Control Protocol */
+#define PPP_STIICP	0x8033	/* Stream Protocol Control Protocol */
 #define PPP_VINESCP	0x8035	/* Banyan Vines Control Protocol */
 #define PPP_IPV6CP	0x8057	/* IPv6 Control Protocol */
 #define PPP_MPLSCP      0x8281  /* rfc 3022 */
diff --git a/rpcap-protocol.c b/rpcap-protocol.c
index 0cdc0ba3..d1aac8be 100644
--- a/rpcap-protocol.c
+++ b/rpcap-protocol.c
@@ -31,9 +31,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <string.h>		/* for strlen(), ... */
 #include <stdlib.h>		/* for malloc(), free(), ... */
@@ -80,7 +78,7 @@
  * error message is returned in the 'errbuf' variable.
  */
 int
-rpcap_senderror(SOCKET sock, SSL *ssl, uint8 ver, unsigned short errcode, const char *error, char *errbuf)
+rpcap_senderror(PCAP_SOCKET sock, SSL *ssl, uint8 ver, unsigned short errcode, const char *error, char *errbuf)
 {
 	char sendbuf[RPCAP_NETBUF_SIZE];	/* temporary buffer in which data to be sent is buffered */
 	int sendbufidx = 0;			/* index which keeps the number of bytes currently buffered */
diff --git a/rpcap-protocol.h b/rpcap-protocol.h
index a93b0a8b..773a1e48 100644
--- a/rpcap-protocol.h
+++ b/rpcap-protocol.h
@@ -137,6 +137,8 @@ typedef unsigned char uint8;	/* 8-bit unsigned integer */
 typedef unsigned short uint16;	/* 16-bit unsigned integer */
 typedef unsigned int uint32;	/* 32-bit unsigned integer */
 typedef int int32;		/* 32-bit signed integer */
+#else
+#include <os/support/SupportDefs.h>
 #endif
 
 /* Common header for all the RPCAP messages */
@@ -241,7 +243,7 @@ struct rpcap_sockaddr
 /*
  * Format of an IPv4 address as sent over the wire.
  */
-#define RPCAP_AF_INET	2		/* Value on all OSes */
+#define RPCAP_AF_INET	2		/* Value on all OSes except for Haiku */
 struct rpcap_sockaddr_in
 {
 	uint16	family;			/* Address family */
@@ -444,6 +446,6 @@ struct rpcap_sampling
 
 extern void rpcap_createhdr(struct rpcap_header *header, uint8 ver, uint8 type, uint16 value, uint32 length);
 extern const char *rpcap_msg_type_string(uint8 type);
-extern int rpcap_senderror(SOCKET sock, SSL *ssl, uint8 ver, uint16 errcode, const char *error, char *errbuf);
+extern int rpcap_senderror(PCAP_SOCKET sock, SSL *ssl, uint8 ver, uint16 errcode, const char *error, char *errbuf);
 
 #endif
diff --git a/rpcapd/CMakeLists.txt b/rpcapd/CMakeLists.txt
index 8b30be3c..28fd3c24 100644
--- a/rpcapd/CMakeLists.txt
+++ b/rpcapd/CMakeLists.txt
@@ -1,3 +1,4 @@
+message(STATUS "Running rpcapd/CMakeLists.txt")
 if(UNIX)
   check_function_exists(crypt HAVE_CRYPT_IN_SYSTEM_LIBRARIES)
   if(HAVE_CRYPT_IN_SYSTEM_LIBRARIES)
@@ -82,34 +83,8 @@ if(WIN32 OR ((CMAKE_USE_PTHREADS_INIT OR PTHREADS_FOUND) AND HAVE_CRYPT))
   # architectures for the OS on which we're doing the build.
   #
   if(APPLE AND "${CMAKE_OSX_ARCHITECTURES}" STREQUAL "")
-    #
-    # Get the major version of Darwin.
-    #
-    string(REGEX MATCH "^([0-9]+)" SYSTEM_VERSION_MAJOR "${CMAKE_SYSTEM_VERSION}")
-
-    if(SYSTEM_VERSION_MAJOR EQUAL 9)
-      #
-      # Leopard.  Build for 32-bit x86 and 32-bit PowerPC, with
-      # 32-bit x86 first.
-      #
-      set(OSX_PROGRAM_ARCHITECTURES "i386;ppc")
-    elseif(SYSTEM_VERSION_MAJOR EQUAL 10)
-      #
-      # Snow Leopard.  Build for x86-64 and 32-bit x86, with
-      # x86-64 first.
-      #
-      set(OSX_PROGRAM_ARCHITECTURES "x86_64;i386")
-    else()
-      #
-      # Post-Snow Leopard.  Build only for x86-64.
-      # XXX - update if and when Apple adds ARM-based Macs.
-      # (You're on your own for iOS etc.)
-      #
-      set(OSX_PROGRAM_ARCHITECTURES "x86_64")
-    endif()
-
     set_target_properties(rpcapd PROPERTIES
-      OSX_ARCHITECTURES "${OSX_PROGRAM_ARCHITECTURES}")
+      OSX_ARCHITECTURES "${OSX_EXECUTABLE_ARCHITECTURES}")
   endif()
 
   if(WIN32)
diff --git a/rpcapd/Makefile.in b/rpcapd/Makefile.in
index b0145cf2..fd00886d 100644
--- a/rpcapd/Makefile.in
+++ b/rpcapd/Makefile.in
@@ -85,7 +85,7 @@ SRC =	daemon.c \
 	log.c \
 	rpcapd.c
 
-OBJ =	$(SRC:.c=.o) ../rpcap-protocol.o ../sockutils.o ../fmtutils.o ../sslutils.o
+OBJ =	$(SRC:.c=.o)
 PUBHDR =
 
 HDR = $(PUBHDR) log.h
@@ -139,4 +139,4 @@ tags: $(TAGFILES)
 	ctags -wtd $(TAGFILES)
 
 depend:
-	$(MKDEP) -c "$(CC)" -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
+	$(MKDEP) -c $(CC) -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
diff --git a/rpcapd/config_params.h b/rpcapd/config_params.h
index c219ce16..a46897d5 100644
--- a/rpcapd/config_params.h
+++ b/rpcapd/config_params.h
@@ -45,7 +45,7 @@ struct active_pars
 {
 	char address[MAX_LINE + 1];	// keeps the network address (either numeric or literal) to of the active client
 	char port[MAX_LINE + 1];	// keeps the network port to bind to
-	int ai_family;			// address faimly to use
+	int ai_family;			// address family to use
 };
 
 extern char hostlist[MAX_HOST_LIST + 1];	//!< Keeps the list of the hosts that are allowed to connect to this server
diff --git a/rpcapd/daemon.c b/rpcapd/daemon.c
index 9b0f8285..87274665 100644
--- a/rpcapd/daemon.c
+++ b/rpcapd/daemon.c
@@ -29,9 +29,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 #include "varattrs.h"
@@ -95,7 +93,7 @@
 // Parameters for the service loop.
 struct daemon_slpars
 {
-	SOCKET sockctrl;	//!< SOCKET ID of the control connection
+	PCAP_SOCKET sockctrl;	//!< PCAP_SOCKET ID of the control connection
 	SSL *ssl;		//!< Optional SSL handler for the controlling sockets
 	int isactive;		//!< Not null if the daemon has to run in active mode
 	int nullAuthAllowed;	//!< '1' if we permit NULL authentication, '0' otherwise
@@ -110,8 +108,8 @@ struct daemon_slpars
 // value for a pthread_t on UN*X.
 //
 struct session {
-	SOCKET sockctrl;
-	SOCKET sockdata;
+	PCAP_SOCKET sockctrl;
+	PCAP_SOCKET sockdata;
 	SSL *ctrl_ssl, *data_ssl; // optional SSL handlers for sockctrl and sockdata.
 	uint8 protocol_version;
 	pcap_t *fp;
@@ -125,7 +123,7 @@ struct session {
 };
 
 // Locally defined functions
-static int daemon_msg_err(SOCKET sockctrl, SSL *, uint32 plen);
+static int daemon_msg_err(PCAP_SOCKET sockctrl, SSL *, uint32 plen);
 static int daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen);
 static int daemon_AuthUserPwd(char *username, char *password, char *errbuf);
 
@@ -142,7 +140,7 @@ static int daemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,
 
 static int daemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,
     struct session *session, uint32 plen);
-static int daemon_unpackapplyfilter(SOCKET sockctrl, SSL *, struct session *session, uint32 *plenp, char *errbuf);
+static int daemon_unpackapplyfilter(PCAP_SOCKET sockctrl, SSL *, struct session *session, uint32 *plenp, char *errbuf);
 
 static int daemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,
     struct session *session, uint32 plen, struct pcap_stat *stats,
@@ -159,9 +157,9 @@ static void *daemon_thrdatamain(void *ptr);
 static void noop_handler(int sign);
 #endif
 
-static int rpcapd_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *headerp);
-static int rpcapd_recv(SOCKET sock, SSL *, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf);
-static int rpcapd_discard(SOCKET sock, SSL *, uint32 len);
+static int rpcapd_recv_msg_header(PCAP_SOCKET sock, SSL *, struct rpcap_header *headerp);
+static int rpcapd_recv(PCAP_SOCKET sock, SSL *, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf);
+static int rpcapd_discard(PCAP_SOCKET sock, SSL *, uint32 len);
 static void session_close(struct session *);
 
 //
@@ -211,7 +209,7 @@ static int is_url(const char *source);
 #endif
 
 int
-daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
+daemon_serviceloop(PCAP_SOCKET sockctrl, int isactive, char *passiveClients,
     int nullAuthAllowed, int uses_ssl)
 {
 	uint8 first_octet;
@@ -559,7 +557,7 @@ daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
 		plen = header.plen;
 
 		//
-		// While we're in the authentication pharse, all requests
+		// While we're in the authentication phase, all requests
 		// must use version 0.
 		//
 		if (header.ver != 0)
@@ -1138,7 +1136,7 @@ end:
  * This handles the RPCAP_MSG_ERR message.
  */
 static int
-daemon_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen)
+daemon_msg_err(PCAP_SOCKET sockctrl, SSL *ssl, uint32 plen)
 {
 	char errbuf[PCAP_ERRBUF_SIZE];
 	char remote_errbuf[PCAP_ERRBUF_SIZE];
@@ -1267,7 +1265,7 @@ daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)
 			username = (char *) malloc (usernamelen + 1);
 			if (username == NULL)
 			{
-				pcap_fmt_errmsg_for_errno(errmsgbuf,
+				pcapint_fmt_errmsg_for_errno(errmsgbuf,
 				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
 				goto error;
 			}
@@ -1288,7 +1286,7 @@ daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)
 			passwd = (char *) malloc (passwdlen + 1);
 			if (passwd == NULL)
 			{
-				pcap_fmt_errmsg_for_errno(errmsgbuf,
+				pcapint_fmt_errmsg_for_errno(errmsgbuf,
 				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
 				free(username);
 				goto error;
@@ -1451,7 +1449,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 		{
 			// Some error other than an authentication error;
 			// log it.
-			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
+			pcapint_fmt_errmsg_for_win32_err(errmsgbuf,
 			    PCAP_ERRBUF_SIZE, error, "LogonUser() failed");
 			rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
 		}
@@ -1463,7 +1461,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	if (ImpersonateLoggedOnUser(Token) == 0)
 	{
 		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
-		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), "ImpersonateLoggedOnUser() failed");
 		rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
 		CloseHandle(Token);
@@ -1483,7 +1481,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	 * we have getspnam(), otherwise we just do traditional
 	 * authentication, which, on some platforms, might work, even
 	 * with shadow passwords, if we're running as root.  Traditional
-	 * authenticaion won't work if we're not running as root, as
+	 * authentication won't work if we're not running as root, as
 	 * I think these days all UN*Xes either won't return the password
 	 * at all with getpwnam() or will only do so if you're root.
 	 *
@@ -1532,7 +1530,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 
 	//
 	// The Single UNIX Specification says that if crypt() fails it
-	// sets errno, but some implementatons that haven't been run
+	// sets errno, but some implementations that haven't been run
 	// through the SUS test suite might not do so.
 	//
 	errno = 0;
@@ -1562,7 +1560,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	if (setuid(user->pw_uid))
 	{
 		error = errno;
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    error, "setuid");
 		rpcapd_log(LOGPRIO_ERROR, "setuid() failed: %s",
 		    strerror(error));
@@ -1572,7 +1570,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 /*	if (setgid(user->pw_gid))
 	{
 		error = errno;
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "setgid");
 		rpcapd_log(LOGPRIO_ERROR, "setgid() failed: %s",
 		    strerror(error));
@@ -1594,7 +1592,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
  */
 #define CHECK_AND_INCREASE_REPLY_LEN(itemlen) \
 	if (replylen > UINT32_MAX - (itemlen)) { \
-		pcap_strlcpy(errmsgbuf, "Reply length doesn't fit in 32 bits", \
+		pcapint_strlcpy(errmsgbuf, "Reply length doesn't fit in 32 bits", \
 		    sizeof (errmsgbuf)); \
 		goto error; \
 	} \
@@ -1648,7 +1646,7 @@ daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 		if (d->description) {
 			size_t stringlen = strlen(d->description);
 			if (stringlen > UINT16_MAX) {
-				pcap_strlcpy(errmsgbuf,
+				pcapint_strlcpy(errmsgbuf,
 				    "Description length doesn't fit in 16 bits",
 				    sizeof (errmsgbuf));
 				goto error;
@@ -1658,7 +1656,7 @@ daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 		if (d->name) {
 			size_t stringlen = strlen(d->name);
 			if (stringlen > UINT16_MAX) {
-				pcap_strlcpy(errmsgbuf,
+				pcapint_strlcpy(errmsgbuf,
 				    "Name length doesn't fit in 16 bits",
 				    sizeof (errmsgbuf));
 				goto error;
@@ -1682,7 +1680,7 @@ daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 #endif
 				CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_sockaddr) * 4);
 				if (naddrs == UINT16_MAX) {
-					pcap_strlcpy(errmsgbuf,
+					pcapint_strlcpy(errmsgbuf,
 					    "Number of interfaces doesn't fit in 16 bits",
 					    sizeof (errmsgbuf));
 					goto error;
@@ -2085,7 +2083,9 @@ daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,
 			goto error;
 		}
 
-		if (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
+		addrinfo = sock_initaddress(peerhost, portdata, &hints,
+		    errmsgbuf, PCAP_ERRBUF_SIZE);
+		if (addrinfo == NULL)
 			goto error;
 
 		if ((session->sockdata = sock_open(peerhost, addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
@@ -2096,7 +2096,9 @@ daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,
 		hints.ai_flags = AI_PASSIVE;
 
 		// Make the server socket pick up a free network port for us
-		if (sock_initaddress(NULL, NULL, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
+		addrinfo = sock_initaddress(NULL, NULL, &hints, errmsgbuf,
+		    PCAP_ERRBUF_SIZE);
+		if (addrinfo == NULL)
 			goto error;
 
 		if ((session->sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1 /* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
@@ -2175,7 +2177,7 @@ daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,
 
 	if (!serveropen_dp)
 	{
-		SOCKET socktemp;	// We need another socket, since we're going to accept() a connection
+		PCAP_SOCKET socktemp;	// We need another socket, since we're going to accept() a connection
 
 		// Connection creation
 		saddrlen = sizeof(struct sockaddr_storage);
@@ -2227,7 +2229,7 @@ daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,
 	    (void *) session);
 	if (ret != 0)
 	{
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    ret, "Error creating the data thread");
 		goto error;
 	}
@@ -2329,7 +2331,7 @@ daemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,
 #define RPCAP_BPF_MAXINSNS	8192
 
 static int
-daemon_unpackapplyfilter(SOCKET sockctrl, SSL *ctrl_ssl, struct session *session, uint32 *plenp, char *errmsgbuf)
+daemon_unpackapplyfilter(PCAP_SOCKET sockctrl, SSL *ctrl_ssl, struct session *session, uint32 *plenp, char *errmsgbuf)
 {
 	int status;
 	struct rpcap_filter filter;
@@ -2367,7 +2369,7 @@ daemon_unpackapplyfilter(SOCKET sockctrl, SSL *ctrl_ssl, struct session *session
 	bf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);
 	if (bf_insn == NULL)
 	{
-		pcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,
 		    errno, "malloc() failed");
 		return -2;
 	}
@@ -2908,7 +2910,7 @@ void sleep_secs(int secs)
  * Read the header of a message.
  */
 static int
-rpcapd_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *headerp)
+rpcapd_recv_msg_header(PCAP_SOCKET sock, SSL *ssl, struct rpcap_header *headerp)
 {
 	int nread;
 	char errbuf[PCAP_ERRBUF_SIZE];		// buffer for network errors
@@ -2940,7 +2942,7 @@ rpcapd_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *headerp)
  * error.
  */
 static int
-rpcapd_recv(SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)
+rpcapd_recv(PCAP_SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)
 {
 	int nread;
 	char errbuf[PCAP_ERRBUF_SIZE];		// buffer for network errors
@@ -2969,7 +2971,7 @@ rpcapd_recv(SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32 *plen, ch
  * error.
  */
 static int
-rpcapd_discard(SOCKET sock, SSL *ssl, uint32 len)
+rpcapd_discard(PCAP_SOCKET sock, SSL *ssl, uint32 len)
 {
 	char errbuf[PCAP_ERRBUF_SIZE + 1];	// keeps the error string, prior to be printed
 
diff --git a/rpcapd/daemon.h b/rpcapd/daemon.h
index dbbdb62c..79cd3848 100644
--- a/rpcapd/daemon.h
+++ b/rpcapd/daemon.h
@@ -33,9 +33,7 @@
 #ifndef __DAEMON_H__
 #define __DAEMON_H__
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "sslutils.h"
 
@@ -44,7 +42,7 @@
 // otherwise; the return value is used only by callers that call us
 // for active mode.
 //
-int daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
+int daemon_serviceloop(PCAP_SOCKET sockctrl, int isactive, char *passiveClients,
     int nullAuthAllowed, int uses_ssl);
 
 void sleep_secs(int secs);
diff --git a/rpcapd/fileconf.c b/rpcapd/fileconf.c
index c051f887..853b4099 100644
--- a/rpcapd/fileconf.c
+++ b/rpcapd/fileconf.c
@@ -31,9 +31,7 @@
  * SUCH DAMAGE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 
@@ -323,7 +321,7 @@ void fileconf_read(void)
 				// it.
 				//
 				*ptr++ = '\0';
-				result = pcap_strlcpy(activelist[num_active_clients].address, address, sizeof(activelist[num_active_clients].address));
+				result = pcapint_strlcpy(activelist[num_active_clients].address, address, sizeof(activelist[num_active_clients].address));
 				if (result >= sizeof(activelist[num_active_clients].address))
 				{
 					//
@@ -336,9 +334,9 @@ void fileconf_read(void)
 					continue;
 				}
 				if (strcmp(port, "DEFAULT") == 0) // the user choose a custom port
-					result = pcap_strlcpy(activelist[num_active_clients].port, RPCAP_DEFAULT_NETPORT_ACTIVE, sizeof(activelist[num_active_clients].port));
+					result = pcapint_strlcpy(activelist[num_active_clients].port, RPCAP_DEFAULT_NETPORT_ACTIVE, sizeof(activelist[num_active_clients].port));
 				else
-					result = pcap_strlcpy(activelist[num_active_clients].port, port, sizeof(activelist[num_active_clients].port));
+					result = pcapint_strlcpy(activelist[num_active_clients].port, port, sizeof(activelist[num_active_clients].port));
 				if (result >= sizeof(activelist[num_active_clients].address))
 				{
 					//
@@ -398,7 +396,7 @@ void fileconf_read(void)
 					// The list is not empty, so prepend
 					// a comma before adding this host.
 					//
-					result = pcap_strlcat(hostlist, ",", sizeof(hostlist));
+					result = pcapint_strlcat(hostlist, ",", sizeof(hostlist));
 					if (result >= sizeof(hostlist))
 					{
 						//
@@ -414,7 +412,7 @@ void fileconf_read(void)
 						continue;
 					}
 				}
-				result = pcap_strlcat(hostlist, host, sizeof(hostlist));
+				result = pcapint_strlcat(hostlist, host, sizeof(hostlist));
 				if (result >= sizeof(hostlist))
 				{
 					//
@@ -507,13 +505,13 @@ int fileconf_save(const char *savefile)
 		fprintf(fp, "# Hosts which are allowed to connect to this server (passive mode)\n");
 		fprintf(fp, "# Format: PassiveClient = <name or address>\n\n");
 
-		pcap_strlcpy(temphostlist, hostlist, sizeof (temphostlist));
+		pcapint_strlcpy(temphostlist, hostlist, sizeof (temphostlist));
 
-		token = pcap_strtok_r(temphostlist, RPCAP_HOSTLIST_SEP, &lasts);
+		token = pcapint_strtok_r(temphostlist, RPCAP_HOSTLIST_SEP, &lasts);
 		while(token != NULL)
 		{
 			fprintf(fp, "%s = %s\n", PARAM_PASSIVECLIENT, token);
-			token = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
+			token = pcapint_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
 		}
 
 
diff --git a/rpcapd/log.c b/rpcapd/log.c
index f26c145e..71668a19 100644
--- a/rpcapd/log.c
+++ b/rpcapd/log.c
@@ -19,9 +19,7 @@
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stdio.h>
 #include <stdarg.h>
diff --git a/rpcapd/rpcapd-config.manfile.in b/rpcapd/rpcapd-config.manfile.in
index 267b48e5..dd0c91e1 100644
--- a/rpcapd/rpcapd-config.manfile.in
+++ b/rpcapd/rpcapd-config.manfile.in
@@ -22,11 +22,13 @@
 rpcapd-config \- rpcapd configuration file format
 .SH DESCRIPTION
 An
-.B rpcapd
+.I rpcapd
 configuration file allows parameters to be set for
 .BR rpcapd (@MAN_ADMIN_COMMANDS@).
 .LP
-A # introduces a comment that runs to the end of the line.  Blank lines,
+A
+.B #
+introduces a comment that runs to the end of the line.  Blank lines,
 and lines with only a comment, are ignored.  Leading and trailing white
 space on a line are also ignored.
 .LP
@@ -34,7 +36,9 @@ Lines that set a parameter are of the form
 .IP
 \fIparameter\fB=\fIvalue\fR
 .LP
-Whitespace preceding or following the = is ignored.
+Whitespace preceding or following the
+.B =
+is ignored.
 .LP
 The
 .IR parameter s
@@ -72,7 +76,7 @@ or
 .BR NO .
 .B YES
 means that null authentication is permitted;
-.B No
+.B NO
 means that it is not permitted.
 .SH SEE ALSO
 .BR rpcapd (@MAN_ADMIN_COMMANDS@)
diff --git a/rpcapd/rpcapd.c b/rpcapd/rpcapd.c
index 4c1b7454..4ab11d8a 100644
--- a/rpcapd/rpcapd.c
+++ b/rpcapd/rpcapd.c
@@ -30,9 +30,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include "ftmacros.h"
 #include "diag-control.h"
@@ -74,7 +72,7 @@
 //
 struct listen_sock {
 	struct listen_sock *next;
-	SOCKET sock;
+	PCAP_SOCKET sock;
 };
 
 // Global variables
@@ -92,7 +90,7 @@ static HANDLE state_change_event;		//!< event to signal that a state change shou
 #endif
 static volatile sig_atomic_t shutdown_server;	//!< '1' if the server is to shut down
 static volatile sig_atomic_t reread_config;	//!< '1' if the server is to re-read its configuration
-static int uses_ssl; //!< '1' to use TLS over the data socket
+static int uses_ssl;				//!< '1' to use TLS over TCP
 
 extern char *optarg;	// for getopt()
 
@@ -106,7 +104,7 @@ static void main_terminate(int sign);
 static void main_reread_config(int sign);
 #endif
 static void accept_connections(void);
-static void accept_connection(SOCKET listen_sock);
+static void accept_connection(PCAP_SOCKET listen_sock);
 #ifndef _WIN32
 static void main_reap_children(int sign);
 #endif
@@ -199,8 +197,8 @@ int main(int argc, char *argv[])
 	// Initialize errbuf
 	memset(errbuf, 0, sizeof(errbuf));
 
-	pcap_strlcpy(address, RPCAP_DEFAULT_NETADDR, sizeof (address));
-	pcap_strlcpy(port, RPCAP_DEFAULT_NETPORT, sizeof (port));
+	pcapint_strlcpy(address, RPCAP_DEFAULT_NETADDR, sizeof (address));
+	pcapint_strlcpy(port, RPCAP_DEFAULT_NETPORT, sizeof (port));
 
 	// Prepare to open a new server socket
 	memset(&mainhints, 0, sizeof(struct addrinfo));
@@ -227,10 +225,10 @@ int main(int argc, char *argv[])
 				rpcapd_log_set(log_to_systemlog, log_debug_messages);
 				break;
 			case 'b':
-				pcap_strlcpy(address, optarg, sizeof (address));
+				pcapint_strlcpy(address, optarg, sizeof (address));
 				break;
 			case 'p':
-				pcap_strlcpy(port, optarg, sizeof (port));
+				pcapint_strlcpy(port, optarg, sizeof (port));
 				break;
 			case '4':
 				mainhints.ai_family = PF_INET;		// IPv4 server only
@@ -258,7 +256,7 @@ int main(int argc, char *argv[])
 				break;
 			case 'l':
 			{
-				pcap_strlcpy(hostlist, optarg, sizeof(hostlist));
+				pcapint_strlcpy(hostlist, optarg, sizeof(hostlist));
 				break;
 			}
 			case 'a':
@@ -267,20 +265,20 @@ int main(int argc, char *argv[])
 				char *lasts;
 				int i = 0;
 
-				tmpaddress = pcap_strtok_r(optarg, RPCAP_HOSTLIST_SEP, &lasts);
+				tmpaddress = pcapint_strtok_r(optarg, RPCAP_HOSTLIST_SEP, &lasts);
 
 				while ((tmpaddress != NULL) && (i < MAX_ACTIVE_LIST))
 				{
-					tmpport = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
+					tmpport = pcapint_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
 
-					pcap_strlcpy(activelist[i].address, tmpaddress, sizeof (activelist[i].address));
+					pcapint_strlcpy(activelist[i].address, tmpaddress, sizeof (activelist[i].address));
 
 					if ((tmpport == NULL) || (strcmp(tmpport, "DEFAULT") == 0)) // the user choose a custom port
-						pcap_strlcpy(activelist[i].port, RPCAP_DEFAULT_NETPORT_ACTIVE, sizeof (activelist[i].port));
+						pcapint_strlcpy(activelist[i].port, RPCAP_DEFAULT_NETPORT_ACTIVE, sizeof (activelist[i].port));
 					else
-						pcap_strlcpy(activelist[i].port, tmpport, sizeof (activelist[i].port));
+						pcapint_strlcpy(activelist[i].port, tmpport, sizeof (activelist[i].port));
 
-					tmpaddress = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
+					tmpaddress = pcapint_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);
 
 					i++;
 				}
@@ -293,10 +291,10 @@ int main(int argc, char *argv[])
 				break;
 			}
 			case 'f':
-				pcap_strlcpy(loadfile, optarg, sizeof (loadfile));
+				pcapint_strlcpy(loadfile, optarg, sizeof (loadfile));
 				break;
 			case 's':
-				pcap_strlcpy(savefile, optarg, sizeof (savefile));
+				pcapint_strlcpy(savefile, optarg, sizeof (savefile));
 				break;
 #ifdef HAVE_OPENSSL
 			case 'S':
@@ -338,7 +336,7 @@ int main(int argc, char *argv[])
 		rpcapd_log(LOGPRIO_ERROR, "%s", errbuf);
 		exit(-1);
 	}
-	pcap_fmt_set_encoding(PCAP_CHAR_ENC_UTF_8);
+	pcapint_fmt_set_encoding(PCAP_CHAR_ENC_UTF_8);
 
 	if (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)
 	{
@@ -390,7 +388,13 @@ int main(int argc, char *argv[])
 	sigaction(SIGCHLD, &action, NULL);
 	// Ignore SIGPIPE - we'll get EPIPE when trying to write to a closed
 	// connection, we don't want to get killed by a signal in that case
+#ifdef __illumos__
+	DIAG_OFF_STRICT_PROTOTYPES
+#endif /* __illumos__ */
 	signal(SIGPIPE, SIG_IGN);
+#ifdef __illumos__
+	DIAG_ON_STRICT_PROTOTYPES
+#endif /* __illumos__ */
 #endif
 
 # ifdef HAVE_OPENSSL
@@ -611,7 +615,9 @@ void main_startup(void)
 		//
 		// Get a list of sockets on which to listen.
 		//
-		if (sock_initaddress((address[0]) ? address : NULL, port, &mainhints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
+		addrinfo = sock_initaddress((address[0]) ? address : NULL,
+		    port, &mainhints, errbuf, PCAP_ERRBUF_SIZE);
+		if (addrinfo == NULL)
 		{
 			rpcapd_log(LOGPRIO_DEBUG, "%s", errbuf);
 			return;
@@ -620,7 +626,7 @@ void main_startup(void)
 		for (tempaddrinfo = addrinfo; tempaddrinfo;
 		     tempaddrinfo = tempaddrinfo->ai_next)
 		{
-			SOCKET sock;
+			PCAP_SOCKET sock;
 			struct listen_sock *sock_info;
 
 			if ((sock = sock_open(NULL, tempaddrinfo, SOCKOPEN_SERVER, SOCKET_MAXCONN, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
@@ -780,7 +786,7 @@ static BOOL WINAPI main_ctrl_event(DWORD ctrltype)
 	// CTRL_CLOSE_EVENT - the console was closed; this is like SIGHUP
 	// CTRL_LOGOFF_EVENT - a user is logging off; this is received
 	//   only by services
-	// CTRL_SHUTDOWN_EVENT - the systemis shutting down; this is
+	// CTRL_SHUTDOWN_EVENT - the system is shutting down; this is
 	//   received only by services
 	//
 	// For now, we treat all but CTRL_LOGOFF_EVENT as indications
@@ -1121,7 +1127,7 @@ accept_connections(void)
 // fork "inherits" the parent stack.)
 //
 struct params_copy {
-	SOCKET sockctrl;
+	PCAP_SOCKET sockctrl;
 	char *hostlist;
 };
 #endif
@@ -1131,10 +1137,10 @@ struct params_copy {
 // worker process, on UN*X, to handle the connection.
 //
 static void
-accept_connection(SOCKET listen_sock)
+accept_connection(PCAP_SOCKET listen_sock)
 {
 	char errbuf[PCAP_ERRBUF_SIZE + 1];	// keeps the error string, prior to be printed
-	SOCKET sockctrl;			// keeps the socket ID for this control connection
+	PCAP_SOCKET sockctrl;			// keeps the socket ID for this control connection
 	struct sockaddr_storage from;		// generic sockaddr_storage variable
 	socklen_t fromlen;			// keeps the length of the sockaddr_storage variable
 
@@ -1328,7 +1334,7 @@ static void *
 main_active(void *ptr)
 {
 	char errbuf[PCAP_ERRBUF_SIZE + 1];	// keeps the error string, prior to be printed
-	SOCKET sockctrl;			// keeps the socket ID for this control connection
+	PCAP_SOCKET sockctrl;			// keeps the socket ID for this control connection
 	struct addrinfo hints;			// temporary struct to keep settings needed to open the new socket
 	struct addrinfo *addrinfo;		// keeps the addrinfo chain; required to open a new socket
 	struct active_pars *activepars;
@@ -1350,7 +1356,9 @@ main_active(void *ptr)
 	memset(errbuf, 0, sizeof(errbuf));
 
 	// Do the work
-	if (sock_initaddress(activepars->address, activepars->port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
+	addrinfo = sock_initaddress(activepars->address, activepars->port,
+	    &hints, errbuf, PCAP_ERRBUF_SIZE);
+	if (addrinfo == NULL)
 	{
 		rpcapd_log(LOGPRIO_DEBUG, "%s", errbuf);
 		return 0;
diff --git a/rpcapd/rpcapd.manadmin.in b/rpcapd/rpcapd.manadmin.in
index f3ab6ea4..724a0fc6 100644
--- a/rpcapd/rpcapd.manadmin.in
+++ b/rpcapd/rpcapd.manadmin.in
@@ -95,22 +95,22 @@ and filter part of libpcap to be run on a remote system.
 Rpcapd can run in two modes: passive mode (default) and active mode.
 .LP
 In passive mode, the client (e.g., a network sniffer) connects to
-.BR rpcapd .
+.IR rpcapd .
 The client then sends the appropriate commands to
-.B rpcapd
+.I rpcapd
 to start the capture.
 .LP
 In active mode,
-.B rpcapd
+.I rpcapd
 tries to establish a connection toward the client
 (e.g., a network sniffer). The client then sends the appropriate commands
 to rpcapd to start the capture.
 .LP
 Active mode is useful in case
-.B rpcapd
+.I rpcapd
 is run behind a firewall and
 cannot receive connections from the external world. In this case,
-.B rpcapd
+.I rpcapd
 can be configured to establish the connection to a given host,
 which has to be configured in order to wait for that connection. After
 establishing the connection, the protocol continues its job in almost
@@ -119,18 +119,19 @@ the same way in both active and passive mode.
 .LP
 The user can create a configuration file in the same directory as the
 executable, and put the configuration commands in there. In order for
-.B rpcapd
+.I rpcapd
 to execute the commands, it needs to be restarted on Win32, i.e.
 the configuration file is parsed only at the beginning. The UNIX
 version of
-.B rpcapd
+.I rpcapd
 will reread the configuration file upon receiving a
-HUP signal. In that case, all the existing connections remain in place,
+.B HUP
+signal. In that case, all the existing connections remain in place,
 while the new connections will be created according to the new parameters.
 .LP
 In case a user does not want to create the configuration file manually,
 they can launch
-.B rpcapd
+.I rpcapd
 with the desired flags plus
 .BR "-s filename" .
 Rpcapd will parse all the parameters and save them into the specified
@@ -139,7 +140,7 @@ configuration file.
 .LP
 The remote daemon is installed automatically when installing WinPcap.
 The installation process places the
-.B rpcapd
+.I rpcapd
 executable file into the WinPcap folder.
 This file can be executed either from the command line, or as a service.
 For instance, the installation process updates the list of available
@@ -157,7 +158,7 @@ flag.
 .SH Starting rpcapd on Win32
 .LP
 The
-.B rpcapd
+.I rpcapd
 executable can be launched directly, i.e.  it can run in the
 foreground as well (not as a daemon/service).  The procedure is quite
 simple: you have to invoke the executable from the command line with all
@@ -168,7 +169,7 @@ start in the foreground.
 .SH Installing rpcapd on Unix-like systems
 TBD
 .SH Starting rpcapd on Unix-like systems
-.B rpcapd
+.I rpcapd
 needs sufficient privileges to perform packet capture, e.g.
 run as root or be owned by root and have suid set. Most operating
 systems provide more elegant solutions when run as user than the
@@ -200,8 +201,7 @@ and the
 .B rpcapd.inetd.conf
 entry has been added to
 .BR inetd.conf (@MAN_FILE_FORMATS@),
-the rpcapd service can be enabled by telling
-.B inetd
+the rpcapd service can be enabled by telling inetd
 to reread its configuration file.
 .LP
 If your system supports
@@ -210,8 +210,7 @@ and the
 .B rpcapd.xinetd.conf
 entry has been added to
 .BR xinetd.conf (@MAN_FILE_FORMATS@),
-the rpcapd service can be enabled by telling
-.B xinetd
+the rpcapd service can be enabled by telling xinetd
 to reread its configuration file.
 .SH OPTIONS
 .TP
@@ -220,20 +219,20 @@ Bind to the IP address specified by
 .I address
 (either numeric or literal).
 By default,
-.B rpcapd
+.I rpcapd
 binds to all local IPv4 and IPv6 addresses.
 .TP
 .BI \-p " port"
 Bind to the port specified by
 .IR port .
 By default,
-.B rpcapd
+.I rpcapd
 binds to port 2002.
 .TP
 .B \-4
 Listen only on IPv4 addresses.
 By default,
-.B rpcapd
+.I rpcapd
 listens on both IPv4 and IPv6 addresses.
 .TP
 .BI \-l " host_list"
@@ -246,8 +245,9 @@ We suggest that you use host names rather than literal IP addresses
 in order to avoid problems with different address families.
 .TP
 .B \-n
-Permit NULL authentication (usually used with
-.BR \-l ).
+Permit NULL authentication (usually used with the
+.B \-l
+flag).
 .TP
 .BI \-a " host" , "port"
 Run in active mode, connecting to host
@@ -262,8 +262,8 @@ is omitted, the default port (2003) is used.
 Run in active mode only; by default, if
 .B \-a
 is specified,
-.B rpcapd
-it accepts passive connections as well.
+.I rpcapd
+accepts passive connections as well.
 .TP
 .B \-d
 Run in daemon mode (UNIX only) or as a service (Win32 only).
@@ -293,7 +293,7 @@ and ignore all flags specified on the command line.
 Print this help screen.
 .LP
 If
-.B rpcapd
+.I rpcapd
 was compiled with SSL support, the following options are also
 available:
 .TP
@@ -304,14 +304,12 @@ Require that SSL be used on connections.
 With SSL enabled, XXX - I'm not sure how *fetching* the list of
 compression mechanisms does anything to compression.
 .TP
-.B \-S
-.I ssl_keyfile
+.BI \-S " ssl_keyfile"
 With SSL enabled, use
 .I ssl_keyfile
 as the SSL key file.
 .TP
-.B \-X
-.I ssl_certfile
+.BI \-X " ssl_certfile"
 With SSL enabled, use
 .I ssl_certfile
 as the SSL certificate file.
diff --git a/rpcapd/win32-svc.c b/rpcapd/win32-svc.c
index 49b6804b..b4a5fa99 100644
--- a/rpcapd/win32-svc.c
+++ b/rpcapd/win32-svc.c
@@ -60,7 +60,7 @@ BOOL svc_start(void)
 	// This call is blocking. A new thread is created which will launch
 	// the svc_main() function
 	if ((rc = StartServiceCtrlDispatcher(ste)) == 0) {
-		pcap_fmt_errmsg_for_win32_err(string, sizeof (string),
+		pcapint_fmt_errmsg_for_win32_err(string, sizeof (string),
 		    GetLastError(), "StartServiceCtrlDispatcher() failed");
 		rpcapd_log(LOGPRIO_ERROR, "%s", string);
 	}
diff --git a/savefile.c b/savefile.c
index db8a3aa0..c711a81c 100644
--- a/savefile.c
+++ b/savefile.c
@@ -28,9 +28,7 @@
  * dependent values so we can print the dump file on any architecture.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 #ifdef _WIN32
@@ -191,7 +189,7 @@ sf_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
 static u_int
 sf_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
 {
-	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on savefiles",
+	pcapint_strlcpy(p->errbuf, "Sending packets isn't supported on savefiles",
 	    PCAP_ERRBUF_SIZE);
 	return (0);
 }
@@ -230,7 +228,7 @@ sf_get_airpcap_handle(pcap_t *pcap _U_)
 static int
 sf_inject(pcap_t *p, const void *buf _U_, int size _U_)
 {
-	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on savefiles",
+	pcapint_strlcpy(p->errbuf, "Sending packets isn't supported on savefiles",
 	    PCAP_ERRBUF_SIZE);
 	return (-1);
 }
@@ -248,7 +246,7 @@ sf_setdirection(pcap_t *p, pcap_direction_t d _U_)
 }
 
 void
-sf_cleanup(pcap_t *p)
+pcapint_sf_cleanup(pcap_t *p)
 {
 	if (p->rfile != stdin)
 		(void)fclose(p->rfile);
@@ -268,7 +266,7 @@ sf_cleanup(pcap_t *p)
  * local code page.
  */
 FILE *
-charset_fopen(const char *path, const char *mode)
+pcapint_charset_fopen(const char *path, const char *mode)
 {
 	wchar_t *utf16_path;
 #define MAX_MODE_LEN	16
@@ -278,7 +276,7 @@ charset_fopen(const char *path, const char *mode)
 	FILE *fp;
 	int save_errno;
 
-	if (pcap_utf_8_mode) {
+	if (pcapint_utf_8_mode) {
 		/*
 		 * Map from UTF-8 to UTF-16LE.
 		 * Fail if there are invalid characters in the input
@@ -375,7 +373,7 @@ pcap_open_offline_with_tstamp_precision(const char *fname, u_int precision,
 	}
 	else {
 		/*
-		 * Use charset_fopen(); on Windows, it tests whether we're
+		 * Use pcapint_charset_fopen(); on Windows, it tests whether we're
 		 * in "local code page" or "UTF-8" mode, and treats the
 		 * pathname appropriately, and on other platforms, it just
 		 * wraps fopen().
@@ -384,9 +382,9 @@ pcap_open_offline_with_tstamp_precision(const char *fname, u_int precision,
 		 * support it, even though it does nothing.  For MS-DOS,
 		 * we again need it.
 		 */
-		fp = charset_fopen(fname, "rb");
+		fp = pcapint_charset_fopen(fname, "rb");
 		if (fp == NULL) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "%s", fname);
 			return (NULL);
 		}
@@ -416,7 +414,7 @@ pcap_t* pcap_hopen_offline_with_tstamp_precision(intptr_t osfd, u_int precision,
 	fd = _open_osfhandle(osfd, _O_RDONLY);
 	if ( fd < 0 )
 	{
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "_open_osfhandle");
 		return NULL;
 	}
@@ -424,7 +422,7 @@ pcap_t* pcap_hopen_offline_with_tstamp_precision(intptr_t osfd, u_int precision,
 	file = _fdopen(fd, "rb");
 	if ( file == NULL )
 	{
-		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "_fdopen");
 		_close(fd);
 		return NULL;
@@ -451,7 +449,7 @@ pcap_t* pcap_hopen_offline(intptr_t osfd, char *errbuf)
  * signed is that pcap_snapshot() returns an int, not an unsigned int.
  */
 bpf_u_int32
-pcap_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen)
+pcapint_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen)
 {
 	if (snaplen == 0 || snaplen > INT_MAX) {
 		/*
@@ -511,7 +509,7 @@ pcap_fopen_offline_with_tstamp_precision(FILE *fp, u_int precision,
 	amt_read = fread(&magic, 1, sizeof(magic), fp);
 	if (amt_read != sizeof(magic)) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 		} else {
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
@@ -562,9 +560,9 @@ found:
 #endif
 
 	p->can_set_rfmon_op = sf_cant_set_rfmon;
-	p->read_op = pcap_offline_read;
+	p->read_op = pcapint_offline_read;
 	p->inject_op = sf_inject;
-	p->setfilter_op = install_bpf_program;
+	p->setfilter_op = pcapint_install_bpf_program;
 	p->setdirection_op = sf_setdirection;
 	p->set_datalink_op = NULL;	/* we don't support munging link-layer headers */
 	p->getnonblock_op = sf_getnonblock;
@@ -589,12 +587,12 @@ found:
 	 * For offline captures, the standard one-shot callback can
 	 * be used for pcap_next()/pcap_next_ex().
 	 */
-	p->oneshot_callback = pcap_oneshot;
+	p->oneshot_callback = pcapint_oneshot;
 
 	/*
 	 * Default breakloop operation.
 	 */
-	p->breakloop_op = pcap_breakloop_common;
+	p->breakloop_op = pcapint_breakloop_common;
 
 	/*
 	 * Savefiles never require special BPF code generation.
@@ -626,7 +624,7 @@ pcap_fopen_offline(FILE *fp, char *errbuf)
  * If cnt > 0, return after 'cnt' packets, otherwise continue until eof.
  */
 int
-pcap_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
+pcapint_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 {
 	struct bpf_insn *fcode;
 	int n = 0;
@@ -687,7 +685,7 @@ pcap_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
 		 * and, if it passes, process it.
 		 */
 		if ((fcode = p->fcode.bf_insns) == NULL ||
-		    pcap_filter(fcode, data, h.len, h.caplen)) {
+		    pcapint_filter(fcode, data, h.len, h.caplen)) {
 			(*callback)(user, &h, data);
 			n++;	/* count the packet */
 			if (n >= cnt)
diff --git a/scanner.c b/scanner.c
index bbb2b460..ca2f08c4 100644
--- a/scanner.c
+++ b/scanner.c
@@ -1,8 +1,6 @@
 #line 2 "scanner.c"
 /* Must come first for _LARGE_FILE_API on AIX. */
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * Must come first to avoid warnings on Windows.
@@ -33,7 +31,27 @@
 
 #include "diag-control.h"
 
-#line 37 "scanner.c"
+/*
+ * Convert string to 32-bit unsigned integer; the string starts at
+ * string and is string_len bytes long.
+ *
+ * On success, sets *val to the value and returns 1.
+ * On failure, sets the BPF error string and returns 0.
+ *
+ * Also used in gencode.c
+ */
+typedef enum {
+	STOULEN_OK,
+	STOULEN_NOT_HEX_NUMBER,
+	STOULEN_NOT_OCTAL_NUMBER,
+	STOULEN_NOT_DECIMAL_NUMBER,
+	STOULEN_ERROR
+} stoulen_ret;
+
+stoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,
+    compiler_state_t *cstate);
+
+#line 55 "scanner.c"
 
 #define  YY_INT_ALIGNED short int
 
@@ -3099,7 +3117,7 @@ static const flex_int16_t yy_chk[7789] =
  * We want to generate code that can be used by a reentrant parser
  * generated by Bison or Berkeley YACC.
  */
-#line 74 "scanner.l"
+#line 92 "scanner.l"
 /*
  * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
  *	The Regents of the University of California.  All rights reserved.
@@ -3178,15 +3196,15 @@ void pcap_set_column(int, yyscan_t);
 #include "os-proto.h"
 #endif
 
-static int stou(char *, YYSTYPE *, compiler_state_t *);
+static int stou(const char *, YYSTYPE *, compiler_state_t *);
 
 /*
  * Disable diagnostics in the code generated by Flex.
  */
 DIAG_OFF_FLEX
 
-#line 3189 "scanner.c"
-#line 3190 "scanner.c"
+#line 3207 "scanner.c"
+#line 3208 "scanner.c"
 
 #define INITIAL 0
 
@@ -3456,9 +3474,9 @@ YY_DECL
 		}
 
 	{
-#line 255 "scanner.l"
+#line 273 "scanner.l"
 
-#line 3462 "scanner.c"
+#line 3480 "scanner.c"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -3513,634 +3531,634 @@ do_action:	/* This label is used only to access EOF actions. */
 
 case 1:
 YY_RULE_SETUP
-#line 256 "scanner.l"
+#line 274 "scanner.l"
 return DST;
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 257 "scanner.l"
+#line 275 "scanner.l"
 return SRC;
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 259 "scanner.l"
+#line 277 "scanner.l"
 return LINK;
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 260 "scanner.l"
+#line 278 "scanner.l"
 return LINK;
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 261 "scanner.l"
+#line 279 "scanner.l"
 return ARP;
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 262 "scanner.l"
+#line 280 "scanner.l"
 return RARP;
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 263 "scanner.l"
+#line 281 "scanner.l"
 return IP;
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 264 "scanner.l"
+#line 282 "scanner.l"
 return SCTP;
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 265 "scanner.l"
+#line 283 "scanner.l"
 return TCP;
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 266 "scanner.l"
+#line 284 "scanner.l"
 return UDP;
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 267 "scanner.l"
+#line 285 "scanner.l"
 return ICMP;
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 268 "scanner.l"
+#line 286 "scanner.l"
 return IGMP;
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 269 "scanner.l"
+#line 287 "scanner.l"
 return IGRP;
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 270 "scanner.l"
+#line 288 "scanner.l"
 return PIM;
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 271 "scanner.l"
+#line 289 "scanner.l"
 return VRRP;
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 272 "scanner.l"
+#line 290 "scanner.l"
 return CARP;
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 273 "scanner.l"
+#line 291 "scanner.l"
 return RADIO;
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 275 "scanner.l"
+#line 293 "scanner.l"
 return IPV6;
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 276 "scanner.l"
+#line 294 "scanner.l"
 return ICMPV6;
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 277 "scanner.l"
+#line 295 "scanner.l"
 return AH;
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 278 "scanner.l"
+#line 296 "scanner.l"
 return ESP;
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 280 "scanner.l"
+#line 298 "scanner.l"
 return ATALK;
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 281 "scanner.l"
+#line 299 "scanner.l"
 return AARP;
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 282 "scanner.l"
+#line 300 "scanner.l"
 return DECNET;
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 283 "scanner.l"
+#line 301 "scanner.l"
 return LAT;
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 284 "scanner.l"
+#line 302 "scanner.l"
 return SCA;
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 285 "scanner.l"
+#line 303 "scanner.l"
 return MOPRC;
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 286 "scanner.l"
+#line 304 "scanner.l"
 return MOPDL;
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 288 "scanner.l"
+#line 306 "scanner.l"
 return ISO;
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 289 "scanner.l"
+#line 307 "scanner.l"
 return ESIS;
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 290 "scanner.l"
+#line 308 "scanner.l"
 return ESIS;
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 291 "scanner.l"
+#line 309 "scanner.l"
 return ISIS;
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 292 "scanner.l"
+#line 310 "scanner.l"
 return ISIS;
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 293 "scanner.l"
+#line 311 "scanner.l"
 return L1;
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 294 "scanner.l"
+#line 312 "scanner.l"
 return L2;
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 295 "scanner.l"
+#line 313 "scanner.l"
 return IIH;
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 296 "scanner.l"
+#line 314 "scanner.l"
 return LSP;
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 297 "scanner.l"
+#line 315 "scanner.l"
 return SNP;
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 298 "scanner.l"
+#line 316 "scanner.l"
 return CSNP;
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 299 "scanner.l"
+#line 317 "scanner.l"
 return PSNP;
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 301 "scanner.l"
+#line 319 "scanner.l"
 return CLNP;
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 303 "scanner.l"
+#line 321 "scanner.l"
 return STP;
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 305 "scanner.l"
+#line 323 "scanner.l"
 return IPX;
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 307 "scanner.l"
+#line 325 "scanner.l"
 return NETBEUI;
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 309 "scanner.l"
+#line 327 "scanner.l"
 return HOST;
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 310 "scanner.l"
+#line 328 "scanner.l"
 return NET;
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 311 "scanner.l"
+#line 329 "scanner.l"
 return NETMASK;
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 312 "scanner.l"
+#line 330 "scanner.l"
 return PORT;
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 313 "scanner.l"
+#line 331 "scanner.l"
 return PORTRANGE;
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 314 "scanner.l"
+#line 332 "scanner.l"
 return PROTO;
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 315 "scanner.l"
+#line 333 "scanner.l"
 return PROTOCHAIN;
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 317 "scanner.l"
+#line 335 "scanner.l"
 return GATEWAY;
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 319 "scanner.l"
+#line 337 "scanner.l"
 return TYPE;
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 320 "scanner.l"
+#line 338 "scanner.l"
 return SUBTYPE;
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 321 "scanner.l"
+#line 339 "scanner.l"
 return DIR;
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 322 "scanner.l"
+#line 340 "scanner.l"
 return ADDR1;
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 323 "scanner.l"
+#line 341 "scanner.l"
 return ADDR2;
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 324 "scanner.l"
+#line 342 "scanner.l"
 return ADDR3;
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 325 "scanner.l"
+#line 343 "scanner.l"
 return ADDR4;
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 326 "scanner.l"
+#line 344 "scanner.l"
 return RA;
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 327 "scanner.l"
+#line 345 "scanner.l"
 return TA;
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 329 "scanner.l"
+#line 347 "scanner.l"
 return LESS;
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 330 "scanner.l"
+#line 348 "scanner.l"
 return GREATER;
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 331 "scanner.l"
+#line 349 "scanner.l"
 return CBYTE;
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 332 "scanner.l"
+#line 350 "scanner.l"
 return TK_BROADCAST;
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 333 "scanner.l"
+#line 351 "scanner.l"
 return TK_MULTICAST;
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 335 "scanner.l"
+#line 353 "scanner.l"
 return AND;
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 336 "scanner.l"
+#line 354 "scanner.l"
 return OR;
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 337 "scanner.l"
+#line 355 "scanner.l"
 return '!';
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 339 "scanner.l"
+#line 357 "scanner.l"
 return LEN;
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 340 "scanner.l"
+#line 358 "scanner.l"
 return INBOUND;
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 341 "scanner.l"
+#line 359 "scanner.l"
 return OUTBOUND;
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 343 "scanner.l"
+#line 361 "scanner.l"
 return IFINDEX;
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 345 "scanner.l"
+#line 363 "scanner.l"
 return VLAN;
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 346 "scanner.l"
+#line 364 "scanner.l"
 return MPLS;
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 347 "scanner.l"
+#line 365 "scanner.l"
 return PPPOED;
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 348 "scanner.l"
+#line 366 "scanner.l"
 return PPPOES;
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 349 "scanner.l"
+#line 367 "scanner.l"
 return GENEVE;
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 351 "scanner.l"
+#line 369 "scanner.l"
 return LANE;
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 352 "scanner.l"
+#line 370 "scanner.l"
 return LLC;
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 353 "scanner.l"
+#line 371 "scanner.l"
 return METAC;
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 354 "scanner.l"
+#line 372 "scanner.l"
 return BCC;
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 355 "scanner.l"
+#line 373 "scanner.l"
 return OAM;
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 356 "scanner.l"
+#line 374 "scanner.l"
 return OAMF4;
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 357 "scanner.l"
+#line 375 "scanner.l"
 return OAMF4EC;
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 358 "scanner.l"
+#line 376 "scanner.l"
 return OAMF4SC;
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 359 "scanner.l"
+#line 377 "scanner.l"
 return SC;
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 360 "scanner.l"
+#line 378 "scanner.l"
 return ILMIC;
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 361 "scanner.l"
+#line 379 "scanner.l"
 return VPI;
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 362 "scanner.l"
+#line 380 "scanner.l"
 return VCI;
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 363 "scanner.l"
+#line 381 "scanner.l"
 return CONNECTMSG;
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 364 "scanner.l"
+#line 382 "scanner.l"
 return METACONNECT;
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 366 "scanner.l"
+#line 384 "scanner.l"
 return PF_IFNAME;
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 367 "scanner.l"
+#line 385 "scanner.l"
 return PF_RSET;
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 368 "scanner.l"
+#line 386 "scanner.l"
 return PF_RNR;
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 369 "scanner.l"
+#line 387 "scanner.l"
 return PF_SRNR;
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 370 "scanner.l"
+#line 388 "scanner.l"
 return PF_REASON;
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 371 "scanner.l"
+#line 389 "scanner.l"
 return PF_ACTION;
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 373 "scanner.l"
+#line 391 "scanner.l"
 return FISU;
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 374 "scanner.l"
+#line 392 "scanner.l"
 return LSSU;
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 375 "scanner.l"
+#line 393 "scanner.l"
 return LSSU;
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 376 "scanner.l"
+#line 394 "scanner.l"
 return MSU;
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 377 "scanner.l"
+#line 395 "scanner.l"
 return HFISU;
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 378 "scanner.l"
+#line 396 "scanner.l"
 return HLSSU;
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 379 "scanner.l"
+#line 397 "scanner.l"
 return HMSU;
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 380 "scanner.l"
+#line 398 "scanner.l"
 return SIO;
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 381 "scanner.l"
+#line 399 "scanner.l"
 return OPC;
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 382 "scanner.l"
+#line 400 "scanner.l"
 return DPC;
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 383 "scanner.l"
+#line 401 "scanner.l"
 return SLS;
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 384 "scanner.l"
+#line 402 "scanner.l"
 return HSIO;
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 385 "scanner.l"
+#line 403 "scanner.l"
 return HOPC;
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 386 "scanner.l"
+#line 404 "scanner.l"
 return HDPC;
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 387 "scanner.l"
+#line 405 "scanner.l"
 return HSLS;
 	YY_BREAK
 case 114:
 /* rule 114 can match eol */
 YY_RULE_SETUP
-#line 389 "scanner.l"
+#line 407 "scanner.l"
 ;
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 390 "scanner.l"
+#line 408 "scanner.l"
 return yytext[0];
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 391 "scanner.l"
+#line 409 "scanner.l"
 return GEQ;
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 392 "scanner.l"
+#line 410 "scanner.l"
 return LEQ;
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 393 "scanner.l"
+#line 411 "scanner.l"
 return NEQ;
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 394 "scanner.l"
+#line 412 "scanner.l"
 return '=';
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 395 "scanner.l"
+#line 413 "scanner.l"
 return LSH;
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 396 "scanner.l"
+#line 414 "scanner.l"
 return RSH;
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 397 "scanner.l"
+#line 415 "scanner.l"
 { yylval->s = sdup(yyextra, yytext); return AID; }
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 398 "scanner.l"
+#line 416 "scanner.l"
 { yylval->s = sdup(yyextra, yytext); return EID; }
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 399 "scanner.l"
+#line 417 "scanner.l"
 { return stou(yytext, yylval, yyextra); }
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-#line 400 "scanner.l"
+#line 418 "scanner.l"
 {
 			yylval->s = sdup(yyextra, (char *)yytext); return HID; }
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 402 "scanner.l"
+#line 420 "scanner.l"
 {
 #ifdef INET6
 			  struct addrinfo hints, *res;
@@ -4163,316 +4181,316 @@ YY_RULE_SETUP
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 421 "scanner.l"
+#line 439 "scanner.l"
 { bpf_set_error(yyextra, "bogus ethernet address %s", yytext); yylval->s = NULL; return EID; }
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 422 "scanner.l"
+#line 440 "scanner.l"
 { yylval->h = 0; return NUM; }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 423 "scanner.l"
+#line 441 "scanner.l"
 { yylval->h = 1; return NUM; }
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 424 "scanner.l"
+#line 442 "scanner.l"
 { yylval->h = 0; return NUM; }
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 425 "scanner.l"
+#line 443 "scanner.l"
 { yylval->h = 3; return NUM; }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 426 "scanner.l"
+#line 444 "scanner.l"
 { yylval->h = 4; return NUM; }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 427 "scanner.l"
+#line 445 "scanner.l"
 { yylval->h = 5; return NUM; }
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 428 "scanner.l"
+#line 446 "scanner.l"
 { yylval->h = 8; return NUM; }
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 429 "scanner.l"
+#line 447 "scanner.l"
 { yylval->h = 9; return NUM; }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 430 "scanner.l"
+#line 448 "scanner.l"
 { yylval->h = 10; return NUM; }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 431 "scanner.l"
+#line 449 "scanner.l"
 { yylval->h = 11; return NUM; }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 432 "scanner.l"
+#line 450 "scanner.l"
 { yylval->h = 12; return NUM; }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 433 "scanner.l"
+#line 451 "scanner.l"
 { yylval->h = 13; return NUM; }
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 434 "scanner.l"
+#line 452 "scanner.l"
 { yylval->h = 14; return NUM; }
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 435 "scanner.l"
+#line 453 "scanner.l"
 { yylval->h = 15; return NUM; }
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 436 "scanner.l"
+#line 454 "scanner.l"
 { yylval->h = 16; return NUM; }
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
-#line 437 "scanner.l"
+#line 455 "scanner.l"
 { yylval->h = 17; return NUM; }
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 438 "scanner.l"
+#line 456 "scanner.l"
 { yylval->h = 18; return NUM; }
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 440 "scanner.l"
+#line 458 "scanner.l"
 { yylval->h = 0; return NUM; }
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 441 "scanner.l"
+#line 459 "scanner.l"
 { yylval->h = 1; return NUM; }
 	YY_BREAK
 case 147:
 YY_RULE_SETUP
-#line 443 "scanner.l"
+#line 461 "scanner.l"
 { yylval->h = 1; return NUM; }
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 444 "scanner.l"
+#line 462 "scanner.l"
 { yylval->h = 2; return NUM; }
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 445 "scanner.l"
+#line 463 "scanner.l"
 { yylval->h = 3; return NUM; }
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 446 "scanner.l"
+#line 464 "scanner.l"
 { yylval->h = 4; return NUM; }
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
-#line 447 "scanner.l"
+#line 465 "scanner.l"
 { yylval->h = 128; return NUM; }
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 448 "scanner.l"
+#line 466 "scanner.l"
 { yylval->h = 129; return NUM; }
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 449 "scanner.l"
+#line 467 "scanner.l"
 { yylval->h = 130; return NUM; }
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 450 "scanner.l"
+#line 468 "scanner.l"
 { yylval->h = 131; return NUM; }
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 451 "scanner.l"
+#line 469 "scanner.l"
 { yylval->h = 132; return NUM; }
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
-#line 452 "scanner.l"
+#line 470 "scanner.l"
 { yylval->h = 133; return NUM; }
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 453 "scanner.l"
+#line 471 "scanner.l"
 { yylval->h = 134; return NUM; }
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 454 "scanner.l"
+#line 472 "scanner.l"
 { yylval->h = 135; return NUM; }
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 455 "scanner.l"
+#line 473 "scanner.l"
 { yylval->h = 136; return NUM; }
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
-#line 456 "scanner.l"
+#line 474 "scanner.l"
 { yylval->h = 137; return NUM; }
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 457 "scanner.l"
+#line 475 "scanner.l"
 { yylval->h = 138; return NUM; }
 	YY_BREAK
 case 162:
 YY_RULE_SETUP
-#line 458 "scanner.l"
+#line 476 "scanner.l"
 { yylval->h = 139; return NUM; }
 	YY_BREAK
 case 163:
 YY_RULE_SETUP
-#line 459 "scanner.l"
+#line 477 "scanner.l"
 { yylval->h = 140; return NUM; }
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 460 "scanner.l"
+#line 478 "scanner.l"
 { yylval->h = 141; return NUM; }
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 461 "scanner.l"
+#line 479 "scanner.l"
 { yylval->h = 142; return NUM; }
 	YY_BREAK
 case 166:
 YY_RULE_SETUP
-#line 462 "scanner.l"
+#line 480 "scanner.l"
 { yylval->h = 143; return NUM; }
 	YY_BREAK
 case 167:
 YY_RULE_SETUP
-#line 463 "scanner.l"
+#line 481 "scanner.l"
 { yylval->h = 144; return NUM; }
 	YY_BREAK
 case 168:
 YY_RULE_SETUP
-#line 464 "scanner.l"
+#line 482 "scanner.l"
 { yylval->h = 145; return NUM; }
 	YY_BREAK
 case 169:
 YY_RULE_SETUP
-#line 465 "scanner.l"
+#line 483 "scanner.l"
 { yylval->h = 146; return NUM; }
 	YY_BREAK
 case 170:
 YY_RULE_SETUP
-#line 466 "scanner.l"
+#line 484 "scanner.l"
 { yylval->h = 147; return NUM; }
 	YY_BREAK
 case 171:
 YY_RULE_SETUP
-#line 467 "scanner.l"
+#line 485 "scanner.l"
 { yylval->h = 148; return NUM; }
 	YY_BREAK
 case 172:
 YY_RULE_SETUP
-#line 468 "scanner.l"
+#line 486 "scanner.l"
 { yylval->h = 149; return NUM; }
 	YY_BREAK
 case 173:
 YY_RULE_SETUP
-#line 469 "scanner.l"
+#line 487 "scanner.l"
 { yylval->h = 151; return NUM; }
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 470 "scanner.l"
+#line 488 "scanner.l"
 { yylval->h = 152; return NUM; }
 	YY_BREAK
 case 175:
 YY_RULE_SETUP
-#line 471 "scanner.l"
+#line 489 "scanner.l"
 { yylval->h = 153; return NUM; }
 	YY_BREAK
 case 176:
 YY_RULE_SETUP
-#line 473 "scanner.l"
+#line 491 "scanner.l"
 { yylval->h = 13; return NUM; }
 	YY_BREAK
 case 177:
 YY_RULE_SETUP
-#line 474 "scanner.l"
+#line 492 "scanner.l"
 { yylval->h = 0x01; return NUM; }
 	YY_BREAK
 case 178:
 YY_RULE_SETUP
-#line 475 "scanner.l"
+#line 493 "scanner.l"
 { yylval->h = 0x02; return NUM; }
 	YY_BREAK
 case 179:
 YY_RULE_SETUP
-#line 476 "scanner.l"
+#line 494 "scanner.l"
 { yylval->h = 0x04; return NUM; }
 	YY_BREAK
 case 180:
 YY_RULE_SETUP
-#line 477 "scanner.l"
+#line 495 "scanner.l"
 { yylval->h = 0x08; return NUM; }
 	YY_BREAK
 case 181:
 YY_RULE_SETUP
-#line 478 "scanner.l"
+#line 496 "scanner.l"
 { yylval->h = 0x10; return NUM; }
 	YY_BREAK
 case 182:
 YY_RULE_SETUP
-#line 479 "scanner.l"
+#line 497 "scanner.l"
 { yylval->h = 0x20; return NUM; }
 	YY_BREAK
 case 183:
 YY_RULE_SETUP
-#line 480 "scanner.l"
+#line 498 "scanner.l"
 { yylval->h = 0x40; return NUM; }
 	YY_BREAK
 case 184:
 YY_RULE_SETUP
-#line 481 "scanner.l"
+#line 499 "scanner.l"
 { yylval->h = 0x80; return NUM; }
 	YY_BREAK
 case 185:
 YY_RULE_SETUP
-#line 482 "scanner.l"
+#line 500 "scanner.l"
 {
 			 yylval->s = sdup(yyextra, (char *)yytext); return ID; }
 	YY_BREAK
 case 186:
 YY_RULE_SETUP
-#line 484 "scanner.l"
+#line 502 "scanner.l"
 { yylval->s = sdup(yyextra, (char *)yytext + 1); return ID; }
 	YY_BREAK
 case 187:
 YY_RULE_SETUP
-#line 485 "scanner.l"
+#line 503 "scanner.l"
 { return LEX_ERROR; }
 	YY_BREAK
 case 188:
 YY_RULE_SETUP
-#line 486 "scanner.l"
+#line 504 "scanner.l"
 ECHO;
 	YY_BREAK
-#line 4476 "scanner.c"
+#line 4494 "scanner.c"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
@@ -5616,7 +5634,7 @@ void yyfree (void * ptr , yyscan_t yyscanner)
 
 #define YYTABLES_NAME "yytables"
 
-#line 486 "scanner.l"
+#line 504 "scanner.l"
 
 
 /*
@@ -5624,27 +5642,20 @@ void yyfree (void * ptr , yyscan_t yyscanner)
  */
 DIAG_ON_FLEX
 
-/*
- * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
- * preceding 0x or 0 and uses hex or octal instead of decimal.
- *
- * On success, sets yylval->h to the value and returns NUM.
- * On failure, sets the BPF error string and returns LEX_ERROR, to force
- * the parse to stop.
- */
-static int
-stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
+stoulen_ret
+stoulen(const char *string, size_t string_len, bpf_u_int32 *val,
+    compiler_state_t *cstate)
 {
 	bpf_u_int32 n = 0;
 	unsigned int digit;
-	char *s = yytext_arg;
+	const char *s = string;
 
 	/*
-	 * yytext_arg is guaranteed either to be a string of decimal digits
+	 * string is guaranteed either to be a string of decimal digits
 	 * or 0[xX] followed by a string of hex digits.
 	 */
-	if (*s == '0') {
-		if (s[1] == 'x' || s[1] == 'X') {
+	if (string_len >= 1 && *s == '0') {
+		if (string_len >= 2  && (s[1] == 'x' || s[1] == 'X')) {
 			/*
 			 * Begins with 0x or 0X, so hex.
 			 * Guaranteed to be all hex digits following the
@@ -5652,13 +5663,25 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 			 * A-F.
 			 */
 			s += 2;	/* skip the prefix */
-			while ((digit = *s++) != '\0') {
+			string_len -= 2;
+			while (string_len != 0) {
+				digit = *s++;
+				string_len--;
 				if (digit >= '0' && digit <= '9')
 					digit = digit - '0';
 				else if (digit >= 'a' && digit <= 'f')
 					digit = digit - 'a' + 10;
-				else
+				else if (digit >= 'A' && digit <= 'F')
 					digit = digit - 'A' + 10;
+				else {
+					/*
+					 * Not a valid hex number.
+					 * Don't treat this as an error,
+					 * in case the caller wants to
+					 * interpret it as something else.
+					 */
+					return STOULEN_NOT_HEX_NUMBER;
+				}
 
 				/*
 				 * Check for overflow.
@@ -5670,10 +5693,10 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 					 * add 4 more; that won't fit
 					 * in 32 bits.
 					 */
-					bpf_set_error(yyextra_arg,
-					    "number %s overflows 32 bits",
-					    yytext_arg);
-					return LEX_ERROR;
+					bpf_set_error(cstate,
+					    "number %.*s overflows 32 bits",
+					   (int)string_len, string);
+					return STOULEN_ERROR;
 				}
 				n = (n << 4) + digit;
 			}
@@ -5685,14 +5708,20 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 			 * report an error.
 			 */
 			s += 1;
-			while ((digit = *s++) != '\0') {
+			string_len -= 1;
+			while (string_len != 0) {
+				digit = *s++;
+				string_len--;
 				if (digit >= '0' && digit <= '7')
 					digit = digit - '0';
 				else {
-					bpf_set_error(yyextra_arg,
-					    "number %s contains non-octal digit",
-					    yytext_arg);
-					return LEX_ERROR;
+					/*
+					 * Not a valid octal number.
+					 * Don't treat this as an error,
+					 * in case the caller wants to
+					 * interpret it as something else.
+					 */
+					return STOULEN_NOT_OCTAL_NUMBER;
 				}
 				if (n > 03777777777U) {
 					/*
@@ -5701,10 +5730,10 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 					 * 3 more; that won't fit in
 					 * 32 bits.
 					 */
-					bpf_set_error(yyextra_arg,
-					    "number %s overflows 32 bits",
-					    yytext_arg);
-					return LEX_ERROR;
+					bpf_set_error(cstate,
+					    "number %.*s overflows 32 bits",
+					   (int)string_len, string);
+					return STOULEN_ERROR;
 				}
 				n = (n << 3) + digit;
 			}
@@ -5713,22 +5742,84 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 		/*
 		 * Decimal.
 		 */
-		while ((digit = *s++) != '\0') {
-			digit = digit - '0';
+		while (string_len != 0) {
+			digit = *s++;
+			string_len--;
+			if (digit >= '0' && digit <= '9')
+				digit = digit - '0';
+			else {
+				/*
+				 * Not a valid decimal number.
+				 * Don't treat this as an error,
+				 * in case the caller wants to
+				 * interpret it as something else.
+				 */
+				return STOULEN_NOT_DECIMAL_NUMBER;
+			}
 #define CUTOFF_DEC	(0xFFFFFFFFU / 10U)
 #define CUTLIM_DEC	(0xFFFFFFFFU % 10U)
 			if (n > CUTOFF_DEC ||
 			    (n == CUTOFF_DEC && digit > CUTLIM_DEC)) {
-				bpf_set_error(yyextra_arg,
-				    "number %s overflows 32 bits",
-				    yytext_arg);
-				return LEX_ERROR;
+				/*
+				 * Adding that digit will result in a
+				 * number that won't fit in 32 bits.
+				 */
+				bpf_set_error(cstate,
+				    "number %.*s overflows 32 bits",
+				   (int)string_len, string);
+				return STOULEN_ERROR;
 			}
 			n = (n * 10) + digit;
 		}
 	}
 
-	yylval_arg->h = n;
-	return NUM;
+	*val = n;
+	return STOULEN_OK;
+}
+
+/*
+ * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
+ * preceding 0x or 0 and uses hex or octal instead of decimal.
+ *
+ * On success, sets yylval->h to the value and returns NUM.
+ * On failure, sets the BPF error string and returns LEX_ERROR, to force
+ * the parse to stop.
+ */
+static int
+stou(const char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
+{
+	stoulen_ret ret;
+
+	ret = stoulen(yytext_arg, strlen(yytext_arg), &yylval_arg->h,
+	    yyextra_arg);
+	switch (ret) {
+
+	case STOULEN_OK:
+		return NUM;
+
+	case STOULEN_NOT_OCTAL_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-octal digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_NOT_HEX_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-hex digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_NOT_DECIMAL_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-decimal digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_ERROR:
+		/* Error already set. */
+		return LEX_ERROR;
+
+	default:
+		/* Should not happen */
+		bpf_set_error(yyextra_arg, "stoulen returned %d - this should not happen", ret);
+		return LEX_ERROR;
+	}
 }
 
diff --git a/scanner.h b/scanner.h
index 9f406ed5..bd06a56c 100644
--- a/scanner.h
+++ b/scanner.h
@@ -4,9 +4,7 @@
 
 #line 6 "scanner.h"
 /* Must come first for _LARGE_FILE_API on AIX. */
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * Must come first to avoid warnings on Windows.
@@ -37,7 +35,27 @@
 
 #include "diag-control.h"
 
-#line 41 "scanner.h"
+/*
+ * Convert string to 32-bit unsigned integer; the string starts at
+ * string and is string_len bytes long.
+ *
+ * On success, sets *val to the value and returns 1.
+ * On failure, sets the BPF error string and returns 0.
+ *
+ * Also used in gencode.c
+ */
+typedef enum {
+	STOULEN_OK,
+	STOULEN_NOT_HEX_NUMBER,
+	STOULEN_NOT_OCTAL_NUMBER,
+	STOULEN_NOT_DECIMAL_NUMBER,
+	STOULEN_ERROR
+} stoulen_ret;
+
+stoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,
+    compiler_state_t *cstate);
+
+#line 59 "scanner.h"
 
 #define  YY_INT_ALIGNED short int
 
@@ -743,9 +761,9 @@ extern int yylex \
 #undef yyTABLES_NAME
 #endif
 
-#line 486 "scanner.l"
+#line 504 "scanner.l"
 
 
-#line 750 "scanner.h"
+#line 768 "scanner.h"
 #undef pcap_IN_HEADER
 #endif /* pcap_HEADER_H */
diff --git a/scanner.l b/scanner.l
index 85fe395a..82e7b318 100644
--- a/scanner.l
+++ b/scanner.l
@@ -1,8 +1,6 @@
 %top {
 /* Must come first for _LARGE_FILE_API on AIX. */
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * Must come first to avoid warnings on Windows.
@@ -32,6 +30,26 @@
 #include "grammar.h"
 
 #include "diag-control.h"
+
+/*
+ * Convert string to 32-bit unsigned integer; the string starts at
+ * string and is string_len bytes long.
+ *
+ * On success, sets *val to the value and returns 1.
+ * On failure, sets the BPF error string and returns 0.
+ *
+ * Also used in gencode.c
+ */
+typedef enum {
+	STOULEN_OK,
+	STOULEN_NOT_HEX_NUMBER,
+	STOULEN_NOT_OCTAL_NUMBER,
+	STOULEN_NOT_DECIMAL_NUMBER,
+	STOULEN_ERROR
+} stoulen_ret;
+
+stoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,
+    compiler_state_t *cstate);
 }
 
 /*
@@ -149,7 +167,7 @@ void pcap_set_column(int, yyscan_t);
 #include "os-proto.h"
 #endif
 
-static int stou(char *, YYSTYPE *, compiler_state_t *);
+static int stou(const char *, YYSTYPE *, compiler_state_t *);
 
 /*
  * Disable diagnostics in the code generated by Flex.
@@ -490,27 +508,20 @@ tcp-cwr			{ yylval->h = 0x80; return NUM; }
  */
 DIAG_ON_FLEX
 
-/*
- * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
- * preceding 0x or 0 and uses hex or octal instead of decimal.
- *
- * On success, sets yylval->h to the value and returns NUM.
- * On failure, sets the BPF error string and returns LEX_ERROR, to force
- * the parse to stop.
- */
-static int
-stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
+stoulen_ret
+stoulen(const char *string, size_t string_len, bpf_u_int32 *val,
+    compiler_state_t *cstate)
 {
 	bpf_u_int32 n = 0;
 	unsigned int digit;
-	char *s = yytext_arg;
+	const char *s = string;
 
 	/*
-	 * yytext_arg is guaranteed either to be a string of decimal digits
+	 * string is guaranteed either to be a string of decimal digits
 	 * or 0[xX] followed by a string of hex digits.
 	 */
-	if (*s == '0') {
-		if (s[1] == 'x' || s[1] == 'X') {
+	if (string_len >= 1 && *s == '0') {
+		if (string_len >= 2  && (s[1] == 'x' || s[1] == 'X')) {
 			/*
 			 * Begins with 0x or 0X, so hex.
 			 * Guaranteed to be all hex digits following the
@@ -518,13 +529,25 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 			 * A-F.
 			 */
 			s += 2;	/* skip the prefix */
-			while ((digit = *s++) != '\0') {
+			string_len -= 2;
+			while (string_len != 0) {
+				digit = *s++;
+				string_len--;
 				if (digit >= '0' && digit <= '9')
 					digit = digit - '0';
 				else if (digit >= 'a' && digit <= 'f')
 					digit = digit - 'a' + 10;
-				else
+				else if (digit >= 'A' && digit <= 'F')
 					digit = digit - 'A' + 10;
+				else {
+					/*
+					 * Not a valid hex number.
+					 * Don't treat this as an error,
+					 * in case the caller wants to
+					 * interpret it as something else.
+					 */
+					return STOULEN_NOT_HEX_NUMBER;
+				}
 
 				/*
 				 * Check for overflow.
@@ -536,10 +559,10 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 					 * add 4 more; that won't fit
 					 * in 32 bits.
 					 */
-					bpf_set_error(yyextra_arg,
-					    "number %s overflows 32 bits",
-					    yytext_arg);
-					return LEX_ERROR;
+					bpf_set_error(cstate,
+					    "number %.*s overflows 32 bits",
+					   (int)string_len, string);
+					return STOULEN_ERROR;
 				}
 				n = (n << 4) + digit;
 			}
@@ -551,14 +574,20 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 			 * report an error.
 			 */
 			s += 1;
-			while ((digit = *s++) != '\0') {
+			string_len -= 1;
+			while (string_len != 0) {
+				digit = *s++;
+				string_len--;
 				if (digit >= '0' && digit <= '7')
 					digit = digit - '0';
 				else {
-					bpf_set_error(yyextra_arg,
-					    "number %s contains non-octal digit",
-					    yytext_arg);
-					return LEX_ERROR;
+					/*
+					 * Not a valid octal number.
+					 * Don't treat this as an error,
+					 * in case the caller wants to
+					 * interpret it as something else.
+					 */
+					return STOULEN_NOT_OCTAL_NUMBER;
 				}
 				if (n > 03777777777U) {
 					/*
@@ -567,10 +596,10 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 					 * 3 more; that won't fit in
 					 * 32 bits.
 					 */
-					bpf_set_error(yyextra_arg,
-					    "number %s overflows 32 bits",
-					    yytext_arg);
-					return LEX_ERROR;
+					bpf_set_error(cstate,
+					    "number %.*s overflows 32 bits",
+					   (int)string_len, string);
+					return STOULEN_ERROR;
 				}
 				n = (n << 3) + digit;
 			}
@@ -579,21 +608,83 @@ stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
 		/*
 		 * Decimal.
 		 */
-		while ((digit = *s++) != '\0') {
-			digit = digit - '0';
+		while (string_len != 0) {
+			digit = *s++;
+			string_len--;
+			if (digit >= '0' && digit <= '9')
+				digit = digit - '0';
+			else {
+				/*
+				 * Not a valid decimal number.
+				 * Don't treat this as an error,
+				 * in case the caller wants to
+				 * interpret it as something else.
+				 */
+				return STOULEN_NOT_DECIMAL_NUMBER;
+			}
 #define CUTOFF_DEC	(0xFFFFFFFFU / 10U)
 #define CUTLIM_DEC	(0xFFFFFFFFU % 10U)
 			if (n > CUTOFF_DEC ||
 			    (n == CUTOFF_DEC && digit > CUTLIM_DEC)) {
-				bpf_set_error(yyextra_arg,
-				    "number %s overflows 32 bits",
-				    yytext_arg);
-				return LEX_ERROR;
+				/*
+				 * Adding that digit will result in a
+				 * number that won't fit in 32 bits.
+				 */
+				bpf_set_error(cstate,
+				    "number %.*s overflows 32 bits",
+				   (int)string_len, string);
+				return STOULEN_ERROR;
 			}
 			n = (n * 10) + digit;
 		}
 	}
 
-	yylval_arg->h = n;
-	return NUM;
+	*val = n;
+	return STOULEN_OK;
+}
+
+/*
+ * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
+ * preceding 0x or 0 and uses hex or octal instead of decimal.
+ *
+ * On success, sets yylval->h to the value and returns NUM.
+ * On failure, sets the BPF error string and returns LEX_ERROR, to force
+ * the parse to stop.
+ */
+static int
+stou(const char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
+{
+	stoulen_ret ret;
+
+	ret = stoulen(yytext_arg, strlen(yytext_arg), &yylval_arg->h,
+	    yyextra_arg);
+	switch (ret) {
+
+	case STOULEN_OK:
+		return NUM;
+
+	case STOULEN_NOT_OCTAL_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-octal digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_NOT_HEX_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-hex digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_NOT_DECIMAL_NUMBER:
+		bpf_set_error(yyextra_arg, "number %s contains non-decimal digit",
+		    yytext_arg);
+		return LEX_ERROR;
+
+	case STOULEN_ERROR:
+		/* Error already set. */
+		return LEX_ERROR;
+
+	default:
+		/* Should not happen */
+		bpf_set_error(yyextra_arg, "stoulen returned %d - this should not happen", ret);
+		return LEX_ERROR;
+	}
 }
diff --git a/sf-pcap.c b/sf-pcap.c
index 42949331..659480b4 100644
--- a/sf-pcap.c
+++ b/sf-pcap.c
@@ -28,9 +28,7 @@
  * dependent values so we can print the dump file on any architecture.
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap-types.h>
 #ifdef _WIN32
@@ -90,7 +88,7 @@
 #define FMESQUITA_TCPDUMP_MAGIC	0xa1b234cd
 
 /*
- * Navtel Communcations' format, with nanosecond timestamps,
+ * Navtel Communications' format, with nanosecond timestamps,
  * as per a request from Dumas Hwang <dumas.hwang@navtelcom.com>.
  */
 #define NAVTEL_TCPDUMP_MAGIC	0xa12b3c4d
@@ -102,16 +100,79 @@
 #define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
 
 /*
- * Mechanism for storing information about a capture in the upper
- * 6 bits of a linktype value in a capture file.
+ * This is a timeval as stored in a savefile.
+ * It has to use the same types everywhere, independent of the actual
+ * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some
+ * platforms and 64-bit tv_sec values on other platforms, and writing
+ * out native `struct timeval' values would mean files could only be
+ * read on systems with the same tv_sec size as the system on which
+ * the file was written.
+ *
+ * THe fields are unsigned, as that's what the pcap draft specification
+ * says they are.  (That gives pcap a 68-year Y2.038K reprieve, although
+ * in 2106 it runs out for good.  pcapng doesn't have that problem,
+ * unless you pick a *really* high time stamp precision.)
+ */
+
+struct pcap_timeval {
+	bpf_u_int32 tv_sec;	/* seconds */
+	bpf_u_int32 tv_usec;	/* microseconds */
+};
+
+/*
+ * This is a `pcap_pkthdr' as actually stored in a savefile.
+ *
+ * Do not change the format of this structure, in any way (this includes
+ * changes that only affect the length of fields in this structure),
+ * and do not make the time stamp anything other than seconds and
+ * microseconds (e.g., seconds and nanoseconds).  Instead:
+ *
+ *	introduce a new structure for the new format;
+ *
+ *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting
+ *	a new magic number for your new capture file format, and, when
+ *	you get the new magic number, put it in "savefile.c";
+ *
+ *	use that magic number for save files with the changed record
+ *	header;
+ *
+ *	make the code in "savefile.c" capable of reading files with
+ *	the old record header as well as files with the new record header
+ *	(using the magic number to determine the header format).
+ *
+ * Then supply the changes by forking the branch at
+ *
+ *	https://github.com/the-tcpdump-group/libpcap/tree/master
  *
- * LT_LINKTYPE_EXT(x) extracts the additional information.
+ * and issuing a pull request, so that future versions of libpcap and
+ * programs that use it (such as tcpdump) will be able to read your new
+ * capture file format.
+ */
+
+struct pcap_sf_pkthdr {
+	struct pcap_timeval ts;	/* time stamp */
+	bpf_u_int32 caplen;	/* length of portion present */
+	bpf_u_int32 len;	/* length of this packet (off wire) */
+};
+
+/*
+ * How a `pcap_pkthdr' is actually stored in savefiles written
+ * by some patched versions of libpcap (e.g. the ones in Red
+ * Hat Linux 6.1 and 6.2).
  *
- * The rest of the bits are for a value describing the link-layer
- * value.  LT_LINKTYPE(x) extracts that value.
+ * Do not change the format of this structure, in any way (this includes
+ * changes that only affect the length of fields in this structure).
+ * Instead, introduce a new structure, as per the above.
  */
-#define LT_LINKTYPE(x)		((x) & 0x03FFFFFF)
-#define LT_LINKTYPE_EXT(x)	((x) & 0xFC000000)
+
+struct pcap_sf_patched_pkthdr {
+	struct pcap_timeval ts;	/* time stamp */
+	bpf_u_int32 caplen;	/* length of portion present */
+	bpf_u_int32 len;	/* length of this packet (off wire) */
+	int index;
+	unsigned short protocol;
+	unsigned char pkt_type;
+};
 
 static int pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **datap);
 
@@ -196,7 +257,7 @@ pcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,
 	    sizeof(hdr) - sizeof(hdr.magic), fp);
 	if (amt_read != sizeof(hdr) - sizeof(hdr.magic)) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 		} else {
 			snprintf(errbuf, PCAP_ERRBUF_SIZE,
@@ -241,6 +302,17 @@ pcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,
 		return NULL;
 	}
 
+	/*
+	 * Check the main reserved field.
+	 */
+	if (LT_RESERVED1(hdr.linktype) != 0) {
+		snprintf(errbuf, PCAP_ERRBUF_SIZE,
+			 "savefile linktype reserved field not zero (0x%08x)",
+			 LT_RESERVED1(hdr.linktype));
+		*err = 1;
+		return NULL;
+	}
+
 	/*
 	 * OK, this is a good pcap file.
 	 * Allocate a pcap_t for it.
@@ -256,7 +328,7 @@ pcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,
 	p->version_minor = hdr.version_minor;
 	p->linktype = linktype_to_dlt(LT_LINKTYPE(hdr.linktype));
 	p->linktype_ext = LT_LINKTYPE_EXT(hdr.linktype);
-	p->snapshot = pcap_adjust_snapshot(p->linktype, hdr.snaplen);
+	p->snapshot = pcapint_adjust_snapshot(p->linktype, hdr.snaplen);
 
 	p->next_packet_op = pcap_next_packet;
 
@@ -414,7 +486,7 @@ pcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,
 		return (NULL);
 	}
 
-	p->cleanup_op = sf_cleanup;
+	p->cleanup_op = pcapint_sf_cleanup;
 
 	return (p);
 }
@@ -461,7 +533,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 	amt_read = fread(&sf_hdr, 1, ps->hdrsize, fp);
 	if (amt_read != ps->hdrsize) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 			return (-1);
 		} else {
@@ -586,7 +658,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 		 * However, perhaps some versions of libpcap failed to
 		 * set the snapshot length correctly in the file header
 		 * or the per-packet header, or perhaps this is a
-		 * corrupted safefile or a savefile built/modified by a
+		 * corrupted savefile or a savefile built/modified by a
 		 * fuzz tester, so we check anyway.  We grow the buffer
 		 * to be big enough for the snapshot length, read up
 		 * to the snapshot length, discard the rest of the
@@ -615,7 +687,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 		amt_read = fread(p->buffer, 1, p->snapshot, fp);
 		if (amt_read != (bpf_u_int32)p->snapshot) {
 			if (ferror(fp)) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				     PCAP_ERRBUF_SIZE, errno,
 				    "error reading dump file");
 			} else {
@@ -646,7 +718,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 			bytes_read += amt_read;
 			if (amt_read != bytes_to_read) {
 				if (ferror(fp)) {
-					pcap_fmt_errmsg_for_errno(p->errbuf,
+					pcapint_fmt_errmsg_for_errno(p->errbuf,
 					    PCAP_ERRBUF_SIZE, errno,
 					    "error reading dump file");
 				} else {
@@ -698,7 +770,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 		amt_read = fread(p->buffer, 1, hdr->caplen, fp);
 		if (amt_read != hdr->caplen) {
 			if (ferror(fp)) {
-				pcap_fmt_errmsg_for_errno(p->errbuf,
+				pcapint_fmt_errmsg_for_errno(p->errbuf,
 				    PCAP_ERRBUF_SIZE, errno,
 				    "error reading dump file");
 			} else {
@@ -711,7 +783,7 @@ pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 	}
 	*data = p->buffer;
 
-	pcap_post_process(p->linktype, p->swapped, hdr, *data);
+	pcapint_post_process(p->linktype, p->swapped, hdr, *data);
 
 	return (1);
 }
@@ -727,9 +799,8 @@ sf_write_header(pcap_t *p, FILE *fp, int linktype, int snaplen)
 
 	/*
 	 * https://www.tcpdump.org/manpages/pcap-savefile.5.txt states:
-	 * thiszone: 4-byte time zone offset; this is always 0.
-	 * sigfigs:  4-byte number giving the accuracy of time stamps
-	 *           in the file; this is always 0.
+	 * thiszone (Reserved1): 4-byte not used - SHOULD be filled with 0
+	 * sigfigs (Reserved2):  4-byte not used - SHOULD be filled with 0
 	 */
 	hdr.thiszone = 0;
 	hdr.sigfigs = 0;
@@ -772,10 +843,17 @@ pcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 		return;
 	/*
 	 * Better not try writing pcap files after
-	 * 2038-01-19 03:14:07 UTC; switch to pcapng.
+	 * 2106-02-07 06:28:15 UTC; switch to pcapng.
+	 * (And better not try writing pcap files with time stamps
+	 * that predate 1970-01-01 00:00:00 UTC; that's not supported.
+	 * You could try using pcapng with the if_tsoffset field in
+	 * the IDB for the interface(s) with packets with those time
+	 * stamps, but you may also have to get a link-layer type for
+	 * IBM Bisync or whatever link layer even older forms
+	 * of computer communication used.)
 	 */
-	sf_hdr.ts.tv_sec  = (bpf_int32)h->ts.tv_sec;
-	sf_hdr.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
+	sf_hdr.ts.tv_sec  = (bpf_u_int32)h->ts.tv_sec;
+	sf_hdr.ts.tv_usec = (bpf_u_int32)h->ts.tv_usec;
 	sf_hdr.caplen     = h->caplen;
 	sf_hdr.len        = h->len;
 	/*
@@ -809,7 +887,7 @@ pcap_setup_dump(pcap_t *p, int linktype, FILE *f, const char *fname)
 		setvbuf(f, NULL, _IONBF, 0);
 #endif
 	if (sf_write_header(p, f, linktype, p->snapshot) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't write to %s", fname);
 		if (f != stdout)
 			(void)fclose(f);
@@ -861,9 +939,9 @@ pcap_dump_open(pcap_t *p, const char *fname)
 		 * required on Windows, as the file is a binary file
 		 * and must be written in binary mode.
 		 */
-		f = charset_fopen(fname, "wb");
+		f = pcapint_charset_fopen(fname, "wb");
 		if (f == NULL) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "%s", fname);
 			return (NULL);
 		}
@@ -884,14 +962,14 @@ pcap_dump_hopen(pcap_t *p, intptr_t osfd)
 
 	fd = _open_osfhandle(osfd, _O_APPEND);
 	if (fd < 0) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "_open_osfhandle");
 		return NULL;
 	}
 
 	file = _fdopen(fd, "wb");
 	if (file == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "_fdopen");
 		_close(fd);
 		return NULL;
@@ -961,9 +1039,9 @@ pcap_dump_open_append(pcap_t *p, const char *fname)
 	 * even though it does nothing.  It's required on Windows, as the
 	 * file is a binary file and must be read in binary mode.
 	 */
-	f = charset_fopen(fname, "ab+");
+	f = pcapint_charset_fopen(fname, "ab+");
 	if (f == NULL) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "%s", fname);
 		return (NULL);
 	}
@@ -981,7 +1059,7 @@ pcap_dump_open_append(pcap_t *p, const char *fname)
 	 * compliant systems or on Windows.
 	 */
 	if (fseek(f, 0, SEEK_SET) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't seek to the beginning of %s", fname);
 		(void)fclose(f);
 		return (NULL);
@@ -989,7 +1067,7 @@ pcap_dump_open_append(pcap_t *p, const char *fname)
 	amt_read = fread(&ph, 1, sizeof (ph), f);
 	if (amt_read != sizeof (ph)) {
 		if (ferror(f)) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "%s", fname);
 			(void)fclose(f);
 			return (NULL);
@@ -1097,7 +1175,7 @@ pcap_dump_open_append(pcap_t *p, const char *fname)
 		 * A header isn't present; attempt to write it.
 		 */
 		if (sf_write_header(p, f, linktype, p->snapshot) == -1) {
-			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "Can't write to %s", fname);
 			(void)fclose(f);
 			return (NULL);
@@ -1112,7 +1190,7 @@ pcap_dump_open_append(pcap_t *p, const char *fname)
 	 * are done at the end of the file in that mode.
 	 */
 	if (fseek(f, 0, SEEK_END) == -1) {
-		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
+		pcapint_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
 		    errno, "Can't seek to the end of %s", fname);
 		(void)fclose(f);
 		return (NULL);
diff --git a/sf-pcapng.c b/sf-pcapng.c
index 058a7244..2a756b4f 100644
--- a/sf-pcapng.c
+++ b/sf-pcapng.c
@@ -21,9 +21,7 @@
  * sf-pcapng.c - pcapng-file-format-specific code from savefile.c
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap/pcap-inttypes.h>
 
@@ -203,7 +201,7 @@ struct pcap_ng_if {
 	uint64_t tsresol;		/* time stamp resolution */
 	tstamp_scale_type_t scale_type;	/* how to scale */
 	uint64_t scale_factor;		/* time stamp scale factor for power-of-10 tsresol */
-	uint64_t tsoffset;		/* time stamp offset */
+	int64_t tsoffset;		/* time stamp offset */
 };
 
 /*
@@ -263,7 +261,7 @@ read_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,
 	amt_read = fread(buf, 1, bytes_to_read, fp);
 	if (amt_read != bytes_to_read) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 		} else {
 			if (amt_read == 0 && !fail_on_eof)
@@ -460,7 +458,7 @@ get_optvalue_from_block_data(struct block_cursor *cursor,
 
 static int
 process_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,
-    uint64_t *tsoffset, int *is_binary, char *errbuf)
+    int64_t *tsoffset, int *is_binary, char *errbuf)
 {
 	struct option_header *opthdr;
 	void *optvalue;
@@ -595,7 +593,7 @@ add_interface(pcap_t *p, struct interface_description_block *idbp,
 {
 	struct pcap_ng_sf *ps;
 	uint64_t tsresol;
-	uint64_t tsoffset;
+	int64_t tsoffset;
 	int is_binary;
 
 	ps = p->priv;
@@ -820,7 +818,7 @@ pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
 	amt_read = fread(&total_length, 1, sizeof(total_length), fp);
 	if (amt_read < sizeof(total_length)) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 			*err = 1;
 			return (NULL);	/* fail */
@@ -835,7 +833,7 @@ pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
 	amt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);
 	if (amt_read < sizeof(byte_order_magic)) {
 		if (ferror(fp)) {
-			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
+			pcapint_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, "error reading dump file");
 			*err = 1;
 			return (NULL);	/* fail */
@@ -1060,7 +1058,7 @@ pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
 
 done:
 	p->linktype = linktype_to_dlt(idbp->linktype);
-	p->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);
+	p->snapshot = pcapint_adjust_snapshot(p->linktype, idbp->snaplen);
 	p->linktype_ext = 0;
 
 	/*
@@ -1090,7 +1088,7 @@ pcap_ng_cleanup(pcap_t *p)
 	struct pcap_ng_sf *ps = p->priv;
 
 	free(ps->ifaces);
-	sf_cleanup(p);
+	pcapint_sf_cleanup(p);
 }
 
 /*
@@ -1261,7 +1259,7 @@ pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
 			 * snapshot length.
 			 */
 			if ((bpf_u_int32)p->snapshot !=
-			    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {
+			    pcapint_adjust_snapshot(p->linktype, idbp->snaplen)) {
 				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
 				    "an interface has a snapshot length %u different from the snapshot length of the first interface",
 				    idbp->snaplen);
@@ -1489,7 +1487,7 @@ found:
 	}
 #ifdef _WIN32
 	/*
-	 * tv_sec and tv_used in the Windows struct timeval are both
+	 * tv_sec and tv_usec in the Windows struct timeval are both
 	 * longs.
 	 */
 	hdr->ts.tv_sec = (long)sec;
@@ -1512,7 +1510,7 @@ found:
 	if (*data == NULL)
 		return (-1);
 
-	pcap_post_process(p->linktype, p->swapped, hdr, *data);
+	pcapint_post_process(p->linktype, p->swapped, hdr, *data);
 
 	return (1);
 }
diff --git a/sockutils.c b/sockutils.c
index 1c07f76f..e1cc4e30 100644
--- a/sockutils.c
+++ b/sockutils.c
@@ -30,9 +30,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 /*
  * \file sockutils.c
@@ -163,10 +161,10 @@ void sock_vfmterrmsg(char *errbuf, size_t errbuflen, int errcode,
 		return;
 
 #ifdef _WIN32
-	pcap_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errcode,
+	pcapint_vfmt_errmsg_for_win32_err(errbuf, errbuflen, errcode,
 	    fmt, ap);
 #else
-	pcap_vfmt_errmsg_for_errno(errbuf, errbuflen, errcode,
+	pcapint_vfmt_errmsg_for_errno(errbuf, errbuflen, errcode,
 	    fmt, ap);
 #endif
 }
@@ -199,7 +197,7 @@ void sock_geterrmsg(char *errbuf, size_t errbuflen, const char *fmt, ...)
  * These are sorted by how likely they are to be the "underlying" problem,
  * so that lower-rated errors for a given address in a given family
  * should not overwrite higher-rated errors for another address in that
- * family, and higher-rated errors should overwrit elower-rated errors.
+ * family, and higher-rated errors should overwrite lower-rated errors.
  */
 typedef enum {
 	SOCK_CONNERR,		/* connection error */
@@ -230,7 +228,7 @@ static sock_errtype sock_geterrtype(int errcode)
 		 * and we're trying the wrong address family.
 		 *
 		 * These overwrite all other errors, as they indicate
-		 * that, even if somethng else went wrong in another
+		 * that, even if something else went wrong in another
 		 * attempt, this probably wouldn't work even if the
 		 * other problems were fixed.
 		 */
@@ -334,9 +332,6 @@ int sock_init(char *errbuf, int errbuflen)
 		{
 			if (errbuf)
 				snprintf(errbuf, errbuflen, "Failed to initialize Winsock\n");
-
-			WSACleanup();
-
 			return -1;
 		}
 	}
@@ -432,10 +427,10 @@ static int compare_addrs_to_try_by_status(const void *a, const void *b)
 	return addr_a->errtype - addr_b->errtype;
 }
 
-static SOCKET sock_create_socket(struct addrinfo *addrinfo, char *errbuf,
+static PCAP_SOCKET sock_create_socket(struct addrinfo *addrinfo, char *errbuf,
     int errbuflen)
 {
-	SOCKET sock;
+	PCAP_SOCKET sock;
 #ifdef SO_NOSIGPIPE
 	int on = 1;
 #endif
@@ -501,9 +496,10 @@ static SOCKET sock_create_socket(struct addrinfo *addrinfo, char *errbuf,
  * if everything is fine, INVALID_SOCKET if some errors occurred. The error message is returned
  * in the 'errbuf' variable.
  */
-SOCKET sock_open(const char *host, struct addrinfo *addrinfo, int server, int nconn, char *errbuf, int errbuflen)
+PCAP_SOCKET sock_open(const char *host, struct addrinfo *addrinfo,
+    int server, int nconn, char *errbuf, int errbuflen)
 {
-	SOCKET sock;
+	PCAP_SOCKET sock;
 
 	/* This is a server socket */
 	if (server)
@@ -872,7 +868,7 @@ SOCKET sock_open(const char *host, struct addrinfo *addrinfo, int server, int nc
  * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned
  * in the 'errbuf' variable.
  */
-int sock_close(SOCKET sock, char *errbuf, int errbuflen)
+int sock_close(PCAP_SOCKET sock, char *errbuf, int errbuflen)
 {
 	/*
 	 * SHUT_WR: subsequent calls to the send function are disallowed.
@@ -881,7 +877,7 @@ int sock_close(SOCKET sock, char *errbuf, int errbuflen)
 	 */
 	if (shutdown(sock, SHUT_WR))
 	{
-		sock_geterrmsg(errbuf, errbuflen, "shutdown() feiled");
+		sock_geterrmsg(errbuf, errbuflen, "shutdown() failed");
 		/* close the socket anyway */
 		closesocket(sock);
 		return -1;
@@ -1004,7 +1000,7 @@ get_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,
 			/*
 			 * Assumed to be UN*X.
 			 */
-			pcap_fmt_errmsg_for_errno(errbuf, errbuflen, errno,
+			pcapint_fmt_errmsg_for_errno(errbuf, errbuflen, errno,
 			    "%sAn error occurred when looking up %s",
 			    prefix, hostport);
 			break;
@@ -1043,7 +1039,7 @@ get_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,
 }
 
 /*
- * \brief Checks that the address, port and flags given are valids and it returns an 'addrinfo' structure.
+ * \brief Checks that the address, port and flags given are valid and it returns an 'addrinfo' structure.
  *
  * This function basically calls the getaddrinfo() calls, and it performs a set of sanity checks
  * to control that everything is fine (e.g. a TCP socket cannot have a mcast address, and such).
@@ -1069,20 +1065,21 @@ get_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,
  * \param errbuflen: length of the buffer that will contains the error. The error message cannot be
  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.
  *
- * \return '0' if everything is fine, '-1' if some errors occurred. The error message is returned
- * in the 'errbuf' variable. The addrinfo variable that has to be used in the following sockets calls is
- * returned into the addrinfo parameter.
+ * \return a pointer to the first element in a list of addrinfo structures
+ * if everything is fine, NULL if some errors occurred. The error message
+ * is returned in the 'errbuf' variable.
  *
- * \warning The 'addrinfo' variable has to be deleted by the programmer by calling freeaddrinfo() when
- * it is no longer needed.
+ * \warning The list of addrinfo structures returned has to be deleted by
+ * the programmer by calling freeaddrinfo() when it is no longer needed.
  *
  * \warning This function requires the 'hints' variable as parameter. The semantic of this variable is the same
  * of the one of the corresponding variable used into the standard getaddrinfo() socket function. We suggest
  * the programmer to look at that function in order to set the 'hints' variable appropriately.
  */
-int sock_initaddress(const char *host, const char *port,
-    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)
+struct addrinfo *sock_initaddress(const char *host, const char *port,
+    struct addrinfo *hints, char *errbuf, int errbuflen)
 {
+	struct addrinfo *addrinfo;
 	int retval;
 
 	/*
@@ -1094,9 +1091,13 @@ int sock_initaddress(const char *host, const char *port,
 	 * as those messages won't talk about a problem with the port if
 	 * no port was specified.
 	 */
-	retval = getaddrinfo(host, port == NULL ? "0" : port, hints, addrinfo);
+	retval = getaddrinfo(host, port == NULL ? "0" : port, hints, &addrinfo);
 	if (retval != 0)
 	{
+		/*
+		 * That call failed.
+		 * Determine whether the problem is that the host is bad.
+		 */
 		if (errbuf)
 		{
 			if (host != NULL && port != NULL) {
@@ -1108,7 +1109,7 @@ int sock_initaddress(const char *host, const char *port,
 				int try_retval;
 
 				try_retval = getaddrinfo(host, NULL, hints,
-				    addrinfo);
+				    &addrinfo);
 				if (try_retval == 0) {
 					/*
 					 * Worked with just the host,
@@ -1117,14 +1118,16 @@ int sock_initaddress(const char *host, const char *port,
 					 *
 					 * Free up the address info first.
 					 */
-					freeaddrinfo(*addrinfo);
+					freeaddrinfo(addrinfo);
 					get_gai_errstring(errbuf, errbuflen,
 					    "", retval, NULL, port);
 				} else {
 					/*
 					 * Didn't work with just the host,
 					 * so assume the problem is
-					 * with the host.
+					 * with the host; we assume
+					 * the original error indicates
+					 * the underlying problem.
 					 */
 					get_gai_errstring(errbuf, errbuflen,
 					    "", retval, host, NULL);
@@ -1132,13 +1135,14 @@ int sock_initaddress(const char *host, const char *port,
 			} else {
 				/*
 				 * Either the host or port was null, so
-				 * there's nothing to determine.
+				 * there's nothing to determine; report
+				 * the error from the original call.
 				 */
 				get_gai_errstring(errbuf, errbuflen, "",
 				    retval, host, port);
 			}
 		}
-		return -1;
+		return NULL;
 	}
 	/*
 	 * \warning SOCKET: I should check all the accept() in order to bind to all addresses in case
@@ -1153,30 +1157,28 @@ int sock_initaddress(const char *host, const char *port,
 	 * ignore all addresses that are neither?  (What, no IPX
 	 * support? :-))
 	 */
-	if (((*addrinfo)->ai_family != PF_INET) &&
-	    ((*addrinfo)->ai_family != PF_INET6))
+	if ((addrinfo->ai_family != PF_INET) &&
+	    (addrinfo->ai_family != PF_INET6))
 	{
 		if (errbuf)
 			snprintf(errbuf, errbuflen, "getaddrinfo(): socket type not supported");
-		freeaddrinfo(*addrinfo);
-		*addrinfo = NULL;
-		return -1;
+		freeaddrinfo(addrinfo);
+		return NULL;
 	}
 
 	/*
 	 * You can't do multicast (or broadcast) TCP.
 	 */
-	if (((*addrinfo)->ai_socktype == SOCK_STREAM) &&
-	    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))
+	if ((addrinfo->ai_socktype == SOCK_STREAM) &&
+	    (sock_ismcastaddr(addrinfo->ai_addr) == 0))
 	{
 		if (errbuf)
 			snprintf(errbuf, errbuflen, "getaddrinfo(): multicast addresses are not valid when using TCP streams");
-		freeaddrinfo(*addrinfo);
-		*addrinfo = NULL;
-		return -1;
+		freeaddrinfo(addrinfo);
+		return NULL;
 	}
 
-	return 0;
+	return addrinfo;
 }
 
 /*
@@ -1206,8 +1208,8 @@ int sock_initaddress(const char *host, const char *port,
  * '-2' if we got one of those errors.
  * For errors, an error message is returned in the 'errbuf' variable.
  */
-int sock_send(SOCKET sock, SSL *ssl _U_NOSSL_, const char *buffer, size_t size,
-    char *errbuf, int errbuflen)
+int sock_send(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, const char *buffer,
+    size_t size, char *errbuf, int errbuflen)
 {
 	int remaining;
 	ssize_t nsent;
@@ -1327,7 +1329,7 @@ int sock_send(SOCKET sock, SSL *ssl _U_NOSSL_, const char *buffer, size_t size,
  * \param totsize: total size of the buffer into which data is being copied.
  *
  * \param checkonly: '1' if we do not want to copy data into the buffer and we
- * want just do a buffer ovreflow control, '0' if data has to be copied as well.
+ * want just do a buffer overflow control, '0' if data has to be copied as well.
  *
  * \param errbuf: a pointer to an user-allocated buffer that will contain the complete
  * error message. This buffer has to be at least 'errbuflen' in length.
@@ -1410,7 +1412,7 @@ int sock_bufferize(const void *data, int size, char *outbuf, int *offset, int to
  * The error message is returned in the 'errbuf' variable.
  */
 
-int sock_recv(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,
+int sock_recv(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,
     int flags, char *errbuf, int errbuflen)
 {
 	int recv_flags = 0;
@@ -1517,8 +1519,8 @@ int sock_recv(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,
  *
  * Returns the size of the datagram on success or -1 on error.
  */
-int sock_recv_dgram(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,
-    char *errbuf, int errbuflen)
+int sock_recv_dgram(PCAP_SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer,
+    size_t size, char *errbuf, int errbuflen)
 {
 	ssize_t nread;
 #ifndef _WIN32
@@ -1665,7 +1667,8 @@ int sock_recv_dgram(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,
  * \return '0' if everything is fine, '-1' if some errors occurred.
  * The error message is returned in the 'errbuf' variable.
  */
-int sock_discard(SOCKET sock, SSL *ssl, int size, char *errbuf, int errbuflen)
+int sock_discard(PCAP_SOCKET sock, SSL *ssl, int size, char *errbuf,
+    int errbuflen)
 {
 #define TEMP_BUF_SIZE 32768
 
@@ -1728,7 +1731,7 @@ int sock_discard(SOCKET sock, SSL *ssl, int size, char *errbuf, int errbuflen)
  * - '-1' in case the host does not belong to the host list (and therefore it is not allowed to connect
  * - '-2' in case or error. The error message is returned in the 'errbuf' variable.
  */
-int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen)
+int sock_check_hostlist(const char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen)
 {
 	/* checks if the connecting host is among the ones allowed */
 	if ((hostlist) && (hostlist[0]))
@@ -1751,7 +1754,7 @@ int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage
 			return -2;
 		}
 
-		token = pcap_strtok_r(temphostlist, sep, &lasts);
+		token = pcapint_strtok_r(temphostlist, sep, &lasts);
 
 		/* it avoids a warning in the compilation ('addrinfo used but not initialized') */
 		addrinfo = NULL;
@@ -1781,7 +1784,7 @@ int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage
 				getaddrinfo_failed = 1;
 
 				/* Get next token */
-				token = pcap_strtok_r(NULL, sep, &lasts);
+				token = pcapint_strtok_r(NULL, sep, &lasts);
 				continue;
 			}
 
@@ -1807,7 +1810,7 @@ int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage
 			addrinfo = NULL;
 
 			/* Get next token */
-			token = pcap_strtok_r(NULL, sep, &lasts);
+			token = pcapint_strtok_r(NULL, sep, &lasts);
 		}
 
 		if (addrinfo)
@@ -1848,7 +1851,7 @@ int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage
  * i.e. an sockaddr_storage structure.
  *
  * The two structures do not need to be sockaddr_storage; you can have both 'sockaddr_in' and
- * sockaddr_in6, properly acsted in order to be compliant to the function interface.
+ * sockaddr_in6, properly casted in order to be compliant to the function interface.
  *
  * This function will return '0' if the two addresses matches, '-1' if not.
  *
@@ -1923,7 +1926,8 @@ int sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second
  * \warning If the socket is using a connectionless protocol, the address may not be available
  * until I/O occurs on the socket.
  */
-int sock_getmyinfo(SOCKET sock, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen)
+int sock_getmyinfo(PCAP_SOCKET sock, char *address, int addrlen, char *port,
+    int portlen, int flags, char *errbuf, int errbuflen)
 {
 	struct sockaddr_storage mysockaddr;
 	socklen_t sockaddrlen;
@@ -2011,7 +2015,7 @@ int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *addres
 			(memcmp(&((struct sockaddr_in6 *) sockaddr)->sin6_addr, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", sizeof(struct in6_addr)) == 0))
 		{
 			if (address)
-				pcap_strlcpy(address, SOCKET_NAME_NULL_DAD, addrlen);
+				pcapint_strlcpy(address, SOCKET_NAME_NULL_DAD, addrlen);
 			return retval;
 		}
 	}
@@ -2028,13 +2032,13 @@ int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *addres
 
 		if (address)
 		{
-			pcap_strlcpy(address, SOCKET_NO_NAME_AVAILABLE, addrlen);
+			pcapint_strlcpy(address, SOCKET_NO_NAME_AVAILABLE, addrlen);
 			address[addrlen - 1] = 0;
 		}
 
 		if (port)
 		{
-			pcap_strlcpy(port, SOCKET_NO_PORT_AVAILABLE, portlen);
+			pcapint_strlcpy(port, SOCKET_NO_PORT_AVAILABLE, portlen);
 			port[portlen - 1] = 0;
 		}
 
@@ -2082,7 +2086,6 @@ int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *addres
  */
 int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)
 {
-	int retval;
 	struct addrinfo *addrinfo;
 	struct addrinfo hints;
 
@@ -2090,7 +2093,9 @@ int sock_present2network(const char *address, struct sockaddr_storage *sockaddr,
 
 	hints.ai_family = addr_family;
 
-	if ((retval = sock_initaddress(address, "22222" /* fake port */, &hints, &addrinfo, errbuf, errbuflen)) == -1)
+	addrinfo = sock_initaddress(address, "22222" /* fake port */, &hints,
+	    errbuf, errbuflen);
+	if (addrinfo == NULL)
 		return 0;
 
 	if (addrinfo->ai_family == PF_INET)
diff --git a/sockutils.h b/sockutils.h
index a488d8fc..34d4e95d 100644
--- a/sockutils.h
+++ b/sockutils.h
@@ -138,24 +138,26 @@ void sock_fmterrmsg(char *errbuf, size_t errbuflen, int errcode,
     PCAP_FORMAT_STRING(const char *fmt), ...) PCAP_PRINTFLIKE(4, 5);
 void sock_geterrmsg(char *errbuf, size_t errbuflen,
     PCAP_FORMAT_STRING(const char *fmt), ...)  PCAP_PRINTFLIKE(3, 4);
-int sock_initaddress(const char *address, const char *port,
-    struct addrinfo *hints, struct addrinfo **addrinfo,
+struct addrinfo *sock_initaddress(const char *address, const char *port,
+    struct addrinfo *hints, char *errbuf, int errbuflen);
+int sock_recv(PCAP_SOCKET sock, SSL *, void *buffer, size_t size,
+    int receiveall, char *errbuf, int errbuflen);
+int sock_recv_dgram(PCAP_SOCKET sock, SSL *, void *buffer, size_t size,
     char *errbuf, int errbuflen);
-int sock_recv(SOCKET sock, SSL *, void *buffer, size_t size, int receiveall,
-    char *errbuf, int errbuflen);
-int sock_recv_dgram(SOCKET sock, SSL *, void *buffer, size_t size,
-    char *errbuf, int errbuflen);
-SOCKET sock_open(const char *host, struct addrinfo *addrinfo, int server, int nconn, char *errbuf, int errbuflen);
-int sock_close(SOCKET sock, char *errbuf, int errbuflen);
+PCAP_SOCKET sock_open(const char *host, struct addrinfo *addrinfo, int server,
+    int nconn, char *errbuf, int errbuflen);
+int sock_close(PCAP_SOCKET sock, char *errbuf, int errbuflen);
 
-int sock_send(SOCKET sock, SSL *, const char *buffer, size_t size,
+int sock_send(PCAP_SOCKET sock, SSL *, const char *buffer, size_t size,
     char *errbuf, int errbuflen);
 int sock_bufferize(const void *data, int size, char *outbuf, int *offset, int totsize, int checkonly, char *errbuf, int errbuflen);
-int sock_discard(SOCKET sock, SSL *, int size, char *errbuf, int errbuflen);
-int	sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen);
+int sock_discard(PCAP_SOCKET sock, SSL *, int size, char *errbuf,
+    int errbuflen);
+int	sock_check_hostlist(const char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen);
 int sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second);
 
-int sock_getmyinfo(SOCKET sock, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen);
+int sock_getmyinfo(PCAP_SOCKET sock, char *address, int addrlen, char *port,
+    int portlen, int flags, char *errbuf, int errbuflen);
 
 int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, size_t errbuflen);
 int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen);
diff --git a/sslutils.c b/sslutils.c
index 7274cc34..c75b5378 100644
--- a/sslutils.c
+++ b/sslutils.c
@@ -30,9 +30,7 @@
  *
  */
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #ifdef HAVE_OPENSSL
 #include <stdlib.h>
@@ -133,7 +131,7 @@ die:
 	return -1;
 }
 
-SSL *ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen)
+SSL *ssl_promotion(int is_server, PCAP_SOCKET s, char *errbuf, size_t errbuflen)
 {
 	if (ssl_init_once(is_server, 1, errbuf, errbuflen) < 0) {
 		return NULL;
diff --git a/sslutils.h b/sslutils.h
index 6316364e..3a36c61b 100644
--- a/sslutils.h
+++ b/sslutils.h
@@ -34,9 +34,15 @@
 #define __SSLUTILS_H__
 
 #ifdef HAVE_OPENSSL
-#include "pcap/socket.h"  // for SOCKET
+#include "pcap/socket.h"  // for PCAP_SOCKET
+// If this is OpenSSL 1.0, at least one header may trigger a -Wdocumentation
+// in Clang, which should not be a problem of this header or a file that
+// includes it.
+#include "diag-control.h"
+DIAG_OFF_DOCUMENTATION
 #include <openssl/ssl.h>
 #include <openssl/err.h>
+DIAG_ON_DOCUMENTATION
 
 /*
  * Utility functions
@@ -45,7 +51,7 @@
 void ssl_set_certfile(const char *certfile);
 void ssl_set_keyfile(const char *keyfile);
 int ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen);
-SSL *ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen);
+SSL *ssl_promotion(int is_server, PCAP_SOCKET s, char *errbuf, size_t errbuflen);
 void ssl_finish(SSL *ssl);
 int ssl_send(SSL *, char const *buffer, int size, char *errbuf, size_t errbuflen);
 int ssl_recv(SSL *, char *buffer, int size, char *errbuf, size_t errbuflen);
diff --git a/testprogs/Makefile.in b/testprogs/Makefile.in
index d3fd328c..d6b2351e 100644
--- a/testprogs/Makefile.in
+++ b/testprogs/Makefile.in
@@ -169,4 +169,4 @@ tags: $(TAGFILES)
 	ctags -wtd $(TAGFILES)
 
 depend:
-	$(MKDEP) -c "$(CC)" -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
+	$(MKDEP) -c $(CC) -m "$(DEPENDENCY_CFLAG)" -s "$(srcdir)" $(CFLAGS) $(DEFS) $(INCLS) $(SRC)
diff --git a/testprogs/filtertest.c b/testprogs/filtertest.c
index 15556d04..17299755 100644
--- a/testprogs/filtertest.c
+++ b/testprogs/filtertest.c
@@ -27,9 +27,7 @@ static const char copyright[] _U_ =
 The Regents of the University of California.  All rights reserved.\n";
 #endif
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <pcap.h>
 #include <stdio.h>
@@ -252,10 +250,10 @@ main(int argc, char **argv)
 		case 'g':
 #ifdef BDEBUG
 			++gflag;
+			break;
 #else
 			error("libpcap and filtertest not built with optimizer debugging enabled");
 #endif
-			break;
 
 		case 'F':
 			infile = optarg;
@@ -272,12 +270,10 @@ main(int argc, char **argv)
 
 			case 0:
 				error("invalid netmask %s", optarg);
-				break;
 
 			case -1:
 				error("invalid netmask %s: %s", optarg,
 				    pcap_strerror(errno));
-				break;
 
 			case 1:
 				netmask = addr;
diff --git a/testprogs/findalldevstest-perf.c b/testprogs/findalldevstest-perf.c
index 16f53cdc..b56b44d1 100644
--- a/testprogs/findalldevstest-perf.c
+++ b/testprogs/findalldevstest-perf.c
@@ -1,6 +1,4 @@
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stdlib.h>
 #include <string.h>
diff --git a/testprogs/findalldevstest.c b/testprogs/findalldevstest.c
index 06293209..e4ec9529 100644
--- a/testprogs/findalldevstest.c
+++ b/testprogs/findalldevstest.c
@@ -1,6 +1,4 @@
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stdlib.h>
 #include <string.h>
@@ -190,7 +188,9 @@ static int ifprint(pcap_if_t *d)
 {
   pcap_addr_t *a;
   char ipv4_buf[INET_ADDRSTRLEN];
+#ifdef INET6
   char ipv6_buf[INET6_ADDRSTRLEN];
+#endif
   const char *sep;
   int status = 1; /* success */
 
@@ -256,7 +256,7 @@ static int ifprint(pcap_if_t *d)
     if (a->addr != NULL)
       switch(a->addr->sa_family) {
       case AF_INET:
-        printf("\tAddress Family: AF_INET\n");
+        printf("\tAddress Family: AF_INET (%d)\n", a->addr->sa_family);
         if (a->addr)
           printf("\t\tAddress: %s\n",
             inet_ntop(AF_INET,
@@ -280,7 +280,7 @@ static int ifprint(pcap_if_t *d)
         break;
 #ifdef INET6
       case AF_INET6:
-        printf("\tAddress Family: AF_INET6\n");
+        printf("\tAddress Family: AF_INET6 (%d)\n", a->addr->sa_family);
         if (a->addr)
           printf("\t\tAddress: %s\n",
             inet_ntop(AF_INET6,
diff --git a/testprogs/valgrindtest.c b/testprogs/valgrindtest.c
index 55055ca3..22b75b0d 100644
--- a/testprogs/valgrindtest.c
+++ b/testprogs/valgrindtest.c
@@ -51,9 +51,7 @@ static const char copyright[] _U_ =
 The Regents of the University of California.  All rights reserved.\n";
 #endif
 
-#ifdef HAVE_CONFIG_H
 #include <config.h>
-#endif
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -72,7 +70,7 @@ The Regents of the University of California.  All rights reserved.\n";
 #if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(_AIX) || defined(sun)
 /* OS with BPF - use BPF */
 #define USE_BPF
-#elif defined(linux)
+#elif defined(__linux__)
 /* Linux - use socket filters */
 #define USE_SOCKET_FILTERS
 #else
diff --git a/thread-local.h b/thread-local.h
new file mode 100644
index 00000000..c9cbda2c
--- /dev/null
+++ b/thread-local.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 1994, 1995, 1996
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef thread_local_h
+#define	thread_local_h
+
+/*
+ * This defines thread_local to specify thread-local storage, if it
+ * is not already defined.
+ *
+ * C11, if __STDC_NO_THREADS__ is not defined to be 1, defines
+ * _Thread_local to indicate thread-local storage.  (You can also
+ * include <threads.h> to so define it, but we don't use any of
+ * the other stuff there.)
+ *
+ * Otherwise, we define it ourselves, based on the compiler.
+ *
+ * This is taken from https://stackoverflow.com/a/18298965/16139739.
+ */
+#ifndef thread_local
+  #if __STDC_VERSION__ >= 201112 && !defined __STDC_NO_THREADS__
+    #define thread_local _Thread_local
+  #elif defined __TINYC__
+    #define thread_local
+    #warning "Some libpcap calls will not be thread-safe."
+  #elif defined _WIN32 && ( \
+         defined _MSC_VER || \
+         defined __ICL || \
+         defined __DMC__ || \
+         defined __BORLANDC__ )
+    #define thread_local __declspec(thread)
+  /* note that ICC (linux) and Clang are covered by __GNUC__ */
+  #elif defined __GNUC__ || \
+         defined __SUNPRO_C || \
+         defined __xlC__
+    #define thread_local __thread
+  #else
+    #error "Cannot define thread_local"
+  #endif
+#endif
+
+#endif
```

