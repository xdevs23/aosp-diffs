```diff
diff --git a/Android.bp b/Android.bp
index 80048b7..3192b79 100644
--- a/Android.bp
+++ b/Android.bp
@@ -32,9 +32,14 @@ cc_library_static {
     ],
     srcs: [
         "src/stdlib/bsearch.cpp",
+        "src/string/memchr.cpp",
         "src/string/memrchr.cpp",
+        "src/string/strchr.cpp",
+        "src/string/strchrnul.cpp",
         "src/string/strlcat.cpp",
         "src/string/strlcpy.cpp",
+        "src/string/strnlen.cpp",
+        "src/string/strrchr.cpp",
     ],
     cppflags: [
         // Necessary for non-namespaced exports.
@@ -72,16 +77,21 @@ cc_library_static {
             // arm-optimized-routines, and aren't yet heavily optimized by
             // llvm-libc.
             exclude_srcs: [
+                "src/string/memchr.cpp",
                 "src/string/memrchr.cpp",
+                "src/string/strchr.cpp",
+                "src/string/strchrnul.cpp",
+                "src/string/strnlen.cpp",
+                "src/string/strrchr.cpp",
             ],
         },
-        x86_64: {
-            srcs: [
+        riscv64: {
+            // These have hand-vectorized impls in Bionic, and aren't yet
+            // heavily optimized by llvm-libc.
+            exclude_srcs: [
                 "src/string/memchr.cpp",
                 "src/string/strchr.cpp",
-                "src/string/strchrnul.cpp",
                 "src/string/strnlen.cpp",
-                "src/string/strrchr.cpp",
             ],
         },
     },
@@ -115,32 +125,37 @@ cc_defaults {
 }
 
 cc_test {
-    // TODO: rename test to simply llvmlibc_tests. Needs to go through a post
-    // submit cycle before can be renamed for presubmit.
-    name: "llvmlibc_stdlib_bsearch_test",
+    name: "llvmlibc_tests",
     defaults: ["llvmlibc_test_defaults"],
     srcs: [
         "test/src/stdlib/bsearch_test.cpp",
+        "test/src/string/memchr_test.cpp",
         "test/src/string/memrchr_test.cpp",
+        "test/src/string/strchr_test.cpp",
+        "test/src/string/strchrnul_test.cpp",
         "test/src/string/strlcat_test.cpp",
         "test/src/string/strlcpy_test.cpp",
+        "test/src/string/strnlen_test.cpp",
+        "test/src/string/strrchr_test.cpp",
     ],
     arch: {
         arm64: {
             // Match exclusions in ':llvmlibc' for arm64.
             exclude_srcs: [
+                "test/src/string/memchr_test.cpp",
                 "test/src/string/memrchr_test.cpp",
+                "test/src/string/strchr_test.cpp",
+                "test/src/string/strchrnul_test.cpp",
+                "test/src/string/strnlen_test.cpp",
+                "test/src/string/strrchr_test.cpp",
             ],
         },
-        x86_64: {
-            // TODO(b/378117947): push these into non-arch-specific `srcs` as
-            // llvm-libc functions are rolled out.
-            srcs: [
+        riscv64: {
+            // Match exclusions in ':llvmlibc' for riscv64.
+            exclude_srcs: [
                 "test/src/string/memchr_test.cpp",
                 "test/src/string/strchr_test.cpp",
-                "test/src/string/strchrnul_test.cpp",
                 "test/src/string/strnlen_test.cpp",
-                "test/src/string/strrchr_test.cpp",
             ],
         },
     },
diff --git a/OWNERS b/OWNERS
index ca56597..ac06b1b 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,5 +1,5 @@
 enh@google.com
 lntue@google.com
 michaelrj@google.com
-ndesaulniers@google.com
 include platform/system/core:main:/janitors/OWNERS
+include platform/system/core:/janitors/OWNERS #{LAST_RESORT_SUGGESTION}
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 528ffec..2bb82e4 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -4,7 +4,7 @@
       "name": "CtsBionicTestCases"
     },
     {
-      "name": "llvmlibc_stdlib_bsearch_test",
+      "name": "llvmlibc_tests",
       "options": [ { "native-test-flag": "--gtest_color=no"} ]
     }
   ]
diff --git a/hdr/fcntl_overlay.h b/hdr/fcntl_overlay.h
index c1cc98b..17ae78b 100644
--- a/hdr/fcntl_overlay.h
+++ b/hdr/fcntl_overlay.h
@@ -20,6 +20,11 @@
 // `__USE_FORTIFY_LEVEL`, which will be temporarily disabled
 // with `_FORTIFY_SOURCE`.
 
+#ifdef _FORTIFY_SOURCE
+#define LIBC_OLD_FORTIFY_SOURCE _FORTIFY_SOURCE
+#undef _FORTIFY_SOURCE
+#endif
+
 #ifdef __USE_FORTIFY_LEVEL
 #define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
 #undef __USE_FORTIFY_LEVEL
@@ -28,6 +33,11 @@
 
 #include <fcntl.h>
 
+#ifdef LIBC_OLD_FORTIFY_SOURCE
+#define _FORTIFY_SOURCE LIBC_OLD_FORTIFY_SOURCE
+#undef LIBC_OLD_FORTIFY_SOURCE
+#endif
+
 #ifdef LIBC_OLD_USE_FORTIFY_LEVEL
 #undef __USE_FORTIFY_LEVEL
 #define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
diff --git a/hdr/func/free.h b/hdr/func/free.h
index b1190a7..316556b 100644
--- a/hdr/func/free.h
+++ b/hdr/func/free.h
@@ -10,7 +10,8 @@
 #define LLVM_LIBC_HDR_FUNC_FREE_H
 
 #ifdef LIBC_FULL_BUILD
-extern "C" void free(void *);
+
+extern "C" void free(void *) noexcept;
 
 #else // Overlay mode
 
diff --git a/hdr/func/malloc.h b/hdr/func/malloc.h
index b395f41..8281021 100644
--- a/hdr/func/malloc.h
+++ b/hdr/func/malloc.h
@@ -10,8 +10,10 @@
 #define LLVM_LIBC_HDR_FUNC_MALLOC_H
 
 #ifdef LIBC_FULL_BUILD
+
 #include "hdr/types/size_t.h"
-extern "C" void *malloc(size_t);
+
+extern "C" void *malloc(size_t) noexcept;
 
 #else // Overlay mode
 
diff --git a/hdr/func/realloc.h b/hdr/func/realloc.h
index 0096045..ecb2954 100644
--- a/hdr/func/realloc.h
+++ b/hdr/func/realloc.h
@@ -10,8 +10,10 @@
 #define LLVM_LIBC_HDR_FUNC_REALLOC_H
 
 #ifdef LIBC_FULL_BUILD
+
 #include "hdr/types/size_t.h"
-extern "C" void *realloc(void *ptr, size_t new_size);
+
+extern "C" void *realloc(void *ptr, size_t new_size) noexcept;
 
 #else // Overlay mode
 
diff --git a/hdr/locale_macros.h b/hdr/locale_macros.h
new file mode 100644
index 0000000..7d94f6d
--- /dev/null
+++ b/hdr/locale_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from locale.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_LOCALE_MACROS_H
+#define LLVM_LIBC_HDR_LOCALE_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/locale-macros.h"
+
+#else // Overlay mode
+
+#error "macros not available in overlay mode"
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_LOCALE_MACROS_H
diff --git a/hdr/sched_macros.h b/hdr/sched_macros.h
new file mode 100644
index 0000000..cfeaa99
--- /dev/null
+++ b/hdr/sched_macros.h
@@ -0,0 +1,22 @@
+//===-- Definition of macros from sched.h ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_SCHED_MACROS_H
+#define LLVM_LIBC_HDR_SCHED_MACROS_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-macros/sched-macros.h"
+
+#else // Overlay mode
+
+#include <sched.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_SCHED_MACROS_H
diff --git a/hdr/time_macros.h b/hdr/time_macros.h
index dc36fe6..4488a24 100644
--- a/hdr/time_macros.h
+++ b/hdr/time_macros.h
@@ -19,4 +19,10 @@
 
 #endif // LLVM_LIBC_FULL_BUILD
 
+// TODO: For now, on windows, let's always include the extension header.
+// We will need to decide how to export this header.
+#ifdef _WIN32
+#include "include/llvm-libc-macros/windows/time-macros-ext.h"
+#endif // _WIN32
+
 #endif // LLVM_LIBC_HDR_TIME_MACROS_H
diff --git a/hdr/types/clockid_t.h b/hdr/types/clockid_t.h
index 3333420..729e580 100644
--- a/hdr/types/clockid_t.h
+++ b/hdr/types/clockid_t.h
@@ -9,7 +9,8 @@
 #ifndef LLVM_LIBC_HDR_TYPES_CLOCKID_T_H
 #define LLVM_LIBC_HDR_TYPES_CLOCKID_T_H
 
-#ifdef LIBC_FULL_BUILD
+// TODO: we will need to decide how to export extension to windows.
+#if defined(LIBC_FULL_BUILD) || defined(_WIN32)
 
 #include "include/llvm-libc-types/clockid_t.h"
 
diff --git a/hdr/types/cpu_set_t.h b/hdr/types/cpu_set_t.h
new file mode 100644
index 0000000..26aed75
--- /dev/null
+++ b/hdr/types/cpu_set_t.h
@@ -0,0 +1,22 @@
+//===-- Proxy for cpu_set_t -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_CPU_SET_T_H
+#define LLVM_LIBC_HDR_TYPES_CPU_SET_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/cpu_set_t.h"
+
+#else // Overlay mode
+
+#include <sched.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_CPU_SET_T_H
diff --git a/hdr/types/sighandler_t.h b/hdr/types/nfds_t.h
similarity index 55%
rename from hdr/types/sighandler_t.h
rename to hdr/types/nfds_t.h
index bc40dd8..9143564 100644
--- a/hdr/types/sighandler_t.h
+++ b/hdr/types/nfds_t.h
@@ -1,24 +1,23 @@
-//===-- Definition of macros from __sighandler_t.h ------------------------===//
+//===-- Definition of nfds_t ----------------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
+//
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
-#define LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
+#ifndef LLVM_LIBC_HDR_TYPES_NFDS_T_H
+#define LLVM_LIBC_HDR_TYPES_NFDS_T_H
 
 #ifdef LIBC_FULL_BUILD
 
-#include "include/llvm-libc-types/__sighandler_t.h"
-
-using sighandler_t = __sighandler_t;
+#include "include/llvm-libc-types/nfds_t.h"
 
 #else // overlay mode
 
-#include <signal.h>
+#include <poll.h>
 
 #endif // LLVM_LIBC_FULL_BUILD
 
-#endif // LLVM_LIBC_HDR_TYPES_SIGHANDLER_T_H
+#endif // LLVM_LIBC_HDR_TYPES_NFDS_T_H
diff --git a/hdr/types/ssize_t.h b/hdr/types/ssize_t.h
index 4d20007..7eff98f 100644
--- a/hdr/types/ssize_t.h
+++ b/hdr/types/ssize_t.h
@@ -14,9 +14,7 @@
 
 #else
 
-#define __need_ssize_t
-#include <stddef.h>
-#undef __need_ssize_t
+#include <sys/types.h>
 
 #endif // LIBC_FULL_BUILD
 
diff --git a/hdr/types/struct_dl_phdr_info.h b/hdr/types/struct_dl_phdr_info.h
new file mode 100644
index 0000000..0cfb3c1
--- /dev/null
+++ b/hdr/types/struct_dl_phdr_info.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct dl_phdr_info  -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_DL_PHDR_INFO_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_DL_PHDR_INFO_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_dl_phdr_info.h"
+
+#else
+
+#include <link.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_DL_PHDR_INFO_H
diff --git a/hdr/types/struct_f_owner_ex.h b/hdr/types/struct_f_owner_ex.h
index 4998511..6e37cea 100644
--- a/hdr/types/struct_f_owner_ex.h
+++ b/hdr/types/struct_f_owner_ex.h
@@ -14,7 +14,7 @@
 
 #else
 
-#include <fcntl.h>
+#include "hdr/fcntl_overlay.h"
 
 #endif // LIBC_FULL_BUILD
 
diff --git a/hdr/types/struct_flock.h b/hdr/types/struct_flock.h
index a552b91..6a6c928 100644
--- a/hdr/types/struct_flock.h
+++ b/hdr/types/struct_flock.h
@@ -14,7 +14,7 @@
 
 #else
 
-#include <fcntl.h>
+#include "hdr/fcntl_overlay.h"
 
 #endif // LIBC_FULL_BUILD
 
diff --git a/hdr/types/struct_flock64.h b/hdr/types/struct_flock64.h
index 84fe678..fcfda59 100644
--- a/hdr/types/struct_flock64.h
+++ b/hdr/types/struct_flock64.h
@@ -14,7 +14,7 @@
 
 #else
 
-#include <fcntl.h>
+#include "hdr/fcntl_overlay.h"
 
 #endif // LIBC_FULL_BUILD
 
diff --git a/hdr/types/struct_iovec.h b/hdr/types/struct_iovec.h
new file mode 100644
index 0000000..fc6174c
--- /dev/null
+++ b/hdr/types/struct_iovec.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct iovec  -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_IOVEC_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_IOVEC_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_iovec.h"
+
+#else
+
+#include <sys/uio.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_IOVEC_H
diff --git a/hdr/types/struct_pollfd.h b/hdr/types/struct_pollfd.h
new file mode 100644
index 0000000..efec6fc
--- /dev/null
+++ b/hdr/types/struct_pollfd.h
@@ -0,0 +1,23 @@
+//===-- Definition of struct pollfd ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_POLLFD_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_POLLFD_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_pollfd.h"
+
+#else // overlay mode
+
+#include <poll.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_POLLFD_H
diff --git a/hdr/types/struct_tm.h b/hdr/types/struct_tm.h
new file mode 100644
index 0000000..96c23e2
--- /dev/null
+++ b/hdr/types/struct_tm.h
@@ -0,0 +1,21 @@
+//===-- Proxy for struct tm  ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_HDR_TYPES_STRUCT_TM_H
+#define LLVM_LIBC_HDR_TYPES_STRUCT_TM_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/struct_tm.h"
+
+#else
+
+#include <time.h>
+
+#endif // LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_STRUCT_TM_H
diff --git a/hdr/types/uid_t.h b/hdr/types/uid_t.h
new file mode 100644
index 0000000..a1eefb0
--- /dev/null
+++ b/hdr/types/uid_t.h
@@ -0,0 +1,22 @@
+//===-- Proxy for uid_t ---------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_TYPES_UID_T_H
+#define LLVM_LIBC_HDR_TYPES_UID_T_H
+
+#ifdef LIBC_FULL_BUILD
+
+#include "include/llvm-libc-types/uid_t.h"
+
+#else // Overlay mode
+
+#include <sys/types.h>
+
+#endif // LLVM_LIBC_FULL_BUILD
+
+#endif // LLVM_LIBC_HDR_TYPES_UID_T_H
diff --git a/hdr/unistd_macros.h b/hdr/unistd_macros.h
index 132e123..5c2b243 100644
--- a/hdr/unistd_macros.h
+++ b/hdr/unistd_macros.h
@@ -15,7 +15,7 @@
 
 #else // Overlay mode
 
-#include <unistd.h>
+#include "unistd_overlay.h"
 
 #endif // LLVM_LIBC_FULL_BUILD
 
diff --git a/hdr/unistd_overlay.h b/hdr/unistd_overlay.h
new file mode 100644
index 0000000..e3001e0
--- /dev/null
+++ b/hdr/unistd_overlay.h
@@ -0,0 +1,69 @@
+//===-- Including unistd.h in overlay mode -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_HDR_UNISTD_OVERLAY_H
+#define LLVM_LIBC_HDR_UNISTD_OVERLAY_H
+
+#ifdef LIBC_FULL_BUILD
+#error "This header should only be included in overlay mode"
+#endif
+
+// Overlay mode
+
+// glibc <unistd.h> header might provide extern inline definitions for few
+// functions, causing external alias errors.  They are guarded by
+// `__USE_EXTERN_INLINES` macro.  We temporarily disable `__USE_EXTERN_INLINES`
+// macro by defining `__NO_INLINE__` before including <stdio.h>.
+// And the same with `__USE_FORTIFY_LEVEL`, which will be temporarily disabled
+// with `_FORTIFY_SOURCE`.
+
+#ifdef _FORTIFY_SOURCE
+#define LIBC_OLD_FORTIFY_SOURCE _FORTIFY_SOURCE
+#undef _FORTIFY_SOURCE
+#endif
+
+#ifdef __USE_EXTERN_INLINES
+#define LIBC_OLD_USE_EXTERN_INLINES
+#undef __USE_EXTERN_INLINES
+#endif
+
+#ifdef __USE_FORTIFY_LEVEL
+#define LIBC_OLD_USE_FORTIFY_LEVEL __USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
+#ifndef __NO_INLINE__
+#define __NO_INLINE__ 1
+#define LIBC_SET_NO_INLINE
+#endif
+
+#include <unistd.h>
+
+#ifdef LIBC_OLD_FORTIFY_SOURCE
+#define _FORTIFY_SOURCE LIBC_OLD_FORTIFY_SOURCE
+#undef LIBC_OLD_FORTIFY_SOURCE
+#endif
+
+#ifdef LIBC_SET_NO_INLINE
+#undef __NO_INLINE__
+#undef LIBC_SET_NO_INLINE
+#endif
+
+#ifdef LIBC_OLD_USE_FORTIFY_LEVEL
+#undef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL LIBC_OLD_USE_FORTIFY_LEVEL
+#undef LIBC_OLD_USE_FORTIFY_LEVEL
+#endif
+
+#ifdef LIBC_OLD_USE_EXTERN_INLINES
+#define __USE_EXTERN_INLINES
+#undef LIBC_OLD_USE_EXTERN_INLINES
+#endif
+
+#endif // LLVM_LIBC_HDR_UNISTD_OVERLAY_H
diff --git a/hdr/wchar_overlay.h b/hdr/wchar_overlay.h
index 99a7089..52d3a0c 100644
--- a/hdr/wchar_overlay.h
+++ b/hdr/wchar_overlay.h
@@ -15,7 +15,7 @@
 
 // Overlay mode
 
-// glibc <wchar.h header might provide extern inline definitions for few
+// glibc <wchar.h> header might provide extern inline definitions for few
 // functions, causing external alias errors.  They are guarded by
 // `__USE_EXTERN_INLINES` macro.  We temporarily disable `__USE_EXTERN_INLINES`
 // macro by defining `__NO_INLINE__` before including <wchar.h>.
diff --git a/include/__llvm-libc-common.h b/include/__llvm-libc-common.h
index e0e29bb..c6fd33a 100644
--- a/include/__llvm-libc-common.h
+++ b/include/__llvm-libc-common.h
@@ -6,8 +6,10 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_COMMON_H
-#define LLVM_LIBC_COMMON_H
+#ifndef _LLVM_LIBC_COMMON_H
+#define _LLVM_LIBC_COMMON_H
+
+#define __LLVM_LIBC__ 1
 
 #ifdef __cplusplus
 
@@ -39,7 +41,16 @@
 #define _Thread_local thread_local
 
 #undef __NOEXCEPT
+#if __cplusplus >= 201103L
 #define __NOEXCEPT noexcept
+#else
+#define __NOEXCEPT throw()
+#endif
+
+// This macro serves as a generic cast implementation for use in both C and C++,
+// similar to `__BIONIC_CAST` in Android.
+#undef __LLVM_LIBC_CAST
+#define __LLVM_LIBC_CAST(cast, type, value) (cast<type>(value))
 
 #else // not __cplusplus
 
@@ -50,11 +61,38 @@
 #define __END_C_DECLS
 
 #undef __restrict
-#define __restrict restrict // C99 and above support the restrict keyword.
+#if __STDC_VERSION__ >= 199901L
+// C99 and above support the restrict keyword.
+#define __restrict restrict
+#elif !defined(__GNUC__)
+// GNU-compatible compilers accept the __ spelling in all modes.
+// Otherwise, omit the qualifier for pure C89 compatibility.
+#define __restrict
+#endif
+
+#undef _Noreturn
+#if __STDC_VERSION__ >= 201112L
+// In C11 and later, _Noreturn is a keyword.
+#elif defined(__GNUC__)
+// GNU-compatible compilers have an equivalent attribute.
+#define _Noreturn __attribute__((__noreturn__))
+#else
+#define _Noreturn
+#endif
 
 #undef __NOEXCEPT
+#ifdef __GNUC__
+#define __NOEXCEPT __attribute__((__nothrow__))
+#else
 #define __NOEXCEPT
+#endif
+
+#undef _Returns_twice
+#define _Returns_twice __attribute__((returns_twice))
+
+#undef __LLVM_LIBC_CAST
+#define __LLVM_LIBC_CAST(cast, type, value) ((type)(value))
 
 #endif // __cplusplus
 
-#endif // LLVM_LIBC_COMMON_H
+#endif // _LLVM_LIBC_COMMON_H
diff --git a/include/llvm-libc-macros/EFIAPI-macros.h b/include/llvm-libc-macros/EFIAPI-macros.h
new file mode 100644
index 0000000..cb85492
--- /dev/null
+++ b/include/llvm-libc-macros/EFIAPI-macros.h
@@ -0,0 +1,18 @@
+//===-- Definition of EFIAPI macro ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_EFIAPI_MACROS_H
+#define LLVM_LIBC_MACROS_EFIAPI_MACROS_H
+
+#if defined(__x86_64__) && !defined(__ILP32__)
+#define EFIAPI __attribute__((ms_abi))
+#else
+#define EFIAPI
+#endif
+
+#endif // LLVM_LIBC_MACROS_EFIAPI_MACROS_H
diff --git a/include/llvm-libc-macros/endian-macros.h b/include/llvm-libc-macros/endian-macros.h
new file mode 100644
index 0000000..52d95dc
--- /dev/null
+++ b/include/llvm-libc-macros/endian-macros.h
@@ -0,0 +1,50 @@
+//===-- Definition of macros from endian.h --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_ENDIAN_MACROS_H
+#define LLVM_LIBC_MACROS_ENDIAN_MACROS_H
+
+#include "stdint-macros.h"
+
+#define LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__
+#define BIG_ENDIAN __ORDER_BIG_ENDIAN__
+#define BYTE_ORDER __BYTE_ORDER__
+
+#if BYTE_ORDER == LITTLE_ENDIAN
+
+#define htobe16(x) __builtin_bswap16((x))
+#define htobe32(x) __builtin_bswap32((x))
+#define htobe64(x) __builtin_bswap64((x))
+#define htole16(x) __LLVM_LIBC_CAST(static_cast, uint16_t, x)
+#define htole32(x) __LLVM_LIBC_CAST(static_cast, uint32_t, x)
+#define htole64(x) __LLVM_LIBC_CAST(static_cast, uint64_t, x)
+#define be16toh(x) __builtin_bswap16((x))
+#define be32toh(x) __builtin_bswap32((x))
+#define be64toh(x) __builtin_bswap64((x))
+#define le16toh(x) __LLVM_LIBC_CAST(static_cast, uint16_t, x)
+#define le32toh(x) __LLVM_LIBC_CAST(static_cast, uint32_t, x)
+#define le64toh(x) __LLVM_LIBC_CAST(static_cast, uint64_t, x)
+
+#else
+
+#define htobe16(x) __LLVM_LIBC_CAST(static_cast, uint16_t, x)
+#define htobe32(x) __LLVM_LIBC_CAST(static_cast, uint32_t, x)
+#define htobe64(x) __LLVM_LIBC_CAST(static_cast, uint64_t, x)
+#define htole16(x) __builtin_bswap16((x))
+#define htole32(x) __builtin_bswap32((x))
+#define htole64(x) __builtin_bswap64((x))
+#define be16toh(x) __LLVM_LIBC_CAST(static_cast, uint16_t, x)
+#define be32toh(x) __LLVM_LIBC_CAST(static_cast, uint32_t, x)
+#define be64toh(x) __LLVM_LIBC_CAST(static_cast, uint64_t, x)
+#define le16toh(x) __builtin_bswap16((x))
+#define le32toh(x) __builtin_bswap32((x))
+#define le64toh(x) __builtin_bswap64((x))
+
+#endif
+
+#endif // LLVM_LIBC_MACROS_ENDIAN_MACROS_H
diff --git a/include/llvm-libc-macros/features-macros.h b/include/llvm-libc-macros/features-macros.h
index 5bc87a6..f87ae4a 100644
--- a/include/llvm-libc-macros/features-macros.h
+++ b/include/llvm-libc-macros/features-macros.h
@@ -9,6 +9,4 @@
 #ifndef LLVM_LIBC_MACROS_FEATURES_MACROS_H
 #define LLVM_LIBC_MACROS_FEATURES_MACROS_H
 
-#define __LLVM_LIBC__ 1
-
 #endif // LLVM_LIBC_MACROS_FEATURES_MACROS_H
diff --git a/include/llvm-libc-macros/gpu/signal-macros.h b/include/llvm-libc-macros/gpu/signal-macros.h
index 2d81592..f0d49ea 100644
--- a/include/llvm-libc-macros/gpu/signal-macros.h
+++ b/include/llvm-libc-macros/gpu/signal-macros.h
@@ -16,9 +16,9 @@
 #define SIGSEGV 11
 #define SIGTERM 15
 
-#define SIG_DFL ((__sighandler_t)(0))
-#define SIG_IGN ((__sighandler_t)(1))
-#define SIG_ERR ((__sighandler_t)(-1))
+#define SIG_DFL ((void (*)(int))(0))
+#define SIG_IGN ((void (*)(int))(1))
+#define SIG_ERR ((void (*)(int))(-1))
 
 // Max signal number
 #define NSIG 64
diff --git a/include/llvm-libc-macros/limits-macros.h b/include/llvm-libc-macros/limits-macros.h
index d4aa7ae..79bbbe4 100644
--- a/include/llvm-libc-macros/limits-macros.h
+++ b/include/llvm-libc-macros/limits-macros.h
@@ -235,4 +235,12 @@
 #define _POSIX_PATH_MAX 256
 #endif
 
+#ifndef _POSIX_ARG_MAX
+#define _POSIX_ARG_MAX 4096
+#endif
+
+#ifndef IOV_MAX
+#define IOV_MAX 1024
+#endif // IOV_MAX
+
 #endif // LLVM_LIBC_MACROS_LIMITS_MACROS_H
diff --git a/include/llvm-libc-macros/linux/poll-macros.h b/include/llvm-libc-macros/linux/poll-macros.h
new file mode 100644
index 0000000..d6724c5
--- /dev/null
+++ b/include/llvm-libc-macros/linux/poll-macros.h
@@ -0,0 +1,65 @@
+//===-- Macros defined in poll.h header file ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_LINUX_POLL_MACROS_H
+#define LLVM_LIBC_MACROS_LINUX_POLL_MACROS_H
+
+// From asm-generic/poll.h, redefined here to avoid redeclaring struct pollfd.
+#ifndef POLLIN
+#define POLLIN 0x0001
+#endif
+
+#ifndef POLLPRI
+#define POLLPRI 0x0002
+#endif
+
+#ifndef POLLOUT
+#define POLLOUT 0x0004
+#endif
+
+#ifndef POLLERR
+#define POLLERR 0x0008
+#endif
+
+#ifndef POLLHUP
+#define POLLHUP 0x0010
+#endif
+
+#ifndef POLLNVAL
+#define POLLNVAL 0x0020
+#endif
+
+#ifndef POLLRDNORM
+#define POLLRDNORM 0x0040
+#endif
+
+#ifndef POLLRDBAND
+#define POLLRDBAND 0x0080
+#endif
+
+#ifndef POLLWRNORM
+#define POLLWRNORM 0x0100
+#endif
+
+#ifndef POLLWRBAND
+#define POLLWRBAND 0x0200
+#endif
+
+#ifndef POLLMSG
+#define POLLMSG 0x0400
+#endif
+
+#ifndef POLLREMOVE
+#define POLLREMOVE 0x1000
+#endif
+
+#ifndef POLLRDHUP
+#define POLLRDHUP 0x2000
+#endif
+
+#endif // LLVM_LIBC_MACROS_LINUX_POLL_MACROS_H
diff --git a/include/llvm-libc-macros/linux/sched-macros.h b/include/llvm-libc-macros/linux/sched-macros.h
index ace6200..597789b 100644
--- a/include/llvm-libc-macros/linux/sched-macros.h
+++ b/include/llvm-libc-macros/linux/sched-macros.h
@@ -23,7 +23,15 @@
 #define SCHED_IDLE 5
 #define SCHED_DEADLINE 6
 
+#define CPU_SETSIZE __CPU_SETSIZE
+#define NCPUBITS __NCPUBITS
 #define CPU_COUNT_S(setsize, set) __sched_getcpucount(setsize, set)
 #define CPU_COUNT(set) CPU_COUNT_S(sizeof(cpu_set_t), set)
+#define CPU_ZERO_S(setsize, set) __sched_setcpuzero(setsize, set)
+#define CPU_ZERO(set) CPU_ZERO_S(sizeof(cpu_set_t), set)
+#define CPU_SET_S(cpu, setsize, set) __sched_setcpuset(cpu, setsize, set)
+#define CPU_SET(cpu, setsize, set) CPU_SET_S(cpu, sizeof(cpt_set_t), set)
+#define CPU_ISSET_S(cpu, setsize, set) __sched_getcpuisset(cpu, setsize, set)
+#define CPU_ISSET(cpu, setsize, set) CPU_ISSET_S(cpu, sizeof(cpt_set_t), set)
 
 #endif // LLVM_LIBC_MACROS_LINUX_SCHED_MACROS_H
diff --git a/include/llvm-libc-macros/linux/signal-macros.h b/include/llvm-libc-macros/linux/signal-macros.h
index 0b7317e..d220241 100644
--- a/include/llvm-libc-macros/linux/signal-macros.h
+++ b/include/llvm-libc-macros/linux/signal-macros.h
@@ -86,9 +86,9 @@
 #error "Signal stack sizes not defined for your platform."
 #endif
 
-#define SIG_DFL ((__sighandler_t)0)
-#define SIG_IGN ((__sighandler_t)1)
-#define SIG_ERR ((__sighandler_t)-1)
+#define SIG_DFL ((void (*)(int))0)
+#define SIG_IGN ((void (*)(int))1)
+#define SIG_ERR ((void (*)(int))(-1))
 
 // SIGCHLD si_codes
 #define CLD_EXITED 1    // child has exited
diff --git a/include/llvm-libc-macros/linux/sys-wait-macros.h b/include/llvm-libc-macros/linux/sys-wait-macros.h
index c101638..d01cfa7 100644
--- a/include/llvm-libc-macros/linux/sys-wait-macros.h
+++ b/include/llvm-libc-macros/linux/sys-wait-macros.h
@@ -9,36 +9,19 @@
 #ifndef LLVM_LIBC_MACROS_LINUX_SYS_WAIT_MACROS_H
 #define LLVM_LIBC_MACROS_LINUX_SYS_WAIT_MACROS_H
 
-// Wait flags
-#define WNOHANG 1    // Do not block
-#define WUNTRACED 2  // Report is a child has stopped even if untraced
-#define WEXITED 4    // Report dead child
-#define WCONTINUED 8 // Report if a stopped child has been resumed by SIGCONT
-#define WSTOPPED WUNTRACED
-
-// Wait status info macros
-#define __WEXITSTATUS(status) (((status)&0xff00) >> 8)
-#define __WTERMSIG(status) ((status)&0x7f)
-#define __WIFEXITED(status) (__WTERMSIG(status) == 0)
-
-// Macros for constructing status values.
-#define __W_EXITCODE(ret, sig) ((ret) << 8 | (sig))
-#define __W_STOPCODE(sig) ((sig) << 8 | 0x7f)
-#define __W_CONTINUED 0xffff
-#define __WCOREFLAG 0x80
-
-#define WEXITSTATUS(status) __WEXITSTATUS(status)
-#define WTERMSIG(status) __WTERMSIG(status)
-#define WIFEXITED(status) __WIFEXITED(status)
-
-#define WCOREFLAG __WCOREFLAG
-#define W_EXITCODE(ret, sig) __W_EXITCODE(ret, sig)
-#define W_STOPCODE(sig) __W_STOPCODE(sig)
-
-// First argument to waitid:
-#define P_ALL 0
-#define P_PID 1
-#define P_PGID 2
-#define P_PIDFD 3
+#include <linux/wait.h>
+
+#define WCOREDUMP(status) ((status) & WCOREFLAG)
+#define WEXITSTATUS(status) (((status) & 0xff00) >> 8)
+#define WIFCONTINUED(status) ((status) == 0xffff)
+#define WIFEXITED(status) (WTERMSIG(status) == 0)
+#define WIFSIGNALED(status) ((WTERMSIG(status) + 1) >= 2)
+#define WIFSTOPPED(status) (WTERMSIG(status) == 0x7f)
+#define WSTOPSIG(status) WEXITSTATUS(status)
+#define WTERMSIG(status) ((status) & 0x7f)
+
+#define WCOREFLAG 0x80
+#define W_EXITCODE(ret, sig) ((ret) << 8 | (sig))
+#define W_STOPCODE(sig) ((sig) << 8 | 0x7f)
 
 #endif // LLVM_LIBC_MACROS_LINUX_SYS_WAIT_MACROS_H
diff --git a/include/llvm-libc-macros/poll-macros.h b/include/llvm-libc-macros/poll-macros.h
new file mode 100644
index 0000000..52b59a9
--- /dev/null
+++ b/include/llvm-libc-macros/poll-macros.h
@@ -0,0 +1,16 @@
+//===-- Macros defined in poll.h header file ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_POLL_MACROS_H
+#define LLVM_LIBC_MACROS_POLL_MACROS_H
+
+#ifdef __linux__
+#include "linux/poll-macros.h"
+#endif
+
+#endif // LLVM_LIBC_MACROS_POLL_MACROS_H
diff --git a/include/llvm-libc-macros/pthread-macros.h b/include/llvm-libc-macros/pthread-macros.h
new file mode 100644
index 0000000..fcc6ef9
--- /dev/null
+++ b/include/llvm-libc-macros/pthread-macros.h
@@ -0,0 +1,65 @@
+//===-- Definition of pthread macros --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_PTHREAD_MACRO_H
+#define LLVM_LIBC_MACROS_PTHREAD_MACRO_H
+
+#include "null-macro.h"
+
+#define PTHREAD_CREATE_JOINABLE 0
+#define PTHREAD_CREATE_DETACHED 1
+
+#define PTHREAD_MUTEX_NORMAL 0
+#define PTHREAD_MUTEX_ERRORCHECK 1
+#define PTHREAD_MUTEX_RECURSIVE 2
+#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL
+
+#define PTHREAD_MUTEX_STALLED 0
+#define PTHREAD_MUTEX_ROBUST 1
+
+#define PTHREAD_ONCE_INIT {0}
+
+#define PTHREAD_PROCESS_PRIVATE 0
+#define PTHREAD_PROCESS_SHARED 1
+
+#ifdef __linux__
+#define PTHREAD_MUTEX_INITIALIZER                                              \
+  {                                                                            \
+      /* .__timed = */ 0,      /* .__recursive = */ 0,                         \
+      /* .__robust = */ 0,     /* .__owner = */ NULL,                          \
+      /* .__lock_count = */ 0, /* .__futex_word = */ {0},                      \
+  }
+#else
+#define PTHREAD_MUTEX_INITIALIZER                                              \
+  {                                                                            \
+      /* .__timed = */ 0,      /* .__recursive = */ 0,                         \
+      /* .__robust = */ 0,     /* .__owner = */ NULL,                          \
+      /* .__lock_count = */ 0,                                                 \
+  }
+#endif
+
+#define PTHREAD_RWLOCK_INITIALIZER                                             \
+  {                                                                            \
+      /* .__is_pshared = */ 0,                                                 \
+      /* .__preference = */ 0,                                                 \
+      /* .__state = */ 0,                                                      \
+      /* .__write_tid = */ 0,                                                  \
+      /* .__wait_queue_mutex = */ {0},                                         \
+      /* .__pending_readers = */ {0},                                          \
+      /* .__pending_writers = */ {0},                                          \
+      /* .__reader_serialization = */ {0},                                     \
+      /* .__writer_serialization = */ {0},                                     \
+  }
+
+// glibc extensions
+#define PTHREAD_STACK_MIN (1 << 14) // 16KB
+#define PTHREAD_RWLOCK_PREFER_READER_NP 0
+#define PTHREAD_RWLOCK_PREFER_WRITER_NP 1
+#define PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP 2
+
+#endif // LLVM_LIBC_MACROS_PTHREAD_MACRO_H
diff --git a/include/llvm-libc-macros/stdfix-macros.h b/include/llvm-libc-macros/stdfix-macros.h
index 554ebe5..04097e1 100644
--- a/include/llvm-libc-macros/stdfix-macros.h
+++ b/include/llvm-libc-macros/stdfix-macros.h
@@ -323,6 +323,45 @@
 #define ULACCUM_EPSILON 0x1.0p-32ULK
 #endif // ULACCUM_EPSILON
 
+#define absfx(x)                                                               \
+  _Generic((x),                                                                \
+      fract: absr,                                                             \
+      short fract: abshr,                                                      \
+      long fract: abslr,                                                       \
+      accum: absk,                                                             \
+      short accum: abshk,                                                      \
+      long accum: abslk)(x)
+
+#define countlsfx(x)                                                           \
+  _Generic((x),                                                                \
+      fract: countlsr,                                                         \
+      short fract: countlshr,                                                  \
+      long fract: countlslr,                                                   \
+      accum: countlsk,                                                         \
+      short accum: countlshk,                                                  \
+      long accum: countlslk,                                                   \
+      unsigned fract: countlsur,                                               \
+      unsigned short fract: countlsuhr,                                        \
+      unsigned long fract: countlsulr,                                         \
+      unsigned accum: countlsuk,                                               \
+      unsigned short accum: countlsuhk,                                        \
+      unsigned long accum: countlsulk)(x)
+
+#define roundfx(x, y)                                                          \
+  _Generic((x),                                                                \
+      fract: roundr,                                                           \
+      short fract: roundhr,                                                    \
+      long fract: roundlr,                                                     \
+      accum: roundk,                                                           \
+      short accum: roundhk,                                                    \
+      long accum: roundlk,                                                     \
+      unsigned fract: roundur,                                                 \
+      unsigned short fract: rounduhr,                                          \
+      unsigned long fract: roundulr,                                           \
+      unsigned accum: rounduk,                                                 \
+      unsigned short accum: rounduhk,                                          \
+      unsigned long accum: roundulk)(x, y)
+
 #endif // LIBC_COMPILER_HAS_FIXED_POINT
 
 #endif // LLVM_LIBC_MACROS_STDFIX_MACROS_H
diff --git a/include/llvm-libc-macros/sysexits-macros.h b/include/llvm-libc-macros/sysexits-macros.h
new file mode 100644
index 0000000..52f8387
--- /dev/null
+++ b/include/llvm-libc-macros/sysexits-macros.h
@@ -0,0 +1,29 @@
+//===-- Macros defined in sysexits.h header file --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef SYSEXITS_MACROS_H
+#define SYSEXITS_MACROS_H
+
+#define EX_OK 0           // Successful termination
+#define EX_USAGE 64       // Command line usage error
+#define EX_DATAERR 65     // Data format error
+#define EX_NOINPUT 66     // Cannot open input
+#define EX_NOUSER 67      // Addressee unknown
+#define EX_NOHOST 68      // Host name unknown
+#define EX_UNAVAILABLE 69 // Service unavailable
+#define EX_SOFTWARE 70    // Internal software error
+#define EX_OSERR 71       // Operating system error
+#define EX_OSFILE 72      // System file error
+#define EX_CANTCREAT 73   // Cannot create (user) output file
+#define EX_IOERR 74       // Input/output error
+#define EX_TEMPFAIL 75    // Temporary failure, try again
+#define EX_PROTOCOL 76    // Remote protocol error
+#define EX_NOPERM 77      // Permission denied
+#define EX_CONFIG 78      // Configuration error
+
+#endif // SYSEXITS_MACROS_H
diff --git a/include/llvm-libc-macros/time-macros.h b/include/llvm-libc-macros/time-macros.h
index 6d49ed4..445d8b3 100644
--- a/include/llvm-libc-macros/time-macros.h
+++ b/include/llvm-libc-macros/time-macros.h
@@ -7,4 +7,9 @@
 #include "linux/time-macros.h"
 #endif
 
+#define TIME_UTC 1
+#define TIME_MONOTONIC 2
+#define TIME_ACTIVE 3
+#define TIME_THREAD_ACTIVE 4
+
 #endif // LLVM_LIBC_MACROS_TIME_MACROS_H
diff --git a/include/llvm-libc-macros/unistd-macros.h b/include/llvm-libc-macros/unistd-macros.h
index 4f27f07..e09dada 100644
--- a/include/llvm-libc-macros/unistd-macros.h
+++ b/include/llvm-libc-macros/unistd-macros.h
@@ -5,4 +5,8 @@
 #include "linux/unistd-macros.h"
 #endif
 
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
 #endif // LLVM_LIBC_MACROS_UNISTD_MACROS_H
diff --git a/include/llvm-libc-macros/windows/time-macros-ext.h b/include/llvm-libc-macros/windows/time-macros-ext.h
new file mode 100644
index 0000000..71d914b
--- /dev/null
+++ b/include/llvm-libc-macros/windows/time-macros-ext.h
@@ -0,0 +1,17 @@
+//===-- Windows Time Macros Extension -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_MACROS_WINDOWS_TIME_MACROS_EXT_H
+#define LLVM_LIBC_MACROS_WINDOWS_TIME_MACROS_EXT_H
+
+#define CLOCK_MONOTONIC 0
+#define CLOCK_REALTIME 1
+#define CLOCK_PROCESS_CPUTIME_ID 2
+#define CLOCK_THREAD_CPUTIME_ID 3
+
+#endif // LLVM_LIBC_MACROS_WINDOWS_TIME_MACROS_EXT_H
diff --git a/include/llvm-libc-types/EFI_ALLOCATE_TYPE.h b/include/llvm-libc-types/EFI_ALLOCATE_TYPE.h
new file mode 100644
index 0000000..90f2396
--- /dev/null
+++ b/include/llvm-libc-types/EFI_ALLOCATE_TYPE.h
@@ -0,0 +1,19 @@
+//===-- Definition of EFI_ALLOCATE_TYPE type ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_ALLOCATE_TYPE_H
+#define LLVM_LIBC_TYPES_EFI_ALLOCATE_TYPE_H
+
+typedef enum {
+  AllocateAnyPages,
+  AllocateMaxAddress,
+  AllocateAddress,
+  MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+#endif // LLVM_LIBC_TYPES_EFI_ALLOCATE_TYPE_H
diff --git a/include/llvm-libc-types/EFI_BOOT_SERVICES.h b/include/llvm-libc-types/EFI_BOOT_SERVICES.h
new file mode 100644
index 0000000..8b7a6aa
--- /dev/null
+++ b/include/llvm-libc-types/EFI_BOOT_SERVICES.h
@@ -0,0 +1,250 @@
+//===-- Definition of EFI_BOOT_SERVICES type ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_BOOT_SERVICES_H
+#define LLVM_LIBC_TYPES_EFI_BOOT_SERVICES_H
+
+#include "../llvm-libc-macros/EFIAPI-macros.h"
+#include "EFI_ALLOCATE_TYPE.h"
+#include "EFI_DEVICE_PATH_PROTOCOL.h"
+#include "EFI_EVENT.h"
+#include "EFI_GUID.h"
+#include "EFI_INTERFACE_TYPE.h"
+#include "EFI_LOCATE_SEARCH_TYPE.h"
+#include "EFI_MEMORY_DESCRIPTOR.h"
+#include "EFI_MEMORY_TYPE.h"
+#include "EFI_OPEN_PROTOCOL_INFORMATION_ENTRY.h"
+#include "EFI_PHYSICAL_ADDRESS.h"
+#include "EFI_STATUS.h"
+#include "EFI_TABLE_HEADER.h"
+#include "EFI_TIMER_DELAY.h"
+#include "EFI_TPL.h"
+#include "char16_t.h"
+#include "size_t.h"
+
+#define EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+typedef EFI_TPL(EFIAPI *EFI_RAISE_TPL)(EFI_TPL NewTpl);
+typedef void(EFIAPI *EFI_RESTORE_TPL)(EFI_TPL OldTpl);
+
+typedef EFI_STATUS(EFIAPI *EFI_ALLOCATE_PAGES)(EFI_ALLOCATE_TYPE Type,
+                                               EFI_MEMORY_TYPE MemoryType,
+                                               size_t Pages,
+                                               EFI_PHYSICAL_ADDRESS *Memory);
+typedef EFI_STATUS(EFIAPI *EFI_FREE_PAGES)(EFI_PHYSICAL_ADDRESS Memory,
+                                           size_t Pages);
+typedef EFI_STATUS(EFIAPI *EFI_GET_MEMORY_MAP)(size_t *MemoryMapSize,
+                                               EFI_MEMORY_DESCRIPTOR *MemoryMap,
+                                               size_t *MapKey,
+                                               size_t *DescriptorSize,
+                                               uint32_t *DescriptorVersion);
+
+typedef EFI_STATUS(EFIAPI *EFI_ALLOCATE_POOL)(EFI_MEMORY_TYPE PoolType,
+                                              size_t Size, void **Buffer);
+typedef EFI_STATUS(EFIAPI *EFI_FREE_POOL)(void *Buffer);
+
+typedef void(EFIAPI *EFI_EVENT_NOTIFY)(EFI_EVENT Event, void *Context);
+
+typedef EFI_STATUS(EFIAPI *EFI_CREATE_EVENT)(uint32_t Type, EFI_TPL NotifyTpl,
+                                             EFI_EVENT_NOTIFY NotifyFunction,
+                                             void *NotifyContext,
+                                             EFI_EVENT *Event);
+typedef EFI_STATUS(EFIAPI *EFI_SET_TIMER)(EFI_EVENT Event, EFI_TIMER_DELAY Type,
+                                          uint64_t TriggerTime);
+typedef EFI_STATUS(EFIAPI *EFI_WAIT_FOR_EVENT)(size_t NumberOfEvents,
+                                               EFI_EVENT *Event, size_t *Index);
+typedef EFI_STATUS(EFIAPI *EFI_SIGNAL_EVENT)(EFI_EVENT Event);
+typedef EFI_STATUS(EFIAPI *EFI_CLOSE_EVENT)(EFI_EVENT Event);
+typedef EFI_STATUS(EFIAPI *EFI_CHECK_EVENT)(EFI_EVENT Event);
+
+typedef EFI_STATUS(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE)(
+    EFI_HANDLE *Handle, EFI_GUID *Protocol, EFI_INTERFACE_TYPE InterfaceType,
+    void *Interface);
+typedef EFI_STATUS(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE)(
+    EFI_HANDLE Handle, EFI_GUID *Protocol, void *OldInterface,
+    void *NewInterface);
+typedef EFI_STATUS(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE)(EFI_HANDLE Handle,
+                                                             EFI_GUID *Protocol,
+                                                             void *Interface);
+
+typedef EFI_STATUS(EFIAPI *EFI_HANDLE_PROTOCOL)(EFI_HANDLE Handle,
+                                                EFI_GUID *Protocol,
+                                                void **Interface);
+typedef EFI_STATUS(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY)(EFI_GUID *Protocol,
+                                                         EFI_EVENT Event,
+                                                         void **Registration);
+
+typedef EFI_STATUS(EFIAPI *EFI_LOCATE_HANDLE)(EFI_LOCATE_SEARCH_TYPE SearchType,
+                                              EFI_GUID *Protocol,
+                                              void *SearchKey,
+                                              size_t *BufferSize,
+                                              EFI_HANDLE *Buffer);
+typedef EFI_STATUS(EFIAPI *EFI_LOCATE_DEVICE_PATH)(
+    EFI_GUID *Protocol, EFI_DEVICE_PATH_PROTOCOL **DevicePath,
+    EFI_HANDLE *Device);
+
+typedef EFI_STATUS(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE)(EFI_GUID *Guid,
+                                                            void *Table);
+typedef EFI_STATUS(EFIAPI *EFI_IMAGE_UNLOAD)(EFI_HANDLE ImageHandle);
+typedef EFI_STATUS(EFIAPI *EFI_IMAGE_START)(EFI_HANDLE ImageHandle,
+                                            size_t *ExitDataSize,
+                                            char16_t **ExitData);
+
+typedef EFI_STATUS(EFIAPI *EFI_EXIT)(EFI_HANDLE ImageHandle,
+                                     EFI_STATUS ExitStatus, size_t ExitDataSize,
+                                     char16_t *ExitData);
+typedef EFI_STATUS(EFIAPI *EFI_EXIT_BOOT_SERVICES)(EFI_HANDLE ImageHandle,
+                                                   size_t MapKey);
+typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT)(uint64_t *Count);
+typedef EFI_STATUS(EFIAPI *EFI_STALL)(size_t Microseconds);
+typedef EFI_STATUS(EFIAPI *EFI_SET_WATCHDOG_TIMER)(size_t Timeout,
+                                                   uint64_t WatchdogCode,
+                                                   size_t DataSize,
+                                                   char16_t *WatchdogData);
+
+typedef EFI_STATUS(EFIAPI *EFI_CONNECT_CONTROLLER)(
+    EFI_HANDLE ControllerHandle, EFI_HANDLE *DriverImageHandle,
+    EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath, bool Recursive);
+
+typedef EFI_STATUS(EFIAPI *EFI_DISCONNECT_CONTROLLER)(
+    EFI_HANDLE ControllerHandle, EFI_HANDLE DriverImageHandle,
+    EFI_HANDLE ChildHandle);
+
+typedef EFI_STATUS(EFIAPI *EFI_OPEN_PROTOCOL)(
+    EFI_HANDLE Handle, EFI_GUID *Protocol, void **Interface,
+    EFI_HANDLE AgentHandle, EFI_HANDLE ControllerHandle, uint32_t Attributes);
+
+typedef EFI_STATUS(EFIAPI *EFI_CLOSE_PROTOCOL)(EFI_HANDLE Handle,
+                                               EFI_GUID *Protocol,
+                                               EFI_HANDLE AgentHandle,
+                                               EFI_HANDLE ControllerHandle);
+
+typedef EFI_STATUS(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION)(
+    EFI_HANDLE Handle, EFI_GUID *Protocol,
+    EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer, size_t *EntryCount);
+
+typedef EFI_STATUS(EFIAPI *EFI_PROTOCOLS_PER_HANDLE)(
+    EFI_HANDLE Handle, EFI_GUID ***ProtocolBuffer, size_t *ProtocolBufferCount);
+
+typedef EFI_STATUS(EFIAPI *EFI_LOCATE_HANDLE_BUFFER)(
+    EFI_LOCATE_SEARCH_TYPE SearchType, EFI_GUID *Protocol, void *SearchKey,
+    size_t *NoHandles, EFI_HANDLE **Buffer);
+
+typedef EFI_STATUS(EFIAPI *EFI_LOCATE_PROTOCOL)(EFI_GUID *Protocol,
+                                                void *Registration,
+                                                void **Interface);
+
+typedef EFI_STATUS(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES)(
+    EFI_HANDLE Handle, ...);
+typedef EFI_STATUS(EFIAPI *EFI_CALCULATE_CRC32)(void *Data, size_t DataSize,
+                                                uint32_t *Crc32);
+
+typedef void(EFIAPI *EFI_COPY_MEM)(void *Destination, void *Source,
+                                   size_t Length);
+typedef void(EFIAPI *EFI_SET_MEM)(void *Buffer, size_t Size, uint8_t Value);
+
+typedef EFI_STATUS(EFIAPI *EFI_CREATE_EVENT_EX)(
+    uint32_t Type, EFI_TPL NotifyTpl, EFI_EVENT_NOTIFY NotifyFunction,
+    const void *NotifyContext, const EFI_GUID *EventGroup, EFI_EVENT *Event);
+
+typedef struct {
+  EFI_TABLE_HEADER Hdr;
+
+  //
+  // Task Priority Services
+  //
+  EFI_RAISE_TPL RaiseTPL;     // EFI 1.0+
+  EFI_RESTORE_TPL RestoreTPL; // EFI 1.0+
+
+  //
+  // Memory Services
+  //
+  EFI_ALLOCATE_PAGES AllocatePages; // EFI 1.0+
+  EFI_FREE_PAGES FreePages;         // EFI 1.0+
+  EFI_GET_MEMORY_MAP GetMemoryMap;  // EFI 1.0+
+  EFI_ALLOCATE_POOL AllocatePool;   // EFI 1.0+
+  EFI_FREE_POOL FreePool;           // EFI 1.0+
+
+  //
+  // Event & Timer Services
+  //
+  EFI_CREATE_EVENT CreateEvent;    // EFI 1.0+
+  EFI_SET_TIMER SetTimer;          // EFI 1.0+
+  EFI_WAIT_FOR_EVENT WaitForEvent; // EFI 1.0+
+  EFI_SIGNAL_EVENT SignalEvent;    // EFI 1.0+
+  EFI_CLOSE_EVENT CloseEvent;      // EFI 1.0+
+  EFI_CHECK_EVENT CheckEvent;      // EFI 1.0+
+
+  //
+  // Protocol Handler Services
+  //
+  EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface;     // EFI 1.0+
+  EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface; // EFI 1.0+
+  EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface; // EFI 1.0+
+  EFI_HANDLE_PROTOCOL HandleProtocol;                          // EFI 1.0+
+  void *Reserved;                                              // EFI 1.0+
+  EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify;         // EFI 1.0+
+  EFI_LOCATE_HANDLE LocateHandle;                              // EFI 1.+
+  EFI_LOCATE_DEVICE_PATH LocateDevicePath;                     // EFI 1.0+
+  EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;   // EFI 1.0+
+
+  //
+  // Image Services
+  //
+  EFI_IMAGE_UNLOAD LoadImage;              // EFI 1.0+
+  EFI_IMAGE_START StartImage;              // EFI 1.0+
+  EFI_EXIT Exit;                           // EFI 1.0+
+  EFI_IMAGE_UNLOAD UnloadImage;            // EFI 1.0+
+  EFI_EXIT_BOOT_SERVICES ExitBootServices; // EFI 1.0+
+
+  //
+  // Miscellaneous Services
+  //
+  EFI_GET_NEXT_MONOTONIC_COUNT GetNextMonotonicCount; // EFI 1.0+
+  EFI_STALL Stall;                                    // EFI 1.0+
+  EFI_SET_WATCHDOG_TIMER SetWatchdogTimer;            // EFI 1.0+
+
+  //
+  // DriverSupport Services
+  //
+  EFI_CONNECT_CONTROLLER ConnectController;       // EFI 1.1
+  EFI_DISCONNECT_CONTROLLER DisconnectController; // EFI 1.1+
+
+  //
+  // Open and Close Protocol Services
+  //
+  EFI_OPEN_PROTOCOL OpenProtocol;                        // EFI 1.1+
+  EFI_CLOSE_PROTOCOL CloseProtocol;                      // EFI 1.1+
+  EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation; // EFI 1.1+
+
+  //
+  // Library Services
+  //
+  EFI_PROTOCOLS_PER_HANDLE ProtocolsPerHandle; // EFI 1.1+
+  EFI_LOCATE_HANDLE_BUFFER LocateHandleBuffer; // EFI 1.1+
+  EFI_LOCATE_PROTOCOL LocateProtocol;          // EFI 1.1+
+  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES
+  InstallMultipleProtocolInterfaces; // EFI 1.1+
+  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES
+  UninstallMultipleProtocolInterfaces; // EFI 1.1+*
+
+  //
+  // 32-bit CRC Services
+  //
+  EFI_CALCULATE_CRC32 CalculateCrc32; // EFI 1.1+
+
+  //
+  // Miscellaneous Services
+  //
+  EFI_COPY_MEM CopyMem;              // EFI 1.1+
+  EFI_SET_MEM SetMem;                // EFI 1.1+
+  EFI_CREATE_EVENT_EX CreateEventEx; // UEFI 2.0+
+} EFI_BOOT_SERVICES;
+
+#endif // LLVM_LIBC_TYPES_EFI_BOOT_SERVICES_H
diff --git a/include/llvm-libc-types/EFI_CAPSULE.h b/include/llvm-libc-types/EFI_CAPSULE.h
new file mode 100644
index 0000000..c7440c9
--- /dev/null
+++ b/include/llvm-libc-types/EFI_CAPSULE.h
@@ -0,0 +1,26 @@
+//===-- Definition of EFI_CAPSULE type ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_CAPSULE_H
+#define LLVM_LIBC_TYPES_EFI_CAPSULE_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_GUID.h"
+
+typedef struct {
+  EFI_GUID CapsuleGuid;
+  uint32_t HeaderSize;
+  uint32_t Flags;
+  uint32_t CapsuleImageSize;
+} EFI_CAPSULE_HEADER;
+
+#define CAPSULE_FLAGS_PERSIST_ACROSS_RESET 0x00010000
+#define CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE 0x00020000
+#define CAPSULE_FLAGS_INITIATE_RESET 0x00040000
+
+#endif // LLVM_LIBC_TYPES_EFI_CAPSULE_H
diff --git a/include/llvm-libc-types/EFI_CONFIGURATION_TABLE.h b/include/llvm-libc-types/EFI_CONFIGURATION_TABLE.h
new file mode 100644
index 0000000..56cd3e4
--- /dev/null
+++ b/include/llvm-libc-types/EFI_CONFIGURATION_TABLE.h
@@ -0,0 +1,19 @@
+//===-- Definition of EFI_CONFIGURATION_TABLE type ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_CONFIGURATION_TABLE_H
+#define LLVM_LIBC_TYPES_EFI_CONFIGURATION_TABLE_H
+
+#include "EFI_GUID.h"
+
+typedef struct {
+  EFI_GUID VendorGuid;
+  void *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+#endif // LLVM_LIBC_TYPES_EFI_CONFIGURATION_TABLE_H
diff --git a/include/llvm-libc-types/EFI_DEVICE_PATH_PROTOCOL.h b/include/llvm-libc-types/EFI_DEVICE_PATH_PROTOCOL.h
new file mode 100644
index 0000000..f6a0b2e
--- /dev/null
+++ b/include/llvm-libc-types/EFI_DEVICE_PATH_PROTOCOL.h
@@ -0,0 +1,23 @@
+//===-- Definition of EFI_DEVICE_PATH_PROTOCOL type -----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_DEVICE_PATH_PROTOCOL_H
+#define LLVM_LIBC_TYPES_EFI_DEVICE_PATH_PROTOCOL_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+#define EFI_DEVICE_PATH_PROTOCOL_GUID                                          \
+  {0x09576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b}}
+
+typedef struct _EFI_DEVICE_PATH_PROTOCOL {
+  uint8_t Type;
+  uint8_t SubType;
+  uint8_t Length[2];
+} EFI_DEVICE_PATH_PROTOCOL;
+
+#endif // LLVM_LIBC_TYPES_EFI_DEVICE_PATH_PROTOCOL_H
diff --git a/include/llvm-libc-types/EFI_EVENT.h b/include/llvm-libc-types/EFI_EVENT.h
new file mode 100644
index 0000000..938856b
--- /dev/null
+++ b/include/llvm-libc-types/EFI_EVENT.h
@@ -0,0 +1,21 @@
+//===-- Definition of EFI_EVENT type --------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_EVENT_H
+#define LLVM_LIBC_TYPES_EFI_EVENT_H
+
+typedef void *EFI_EVENT;
+
+#define EVT_TIMER 0x80000000
+#define EVT_RUNTIME 0x40000000
+#define EVT_NOTIFY_WAIT 0x00000100
+#define EVT_NOTIFY_SIGNAL 0x00000200
+#define EVT_SIGNAL_EXIT_BOOT_SERVICES 0x00000201
+#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE 0x60000202
+
+#endif // LLVM_LIBC_TYPES_EFI_EVENT_H
diff --git a/include/llvm-libc-types/EFI_GUID.h b/include/llvm-libc-types/EFI_GUID.h
new file mode 100644
index 0000000..b353000
--- /dev/null
+++ b/include/llvm-libc-types/EFI_GUID.h
@@ -0,0 +1,21 @@
+//===-- Definition of EFI_GUID type -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_GUID_H
+#define LLVM_LIBC_TYPES_EFI_GUID_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+typedef struct {
+  uint32_t Data1;
+  uint16_t Data2;
+  uint16_t Data3;
+  uint8_t Data4[8];
+} EFI_GUID;
+
+#endif // LLVM_LIBC_TYPES_EFI_GUID_H
diff --git a/include/llvm-libc-types/EFI_HANDLE.h b/include/llvm-libc-types/EFI_HANDLE.h
new file mode 100644
index 0000000..d4376dd
--- /dev/null
+++ b/include/llvm-libc-types/EFI_HANDLE.h
@@ -0,0 +1,14 @@
+//===-- Definition of EFI_HANDLE type ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_HANDLE_H
+#define LLVM_LIBC_TYPES_EFI_HANDLE_H
+
+typedef void *EFI_HANDLE;
+
+#endif // LLVM_LIBC_TYPES_EFI_HANDLE_H
diff --git a/include/llvm-libc-types/EFI_INTERFACE_TYPE.h b/include/llvm-libc-types/EFI_INTERFACE_TYPE.h
new file mode 100644
index 0000000..d463c53
--- /dev/null
+++ b/include/llvm-libc-types/EFI_INTERFACE_TYPE.h
@@ -0,0 +1,16 @@
+//===-- Definition of EFI_INTERFACE_TYPE type -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_INTERFACE_TYPE_H
+#define LLVM_LIBC_TYPES_EFI_INTERFACE_TYPE_H
+
+typedef enum {
+  EFI_NATIVE_INTERFACE,
+} EFI_INTERFACE_TYPE;
+
+#endif // LLVM_LIBC_TYPES_EFI_INTERFACE_TYPE_H
diff --git a/include/llvm-libc-types/EFI_LOCATE_SEARCH_TYPE.h b/include/llvm-libc-types/EFI_LOCATE_SEARCH_TYPE.h
new file mode 100644
index 0000000..3a8fd7b
--- /dev/null
+++ b/include/llvm-libc-types/EFI_LOCATE_SEARCH_TYPE.h
@@ -0,0 +1,18 @@
+//===-- Definition of EFI_LOCATE_SEARCH_TYPE type -------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_LOCATE_SEARCH_TYPE_H
+#define LLVM_LIBC_TYPES_EFI_LOCATE_SEARCH_TYPE_H
+
+typedef enum {
+  AllHandles,
+  ByRegisterNotify,
+  ByProtocol,
+} EFI_LOCATE_SEARCH_TYPE;
+
+#endif // LLVM_LIBC_TYPES_EFI_LOCATE_SEARCH_TYPE_H
diff --git a/include/llvm-libc-types/EFI_MEMORY_DESCRIPTOR.h b/include/llvm-libc-types/EFI_MEMORY_DESCRIPTOR.h
new file mode 100644
index 0000000..72d0579
--- /dev/null
+++ b/include/llvm-libc-types/EFI_MEMORY_DESCRIPTOR.h
@@ -0,0 +1,43 @@
+//===-- Definition of EFI_MEMORY_DESCRIPTOR type --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_MEMORY_DESCRIPTOR_H
+#define LLVM_LIBC_TYPES_EFI_MEMORY_DESCRIPTOR_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_PHYSICAL_ADDRESS.h"
+#include "EFI_VIRTUAL_ADDRESS.h"
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION 1
+
+#define EFI_MEMORY_UC 0x0000000000000001
+#define EFI_MEMORY_WC 0x0000000000000002
+#define EFI_MEMORY_WT 0x0000000000000004
+#define EFI_MEMORY_WB 0x0000000000000008
+#define EFI_MEMORY_UCE 0x0000000000000010
+#define EFI_MEMORY_WP 0x0000000000001000
+#define EFI_MEMORY_RP 0x0000000000002000
+#define EFI_MEMORY_XP 0x0000000000004000
+#define EFI_MEMORY_NV 0x0000000000008000
+#define EFI_MEMORY_MORE_RELIABLE 0x0000000000010000
+#define EFI_MEMORY_RO 0x0000000000020000
+#define EFI_MEMORY_SP 0x0000000000040000
+#define EFI_MEMORY_CPU_CRYPTO 0x0000000000080000
+#define EFI_MEMORY_RUNTIME 0x8000000000000000
+#define EFI_MEMORY_ISA_VALID 0x4000000000000000
+#define EFI_MEMORY_ISA_MASK 0x0FFFF00000000000
+
+typedef struct {
+  uint32_t Type;
+  EFI_PHYSICAL_ADDRESS PhysicalStart;
+  EFI_VIRTUAL_ADDRESS VirtualStart;
+  uint64_t NumberOfPages;
+  uint64_t Attribute;
+} EFI_MEMORY_DESCRIPTOR;
+
+#endif // LLVM_LIBC_TYPES_EFI_MEMORY_DESCRIPTOR_H
diff --git a/include/llvm-libc-types/EFI_MEMORY_TYPE.h b/include/llvm-libc-types/EFI_MEMORY_TYPE.h
new file mode 100644
index 0000000..c8921cd
--- /dev/null
+++ b/include/llvm-libc-types/EFI_MEMORY_TYPE.h
@@ -0,0 +1,32 @@
+//===-- Definition of EFI_MEMORY_TYPE type --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_MEMORY_TYPE_H
+#define LLVM_LIBC_TYPES_EFI_MEMORY_TYPE_H
+
+typedef enum {
+  EfiReservedMemoryType,
+  EfiLoaderCode,
+  EfiLoaderData,
+  EfiBootServicesCode,
+  EfiBootServicesData,
+  EfiRuntimeServicesCode,
+  EfiRuntimeServicesData,
+  EfiConventionalMemory,
+  EfiUnusableMemory,
+  EfiACPIReclaimMemory,
+  EfiACPIMemoryNVS,
+  EfiMemoryMappedIO,
+  EfiMemoryMappedIOPortSpace,
+  EfiPalCode,
+  EfiPersistentMemory,
+  EfiUnacceptedMemoryType,
+  EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+#endif // LLVM_LIBC_TYPES_EFI_MEMORY_TYPE_H
diff --git a/include/llvm-libc-types/EFI_OPEN_PROTOCOL_INFORMATION_ENTRY.h b/include/llvm-libc-types/EFI_OPEN_PROTOCOL_INFORMATION_ENTRY.h
new file mode 100644
index 0000000..de0c59c
--- /dev/null
+++ b/include/llvm-libc-types/EFI_OPEN_PROTOCOL_INFORMATION_ENTRY.h
@@ -0,0 +1,22 @@
+//===-- Definition of EFI_OPEN_PROTOCOL_INFORMATION_ENTRY type ------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_OPEN_PROTOCOL_INFORMATION_ENTRY_H
+#define LLVM_LIBC_TYPES_EFI_OPEN_PROTOCOL_INFORMATION_ENTRY_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_HANDLE.h"
+
+typedef struct {
+  EFI_HANDLE AgentHandle;
+  EFI_HANDLE ControllerHandle;
+  uint32_t Attributes;
+  uint32_t OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+#endif // LLVM_LIBC_TYPES_EFI_OPEN_PROTOCOL_INFORMATION_ENTRY_H
diff --git a/include/llvm-libc-types/EFI_PHYSICAL_ADDRESS.h b/include/llvm-libc-types/EFI_PHYSICAL_ADDRESS.h
new file mode 100644
index 0000000..8880ee6
--- /dev/null
+++ b/include/llvm-libc-types/EFI_PHYSICAL_ADDRESS.h
@@ -0,0 +1,16 @@
+//===-- Definition of EFI_PHYSICAL_ADDRESS type ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_PHYSICAL_ADDRESS_H
+#define LLVM_LIBC_TYPES_EFI_PHYSICAL_ADDRESS_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+typedef uint64_t EFI_PHYSICAL_ADDRESS;
+
+#endif // LLVM_LIBC_TYPES_EFI_PHYSICAL_ADDRESS_H
diff --git a/include/llvm-libc-types/EFI_RUNTIME_SERVICES.h b/include/llvm-libc-types/EFI_RUNTIME_SERVICES.h
new file mode 100644
index 0000000..8913118
--- /dev/null
+++ b/include/llvm-libc-types/EFI_RUNTIME_SERVICES.h
@@ -0,0 +1,137 @@
+//===-- Definition of EFI_RUNTIME_SERVICES type ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_RUNTIME_SERVICES_H
+#define LLVM_LIBC_TYPES_EFI_RUNTIME_SERVICES_H
+
+#include "../llvm-libc-macros/EFIAPI-macros.h"
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_CAPSULE.h"
+#include "EFI_MEMORY_DESCRIPTOR.h"
+#include "EFI_PHYSICAL_ADDRESS.h"
+#include "EFI_STATUS.h"
+#include "EFI_TABLE_HEADER.h"
+#include "EFI_TIME.h"
+#include "char16_t.h"
+#include "size_t.h"
+
+#define EFI_RUNTIME_SERVICES_SIGNATURE 0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION EFI_SPECIFICATION_VERSION
+
+#define EFI_VARIABLE_NON_VOLATILE 0x00000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
+#define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004
+#define EFI_VARIABLE_HARDWARE_ERROR_RECORD 0x00000008
+// This attribute is identified by the mnemonic 'HR' elsewhere
+// in this specification.
+#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS 0x00000010
+// NOTE: EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS is deprecated
+// and should be considered reserved.
+#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
+#define EFI_VARIABLE_APPEND_WRITE 0x00000040
+#define EFI_VARIABLE_ENHANCED_AUTHENTICATED_ACCESS 0x00000080
+
+typedef enum {
+  EfiResetCold,
+  EfiResetWarm,
+  EfiResetShutdown,
+  EfiResetPlatformSpecific,
+} EFI_RESET_TYPE;
+
+#define EFI_VARIABLE_AUTHENTICATION_3_CERT_ID_SHA256 1
+
+typedef struct {
+  uint8_t Type;
+  uint32_t IdSize;
+  // Value is defined as:
+  // uint8_t Id[IdSize];
+} EFI_VARIABLE_AUTHENTICATION_3_CERT_ID;
+
+typedef EFI_STATUS(EFIAPI *EFI_GET_TIME)(EFI_TIME *Time,
+                                         EFI_TIME_CAPABILITIES *Capabilities);
+typedef EFI_STATUS(EFIAPI *EFI_SET_TIME)(EFI_TIME *Time);
+typedef EFI_STATUS(EFIAPI *EFI_GET_WAKEUP_TIME)(bool *Enabled, bool *Pending,
+                                                EFI_TIME *Time);
+typedef EFI_STATUS(EFIAPI *EFI_SET_WAKEUP_TIME)(bool *Enabled, EFI_TIME *Time);
+
+typedef EFI_STATUS(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP)(
+    size_t MemoryMapSize, size_t DescriptorSize, uint32_t DescriptorVersion,
+    EFI_MEMORY_DESCRIPTOR *VirtualMap);
+typedef EFI_STATUS(EFIAPI *EFI_CONVERT_POINTER)(size_t DebugDisposition,
+                                                void **Address);
+
+typedef EFI_STATUS(EFIAPI *EFI_GET_VARIABLE)(char16_t *VariableName,
+                                             EFI_GUID *VendorGuid,
+                                             uint32_t *Attributes,
+                                             size_t *DataSize, void *Data);
+typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME)(size_t *VariableNameSize,
+                                                       char16_t *VariableName,
+                                                       EFI_GUID *VendorGuid);
+typedef EFI_STATUS(EFIAPI *EFI_SET_VARIABLE)(char16_t *VariableName,
+                                             EFI_GUID *VendorGuid,
+                                             uint32_t Attributes,
+                                             size_t DataSize, void *Data);
+
+typedef EFI_STATUS(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT)(uint32_t *HighCount);
+typedef void(EFIAPI *EFI_RESET_SYSTEM)(EFI_RESET_TYPE ResetType,
+                                       EFI_STATUS ResetStatus, size_t DataSize,
+                                       void *ResetData);
+
+typedef EFI_STATUS(EFIAPI *EFI_UPDATE_CAPSULE)(
+    EFI_CAPSULE_HEADER **CapsuleHeaderArray, size_t CapsuleCount,
+    EFI_PHYSICAL_ADDRESS ScatterGatherList);
+typedef EFI_STATUS(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES)(
+    EFI_CAPSULE_HEADER **CapsuleHeaderArray, size_t CapsuleCount,
+    uint64_t *MaximumCapsuleSize, EFI_RESET_TYPE ResetType);
+
+typedef EFI_STATUS(EFIAPI *EFI_QUERY_VARIABLE_INFO)(
+    uint32_t Attributes, uint64_t *MaximumVariableStorageSize,
+    uint64_t *RemainingVariableStorageSize, uint64_t *MaximumVariableSize);
+
+typedef struct {
+  EFI_TABLE_HEADER Hdr;
+
+  ///
+  /// Time Services
+  EFI_GET_TIME GetTime;
+  EFI_SET_TIME SetTime;
+  EFI_GET_WAKEUP_TIME GetWakeupTime;
+  EFI_SET_WAKEUP_TIME SetWakeupTime;
+
+  //
+  // Virtual Memory Services
+  //
+  EFI_SET_VIRTUAL_ADDRESS_MAP SetVirtualAddressMap;
+  EFI_CONVERT_POINTER ConvertPointer;
+
+  //
+  // Variable Services
+  //
+  EFI_GET_VARIABLE GetVariable;
+  EFI_GET_NEXT_VARIABLE_NAME GetNextVariableName;
+  EFI_SET_VARIABLE SetVariable;
+
+  //
+  // Miscellaneous Services
+  //
+  EFI_GET_NEXT_HIGH_MONO_COUNT GetNextHighMonotonicCount;
+  EFI_RESET_SYSTEM ResetSystem;
+
+  //
+  // UEFI 2.0 Capsule Services
+  //
+  EFI_UPDATE_CAPSULE UpdateCapsule;
+  EFI_QUERY_CAPSULE_CAPABILITIES QueryCapsuleCapabilities;
+
+  //
+  // Miscellaneous UEFI 2.0 Service
+  //
+  EFI_QUERY_VARIABLE_INFO QueryVariableInfo;
+} EFI_RUNTIME_SERVICES;
+
+#endif // LLVM_LIBC_TYPES_EFI_RUNTIME_SERVICES_H
diff --git a/include/llvm-libc-types/EFI_SIMPLE_TEXT_INPUT_PROTOCOL.h b/include/llvm-libc-types/EFI_SIMPLE_TEXT_INPUT_PROTOCOL.h
new file mode 100644
index 0000000..a6dc095
--- /dev/null
+++ b/include/llvm-libc-types/EFI_SIMPLE_TEXT_INPUT_PROTOCOL.h
@@ -0,0 +1,39 @@
+//===-- Definition of EFI_SIMPLE_TEXT_INPUT_PROTOCOL type -----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_INPUT_PROTOCOL_H
+#define LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_INPUT_PROTOCOL_H
+
+#include "../llvm-libc-macros/EFIAPI-macros.h"
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_EVENT.h"
+#include "EFI_STATUS.h"
+#include "char16_t.h"
+
+#define EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID                                    \
+  {0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b}}
+
+typedef struct {
+  uint16_t ScanCode;
+  char16_t UnicodeChar;
+} EFI_INPUT_KEY;
+
+struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL;
+
+typedef EFI_STATUS(EFIAPI *EFI_INPUT_RESET)(
+    struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL *This, bool ExtendedVerification);
+typedef EFI_STATUS(EFIAPI *EFI_INPUT_READ_KEY)(
+    struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL *This, EFI_INPUT_KEY *Key);
+
+typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL {
+  EFI_INPUT_RESET Reset;
+  EFI_INPUT_READ_KEY ReadKeyStroke;
+  EFI_EVENT WaitForKey;
+} EFI_SIMPLE_TEXT_INPUT_PROTOCOL;
+
+#endif // LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_INPUT_PROTOCOL_H
diff --git a/include/llvm-libc-types/EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.h b/include/llvm-libc-types/EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.h
new file mode 100644
index 0000000..b5014c4
--- /dev/null
+++ b/include/llvm-libc-types/EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.h
@@ -0,0 +1,64 @@
+//===-- Definition of EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL type ----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_H
+#define LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_STATUS.h"
+#include "size_t.h"
+
+#define EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID                                   \
+  {0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b}}
+
+struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;
+
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_RESET)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, bool ExtendedVerification);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_STRING)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, const char16_t *String);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_TEST_STRING)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, const char16_t *String);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_QUERY_MODE)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, size_t ModeNumber,
+    size_t *Columns, size_t *Rows);
+
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_MODE)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, size_t ModeNumber);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_ATTRIBUTE)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, size_t Attribute);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_CLEAR_SCREEN)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, size_t Column, size_t Row);
+typedef EFI_STATUS(EFIAPI *EFI_TEXT_ENABLE_CURSOR)(
+    struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *This, bool Visible);
+
+typedef struct {
+  int32_t MaxMode;
+  int32_t Mode;
+  int32_t Attribute;
+  int32_t CursorColumn;
+  int32_t CursorRow;
+  bool CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
+  EFI_TEXT_RESET Reset;
+  EFI_TEXT_STRING OutputString;
+  EFI_TEXT_TEST_STRING TestString;
+  EFI_TEXT_QUERY_MODE QueryMode;
+  EFI_TEXT_SET_MODE SetMode;
+  EFI_TEXT_SET_ATTRIBUTE SetAttribute;
+  EFI_TEXT_CLEAR_SCREEN ClearScreen;
+  EFI_TEXT_SET_CURSOR_POSITION SetCursorPosition;
+  EFI_TEXT_ENABLE_CURSOR EnableCursor;
+  SIMPLE_TEXT_OUTPUT_MODE *Mode;
+} EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;
+
+#endif // LLVM_LIBC_TYPES_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_H
diff --git a/include/llvm-libc-types/EFI_STATUS.h b/include/llvm-libc-types/EFI_STATUS.h
new file mode 100644
index 0000000..f7fa6e5
--- /dev/null
+++ b/include/llvm-libc-types/EFI_STATUS.h
@@ -0,0 +1,16 @@
+//===-- Definition of EFI_STATUS type ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_STATUS_H
+#define LLVM_LIBC_TYPES_EFI_STATUS_H
+
+#include "size_t.h"
+
+typedef size_t EFI_STATUS;
+
+#endif // LLVM_LIBC_TYPES_EFI_STATUS_H
diff --git a/include/llvm-libc-types/EFI_SYSTEM_TABLE.h b/include/llvm-libc-types/EFI_SYSTEM_TABLE.h
new file mode 100644
index 0000000..290067a
--- /dev/null
+++ b/include/llvm-libc-types/EFI_SYSTEM_TABLE.h
@@ -0,0 +1,65 @@
+//===-- Definition of EFI_SYSTEM_TABLE type -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_SYSTEM_TABLE_H
+#define LLVM_LIBC_TYPES_EFI_SYSTEM_TABLE_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+#include "EFI_BOOT_SERVICES.h"
+#include "EFI_CONFIGURATION_TABLE.h"
+#include "EFI_HANDLE.h"
+#include "EFI_RUNTIME_SERVICES.h"
+#include "EFI_SIMPLE_TEXT_INPUT_PROTOCOL.h"
+#include "EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.h"
+#include "EFI_STATUS.h"
+#include "EFI_TABLE_HEADER.h"
+
+#include "char16_t.h"
+#include "size_t.h"
+
+#define EFI_SYSTEM_TABLE_SIGNATURE 0x5453595320494249
+#define EFI_2_100_SYSTEM_TABLE_REVISION ((2 << 16) | (100))
+#define EFI_2_90_SYSTEM_TABLE_REVISION ((2 << 16) | (90))
+#define EFI_2_80_SYSTEM_TABLE_REVISION ((2 << 16) | (80))
+#define EFI_2_70_SYSTEM_TABLE_REVISION ((2 << 16) | (70))
+#define EFI_2_60_SYSTEM_TABLE_REVISION ((2 << 16) | (60))
+#define EFI_2_50_SYSTEM_TABLE_REVISION ((2 << 16) | (50))
+#define EFI_2_40_SYSTEM_TABLE_REVISION ((2 << 16) | (40))
+#define EFI_2_31_SYSTEM_TABLE_REVISION ((2 << 16) | (31))
+#define EFI_2_30_SYSTEM_TABLE_REVISION ((2 << 16) | (30))
+#define EFI_2_20_SYSTEM_TABLE_REVISION ((2 << 16) | (20))
+#define EFI_2_10_SYSTEM_TABLE_REVISION ((2 << 16) | (10))
+#define EFI_2_00_SYSTEM_TABLE_REVISION ((2 << 16) | (00))
+#define EFI_1_10_SYSTEM_TABLE_REVISION ((1 << 16) | (10))
+#define EFI_1_02_SYSTEM_TABLE_REVISION ((1 << 16) | (02))
+#define EFI_SPECIFICATION_VERSION EFI_SYSTEM_TABLE_REVISION
+#define EFI_SYSTEM_TABLE_REVISION EFI_2_100_SYSTEM_TABLE_REVISION
+
+typedef struct {
+  EFI_TABLE_HEADER Hdr;
+
+  char16_t *FirmwareVendor;
+  uint32_t FirmwareRevision;
+
+  EFI_HANDLE ConsoleInHandle;
+  EFI_SIMPLE_TEXT_INPUT_PROTOCOL *ConIn;
+
+  EFI_HANDLE ConsoleOutHandle;
+  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *ConOut;
+
+  EFI_HANDLE StandardErrorHandle;
+  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *StdErr;
+
+  EFI_RUNTIME_SERVICES *RuntimeServices;
+  EFI_BOOT_SERVICES *BootServices;
+
+  size_t NumberOfTableEntries;
+  EFI_CONFIGURATION_TABLE *ConfigurationTable;
+} EFI_SYSTEM_TABLE;
+
+#endif // LLVM_LIBC_TYPES_EFI_SYSTEM_TABLE_H
diff --git a/include/llvm-libc-types/EFI_TABLE_HEADER.h b/include/llvm-libc-types/EFI_TABLE_HEADER.h
new file mode 100644
index 0000000..293968e
--- /dev/null
+++ b/include/llvm-libc-types/EFI_TABLE_HEADER.h
@@ -0,0 +1,22 @@
+//===-- Definition of EFI_TABLE_HEADER type -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_TABLE_HEADER_H
+#define LLVM_LIBC_TYPES_EFI_TABLE_HEADER_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+typedef struct {
+  uint64_t Signature;
+  uint32_t Revision;
+  uint32_t HeaderSize;
+  uint32_t CRC32;
+  uint32_t Reserved;
+} EFI_TABLE_HEADER;
+
+#endif // LLVM_LIBC_TYPES_EFI_TABLE_HEADER_H
diff --git a/include/llvm-libc-types/EFI_TIME.h b/include/llvm-libc-types/EFI_TIME.h
new file mode 100644
index 0000000..b0e38b9
--- /dev/null
+++ b/include/llvm-libc-types/EFI_TIME.h
@@ -0,0 +1,37 @@
+//===-- Definition of EFI_TIME type ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_TIME_H
+#define LLVM_LIBC_TYPES_EFI_TIME_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+typedef struct {
+  uint16_t Year;  // 1900 - 9999
+  uint8_t Month;  // 1 - 12
+  uint8_t Day;    // 1 - 31
+  uint8_t Hour;   // 0 - 23
+  uint8_t Minute; // 0 - 59
+  uint8_t Second; // 0 - 59
+  uint8_t Pad1;
+  uint32_t Nanosecond; // 0 - 999,999,999
+  int16_t TimeZone;    // --1440 to 1440 or 2047
+} EFI_TIME;
+
+#define EFI_TIME_ADJUST_DAYLIGHT 0x01
+#define EFI_TIME_IN_DAYLIGHT 0x02
+
+#define EFI_UNSPECIFIED_TIMEZONE 0x07FF
+
+typedef struct {
+  uint32_t Resolution;
+  uint32_t Accuracy;
+  bool SetsToZero;
+} EFI_TIME_CAPABILITIES;
+
+#endif // LLVM_LIBC_TYPES_EFI_TIME_H
diff --git a/include/llvm-libc-types/EFI_TIMER_DELAY.h b/include/llvm-libc-types/EFI_TIMER_DELAY.h
new file mode 100644
index 0000000..2a6872c
--- /dev/null
+++ b/include/llvm-libc-types/EFI_TIMER_DELAY.h
@@ -0,0 +1,18 @@
+//===-- Definition of EFI_TIMER_DELAY type --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_TIMER_DELAY_H
+#define LLVM_LIBC_TYPES_EFI_TIMER_DELAY_H
+
+typedef enum {
+  TimerCancel,
+  TimerPeriodic,
+  TimerRelative,
+} EFI_TIMER_DELAY;
+
+#endif // LLVM_LIBC_TYPES_EFI_TIMER_DELAY_H
diff --git a/include/llvm-libc-types/EFI_TPL.h b/include/llvm-libc-types/EFI_TPL.h
new file mode 100644
index 0000000..8361ccf
--- /dev/null
+++ b/include/llvm-libc-types/EFI_TPL.h
@@ -0,0 +1,21 @@
+//===-- Definition of EFI_TPL type ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_TPL_H
+#define LLVM_LIBC_TYPES_EFI_TPL_H
+
+#include "size_t.h"
+
+typedef size_t EFI_TPL;
+
+#define TPL_APPLICATION 4
+#define TPL_CALLBACK 8
+#define TPL_NOTIFY 16
+#define TPL_HIGH_LEVEL 31
+
+#endif // LLVM_LIBC_TYPES_EFI_TPL_H
diff --git a/include/llvm-libc-types/EFI_VIRTUAL_ADDRESS.h b/include/llvm-libc-types/EFI_VIRTUAL_ADDRESS.h
new file mode 100644
index 0000000..46cbec7
--- /dev/null
+++ b/include/llvm-libc-types/EFI_VIRTUAL_ADDRESS.h
@@ -0,0 +1,16 @@
+//===-- Definition of EFI_VIRTUAL_ADDRESS type ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_EFI_VIRTUAL_ADDRESS_H
+#define LLVM_LIBC_TYPES_EFI_VIRTUAL_ADDRESS_H
+
+#include "../llvm-libc-macros/stdint-macros.h"
+
+typedef uint64_t EFI_VIRTUAL_ADDRESS;
+
+#endif // LLVM_LIBC_TYPES_EFI_VIRTUAL_ADDRESS_H
diff --git a/include/llvm-libc-types/__dl_iterate_phdr_callback_t.h b/include/llvm-libc-types/__dl_iterate_phdr_callback_t.h
new file mode 100644
index 0000000..52078da
--- /dev/null
+++ b/include/llvm-libc-types/__dl_iterate_phdr_callback_t.h
@@ -0,0 +1,19 @@
+//===-- Definition of type __dl_iterate_phdr_callback_t ------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES___DL_ITERATE_PHDR_CALLBACK_T_H
+#define LLVM_LIBC_TYPES___DL_ITERATE_PHDR_CALLBACK_T_H
+
+#include "size_t.h"
+
+struct dl_phdr_info;
+
+typedef int (*__dl_iterate_phdr_callback_t)(struct dl_phdr_info *, size_t,
+                                            void *);
+
+#endif // LLVM_LIBC_TYPES___DL_ITERATE_PHDR_CALLBACK_T_H
diff --git a/include/llvm-libc-types/cfloat128.h b/include/llvm-libc-types/cfloat128.h
index a371671..83fad87 100644
--- a/include/llvm-libc-types/cfloat128.h
+++ b/include/llvm-libc-types/cfloat128.h
@@ -18,23 +18,26 @@
 //
 // TODO: Update the complex variant of C23 `_Float128` type detection again when
 // clang supports it.
-#if defined(__STDC_IEC_60559_COMPLEX__) && !defined(__clang__)
-#if !defined(__cplusplus)
-#define LIBC_TYPES_HAS_CFLOAT128
-typedef _Complex _Float128 cfloat128;
-#elif defined(__GNUC__) && __GNUC__ >= 13
-#define LIBC_TYPES_HAS_CFLOAT128
-typedef _Complex _Float128 cfloat128;
-#endif
-#elif __clang_major__ >= 11 &&                                                 \
+#ifdef __clang__
+#if (__clang_major__ >= 11) &&                                                 \
     (defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__))
 // Use _Complex __float128 type. clang uses __SIZEOF_FLOAT128__ or __FLOAT128__
 // macro to notify the availability of __float128 type:
 // https://reviews.llvm.org/D15120
 #define LIBC_TYPES_HAS_CFLOAT128
 typedef _Complex __float128 cfloat128;
-#elif (LDBL_MANT_DIG == 113)
+#endif
+#elif defined(__GNUC__)
+#if (defined(__STDC_IEC_60559_COMPLEX__) || defined(__SIZEOF_FLOAT128__)) &&   \
+    (__GNUC__ >= 13 || (!defined(__cplusplus)))
+#define LIBC_TYPES_HAS_CFLOAT128
+typedef _Complex _Float128 cfloat128;
+#endif
+#endif
+
+#if !defined(LIBC_TYPES_HAS_CFLOAT128) && (LDBL_MANT_DIG == 113)
 #define LIBC_TYPES_HAS_CFLOAT128
+#define LIBC_TYPES_CFLOAT128_IS_COMPLEX_LONG_DOUBLE
 typedef _Complex long double cfloat128;
 #endif
 
diff --git a/include/llvm-libc-types/cpu_set_t.h b/include/llvm-libc-types/cpu_set_t.h
index e7f5259..8c6859d 100644
--- a/include/llvm-libc-types/cpu_set_t.h
+++ b/include/llvm-libc-types/cpu_set_t.h
@@ -9,6 +9,9 @@
 #ifndef LLVM_LIBC_TYPES_CPU_SET_T_H
 #define LLVM_LIBC_TYPES_CPU_SET_T_H
 
+#define __CPU_SETSIZE 1024
+#define __NCPUBITS (8 * sizeof(unsigned long))
+
 typedef struct {
   // If a processor with more than 1024 CPUs is to be supported in future,
   // we need to adjust the size of this array.
diff --git a/include/llvm-libc-types/__sighandler_t.h b/include/llvm-libc-types/nfds_t.h
similarity index 57%
rename from include/llvm-libc-types/__sighandler_t.h
rename to include/llvm-libc-types/nfds_t.h
index 9c1ac99..c0abcce 100644
--- a/include/llvm-libc-types/__sighandler_t.h
+++ b/include/llvm-libc-types/nfds_t.h
@@ -1,4 +1,4 @@
-//===-- Definition of struct __sighandler_t -------------------------------===//
+//===-- Definition of type nfds_t -----------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,9 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_TYPES___SIGHANDLER_T_H
-#define LLVM_LIBC_TYPES___SIGHANDLER_T_H
+#ifndef LLVM_LIBC_TYPES_NFDS_T_H
+#define LLVM_LIBC_TYPES_NFDS_T_H
 
-typedef void (*__sighandler_t)(int);
+typedef unsigned int nfds_t;
 
-#endif // LLVM_LIBC_TYPES___SIGHANDLER_T_H
+#endif // LLVM_LIBC_TYPES_NFDS_T_H
diff --git a/include/llvm-libc-types/sighandler_t.h b/include/llvm-libc-types/sighandler_t.h
new file mode 100644
index 0000000..f39ab04
--- /dev/null
+++ b/include/llvm-libc-types/sighandler_t.h
@@ -0,0 +1,17 @@
+//===-- Definition of sighandler_t ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_SIGHANDLER_T_H
+#define LLVM_LIBC_TYPES_SIGHANDLER_T_H
+
+#ifdef __linux__
+// For compatibility with glibc.
+typedef void (*sighandler_t)(int);
+#endif
+
+#endif // LLVM_LIBC_TYPES_SIGHANDLER_T_H
diff --git a/include/llvm-libc-types/sigset_t.h b/include/llvm-libc-types/sigset_t.h
index 1f60148..8c4d3b4 100644
--- a/include/llvm-libc-types/sigset_t.h
+++ b/include/llvm-libc-types/sigset_t.h
@@ -13,8 +13,8 @@
 
 // This definition can be adjusted/specialized for different targets and
 // platforms as necessary. This definition works for Linux on most targets.
-struct sigset_t {
+typedef struct {
   unsigned long __signals[__NSIGSET_WORDS];
-};
+} sigset_t;
 
 #endif // LLVM_LIBC_TYPES_SIGSET_T_H
diff --git a/include/llvm-libc-types/struct_dl_phdr_info.h b/include/llvm-libc-types/struct_dl_phdr_info.h
new file mode 100644
index 0000000..2b9a5d2
--- /dev/null
+++ b/include/llvm-libc-types/struct_dl_phdr_info.h
@@ -0,0 +1,30 @@
+//===-- Definition of type struct dl_phdr_info ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_STRUCT_DL_PHDR_INFO_H
+#define LLVM_LIBC_TYPES_STRUCT_DL_PHDR_INFO_H
+
+#include "../llvm-libc-macros/link-macros.h"
+#include "size_t.h"
+#include <elf.h>
+#include <stdint.h>
+
+struct dl_phdr_info {
+  ElfW(Addr) dlpi_addr;
+  const char *dlpi_name;
+  const ElfW(Phdr) * dlpi_phdr;
+  ElfW(Half) dlpi_phnum;
+
+  uint64_t dlpi_adds;
+  uint64_t dlpi_subs;
+
+  size_t dlpi_tls_modid;
+  void *dlpi_tls_data;
+};
+
+#endif // LLVM_LIBC_TYPES_STRUCT_DL_PHDR_INFO_H
diff --git a/include/llvm-libc-types/struct_pollfd.h b/include/llvm-libc-types/struct_pollfd.h
new file mode 100644
index 0000000..80abc8e
--- /dev/null
+++ b/include/llvm-libc-types/struct_pollfd.h
@@ -0,0 +1,18 @@
+//===-- Definition of type struct pollfd ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TYPES_STRUCT_POLLFD_H
+#define LLVM_LIBC_TYPES_STRUCT_POLLFD_H
+
+struct pollfd {
+  int fd;
+  short events;
+  short revents;
+};
+
+#endif // LLVM_LIBC_TYPES_STRUCT_POLLFD_H
diff --git a/include/llvm-libc-types/struct_sigaction.h b/include/llvm-libc-types/struct_sigaction.h
index 4257cfe..907418b 100644
--- a/include/llvm-libc-types/struct_sigaction.h
+++ b/include/llvm-libc-types/struct_sigaction.h
@@ -17,7 +17,7 @@ struct sigaction {
     void (*sa_handler)(int);
     void (*sa_sigaction)(int, siginfo_t *, void *);
   };
-  struct sigset_t sa_mask;
+  sigset_t sa_mask;
   int sa_flags;
 #ifdef __linux__
   // This field is present on linux for most targets.
@@ -25,6 +25,4 @@ struct sigaction {
 #endif
 };
 
-typedef void (*__sighandler_t)(int);
-
 #endif // LLVM_LIBC_TYPES_STRUCT_SIGACTION_H
diff --git a/include/llvm-libc-types/struct_tm.h b/include/llvm-libc-types/struct_tm.h
index 9fef7c5..2ec74ec 100644
--- a/include/llvm-libc-types/struct_tm.h
+++ b/include/llvm-libc-types/struct_tm.h
@@ -19,6 +19,7 @@ struct tm {
   int tm_wday;  // days since Sunday
   int tm_yday;  // days since January
   int tm_isdst; // Daylight Saving Time flag
+  // TODO: add tm_gmtoff and tm_zone? (posix extensions)
 };
 
 #endif // LLVM_LIBC_TYPES_STRUCT_TM_H
diff --git a/libc/shared/rpc.h b/libc/shared/rpc.h
index 3f58674..dd46d5d 100644
--- a/libc/shared/rpc.h
+++ b/libc/shared/rpc.h
@@ -20,12 +20,6 @@
 
 #include "rpc_util.h"
 
-#include <stdint.h>
-
-#ifndef RPC_INLINE
-#define RPC_INLINE inline
-#endif
-
 namespace rpc {
 
 /// Use scoped atomic variants if they are available for the target.
@@ -44,9 +38,9 @@ namespace rpc {
 
 /// Generic codes that can be used whem implementing the server.
 enum Status {
-  SUCCESS = 0x0,
-  ERROR = 0x1000,
-  UNHANDLED_OPCODE = 0x1001,
+  RPC_SUCCESS = 0x0,
+  RPC_ERROR = 0x1000,
+  RPC_UNHANDLED_OPCODE = 0x1001,
 };
 
 /// A fixed size channel used to communicate between the RPC client and server.
@@ -78,12 +72,12 @@ constexpr static uint64_t MAX_PORT_COUNT = 4096;
 ///   - The server will always start with a 'recv' operation.
 ///   - Every 'send' or 'recv' call is mirrored by the other process.
 template <bool Invert> struct Process {
-  RPC_INLINE Process() = default;
-  RPC_INLINE Process(const Process &) = delete;
-  RPC_INLINE Process &operator=(const Process &) = delete;
-  RPC_INLINE Process(Process &&) = default;
-  RPC_INLINE Process &operator=(Process &&) = default;
-  RPC_INLINE ~Process() = default;
+  RPC_ATTRS Process() = default;
+  RPC_ATTRS Process(const Process &) = delete;
+  RPC_ATTRS Process &operator=(const Process &) = delete;
+  RPC_ATTRS Process(Process &&) = default;
+  RPC_ATTRS Process &operator=(Process &&) = default;
+  RPC_ATTRS ~Process() = default;
 
   const uint32_t port_count = 0;
   const uint32_t *const inbox = nullptr;
@@ -94,7 +88,7 @@ template <bool Invert> struct Process {
   static constexpr uint64_t NUM_BITS_IN_WORD = sizeof(uint32_t) * 8;
   uint32_t lock[MAX_PORT_COUNT / NUM_BITS_IN_WORD] = {0};
 
-  RPC_INLINE Process(uint32_t port_count, void *buffer)
+  RPC_ATTRS Process(uint32_t port_count, void *buffer)
       : port_count(port_count), inbox(reinterpret_cast<uint32_t *>(
                                     advance(buffer, inbox_offset(port_count)))),
         outbox(reinterpret_cast<uint32_t *>(
@@ -113,20 +107,20 @@ template <bool Invert> struct Process {
   ///   Header header[port_count];
   ///   Buffer packet[port_count][lane_size];
   /// };
-  RPC_INLINE static constexpr uint64_t allocation_size(uint32_t port_count,
-                                                       uint32_t lane_size) {
+  RPC_ATTRS static constexpr uint64_t allocation_size(uint32_t port_count,
+                                                      uint32_t lane_size) {
     return buffer_offset(port_count) + buffer_bytes(port_count, lane_size);
   }
 
   /// Retrieve the inbox state from memory shared between processes.
-  RPC_INLINE uint32_t load_inbox(uint64_t lane_mask, uint32_t index) const {
+  RPC_ATTRS uint32_t load_inbox(uint64_t lane_mask, uint32_t index) const {
     return rpc::broadcast_value(
         lane_mask, __scoped_atomic_load_n(&inbox[index], __ATOMIC_RELAXED,
                                           __MEMORY_SCOPE_SYSTEM));
   }
 
   /// Retrieve the outbox state from memory shared between processes.
-  RPC_INLINE uint32_t load_outbox(uint64_t lane_mask, uint32_t index) const {
+  RPC_ATTRS uint32_t load_outbox(uint64_t lane_mask, uint32_t index) const {
     return rpc::broadcast_value(
         lane_mask, __scoped_atomic_load_n(&outbox[index], __ATOMIC_RELAXED,
                                           __MEMORY_SCOPE_SYSTEM));
@@ -136,7 +130,7 @@ template <bool Invert> struct Process {
   /// Equivalent to loading outbox followed by store of the inverted value
   /// The outbox is write only by this warp and tracking the value locally is
   /// cheaper than calling load_outbox to get the value to store.
-  RPC_INLINE uint32_t invert_outbox(uint32_t index, uint32_t current_outbox) {
+  RPC_ATTRS uint32_t invert_outbox(uint32_t index, uint32_t current_outbox) {
     uint32_t inverted_outbox = !current_outbox;
     __scoped_atomic_thread_fence(__ATOMIC_RELEASE, __MEMORY_SCOPE_SYSTEM);
     __scoped_atomic_store_n(&outbox[index], inverted_outbox, __ATOMIC_RELAXED,
@@ -146,8 +140,8 @@ template <bool Invert> struct Process {
 
   // Given the current outbox and inbox values, wait until the inbox changes
   // to indicate that this thread owns the buffer element.
-  RPC_INLINE void wait_for_ownership(uint64_t lane_mask, uint32_t index,
-                                     uint32_t outbox, uint32_t in) {
+  RPC_ATTRS void wait_for_ownership(uint64_t lane_mask, uint32_t index,
+                                    uint32_t outbox, uint32_t in) {
     while (buffer_unavailable(in, outbox)) {
       sleep_briefly();
       in = load_inbox(lane_mask, index);
@@ -158,14 +152,14 @@ template <bool Invert> struct Process {
   /// The packet is a linearly allocated array of buffers used to communicate
   /// with the other process. This function returns the appropriate slot in this
   /// array such that the process can operate on an entire warp or wavefront.
-  RPC_INLINE Buffer *get_packet(uint32_t index, uint32_t lane_size) {
+  RPC_ATTRS Buffer *get_packet(uint32_t index, uint32_t lane_size) {
     return &packet[index * lane_size];
   }
 
   /// Determines if this process needs to wait for ownership of the buffer. We
   /// invert the condition on one of the processes to indicate that if one
   /// process owns the buffer then the other does not.
-  RPC_INLINE static bool buffer_unavailable(uint32_t in, uint32_t out) {
+  RPC_ATTRS static bool buffer_unavailable(uint32_t in, uint32_t out) {
     bool cond = in != out;
     return Invert ? !cond : cond;
   }
@@ -174,7 +168,7 @@ template <bool Invert> struct Process {
   /// lane_mask is a bitmap of the threads in the warp that would hold the
   /// single lock on success, e.g. the result of rpc::get_lane_mask()
   /// The lock is held when the n-th bit of the lock bitfield is set.
-  RPC_INLINE bool try_lock(uint64_t lane_mask, uint32_t index) {
+  RPC_ATTRS bool try_lock(uint64_t lane_mask, uint32_t index) {
     // On amdgpu, test and set to the nth lock bit and a sync_lane would suffice
     // On volta, need to handle differences between the threads running and
     // the threads that were detected in the previous call to get_lane_mask()
@@ -214,7 +208,7 @@ template <bool Invert> struct Process {
 
   /// Unlock the lock at index. We need a lane sync to keep this function
   /// convergent, otherwise the compiler will sink the store and deadlock.
-  RPC_INLINE void unlock(uint64_t lane_mask, uint32_t index) {
+  RPC_ATTRS void unlock(uint64_t lane_mask, uint32_t index) {
     // Do not move any writes past the unlock.
     __scoped_atomic_thread_fence(__ATOMIC_RELEASE, __MEMORY_SCOPE_DEVICE);
 
@@ -227,40 +221,40 @@ template <bool Invert> struct Process {
   }
 
   /// Number of bytes to allocate for an inbox or outbox.
-  RPC_INLINE static constexpr uint64_t mailbox_bytes(uint32_t port_count) {
+  RPC_ATTRS static constexpr uint64_t mailbox_bytes(uint32_t port_count) {
     return port_count * sizeof(uint32_t);
   }
 
   /// Number of bytes to allocate for the buffer containing the packets.
-  RPC_INLINE static constexpr uint64_t buffer_bytes(uint32_t port_count,
-                                                    uint32_t lane_size) {
+  RPC_ATTRS static constexpr uint64_t buffer_bytes(uint32_t port_count,
+                                                   uint32_t lane_size) {
     return port_count * lane_size * sizeof(Buffer);
   }
 
   /// Offset of the inbox in memory. This is the same as the outbox if inverted.
-  RPC_INLINE static constexpr uint64_t inbox_offset(uint32_t port_count) {
+  RPC_ATTRS static constexpr uint64_t inbox_offset(uint32_t port_count) {
     return Invert ? mailbox_bytes(port_count) : 0;
   }
 
   /// Offset of the outbox in memory. This is the same as the inbox if inverted.
-  RPC_INLINE static constexpr uint64_t outbox_offset(uint32_t port_count) {
+  RPC_ATTRS static constexpr uint64_t outbox_offset(uint32_t port_count) {
     return Invert ? 0 : mailbox_bytes(port_count);
   }
 
   /// Offset of the buffer containing the packets after the inbox and outbox.
-  RPC_INLINE static constexpr uint64_t header_offset(uint32_t port_count) {
+  RPC_ATTRS static constexpr uint64_t header_offset(uint32_t port_count) {
     return align_up(2 * mailbox_bytes(port_count), alignof(Header));
   }
 
   /// Offset of the buffer containing the packets after the inbox and outbox.
-  RPC_INLINE static constexpr uint64_t buffer_offset(uint32_t port_count) {
+  RPC_ATTRS static constexpr uint64_t buffer_offset(uint32_t port_count) {
     return align_up(header_offset(port_count) + port_count * sizeof(Header),
                     alignof(Buffer));
   }
 
   /// Conditionally set the n-th bit in the atomic bitfield.
-  RPC_INLINE static constexpr uint32_t set_nth(uint32_t *bits, uint32_t index,
-                                               bool cond) {
+  RPC_ATTRS static constexpr uint32_t set_nth(uint32_t *bits, uint32_t index,
+                                              bool cond) {
     uint32_t slot = index / NUM_BITS_IN_WORD;
     uint32_t bit = index % NUM_BITS_IN_WORD;
     return __scoped_atomic_fetch_or(&bits[slot],
@@ -270,8 +264,8 @@ template <bool Invert> struct Process {
   }
 
   /// Conditionally clear the n-th bit in the atomic bitfield.
-  RPC_INLINE static constexpr uint32_t clear_nth(uint32_t *bits, uint32_t index,
-                                                 bool cond) {
+  RPC_ATTRS static constexpr uint32_t clear_nth(uint32_t *bits, uint32_t index,
+                                                bool cond) {
     uint32_t slot = index / NUM_BITS_IN_WORD;
     uint32_t bit = index % NUM_BITS_IN_WORD;
     return __scoped_atomic_fetch_and(&bits[slot],
@@ -283,8 +277,8 @@ template <bool Invert> struct Process {
 
 /// Invokes a function accross every active buffer across the total lane size.
 template <typename F>
-RPC_INLINE static void invoke_rpc(F &&fn, uint32_t lane_size,
-                                  uint64_t lane_mask, Buffer *slot) {
+RPC_ATTRS static void invoke_rpc(F &&fn, uint32_t lane_size, uint64_t lane_mask,
+                                 Buffer *slot) {
   if constexpr (is_process_gpu()) {
     fn(&slot[rpc::get_lane_id()], rpc::get_lane_id());
   } else {
@@ -298,40 +292,37 @@ RPC_INLINE static void invoke_rpc(F &&fn, uint32_t lane_size,
 /// processes. A port is conceptually an index into the memory provided by the
 /// underlying process that is guarded by a lock bit.
 template <bool T> struct Port {
-  RPC_INLINE Port(Process<T> &process, uint64_t lane_mask, uint32_t lane_size,
-                  uint32_t index, uint32_t out)
+  RPC_ATTRS Port(Process<T> &process, uint64_t lane_mask, uint32_t lane_size,
+                 uint32_t index, uint32_t out)
       : process(process), lane_mask(lane_mask), lane_size(lane_size),
         index(index), out(out), receive(false), owns_buffer(true) {}
-  RPC_INLINE ~Port() = default;
+  RPC_ATTRS ~Port() = default;
 
 private:
-  RPC_INLINE Port(const Port &) = delete;
-  RPC_INLINE Port &operator=(const Port &) = delete;
-  RPC_INLINE Port(Port &&) = default;
-  RPC_INLINE Port &operator=(Port &&) = default;
+  RPC_ATTRS Port(const Port &) = delete;
+  RPC_ATTRS Port &operator=(const Port &) = delete;
+  RPC_ATTRS Port(Port &&) = default;
+  RPC_ATTRS Port &operator=(Port &&) = default;
 
   friend struct Client;
   friend struct Server;
   friend class rpc::optional<Port<T>>;
 
 public:
-  template <typename U> RPC_INLINE void recv(U use);
-  template <typename F> RPC_INLINE void send(F fill);
-  template <typename F, typename U>
-  RPC_INLINE void send_and_recv(F fill, U use);
-  template <typename W> RPC_INLINE void recv_and_send(W work);
-  RPC_INLINE void send_n(const void *const *src, uint64_t *size);
-  RPC_INLINE void send_n(const void *src, uint64_t size);
+  template <typename U> RPC_ATTRS void recv(U use);
+  template <typename F> RPC_ATTRS void send(F fill);
+  template <typename F, typename U> RPC_ATTRS void send_and_recv(F fill, U use);
+  template <typename W> RPC_ATTRS void recv_and_send(W work);
+  RPC_ATTRS void send_n(const void *const *src, uint64_t *size);
+  RPC_ATTRS void send_n(const void *src, uint64_t size);
   template <typename A>
-  RPC_INLINE void recv_n(void **dst, uint64_t *size, A &&alloc);
+  RPC_ATTRS void recv_n(void **dst, uint64_t *size, A &&alloc);
 
-  RPC_INLINE uint32_t get_opcode() const {
-    return process.header[index].opcode;
-  }
+  RPC_ATTRS uint32_t get_opcode() const { return process.header[index].opcode; }
 
-  RPC_INLINE uint32_t get_index() const { return index; }
+  RPC_ATTRS uint32_t get_index() const { return index; }
 
-  RPC_INLINE void close() {
+  RPC_ATTRS void close() {
     // Wait for all lanes to finish using the port.
     rpc::sync_lane(lane_mask);
 
@@ -354,16 +345,16 @@ private:
 
 /// The RPC client used to make requests to the server.
 struct Client {
-  RPC_INLINE Client() = default;
-  RPC_INLINE Client(const Client &) = delete;
-  RPC_INLINE Client &operator=(const Client &) = delete;
-  RPC_INLINE ~Client() = default;
+  RPC_ATTRS Client() = default;
+  RPC_ATTRS Client(const Client &) = delete;
+  RPC_ATTRS Client &operator=(const Client &) = delete;
+  RPC_ATTRS ~Client() = default;
 
-  RPC_INLINE Client(uint32_t port_count, void *buffer)
+  RPC_ATTRS Client(uint32_t port_count, void *buffer)
       : process(port_count, buffer) {}
 
   using Port = rpc::Port<false>;
-  template <uint32_t opcode> RPC_INLINE Port open();
+  template <uint32_t opcode> RPC_ATTRS Port open();
 
 private:
   Process<false> process;
@@ -371,21 +362,21 @@ private:
 
 /// The RPC server used to respond to the client.
 struct Server {
-  RPC_INLINE Server() = default;
-  RPC_INLINE Server(const Server &) = delete;
-  RPC_INLINE Server &operator=(const Server &) = delete;
-  RPC_INLINE ~Server() = default;
+  RPC_ATTRS Server() = default;
+  RPC_ATTRS Server(const Server &) = delete;
+  RPC_ATTRS Server &operator=(const Server &) = delete;
+  RPC_ATTRS ~Server() = default;
 
-  RPC_INLINE Server(uint32_t port_count, void *buffer)
+  RPC_ATTRS Server(uint32_t port_count, void *buffer)
       : process(port_count, buffer) {}
 
   using Port = rpc::Port<true>;
-  RPC_INLINE rpc::optional<Port> try_open(uint32_t lane_size,
-                                          uint32_t start = 0);
-  RPC_INLINE Port open(uint32_t lane_size);
+  RPC_ATTRS rpc::optional<Port> try_open(uint32_t lane_size,
+                                         uint32_t start = 0);
+  RPC_ATTRS Port open(uint32_t lane_size);
 
-  RPC_INLINE static uint64_t allocation_size(uint32_t lane_size,
-                                             uint32_t port_count) {
+  RPC_ATTRS static uint64_t allocation_size(uint32_t lane_size,
+                                            uint32_t port_count) {
     return Process<true>::allocation_size(port_count, lane_size);
   }
 
@@ -394,7 +385,7 @@ private:
 };
 
 /// Applies \p fill to the shared buffer and initiates a send operation.
-template <bool T> template <typename F> RPC_INLINE void Port<T>::send(F fill) {
+template <bool T> template <typename F> RPC_ATTRS void Port<T>::send(F fill) {
   uint32_t in = owns_buffer ? out ^ T : process.load_inbox(lane_mask, index);
 
   // We need to wait until we own the buffer before sending.
@@ -409,7 +400,7 @@ template <bool T> template <typename F> RPC_INLINE void Port<T>::send(F fill) {
 }
 
 /// Applies \p use to the shared buffer and acknowledges the send.
-template <bool T> template <typename U> RPC_INLINE void Port<T>::recv(U use) {
+template <bool T> template <typename U> RPC_ATTRS void Port<T>::recv(U use) {
   // We only exchange ownership of the buffer during a receive if we are waiting
   // for a previous receive to finish.
   if (receive) {
@@ -432,7 +423,7 @@ template <bool T> template <typename U> RPC_INLINE void Port<T>::recv(U use) {
 /// Combines a send and receive into a single function.
 template <bool T>
 template <typename F, typename U>
-RPC_INLINE void Port<T>::send_and_recv(F fill, U use) {
+RPC_ATTRS void Port<T>::send_and_recv(F fill, U use) {
   send(fill);
   recv(use);
 }
@@ -442,7 +433,7 @@ RPC_INLINE void Port<T>::send_and_recv(F fill, U use) {
 /// the copy back.
 template <bool T>
 template <typename W>
-RPC_INLINE void Port<T>::recv_and_send(W work) {
+RPC_ATTRS void Port<T>::recv_and_send(W work) {
   recv(work);
   send([](Buffer *, uint32_t) { /* no-op */ });
 }
@@ -450,7 +441,7 @@ RPC_INLINE void Port<T>::recv_and_send(W work) {
 /// Helper routine to simplify the interface when sending from the GPU using
 /// thread private pointers to the underlying value.
 template <bool T>
-RPC_INLINE void Port<T>::send_n(const void *src, uint64_t size) {
+RPC_ATTRS void Port<T>::send_n(const void *src, uint64_t size) {
   const void **src_ptr = &src;
   uint64_t *size_ptr = &size;
   send_n(src_ptr, size_ptr);
@@ -459,7 +450,7 @@ RPC_INLINE void Port<T>::send_n(const void *src, uint64_t size) {
 /// Sends an arbitrarily sized data buffer \p src across the shared channel in
 /// multiples of the packet length.
 template <bool T>
-RPC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
+RPC_ATTRS void Port<T>::send_n(const void *const *src, uint64_t *size) {
   uint64_t num_sends = 0;
   send([&](Buffer *buffer, uint32_t id) {
     reinterpret_cast<uint64_t *>(buffer->data)[0] = lane_value(size, id);
@@ -490,7 +481,7 @@ RPC_INLINE void Port<T>::send_n(const void *const *src, uint64_t *size) {
 /// size of the data so that we can initialize the size of the \p dst buffer.
 template <bool T>
 template <typename A>
-RPC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
+RPC_ATTRS void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
   uint64_t num_recvs = 0;
   recv([&](Buffer *buffer, uint32_t id) {
     lane_value(size, id) = reinterpret_cast<uint64_t *>(buffer->data)[0];
@@ -524,7 +515,7 @@ RPC_INLINE void Port<T>::recv_n(void **dst, uint64_t *size, A &&alloc) {
 /// port. Each port instance uses an associated \p opcode to tell the server
 /// what to do. The Client interface provides the appropriate lane size to the
 /// port using the platform's returned value.
-template <uint32_t opcode> RPC_INLINE Client::Port Client::open() {
+template <uint32_t opcode> RPC_ATTRS Client::Port Client::open() {
   // Repeatedly perform a naive linear scan for a port that can be opened to
   // send data.
   for (uint32_t index = 0;; ++index) {
@@ -558,7 +549,7 @@ template <uint32_t opcode> RPC_INLINE Client::Port Client::open() {
 
 /// Attempts to open a port to use as the server. The server can only open a
 /// port if it has a pending receive operation
-RPC_INLINE rpc::optional<typename Server::Port>
+RPC_ATTRS rpc::optional<typename Server::Port>
 Server::try_open(uint32_t lane_size, uint32_t start) {
   // Perform a naive linear scan for a port that has a pending request.
   for (uint32_t index = start; index < process.port_count; ++index) {
@@ -588,7 +579,7 @@ Server::try_open(uint32_t lane_size, uint32_t start) {
   return rpc::nullopt;
 }
 
-RPC_INLINE Server::Port Server::open(uint32_t lane_size) {
+RPC_ATTRS Server::Port Server::open(uint32_t lane_size) {
   for (;;) {
     if (rpc::optional<Server::Port> p = try_open(lane_size))
       return rpc::move(p.value());
@@ -596,6 +587,7 @@ RPC_INLINE Server::Port Server::open(uint32_t lane_size) {
   }
 }
 
+#undef RPC_ATTRS
 #if !__has_builtin(__scoped_atomic_load_n)
 #undef __scoped_atomic_load_n
 #undef __scoped_atomic_store_n
diff --git a/libc/shared/rpc_opcodes.h b/libc/shared/rpc_opcodes.h
index e7ec0e7..6de41cd 100644
--- a/libc/shared/rpc_opcodes.h
+++ b/libc/shared/rpc_opcodes.h
@@ -15,45 +15,39 @@
 #define LLVM_LIBC_OPCODE(n) (LLVM_LIBC_RPC_BASE << 24 | n)
 
 typedef enum {
-  RPC_NOOP = LLVM_LIBC_OPCODE(0),
-  RPC_EXIT = LLVM_LIBC_OPCODE(1),
-  RPC_WRITE_TO_STDOUT = LLVM_LIBC_OPCODE(2),
-  RPC_WRITE_TO_STDERR = LLVM_LIBC_OPCODE(3),
-  RPC_WRITE_TO_STREAM = LLVM_LIBC_OPCODE(4),
-  RPC_WRITE_TO_STDOUT_NEWLINE = LLVM_LIBC_OPCODE(5),
-  RPC_READ_FROM_STREAM = LLVM_LIBC_OPCODE(6),
-  RPC_READ_FGETS = LLVM_LIBC_OPCODE(7),
-  RPC_OPEN_FILE = LLVM_LIBC_OPCODE(8),
-  RPC_CLOSE_FILE = LLVM_LIBC_OPCODE(9),
-  RPC_MALLOC = LLVM_LIBC_OPCODE(10),
-  RPC_FREE = LLVM_LIBC_OPCODE(11),
-  RPC_HOST_CALL = LLVM_LIBC_OPCODE(12),
-  RPC_ABORT = LLVM_LIBC_OPCODE(13),
-  RPC_FEOF = LLVM_LIBC_OPCODE(14),
-  RPC_FERROR = LLVM_LIBC_OPCODE(15),
-  RPC_CLEARERR = LLVM_LIBC_OPCODE(16),
-  RPC_FSEEK = LLVM_LIBC_OPCODE(17),
-  RPC_FTELL = LLVM_LIBC_OPCODE(18),
-  RPC_FFLUSH = LLVM_LIBC_OPCODE(19),
-  RPC_UNGETC = LLVM_LIBC_OPCODE(20),
-  RPC_PRINTF_TO_STDOUT = LLVM_LIBC_OPCODE(21),
-  RPC_PRINTF_TO_STDERR = LLVM_LIBC_OPCODE(22),
-  RPC_PRINTF_TO_STREAM = LLVM_LIBC_OPCODE(23),
-  RPC_PRINTF_TO_STDOUT_PACKED = LLVM_LIBC_OPCODE(24),
-  RPC_PRINTF_TO_STDERR_PACKED = LLVM_LIBC_OPCODE(25),
-  RPC_PRINTF_TO_STREAM_PACKED = LLVM_LIBC_OPCODE(26),
-  RPC_REMOVE = LLVM_LIBC_OPCODE(27),
-  RPC_RENAME = LLVM_LIBC_OPCODE(28),
-  RPC_SYSTEM = LLVM_LIBC_OPCODE(29),
-  RPC_LAST = 0xFFFFFFFF,
+  LIBC_NOOP = LLVM_LIBC_OPCODE(0),
+  LIBC_EXIT = LLVM_LIBC_OPCODE(1),
+  LIBC_WRITE_TO_STDOUT = LLVM_LIBC_OPCODE(2),
+  LIBC_WRITE_TO_STDERR = LLVM_LIBC_OPCODE(3),
+  LIBC_WRITE_TO_STREAM = LLVM_LIBC_OPCODE(4),
+  LIBC_WRITE_TO_STDOUT_NEWLINE = LLVM_LIBC_OPCODE(5),
+  LIBC_READ_FROM_STREAM = LLVM_LIBC_OPCODE(6),
+  LIBC_READ_FGETS = LLVM_LIBC_OPCODE(7),
+  LIBC_OPEN_FILE = LLVM_LIBC_OPCODE(8),
+  LIBC_CLOSE_FILE = LLVM_LIBC_OPCODE(9),
+  LIBC_MALLOC = LLVM_LIBC_OPCODE(10),
+  LIBC_FREE = LLVM_LIBC_OPCODE(11),
+  LIBC_HOST_CALL = LLVM_LIBC_OPCODE(12),
+  LIBC_ABORT = LLVM_LIBC_OPCODE(13),
+  LIBC_FEOF = LLVM_LIBC_OPCODE(14),
+  LIBC_FERROR = LLVM_LIBC_OPCODE(15),
+  LIBC_CLEARERR = LLVM_LIBC_OPCODE(16),
+  LIBC_FSEEK = LLVM_LIBC_OPCODE(17),
+  LIBC_FTELL = LLVM_LIBC_OPCODE(18),
+  LIBC_FFLUSH = LLVM_LIBC_OPCODE(19),
+  LIBC_UNGETC = LLVM_LIBC_OPCODE(20),
+  LIBC_PRINTF_TO_STDOUT = LLVM_LIBC_OPCODE(21),
+  LIBC_PRINTF_TO_STDERR = LLVM_LIBC_OPCODE(22),
+  LIBC_PRINTF_TO_STREAM = LLVM_LIBC_OPCODE(23),
+  LIBC_PRINTF_TO_STDOUT_PACKED = LLVM_LIBC_OPCODE(24),
+  LIBC_PRINTF_TO_STDERR_PACKED = LLVM_LIBC_OPCODE(25),
+  LIBC_PRINTF_TO_STREAM_PACKED = LLVM_LIBC_OPCODE(26),
+  LIBC_REMOVE = LLVM_LIBC_OPCODE(27),
+  LIBC_RENAME = LLVM_LIBC_OPCODE(28),
+  LIBC_SYSTEM = LLVM_LIBC_OPCODE(29),
+  LIBC_LAST = 0xFFFFFFFF,
 } rpc_opcode_t;
 
 #undef LLVM_LIBC_OPCODE
 
-namespace rpc {
-// The implementation of this function currently lives in the utility directory
-// at 'utils/gpu/server/rpc_server.cpp'.
-rpc::Status handle_libc_opcodes(rpc::Server::Port &port, uint32_t num_lanes);
-} // namespace rpc
-
 #endif // LLVM_LIBC_SHARED_RPC_OPCODES_H
diff --git a/libc/shared/rpc_server.h b/libc/shared/rpc_server.h
new file mode 100644
index 0000000..5509094
--- /dev/null
+++ b/libc/shared/rpc_server.h
@@ -0,0 +1,22 @@
+//===-- Shared RPC server interface -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SHARED_RPC_SERVER_H
+#define LLVM_LIBC_SHARED_RPC_SERVER_H
+
+#include "src/__support/RPC/rpc_server.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace shared {
+
+using LIBC_NAMESPACE::rpc::handle_libc_opcodes;
+
+} // namespace shared
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SHARED_RPC_SERVER_H
diff --git a/libc/shared/rpc_util.h b/libc/shared/rpc_util.h
index bb0177c..687814b 100644
--- a/libc/shared/rpc_util.h
+++ b/libc/shared/rpc_util.h
@@ -12,7 +12,9 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#if defined(__NVPTX__) || defined(__AMDGPU__)
+#if (defined(__NVPTX__) || defined(__AMDGPU__)) &&                             \
+    !((defined(__CUDA__) && !defined(__CUDA_ARCH__)) ||                        \
+      (defined(__HIP__) && !defined(__HIP_DEVICE_COMPILE__)))
 #include <gpuintrin.h>
 #define RPC_TARGET_IS_GPU
 #endif
@@ -22,8 +24,12 @@
 #define __has_builtin(x) 0
 #endif
 
-#ifndef RPC_INLINE
-#define RPC_INLINE inline
+#ifndef RPC_ATTRS
+#if defined(__CUDA__) || defined(__HIP__)
+#define RPC_ATTRS __attribute__((host, device)) inline
+#else
+#define RPC_ATTRS inline
+#endif
 #endif
 
 namespace rpc {
@@ -45,26 +51,26 @@ template <class T> struct is_const<const T> : type_constant<bool, true> {};
 
 /// Freestanding implementation of std::move.
 template <class T>
-RPC_INLINE constexpr typename remove_reference<T>::type &&move(T &&t) {
+RPC_ATTRS constexpr typename remove_reference<T>::type &&move(T &&t) {
   return static_cast<typename remove_reference<T>::type &&>(t);
 }
 
 /// Freestanding implementation of std::forward.
 template <typename T>
-RPC_INLINE constexpr T &&forward(typename remove_reference<T>::type &value) {
+RPC_ATTRS constexpr T &&forward(typename remove_reference<T>::type &value) {
   return static_cast<T &&>(value);
 }
 template <typename T>
-RPC_INLINE constexpr T &&forward(typename remove_reference<T>::type &&value) {
+RPC_ATTRS constexpr T &&forward(typename remove_reference<T>::type &&value) {
   return static_cast<T &&>(value);
 }
 
 struct in_place_t {
-  RPC_INLINE explicit in_place_t() = default;
+  RPC_ATTRS explicit in_place_t() = default;
 };
 
 struct nullopt_t {
-  RPC_INLINE constexpr explicit nullopt_t() = default;
+  RPC_ATTRS constexpr explicit nullopt_t() = default;
 };
 
 constexpr inline in_place_t in_place{};
@@ -80,15 +86,15 @@ template <typename T> class optional {
 
     bool in_use = false;
 
-    RPC_INLINE ~OptionalStorage() { reset(); }
+    RPC_ATTRS ~OptionalStorage() { reset(); }
 
-    RPC_INLINE constexpr OptionalStorage() : empty() {}
+    RPC_ATTRS constexpr OptionalStorage() : empty() {}
 
     template <typename... Args>
-    RPC_INLINE constexpr explicit OptionalStorage(in_place_t, Args &&...args)
+    RPC_ATTRS constexpr explicit OptionalStorage(in_place_t, Args &&...args)
         : stored_value(forward<Args>(args)...) {}
 
-    RPC_INLINE constexpr void reset() {
+    RPC_ATTRS constexpr void reset() {
       if (in_use)
         stored_value.~U();
       in_use = false;
@@ -98,58 +104,58 @@ template <typename T> class optional {
   OptionalStorage<T> storage;
 
 public:
-  RPC_INLINE constexpr optional() = default;
-  RPC_INLINE constexpr optional(nullopt_t) {}
+  RPC_ATTRS constexpr optional() = default;
+  RPC_ATTRS constexpr optional(nullopt_t) {}
 
-  RPC_INLINE constexpr optional(const T &t) : storage(in_place, t) {
+  RPC_ATTRS constexpr optional(const T &t) : storage(in_place, t) {
     storage.in_use = true;
   }
-  RPC_INLINE constexpr optional(const optional &) = default;
+  RPC_ATTRS constexpr optional(const optional &) = default;
 
-  RPC_INLINE constexpr optional(T &&t) : storage(in_place, move(t)) {
+  RPC_ATTRS constexpr optional(T &&t) : storage(in_place, move(t)) {
     storage.in_use = true;
   }
-  RPC_INLINE constexpr optional(optional &&O) = default;
+  RPC_ATTRS constexpr optional(optional &&O) = default;
 
-  RPC_INLINE constexpr optional &operator=(T &&t) {
+  RPC_ATTRS constexpr optional &operator=(T &&t) {
     storage = move(t);
     return *this;
   }
-  RPC_INLINE constexpr optional &operator=(optional &&) = default;
+  RPC_ATTRS constexpr optional &operator=(optional &&) = default;
 
-  RPC_INLINE constexpr optional &operator=(const T &t) {
+  RPC_ATTRS constexpr optional &operator=(const T &t) {
     storage = t;
     return *this;
   }
-  RPC_INLINE constexpr optional &operator=(const optional &) = default;
+  RPC_ATTRS constexpr optional &operator=(const optional &) = default;
 
-  RPC_INLINE constexpr void reset() { storage.reset(); }
+  RPC_ATTRS constexpr void reset() { storage.reset(); }
 
-  RPC_INLINE constexpr const T &value() const & { return storage.stored_value; }
+  RPC_ATTRS constexpr const T &value() const & { return storage.stored_value; }
 
-  RPC_INLINE constexpr T &value() & { return storage.stored_value; }
+  RPC_ATTRS constexpr T &value() & { return storage.stored_value; }
 
-  RPC_INLINE constexpr explicit operator bool() const { return storage.in_use; }
-  RPC_INLINE constexpr bool has_value() const { return storage.in_use; }
-  RPC_INLINE constexpr const T *operator->() const {
+  RPC_ATTRS constexpr explicit operator bool() const { return storage.in_use; }
+  RPC_ATTRS constexpr bool has_value() const { return storage.in_use; }
+  RPC_ATTRS constexpr const T *operator->() const {
     return &storage.stored_value;
   }
-  RPC_INLINE constexpr T *operator->() { return &storage.stored_value; }
-  RPC_INLINE constexpr const T &operator*() const & {
+  RPC_ATTRS constexpr T *operator->() { return &storage.stored_value; }
+  RPC_ATTRS constexpr const T &operator*() const & {
     return storage.stored_value;
   }
-  RPC_INLINE constexpr T &operator*() & { return storage.stored_value; }
+  RPC_ATTRS constexpr T &operator*() & { return storage.stored_value; }
 
-  RPC_INLINE constexpr T &&value() && { return move(storage.stored_value); }
-  RPC_INLINE constexpr T &&operator*() && { return move(storage.stored_value); }
+  RPC_ATTRS constexpr T &&value() && { return move(storage.stored_value); }
+  RPC_ATTRS constexpr T &&operator*() && { return move(storage.stored_value); }
 };
 
 /// Suspend the thread briefly to assist the thread scheduler during busy loops.
-RPC_INLINE void sleep_briefly() {
-#if defined(__NVPTX__)
+RPC_ATTRS void sleep_briefly() {
+#if __has_builtin(__nvvm_reflect)
   if (__nvvm_reflect("__CUDA_ARCH") >= 700)
     asm("nanosleep.u32 64;" ::: "memory");
-#elif defined(__AMDGPU__)
+#elif __has_builtin(__builtin_amdgcn_s_sleep)
   __builtin_amdgcn_s_sleep(2);
 #elif __has_builtin(__builtin_ia32_pause)
   __builtin_ia32_pause();
@@ -161,7 +167,7 @@ RPC_INLINE void sleep_briefly() {
 }
 
 /// Conditional to indicate if this process is running on the GPU.
-RPC_INLINE constexpr bool is_process_gpu() {
+RPC_ATTRS constexpr bool is_process_gpu() {
 #ifdef RPC_TARGET_IS_GPU
   return true;
 #else
@@ -170,14 +176,15 @@ RPC_INLINE constexpr bool is_process_gpu() {
 }
 
 /// Wait for all lanes in the group to complete.
-RPC_INLINE void sync_lane(uint64_t lane_mask) {
+RPC_ATTRS void sync_lane([[maybe_unused]] uint64_t lane_mask) {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_sync_lane(lane_mask);
 #endif
 }
 
 /// Copies the value from the first active thread to the rest.
-RPC_INLINE uint32_t broadcast_value(uint64_t lane_mask, uint32_t x) {
+RPC_ATTRS uint32_t broadcast_value([[maybe_unused]] uint64_t lane_mask,
+                                   uint32_t x) {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_read_first_lane_u32(lane_mask, x);
 #else
@@ -186,7 +193,7 @@ RPC_INLINE uint32_t broadcast_value(uint64_t lane_mask, uint32_t x) {
 }
 
 /// Returns the number lanes that participate in the RPC interface.
-RPC_INLINE uint32_t get_num_lanes() {
+RPC_ATTRS uint32_t get_num_lanes() {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_num_lanes();
 #else
@@ -195,7 +202,7 @@ RPC_INLINE uint32_t get_num_lanes() {
 }
 
 /// Returns the id of the thread inside of an AMD wavefront executing together.
-RPC_INLINE uint64_t get_lane_mask() {
+RPC_ATTRS uint64_t get_lane_mask() {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_lane_mask();
 #else
@@ -204,7 +211,7 @@ RPC_INLINE uint64_t get_lane_mask() {
 }
 
 /// Returns the id of the thread inside of an AMD wavefront executing together.
-RPC_INLINE uint32_t get_lane_id() {
+RPC_ATTRS uint32_t get_lane_id() {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_lane_id();
 #else
@@ -213,7 +220,7 @@ RPC_INLINE uint32_t get_lane_id() {
 }
 
 /// Conditional that is only true for a single thread in a lane.
-RPC_INLINE bool is_first_lane(uint64_t lane_mask) {
+RPC_ATTRS bool is_first_lane([[maybe_unused]] uint64_t lane_mask) {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_is_first_in_lane(lane_mask);
 #else
@@ -222,7 +229,7 @@ RPC_INLINE bool is_first_lane(uint64_t lane_mask) {
 }
 
 /// Returns a bitmask of threads in the current lane for which \p x is true.
-RPC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
+RPC_ATTRS uint64_t ballot([[maybe_unused]] uint64_t lane_mask, bool x) {
 #ifdef RPC_TARGET_IS_GPU
   return __gpu_ballot(lane_mask, x);
 #else
@@ -232,7 +239,7 @@ RPC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
 
 /// Return \p val aligned "upwards" according to \p align.
 template <typename V, typename A>
-RPC_INLINE constexpr V align_up(V val, A align) {
+RPC_ATTRS constexpr V align_up(V val, A align) {
   return ((val + V(align) - 1) / V(align)) * V(align);
 }
 
@@ -240,14 +247,14 @@ RPC_INLINE constexpr V align_up(V val, A align) {
 /// model. On the GPU stack variables are always private to a lane so we can
 /// simply use the variable passed in. On the CPU we need to allocate enough
 /// space for the whole lane and index into it.
-template <typename V> RPC_INLINE V &lane_value(V *val, uint32_t id) {
+template <typename V> RPC_ATTRS V &lane_value(V *val, uint32_t id) {
   if constexpr (is_process_gpu())
     return *val;
   return val[id];
 }
 
 /// Advance the \p p by \p bytes.
-template <typename T, typename U> RPC_INLINE T *advance(T *ptr, U bytes) {
+template <typename T, typename U> RPC_ATTRS T *advance(T *ptr, U bytes) {
   if constexpr (is_const<T>::value)
     return reinterpret_cast<T *>(reinterpret_cast<const uint8_t *>(ptr) +
                                  bytes);
@@ -256,11 +263,11 @@ template <typename T, typename U> RPC_INLINE T *advance(T *ptr, U bytes) {
 }
 
 /// Wrapper around the optimal memory copy implementation for the target.
-RPC_INLINE void rpc_memcpy(void *dst, const void *src, size_t count) {
+RPC_ATTRS void rpc_memcpy(void *dst, const void *src, size_t count) {
   __builtin_memcpy(dst, src, count);
 }
 
-template <class T> RPC_INLINE constexpr const T &max(const T &a, const T &b) {
+template <class T> RPC_ATTRS constexpr const T &max(const T &a, const T &b) {
   return (a < b) ? b : a;
 }
 
diff --git a/src/__support/CPP/algorithm.h b/src/__support/CPP/algorithm.h
index f5dc906..7704b3f 100644
--- a/src/__support/CPP/algorithm.h
+++ b/src/__support/CPP/algorithm.h
@@ -26,6 +26,8 @@ template <class T> LIBC_INLINE constexpr const T &min(const T &a, const T &b) {
   return (a < b) ? a : b;
 }
 
+template <class T> LIBC_INLINE constexpr T abs(T a) { return a < 0 ? -a : a; }
+
 template <class InputIt, class UnaryPred>
 LIBC_INLINE constexpr InputIt find_if_not(InputIt first, InputIt last,
                                           UnaryPred q) {
diff --git a/src/__support/CPP/atomic.h b/src/__support/CPP/atomic.h
index 72e7f2a..287dcac 100644
--- a/src/__support/CPP/atomic.h
+++ b/src/__support/CPP/atomic.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_ATOMIC_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_ATOMIC_H
 
+#include "src/__support/CPP/type_traits/has_unique_object_representations.h"
 #include "src/__support/macros/attributes.h"
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
@@ -40,15 +41,37 @@ enum class MemoryScope : int {
 };
 
 template <typename T> struct Atomic {
-  // For now, we will restrict to only arithmetic types.
-  static_assert(is_arithmetic_v<T>, "Only arithmetic types can be atomic.");
+  static_assert(is_trivially_copyable_v<T> && is_copy_constructible_v<T> &&
+                    is_move_constructible_v<T> && is_copy_assignable_v<T> &&
+                    is_move_assignable_v<T>,
+                "atomic<T> requires T to be trivially copyable, copy "
+                "constructible, move constructible, copy assignable, "
+                "and move assignable.");
+
+  static_assert(cpp::has_unique_object_representations_v<T>,
+                "atomic<T> in libc only support types whose values has unique "
+                "object representations.");
 
 private:
-  // The value stored should be appropriately aligned so that
-  // hardware instructions used to perform atomic operations work
-  // correctly.
-  static constexpr int ALIGNMENT = sizeof(T) > alignof(T) ? sizeof(T)
-                                                          : alignof(T);
+  // type conversion helper to avoid long c++ style casts
+  LIBC_INLINE static int order(MemoryOrder mem_ord) {
+    return static_cast<int>(mem_ord);
+  }
+
+  LIBC_INLINE static int scope(MemoryScope mem_scope) {
+    return static_cast<int>(mem_scope);
+  }
+
+  LIBC_INLINE static T *addressof(T &ref) { return __builtin_addressof(ref); }
+
+  // Require types that are 1, 2, 4, 8, or 16 bytes in length to be aligned to
+  // at least their size to be potentially used lock-free.
+  LIBC_INLINE_VAR static constexpr size_t MIN_ALIGNMENT =
+      (sizeof(T) & (sizeof(T) - 1)) || (sizeof(T) > 16) ? 0 : sizeof(T);
+
+  LIBC_INLINE_VAR static constexpr size_t ALIGNMENT = alignof(T) > MIN_ALIGNMENT
+                                                          ? alignof(T)
+                                                          : MIN_ALIGNMENT;
 
 public:
   using value_type = T;
@@ -59,139 +82,160 @@ public:
   // operations should be performed using the atomic methods however.
   alignas(ALIGNMENT) value_type val;
 
-  constexpr Atomic() = default;
+  LIBC_INLINE constexpr Atomic() = default;
 
   // Intializes the value without using atomic operations.
-  constexpr Atomic(value_type v) : val(v) {}
+  LIBC_INLINE constexpr Atomic(value_type v) : val(v) {}
 
-  Atomic(const Atomic &) = delete;
-  Atomic &operator=(const Atomic &) = delete;
+  LIBC_INLINE Atomic(const Atomic &) = delete;
+  LIBC_INLINE Atomic &operator=(const Atomic &) = delete;
 
   // Atomic load.
-  operator T() { return __atomic_load_n(&val, int(MemoryOrder::SEQ_CST)); }
+  LIBC_INLINE operator T() { return load(); }
 
-  T load(MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-         [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-#if __has_builtin(__scoped_atomic_load_n)
-    return __scoped_atomic_load_n(&val, int(mem_ord), (int)(mem_scope));
+  LIBC_INLINE T
+  load(MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+       [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    T res;
+#if __has_builtin(__scoped_atomic_load)
+    __scoped_atomic_load(addressof(val), addressof(res), order(mem_ord),
+                         scope(mem_scope));
 #else
-    return __atomic_load_n(&val, int(mem_ord));
+    __atomic_load(addressof(val), addressof(res), order(mem_ord));
 #endif
+    return res;
   }
 
   // Atomic store.
-  T operator=(T rhs) {
-    __atomic_store_n(&val, rhs, int(MemoryOrder::SEQ_CST));
+  LIBC_INLINE T operator=(T rhs) {
+    store(rhs);
     return rhs;
   }
 
-  void store(T rhs, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-             [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-#if __has_builtin(__scoped_atomic_store_n)
-    __scoped_atomic_store_n(&val, rhs, int(mem_ord), (int)(mem_scope));
+  LIBC_INLINE void
+  store(T rhs, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+        [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+#if __has_builtin(__scoped_atomic_store)
+    __scoped_atomic_store(addressof(val), addressof(rhs), order(mem_ord),
+                          scope(mem_scope));
 #else
-    __atomic_store_n(&val, rhs, int(mem_ord));
+    __atomic_store(addressof(val), addressof(rhs), order(mem_ord));
 #endif
   }
 
   // Atomic compare exchange
-  bool compare_exchange_strong(
+  LIBC_INLINE bool compare_exchange_strong(
       T &expected, T desired, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
       [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-    return __atomic_compare_exchange_n(&val, &expected, desired, false,
-                                       int(mem_ord), int(mem_ord));
+    return __atomic_compare_exchange(addressof(val), addressof(expected),
+                                     addressof(desired), false, order(mem_ord),
+                                     order(mem_ord));
   }
 
   // Atomic compare exchange (separate success and failure memory orders)
-  bool compare_exchange_strong(
+  LIBC_INLINE bool compare_exchange_strong(
       T &expected, T desired, MemoryOrder success_order,
       MemoryOrder failure_order,
       [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-    return __atomic_compare_exchange_n(&val, &expected, desired, false,
-                                       static_cast<int>(success_order),
-                                       static_cast<int>(failure_order));
+    return __atomic_compare_exchange(
+        addressof(val), addressof(expected), addressof(desired), false,
+        order(success_order), order(failure_order));
   }
 
   // Atomic compare exchange (weak version)
-  bool compare_exchange_weak(
+  LIBC_INLINE bool compare_exchange_weak(
       T &expected, T desired, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
       [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-    return __atomic_compare_exchange_n(&val, &expected, desired, true,
-                                       static_cast<int>(mem_ord),
-                                       static_cast<int>(mem_ord));
+    return __atomic_compare_exchange(addressof(val), addressof(expected),
+                                     addressof(desired), true, order(mem_ord),
+                                     order(mem_ord));
   }
 
   // Atomic compare exchange (weak version with separate success and failure
   // memory orders)
-  bool compare_exchange_weak(
+  LIBC_INLINE bool compare_exchange_weak(
       T &expected, T desired, MemoryOrder success_order,
       MemoryOrder failure_order,
       [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-    return __atomic_compare_exchange_n(&val, &expected, desired, true,
-                                       static_cast<int>(success_order),
-                                       static_cast<int>(failure_order));
+    return __atomic_compare_exchange(
+        addressof(val), addressof(expected), addressof(desired), true,
+        order(success_order), order(failure_order));
   }
 
-  T exchange(T desired, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-             [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
-#if __has_builtin(__scoped_atomic_exchange_n)
-    return __scoped_atomic_exchange_n(&val, desired, int(mem_ord),
-                                      (int)(mem_scope));
+  LIBC_INLINE T
+  exchange(T desired, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+           [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    T ret;
+#if __has_builtin(__scoped_atomic_exchange)
+    __scoped_atomic_exchange(addressof(val), addressof(desired), addressof(ret),
+                             order(mem_ord), scope(mem_scope));
 #else
-    return __atomic_exchange_n(&val, desired, int(mem_ord));
+    __atomic_exchange(addressof(val), addressof(desired), addressof(ret),
+                      order(mem_ord));
 #endif
+    return ret;
   }
 
-  T fetch_add(T increment, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-              [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+  LIBC_INLINE T
+  fetch_add(T increment, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+            [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    static_assert(cpp::is_integral_v<T>, "T must be an integral type.");
 #if __has_builtin(__scoped_atomic_fetch_add)
-    return __scoped_atomic_fetch_add(&val, increment, int(mem_ord),
-                                     (int)(mem_scope));
+    return __scoped_atomic_fetch_add(addressof(val), increment, order(mem_ord),
+                                     scope(mem_scope));
 #else
-    return __atomic_fetch_add(&val, increment, int(mem_ord));
+    return __atomic_fetch_add(addressof(val), increment, order(mem_ord));
 #endif
   }
 
-  T fetch_or(T mask, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-             [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+  LIBC_INLINE T
+  fetch_or(T mask, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+           [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    static_assert(cpp::is_integral_v<T>, "T must be an integral type.");
 #if __has_builtin(__scoped_atomic_fetch_or)
-    return __scoped_atomic_fetch_or(&val, mask, int(mem_ord), (int)(mem_scope));
+    return __scoped_atomic_fetch_or(addressof(val), mask, order(mem_ord),
+                                    scope(mem_scope));
 #else
-    return __atomic_fetch_or(&val, mask, int(mem_ord));
+    return __atomic_fetch_or(addressof(val), mask, order(mem_ord));
 #endif
   }
 
-  T fetch_and(T mask, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-              [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+  LIBC_INLINE T
+  fetch_and(T mask, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+            [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    static_assert(cpp::is_integral_v<T>, "T must be an integral type.");
 #if __has_builtin(__scoped_atomic_fetch_and)
-    return __scoped_atomic_fetch_and(&val, mask, int(mem_ord),
-                                     (int)(mem_scope));
+    return __scoped_atomic_fetch_and(addressof(val), mask, order(mem_ord),
+                                     scope(mem_scope));
 #else
-    return __atomic_fetch_and(&val, mask, int(mem_ord));
+    return __atomic_fetch_and(addressof(val), mask, order(mem_ord));
 #endif
   }
 
-  T fetch_sub(T decrement, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
-              [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+  LIBC_INLINE T
+  fetch_sub(T decrement, MemoryOrder mem_ord = MemoryOrder::SEQ_CST,
+            [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+    static_assert(cpp::is_integral_v<T>, "T must be an integral type.");
 #if __has_builtin(__scoped_atomic_fetch_sub)
-    return __scoped_atomic_fetch_sub(&val, decrement, int(mem_ord),
-                                     (int)(mem_scope));
+    return __scoped_atomic_fetch_sub(addressof(val), decrement, order(mem_ord),
+                                     scope(mem_scope));
 #else
-    return __atomic_fetch_sub(&val, decrement, int(mem_ord));
+    return __atomic_fetch_sub(addressof(val), decrement, order(mem_ord));
 #endif
   }
 
   // Set the value without using an atomic operation. This is useful
   // in initializing atomic values without a constructor.
-  void set(T rhs) { val = rhs; }
+  LIBC_INLINE void set(T rhs) { val = rhs; }
 };
 
 // Issue a thread fence with the given memory ordering.
-LIBC_INLINE void atomic_thread_fence([[maybe_unused]] MemoryOrder mem_ord) {
-// The NVPTX backend currently does not support atomic thread fences so we use a
-// full system fence instead.
-#ifdef LIBC_TARGET_ARCH_IS_NVPTX
-  __nvvm_membar_sys();
+LIBC_INLINE void atomic_thread_fence(
+    MemoryOrder mem_ord,
+    [[maybe_unused]] MemoryScope mem_scope = MemoryScope::DEVICE) {
+#if __has_builtin(__scoped_atomic_thread_fence)
+  __scoped_atomic_thread_fence(static_cast<int>(mem_ord),
+                               static_cast<int>(mem_scope));
 #else
   __atomic_thread_fence(static_cast<int>(mem_ord));
 #endif
diff --git a/src/__support/CPP/bit.h b/src/__support/CPP/bit.h
index adcd047..e491f3e 100644
--- a/src/__support/CPP/bit.h
+++ b/src/__support/CPP/bit.h
@@ -101,7 +101,7 @@ countr_zero(T value) {
     shift >>= 1;
     mask >>= shift;
   }
-  return zero_bits;
+  return static_cast<int>(zero_bits);
 }
 #if __has_builtin(__builtin_ctzs)
 ADD_SPECIALIZATION(countr_zero, unsigned short, __builtin_ctzs)
@@ -140,7 +140,7 @@ countl_zero(T value) {
     else
       zero_bits |= shift;
   }
-  return zero_bits;
+  return static_cast<int>(zero_bits);
 }
 #if __has_builtin(__builtin_clzs)
 ADD_SPECIALIZATION(countl_zero, unsigned short, __builtin_clzs)
@@ -162,7 +162,7 @@ ADD_SPECIALIZATION(countl_zero, unsigned long long, __builtin_clzll)
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_unsigned_v<T>, int>
 countl_one(T value) {
-  return cpp::countl_zero<T>(~value);
+  return cpp::countl_zero<T>(static_cast<T>(~value));
 }
 
 /// Count the number of ones from the least significant bit to the first
@@ -175,7 +175,7 @@ countl_one(T value) {
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_unsigned_v<T>, int>
 countr_one(T value) {
-  return cpp::countr_zero<T>(~value);
+  return cpp::countr_zero<T>(static_cast<T>(~value));
 }
 
 /// Returns the number of bits needed to represent value if value is nonzero.
@@ -226,25 +226,25 @@ rotr(T value, int rotate);
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_unsigned_v<T>, T>
 rotl(T value, int rotate) {
-  constexpr unsigned N = cpp::numeric_limits<T>::digits;
+  constexpr int N = cpp::numeric_limits<T>::digits;
   rotate = rotate % N;
   if (!rotate)
     return value;
   if (rotate < 0)
     return cpp::rotr<T>(value, -rotate);
-  return (value << rotate) | (value >> (N - rotate));
+  return static_cast<T>((value << rotate) | (value >> (N - rotate)));
 }
 
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_unsigned_v<T>, T>
 rotr(T value, int rotate) {
-  constexpr unsigned N = cpp::numeric_limits<T>::digits;
+  constexpr int N = cpp::numeric_limits<T>::digits;
   rotate = rotate % N;
   if (!rotate)
     return value;
   if (rotate < 0)
     return cpp::rotl<T>(value, -rotate);
-  return (value >> rotate) | (value << (N - rotate));
+  return static_cast<T>((value >> rotate) | (value << (N - rotate)));
 }
 
 // TODO: Do we need this function at all? How is it different from
diff --git a/src/__support/CPP/span.h b/src/__support/CPP/span.h
index e9e3dbf..9234a26 100644
--- a/src/__support/CPP/span.h
+++ b/src/__support/CPP/span.h
@@ -10,7 +10,8 @@
 
 #include <stddef.h> // For size_t
 
-#include "array.h"       // For array
+#include "array.h" // For array
+#include "limits.h"
 #include "src/__support/macros/config.h"
 #include "type_traits.h" // For remove_cv_t, enable_if_t, is_same_v, is_const_v
 
@@ -48,15 +49,18 @@ public:
   using const_reference = const T &;
   using iterator = T *;
 
-  LIBC_INLINE_VAR static constexpr size_type dynamic_extent = -1;
+  LIBC_INLINE_VAR static constexpr size_type dynamic_extent =
+      cpp::numeric_limits<size_type>::max();
 
   LIBC_INLINE constexpr span() : span_data(nullptr), span_size(0) {}
 
+  LIBC_INLINE constexpr span(const span &) = default;
+
   LIBC_INLINE constexpr span(pointer first, size_type count)
       : span_data(first), span_size(count) {}
 
   LIBC_INLINE constexpr span(pointer first, pointer end)
-      : span_data(first), span_size(end - first) {}
+      : span_data(first), span_size(static_cast<size_t>(end - first)) {}
 
   template <typename U, size_t N,
             cpp::enable_if_t<is_compatible_v<U>, bool> = true>
diff --git a/src/__support/CPP/string.h b/src/__support/CPP/string.h
index dbc0ae0..1ac04c7 100644
--- a/src/__support/CPP/string.h
+++ b/src/__support/CPP/string.h
@@ -67,7 +67,8 @@ public:
       : string(cstr, ::LIBC_NAMESPACE::internal::string_length(cstr)) {}
   LIBC_INLINE string(size_t size_, char value) {
     resize(size_);
-    inline_memset((void *)buffer_, value, size_);
+    static_assert(sizeof(char) == sizeof(uint8_t));
+    inline_memset((void *)buffer_, static_cast<uint8_t>(value), size_);
   }
 
   LIBC_INLINE string &operator=(const string &other) {
diff --git a/src/__support/CPP/string_view.h b/src/__support/CPP/string_view.h
index 745c62c..aa15814 100644
--- a/src/__support/CPP/string_view.h
+++ b/src/__support/CPP/string_view.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_CPP_STRING_VIEW_H
 #define LLVM_LIBC_SRC___SUPPORT_CPP_STRING_VIEW_H
 
+#include "limits.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
@@ -40,7 +41,7 @@ private:
   LIBC_INLINE static constexpr size_t length(const char *Str) {
     for (const char *End = Str;; ++End)
       if (*End == '\0')
-        return End - Str;
+        return static_cast<size_t>(End - Str);
   }
 
   LIBC_INLINE bool equals(string_view Other) const {
@@ -61,7 +62,8 @@ public:
 
   // special value equal to the maximum value representable by the type
   // size_type.
-  LIBC_INLINE_VAR static constexpr size_t npos = -1;
+  LIBC_INLINE_VAR static constexpr size_t npos =
+      cpp::numeric_limits<size_t>::max();
 
   LIBC_INLINE constexpr string_view() : Data(nullptr), Len(0) {}
 
diff --git a/src/__support/CPP/type_traits.h b/src/__support/CPP/type_traits.h
index d50b661..d48ee23 100644
--- a/src/__support/CPP/type_traits.h
+++ b/src/__support/CPP/type_traits.h
@@ -18,6 +18,7 @@
 #include "src/__support/CPP/type_traits/decay.h"
 #include "src/__support/CPP/type_traits/enable_if.h"
 #include "src/__support/CPP/type_traits/false_type.h"
+#include "src/__support/CPP/type_traits/has_unique_object_representations.h"
 #include "src/__support/CPP/type_traits/integral_constant.h"
 #include "src/__support/CPP/type_traits/invoke.h"
 #include "src/__support/CPP/type_traits/invoke_result.h"
@@ -25,9 +26,12 @@
 #include "src/__support/CPP/type_traits/is_array.h"
 #include "src/__support/CPP/type_traits/is_base_of.h"
 #include "src/__support/CPP/type_traits/is_class.h"
+#include "src/__support/CPP/type_traits/is_complex.h"
 #include "src/__support/CPP/type_traits/is_const.h"
 #include "src/__support/CPP/type_traits/is_constant_evaluated.h"
 #include "src/__support/CPP/type_traits/is_convertible.h"
+#include "src/__support/CPP/type_traits/is_copy_assignable.h"
+#include "src/__support/CPP/type_traits/is_copy_constructible.h"
 #include "src/__support/CPP/type_traits/is_destructible.h"
 #include "src/__support/CPP/type_traits/is_enum.h"
 #include "src/__support/CPP/type_traits/is_fixed_point.h"
@@ -36,6 +40,8 @@
 #include "src/__support/CPP/type_traits/is_integral.h"
 #include "src/__support/CPP/type_traits/is_lvalue_reference.h"
 #include "src/__support/CPP/type_traits/is_member_pointer.h"
+#include "src/__support/CPP/type_traits/is_move_assignable.h"
+#include "src/__support/CPP/type_traits/is_move_constructible.h"
 #include "src/__support/CPP/type_traits/is_null_pointer.h"
 #include "src/__support/CPP/type_traits/is_object.h"
 #include "src/__support/CPP/type_traits/is_pointer.h"
diff --git a/src/__support/CPP/type_traits/has_unique_object_representations.h b/src/__support/CPP/type_traits/has_unique_object_representations.h
new file mode 100644
index 0000000..639fb69
--- /dev/null
+++ b/src/__support/CPP/type_traits/has_unique_object_representations.h
@@ -0,0 +1,30 @@
+//===-- has_unique_object_representations type_traits ------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_HAS_UNIQUE_OBJECT_REPRESENTATIONS_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_HAS_UNIQUE_OBJECT_REPRESENTATIONS_H
+
+#include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/CPP/type_traits/remove_all_extents.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+template <class T>
+struct has_unique_object_representations
+    : public integral_constant<bool, __has_unique_object_representations(
+                                         remove_all_extents_t<T>)> {};
+
+template <class T>
+LIBC_INLINE_VAR constexpr bool has_unique_object_representations_v =
+    has_unique_object_representations<T>::value;
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_HAS_UNIQUE_OBJECT_REPRESENTATIONS_H
diff --git a/src/__support/CPP/type_traits/is_copy_assignable.h b/src/__support/CPP/type_traits/is_copy_assignable.h
new file mode 100644
index 0000000..9beb93d
--- /dev/null
+++ b/src/__support/CPP/type_traits/is_copy_assignable.h
@@ -0,0 +1,32 @@
+//===-- is_copy_assignable type_traits --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_ASSIGNABLE_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_ASSIGNABLE_H
+
+#include "src/__support/CPP/type_traits/add_lvalue_reference.h"
+#include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+// is copy assignable
+template <class T>
+struct is_copy_assignable
+    : public integral_constant<
+          bool, __is_assignable(cpp::add_lvalue_reference_t<T>,
+                                cpp::add_lvalue_reference_t<const T>)> {};
+
+template <class T>
+LIBC_INLINE_VAR constexpr bool is_copy_assignable_v =
+    is_copy_assignable<T>::value;
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_ASSIGNABLE_H
diff --git a/src/__support/CPP/type_traits/is_copy_constructible.h b/src/__support/CPP/type_traits/is_copy_constructible.h
new file mode 100644
index 0000000..d8eb9ad
--- /dev/null
+++ b/src/__support/CPP/type_traits/is_copy_constructible.h
@@ -0,0 +1,31 @@
+//===-- is_copy_constructible type_traits -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_CONSTRUCTIBLE_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_CONSTRUCTIBLE_H
+
+#include "src/__support/CPP/type_traits/add_lvalue_reference.h"
+#include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+// is copy constructible
+template <class T>
+struct is_copy_constructible
+    : public integral_constant<
+          bool, __is_constructible(T, cpp::add_lvalue_reference_t<const T>)> {};
+
+template <class T>
+LIBC_INLINE_VAR constexpr bool is_copy_constructible_v =
+    is_copy_constructible<T>::value;
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_COPY_CONSTRUCTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_move_assignable.h b/src/__support/CPP/type_traits/is_move_assignable.h
new file mode 100644
index 0000000..a788bd9
--- /dev/null
+++ b/src/__support/CPP/type_traits/is_move_assignable.h
@@ -0,0 +1,33 @@
+//===-- is_move_assignable type_traits --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_ASSIGNABLE_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_ASSIGNABLE_H
+
+#include "src/__support/CPP/type_traits/add_lvalue_reference.h"
+#include "src/__support/CPP/type_traits/add_rvalue_reference.h"
+#include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+// is move assignable
+template <class T>
+struct is_move_assignable
+    : public integral_constant<bool, __is_assignable(
+                                         cpp::add_lvalue_reference_t<T>,
+                                         cpp::add_rvalue_reference_t<T>)> {};
+
+template <class T>
+LIBC_INLINE_VAR constexpr bool is_move_assignable_v =
+    is_move_assignable<T>::value;
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_ASSIGNABLE_H
diff --git a/src/__support/CPP/type_traits/is_move_constructible.h b/src/__support/CPP/type_traits/is_move_constructible.h
new file mode 100644
index 0000000..c898960
--- /dev/null
+++ b/src/__support/CPP/type_traits/is_move_constructible.h
@@ -0,0 +1,31 @@
+//===-- is_move_constructible type_traits ------------------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_CONSTRUCTIBLE_H
+#define LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_CONSTRUCTIBLE_H
+
+#include "src/__support/CPP/type_traits/add_rvalue_reference.h"
+#include "src/__support/CPP/type_traits/integral_constant.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace cpp {
+
+// is move constructible
+template <class T>
+struct is_move_constructible
+    : public integral_constant<bool, __is_constructible(
+                                         T, cpp::add_rvalue_reference_t<T>)> {};
+
+template <class T>
+LIBC_INLINE_VAR constexpr bool is_move_constructible_v =
+    is_move_constructible<T>::value;
+
+} // namespace cpp
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_CPP_TYPE_TRAITS_IS_MOVE_CONSTRUCTIBLE_H
diff --git a/src/__support/CPP/type_traits/is_trivially_copyable.h b/src/__support/CPP/type_traits/is_trivially_copyable.h
index 68e56c8..a3e786f 100644
--- a/src/__support/CPP/type_traits/is_trivially_copyable.h
+++ b/src/__support/CPP/type_traits/is_trivially_copyable.h
@@ -19,6 +19,10 @@ template <class T>
 struct is_trivially_copyable
     : public integral_constant<bool, __is_trivially_copyable(T)> {};
 
+template <class T>
+LIBC_INLINE_VAR constexpr bool is_trivially_copyable_v =
+    is_trivially_copyable<T>::value;
+
 } // namespace cpp
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/__support/FPUtil/FMA.h b/src/__support/FPUtil/FMA.h
index 807d685..2cafb4c 100644
--- a/src/__support/FPUtil/FMA.h
+++ b/src/__support/FPUtil/FMA.h
@@ -24,13 +24,26 @@ LIBC_INLINE OutType fma(InType x, InType y, InType z) {
 }
 
 #ifdef LIBC_TARGET_CPU_HAS_FMA
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 template <> LIBC_INLINE float fma(float x, float y, float z) {
+#if __has_builtin(__builtin_elementwise_fma)
+  return __builtin_elementwise_fma(x, y, z);
+#else
   return __builtin_fmaf(x, y, z);
+#endif
 }
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 template <> LIBC_INLINE double fma(double x, double y, double z) {
+#if __has_builtin(__builtin_elementwise_fma)
+  return __builtin_elementwise_fma(x, y, z);
+#else
   return __builtin_fma(x, y, z);
+#endif
 }
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
 } // namespace fputil
diff --git a/src/__support/FPUtil/FPBits.h b/src/__support/FPUtil/FPBits.h
index 90b6e40..bee8d0a 100644
--- a/src/__support/FPUtil/FPBits.h
+++ b/src/__support/FPUtil/FPBits.h
@@ -247,11 +247,11 @@ protected:
     using UP::UP;
 
     LIBC_INLINE constexpr BiasedExponent(Exponent exp)
-        : UP(static_cast<int32_t>(exp) + EXP_BIAS) {}
+        : UP(static_cast<uint32_t>(static_cast<int32_t>(exp) + EXP_BIAS)) {}
 
     // Cast operator to get convert from BiasedExponent to Exponent.
     LIBC_INLINE constexpr operator Exponent() const {
-      return Exponent(UP::value - EXP_BIAS);
+      return Exponent(static_cast<int32_t>(UP::value - EXP_BIAS));
     }
 
     LIBC_INLINE constexpr BiasedExponent &operator++() {
@@ -686,7 +686,7 @@ public:
   }
 
   LIBC_INLINE constexpr void set_biased_exponent(StorageType biased) {
-    UP::set_biased_exponent(BiasedExponent((int32_t)biased));
+    UP::set_biased_exponent(BiasedExponent(static_cast<uint32_t>(biased)));
   }
 
   LIBC_INLINE constexpr int get_exponent() const {
diff --git a/src/__support/FPUtil/NormalFloat.h b/src/__support/FPUtil/NormalFloat.h
index b4cbb50..a2f285f 100644
--- a/src/__support/FPUtil/NormalFloat.h
+++ b/src/__support/FPUtil/NormalFloat.h
@@ -105,7 +105,7 @@ template <typename T> struct NormalFloat {
 
     constexpr int SUBNORMAL_EXPONENT = -FPBits<T>::EXP_BIAS + 1;
     if (exponent < SUBNORMAL_EXPONENT) {
-      unsigned shift = SUBNORMAL_EXPONENT - exponent;
+      unsigned shift = static_cast<unsigned>(SUBNORMAL_EXPONENT - exponent);
       // Since exponent > subnormalExponent, shift is strictly greater than
       // zero.
       if (shift <= FPBits<T>::FRACTION_LEN + 1) {
@@ -160,7 +160,7 @@ private:
     if (bits.is_subnormal()) {
       unsigned shift = evaluate_normalization_shift(bits.get_mantissa());
       mantissa = static_cast<StorageType>(bits.get_mantissa() << shift);
-      exponent = 1 - FPBits<T>::EXP_BIAS - shift;
+      exponent = 1 - FPBits<T>::EXP_BIAS - static_cast<int32_t>(shift);
     } else {
       exponent = bits.get_biased_exponent() - FPBits<T>::EXP_BIAS;
       mantissa = ONE | bits.get_mantissa();
diff --git a/src/__support/FPUtil/aarch64/FEnvImpl.h b/src/__support/FPUtil/aarch64/FEnvImpl.h
index 3cea977..914155a 100644
--- a/src/__support/FPUtil/aarch64/FEnvImpl.h
+++ b/src/__support/FPUtil/aarch64/FEnvImpl.h
@@ -26,7 +26,6 @@
 
 namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
-
 struct FEnv {
   struct FPState {
     uint32_t ControlWord;
@@ -42,11 +41,11 @@ struct FEnv {
   static constexpr uint32_t DOWNWARD = 0x2;
   static constexpr uint32_t TOWARDZERO = 0x3;
 
-  static constexpr uint32_t INVALID = 0x1;
-  static constexpr uint32_t DIVBYZERO = 0x2;
-  static constexpr uint32_t OVERFLOW = 0x4;
-  static constexpr uint32_t UNDERFLOW = 0x8;
-  static constexpr uint32_t INEXACT = 0x10;
+  static constexpr uint32_t INVALID_F = 0x1;
+  static constexpr uint32_t DIVBYZERO_F = 0x2;
+  static constexpr uint32_t OVERFLOW_F = 0x4;
+  static constexpr uint32_t UNDERFLOW_F = 0x8;
+  static constexpr uint32_t INEXACT_F = 0x10;
 
   // Zero-th bit is the first bit.
   static constexpr uint32_t RoundingControlBitPosition = 22;
@@ -54,19 +53,19 @@ struct FEnv {
   static constexpr uint32_t ExceptionControlFlagsBitPosition = 8;
 
   LIBC_INLINE static uint32_t getStatusValueForExcept(int excepts) {
-    return ((excepts & FE_INVALID) ? INVALID : 0) |
-           ((excepts & FE_DIVBYZERO) ? DIVBYZERO : 0) |
-           ((excepts & FE_OVERFLOW) ? OVERFLOW : 0) |
-           ((excepts & FE_UNDERFLOW) ? UNDERFLOW : 0) |
-           ((excepts & FE_INEXACT) ? INEXACT : 0);
+    return ((excepts & FE_INVALID) ? INVALID_F : 0) |
+           ((excepts & FE_DIVBYZERO) ? DIVBYZERO_F : 0) |
+           ((excepts & FE_OVERFLOW) ? OVERFLOW_F : 0) |
+           ((excepts & FE_UNDERFLOW) ? UNDERFLOW_F : 0) |
+           ((excepts & FE_INEXACT) ? INEXACT_F : 0);
   }
 
   LIBC_INLINE static int exceptionStatusToMacro(uint32_t status) {
-    return ((status & INVALID) ? FE_INVALID : 0) |
-           ((status & DIVBYZERO) ? FE_DIVBYZERO : 0) |
-           ((status & OVERFLOW) ? FE_OVERFLOW : 0) |
-           ((status & UNDERFLOW) ? FE_UNDERFLOW : 0) |
-           ((status & INEXACT) ? FE_INEXACT : 0);
+    return ((status & INVALID_F) ? FE_INVALID : 0) |
+           ((status & DIVBYZERO_F) ? FE_DIVBYZERO : 0) |
+           ((status & OVERFLOW_F) ? FE_OVERFLOW : 0) |
+           ((status & UNDERFLOW_F) ? FE_UNDERFLOW : 0) |
+           ((status & INEXACT_F) ? FE_INEXACT : 0);
   }
 
   static uint32_t getControlWord() {
@@ -111,7 +110,7 @@ LIBC_INLINE int enable_except(int excepts) {
       (controlWord >> FEnv::ExceptionControlFlagsBitPosition) & 0x1F;
   controlWord |= (newExcepts << FEnv::ExceptionControlFlagsBitPosition);
   FEnv::writeControlWord(controlWord);
-  return FEnv::exceptionStatusToMacro(oldExcepts);
+  return FEnv::exceptionStatusToMacro(static_cast<uint32_t>(oldExcepts));
 }
 
 LIBC_INLINE int disable_except(int excepts) {
@@ -121,12 +120,12 @@ LIBC_INLINE int disable_except(int excepts) {
       (controlWord >> FEnv::ExceptionControlFlagsBitPosition) & 0x1F;
   controlWord &= ~(disabledExcepts << FEnv::ExceptionControlFlagsBitPosition);
   FEnv::writeControlWord(controlWord);
-  return FEnv::exceptionStatusToMacro(oldExcepts);
+  return FEnv::exceptionStatusToMacro(static_cast<uint32_t>(oldExcepts));
 }
 
 LIBC_INLINE int get_except() {
   uint32_t controlWord = FEnv::getControlWord();
-  int enabledExcepts =
+  uint32_t enabledExcepts =
       (controlWord >> FEnv::ExceptionControlFlagsBitPosition) & 0x1F;
   return FEnv::exceptionStatusToMacro(enabledExcepts);
 }
@@ -171,36 +170,36 @@ LIBC_INLINE int raise_except(int excepts) {
   uint32_t toRaise = FEnv::getStatusValueForExcept(excepts);
   int result = 0;
 
-  if (toRaise & FEnv::INVALID) {
+  if (toRaise & FEnv::INVALID_F) {
     divfunc(zero, zero);
     uint32_t statusWord = FEnv::getStatusWord();
     if (!((statusWord >> FEnv::ExceptionStatusFlagsBitPosition) &
-          FEnv::INVALID))
+          FEnv::INVALID_F))
       result = -1;
   }
 
-  if (toRaise & FEnv::DIVBYZERO) {
+  if (toRaise & FEnv::DIVBYZERO_F) {
     divfunc(one, zero);
     uint32_t statusWord = FEnv::getStatusWord();
     if (!((statusWord >> FEnv::ExceptionStatusFlagsBitPosition) &
-          FEnv::DIVBYZERO))
+          FEnv::DIVBYZERO_F))
       result = -1;
   }
-  if (toRaise & FEnv::OVERFLOW) {
+  if (toRaise & FEnv::OVERFLOW_F) {
     divfunc(largeValue, smallValue);
     uint32_t statusWord = FEnv::getStatusWord();
     if (!((statusWord >> FEnv::ExceptionStatusFlagsBitPosition) &
-          FEnv::OVERFLOW))
+          FEnv::OVERFLOW_F))
       result = -1;
   }
-  if (toRaise & FEnv::UNDERFLOW) {
+  if (toRaise & FEnv::UNDERFLOW_F) {
     divfunc(smallValue, largeValue);
     uint32_t statusWord = FEnv::getStatusWord();
     if (!((statusWord >> FEnv::ExceptionStatusFlagsBitPosition) &
-          FEnv::UNDERFLOW))
+          FEnv::UNDERFLOW_F))
       result = -1;
   }
-  if (toRaise & FEnv::INEXACT) {
+  if (toRaise & FEnv::INEXACT_F) {
     float two = 2.0f;
     float three = 3.0f;
     // 2.0 / 3.0 cannot be represented exactly in any radix 2 floating point
@@ -208,7 +207,7 @@ LIBC_INLINE int raise_except(int excepts) {
     divfunc(two, three);
     uint32_t statusWord = FEnv::getStatusWord();
     if (!((statusWord >> FEnv::ExceptionStatusFlagsBitPosition) &
-          FEnv::INEXACT))
+          FEnv::INEXACT_F))
       result = -1;
   }
   return result;
@@ -251,8 +250,10 @@ LIBC_INLINE int set_round(int mode) {
   }
 
   uint32_t controlWord = FEnv::getControlWord();
-  controlWord &= ~(0x3 << FEnv::RoundingControlBitPosition);
-  controlWord |= (bitValue << FEnv::RoundingControlBitPosition);
+  controlWord &=
+      static_cast<uint32_t>(~(0x3 << FEnv::RoundingControlBitPosition));
+  controlWord |=
+      static_cast<uint32_t>(bitValue << FEnv::RoundingControlBitPosition);
   FEnv::writeControlWord(controlWord);
 
   return 0;
@@ -278,7 +279,6 @@ LIBC_INLINE int set_env(const fenv_t *envp) {
   FEnv::writeStatusWord(state->StatusWord);
   return 0;
 }
-
 } // namespace fputil
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/__support/FPUtil/aarch64/fenv_darwin_impl.h b/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
index 969e707..dcce76b 100644
--- a/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
+++ b/src/__support/FPUtil/aarch64/fenv_darwin_impl.h
@@ -63,7 +63,7 @@ struct FEnv {
   // __fpcr_flush_to_zero bit in the FPCR register.  This control bit is
   // located in a different place from FE_FLUSHTOZERO status bit relative to
   // the other exceptions.
-  LIBC_INLINE static uint32_t exception_value_from_status(int status) {
+  LIBC_INLINE static uint32_t exception_value_from_status(uint32_t status) {
     return ((status & FE_INVALID) ? EX_INVALID : 0) |
            ((status & FE_DIVBYZERO) ? EX_DIVBYZERO : 0) |
            ((status & FE_OVERFLOW) ? EX_OVERFLOW : 0) |
@@ -72,7 +72,7 @@ struct FEnv {
            ((status & FE_FLUSHTOZERO) ? EX_FLUSHTOZERO : 0);
   }
 
-  LIBC_INLINE static uint32_t exception_value_from_control(int control) {
+  LIBC_INLINE static uint32_t exception_value_from_control(uint32_t control) {
     return ((control & __fpcr_trap_invalid) ? EX_INVALID : 0) |
            ((control & __fpcr_trap_divbyzero) ? EX_DIVBYZERO : 0) |
            ((control & __fpcr_trap_overflow) ? EX_OVERFLOW : 0) |
@@ -81,7 +81,7 @@ struct FEnv {
            ((control & __fpcr_flush_to_zero) ? EX_FLUSHTOZERO : 0);
   }
 
-  LIBC_INLINE static int exception_value_to_status(uint32_t excepts) {
+  LIBC_INLINE static uint32_t exception_value_to_status(uint32_t excepts) {
     return ((excepts & EX_INVALID) ? FE_INVALID : 0) |
            ((excepts & EX_DIVBYZERO) ? FE_DIVBYZERO : 0) |
            ((excepts & EX_OVERFLOW) ? FE_OVERFLOW : 0) |
@@ -90,7 +90,7 @@ struct FEnv {
            ((excepts & EX_FLUSHTOZERO) ? FE_FLUSHTOZERO : 0);
   }
 
-  LIBC_INLINE static int exception_value_to_control(uint32_t excepts) {
+  LIBC_INLINE static uint32_t exception_value_to_control(uint32_t excepts) {
     return ((excepts & EX_INVALID) ? __fpcr_trap_invalid : 0) |
            ((excepts & EX_DIVBYZERO) ? __fpcr_trap_divbyzero : 0) |
            ((excepts & EX_OVERFLOW) ? __fpcr_trap_overflow : 0) |
@@ -113,34 +113,37 @@ struct FEnv {
 };
 
 LIBC_INLINE int enable_except(int excepts) {
-  uint32_t new_excepts = FEnv::exception_value_from_status(excepts);
+  uint32_t new_excepts =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
   uint32_t control_word = FEnv::get_control_word();
   uint32_t old_excepts = FEnv::exception_value_from_control(control_word);
   if (new_excepts != old_excepts) {
     control_word |= FEnv::exception_value_to_control(new_excepts);
     FEnv::set_control_word(control_word);
   }
-  return FEnv::exception_value_to_status(old_excepts);
+  return static_cast<int>(FEnv::exception_value_to_status(old_excepts));
 }
 
 LIBC_INLINE int disable_except(int excepts) {
-  uint32_t disabled_excepts = FEnv::exception_value_from_status(excepts);
+  uint32_t disabled_excepts =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
   uint32_t control_word = FEnv::get_control_word();
   uint32_t old_excepts = FEnv::exception_value_from_control(control_word);
   control_word &= ~FEnv::exception_value_to_control(disabled_excepts);
   FEnv::set_control_word(control_word);
-  return FEnv::exception_value_to_status(old_excepts);
+  return static_cast<int>(FEnv::exception_value_to_status(old_excepts));
 }
 
 LIBC_INLINE int get_except() {
   uint32_t control_word = FEnv::get_control_word();
   uint32_t enabled_excepts = FEnv::exception_value_from_control(control_word);
-  return FEnv::exception_value_to_status(enabled_excepts);
+  return static_cast<int>(FEnv::exception_value_to_status(enabled_excepts));
 }
 
 LIBC_INLINE int clear_except(int excepts) {
   uint32_t status_word = FEnv::get_status_word();
-  uint32_t except_value = FEnv::exception_value_from_status(excepts);
+  uint32_t except_value =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
   status_word &= ~FEnv::exception_value_to_status(except_value);
   FEnv::set_status_word(status_word);
   return 0;
@@ -148,13 +151,16 @@ LIBC_INLINE int clear_except(int excepts) {
 
 LIBC_INLINE int test_except(int excepts) {
   uint32_t statusWord = FEnv::get_status_word();
-  uint32_t ex_value = FEnv::exception_value_from_status(excepts);
-  return statusWord & FEnv::exception_value_to_status(ex_value);
+  uint32_t ex_value =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
+  return static_cast<int>(statusWord &
+                          FEnv::exception_value_to_status(ex_value));
 }
 
 LIBC_INLINE int set_except(int excepts) {
   uint32_t status_word = FEnv::get_status_word();
-  uint32_t new_exceptions = FEnv::exception_value_from_status(excepts);
+  uint32_t new_exceptions =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
   status_word |= FEnv::exception_value_to_status(new_exceptions);
   FEnv::set_status_word(status_word);
   return 0;
@@ -174,7 +180,8 @@ LIBC_INLINE int raise_except(int excepts) {
                          : "s0", "s1" /* s0 and s1 are clobbered */);
   };
 
-  uint32_t to_raise = FEnv::exception_value_from_status(excepts);
+  uint32_t to_raise =
+      FEnv::exception_value_from_status(static_cast<uint32_t>(excepts));
   int result = 0;
 
   if (to_raise & FEnv::EX_INVALID) {
@@ -237,7 +244,7 @@ LIBC_INLINE int get_round() {
 }
 
 LIBC_INLINE int set_round(int mode) {
-  uint16_t bit_value;
+  uint32_t bit_value;
   switch (mode) {
   case FE_TONEAREST:
     bit_value = FEnv::TONEAREST;
@@ -256,7 +263,7 @@ LIBC_INLINE int set_round(int mode) {
   }
 
   uint32_t control_word = FEnv::get_control_word();
-  control_word &= ~(0x3 << FEnv::ROUNDING_CONTROL_BIT_POSITION);
+  control_word &= ~(0x3u << FEnv::ROUNDING_CONTROL_BIT_POSITION);
   control_word |= (bit_value << FEnv::ROUNDING_CONTROL_BIT_POSITION);
   FEnv::set_control_word(control_word);
 
diff --git a/src/__support/FPUtil/double_double.h b/src/__support/FPUtil/double_double.h
index db3c2c8..c27885a 100644
--- a/src/__support/FPUtil/double_double.h
+++ b/src/__support/FPUtil/double_double.h
@@ -18,43 +18,52 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
-#define DEFAULT_DOUBLE_SPLIT 27
+template <typename T> struct DefaultSplit;
+template <> struct DefaultSplit<float> {
+  static constexpr size_t VALUE = 12;
+};
+template <> struct DefaultSplit<double> {
+  static constexpr size_t VALUE = 27;
+};
 
-using DoubleDouble = LIBC_NAMESPACE::NumberPair<double>;
+using DoubleDouble = NumberPair<double>;
+using FloatFloat = NumberPair<float>;
 
 // The output of Dekker's FastTwoSum algorithm is correct, i.e.:
 //   r.hi + r.lo = a + b exactly
 //   and |r.lo| < eps(r.lo)
 // Assumption: |a| >= |b|, or a = 0.
-template <bool FAST2SUM = true>
-LIBC_INLINE constexpr DoubleDouble exact_add(double a, double b) {
-  DoubleDouble r{0.0, 0.0};
+template <bool FAST2SUM = true, typename T = double>
+LIBC_INLINE constexpr NumberPair<T> exact_add(T a, T b) {
+  NumberPair<T> r{0.0, 0.0};
   if constexpr (FAST2SUM) {
     r.hi = a + b;
-    double t = r.hi - a;
+    T t = r.hi - a;
     r.lo = b - t;
   } else {
     r.hi = a + b;
-    double t1 = r.hi - a;
-    double t2 = r.hi - t1;
-    double t3 = b - t1;
-    double t4 = a - t2;
+    T t1 = r.hi - a;
+    T t2 = r.hi - t1;
+    T t3 = b - t1;
+    T t4 = a - t2;
     r.lo = t3 + t4;
   }
   return r;
 }
 
 // Assumption: |a.hi| >= |b.hi|
-LIBC_INLINE constexpr DoubleDouble add(const DoubleDouble &a,
-                                       const DoubleDouble &b) {
-  DoubleDouble r = exact_add(a.hi, b.hi);
-  double lo = a.lo + b.lo;
+template <typename T>
+LIBC_INLINE constexpr NumberPair<T> add(const NumberPair<T> &a,
+                                        const NumberPair<T> &b) {
+  NumberPair<T> r = exact_add(a.hi, b.hi);
+  T lo = a.lo + b.lo;
   return exact_add(r.hi, r.lo + lo);
 }
 
 // Assumption: |a.hi| >= |b|
-LIBC_INLINE constexpr DoubleDouble add(const DoubleDouble &a, double b) {
-  DoubleDouble r = exact_add<false>(a.hi, b);
+template <typename T>
+LIBC_INLINE constexpr NumberPair<T> add(const NumberPair<T> &a, T b) {
+  NumberPair<T> r = exact_add<false>(a.hi, b);
   return exact_add(r.hi, r.lo + a.lo);
 }
 
@@ -63,12 +72,12 @@ LIBC_INLINE constexpr DoubleDouble add(const DoubleDouble &a, double b) {
 //   Zimmermann, P., "Note on the Veltkamp/Dekker Algorithms with Directed
 //   Roundings," https://inria.hal.science/hal-04480440.
 // Default splitting constant = 2^ceil(prec(double)/2) + 1 = 2^27 + 1.
-template <size_t N = DEFAULT_DOUBLE_SPLIT>
-LIBC_INLINE constexpr DoubleDouble split(double a) {
-  DoubleDouble r{0.0, 0.0};
+template <typename T = double, size_t N = DefaultSplit<T>::VALUE>
+LIBC_INLINE constexpr NumberPair<T> split(T a) {
+  NumberPair<T> r{0.0, 0.0};
   // CN = 2^N.
-  constexpr double CN = static_cast<double>(1 << N);
-  constexpr double C = CN + 1.0;
+  constexpr T CN = static_cast<T>(1 << N);
+  constexpr T C = CN + 1.0;
   double t1 = C * a;
   double t2 = a - t1;
   r.hi = t1 + t2;
@@ -77,21 +86,40 @@ LIBC_INLINE constexpr DoubleDouble split(double a) {
 }
 
 // Helper for non-fma exact mult where the first number is already split.
-template <size_t SPLIT_B = DEFAULT_DOUBLE_SPLIT>
-LIBC_INLINE DoubleDouble exact_mult(const DoubleDouble &as, double a,
-                                    double b) {
-  DoubleDouble bs = split<SPLIT_B>(b);
-  DoubleDouble r{0.0, 0.0};
+template <typename T = double, size_t SPLIT_B = DefaultSplit<T>::VALUE>
+LIBC_INLINE NumberPair<T> exact_mult(const NumberPair<T> &as, T a, T b) {
+  NumberPair<T> bs = split<T, SPLIT_B>(b);
+  NumberPair<T> r{0.0, 0.0};
 
   r.hi = a * b;
-  double t1 = as.hi * bs.hi - r.hi;
-  double t2 = as.hi * bs.lo + t1;
-  double t3 = as.lo * bs.hi + t2;
+  T t1 = as.hi * bs.hi - r.hi;
+  T t2 = as.hi * bs.lo + t1;
+  T t3 = as.lo * bs.hi + t2;
   r.lo = as.lo * bs.lo + t3;
 
   return r;
 }
 
+// The templated exact multiplication needs template version of
+// LIBC_TARGET_CPU_HAS_FMA_* macro to correctly select the implementation.
+// These can be moved to "src/__support/macros/properties/cpu_features.h" if
+// other part of libc needed.
+template <typename T> struct TargetHasFmaInstruction {
+  static constexpr bool VALUE = false;
+};
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
+template <> struct TargetHasFmaInstruction<float> {
+  static constexpr bool VALUE = true;
+};
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+template <> struct TargetHasFmaInstruction<double> {
+  static constexpr bool VALUE = true;
+};
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+
 // Note: When FMA instruction is not available, the `exact_mult` function is
 // only correct for round-to-nearest mode.  See:
 //   Zimmermann, P., "Note on the Veltkamp/Dekker Algorithms with Directed
@@ -99,19 +127,19 @@ LIBC_INLINE DoubleDouble exact_mult(const DoubleDouble &as, double a,
 // Using Theorem 1 in the paper above, without FMA instruction, if we restrict
 // the generated constants to precision <= 51, and splitting it by 2^28 + 1,
 // then a * b = r.hi + r.lo is exact for all rounding modes.
-template <size_t SPLIT_B = 27>
-LIBC_INLINE DoubleDouble exact_mult(double a, double b) {
-  DoubleDouble r{0.0, 0.0};
+template <typename T = double, size_t SPLIT_B = DefaultSplit<T>::VALUE>
+LIBC_INLINE NumberPair<T> exact_mult(T a, T b) {
+  NumberPair<T> r{0.0, 0.0};
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
-  r.hi = a * b;
-  r.lo = fputil::multiply_add(a, b, -r.hi);
-#else
-  // Dekker's Product.
-  DoubleDouble as = split(a);
+  if constexpr (TargetHasFmaInstruction<T>::VALUE) {
+    r.hi = a * b;
+    r.lo = fputil::multiply_add(a, b, -r.hi);
+  } else {
+    // Dekker's Product.
+    NumberPair<T> as = split(a);
 
-  r = exact_mult<SPLIT_B>(as, a, b);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+    r = exact_mult<T, SPLIT_B>(as, a, b);
+  }
 
   return r;
 }
@@ -125,7 +153,7 @@ LIBC_INLINE DoubleDouble quick_mult(double a, const DoubleDouble &b) {
 template <size_t SPLIT_B = 27>
 LIBC_INLINE DoubleDouble quick_mult(const DoubleDouble &a,
                                     const DoubleDouble &b) {
-  DoubleDouble r = exact_mult<SPLIT_B>(a.hi, b.hi);
+  DoubleDouble r = exact_mult<double, SPLIT_B>(a.hi, b.hi);
   double t1 = multiply_add(a.hi, b.lo, r.lo);
   double t2 = multiply_add(a.lo, b.hi, t1);
   r.lo = t2;
@@ -157,19 +185,20 @@ LIBC_INLINE DoubleDouble multiply_add<DoubleDouble>(const DoubleDouble &a,
 //   rl = q * (ah - bh * rh) + q * (al - bl * rh)
 // as accurate as possible, then the error is bounded by:
 //   |(ah + al) / (bh + bl) - (rh + rl)| < O(bl/bh) * (2^-52 + al/ah + bl/bh)
-LIBC_INLINE DoubleDouble div(const DoubleDouble &a, const DoubleDouble &b) {
-  DoubleDouble r;
-  double q = 1.0 / b.hi;
+template <typename T>
+LIBC_INLINE NumberPair<T> div(const NumberPair<T> &a, const NumberPair<T> &b) {
+  NumberPair<T> r;
+  T q = T(1) / b.hi;
   r.hi = a.hi * q;
 
 #ifdef LIBC_TARGET_CPU_HAS_FMA
-  double e_hi = fputil::multiply_add(b.hi, -r.hi, a.hi);
-  double e_lo = fputil::multiply_add(b.lo, -r.hi, a.lo);
+  T e_hi = fputil::multiply_add(b.hi, -r.hi, a.hi);
+  T e_lo = fputil::multiply_add(b.lo, -r.hi, a.lo);
 #else
-  DoubleDouble b_hi_r_hi = fputil::exact_mult(b.hi, -r.hi);
-  DoubleDouble b_lo_r_hi = fputil::exact_mult(b.lo, -r.hi);
-  double e_hi = (a.hi + b_hi_r_hi.hi) + b_hi_r_hi.lo;
-  double e_lo = (a.lo + b_lo_r_hi.hi) + b_lo_r_hi.lo;
+  NumberPair<T> b_hi_r_hi = fputil::exact_mult(b.hi, -r.hi);
+  NumberPair<T> b_lo_r_hi = fputil::exact_mult(b.lo, -r.hi);
+  T e_hi = (a.hi + b_hi_r_hi.hi) + b_hi_r_hi.lo;
+  T e_lo = (a.lo + b_lo_r_hi.hi) + b_lo_r_hi.lo;
 #endif // LIBC_TARGET_CPU_HAS_FMA
 
   r.lo = q * (e_hi + e_lo);
diff --git a/src/__support/FPUtil/dyadic_float.h b/src/__support/FPUtil/dyadic_float.h
index 289fd01..5ef35de 100644
--- a/src/__support/FPUtil/dyadic_float.h
+++ b/src/__support/FPUtil/dyadic_float.h
@@ -26,6 +26,54 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
+// Decide whether to round a UInt up, down or not at all at a given bit
+// position, based on the current rounding mode. The assumption is that the
+// caller is going to make the integer `value >> rshift`, and then might need
+// to round it up by 1 depending on the value of the bits shifted off the
+// bottom.
+//
+// `logical_sign` causes the behavior of FE_DOWNWARD and FE_UPWARD to
+// be reversed, which is what you'd want if this is the mantissa of a
+// negative floating-point number.
+//
+// Return value is +1 if the value should be rounded up; -1 if it should be
+// rounded down; 0 if it's exact and needs no rounding.
+template <size_t Bits>
+LIBC_INLINE constexpr int
+rounding_direction(const LIBC_NAMESPACE::UInt<Bits> &value, size_t rshift,
+                   Sign logical_sign) {
+  if (rshift == 0 || (rshift < Bits && (value << (Bits - rshift)) == 0) ||
+      (rshift >= Bits && value == 0))
+    return 0; // exact
+
+  switch (quick_get_round()) {
+  case FE_TONEAREST:
+    if (rshift > 0 && rshift <= Bits && value.get_bit(rshift - 1)) {
+      // We round up, unless the value is an exact halfway case and
+      // the bit that will end up in the units place is 0, in which
+      // case tie-break-to-even says round down.
+      bool round_bit = rshift < Bits ? value.get_bit(rshift) : 0;
+      return round_bit != 0 || (value << (Bits - rshift + 1)) != 0 ? +1 : -1;
+    } else {
+      return -1;
+    }
+  case FE_TOWARDZERO:
+    return -1;
+  case FE_DOWNWARD:
+    return logical_sign.is_neg() &&
+                   (rshift < Bits && (value << (Bits - rshift)) != 0)
+               ? +1
+               : -1;
+  case FE_UPWARD:
+    return logical_sign.is_pos() &&
+                   (rshift < Bits && (value << (Bits - rshift)) != 0)
+               ? +1
+               : -1;
+  default:
+    __builtin_unreachable();
+  }
+}
+
 // A generic class to perform computations of high precision floating points.
 // We store the value in dyadic format, including 3 fields:
 //   sign    : boolean value - false means positive, true means negative
@@ -101,6 +149,27 @@ template <size_t Bits> struct DyadicFloat {
     return exponent + (Bits - 1);
   }
 
+  // Produce a correctly rounded DyadicFloat from a too-large mantissa,
+  // by shifting it down and rounding if necessary.
+  template <size_t MantissaBits>
+  LIBC_INLINE constexpr static DyadicFloat<Bits>
+  round(Sign result_sign, int result_exponent,
+        const LIBC_NAMESPACE::UInt<MantissaBits> &input_mantissa,
+        size_t rshift) {
+    MantissaType result_mantissa(input_mantissa >> rshift);
+    if (rounding_direction(input_mantissa, rshift, result_sign) > 0) {
+      ++result_mantissa;
+      if (result_mantissa == 0) {
+        // Rounding up made the mantissa integer wrap round to 0,
+        // carrying a bit off the top. So we've rounded up to the next
+        // exponent.
+        result_mantissa.set_bit(Bits - 1);
+        ++result_exponent;
+      }
+    }
+    return DyadicFloat(result_sign, result_exponent, result_mantissa);
+  }
+
 #ifdef LIBC_TYPES_HAS_FLOAT16
   template <typename T, bool ShouldSignalExceptions>
   LIBC_INLINE constexpr cpp::enable_if_t<
@@ -374,6 +443,43 @@ template <size_t Bits> struct DyadicFloat {
 
     return new_mant;
   }
+
+  LIBC_INLINE constexpr MantissaType
+  as_mantissa_type_rounded(int *round_dir_out = nullptr) const {
+    int round_dir = 0;
+    MantissaType new_mant;
+    if (mantissa.is_zero()) {
+      new_mant = 0;
+    } else {
+      new_mant = mantissa;
+      if (exponent > 0) {
+        new_mant <<= exponent;
+      } else if (exponent < 0) {
+        // Cast the exponent to size_t before negating it, rather than after,
+        // to avoid undefined behavior negating INT_MIN as an integer (although
+        // exponents coming in to this function _shouldn't_ be that large). The
+        // result should always end up as a positive size_t.
+        size_t shift = -static_cast<size_t>(exponent);
+        new_mant >>= shift;
+        round_dir = rounding_direction(mantissa, shift, sign);
+        if (round_dir > 0)
+          ++new_mant;
+      }
+
+      if (sign.is_neg()) {
+        new_mant = (~new_mant) + 1;
+      }
+    }
+
+    if (round_dir_out)
+      *round_dir_out = round_dir;
+
+    return new_mant;
+  }
+
+  LIBC_INLINE constexpr DyadicFloat operator-() const {
+    return DyadicFloat(sign.negate(), exponent, mantissa);
+  }
 };
 
 // Quick add - Add 2 dyadic floats with rounding toward 0 and then normalize the
@@ -433,6 +539,12 @@ LIBC_INLINE constexpr DyadicFloat<Bits> quick_add(DyadicFloat<Bits> a,
   return result.normalize();
 }
 
+template <size_t Bits>
+LIBC_INLINE constexpr DyadicFloat<Bits> quick_sub(DyadicFloat<Bits> a,
+                                                  DyadicFloat<Bits> b) {
+  return quick_add(a, -b);
+}
+
 // Quick Mul - Slightly less accurate but efficient multiplication of 2 dyadic
 // floats with rounding toward 0 and then normalize the output:
 //   result.exponent = a.exponent + b.exponent + Bits,
@@ -464,6 +576,95 @@ LIBC_INLINE constexpr DyadicFloat<Bits> quick_mul(const DyadicFloat<Bits> &a,
   return result;
 }
 
+// Correctly rounded multiplication of 2 dyadic floats, assuming the
+// exponent remains within range.
+template <size_t Bits>
+LIBC_INLINE constexpr DyadicFloat<Bits>
+rounded_mul(const DyadicFloat<Bits> &a, const DyadicFloat<Bits> &b) {
+  using DblMant = LIBC_NAMESPACE::UInt<(2 * Bits)>;
+  Sign result_sign = (a.sign != b.sign) ? Sign::NEG : Sign::POS;
+  int result_exponent = a.exponent + b.exponent + static_cast<int>(Bits);
+  auto product = DblMant(a.mantissa) * DblMant(b.mantissa);
+  // As in quick_mul(), renormalize by 1 bit manually rather than countl_zero
+  if (product.get_bit(2 * Bits - 1) == 0) {
+    product <<= 1;
+    result_exponent -= 1;
+  }
+
+  return DyadicFloat<Bits>::round(result_sign, result_exponent, product, Bits);
+}
+
+// Approximate reciprocal - given a nonzero a, make a good approximation to 1/a.
+// The method is Newton-Raphson iteration, based on quick_mul.
+template <size_t Bits, typename = cpp::enable_if_t<(Bits >= 32)>>
+LIBC_INLINE constexpr DyadicFloat<Bits>
+approx_reciprocal(const DyadicFloat<Bits> &a) {
+  // Given an approximation x to 1/a, a better one is x' = x(2-ax).
+  //
+  // You can derive this by using the Newton-Raphson formula with the function
+  // f(x) = 1/x - a. But another way to see that it works is to say: suppose
+  // that ax = 1-e for some small error e. Then ax' = ax(2-ax) = (1-e)(1+e) =
+  // 1-e^2. So the error in x' is the square of the error in x, i.e. the number
+  // of correct bits in x' is double the number in x.
+
+  // An initial approximation to the reciprocal
+  DyadicFloat<Bits> x(Sign::POS, -32 - a.exponent - int(Bits),
+                      uint64_t(0xFFFFFFFFFFFFFFFF) /
+                          static_cast<uint64_t>(a.mantissa >> (Bits - 32)));
+
+  // The constant 2, which we'll need in every iteration
+  DyadicFloat<Bits> two(Sign::POS, 1, 1);
+
+  // We expect at least 31 correct bits from our 32-bit starting approximation
+  size_t ok_bits = 31;
+
+  // The number of good bits doubles in each iteration, except that rounding
+  // errors introduce a little extra each time. Subtract a bit from our
+  // accuracy assessment to account for that.
+  while (ok_bits < Bits) {
+    x = quick_mul(x, quick_sub(two, quick_mul(a, x)));
+    ok_bits = 2 * ok_bits - 1;
+  }
+
+  return x;
+}
+
+// Correctly rounded division of 2 dyadic floats, assuming the
+// exponent remains within range.
+template <size_t Bits>
+LIBC_INLINE constexpr DyadicFloat<Bits>
+rounded_div(const DyadicFloat<Bits> &af, const DyadicFloat<Bits> &bf) {
+  using DblMant = LIBC_NAMESPACE::UInt<(Bits * 2 + 64)>;
+
+  // Make an approximation to the quotient as a * (1/b). Both the
+  // multiplication and the reciprocal are a bit sloppy, which doesn't
+  // matter, because we're going to correct for that below.
+  auto qf = fputil::quick_mul(af, fputil::approx_reciprocal(bf));
+
+  // Switch to BigInt and stop using quick_add and quick_mul: now
+  // we're working in exact integers so as to get the true remainder.
+  DblMant a = af.mantissa, b = bf.mantissa, q = qf.mantissa;
+  q <<= 2; // leave room for a round bit, even if exponent decreases
+  a <<= af.exponent - bf.exponent - qf.exponent + 2;
+  DblMant qb = q * b;
+  if (qb < a) {
+    DblMant too_small = a - b;
+    while (qb <= too_small) {
+      qb += b;
+      ++q;
+    }
+  } else {
+    while (qb > a) {
+      qb -= b;
+      --q;
+    }
+  }
+
+  DyadicFloat<(Bits * 2)> qbig(qf.sign, qf.exponent - 2, q);
+  return DyadicFloat<Bits>::round(qbig.sign, qbig.exponent + Bits,
+                                  qbig.mantissa, Bits);
+}
+
 // Simple polynomial approximation.
 template <size_t Bits>
 LIBC_INLINE constexpr DyadicFloat<Bits>
diff --git a/src/__support/FPUtil/except_value_utils.h b/src/__support/FPUtil/except_value_utils.h
index f8e4e92..5f76776 100644
--- a/src/__support/FPUtil/except_value_utils.h
+++ b/src/__support/FPUtil/except_value_utils.h
@@ -81,12 +81,19 @@ template <typename T, size_t N> struct ExceptValues {
         StorageType out_bits = values[i].rnd_towardzero_result;
         switch (fputil::quick_get_round()) {
         case FE_UPWARD:
-          out_bits += sign ? values[i].rnd_downward_offset
-                           : values[i].rnd_upward_offset;
+          if (sign)
+            out_bits += values[i].rnd_downward_offset;
+          else
+            out_bits += values[i].rnd_upward_offset;
           break;
         case FE_DOWNWARD:
-          out_bits += sign ? values[i].rnd_upward_offset
-                           : values[i].rnd_downward_offset;
+          // Use conditionals instead of ternary operator to work around gcc's
+          // -Wconversion false positive bug:
+          // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101537
+          if (sign)
+            out_bits += values[i].rnd_upward_offset;
+          else
+            out_bits += values[i].rnd_downward_offset;
           break;
         case FE_TONEAREST:
           out_bits += values[i].rnd_tonearest_offset;
diff --git a/src/__support/FPUtil/generic/add_sub.h b/src/__support/FPUtil/generic/add_sub.h
index 6bc9dcd..fda7029 100644
--- a/src/__support/FPUtil/generic/add_sub.h
+++ b/src/__support/FPUtil/generic/add_sub.h
@@ -9,7 +9,6 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_ADD_SUB_H
 #define LLVM_LIBC_SRC___SUPPORT_FPUTIL_GENERIC_ADD_SUB_H
 
-#include "hdr/errno_macros.h"
 #include "hdr/fenv_macros.h"
 #include "src/__support/CPP/algorithm.h"
 #include "src/__support/CPP/bit.h"
@@ -110,12 +109,8 @@ add_or_sub(InType x, InType y) {
       return cast<OutType>(tmp);
     }
 
-    if (y_bits.is_zero()) {
-      volatile InType tmp = y;
-      if constexpr (IsSub)
-        tmp = -tmp;
-      return cast<OutType>(tmp);
-    }
+    if (y_bits.is_zero())
+      return cast<OutType>(x);
   }
 
   InType x_abs = x_bits.abs().get_val();
@@ -160,20 +155,22 @@ add_or_sub(InType x, InType y) {
   } else {
     InStorageType max_mant = max_bits.get_explicit_mantissa() << GUARD_BITS_LEN;
     InStorageType min_mant = min_bits.get_explicit_mantissa() << GUARD_BITS_LEN;
-    int alignment =
-        max_bits.get_biased_exponent() - min_bits.get_biased_exponent();
+
+    int alignment = (max_bits.get_biased_exponent() - max_bits.is_normal()) -
+                    (min_bits.get_biased_exponent() - min_bits.is_normal());
 
     InStorageType aligned_min_mant =
         min_mant >> cpp::min(alignment, RESULT_MANTISSA_LEN);
     bool aligned_min_mant_sticky;
 
-    if (alignment <= 3)
+    if (alignment <= GUARD_BITS_LEN)
       aligned_min_mant_sticky = false;
-    else if (alignment <= InFPBits::FRACTION_LEN + 3)
-      aligned_min_mant_sticky =
-          (min_mant << (InFPBits::STORAGE_LEN - alignment)) != 0;
-    else
+    else if (alignment > InFPBits::FRACTION_LEN + GUARD_BITS_LEN)
       aligned_min_mant_sticky = true;
+    else
+      aligned_min_mant_sticky =
+          (static_cast<InStorageType>(
+              min_mant << (InFPBits::STORAGE_LEN - alignment))) != 0;
 
     InStorageType min_mant_sticky(static_cast<int>(aligned_min_mant_sticky));
 
@@ -183,7 +180,7 @@ add_or_sub(InType x, InType y) {
       result_mant = max_mant - (aligned_min_mant | min_mant_sticky);
   }
 
-  int result_exp = max_bits.get_exponent() - RESULT_FRACTION_LEN;
+  int result_exp = max_bits.get_explicit_exponent() - RESULT_FRACTION_LEN;
   DyadicFloat result(result_sign, result_exp, result_mant);
   return result.template as<OutType, /*ShouldSignalExceptions=*/true>();
 }
diff --git a/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h b/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
index 9492d52..0ba836d 100644
--- a/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
+++ b/src/__support/FPUtil/generic/sqrt_80_bit_long_double.h
@@ -24,7 +24,7 @@ namespace x86 {
 LIBC_INLINE void normalize(int &exponent,
                            FPBits<long double>::StorageType &mantissa) {
   const unsigned int shift = static_cast<unsigned int>(
-      cpp::countl_zero(static_cast<uint64_t>(mantissa)) -
+      static_cast<size_t>(cpp::countl_zero(static_cast<uint64_t>(mantissa))) -
       (8 * sizeof(uint64_t) - 1 - FPBits<long double>::FRACTION_LEN));
   exponent -= shift;
   mantissa <<= shift;
diff --git a/src/__support/FPUtil/multiply_add.h b/src/__support/FPUtil/multiply_add.h
index a86067c..8260702 100644
--- a/src/__support/FPUtil/multiply_add.h
+++ b/src/__support/FPUtil/multiply_add.h
@@ -46,13 +46,25 @@ multiply_add(T x, T y, T z) {
 namespace LIBC_NAMESPACE_DECL {
 namespace fputil {
 
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 LIBC_INLINE float multiply_add(float x, float y, float z) {
+#if __has_builtin(__builtin_elementwise_fma)
+  return __builtin_elementwise_fma(x, y, z);
+#else
   return __builtin_fmaf(x, y, z);
+#endif
 }
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 LIBC_INLINE double multiply_add(double x, double y, double z) {
+#if __has_builtin(__builtin_elementwise_fma)
+  return __builtin_elementwise_fma(x, y, z);
+#else
   return __builtin_fma(x, y, z);
+#endif
 }
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 } // namespace fputil
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/File/file.cpp b/src/__support/File/file.cpp
index 972249f..528542c 100644
--- a/src/__support/File/file.cpp
+++ b/src/__support/File/file.cpp
@@ -42,7 +42,7 @@ FileIOResult File::write_unlocked_nbf(const uint8_t *data, size_t len) {
   if (pos > 0) { // If the buffer is not empty
     // Flush the buffer
     const size_t write_size = pos;
-    auto write_result = platform_write(this, buf, write_size);
+    FileIOResult write_result = platform_write(this, buf, write_size);
     pos = 0; // Buffer is now empty so reset pos to the beginning.
     // If less bytes were written than expected, then an error occurred.
     if (write_result < write_size) {
@@ -52,7 +52,7 @@ FileIOResult File::write_unlocked_nbf(const uint8_t *data, size_t len) {
     }
   }
 
-  auto write_result = platform_write(this, data, len);
+  FileIOResult write_result = platform_write(this, data, len);
   if (write_result < len)
     err = true;
   return write_result;
@@ -99,7 +99,7 @@ FileIOResult File::write_unlocked_fbf(const uint8_t *data, size_t len) {
   // is full.
   const size_t write_size = pos;
 
-  auto buf_result = platform_write(this, buf, write_size);
+  FileIOResult buf_result = platform_write(this, buf, write_size);
   size_t bytes_written = buf_result.value;
 
   pos = 0; // Buffer is now empty so reset pos to the beginning.
@@ -121,7 +121,8 @@ FileIOResult File::write_unlocked_fbf(const uint8_t *data, size_t len) {
     pos = remainder.size();
   } else {
 
-    auto result = platform_write(this, remainder.data(), remainder.size());
+    FileIOResult result =
+        platform_write(this, remainder.data(), remainder.size());
     size_t bytes_written = buf_result.value;
 
     // If less bytes were written than expected, then an error occurred. Return
@@ -190,6 +191,17 @@ FileIOResult File::read_unlocked(void *data, size_t len) {
 
   prev_op = FileOp::READ;
 
+  if (bufmode == _IONBF) { // unbuffered.
+    return read_unlocked_nbf(static_cast<uint8_t *>(data), len);
+  } else if (bufmode == _IOFBF) { // fully buffered
+    return read_unlocked_fbf(static_cast<uint8_t *>(data), len);
+  } else /*if (bufmode == _IOLBF) */ { // line buffered
+    // There is no line buffered mode for read. Use fully buffered instead.
+    return read_unlocked_fbf(static_cast<uint8_t *>(data), len);
+  }
+}
+
+size_t File::copy_data_from_buf(uint8_t *data, size_t len) {
   cpp::span<uint8_t> bufref(static_cast<uint8_t *>(buf), bufsize);
   cpp::span<uint8_t> dataref(static_cast<uint8_t *>(data), len);
 
@@ -209,32 +221,42 @@ FileIOResult File::read_unlocked(void *data, size_t len) {
   for (size_t i = 0; i < available_data; ++i)
     dataref[i] = bufref[i + pos];
   read_limit = pos = 0; // Reset the pointers.
+
+  return available_data;
+}
+
+FileIOResult File::read_unlocked_fbf(uint8_t *data, size_t len) {
+  // Read data from the buffer first.
+  size_t available_data = copy_data_from_buf(data, len);
+  if (available_data == len)
+    return available_data;
+
   // Update the dataref to reflect that fact that we have already
   // copied |available_data| into |data|.
-  dataref = cpp::span<uint8_t>(dataref.data() + available_data,
-                               dataref.size() - available_data);
-
   size_t to_fetch = len - available_data;
+  cpp::span<uint8_t> dataref(static_cast<uint8_t *>(data) + available_data,
+                             to_fetch);
+
   if (to_fetch > bufsize) {
-    auto result = platform_read(this, dataref.data(), to_fetch);
+    FileIOResult result = platform_read(this, dataref.data(), to_fetch);
     size_t fetched_size = result.value;
     if (result.has_error() || fetched_size < to_fetch) {
       if (!result.has_error())
         eof = true;
       else
         err = true;
-      return {available_data + fetched_size, result.has_error()};
+      return {available_data + fetched_size, result.error};
     }
     return len;
   }
 
   // Fetch and buffer another buffer worth of data.
-  auto result = platform_read(this, buf, bufsize);
+  FileIOResult result = platform_read(this, buf, bufsize);
   size_t fetched_size = result.value;
   read_limit += fetched_size;
   size_t transfer_size = fetched_size >= to_fetch ? to_fetch : fetched_size;
   for (size_t i = 0; i < transfer_size; ++i)
-    dataref[i] = bufref[i];
+    dataref[i] = buf[i];
   pos += transfer_size;
   if (result.has_error() || fetched_size < to_fetch) {
     if (!result.has_error())
@@ -245,6 +267,26 @@ FileIOResult File::read_unlocked(void *data, size_t len) {
   return {transfer_size + available_data, result.error};
 }
 
+FileIOResult File::read_unlocked_nbf(uint8_t *data, size_t len) {
+  // Check whether there is a character in the ungetc buffer.
+  size_t available_data = copy_data_from_buf(data, len);
+  if (available_data == len)
+    return available_data;
+
+  // Directly copy the data into |data|.
+  cpp::span<uint8_t> dataref(static_cast<uint8_t *>(data) + available_data,
+                             len - available_data);
+  FileIOResult result = platform_read(this, dataref.data(), dataref.size());
+
+  if (result.has_error() || result < dataref.size()) {
+    if (!result.has_error())
+      eof = true;
+    else
+      err = true;
+  }
+  return {result + available_data, result.error};
+}
+
 int File::ungetc_unlocked(int c) {
   // There is no meaning to unget if:
   // 1. You are trying to push back EOF.
@@ -287,7 +329,7 @@ ErrorOr<int> File::seek(off_t offset, int whence) {
   FileLock lock(this);
   if (prev_op == FileOp::WRITE && pos > 0) {
 
-    auto buf_result = platform_write(this, buf, pos);
+    FileIOResult buf_result = platform_write(this, buf, pos);
     if (buf_result.has_error() || buf_result.value < pos) {
       err = true;
       return Error(buf_result.error);
@@ -325,7 +367,7 @@ ErrorOr<off_t> File::tell() {
 
 int File::flush_unlocked() {
   if (prev_op == FileOp::WRITE && pos > 0) {
-    auto buf_result = platform_write(this, buf, pos);
+    FileIOResult buf_result = platform_write(this, buf, pos);
     if (buf_result.has_error() || buf_result.value < pos) {
       err = true;
       return buf_result.error;
diff --git a/src/__support/File/file.h b/src/__support/File/file.h
index 42e1d11..5c97a9c 100644
--- a/src/__support/File/file.h
+++ b/src/__support/File/file.h
@@ -280,6 +280,10 @@ private:
   FileIOResult write_unlocked_fbf(const uint8_t *data, size_t len);
   FileIOResult write_unlocked_nbf(const uint8_t *data, size_t len);
 
+  FileIOResult read_unlocked_fbf(uint8_t *data, size_t len);
+  FileIOResult read_unlocked_nbf(uint8_t *data, size_t len);
+  size_t copy_data_from_buf(uint8_t *data, size_t len);
+
   constexpr void adjust_buf() {
     if (read_allowed() && (buf == nullptr || bufsize == 0)) {
       // We should allow atleast one ungetc operation.
diff --git a/src/__support/GPU/allocator.cpp b/src/__support/GPU/allocator.cpp
index f98e610..ac335a1 100644
--- a/src/__support/GPU/allocator.cpp
+++ b/src/__support/GPU/allocator.cpp
@@ -17,7 +17,7 @@ namespace {
 
 void *rpc_allocate(uint64_t size) {
   void *ptr = nullptr;
-  rpc::Client::Port port = rpc::client.open<RPC_MALLOC>();
+  rpc::Client::Port port = rpc::client.open<LIBC_MALLOC>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) { buffer->data[0] = size; },
       [&](rpc::Buffer *buffer, uint32_t) {
@@ -28,7 +28,7 @@ void *rpc_allocate(uint64_t size) {
 }
 
 void rpc_free(void *ptr) {
-  rpc::Client::Port port = rpc::client.open<RPC_FREE>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FREE>();
   port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = reinterpret_cast<uintptr_t>(ptr);
   });
diff --git a/src/__support/GPU/amdgpu/utils.h b/src/__support/GPU/amdgpu/utils.h
deleted file mode 100644
index 6ab9540..0000000
--- a/src/__support/GPU/amdgpu/utils.h
+++ /dev/null
@@ -1,183 +0,0 @@
-//===-------------- AMDGPU implementation of GPU utils ----------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_SRC___SUPPORT_GPU_AMDGPU_IO_H
-#define LLVM_LIBC_SRC___SUPPORT_GPU_AMDGPU_IO_H
-
-#include "src/__support/common.h"
-#include "src/__support/macros/config.h"
-
-#include <stdint.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace gpu {
-
-/// Type aliases to the address spaces used by the AMDGPU backend.
-template <typename T> using Private = [[clang::opencl_private]] T;
-template <typename T> using Constant = [[clang::opencl_constant]] T;
-template <typename T> using Local = [[clang::opencl_local]] T;
-template <typename T> using Global = [[clang::opencl_global]] T;
-
-/// Returns the number of workgroups in the 'x' dimension of the grid.
-LIBC_INLINE uint32_t get_num_blocks_x() {
-  return __builtin_amdgcn_grid_size_x() / __builtin_amdgcn_workgroup_size_x();
-}
-
-/// Returns the number of workgroups in the 'y' dimension of the grid.
-LIBC_INLINE uint32_t get_num_blocks_y() {
-  return __builtin_amdgcn_grid_size_y() / __builtin_amdgcn_workgroup_size_y();
-}
-
-/// Returns the number of workgroups in the 'z' dimension of the grid.
-LIBC_INLINE uint32_t get_num_blocks_z() {
-  return __builtin_amdgcn_grid_size_z() / __builtin_amdgcn_workgroup_size_z();
-}
-
-/// Returns the total number of workgruops in the grid.
-LIBC_INLINE uint64_t get_num_blocks() {
-  return get_num_blocks_x() * get_num_blocks_y() * get_num_blocks_z();
-}
-
-/// Returns the 'x' dimension of the current AMD workgroup's id.
-LIBC_INLINE uint32_t get_block_id_x() {
-  return __builtin_amdgcn_workgroup_id_x();
-}
-
-/// Returns the 'y' dimension of the current AMD workgroup's id.
-LIBC_INLINE uint32_t get_block_id_y() {
-  return __builtin_amdgcn_workgroup_id_y();
-}
-
-/// Returns the 'z' dimension of the current AMD workgroup's id.
-LIBC_INLINE uint32_t get_block_id_z() {
-  return __builtin_amdgcn_workgroup_id_z();
-}
-
-/// Returns the absolute id of the AMD workgroup.
-LIBC_INLINE uint64_t get_block_id() {
-  return get_block_id_x() + get_num_blocks_x() * get_block_id_y() +
-         get_num_blocks_x() * get_num_blocks_y() * get_block_id_z();
-}
-
-/// Returns the number of workitems in the 'x' dimension.
-LIBC_INLINE uint32_t get_num_threads_x() {
-  return __builtin_amdgcn_workgroup_size_x();
-}
-
-/// Returns the number of workitems in the 'y' dimension.
-LIBC_INLINE uint32_t get_num_threads_y() {
-  return __builtin_amdgcn_workgroup_size_y();
-}
-
-/// Returns the number of workitems in the 'z' dimension.
-LIBC_INLINE uint32_t get_num_threads_z() {
-  return __builtin_amdgcn_workgroup_size_z();
-}
-
-/// Returns the total number of workitems in the workgroup.
-LIBC_INLINE uint64_t get_num_threads() {
-  return get_num_threads_x() * get_num_threads_y() * get_num_threads_z();
-}
-
-/// Returns the 'x' dimension id of the workitem in the current AMD workgroup.
-LIBC_INLINE uint32_t get_thread_id_x() {
-  return __builtin_amdgcn_workitem_id_x();
-}
-
-/// Returns the 'y' dimension id of the workitem in the current AMD workgroup.
-LIBC_INLINE uint32_t get_thread_id_y() {
-  return __builtin_amdgcn_workitem_id_y();
-}
-
-/// Returns the 'z' dimension id of the workitem in the current AMD workgroup.
-LIBC_INLINE uint32_t get_thread_id_z() {
-  return __builtin_amdgcn_workitem_id_z();
-}
-
-/// Returns the absolute id of the thread in the current AMD workgroup.
-LIBC_INLINE uint64_t get_thread_id() {
-  return get_thread_id_x() + get_num_threads_x() * get_thread_id_y() +
-         get_num_threads_x() * get_num_threads_y() * get_thread_id_z();
-}
-
-/// Returns the size of an AMD wavefront, either 32 or 64 depending on hardware
-/// and compilation options.
-LIBC_INLINE uint32_t get_lane_size() {
-  return __builtin_amdgcn_wavefrontsize();
-}
-
-/// Returns the id of the thread inside of an AMD wavefront executing together.
-[[clang::convergent]] LIBC_INLINE uint32_t get_lane_id() {
-  return __builtin_amdgcn_mbcnt_hi(~0u, __builtin_amdgcn_mbcnt_lo(~0u, 0u));
-}
-
-/// Returns the bit-mask of active threads in the current wavefront.
-[[clang::convergent]] LIBC_INLINE uint64_t get_lane_mask() {
-  return __builtin_amdgcn_read_exec();
-}
-
-/// Copies the value from the first active thread in the wavefront to the rest.
-[[clang::convergent]] LIBC_INLINE uint32_t broadcast_value(uint64_t,
-                                                           uint32_t x) {
-  return __builtin_amdgcn_readfirstlane(x);
-}
-
-/// Returns a bitmask of threads in the current lane for which \p x is true.
-[[clang::convergent]] LIBC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
-  // the lane_mask & gives the nvptx semantics when lane_mask is a subset of
-  // the active threads
-  return lane_mask & __builtin_amdgcn_ballot_w64(x);
-}
-
-/// Waits for all the threads in the block to converge and issues a fence.
-[[clang::convergent]] LIBC_INLINE void sync_threads() {
-  __builtin_amdgcn_s_barrier();
-  __builtin_amdgcn_fence(__ATOMIC_ACQUIRE, "workgroup");
-}
-
-/// Waits for all pending memory operations to complete in program order.
-[[clang::convergent]] LIBC_INLINE void memory_fence() {
-  __builtin_amdgcn_fence(__ATOMIC_ACQ_REL, "");
-}
-
-/// Wait for all threads in the wavefront to converge, this is a noop on AMDGPU.
-[[clang::convergent]] LIBC_INLINE void sync_lane(uint64_t) {
-  __builtin_amdgcn_wave_barrier();
-}
-
-/// Shuffles the the lanes inside the wavefront according to the given index.
-[[clang::convergent]] LIBC_INLINE uint32_t shuffle(uint64_t, uint32_t idx,
-                                                   uint32_t x) {
-  return __builtin_amdgcn_ds_bpermute(idx << 2, x);
-}
-
-/// Returns the current value of the GPU's processor clock.
-/// NOTE: The RDNA3 and RDNA2 architectures use a 20-bit cycle counter.
-LIBC_INLINE uint64_t processor_clock() { return __builtin_readcyclecounter(); }
-
-/// Returns a fixed-frequency timestamp. The actual frequency is dependent on
-/// the card and can only be queried via the driver.
-LIBC_INLINE uint64_t fixed_frequency_clock() {
-  return __builtin_readsteadycounter();
-}
-
-/// Terminates execution of the associated wavefront.
-[[noreturn]] LIBC_INLINE void end_program() { __builtin_amdgcn_endpgm(); }
-
-/// Returns a unique identifier for the process cluster the current wavefront is
-/// executing on. Here we use the identifier for the compute unit (CU) and
-/// shader engine.
-/// FIXME: Currently unimplemented on AMDGPU until we have a simpler interface
-/// than the one at
-/// https://github.com/ROCm/clr/blob/develop/hipamd/include/hip/amd_detail/amd_device_functions.h#L899
-LIBC_INLINE uint32_t get_cluster_id() { return 0; }
-
-} // namespace gpu
-} // namespace LIBC_NAMESPACE_DECL
-
-#endif
diff --git a/src/__support/GPU/generic/utils.h b/src/__support/GPU/generic/utils.h
deleted file mode 100644
index 9461ef0..0000000
--- a/src/__support/GPU/generic/utils.h
+++ /dev/null
@@ -1,84 +0,0 @@
-//===-------------- Generic implementation of GPU utils ---------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_SRC___SUPPORT_GPU_GENERIC_UTILS_H
-#define LLVM_LIBC_SRC___SUPPORT_GPU_GENERIC_UTILS_H
-
-#include "src/__support/common.h"
-#include "src/__support/macros/config.h"
-
-#include <stdint.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace gpu {
-
-template <typename T> using Private = T;
-template <typename T> using Constant = T;
-template <typename T> using Shared = T;
-template <typename T> using Global = T;
-
-LIBC_INLINE uint32_t get_num_blocks_x() { return 1; }
-
-LIBC_INLINE uint32_t get_num_blocks_y() { return 1; }
-
-LIBC_INLINE uint32_t get_num_blocks_z() { return 1; }
-
-LIBC_INLINE uint64_t get_num_blocks() { return 1; }
-
-LIBC_INLINE uint32_t get_block_id_x() { return 0; }
-
-LIBC_INLINE uint32_t get_block_id_y() { return 0; }
-
-LIBC_INLINE uint32_t get_block_id_z() { return 0; }
-
-LIBC_INLINE uint64_t get_block_id() { return 0; }
-
-LIBC_INLINE uint32_t get_num_threads_x() { return 1; }
-
-LIBC_INLINE uint32_t get_num_threads_y() { return 1; }
-
-LIBC_INLINE uint32_t get_num_threads_z() { return 1; }
-
-LIBC_INLINE uint64_t get_num_threads() { return 1; }
-
-LIBC_INLINE uint32_t get_thread_id_x() { return 0; }
-
-LIBC_INLINE uint32_t get_thread_id_y() { return 0; }
-
-LIBC_INLINE uint32_t get_thread_id_z() { return 0; }
-
-LIBC_INLINE uint64_t get_thread_id() { return 0; }
-
-LIBC_INLINE uint32_t get_lane_size() { return 1; }
-
-LIBC_INLINE uint32_t get_lane_id() { return 0; }
-
-LIBC_INLINE uint64_t get_lane_mask() { return 1; }
-
-LIBC_INLINE uint32_t broadcast_value(uint64_t, uint32_t x) { return x; }
-
-LIBC_INLINE uint64_t ballot(uint64_t, bool x) { return x; }
-
-LIBC_INLINE void sync_threads() {}
-
-LIBC_INLINE void sync_lane(uint64_t) {}
-
-LIBC_INLINE uint32_t shuffle(uint64_t, uint32_t, uint32_t x) { return x; }
-
-LIBC_INLINE uint64_t processor_clock() { return 0; }
-
-LIBC_INLINE uint64_t fixed_frequency_clock() { return 0; }
-
-[[noreturn]] LIBC_INLINE void end_program() { __builtin_unreachable(); }
-
-LIBC_INLINE uint32_t get_cluster_id() { return 0; }
-
-} // namespace gpu
-} // namespace LIBC_NAMESPACE_DECL
-
-#endif // LLVM_LIBC_SRC___SUPPORT_GPU_GENERIC_UTILS_H
diff --git a/src/__support/GPU/nvptx/utils.h b/src/__support/GPU/nvptx/utils.h
deleted file mode 100644
index 1a43a83..0000000
--- a/src/__support/GPU/nvptx/utils.h
+++ /dev/null
@@ -1,160 +0,0 @@
-//===-------------- NVPTX implementation of GPU utils -----------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-id: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIBC_SRC___SUPPORT_GPU_NVPTX_IO_H
-#define LLVM_LIBC_SRC___SUPPORT_GPU_NVPTX_IO_H
-
-#include "src/__support/common.h"
-#include "src/__support/macros/config.h"
-
-#include <stdint.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace gpu {
-
-/// Type aliases to the address spaces used by the NVPTX backend.
-template <typename T> using Private = [[clang::opencl_private]] T;
-template <typename T> using Constant = [[clang::opencl_constant]] T;
-template <typename T> using Local = [[clang::opencl_local]] T;
-template <typename T> using Global = [[clang::opencl_global]] T;
-
-/// Returns the number of CUDA blocks in the 'x' dimension.
-LIBC_INLINE uint32_t get_num_blocks_x() {
-  return __nvvm_read_ptx_sreg_nctaid_x();
-}
-
-/// Returns the number of CUDA blocks in the 'y' dimension.
-LIBC_INLINE uint32_t get_num_blocks_y() {
-  return __nvvm_read_ptx_sreg_nctaid_y();
-}
-
-/// Returns the number of CUDA blocks in the 'z' dimension.
-LIBC_INLINE uint32_t get_num_blocks_z() {
-  return __nvvm_read_ptx_sreg_nctaid_z();
-}
-
-/// Returns the total number of CUDA blocks.
-LIBC_INLINE uint64_t get_num_blocks() {
-  return get_num_blocks_x() * get_num_blocks_y() * get_num_blocks_z();
-}
-
-/// Returns the 'x' dimension of the current CUDA block's id.
-LIBC_INLINE uint32_t get_block_id_x() { return __nvvm_read_ptx_sreg_ctaid_x(); }
-
-/// Returns the 'y' dimension of the current CUDA block's id.
-LIBC_INLINE uint32_t get_block_id_y() { return __nvvm_read_ptx_sreg_ctaid_y(); }
-
-/// Returns the 'z' dimension of the current CUDA block's id.
-LIBC_INLINE uint32_t get_block_id_z() { return __nvvm_read_ptx_sreg_ctaid_z(); }
-
-/// Returns the absolute id of the CUDA block.
-LIBC_INLINE uint64_t get_block_id() {
-  return get_block_id_x() + get_num_blocks_x() * get_block_id_y() +
-         get_num_blocks_x() * get_num_blocks_y() * get_block_id_z();
-}
-
-/// Returns the number of CUDA threads in the 'x' dimension.
-LIBC_INLINE uint32_t get_num_threads_x() {
-  return __nvvm_read_ptx_sreg_ntid_x();
-}
-
-/// Returns the number of CUDA threads in the 'y' dimension.
-LIBC_INLINE uint32_t get_num_threads_y() {
-  return __nvvm_read_ptx_sreg_ntid_y();
-}
-
-/// Returns the number of CUDA threads in the 'z' dimension.
-LIBC_INLINE uint32_t get_num_threads_z() {
-  return __nvvm_read_ptx_sreg_ntid_z();
-}
-
-/// Returns the total number of threads in the block.
-LIBC_INLINE uint64_t get_num_threads() {
-  return get_num_threads_x() * get_num_threads_y() * get_num_threads_z();
-}
-
-/// Returns the 'x' dimension id of the thread in the current CUDA block.
-LIBC_INLINE uint32_t get_thread_id_x() { return __nvvm_read_ptx_sreg_tid_x(); }
-
-/// Returns the 'y' dimension id of the thread in the current CUDA block.
-LIBC_INLINE uint32_t get_thread_id_y() { return __nvvm_read_ptx_sreg_tid_y(); }
-
-/// Returns the 'z' dimension id of the thread in the current CUDA block.
-LIBC_INLINE uint32_t get_thread_id_z() { return __nvvm_read_ptx_sreg_tid_z(); }
-
-/// Returns the absolute id of the thread in the current CUDA block.
-LIBC_INLINE uint64_t get_thread_id() {
-  return get_thread_id_x() + get_num_threads_x() * get_thread_id_y() +
-         get_num_threads_x() * get_num_threads_y() * get_thread_id_z();
-}
-
-/// Returns the size of a CUDA warp, always 32 on NVIDIA hardware.
-LIBC_INLINE uint32_t get_lane_size() { return 32; }
-
-/// Returns the id of the thread inside of a CUDA warp executing together.
-[[clang::convergent]] LIBC_INLINE uint32_t get_lane_id() {
-  return __nvvm_read_ptx_sreg_laneid();
-}
-
-/// Returns the bit-mask of active threads in the current warp.
-[[clang::convergent]] LIBC_INLINE uint64_t get_lane_mask() {
-  return __nvvm_activemask();
-}
-
-/// Copies the value from the first active thread in the warp to the rest.
-[[clang::convergent]] LIBC_INLINE uint32_t broadcast_value(uint64_t lane_mask,
-                                                           uint32_t x) {
-  uint32_t mask = static_cast<uint32_t>(lane_mask);
-  uint32_t id = __builtin_ffs(mask) - 1;
-  return __nvvm_shfl_sync_idx_i32(mask, x, id, get_lane_size() - 1);
-}
-
-/// Returns a bitmask of threads in the current lane for which \p x is true.
-[[clang::convergent]] LIBC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
-  uint32_t mask = static_cast<uint32_t>(lane_mask);
-  return __nvvm_vote_ballot_sync(mask, x);
-}
-
-/// Waits for all the threads in the block to converge and issues a fence.
-[[clang::convergent]] LIBC_INLINE void sync_threads() { __syncthreads(); }
-
-/// Waits for all pending memory operations to complete in program order.
-[[clang::convergent]] LIBC_INLINE void memory_fence() { __nvvm_membar_sys(); }
-
-/// Waits for all threads in the warp to reconverge for independent scheduling.
-[[clang::convergent]] LIBC_INLINE void sync_lane(uint64_t mask) {
-  __nvvm_bar_warp_sync(static_cast<uint32_t>(mask));
-}
-
-/// Shuffles the the lanes inside the warp according to the given index.
-[[clang::convergent]] LIBC_INLINE uint32_t shuffle(uint64_t lane_mask,
-                                                   uint32_t idx, uint32_t x) {
-  uint32_t mask = static_cast<uint32_t>(lane_mask);
-  uint32_t bitmask = (mask >> idx) & 1;
-  return -bitmask & __nvvm_shfl_sync_idx_i32(mask, x, idx, get_lane_size() - 1);
-}
-
-/// Returns the current value of the GPU's processor clock.
-LIBC_INLINE uint64_t processor_clock() { return __builtin_readcyclecounter(); }
-
-/// Returns a global fixed-frequency timer at nanosecond frequency.
-LIBC_INLINE uint64_t fixed_frequency_clock() {
-  return __builtin_readsteadycounter();
-}
-
-/// Terminates execution of the calling thread.
-[[noreturn]] LIBC_INLINE void end_program() { __nvvm_exit(); }
-
-/// Returns a unique identifier for the process cluster the current warp is
-/// executing on. Here we use the identifier for the symmetric multiprocessor.
-LIBC_INLINE uint32_t get_cluster_id() { return __nvvm_read_ptx_sreg_smid(); }
-
-} // namespace gpu
-} // namespace LIBC_NAMESPACE_DECL
-
-#endif
diff --git a/src/__support/GPU/utils.h b/src/__support/GPU/utils.h
index ae52e7a..0fd3a64 100644
--- a/src/__support/GPU/utils.h
+++ b/src/__support/GPU/utils.h
@@ -9,48 +9,117 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_GPU_UTILS_H
 #define LLVM_LIBC_SRC___SUPPORT_GPU_UTILS_H
 
+#include "src/__support/macros/attributes.h"
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/architectures.h"
 
-#if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
-#include "amdgpu/utils.h"
-#elif defined(LIBC_TARGET_ARCH_IS_NVPTX)
-#include "nvptx/utils.h"
-#else
-#include "generic/utils.h"
+#if !__has_include(<gpuintrin.h>)
+#error "Unsupported compiler"
 #endif
 
+#include <gpuintrin.h>
+
 namespace LIBC_NAMESPACE_DECL {
 namespace gpu {
-/// Get the first active thread inside the lane.
-LIBC_INLINE uint64_t get_first_lane_id(uint64_t lane_mask) {
-  return __builtin_ffsll(lane_mask) - 1;
+
+template <typename T> using Private = __gpu_private T;
+template <typename T> using Constant = __gpu_constant T;
+template <typename T> using Local = __gpu_local T;
+template <typename T> using Global = __gpu_local T;
+
+LIBC_INLINE uint32_t get_num_blocks_x() { return __gpu_num_blocks(0); }
+
+LIBC_INLINE uint32_t get_num_blocks_y() { return __gpu_num_blocks(1); }
+
+LIBC_INLINE uint32_t get_num_blocks_z() { return __gpu_num_blocks(2); }
+
+LIBC_INLINE uint64_t get_num_blocks() {
+  return get_num_blocks_x() * get_num_blocks_y() * get_num_blocks_z();
+}
+
+LIBC_INLINE uint32_t get_block_id_x() { return __gpu_block_id(0); }
+
+LIBC_INLINE uint32_t get_block_id_y() { return __gpu_block_id(1); }
+
+LIBC_INLINE uint32_t get_block_id_z() { return __gpu_block_id(2); }
+
+LIBC_INLINE uint64_t get_block_id() {
+  return get_block_id_x() + get_num_blocks_x() * get_block_id_y() +
+         get_num_blocks_x() * get_num_blocks_y() * get_block_id_z();
+}
+
+LIBC_INLINE uint32_t get_num_threads_x() { return __gpu_num_threads(0); }
+
+LIBC_INLINE uint32_t get_num_threads_y() { return __gpu_num_threads(1); }
+
+LIBC_INLINE uint32_t get_num_threads_z() { return __gpu_num_threads(2); }
+
+LIBC_INLINE uint64_t get_num_threads() {
+  return get_num_threads_x() * get_num_threads_y() * get_num_threads_z();
+}
+
+LIBC_INLINE uint32_t get_thread_id_x() { return __gpu_thread_id(0); }
+
+LIBC_INLINE uint32_t get_thread_id_y() { return __gpu_thread_id(1); }
+
+LIBC_INLINE uint32_t get_thread_id_z() { return __gpu_thread_id(2); }
+
+LIBC_INLINE uint64_t get_thread_id() {
+  return get_thread_id_x() + get_num_threads_x() * get_thread_id_y() +
+         get_num_threads_x() * get_num_threads_y() * get_thread_id_z();
+}
+
+LIBC_INLINE uint32_t get_lane_size() { return __gpu_num_lanes(); }
+
+LIBC_INLINE uint32_t get_lane_id() { return __gpu_lane_id(); }
+
+LIBC_INLINE uint64_t get_lane_mask() { return __gpu_lane_mask(); }
+
+LIBC_INLINE uint32_t broadcast_value(uint64_t lane_mask, uint32_t x) {
+  return __gpu_read_first_lane_u32(lane_mask, x);
+}
+
+LIBC_INLINE uint64_t ballot(uint64_t lane_mask, bool x) {
+  return __gpu_ballot(lane_mask, x);
+}
+
+LIBC_INLINE void sync_threads() { __gpu_sync_threads(); }
+
+LIBC_INLINE void sync_lane(uint64_t lane_mask) { __gpu_sync_lane(lane_mask); }
+
+LIBC_INLINE uint32_t shuffle(uint64_t lane_mask, uint32_t idx, uint32_t x,
+                             uint32_t width = __gpu_num_lanes()) {
+  return __gpu_shuffle_idx_u32(lane_mask, idx, x, width);
+}
+
+LIBC_INLINE uint64_t match_any(uint64_t lane_mask, uint32_t x) {
+  return __gpu_match_any_u32(lane_mask, x);
+}
+
+LIBC_INLINE uint64_t match_all(uint64_t lane_mask, uint32_t x) {
+  return __gpu_match_all_u32(lane_mask, x);
 }
 
-/// Conditional that is only true for a single thread in a lane.
+[[noreturn]] LIBC_INLINE void end_program() { __gpu_exit(); }
+
 LIBC_INLINE bool is_first_lane(uint64_t lane_mask) {
-  return gpu::get_lane_id() == get_first_lane_id(lane_mask);
+  return __gpu_is_first_in_lane(lane_mask);
 }
 
-/// Gets the sum of all lanes inside the warp or wavefront.
 LIBC_INLINE uint32_t reduce(uint64_t lane_mask, uint32_t x) {
-  for (uint32_t step = gpu::get_lane_size() / 2; step > 0; step /= 2) {
-    uint32_t index = step + gpu::get_lane_id();
-    x += gpu::shuffle(lane_mask, index, x);
-  }
-  return gpu::broadcast_value(lane_mask, x);
+  return __gpu_lane_sum_u32(lane_mask, x);
 }
 
-/// Gets the accumulator scan of the threads in the warp or wavefront.
 LIBC_INLINE uint32_t scan(uint64_t lane_mask, uint32_t x) {
-  for (uint32_t step = 1; step < gpu::get_lane_size(); step *= 2) {
-    uint32_t index = gpu::get_lane_id() - step;
-    uint32_t bitmask = gpu::get_lane_id() >= step;
-    x += -bitmask & gpu::shuffle(lane_mask, index, x);
-  }
-  return x;
+  return __gpu_lane_scan_u32(lane_mask, x);
 }
 
+LIBC_INLINE uint64_t fixed_frequency_clock() {
+  return __builtin_readsteadycounter();
+}
+
+LIBC_INLINE uint64_t processor_clock() { return __builtin_readcyclecounter(); }
+
 } // namespace gpu
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/__support/OSUtil/darwin/io.h b/src/__support/OSUtil/darwin/io.h
index a5f7ecb..69df99d 100644
--- a/src/__support/OSUtil/darwin/io.h
+++ b/src/__support/OSUtil/darwin/io.h
@@ -17,7 +17,8 @@ namespace LIBC_NAMESPACE_DECL {
 
 LIBC_INLINE void write_to_stderr(cpp::string_view msg) {
   LIBC_NAMESPACE::syscall_impl(4 /*SYS_write*/, 2 /* stderr */,
-                               reinterpret_cast<long>(msg.data()), msg.size());
+                               reinterpret_cast<long>(msg.data()),
+                               static_cast<long>(msg.size()));
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/gpu/exit.cpp b/src/__support/OSUtil/gpu/exit.cpp
index 0cb266a..85f8183 100644
--- a/src/__support/OSUtil/gpu/exit.cpp
+++ b/src/__support/OSUtil/gpu/exit.cpp
@@ -18,7 +18,7 @@ namespace internal {
 
 [[noreturn]] void exit(int status) {
   // We want to first make sure the server is listening before we exit.
-  rpc::Client::Port port = rpc::client.open<RPC_EXIT>();
+  rpc::Client::Port port = rpc::client.open<LIBC_EXIT>();
   port.send_and_recv([](rpc::Buffer *, uint32_t) {},
                      [](rpc::Buffer *, uint32_t) {});
   port.send([&](rpc::Buffer *buffer, uint32_t) {
diff --git a/src/__support/OSUtil/gpu/io.cpp b/src/__support/OSUtil/gpu/io.cpp
index f70c2e7..5d107ab 100644
--- a/src/__support/OSUtil/gpu/io.cpp
+++ b/src/__support/OSUtil/gpu/io.cpp
@@ -15,7 +15,7 @@
 namespace LIBC_NAMESPACE_DECL {
 
 void write_to_stderr(cpp::string_view msg) {
-  rpc::Client::Port port = rpc::client.open<RPC_WRITE_TO_STDERR>();
+  rpc::Client::Port port = rpc::client.open<LIBC_WRITE_TO_STDERR>();
   port.send_n(msg.data(), msg.size());
   port.recv([](rpc::Buffer *, uint32_t) { /* void */ });
   port.close();
diff --git a/src/__support/OSUtil/io.h b/src/__support/OSUtil/io.h
index 80119da..66af31f 100644
--- a/src/__support/OSUtil/io.h
+++ b/src/__support/OSUtil/io.h
@@ -24,6 +24,8 @@
 #elif defined(__ELF__)
 // TODO: Ideally we would have LIBC_TARGET_OS_IS_BAREMETAL.
 #include "baremetal/io.h"
+#elif defined(__UEFI__)
+#include "uefi/io.h"
 #endif
 
 #endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_IO_H
diff --git a/src/__support/OSUtil/linux/exit.cpp b/src/__support/OSUtil/linux/exit.cpp
index 9c64ce4..e26b90f 100644
--- a/src/__support/OSUtil/linux/exit.cpp
+++ b/src/__support/OSUtil/linux/exit.cpp
@@ -6,9 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/OSUtil/linux/syscall.h" // syscall_impl
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "syscall.h"     // For internal syscall function.
 #include <sys/syscall.h> // For syscall numbers.
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/__support/OSUtil/uefi/exit.cpp b/src/__support/OSUtil/uefi/exit.cpp
new file mode 100644
index 0000000..432f69a
--- /dev/null
+++ b/src/__support/OSUtil/uefi/exit.cpp
@@ -0,0 +1,22 @@
+//===-------- UEFI implementation of an exit function ------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===-----------------------------------------------------------------===//
+
+#include "src/__support/OSUtil/exit.h"
+#include "include/Uefi.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+[[noreturn]] void exit(int status) {
+  efi_system_table->BootServices->Exit(efi_image_handle, status, 0, nullptr);
+  __builtin_unreachable();
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/uefi/io.cpp b/src/__support/OSUtil/uefi/io.cpp
new file mode 100644
index 0000000..756c5aa
--- /dev/null
+++ b/src/__support/OSUtil/uefi/io.cpp
@@ -0,0 +1,36 @@
+//===---------- UEFI implementation of IO utils ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===-----------------------------------------------------------------===//
+
+#include "io.h"
+
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t read_from_stdin(char *buf, size_t size) { return 0; }
+
+void write_to_stdout(cpp::string_view msg) {
+  // TODO: use mbstowcs once implemented
+  for (size_t i = 0; i < msg.size(); i++) {
+    char16_t e[2] = {msg[i], 0};
+    efi_system_table->ConOut->OutputString(
+        efi_system_table->ConOut, reinterpret_cast<const char16_t *>(&e));
+  }
+}
+
+void write_to_stderr(cpp::string_view msg) {
+  // TODO: use mbstowcs once implemented
+  for (size_t i = 0; i < msg.size(); i++) {
+    char16_t e[2] = {msg[i], 0};
+    efi_system_table->StdErr->OutputString(
+        efi_system_table->StdErr, reinterpret_cast<const char16_t *>(&e));
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/OSUtil/uefi/io.h b/src/__support/OSUtil/uefi/io.h
new file mode 100644
index 0000000..088ae09
--- /dev/null
+++ b/src/__support/OSUtil/uefi/io.h
@@ -0,0 +1,25 @@
+//===---------- UEFI implementation of IO utils ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===-----------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_OSUTIL_UEFI_IO_H
+#define LLVM_LIBC_SRC___SUPPORT_OSUTIL_UEFI_IO_H
+
+#include "include/llvm-libc-types/size_t.h"
+#include "include/llvm-libc-types/ssize_t.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t read_from_stdin(char *buf, size_t size);
+void write_to_stderr(cpp::string_view msg);
+void write_to_stdout(cpp::string_view msg);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_OSUTIL_UEFI_IO_H
diff --git a/src/__support/RPC/rpc_server.h b/src/__support/RPC/rpc_server.h
new file mode 100644
index 0000000..dc3d803
--- /dev/null
+++ b/src/__support/RPC/rpc_server.h
@@ -0,0 +1,551 @@
+//===-- Shared memory RPC server instantiation ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is intended to be used externally as part of the `shared/`
+// interface. For that purpose, we manually define a few options normally
+// handled by the libc build system.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_RPC_RPC_SERVER_H
+#define LLVM_LIBC_SRC___SUPPORT_RPC_RPC_SERVER_H
+
+// Workaround for missing __has_builtin in < GCC 10.
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+// Workaround for missing __builtin_is_constant_evaluated in < GCC 10.
+#ifndef __builtin_is_constant_evaluated
+#define __builtin_is_constant_evaluated(x) 0
+#endif
+
+// Configs for using the LLVM libc writer interface.
+#define LIBC_COPT_USE_C_ASSERT
+#define LIBC_COPT_MEMCPY_USE_EMBEDDED_TINY
+#define LIBC_COPT_ARRAY_ARG_LIST
+#define LIBC_COPT_PRINTF_DISABLE_WRITE_INT
+#define LIBC_COPT_PRINTF_DISABLE_INDEX_MODE
+#define LIBC_COPT_PRINTF_DISABLE_STRERROR
+
+// The 'long double' type is 8 bytes.
+#define LIBC_TYPES_LONG_DOUBLE_IS_FLOAT64
+
+#include "shared/rpc.h"
+#include "shared/rpc_opcodes.h"
+
+#include "src/__support/arg_list.h"
+#include "src/stdio/printf_core/converter.h"
+#include "src/stdio/printf_core/parser.h"
+#include "src/stdio/printf_core/writer.h"
+
+#include "hdr/stdio_overlay.h"
+#include "hdr/stdlib_overlay.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+// Minimal replacement for 'std::vector' that works for trivial types.
+template <typename T> class TempVector {
+  static_assert(cpp::is_trivially_constructible<T>::value &&
+                    cpp::is_trivially_destructible<T>::value,
+                "Not a trivial type.");
+  T *data;
+  size_t current;
+  size_t capacity;
+
+public:
+  LIBC_INLINE TempVector() : data(nullptr), current(0), capacity(0) {}
+
+  LIBC_INLINE ~TempVector() { free(data); }
+
+  LIBC_INLINE void push_back(const T &value) {
+    if (current == capacity)
+      grow();
+    data[current] = T(value);
+    ++current;
+  }
+
+  LIBC_INLINE void push_back(T &&value) {
+    if (current == capacity)
+      grow();
+    data[current] = T(static_cast<T &&>(value));
+    ++current;
+  }
+
+  LIBC_INLINE void pop_back() { --current; }
+
+  LIBC_INLINE bool empty() { return current == 0; }
+
+  LIBC_INLINE size_t size() { return current; }
+
+  LIBC_INLINE T &operator[](size_t index) { return data[index]; }
+
+  LIBC_INLINE T &back() { return data[current - 1]; }
+
+private:
+  LIBC_INLINE void grow() {
+    size_t new_capacity = capacity ? capacity * 2 : 1;
+    void *new_data = realloc(data, new_capacity * sizeof(T));
+    data = static_cast<T *>(new_data);
+    capacity = new_capacity;
+  }
+};
+
+struct TempStorage {
+  LIBC_INLINE char *alloc(size_t size) {
+    storage.push_back(reinterpret_cast<char *>(malloc(size)));
+    return storage.back();
+  }
+
+  LIBC_INLINE ~TempStorage() {
+    for (size_t i = 0; i < storage.size(); ++i)
+      free(storage[i]);
+  }
+
+  TempVector<char *> storage;
+};
+
+// Get the associated stream out of an encoded number.
+LIBC_INLINE static ::FILE *to_stream(uintptr_t f) {
+  enum Stream {
+    File = 0,
+    Stdin = 1,
+    Stdout = 2,
+    Stderr = 3,
+  };
+
+  ::FILE *stream = reinterpret_cast<FILE *>(f & ~0x3ull);
+  Stream type = static_cast<Stream>(f & 0x3ull);
+  if (type == Stdin)
+    return stdin;
+  if (type == Stdout)
+    return stdout;
+  if (type == Stderr)
+    return stderr;
+  return stream;
+}
+
+template <bool packed, uint32_t num_lanes>
+LIBC_INLINE static void handle_printf(rpc::Server::Port &port,
+                                      TempStorage &temp_storage) {
+  FILE *files[num_lanes] = {nullptr};
+  // Get the appropriate output stream to use.
+  if (port.get_opcode() == LIBC_PRINTF_TO_STREAM ||
+      port.get_opcode() == LIBC_PRINTF_TO_STREAM_PACKED) {
+    port.recv([&](rpc::Buffer *buffer, uint32_t id) {
+      files[id] = reinterpret_cast<FILE *>(buffer->data[0]);
+    });
+  } else if (port.get_opcode() == LIBC_PRINTF_TO_STDOUT ||
+             port.get_opcode() == LIBC_PRINTF_TO_STDOUT_PACKED) {
+    for (uint32_t i = 0; i < num_lanes; ++i)
+      files[i] = stdout;
+  } else {
+    for (uint32_t i = 0; i < num_lanes; ++i)
+      files[i] = stderr;
+  }
+
+  uint64_t format_sizes[num_lanes] = {0};
+  void *format[num_lanes] = {nullptr};
+
+  uint64_t args_sizes[num_lanes] = {0};
+  void *args[num_lanes] = {nullptr};
+
+  // Recieve the format string and arguments from the client.
+  port.recv_n(format, format_sizes,
+              [&](uint64_t size) { return temp_storage.alloc(size); });
+
+  // Parse the format string to get the expected size of the buffer.
+  for (uint32_t lane = 0; lane < num_lanes; ++lane) {
+    if (!format[lane])
+      continue;
+
+    printf_core::WriteBuffer<
+        printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>
+        wb(nullptr, 0);
+    printf_core::Writer writer(wb);
+
+    internal::DummyArgList<packed> printf_args;
+    printf_core::Parser<internal::DummyArgList<packed> &> parser(
+        reinterpret_cast<const char *>(format[lane]), printf_args);
+
+    for (printf_core::FormatSection cur_section = parser.get_next_section();
+         !cur_section.raw_string.empty();
+         cur_section = parser.get_next_section())
+      ;
+    args_sizes[lane] = printf_args.read_count();
+  }
+  port.send([&](rpc::Buffer *buffer, uint32_t id) {
+    buffer->data[0] = args_sizes[id];
+  });
+  port.recv_n(args, args_sizes,
+              [&](uint64_t size) { return temp_storage.alloc(size); });
+
+  // Identify any arguments that are actually pointers to strings on the client.
+  // Additionally we want to determine how much buffer space we need to print.
+  TempVector<void *> strs_to_copy[num_lanes];
+  int buffer_size[num_lanes] = {0};
+  for (uint32_t lane = 0; lane < num_lanes; ++lane) {
+    if (!format[lane])
+      continue;
+
+    printf_core::WriteBuffer<
+        printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>
+        wb(nullptr, 0);
+    printf_core::Writer writer(wb);
+
+    internal::StructArgList<packed> printf_args(args[lane], args_sizes[lane]);
+    printf_core::Parser<internal::StructArgList<packed>> parser(
+        reinterpret_cast<const char *>(format[lane]), printf_args);
+
+    for (printf_core::FormatSection cur_section = parser.get_next_section();
+         !cur_section.raw_string.empty();
+         cur_section = parser.get_next_section()) {
+      if (cur_section.has_conv && cur_section.conv_name == 's' &&
+          cur_section.conv_val_ptr) {
+        strs_to_copy[lane].push_back(cur_section.conv_val_ptr);
+        // Get the minimum size of the string in the case of padding.
+        char c = '\0';
+        cur_section.conv_val_ptr = &c;
+        convert(&writer, cur_section);
+      } else if (cur_section.has_conv) {
+        // Ignore conversion errors for the first pass.
+        convert(&writer, cur_section);
+      } else {
+        writer.write(cur_section.raw_string);
+      }
+    }
+    buffer_size[lane] = writer.get_chars_written();
+  }
+
+  // Recieve any strings from the client and push them into a buffer.
+  TempVector<void *> copied_strs[num_lanes];
+  auto HasPendingCopies = [](TempVector<void *> v[num_lanes]) {
+    for (uint32_t i = 0; i < num_lanes; ++i)
+      if (!v[i].empty() && v[i].back())
+        return true;
+    return false;
+  };
+  while (HasPendingCopies(strs_to_copy)) {
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      void *ptr = !strs_to_copy[id].empty() ? strs_to_copy[id].back() : nullptr;
+      buffer->data[1] = reinterpret_cast<uintptr_t>(ptr);
+      if (!strs_to_copy[id].empty())
+        strs_to_copy[id].pop_back();
+    });
+    uint64_t str_sizes[num_lanes] = {0};
+    void *strs[num_lanes] = {nullptr};
+    port.recv_n(strs, str_sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    for (uint32_t lane = 0; lane < num_lanes; ++lane) {
+      if (!strs[lane])
+        continue;
+
+      copied_strs[lane].push_back(strs[lane]);
+      buffer_size[lane] += str_sizes[lane];
+    }
+  }
+
+  // Perform the final formatting and printing using the LLVM C library printf.
+  int results[num_lanes] = {0};
+  for (uint32_t lane = 0; lane < num_lanes; ++lane) {
+    if (!format[lane])
+      continue;
+
+    char *buffer = temp_storage.alloc(buffer_size[lane]);
+    printf_core::WriteBuffer<
+        printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>
+        wb(buffer, buffer_size[lane]);
+    printf_core::Writer writer(wb);
+
+    internal::StructArgList<packed> printf_args(args[lane], args_sizes[lane]);
+    printf_core::Parser<internal::StructArgList<packed>> parser(
+        reinterpret_cast<const char *>(format[lane]), printf_args);
+
+    // Parse and print the format string using the arguments we copied from
+    // the client.
+    int ret = 0;
+    for (printf_core::FormatSection cur_section = parser.get_next_section();
+         !cur_section.raw_string.empty();
+         cur_section = parser.get_next_section()) {
+      // If this argument was a string we use the memory buffer we copied from
+      // the client by replacing the raw pointer with the copied one.
+      if (cur_section.has_conv && cur_section.conv_name == 's') {
+        if (!copied_strs[lane].empty()) {
+          cur_section.conv_val_ptr = copied_strs[lane].back();
+          copied_strs[lane].pop_back();
+        } else {
+          cur_section.conv_val_ptr = nullptr;
+        }
+      }
+      if (cur_section.has_conv) {
+        ret = convert(&writer, cur_section);
+        if (ret == -1)
+          break;
+      } else {
+        writer.write(cur_section.raw_string);
+      }
+    }
+
+    results[lane] = static_cast<int>(
+        fwrite(buffer, 1, writer.get_chars_written(), files[lane]));
+    if (results[lane] != writer.get_chars_written() || ret == -1)
+      results[lane] = -1;
+  }
+
+  // Send the final return value and signal completion by setting the string
+  // argument to null.
+  port.send([&](rpc::Buffer *buffer, uint32_t id) {
+    buffer->data[0] = static_cast<uint64_t>(results[id]);
+    buffer->data[1] = reinterpret_cast<uintptr_t>(nullptr);
+  });
+}
+
+template <uint32_t num_lanes>
+LIBC_INLINE static rpc::Status handle_port_impl(rpc::Server::Port &port) {
+  TempStorage temp_storage;
+
+  switch (port.get_opcode()) {
+  case LIBC_WRITE_TO_STREAM:
+  case LIBC_WRITE_TO_STDERR:
+  case LIBC_WRITE_TO_STDOUT:
+  case LIBC_WRITE_TO_STDOUT_NEWLINE: {
+    uint64_t sizes[num_lanes] = {0};
+    void *strs[num_lanes] = {nullptr};
+    FILE *files[num_lanes] = {nullptr};
+    if (port.get_opcode() == LIBC_WRITE_TO_STREAM) {
+      port.recv([&](rpc::Buffer *buffer, uint32_t id) {
+        files[id] = reinterpret_cast<FILE *>(buffer->data[0]);
+      });
+    } else {
+      for (uint32_t i = 0; i < num_lanes; ++i)
+        files[i] = port.get_opcode() == LIBC_WRITE_TO_STDERR ? stderr : stdout;
+    }
+
+    port.recv_n(strs, sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      flockfile(files[id]);
+      buffer->data[0] = fwrite_unlocked(strs[id], 1, sizes[id], files[id]);
+      if (port.get_opcode() == LIBC_WRITE_TO_STDOUT_NEWLINE &&
+          buffer->data[0] == sizes[id])
+        buffer->data[0] += fwrite_unlocked("\n", 1, 1, files[id]);
+      funlockfile(files[id]);
+    });
+    break;
+  }
+  case LIBC_READ_FROM_STREAM: {
+    uint64_t sizes[num_lanes] = {0};
+    void *data[num_lanes] = {nullptr};
+    port.recv([&](rpc::Buffer *buffer, uint32_t id) {
+      data[id] = temp_storage.alloc(buffer->data[0]);
+      sizes[id] =
+          fread(data[id], 1, buffer->data[0], to_stream(buffer->data[1]));
+    });
+    port.send_n(data, sizes);
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      __builtin_memcpy(buffer->data, &sizes[id], sizeof(uint64_t));
+    });
+    break;
+  }
+  case LIBC_READ_FGETS: {
+    uint64_t sizes[num_lanes] = {0};
+    void *data[num_lanes] = {nullptr};
+    port.recv([&](rpc::Buffer *buffer, uint32_t id) {
+      data[id] = temp_storage.alloc(buffer->data[0]);
+      const char *str = ::fgets(reinterpret_cast<char *>(data[id]),
+                                static_cast<int>(buffer->data[0]),
+                                to_stream(buffer->data[1]));
+      sizes[id] = !str ? 0 : __builtin_strlen(str) + 1;
+    });
+    port.send_n(data, sizes);
+    break;
+  }
+  case LIBC_OPEN_FILE: {
+    uint64_t sizes[num_lanes] = {0};
+    void *paths[num_lanes] = {nullptr};
+    port.recv_n(paths, sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.recv_and_send([&](rpc::Buffer *buffer, uint32_t id) {
+      FILE *file = fopen(reinterpret_cast<char *>(paths[id]),
+                         reinterpret_cast<char *>(buffer->data));
+      buffer->data[0] = reinterpret_cast<uintptr_t>(file);
+    });
+    break;
+  }
+  case LIBC_CLOSE_FILE: {
+    port.recv_and_send([&](rpc::Buffer *buffer, uint32_t) {
+      FILE *file = reinterpret_cast<FILE *>(buffer->data[0]);
+      buffer->data[0] = ::fclose(file);
+    });
+    break;
+  }
+  case LIBC_EXIT: {
+    // Send a response to the client to signal that we are ready to exit.
+    port.recv_and_send([](rpc::Buffer *, uint32_t) {});
+    port.recv([](rpc::Buffer *buffer, uint32_t) {
+      int status = 0;
+      __builtin_memcpy(&status, buffer->data, sizeof(int));
+      exit(status);
+    });
+    break;
+  }
+  case LIBC_ABORT: {
+    // Send a response to the client to signal that we are ready to abort.
+    port.recv_and_send([](rpc::Buffer *, uint32_t) {});
+    port.recv([](rpc::Buffer *, uint32_t) {});
+    abort();
+    break;
+  }
+  case LIBC_HOST_CALL: {
+    uint64_t sizes[num_lanes] = {0};
+    unsigned long long results[num_lanes] = {0};
+    void *args[num_lanes] = {nullptr};
+    port.recv_n(args, sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.recv([&](rpc::Buffer *buffer, uint32_t id) {
+      using func_ptr_t = unsigned long long (*)(void *);
+      auto func = reinterpret_cast<func_ptr_t>(buffer->data[0]);
+      results[id] = func(args[id]);
+    });
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      buffer->data[0] = static_cast<uint64_t>(results[id]);
+    });
+    break;
+  }
+  case LIBC_FEOF: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = feof(to_stream(buffer->data[0]));
+    });
+    break;
+  }
+  case LIBC_FERROR: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = ferror(to_stream(buffer->data[0]));
+    });
+    break;
+  }
+  case LIBC_CLEARERR: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      clearerr(to_stream(buffer->data[0]));
+    });
+    break;
+  }
+  case LIBC_FSEEK: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] =
+          fseek(to_stream(buffer->data[0]), static_cast<long>(buffer->data[1]),
+                static_cast<int>(buffer->data[2]));
+    });
+    break;
+  }
+  case LIBC_FTELL: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = ftell(to_stream(buffer->data[0]));
+    });
+    break;
+  }
+  case LIBC_FFLUSH: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] = fflush(to_stream(buffer->data[0]));
+    });
+    break;
+  }
+  case LIBC_UNGETC: {
+    port.recv_and_send([](rpc::Buffer *buffer, uint32_t) {
+      buffer->data[0] =
+          ungetc(static_cast<int>(buffer->data[0]), to_stream(buffer->data[1]));
+    });
+    break;
+  }
+  case LIBC_PRINTF_TO_STREAM_PACKED:
+  case LIBC_PRINTF_TO_STDOUT_PACKED:
+  case LIBC_PRINTF_TO_STDERR_PACKED: {
+    handle_printf<true, num_lanes>(port, temp_storage);
+    break;
+  }
+  case LIBC_PRINTF_TO_STREAM:
+  case LIBC_PRINTF_TO_STDOUT:
+  case LIBC_PRINTF_TO_STDERR: {
+    handle_printf<false, num_lanes>(port, temp_storage);
+    break;
+  }
+  case LIBC_REMOVE: {
+    uint64_t sizes[num_lanes] = {0};
+    void *args[num_lanes] = {nullptr};
+    port.recv_n(args, sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      buffer->data[0] = static_cast<uint64_t>(
+          remove(reinterpret_cast<const char *>(args[id])));
+    });
+    break;
+  }
+  case LIBC_RENAME: {
+    uint64_t oldsizes[num_lanes] = {0};
+    uint64_t newsizes[num_lanes] = {0};
+    void *oldpath[num_lanes] = {nullptr};
+    void *newpath[num_lanes] = {nullptr};
+    port.recv_n(oldpath, oldsizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.recv_n(newpath, newsizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      buffer->data[0] = static_cast<uint64_t>(
+          rename(reinterpret_cast<const char *>(oldpath[id]),
+                 reinterpret_cast<const char *>(newpath[id])));
+    });
+    break;
+  }
+  case LIBC_SYSTEM: {
+    uint64_t sizes[num_lanes] = {0};
+    void *args[num_lanes] = {nullptr};
+    port.recv_n(args, sizes,
+                [&](uint64_t size) { return temp_storage.alloc(size); });
+    port.send([&](rpc::Buffer *buffer, uint32_t id) {
+      buffer->data[0] = static_cast<uint64_t>(
+          system(reinterpret_cast<const char *>(args[id])));
+    });
+    break;
+  }
+  case LIBC_NOOP: {
+    port.recv([](rpc::Buffer *, uint32_t) {});
+    break;
+  }
+  default:
+    return rpc::RPC_UNHANDLED_OPCODE;
+  }
+
+  return rpc::RPC_SUCCESS;
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+namespace rpc {
+
+// Handles any opcode generated from the 'libc' client code.
+LIBC_INLINE ::rpc::Status handle_libc_opcodes(::rpc::Server::Port &port,
+                                              uint32_t num_lanes) {
+  switch (num_lanes) {
+  case 1:
+    return internal::handle_port_impl<1>(port);
+  case 32:
+    return internal::handle_port_impl<32>(port);
+  case 64:
+    return internal::handle_port_impl<64>(port);
+  default:
+    return ::rpc::RPC_ERROR;
+  }
+}
+
+} // namespace rpc
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC___SUPPORT_RPC_RPC_SERVER_H
diff --git a/src/__support/big_int.h b/src/__support/big_int.h
index a95ab4f..85db31d 100644
--- a/src/__support/big_int.h
+++ b/src/__support/big_int.h
@@ -241,7 +241,7 @@ LIBC_INLINE constexpr void quick_mul_hi(cpp::array<word, N> &dst,
 }
 
 template <typename word, size_t N>
-LIBC_INLINE constexpr bool is_negative(cpp::array<word, N> &array) {
+LIBC_INLINE constexpr bool is_negative(const cpp::array<word, N> &array) {
   using signed_word = cpp::make_signed_t<word>;
   return cpp::bit_cast<signed_word>(array.back()) < 0;
 }
@@ -284,8 +284,8 @@ LIBC_INLINE constexpr cpp::array<word, N> shift(cpp::array<word, N> array,
     if (i < 0)
       return 0;
     if (i >= int(N))
-      return is_neg ? -1 : 0;
-    return array[i];
+      return is_neg ? cpp::numeric_limits<word>::max() : 0;
+    return array[static_cast<unsigned>(i)];
   };
   const size_t index_offset = offset / WORD_BITS;
   const size_t bit_offset = offset % WORD_BITS;
@@ -296,7 +296,7 @@ LIBC_INLINE constexpr cpp::array<word, N> shift(cpp::array<word, N> array,
   for (size_t index = 0; index < N; ++index) {
     const word part1 = safe_get_at(index + index_offset);
     const word part2 = safe_get_at(index + index_offset + 1);
-    word &dst = out[at(index)];
+    word &dst = out[static_cast<unsigned>(at(index))];
     if (bit_offset == 0)
       dst = part1; // no crosstalk between parts.
     else if constexpr (direction == LEFT)
@@ -465,8 +465,7 @@ public:
   }
 
   // Initialize the first word to |v| and the rest to 0.
-  template <typename T, typename = cpp::enable_if_t<cpp::is_integral_v<T> &&
-                                                    !cpp::is_same_v<T, bool>>>
+  template <typename T, typename = cpp::enable_if_t<cpp::is_integral_v<T>>>
   LIBC_INLINE constexpr BigInt(T v) {
     constexpr size_t T_SIZE = sizeof(T) * CHAR_BIT;
     const bool is_neg = v < 0;
@@ -697,7 +696,8 @@ public:
     }
     BigInt quotient;
     WordType x_word = static_cast<WordType>(x);
-    constexpr size_t LOG2_WORD_SIZE = cpp::bit_width(WORD_SIZE) - 1;
+    constexpr size_t LOG2_WORD_SIZE =
+        static_cast<size_t>(cpp::bit_width(WORD_SIZE) - 1);
     constexpr size_t HALF_WORD_SIZE = WORD_SIZE >> 1;
     constexpr WordType HALF_MASK = ((WordType(1) << HALF_WORD_SIZE) - 1);
     // lower = smallest multiple of WORD_SIZE that is >= e.
@@ -866,7 +866,7 @@ public:
   LIBC_INLINE constexpr BigInt operator~() const {
     BigInt result;
     for (size_t i = 0; i < WORD_COUNT; ++i)
-      result[i] = ~val[i];
+      result[i] = static_cast<WordType>(~val[i]);
     return result;
   }
 
@@ -936,6 +936,18 @@ public:
   // Return the i-th word of the number.
   LIBC_INLINE constexpr WordType &operator[](size_t i) { return val[i]; }
 
+  // Return the i-th bit of the number.
+  LIBC_INLINE constexpr bool get_bit(size_t i) const {
+    const size_t word_index = i / WORD_SIZE;
+    return 1 & (val[word_index] >> (i % WORD_SIZE));
+  }
+
+  // Set the i-th bit of the number.
+  LIBC_INLINE constexpr void set_bit(size_t i) {
+    const size_t word_index = i / WORD_SIZE;
+    val[word_index] |= WordType(1) << (i % WORD_SIZE);
+  }
+
 private:
   LIBC_INLINE friend constexpr int cmp(const BigInt &lhs, const BigInt &rhs) {
     constexpr auto compare = [](WordType a, WordType b) {
@@ -955,7 +967,7 @@ private:
 
   LIBC_INLINE constexpr void bitwise_not() {
     for (auto &part : val)
-      part = ~part;
+      part = static_cast<WordType>(~part);
   }
 
   LIBC_INLINE constexpr void negate() {
@@ -968,7 +980,7 @@ private:
   }
 
   LIBC_INLINE constexpr void decrement() {
-    multiword::add_with_carry(val, cpp::array<WordType, 1>{1});
+    multiword::sub_with_borrow(val, cpp::array<WordType, 1>{1});
   }
 
   LIBC_INLINE constexpr void extend(size_t index, bool is_neg) {
@@ -989,12 +1001,6 @@ private:
   LIBC_INLINE constexpr void clear_msb() {
     val.back() &= mask_trailing_ones<WordType, WORD_SIZE - 1>();
   }
-
-  LIBC_INLINE constexpr void set_bit(size_t i) {
-    const size_t word_index = i / WORD_SIZE;
-    val[word_index] |= WordType(1) << (i % WORD_SIZE);
-  }
-
   LIBC_INLINE constexpr static Division divide_unsigned(const BigInt &dividend,
                                                         const BigInt &divider) {
     BigInt remainder = dividend;
@@ -1003,12 +1009,12 @@ private:
       BigInt subtractor = divider;
       int cur_bit = multiword::countl_zero(subtractor.val) -
                     multiword::countl_zero(remainder.val);
-      subtractor <<= cur_bit;
+      subtractor <<= static_cast<size_t>(cur_bit);
       for (; cur_bit >= 0 && remainder > 0; --cur_bit, subtractor >>= 1) {
         if (remainder < subtractor)
           continue;
         remainder -= subtractor;
-        quotient.set_bit(cur_bit);
+        quotient.set_bit(static_cast<size_t>(cur_bit));
       }
     }
     return Division{quotient, remainder};
@@ -1270,26 +1276,28 @@ rotr(T value, int rotate);
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<is_big_int_v<T>, T>
 rotl(T value, int rotate) {
-  constexpr unsigned N = cpp::numeric_limits<T>::digits;
+  constexpr int N = cpp::numeric_limits<T>::digits;
   rotate = rotate % N;
   if (!rotate)
     return value;
   if (rotate < 0)
     return cpp::rotr<T>(value, -rotate);
-  return (value << rotate) | (value >> (N - rotate));
+  return (value << static_cast<size_t>(rotate)) |
+         (value >> (N - static_cast<size_t>(rotate)));
 }
 
 // Specialization of cpp::rotr ('bit.h') for BigInt.
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<is_big_int_v<T>, T>
 rotr(T value, int rotate) {
-  constexpr unsigned N = cpp::numeric_limits<T>::digits;
+  constexpr int N = cpp::numeric_limits<T>::digits;
   rotate = rotate % N;
   if (!rotate)
     return value;
   if (rotate < 0)
     return cpp::rotl<T>(value, -rotate);
-  return (value >> rotate) | (value << (N - rotate));
+  return (value >> static_cast<size_t>(rotate)) |
+         (value << (N - static_cast<size_t>(rotate)));
 }
 
 } // namespace cpp
@@ -1306,7 +1314,7 @@ mask_trailing_ones() {
   T out; // zero initialized
   for (size_t i = 0; i <= QUOTIENT; ++i)
     out[i] = i < QUOTIENT
-                 ? -1
+                 ? cpp::numeric_limits<typename T::word_type>::max()
                  : mask_trailing_ones<typename T::word_type, REMAINDER>();
   return out;
 }
@@ -1322,7 +1330,7 @@ LIBC_INLINE constexpr cpp::enable_if_t<is_big_int_v<T>, T> mask_leading_ones() {
   T out; // zero initialized
   for (size_t i = QUOTIENT; i < T::WORD_COUNT; ++i)
     out[i] = i > QUOTIENT
-                 ? -1
+                 ? cpp::numeric_limits<typename T::word_type>::max()
                  : mask_leading_ones<typename T::word_type, REMAINDER>();
   return out;
 }
@@ -1375,8 +1383,7 @@ first_trailing_zero(T value) {
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<is_big_int_v<T>, int>
 first_trailing_one(T value) {
-  return value == cpp::numeric_limits<T>::max() ? 0
-                                                : cpp::countr_zero(value) + 1;
+  return value == 0 ? 0 : cpp::countr_zero(value) + 1;
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/block.h b/src/__support/block.h
index 9ca3f11..a58c38b 100644
--- a/src/__support/block.h
+++ b/src/__support/block.h
@@ -18,46 +18,22 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/libc_assert.h"
 #include "src/__support/macros/config.h"
+#include "src/__support/math_extras.h"
 
 #include <stdint.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
-namespace internal {
-// Types of corrupted blocks, and functions to crash with an error message
-// corresponding to each type.
-enum class BlockStatus {
-  VALID,
-  MISALIGNED,
-  PREV_MISMATCHED,
-  NEXT_MISMATCHED,
-};
-} // namespace internal
-
 /// Returns the value rounded down to the nearest multiple of alignment.
 LIBC_INLINE constexpr size_t align_down(size_t value, size_t alignment) {
   // Note this shouldn't overflow since the result will always be <= value.
   return (value / alignment) * alignment;
 }
 
-/// Returns the value rounded down to the nearest multiple of alignment.
-template <typename T>
-LIBC_INLINE constexpr T *align_down(T *value, size_t alignment) {
-  return reinterpret_cast<T *>(
-      align_down(reinterpret_cast<size_t>(value), alignment));
-}
-
-/// Returns the value rounded up to the nearest multiple of alignment.
+/// Returns the value rounded up to the nearest multiple of alignment. May wrap
+/// around.
 LIBC_INLINE constexpr size_t align_up(size_t value, size_t alignment) {
-  __builtin_add_overflow(value, alignment - 1, &value);
-  return align_down(value, alignment);
-}
-
-/// Returns the value rounded up to the nearest multiple of alignment.
-template <typename T>
-LIBC_INLINE constexpr T *align_up(T *value, size_t alignment) {
-  return reinterpret_cast<T *>(
-      align_up(reinterpret_cast<size_t>(value), alignment));
+  return align_down(value + alignment - 1, alignment);
 }
 
 using ByteSpan = cpp::span<LIBC_NAMESPACE::cpp::byte>;
@@ -68,8 +44,8 @@ using cpp::optional;
 /// The blocks store their offsets to the previous and next blocks. The latter
 /// is also the block's size.
 ///
-/// Blocks will always be aligned to a `ALIGNMENT` boundary. Block sizes will
-/// always be rounded up to a multiple of `ALIGNMENT`.
+/// All blocks have their usable space aligned to some multiple of max_align_t.
+/// This also implies that block outer sizes are aligned to max_align_t.
 ///
 /// As an example, the diagram below represents two contiguous `Block`s. The
 /// indices indicate byte offsets:
@@ -122,15 +98,13 @@ class Block {
   static constexpr size_t SIZE_MASK = ~(PREV_FREE_MASK | LAST_MASK);
 
 public:
-  static constexpr size_t ALIGNMENT = cpp::max(alignof(max_align_t), size_t{4});
-  static const size_t BLOCK_OVERHEAD;
-
   // No copy or move.
   Block(const Block &other) = delete;
   Block &operator=(const Block &other) = delete;
 
-  /// Creates the first block for a given memory region, followed by a sentinel
-  /// last block. Returns the first block.
+  /// Initializes a given memory region into a first block and a sentinel last
+  /// block. Returns the first block, which has its usable space aligned to
+  /// max_align_t.
   static optional<Block *> init(ByteSpan region);
 
   /// @returns  A pointer to a `Block`, given a pointer to the start of the
@@ -142,11 +116,11 @@ public:
   ///           pointer will return a non-null pointer.
   LIBC_INLINE static Block *from_usable_space(void *usable_space) {
     auto *bytes = reinterpret_cast<cpp::byte *>(usable_space);
-    return reinterpret_cast<Block *>(bytes - BLOCK_OVERHEAD);
+    return reinterpret_cast<Block *>(bytes - sizeof(Block));
   }
   LIBC_INLINE static const Block *from_usable_space(const void *usable_space) {
     const auto *bytes = reinterpret_cast<const cpp::byte *>(usable_space);
-    return reinterpret_cast<const Block *>(bytes - BLOCK_OVERHEAD);
+    return reinterpret_cast<const Block *>(bytes - sizeof(Block));
   }
 
   /// @returns The total size of the block in bytes, including the header.
@@ -154,7 +128,7 @@ public:
 
   LIBC_INLINE static size_t outer_size(size_t inner_size) {
     // The usable region includes the prev_ field of the next block.
-    return inner_size - sizeof(prev_) + BLOCK_OVERHEAD;
+    return inner_size - sizeof(prev_) + sizeof(Block);
   }
 
   /// @returns The number of usable bytes inside the block were it to be
@@ -182,15 +156,23 @@ public:
   /// @returns The number of usable bytes inside a block with the given outer
   /// size if it remains free.
   LIBC_INLINE static size_t inner_size_free(size_t outer_size) {
-    return outer_size - BLOCK_OVERHEAD;
+    return outer_size - sizeof(Block);
   }
 
   /// @returns A pointer to the usable space inside this block.
+  ///
+  /// Aligned to some multiple of max_align_t.
   LIBC_INLINE cpp::byte *usable_space() {
-    return reinterpret_cast<cpp::byte *>(this) + BLOCK_OVERHEAD;
+    auto *s = reinterpret_cast<cpp::byte *>(this) + sizeof(Block);
+    LIBC_ASSERT(reinterpret_cast<uintptr_t>(s) % alignof(max_align_t) == 0 &&
+                "usable space must be aligned to a multiple of max_align_t");
+    return s;
   }
   LIBC_INLINE const cpp::byte *usable_space() const {
-    return reinterpret_cast<const cpp::byte *>(this) + BLOCK_OVERHEAD;
+    const auto *s = reinterpret_cast<const cpp::byte *>(this) + sizeof(Block);
+    LIBC_ASSERT(reinterpret_cast<uintptr_t>(s) % alignof(max_align_t) == 0 &&
+                "usable space must be aligned to a multiple of max_align_t");
+    return s;
   }
 
   // @returns The region of memory the block manages, including the header.
@@ -201,11 +183,12 @@ public:
   /// Attempts to split this block.
   ///
   /// If successful, the block will have an inner size of at least
-  /// `new_inner_size`, rounded to ensure that the split point is on an
-  /// ALIGNMENT boundary. The remaining space will be returned as a new block.
-  /// Note that the prev_ field of the next block counts as part of the inner
-  /// size of the returnd block.
-  optional<Block *> split(size_t new_inner_size);
+  /// `new_inner_size`. The remaining space will be returned as a new block,
+  /// with usable space aligned to `usable_space_alignment`. Note that the prev_
+  /// field of the next block counts as part of the inner size of the block.
+  /// `usable_space_alignment` must be a multiple of max_align_t.
+  optional<Block *> split(size_t new_inner_size,
+                          size_t usable_space_alignment = alignof(max_align_t));
 
   /// Merges this block with the one that comes after it.
   bool merge_next();
@@ -244,50 +227,63 @@ public:
     *new (&next()->prev_) size_t = outer_size();
   }
 
-  /// Marks this block as the last one in the chain. Makes next() return
-  /// nullptr.
-  LIBC_INLINE void mark_last() { next_ |= LAST_MASK; }
-
-  LIBC_INLINE constexpr Block(size_t outer_size) : next_(outer_size) {
-    LIBC_ASSERT(outer_size % ALIGNMENT == 0 && "block sizes must be aligned");
+  LIBC_INLINE Block(size_t outer_size, bool is_last) : next_(outer_size) {
+    // Last blocks are not usable, so they need not have sizes aligned to
+    // max_align_t. Their lower bits must still be free, so they must be aligned
+    // to Block.
+    LIBC_ASSERT(
+        outer_size % (is_last ? alignof(Block) : alignof(max_align_t)) == 0 &&
+        "block sizes must be aligned");
+    LIBC_ASSERT(is_usable_space_aligned(alignof(max_align_t)) &&
+                "usable space must be aligned to a multiple of max_align_t");
+    if (is_last)
+      next_ |= LAST_MASK;
   }
 
   LIBC_INLINE bool is_usable_space_aligned(size_t alignment) const {
     return reinterpret_cast<uintptr_t>(usable_space()) % alignment == 0;
   }
 
-  /// @returns The new inner size of this block that would give the usable
-  /// space of the next block the given alignment.
-  LIBC_INLINE size_t padding_for_alignment(size_t alignment) const {
-    if (is_usable_space_aligned(alignment))
+  // Returns the minimum inner size necessary for a block of that size to
+  // always be able to allocate at the given size and alignment.
+  //
+  // Returns 0 if there is no such size.
+  LIBC_INLINE static size_t min_size_for_allocation(size_t alignment,
+                                                    size_t size) {
+    LIBC_ASSERT(alignment >= alignof(max_align_t) &&
+                alignment % alignof(max_align_t) == 0 &&
+                "alignment must be multiple of max_align_t");
+
+    if (alignment == alignof(max_align_t))
+      return size;
+
+    // We must create a new block inside this one (splitting). This requires a
+    // block header in addition to the requested size.
+    if (add_overflow(size, sizeof(Block), size))
       return 0;
 
-    // We need to ensure we can always split this block into a "padding" block
-    // and the aligned block. To do this, we need enough extra space for at
-    // least one block.
+    // Beyond that, padding space may need to remain in this block to ensure
+    // that the usable space of the next block is aligned.
     //
-    // |block   |usable_space                          |
-    // |........|......................................|
-    //                            ^
-    //                            Alignment requirement
+    // Consider a position P of some lesser alignment, L, with maximal distance
+    // to the next position of some greater alignment, G, where G is a multiple
+    // of L. P must be one L unit past a G-aligned point. If it were one L-unit
+    // earlier, its distance would be zero. If it were one L-unit later, its
+    // distance would not be maximal. If it were not some integral number of L
+    // units away, it would not be L-aligned.
     //
+    // So the maximum distance would be G - L. As a special case, if L is 1
+    // (unaligned), the max distance is G - 1.
     //
-    // |block   |space   |block   |usable_space        |
-    // |........|........|........|....................|
-    //                            ^
-    //                            Alignment requirement
-    //
-    alignment = cpp::max(alignment, ALIGNMENT);
-    uintptr_t start = reinterpret_cast<uintptr_t>(usable_space());
-    uintptr_t next_usable_space = align_up(start + BLOCK_OVERHEAD, alignment);
-    uintptr_t next_block = next_usable_space - BLOCK_OVERHEAD;
-    return next_block - start + sizeof(prev_);
+    // This block's usable space is aligned to max_align_t >= Block. With zero
+    // padding, the next block's usable space is sizeof(Block) past it, which is
+    // a point aligned to Block. Thus the max padding needed is alignment -
+    // alignof(Block).
+    if (add_overflow(size, alignment - alignof(Block), size))
+      return 0;
+    return size;
   }
 
-  // Check that we can `allocate` a block with a given alignment and size from
-  // this existing block.
-  bool can_allocate(size_t alignment, size_t size) const;
-
   // This is the return type for `allocate` which can split one block into up to
   // three blocks.
   struct BlockInfo {
@@ -309,20 +305,36 @@ public:
     Block *next;
   };
 
-  // Divide a block into up to 3 blocks according to `BlockInfo`. This should
-  // only be called if `can_allocate` returns true.
+  // Divide a block into up to 3 blocks according to `BlockInfo`. Behavior is
+  // undefined if allocation is not possible for the given size and alignment.
   static BlockInfo allocate(Block *block, size_t alignment, size_t size);
 
+  // These two functions may wrap around.
+  LIBC_INLINE static uintptr_t next_possible_block_start(
+      uintptr_t ptr, size_t usable_space_alignment = alignof(max_align_t)) {
+    return align_up(ptr + sizeof(Block), usable_space_alignment) -
+           sizeof(Block);
+  }
+  LIBC_INLINE static uintptr_t prev_possible_block_start(
+      uintptr_t ptr, size_t usable_space_alignment = alignof(max_align_t)) {
+    return align_down(ptr, usable_space_alignment) - sizeof(Block);
+  }
+
 private:
   /// Construct a block to represent a span of bytes. Overwrites only enough
   /// memory for the block header; the rest of the span is left alone.
   LIBC_INLINE static Block *as_block(ByteSpan bytes) {
-    return ::new (bytes.data()) Block(bytes.size());
+    LIBC_ASSERT(reinterpret_cast<uintptr_t>(bytes.data()) % alignof(Block) ==
+                    0 &&
+                "block start must be suitably aligned");
+    return ::new (bytes.data()) Block(bytes.size(), /*is_last=*/false);
   }
 
-  /// Like `split`, but assumes the caller has already checked to parameters to
-  /// ensure the split will succeed.
-  Block *split_impl(size_t new_inner_size);
+  LIBC_INLINE static void make_last_block(cpp::byte *start) {
+    LIBC_ASSERT(reinterpret_cast<uintptr_t>(start) % alignof(Block) == 0 &&
+                "block start must be suitably aligned");
+    ::new (start) Block(sizeof(Block), /*is_last=*/true);
+  }
 
   /// Offset from this block to the previous block. 0 if this is the first
   /// block. This field is only alive when the previous block is free;
@@ -343,81 +355,57 @@ private:
   ///   previous block is free.
   /// * If the `last` flag is set, the block is the sentinel last block. It is
   ///   summarily considered used and has no next block.
-} __attribute__((packed, aligned(cpp::max(alignof(max_align_t), size_t{4}))));
-
-inline constexpr size_t Block::BLOCK_OVERHEAD =
-    align_up(sizeof(Block), ALIGNMENT);
-
-LIBC_INLINE ByteSpan get_aligned_subspan(ByteSpan bytes, size_t alignment) {
-  if (bytes.data() == nullptr)
-    return ByteSpan();
-
-  auto unaligned_start = reinterpret_cast<uintptr_t>(bytes.data());
-  auto aligned_start = align_up(unaligned_start, alignment);
-  auto unaligned_end = unaligned_start + bytes.size();
-  auto aligned_end = align_down(unaligned_end, alignment);
 
-  if (aligned_end <= aligned_start)
-    return ByteSpan();
+public:
+  /// Only for testing.
+  static constexpr size_t PREV_FIELD_SIZE = sizeof(prev_);
+};
 
-  return bytes.subspan(aligned_start - unaligned_start,
-                       aligned_end - aligned_start);
-}
+static_assert(alignof(Block) >= 4,
+              "at least 2 bits must be available in block sizes for flags");
 
 LIBC_INLINE
 optional<Block *> Block::init(ByteSpan region) {
-  optional<ByteSpan> result = get_aligned_subspan(region, ALIGNMENT);
-  if (!result)
+  if (!region.data())
     return {};
 
-  region = result.value();
-  // Two blocks are allocated: a free block and a sentinel last block.
-  if (region.size() < 2 * BLOCK_OVERHEAD)
+  uintptr_t start = reinterpret_cast<uintptr_t>(region.data());
+  uintptr_t end = start + region.size();
+  if (end < start)
     return {};
 
-  if (cpp::numeric_limits<size_t>::max() < region.size())
+  uintptr_t block_start = next_possible_block_start(start);
+  if (block_start < start)
     return {};
 
-  Block *block = as_block(region.first(region.size() - BLOCK_OVERHEAD));
-  Block *last = as_block(region.last(BLOCK_OVERHEAD));
-  block->mark_free();
-  last->mark_last();
-  return block;
-}
-
-LIBC_INLINE
-bool Block::can_allocate(size_t alignment, size_t size) const {
-  if (inner_size() < size)
-    return false;
-  if (is_usable_space_aligned(alignment))
-    return true;
+  uintptr_t last_start = prev_possible_block_start(end);
+  if (last_start >= end)
+    return {};
 
-  // Alignment isn't met, so a padding block is needed. Determine amount of
-  // inner_size() consumed by the padding block.
-  size_t padding_size = padding_for_alignment(alignment) - sizeof(prev_);
+  if (block_start + sizeof(Block) > last_start)
+    return {};
 
-  // Check that there is room for the allocation in the following aligned block.
-  size_t aligned_inner_size = inner_size() - padding_size - BLOCK_OVERHEAD;
-  return size <= aligned_inner_size;
+  auto *last_start_ptr = reinterpret_cast<cpp::byte *>(last_start);
+  Block *block =
+      as_block({reinterpret_cast<cpp::byte *>(block_start), last_start_ptr});
+  make_last_block(last_start_ptr);
+  block->mark_free();
+  return block;
 }
 
 LIBC_INLINE
 Block::BlockInfo Block::allocate(Block *block, size_t alignment, size_t size) {
-  LIBC_ASSERT(
-      block->can_allocate(alignment, size) &&
-      "Calls to this function for a given alignment and size should only be "
-      "done if `can_allocate` for these parameters returns true.");
+  LIBC_ASSERT(alignment % alignof(max_align_t) == 0 &&
+              "alignment must be a multiple of max_align_t");
 
   BlockInfo info{block, /*prev=*/nullptr, /*next=*/nullptr};
 
   if (!info.block->is_usable_space_aligned(alignment)) {
     Block *original = info.block;
-    optional<Block *> maybe_aligned_block =
-        original->split(info.block->padding_for_alignment(alignment));
+    // The padding block has no minimum size requirement.
+    optional<Block *> maybe_aligned_block = original->split(0, alignment);
     LIBC_ASSERT(maybe_aligned_block.has_value() &&
-                "This split should always result in a new block. The check in "
-                "`can_allocate` ensures that we have enough space here to make "
-                "two blocks.");
+                "it should always be possible to split for alignment");
 
     if (Block *prev = original->prev_free()) {
       // If there is a free block before this, we can merge the current one with
@@ -441,37 +429,40 @@ Block::BlockInfo Block::allocate(Block *block, size_t alignment, size_t size) {
 }
 
 LIBC_INLINE
-optional<Block *> Block::split(size_t new_inner_size) {
+optional<Block *> Block::split(size_t new_inner_size,
+                               size_t usable_space_alignment) {
+  LIBC_ASSERT(usable_space_alignment % alignof(max_align_t) == 0 &&
+              "alignment must be a multiple of max_align_t");
   if (used())
     return {};
-  // The prev_ field of the next block is always available, so there is a
-  // minimum size to a block created through splitting.
-  if (new_inner_size < sizeof(prev_))
-    new_inner_size = sizeof(prev_);
-
-  size_t old_inner_size = inner_size();
-  new_inner_size =
-      align_up(new_inner_size - sizeof(prev_), ALIGNMENT) + sizeof(prev_);
-  if (old_inner_size < new_inner_size)
-    return {};
 
-  if (old_inner_size - new_inner_size < BLOCK_OVERHEAD)
+  // Compute the minimum outer size that produces a block of at least
+  // `new_inner_size`.
+  size_t min_outer_size = outer_size(cpp::max(new_inner_size, sizeof(prev_)));
+
+  uintptr_t start = reinterpret_cast<uintptr_t>(this);
+  uintptr_t next_block_start =
+      next_possible_block_start(start + min_outer_size, usable_space_alignment);
+  if (next_block_start < start)
     return {};
+  size_t new_outer_size = next_block_start - start;
+  LIBC_ASSERT(new_outer_size % alignof(max_align_t) == 0 &&
+              "new size must be aligned to max_align_t");
 
-  return split_impl(new_inner_size);
-}
+  if (outer_size() < new_outer_size ||
+      outer_size() - new_outer_size < sizeof(Block))
+    return {};
 
-LIBC_INLINE
-Block *Block::split_impl(size_t new_inner_size) {
-  size_t outer_size1 = outer_size(new_inner_size);
-  LIBC_ASSERT(outer_size1 % ALIGNMENT == 0 && "new size must be aligned");
-  ByteSpan new_region = region().subspan(outer_size1);
+  ByteSpan new_region = region().subspan(new_outer_size);
   next_ &= ~SIZE_MASK;
-  next_ |= outer_size1;
+  next_ |= new_outer_size;
 
   Block *new_block = as_block(new_region);
   mark_free(); // Free status for this block is now stored in new_block.
   new_block->next()->prev_ = new_region.size();
+
+  LIBC_ASSERT(new_block->is_usable_space_aligned(usable_space_alignment) &&
+              "usable space must have requested alignment");
   return new_block;
 }
 
diff --git a/src/__support/complex_basic_ops.h b/src/__support/complex_basic_ops.h
new file mode 100644
index 0000000..5992ebe
--- /dev/null
+++ b/src/__support/complex_basic_ops.h
@@ -0,0 +1,36 @@
+//===-- complex basic operations --------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC___SUPPORT_COMPLEX_BASIC_OPERATIONS_H
+#define LLVM_LIBC_SRC___SUPPORT_COMPLEX_BASIC_OPERATIONS_H
+
+#include "complex_type.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/FPUtil/FPBits.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+template <typename T> LIBC_INLINE constexpr T conjugate(T c) {
+  Complex<make_real_t<T>> c_c = cpp::bit_cast<Complex<make_real_t<T>>>(c);
+  c_c.imag = -c_c.imag;
+  return cpp::bit_cast<T>(c_c);
+}
+
+template <typename T> LIBC_INLINE constexpr T project(T c) {
+  using real_t = make_real_t<T>;
+  Complex<real_t> c_c = cpp::bit_cast<Complex<real_t>>(c);
+  if (fputil::FPBits<real_t>(c_c.real).is_inf() ||
+      fputil::FPBits<real_t>(c_c.imag).is_inf())
+    return cpp::bit_cast<T>(
+        Complex<real_t>{(fputil::FPBits<real_t>::inf(Sign::POS).get_val()),
+                        static_cast<real_t>(c_c.imag > 0 ? 0.0 : -0.0)});
+  return c;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC___SUPPORT_COMPLEX_BASIC_OPERATIONS_H
diff --git a/src/__support/complex_type.h b/src/__support/complex_type.h
index d6b5eec..93089de 100644
--- a/src/__support/complex_type.h
+++ b/src/__support/complex_type.h
@@ -10,11 +10,64 @@
 #define LLVM_LIBC_SRC___SUPPORT_COMPLEX_TYPE_H
 
 #include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
 
 namespace LIBC_NAMESPACE_DECL {
 template <typename T> struct Complex {
   T real;
   T imag;
 };
+
+template <typename T> struct make_complex;
+
+template <> struct make_complex<float> {
+  using type = _Complex float;
+};
+template <> struct make_complex<double> {
+  using type = _Complex double;
+};
+template <> struct make_complex<long double> {
+  using type = _Complex long double;
+};
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+template <> struct make_complex<float16> {
+  using type = cfloat16;
+};
+#endif
+#ifdef LIBC_TYPES_CFLOAT128_IS_NOT_COMPLEX_LONG_DOUBLE
+template <> struct make_complex<float128> {
+  using type = cfloat128;
+};
+#endif
+
+template <typename T> using make_complex_t = typename make_complex<T>::type;
+
+template <typename T> struct make_real;
+
+template <> struct make_real<_Complex float> {
+  using type = float;
+};
+template <> struct make_real<_Complex double> {
+  using type = double;
+};
+template <> struct make_real<_Complex long double> {
+  using type = long double;
+};
+
+#if defined(LIBC_TYPES_HAS_CFLOAT16)
+template <> struct make_real<cfloat16> {
+  using type = float16;
+};
+#endif
+#ifdef LIBC_TYPES_CFLOAT128_IS_NOT_COMPLEX_LONG_DOUBLE
+template <> struct make_real<cfloat128> {
+  using type = float128;
+};
+#endif
+
+template <typename T> using make_real_t = typename make_real<T>::type;
+
 } // namespace LIBC_NAMESPACE_DECL
 #endif // LLVM_LIBC_SRC___SUPPORT_COMPLEX_TYPE_H
diff --git a/src/__support/ctype_utils.h b/src/__support/ctype_utils.h
index 91f6ce8..be0f253 100644
--- a/src/__support/ctype_utils.h
+++ b/src/__support/ctype_utils.h
@@ -15,44 +15,567 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
-// ------------------------------------------------------
-// Rationale: Since these classification functions are
-// called in other functions, we will avoid the overhead
-// of a function call by inlining them.
-// ------------------------------------------------------
+// -----------------------------------------------------------------------------
+// ******************                 WARNING                 ******************
+// ****************** DO NOT TRY TO OPTIMIZE THESE FUNCTIONS! ******************
+// -----------------------------------------------------------------------------
+// This switch/case form is easier for the compiler to understand, and is
+// optimized into a form that is almost always the same as or better than
+// versions written by hand (see https://godbolt.org/z/qvrebqvvr). Also this
+// form makes these functions encoding independent. If you want to rewrite these
+// functions, make sure you have benchmarks to show your new solution is faster,
+// as well as a way to support non-ASCII character encodings.
 
-LIBC_INLINE static constexpr bool isalpha(unsigned ch) {
-  return (ch | 32) - 'a' < 26;
+// Similarly, do not change these functions to use case ranges. e.g.
+//  bool islower(int ch) {
+//    switch(ch) {
+//    case 'a'...'z':
+//      return true;
+//    }
+//  }
+// This assumes the character ranges are contiguous, which they aren't in
+// EBCDIC. Technically we could use some smaller ranges, but that's even harder
+// to read.
+
+LIBC_INLINE static constexpr bool islower(int ch) {
+  switch (ch) {
+  case 'a':
+  case 'b':
+  case 'c':
+  case 'd':
+  case 'e':
+  case 'f':
+  case 'g':
+  case 'h':
+  case 'i':
+  case 'j':
+  case 'k':
+  case 'l':
+  case 'm':
+  case 'n':
+  case 'o':
+  case 'p':
+  case 'q':
+  case 'r':
+  case 's':
+  case 't':
+  case 'u':
+  case 'v':
+  case 'w':
+  case 'x':
+  case 'y':
+  case 'z':
+    return true;
+  default:
+    return false;
+  }
 }
 
-LIBC_INLINE static constexpr bool isdigit(unsigned ch) {
-  return (ch - '0') < 10;
+LIBC_INLINE static constexpr bool isupper(int ch) {
+  switch (ch) {
+  case 'A':
+  case 'B':
+  case 'C':
+  case 'D':
+  case 'E':
+  case 'F':
+  case 'G':
+  case 'H':
+  case 'I':
+  case 'J':
+  case 'K':
+  case 'L':
+  case 'M':
+  case 'N':
+  case 'O':
+  case 'P':
+  case 'Q':
+  case 'R':
+  case 'S':
+  case 'T':
+  case 'U':
+  case 'V':
+  case 'W':
+  case 'X':
+  case 'Y':
+  case 'Z':
+    return true;
+  default:
+    return false;
+  }
 }
 
-LIBC_INLINE static constexpr bool isalnum(unsigned ch) {
-  return isalpha(ch) || isdigit(ch);
+LIBC_INLINE static constexpr bool isdigit(int ch) {
+  switch (ch) {
+  case '0':
+  case '1':
+  case '2':
+  case '3':
+  case '4':
+  case '5':
+  case '6':
+  case '7':
+  case '8':
+  case '9':
+    return true;
+  default:
+    return false;
+  }
 }
 
-LIBC_INLINE static constexpr bool isgraph(unsigned ch) {
-  return 0x20 < ch && ch < 0x7f;
+LIBC_INLINE static constexpr int tolower(int ch) {
+  switch (ch) {
+  case 'A':
+    return 'a';
+  case 'B':
+    return 'b';
+  case 'C':
+    return 'c';
+  case 'D':
+    return 'd';
+  case 'E':
+    return 'e';
+  case 'F':
+    return 'f';
+  case 'G':
+    return 'g';
+  case 'H':
+    return 'h';
+  case 'I':
+    return 'i';
+  case 'J':
+    return 'j';
+  case 'K':
+    return 'k';
+  case 'L':
+    return 'l';
+  case 'M':
+    return 'm';
+  case 'N':
+    return 'n';
+  case 'O':
+    return 'o';
+  case 'P':
+    return 'p';
+  case 'Q':
+    return 'q';
+  case 'R':
+    return 'r';
+  case 'S':
+    return 's';
+  case 'T':
+    return 't';
+  case 'U':
+    return 'u';
+  case 'V':
+    return 'v';
+  case 'W':
+    return 'w';
+  case 'X':
+    return 'x';
+  case 'Y':
+    return 'y';
+  case 'Z':
+    return 'z';
+  default:
+    return ch;
+  }
 }
 
-LIBC_INLINE static constexpr bool islower(unsigned ch) {
-  return (ch - 'a') < 26;
+LIBC_INLINE static constexpr int toupper(int ch) {
+  switch (ch) {
+  case 'a':
+    return 'A';
+  case 'b':
+    return 'B';
+  case 'c':
+    return 'C';
+  case 'd':
+    return 'D';
+  case 'e':
+    return 'E';
+  case 'f':
+    return 'F';
+  case 'g':
+    return 'G';
+  case 'h':
+    return 'H';
+  case 'i':
+    return 'I';
+  case 'j':
+    return 'J';
+  case 'k':
+    return 'K';
+  case 'l':
+    return 'L';
+  case 'm':
+    return 'M';
+  case 'n':
+    return 'N';
+  case 'o':
+    return 'O';
+  case 'p':
+    return 'P';
+  case 'q':
+    return 'Q';
+  case 'r':
+    return 'R';
+  case 's':
+    return 'S';
+  case 't':
+    return 'T';
+  case 'u':
+    return 'U';
+  case 'v':
+    return 'V';
+  case 'w':
+    return 'W';
+  case 'x':
+    return 'X';
+  case 'y':
+    return 'Y';
+  case 'z':
+    return 'Z';
+  default:
+    return ch;
+  }
 }
 
-LIBC_INLINE static constexpr bool isupper(unsigned ch) {
-  return (ch - 'A') < 26;
+LIBC_INLINE static constexpr bool isalpha(int ch) {
+  switch (ch) {
+  case 'a':
+  case 'b':
+  case 'c':
+  case 'd':
+  case 'e':
+  case 'f':
+  case 'g':
+  case 'h':
+  case 'i':
+  case 'j':
+  case 'k':
+  case 'l':
+  case 'm':
+  case 'n':
+  case 'o':
+  case 'p':
+  case 'q':
+  case 'r':
+  case 's':
+  case 't':
+  case 'u':
+  case 'v':
+  case 'w':
+  case 'x':
+  case 'y':
+  case 'z':
+  case 'A':
+  case 'B':
+  case 'C':
+  case 'D':
+  case 'E':
+  case 'F':
+  case 'G':
+  case 'H':
+  case 'I':
+  case 'J':
+  case 'K':
+  case 'L':
+  case 'M':
+  case 'N':
+  case 'O':
+  case 'P':
+  case 'Q':
+  case 'R':
+  case 'S':
+  case 'T':
+  case 'U':
+  case 'V':
+  case 'W':
+  case 'X':
+  case 'Y':
+  case 'Z':
+    return true;
+  default:
+    return false;
+  }
 }
 
-LIBC_INLINE static constexpr bool isspace(unsigned ch) {
-  return ch == ' ' || (ch - '\t') < 5;
+LIBC_INLINE static constexpr bool isalnum(int ch) {
+  switch (ch) {
+  case 'a':
+  case 'b':
+  case 'c':
+  case 'd':
+  case 'e':
+  case 'f':
+  case 'g':
+  case 'h':
+  case 'i':
+  case 'j':
+  case 'k':
+  case 'l':
+  case 'm':
+  case 'n':
+  case 'o':
+  case 'p':
+  case 'q':
+  case 'r':
+  case 's':
+  case 't':
+  case 'u':
+  case 'v':
+  case 'w':
+  case 'x':
+  case 'y':
+  case 'z':
+  case 'A':
+  case 'B':
+  case 'C':
+  case 'D':
+  case 'E':
+  case 'F':
+  case 'G':
+  case 'H':
+  case 'I':
+  case 'J':
+  case 'K':
+  case 'L':
+  case 'M':
+  case 'N':
+  case 'O':
+  case 'P':
+  case 'Q':
+  case 'R':
+  case 'S':
+  case 'T':
+  case 'U':
+  case 'V':
+  case 'W':
+  case 'X':
+  case 'Y':
+  case 'Z':
+  case '0':
+  case '1':
+  case '2':
+  case '3':
+  case '4':
+  case '5':
+  case '6':
+  case '7':
+  case '8':
+  case '9':
+    return true;
+  default:
+    return false;
+  }
 }
 
-LIBC_INLINE static constexpr int tolower(int ch) {
-  if (isupper(ch))
-    return ch + ('a' - 'A');
-  return ch;
+LIBC_INLINE static constexpr int b36_char_to_int(int ch) {
+  switch (ch) {
+  case '0':
+    return 0;
+  case '1':
+    return 1;
+  case '2':
+    return 2;
+  case '3':
+    return 3;
+  case '4':
+    return 4;
+  case '5':
+    return 5;
+  case '6':
+    return 6;
+  case '7':
+    return 7;
+  case '8':
+    return 8;
+  case '9':
+    return 9;
+  case 'a':
+  case 'A':
+    return 10;
+  case 'b':
+  case 'B':
+    return 11;
+  case 'c':
+  case 'C':
+    return 12;
+  case 'd':
+  case 'D':
+    return 13;
+  case 'e':
+  case 'E':
+    return 14;
+  case 'f':
+  case 'F':
+    return 15;
+  case 'g':
+  case 'G':
+    return 16;
+  case 'h':
+  case 'H':
+    return 17;
+  case 'i':
+  case 'I':
+    return 18;
+  case 'j':
+  case 'J':
+    return 19;
+  case 'k':
+  case 'K':
+    return 20;
+  case 'l':
+  case 'L':
+    return 21;
+  case 'm':
+  case 'M':
+    return 22;
+  case 'n':
+  case 'N':
+    return 23;
+  case 'o':
+  case 'O':
+    return 24;
+  case 'p':
+  case 'P':
+    return 25;
+  case 'q':
+  case 'Q':
+    return 26;
+  case 'r':
+  case 'R':
+    return 27;
+  case 's':
+  case 'S':
+    return 28;
+  case 't':
+  case 'T':
+    return 29;
+  case 'u':
+  case 'U':
+    return 30;
+  case 'v':
+  case 'V':
+    return 31;
+  case 'w':
+  case 'W':
+    return 32;
+  case 'x':
+  case 'X':
+    return 33;
+  case 'y':
+  case 'Y':
+    return 34;
+  case 'z':
+  case 'Z':
+    return 35;
+  default:
+    return 0;
+  }
+}
+
+LIBC_INLINE static constexpr int int_to_b36_char(int num) {
+  // Can't actually use LIBC_ASSERT here because it depends on integer_to_string
+  // which depends on this.
+
+  // LIBC_ASSERT(num < 36);
+  switch (num) {
+  case 0:
+    return '0';
+  case 1:
+    return '1';
+  case 2:
+    return '2';
+  case 3:
+    return '3';
+  case 4:
+    return '4';
+  case 5:
+    return '5';
+  case 6:
+    return '6';
+  case 7:
+    return '7';
+  case 8:
+    return '8';
+  case 9:
+    return '9';
+  case 10:
+    return 'a';
+  case 11:
+    return 'b';
+  case 12:
+    return 'c';
+  case 13:
+    return 'd';
+  case 14:
+    return 'e';
+  case 15:
+    return 'f';
+  case 16:
+    return 'g';
+  case 17:
+    return 'h';
+  case 18:
+    return 'i';
+  case 19:
+    return 'j';
+  case 20:
+    return 'k';
+  case 21:
+    return 'l';
+  case 22:
+    return 'm';
+  case 23:
+    return 'n';
+  case 24:
+    return 'o';
+  case 25:
+    return 'p';
+  case 26:
+    return 'q';
+  case 27:
+    return 'r';
+  case 28:
+    return 's';
+  case 29:
+    return 't';
+  case 30:
+    return 'u';
+  case 31:
+    return 'v';
+  case 32:
+    return 'w';
+  case 33:
+    return 'x';
+  case 34:
+    return 'y';
+  case 35:
+    return 'z';
+  default:
+    return '!';
+  }
+}
+
+LIBC_INLINE static constexpr bool isspace(int ch) {
+  switch (ch) {
+  case ' ':
+  case '\t':
+  case '\n':
+  case '\v':
+  case '\f':
+  case '\r':
+    return true;
+  default:
+    return false;
+  }
+}
+
+// not yet encoding independent.
+LIBC_INLINE static constexpr bool isgraph(int ch) {
+  return 0x20 < ch && ch < 0x7f;
 }
 
 } // namespace internal
diff --git a/src/__support/fixed_point/fx_bits.h b/src/__support/fixed_point/fx_bits.h
index 225ea41..b05f46b 100644
--- a/src/__support/fixed_point/fx_bits.h
+++ b/src/__support/fixed_point/fx_bits.h
@@ -11,9 +11,10 @@
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
 #include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/limits.h" // numeric_limits
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h"   // LIBC_INLINE
+#include "src/__support/macros/config.h"       // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/__support/math_extras.h"
 
@@ -50,6 +51,12 @@ private:
   static constexpr StorageType SIGN_MASK =
       (fx_rep::SIGN_LEN == 0 ? 0 : StorageType(1) << SIGN_OFFSET);
 
+  // mask for <integral | fraction>
+  static constexpr StorageType VALUE_MASK = INTEGRAL_MASK | FRACTION_MASK;
+
+  // mask for <sign | integral | fraction>
+  static constexpr StorageType TOTAL_MASK = SIGN_MASK | VALUE_MASK;
+
 public:
   LIBC_INLINE constexpr FXBits() = default;
 
@@ -74,6 +81,12 @@ public:
     return (value & INTEGRAL_MASK) >> INTEGRAL_OFFSET;
   }
 
+  // returns complete bitstring representation the fixed point number
+  // the bitstring is of the form: padding | sign | integral | fraction
+  LIBC_INLINE constexpr StorageType get_bits() {
+    return (value & TOTAL_MASK) >> FRACTION_OFFSET;
+  }
+
   // TODO: replace bool with Sign
   LIBC_INLINE constexpr bool get_sign() {
     return static_cast<bool>((value & SIGN_MASK) >> SIGN_OFFSET);
@@ -163,6 +176,31 @@ template <typename T> LIBC_INLINE constexpr T round(T x, int n) {
   return bit_and((x + round_bit), rounding_mask);
 }
 
+// count leading sign bits
+// TODO: support fixed_point_padding
+template <typename T>
+LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_fixed_point_v<T>, int>
+countls(T f) {
+  using FXRep = FXRep<T>;
+  using BitType = typename FXRep::StorageType;
+  using FXBits = FXBits<T>;
+
+  if constexpr (FXRep::SIGN_LEN > 0) {
+    if (f < 0)
+      f = bit_not(f);
+  }
+
+  BitType value_bits = FXBits(f).get_bits();
+  return cpp::countl_zero(value_bits) - FXRep::SIGN_LEN;
+}
+
+// fixed-point to integer conversion
+template <typename T, typename XType>
+LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_fixed_point_v<T>, XType>
+bitsfx(T f) {
+  return cpp::bit_cast<XType, T>(f);
+}
+
 } // namespace fixed_point
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/__support/fixed_point/fx_rep.h b/src/__support/fixed_point/fx_rep.h
index 1869389..7227fff 100644
--- a/src/__support/fixed_point/fx_rep.h
+++ b/src/__support/fixed_point/fx_rep.h
@@ -43,8 +43,8 @@ template <> struct FXRep<short fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = SFRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return SFRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return SFRACT_MAX; }
@@ -63,8 +63,8 @@ template <> struct FXRep<unsigned short fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = USFRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return USFRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return USFRACT_MAX; }
@@ -83,8 +83,8 @@ template <> struct FXRep<fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = FRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return FRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return FRACT_MAX; }
@@ -103,8 +103,8 @@ template <> struct FXRep<unsigned fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = UFRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return UFRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return UFRACT_MAX; }
@@ -123,8 +123,8 @@ template <> struct FXRep<long fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = LFRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return LFRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return LFRACT_MAX; }
@@ -143,8 +143,8 @@ template <> struct FXRep<unsigned long fract> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = 0;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = ULFRACT_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return ULFRACT_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return ULFRACT_MAX; }
@@ -163,8 +163,8 @@ template <> struct FXRep<short accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = SACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = SACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return SACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return SACCUM_MAX; }
@@ -183,8 +183,8 @@ template <> struct FXRep<unsigned short accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = USACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = USACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return USACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return USACCUM_MAX; }
@@ -203,8 +203,8 @@ template <> struct FXRep<accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = ACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = ACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return ACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return ACCUM_MAX; }
@@ -223,8 +223,8 @@ template <> struct FXRep<unsigned accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = UACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = UACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return UACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return UACCUM_MAX; }
@@ -243,8 +243,8 @@ template <> struct FXRep<long accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 1;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = LACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = LACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return LACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return LACCUM_MAX; }
@@ -263,8 +263,8 @@ template <> struct FXRep<unsigned long accum> {
   LIBC_INLINE_VAR static constexpr int SIGN_LEN = 0;
   LIBC_INLINE_VAR static constexpr int INTEGRAL_LEN = ULACCUM_IBIT;
   LIBC_INLINE_VAR static constexpr int FRACTION_LEN = ULACCUM_FBIT;
-  LIBC_INLINE_VAR static constexpr int TOTAL_LEN =
-      SIGN_LEN + INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int VALUE_LEN = INTEGRAL_LEN + FRACTION_LEN;
+  LIBC_INLINE_VAR static constexpr int TOTAL_LEN = SIGN_LEN + VALUE_LEN;
 
   LIBC_INLINE static constexpr Type MIN() { return ULACCUM_MIN; }
   LIBC_INLINE static constexpr Type MAX() { return ULACCUM_MAX; }
diff --git a/src/__support/fixedvector.h b/src/__support/fixedvector.h
index 7ac0c23..34601f8 100644
--- a/src/__support/fixedvector.h
+++ b/src/__support/fixedvector.h
@@ -10,9 +10,10 @@
 #define LLVM_LIBC_SRC___SUPPORT_FIXEDVECTOR_H
 
 #include "src/__support/CPP/array.h"
-
 #include "src/__support/CPP/iterator.h"
+#include "src/__support/libc_assert.h"
 #include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_memset.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -23,27 +24,32 @@ template <typename T, size_t CAPACITY> class FixedVector {
   size_t item_count = 0;
 
 public:
-  constexpr FixedVector() = default;
+  LIBC_INLINE constexpr FixedVector() = default;
 
   using iterator = typename cpp::array<T, CAPACITY>::iterator;
-  constexpr FixedVector(iterator begin, iterator end) : store{}, item_count{} {
+  LIBC_INLINE constexpr FixedVector(iterator begin, iterator end)
+      : store{}, item_count{} {
+    LIBC_ASSERT(begin + CAPACITY >= end);
     for (; begin != end; ++begin)
       push_back(*begin);
   }
 
   using const_iterator = typename cpp::array<T, CAPACITY>::const_iterator;
-  constexpr FixedVector(const_iterator begin, const_iterator end)
+  LIBC_INLINE constexpr FixedVector(const_iterator begin, const_iterator end)
       : store{}, item_count{} {
+    LIBC_ASSERT(begin + CAPACITY >= end);
     for (; begin != end; ++begin)
       push_back(*begin);
   }
 
-  constexpr FixedVector(size_t count, const T &value) : store{}, item_count{} {
+  LIBC_INLINE constexpr FixedVector(size_t count, const T &value)
+      : store{}, item_count{} {
+    LIBC_ASSERT(count <= CAPACITY);
     for (size_t i = 0; i < count; ++i)
       push_back(value);
   }
 
-  constexpr bool push_back(const T &obj) {
+  LIBC_INLINE constexpr bool push_back(const T &obj) {
     if (item_count == CAPACITY)
       return false;
     store[item_count] = obj;
@@ -51,27 +57,43 @@ public:
     return true;
   }
 
-  constexpr const T &back() const { return store[item_count - 1]; }
+  LIBC_INLINE constexpr const T &back() const {
+    LIBC_ASSERT(!empty());
+    return store[item_count - 1];
+  }
 
-  constexpr T &back() { return store[item_count - 1]; }
+  LIBC_INLINE constexpr T &back() {
+    LIBC_ASSERT(!empty());
+    return store[item_count - 1];
+  }
 
-  constexpr bool pop_back() {
+  LIBC_INLINE constexpr bool pop_back() {
     if (item_count == 0)
       return false;
+    inline_memset(&store[item_count - 1], 0, sizeof(T));
     --item_count;
     return true;
   }
 
-  constexpr T &operator[](size_t idx) { return store[idx]; }
+  LIBC_INLINE constexpr T &operator[](size_t idx) {
+    LIBC_ASSERT(idx < item_count);
+    return store[idx];
+  }
 
-  constexpr const T &operator[](size_t idx) const { return store[idx]; }
+  LIBC_INLINE constexpr const T &operator[](size_t idx) const {
+    LIBC_ASSERT(idx < item_count);
+    return store[idx];
+  }
 
-  constexpr bool empty() const { return item_count == 0; }
+  LIBC_INLINE constexpr bool empty() const { return item_count == 0; }
 
-  constexpr size_t size() const { return item_count; }
+  LIBC_INLINE constexpr size_t size() const { return item_count; }
 
   // Empties the store for all practical purposes.
-  constexpr void reset() { item_count = 0; }
+  LIBC_INLINE constexpr void reset() {
+    inline_memset(store.data(), 0, sizeof(T) * item_count);
+    item_count = 0;
+  }
 
   // This static method does not free up the resources held by |store|,
   // say by calling `free` or something similar. It just does the equivalent
@@ -81,7 +103,9 @@ public:
   // dynamically allocated storate. So, the `destroy` method like this
   // matches the `destroy` API of those other data structures so that users
   // can easily swap one data structure for the other.
-  static void destroy(FixedVector<T, CAPACITY> *store) { store->reset(); }
+  LIBC_INLINE static void destroy(FixedVector<T, CAPACITY> *store) {
+    store->reset();
+  }
 
   using reverse_iterator = typename cpp::array<T, CAPACITY>::reverse_iterator;
   LIBC_INLINE constexpr reverse_iterator rbegin() {
diff --git a/src/__support/float_to_string.h b/src/__support/float_to_string.h
index d5de6f3..4b03eaf 100644
--- a/src/__support/float_to_string.h
+++ b/src/__support/float_to_string.h
@@ -287,7 +287,7 @@ LIBC_INLINE UInt<MID_INT_SIZE> get_table_negative(int exponent, size_t i) {
   size_t ten_blocks = i;
   size_t five_blocks = 0;
   if (shift_amount < 0) {
-    int block_shifts = (-shift_amount) / BLOCK_SIZE;
+    int block_shifts = (-shift_amount) / static_cast<int>(BLOCK_SIZE);
     if (block_shifts < static_cast<int>(ten_blocks)) {
       ten_blocks = ten_blocks - block_shifts;
       five_blocks = block_shifts;
diff --git a/src/__support/freelist_heap.cpp b/src/__support/freelist_heap.cpp
new file mode 100644
index 0000000..4deb0e0
--- /dev/null
+++ b/src/__support/freelist_heap.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation for freelist_heap ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+static LIBC_CONSTINIT FreeListHeap freelist_heap_symbols;
+FreeListHeap *freelist_heap = &freelist_heap_symbols;
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/freelist_heap.h b/src/__support/freelist_heap.h
index 8fa3625..d586851 100644
--- a/src/__support/freelist_heap.h
+++ b/src/__support/freelist_heap.h
@@ -89,28 +89,14 @@ LIBC_INLINE void *FreeListHeap::allocate_impl(size_t alignment, size_t size) {
   if (!is_initialized)
     init();
 
-  size_t request_size = size;
-
-  // TODO: usable_space should always be aligned to max_align_t.
-  if (alignment > alignof(max_align_t) ||
-      (Block::BLOCK_OVERHEAD % alignof(max_align_t) != 0)) {
-    // TODO: This bound isn't precisely calculated yet. It assumes one extra
-    // Block::ALIGNMENT to accomodate the possibility for padding block
-    // overhead. (alignment - 1) ensures that there is an aligned point
-    // somewhere in usable_space, but this isn't tight either, since
-    // usable_space is also already somewhat aligned.
-    if (add_overflow(size, (alignment - 1) + Block::ALIGNMENT, request_size))
-      return nullptr;
-  }
+  size_t request_size = Block::min_size_for_allocation(alignment, size);
+  if (!request_size)
+    return nullptr;
 
   Block *block = free_store.remove_best_fit(request_size);
   if (!block)
     return nullptr;
 
-  LIBC_ASSERT(block->can_allocate(alignment, size) &&
-              "block should always be large enough to allocate at the correct "
-              "alignment");
-
   auto block_info = Block::allocate(block, alignment, size);
   if (block_info.next)
     free_store.insert(block_info.next);
@@ -135,6 +121,9 @@ LIBC_INLINE void *FreeListHeap::aligned_allocate(size_t alignment,
   if (size % alignment != 0)
     return nullptr;
 
+  // The minimum alignment supported by Block is max_align_t.
+  alignment = cpp::max(alignment, alignof(max_align_t));
+
   return allocate_impl(alignment, size);
 }
 
diff --git a/src/__support/freestore.h b/src/__support/freestore.h
index 97197dd..09f2479 100644
--- a/src/__support/freestore.h
+++ b/src/__support/freestore.h
@@ -40,13 +40,12 @@ public:
   Block *remove_best_fit(size_t size);
 
 private:
-  static constexpr size_t ALIGNMENT = alignof(max_align_t);
   static constexpr size_t MIN_OUTER_SIZE =
-      align_up(Block::BLOCK_OVERHEAD + sizeof(FreeList::Node), ALIGNMENT);
+      align_up(sizeof(Block) + sizeof(FreeList::Node), alignof(max_align_t));
   static constexpr size_t MIN_LARGE_OUTER_SIZE =
-      align_up(Block::BLOCK_OVERHEAD + sizeof(FreeTrie::Node), ALIGNMENT);
+      align_up(sizeof(Block) + sizeof(FreeTrie::Node), alignof(max_align_t));
   static constexpr size_t NUM_SMALL_SIZES =
-      (MIN_LARGE_OUTER_SIZE - MIN_OUTER_SIZE) / ALIGNMENT;
+      (MIN_LARGE_OUTER_SIZE - MIN_OUTER_SIZE) / alignof(max_align_t);
 
   LIBC_INLINE static bool too_small(Block *block) {
     return block->outer_size() < MIN_OUTER_SIZE;
@@ -99,7 +98,8 @@ LIBC_INLINE Block *FreeStore::remove_best_fit(size_t size) {
 
 LIBC_INLINE FreeList &FreeStore::small_list(Block *block) {
   LIBC_ASSERT(is_small(block) && "only legal for small blocks");
-  return small_lists[(block->outer_size() - MIN_OUTER_SIZE) / ALIGNMENT];
+  return small_lists[(block->outer_size() - MIN_OUTER_SIZE) /
+                     alignof(max_align_t)];
 }
 
 LIBC_INLINE FreeList *FreeStore::find_best_small_fit(size_t size) {
diff --git a/src/__support/high_precision_decimal.h b/src/__support/high_precision_decimal.h
index 20088d6..cb4b50c 100644
--- a/src/__support/high_precision_decimal.h
+++ b/src/__support/high_precision_decimal.h
@@ -178,9 +178,11 @@ private:
       if (digit_index >= this->num_digits) {
         return new_digits - 1;
       }
-      if (this->digits[digit_index] != power_of_five[digit_index] - '0') {
+      if (this->digits[digit_index] !=
+          internal::b36_char_to_int(power_of_five[digit_index])) {
         return new_digits -
-               ((this->digits[digit_index] < power_of_five[digit_index] - '0')
+               ((this->digits[digit_index] <
+                 internal::b36_char_to_int(power_of_five[digit_index]))
                     ? 1
                     : 0);
       }
@@ -262,7 +264,7 @@ private:
   LIBC_INLINE void left_shift(uint32_t shift_amount) {
     uint32_t new_digits = this->get_num_new_digits(shift_amount);
 
-    int32_t read_index = this->num_digits - 1;
+    int32_t read_index = static_cast<int32_t>(this->num_digits - 1);
     uint32_t write_index = this->num_digits + new_digits;
 
     uint64_t accumulator = 0;
@@ -327,7 +329,7 @@ public:
         if (saw_dot) {
           break;
         }
-        this->decimal_point = total_digits;
+        this->decimal_point = static_cast<int32_t>(total_digits);
         saw_dot = true;
       } else {
         if (num_string[num_cur] == '0' && this->num_digits == 0) {
@@ -337,8 +339,8 @@ public:
         }
         ++total_digits;
         if (this->num_digits < MAX_NUM_DIGITS) {
-          this->digits[this->num_digits] =
-              static_cast<uint8_t>(num_string[num_cur] - '0');
+          this->digits[this->num_digits] = static_cast<uint8_t>(
+              internal::b36_char_to_int(num_string[num_cur]));
           ++this->num_digits;
         } else if (num_string[num_cur] != '0') {
           this->truncated = true;
@@ -348,7 +350,7 @@ public:
     }
 
     if (!saw_dot)
-      this->decimal_point = total_digits;
+      this->decimal_point = static_cast<int32_t>(total_digits);
 
     if (num_cur < num_len &&
         (num_string[num_cur] == 'e' || num_string[num_cur] == 'E')) {
@@ -391,7 +393,7 @@ public:
         this->left_shift(MAX_SHIFT_AMOUNT);
         shift_amount -= MAX_SHIFT_AMOUNT;
       }
-      this->left_shift(shift_amount);
+      this->left_shift(static_cast<uint32_t>(shift_amount));
     }
     // Right
     else {
@@ -399,7 +401,7 @@ public:
         this->right_shift(MAX_SHIFT_AMOUNT);
         shift_amount += MAX_SHIFT_AMOUNT;
       }
-      this->right_shift(-shift_amount);
+      this->right_shift(static_cast<uint32_t>(-shift_amount));
     }
   }
 
@@ -422,8 +424,8 @@ public:
       result *= 10;
       ++cur_digit;
     }
-    return result + static_cast<unsigned int>(
-                        this->should_round_up(this->decimal_point, round));
+    return result +
+           static_cast<T>(this->should_round_up(this->decimal_point, round));
   }
 
   // Extra functions for testing.
diff --git a/src/__support/integer_literals.h b/src/__support/integer_literals.h
index 4c5c4c4..f68b7ef 100644
--- a/src/__support/integer_literals.h
+++ b/src/__support/integer_literals.h
@@ -13,12 +13,13 @@
 #ifndef LLVM_LIBC_SRC___SUPPORT_INTEGER_LITERALS_H
 #define LLVM_LIBC_SRC___SUPPORT_INTEGER_LITERALS_H
 
-#include "src/__support/CPP/limits.h"        // CHAR_BIT
+#include "src/__support/CPP/limits.h" // CHAR_BIT
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
 #include "src/__support/macros/config.h"
-#include "src/__support/uint128.h"           // UInt128
-#include <stddef.h>                          // size_t
-#include <stdint.h>                          // uintxx_t
+#include "src/__support/uint128.h" // UInt128
+#include <stddef.h>                // size_t
+#include <stdint.h>                // uintxx_t
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -46,7 +47,7 @@ LIBC_INLINE constexpr T accumulate(int base, const uint8_t *digits,
                                    size_t size) {
   T value{};
   for (; size; ++digits, --size) {
-    value *= base;
+    value *= static_cast<unsigned int>(base);
     value += *digits;
   }
   return value;
@@ -75,26 +76,13 @@ template <typename T, int base> struct DigitBuffer {
       push(*str);
   }
 
-  // Returns the digit for a particular character.
-  // Returns INVALID_DIGIT if the character is invalid.
-  LIBC_INLINE static constexpr uint8_t get_digit_value(const char c) {
-    const auto to_lower = [](char c) { return c | 32; };
-    const auto is_digit = [](char c) { return c >= '0' && c <= '9'; };
-    const auto is_alpha = [](char c) {
-      return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
-    };
-    if (is_digit(c))
-      return static_cast<uint8_t>(c - '0');
-    if (base > 10 && is_alpha(c))
-      return static_cast<uint8_t>(to_lower(c) - 'a' + 10);
-    return INVALID_DIGIT;
-  }
-
   // Adds a single character to this buffer.
   LIBC_INLINE constexpr void push(char c) {
     if (c == '\'')
       return; // ' is valid but not taken into account.
-    const uint8_t value = get_digit_value(c);
+    const int b36_val = internal::b36_char_to_int(c);
+    const uint8_t value = static_cast<uint8_t>(
+        b36_val < base && (b36_val != 0 || c == '0') ? b36_val : INVALID_DIGIT);
     if (value == INVALID_DIGIT || size >= MAX_DIGITS) {
       // During constant evaluation `__builtin_unreachable` will halt the
       // compiler as it is not executable. This is preferable over `assert` that
diff --git a/src/__support/integer_to_string.h b/src/__support/integer_to_string.h
index 40d45a0..65bdcf1 100644
--- a/src/__support/integer_to_string.h
+++ b/src/__support/integer_to_string.h
@@ -69,6 +69,7 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/big_int.h" // make_integral_or_big_int_unsigned_t
 #include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 
 namespace LIBC_NAMESPACE_DECL {
@@ -163,6 +164,170 @@ template <size_t radix> using Custom = details::Fmt<radix>;
 
 } // namespace radix
 
+// Extract the low-order decimal digit from a value of integer type T. The
+// returned value is the digit itself, from 0 to 9. The input value is passed
+// by reference, and modified by dividing by 10, so that iterating this
+// function extracts all the digits of the original number one at a time from
+// low to high.
+template <typename T>
+LIBC_INLINE cpp::enable_if_t<cpp::is_integral_v<T>, uint8_t>
+extract_decimal_digit(T &value) {
+  const uint8_t digit(static_cast<uint8_t>(value % 10));
+  // For built-in integer types, we assume that an adequately fast division is
+  // available. If hardware division isn't implemented, then with a divisor
+  // known at compile time the compiler might be able to generate an optimized
+  // sequence instead.
+  value /= 10;
+  return digit;
+}
+
+// A specialization of extract_decimal_digit for the BigInt type in big_int.h,
+// avoiding the use of general-purpose BigInt division which is very slow.
+template <typename T>
+LIBC_INLINE cpp::enable_if_t<is_big_int_v<T>, uint8_t>
+extract_decimal_digit(T &value) {
+  // There are two essential ways you can turn n into (n/10,n%10). One is
+  // ordinary integer division. The other is a modular-arithmetic approach in
+  // which you first compute n%10 by bit twiddling, then subtract it off to get
+  // a value that is definitely a multiple of 10. Then you divide that by 10 in
+  // two steps: shift right to divide off a factor of 2, and then divide off a
+  // factor of 5 by multiplying by the modular inverse of 5 mod 2^BITS. (That
+  // last step only works if you know there's no remainder, which is why you
+  // had to subtract off the output digit first.)
+  //
+  // Either approach can be made to work in linear time. This code uses the
+  // modular-arithmetic technique, because the other approach either does a lot
+  // of integer divisions (requiring a fast hardware divider), or else uses a
+  // "multiply by an approximation to the reciprocal" technique which depends
+  // on careful error analysis which might go wrong in an untested edge case.
+
+  using Word = typename T::word_type;
+
+  // Find the remainder (value % 10). We do this by breaking up the input
+  // integer into chunks of size WORD_SIZE/2, so that the sum of them doesn't
+  // overflow a Word. Then we sum all the half-words times 6, except the bottom
+  // one, which is added to that sum without scaling.
+  //
+  // Why 6? Because you can imagine that the original number had the form
+  //
+  //   halfwords[0] + K*halfwords[1] + K^2*halfwords[2] + ...
+  //
+  // where K = 2^(WORD_SIZE/2). Since WORD_SIZE is expected to be a multiple of
+  // 8, that makes WORD_SIZE/2 a multiple of 4, so that K is a power of 16. And
+  // all powers of 16 (larger than 1) are congruent to 6 mod 10, by induction:
+  // 16 itself is, and 6^2=36 is also congruent to 6.
+  Word acc_remainder = 0;
+  constexpr Word HALFWORD_BITS = T::WORD_SIZE / 2;
+  constexpr Word HALFWORD_MASK = ((Word(1) << HALFWORD_BITS) - 1);
+  // Sum both halves of all words except the low one.
+  for (size_t i = 1; i < T::WORD_COUNT; i++) {
+    acc_remainder += value.val[i] >> HALFWORD_BITS;
+    acc_remainder += value.val[i] & HALFWORD_MASK;
+  }
+  // Add the high half of the low word. Then we have everything that needs to
+  // be multiplied by 6, so do that.
+  acc_remainder += value.val[0] >> HALFWORD_BITS;
+  acc_remainder *= 6;
+  // Having multiplied it by 6, add the lowest half-word, and then reduce mod
+  // 10 by normal integer division to finish.
+  acc_remainder += value.val[0] & HALFWORD_MASK;
+  uint8_t digit = static_cast<uint8_t>(acc_remainder % 10);
+
+  // Now we have the output digit. Subtract it from the input value, and shift
+  // right to divide by 2.
+  value -= digit;
+  value >>= 1;
+
+  // Now all that's left is to multiply by the inverse of 5 mod 2^BITS. No
+  // matter what the value of BITS, the inverse of 5 has the very convenient
+  // form 0xCCCC...CCCD, with as many C hex digits in the middle as necessary.
+  //
+  // We could construct a second BigInt with all words 0xCCCCCCCCCCCCCCCC,
+  // increment the bottom word, and call a general-purpose multiply function.
+  // But we can do better, by taking advantage of the regularity: we can do
+  // this particular operation in linear time, whereas a general multiplier
+  // would take superlinear time (quadratic in small cases).
+  //
+  // To begin with, instead of computing n*0xCCCC...CCCD, we'll compute
+  // n*0xCCCC...CCCC and then add it to the original n. Then all the words of
+  // the multiplier have the same value 0xCCCCCCCCCCCCCCCC, which I'll just
+  // denote as C. If we also write t = 2^WORD_SIZE, and imagine (as an example)
+  // that the input number has three words x,y,z with x being the low word,
+  // then we're computing
+  //
+  //   (x + y t + z t^2) * (C + C t + C t^2)
+  //
+  // = x C + y C t + z C t^2
+  //       + x C t + y C t^2 + z C t^3
+  //               + x C t^2 + y C t^3 + z C t^4
+  //
+  // but we're working mod t^3, so the high-order terms vanish and this becomes
+  //
+  //   x C + y C t + z C t^2
+  //       + x C t + y C t^2
+  //               + x C t^2
+  //
+  // = x C + (x+y) C t + (x+y+z) C t^2
+  //
+  // So all you have to do is to work from the low word of the integer upwards,
+  // accumulating C times the sum of all the words you've seen so far to get
+  // x*C, (x+y)*C, (x+y+z)*C and so on. In each step you add another product to
+  // the accumulator, and add the accumulator to the corresponding word of the
+  // original number (so that we end up with value*CCCD, not just value*CCCC).
+  //
+  // If you do that literally, then your accumulator has to be three words
+  // wide, because the sum of words can overflow into a second word, and
+  // multiplying by C adds another word. But we can do slightly better by
+  // breaking each product word*C up into a bottom half and a top half. If we
+  // write x*C = xl + xh*t, and similarly for y and z, then our sum becomes
+  //
+  //   (xl + xh t) + (yl + yh t) t + (zl + zh t) t^2
+  //               + (xl + xh t) t + (yl + yh t) t^2
+  //                               + (xl + xh t) t^2
+  //
+  // and if you expand out again, collect terms, and discard t^3 terms, you get
+  //
+  //   (xl)
+  // + (xl + xh + yl) t
+  // + (xl + xh + yl + yh + zl) t^2
+  //
+  // in which each coefficient is the sum of all the low words of the products
+  // up to _and including_ the current word, plus all the high words up to but
+  // _not_ including the current word. So now you only have to retain two words
+  // of sum instead of three.
+  //
+  // We do this entire procedure in a single in-place pass over the input
+  // number, reading each word to make its product with C and then adding the
+  // low word of the accumulator to it.
+  constexpr Word C = Word(-1) / 5 * 4; // calculate 0xCCCC as 4/5 of 0xFFFF
+  Word acc_lo = 0, acc_hi = 0; // accumulator of all the half-products so far
+  Word carry_bit, carry_word = 0;
+
+  for (size_t i = 0; i < T::WORD_COUNT; i++) {
+    // Make the two-word product of C with the current input word.
+    multiword::DoubleWide<Word> product = multiword::mul2(C, value.val[i]);
+
+    // Add the low half of the product to our accumulator, but not yet the high
+    // half.
+    acc_lo = add_with_carry<Word>(acc_lo, product[0], 0, carry_bit);
+    acc_hi += carry_bit;
+
+    // Now the accumulator contains exactly the value we need to add to the
+    // current input word. Add it, plus any carries from lower words, and make
+    // a new word of carry data to propagate into the next iteration.
+    value.val[i] = add_with_carry<Word>(value.val[i], carry_word, 0, carry_bit);
+    carry_word = acc_hi + carry_bit;
+    value.val[i] = add_with_carry<Word>(value.val[i], acc_lo, 0, carry_bit);
+    carry_word += carry_bit;
+
+    // Now add the high half of the current product to our accumulator.
+    acc_lo = add_with_carry<Word>(acc_lo, product[1], 0, carry_bit);
+    acc_hi += carry_bit;
+  }
+
+  return digit;
+}
+
 // See file header for documentation.
 template <typename T, typename Fmt = radix::Dec> class IntegerToString {
   static_assert(cpp::is_integral_v<T> || is_big_int_v<T>);
@@ -214,9 +379,9 @@ template <typename T, typename Fmt = radix::Dec> class IntegerToString {
     using UNSIGNED_T = make_integral_or_big_int_unsigned_t<T>;
 
     LIBC_INLINE static char digit_char(uint8_t digit) {
-      if (digit < 10)
-        return '0' + static_cast<char>(digit);
-      return (Fmt::IS_UPPERCASE ? 'A' : 'a') + static_cast<char>(digit - 10);
+      const int result = internal::int_to_b36_char(digit);
+      return static_cast<char>(Fmt::IS_UPPERCASE ? internal::toupper(result)
+                                                 : result);
     }
 
     LIBC_INLINE static void
@@ -228,10 +393,19 @@ template <typename T, typename Fmt = radix::Dec> class IntegerToString {
       }
     }
 
+    LIBC_INLINE static void
+    write_unsigned_number_dec(UNSIGNED_T value,
+                              details::BackwardStringBufferWriter &sink) {
+      while (sink.ok() && value != 0) {
+        const uint8_t digit = extract_decimal_digit(value);
+        sink.push(digit_char(digit));
+      }
+    }
+
     // Returns the absolute value of 'value' as 'UNSIGNED_T'.
     LIBC_INLINE static UNSIGNED_T abs(T value) {
       if (cpp::is_unsigned_v<T> || value >= 0)
-        return value; // already of the right sign.
+        return static_cast<UNSIGNED_T>(value); // already of the right sign.
 
       // Signed integers are asymmetric (e.g., int8_t  [-128, 127]).
       // Thus negating the type's minimum value would overflow.
@@ -248,14 +422,15 @@ template <typename T, typename Fmt = radix::Dec> class IntegerToString {
       if (value == cpp::numeric_limits<T>::min()) {
         return cpp::bit_cast<UNSIGNED_T>(value);
       } else {
-        return -value; // legal and representable both as T and UNSIGNED_T.`
+        return static_cast<UNSIGNED_T>(
+            -value); // legal and representable both as T and UNSIGNED_T.`
       }
     }
 
     LIBC_INLINE static void write(T value,
                                   details::BackwardStringBufferWriter &sink) {
       if constexpr (Fmt::BASE == 10) {
-        write_unsigned_number(abs(value), sink);
+        write_unsigned_number_dec(abs(value), sink);
       } else {
         write_unsigned_number(static_cast<UNSIGNED_T>(value), sink);
       }
diff --git a/src/__support/macros/null_check.h b/src/__support/macros/null_check.h
index 400f7d8..eda19f8 100644
--- a/src/__support/macros/null_check.h
+++ b/src/__support/macros/null_check.h
@@ -14,15 +14,10 @@
 #include "src/__support/macros/sanitizer.h"
 
 #if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
-// Use volatile to prevent undefined behavior of dereferencing nullptr.
-// Intentionally crashing with SIGSEGV.
-#define LIBC_CRASH_ON_NULLPTR(PTR)                                             \
+#define LIBC_CRASH_ON_NULLPTR(ptr)                                             \
   do {                                                                         \
-    if (LIBC_UNLIKELY(PTR == nullptr)) {                                       \
-      volatile auto *crashing = PTR;                                           \
-      [[maybe_unused]] volatile auto crash = *crashing;                        \
+    if (LIBC_UNLIKELY((ptr) == nullptr))                                       \
       __builtin_trap();                                                        \
-    }                                                                          \
   } while (0)
 #else
 #define LIBC_CRASH_ON_NULLPTR(ptr)                                             \
diff --git a/src/__support/macros/optimization.h b/src/__support/macros/optimization.h
index 41ecd2b..253843e 100644
--- a/src/__support/macros/optimization.h
+++ b/src/__support/macros/optimization.h
@@ -45,10 +45,11 @@ LIBC_INLINE constexpr bool expects_bool_condition(T value, T expected) {
 #define LIBC_MATH_FAST                                                         \
   (LIBC_MATH_SKIP_ACCURATE_PASS | LIBC_MATH_SMALL_TABLES |                     \
    LIBC_MATH_NO_ERRNO | LIBC_MATH_NO_EXCEPT)
+#define LIBC_MATH_INTERMEDIATE_COMP_IN_FLOAT 0x10
 
 #ifndef LIBC_MATH
 #define LIBC_MATH 0
-#else
+#endif // LIBC_MATH
 
 #if (LIBC_MATH & LIBC_MATH_SKIP_ACCURATE_PASS)
 #define LIBC_MATH_HAS_SKIP_ACCURATE_PASS
@@ -58,6 +59,8 @@ LIBC_INLINE constexpr bool expects_bool_condition(T value, T expected) {
 #define LIBC_MATH_HAS_SMALL_TABLES
 #endif
 
-#endif // LIBC_MATH
+#if (LIBC_MATH & LIBC_MATH_INTERMEDIATE_COMP_IN_FLOAT)
+#define LIBC_MATH_HAS_INTERMEDIATE_COMP_IN_FLOAT
+#endif
 
 #endif // LLVM_LIBC_SRC___SUPPORT_MACROS_OPTIMIZATION_H
diff --git a/src/__support/macros/properties/complex_types.h b/src/__support/macros/properties/complex_types.h
index 3f4a764..ede4d6b 100644
--- a/src/__support/macros/properties/complex_types.h
+++ b/src/__support/macros/properties/complex_types.h
@@ -22,4 +22,9 @@
 // LIBC_TYPES_HAS_CFLOAT128 and 'cfloat128' type are provided by
 // "include/llvm-libc-types/cfloat128.h"
 
+#if defined(LIBC_TYPES_HAS_CFLOAT128) &&                                       \
+    !defined(LIBC_TYPES_CFLOAT128_IS_COMPLEX_LONG_DOUBLE)
+#define LIBC_TYPES_CFLOAT128_IS_NOT_COMPLEX_LONG_DOUBLE
+#endif
+
 #endif // LLVM_LIBC_SRC___SUPPORT_MACROS_PROPERTIES_CTYPES_H
diff --git a/src/__support/macros/properties/cpu_features.h b/src/__support/macros/properties/cpu_features.h
index d2cea36..1714775 100644
--- a/src/__support/macros/properties/cpu_features.h
+++ b/src/__support/macros/properties/cpu_features.h
@@ -45,6 +45,21 @@
 #if defined(__ARM_FEATURE_FMA) || (defined(__AVX2__) && defined(__FMA__)) ||   \
     defined(__NVPTX__) || defined(__AMDGPU__) || defined(__LIBC_RISCV_USE_FMA)
 #define LIBC_TARGET_CPU_HAS_FMA
+// Provide a more fine-grained control of FMA instruction for ARM targets.
+#if defined(__ARM_FP)
+#if (__ARM_FP & 0x2)
+#define LIBC_TARGET_CPU_HAS_FMA_HALF
+#endif // LIBC_TARGET_CPU_HAS_FMA_HALF
+#if (__ARM_FP & 0x4)
+#define LIBC_TARGET_CPU_HAS_FMA_FLOAT
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
+#if (__ARM_FP & 0x8)
+#define LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+#else
+#define LIBC_TARGET_CPU_HAS_FMA_FLOAT
+#define LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+#endif
 #endif
 
 #if defined(LIBC_TARGET_ARCH_IS_AARCH64) ||                                    \
diff --git a/src/__support/macros/properties/os.h b/src/__support/macros/properties/os.h
index 1c8fd57..807ce18 100644
--- a/src/__support/macros/properties/os.h
+++ b/src/__support/macros/properties/os.h
@@ -25,18 +25,6 @@
 #define LIBC_TARGET_OS_IS_WINDOWS
 #endif
 
-#if (defined(__apple__) || defined(__APPLE__) || defined(__MACH__))
-// From https://stackoverflow.com/a/49560690
-#include "TargetConditionals.h"
-#if defined(TARGET_OS_OSX)
-#define LIBC_TARGET_OS_IS_MACOS
-#endif
-#if defined(TARGET_OS_IPHONE)
-// This is set for any non-Mac Apple products (IOS, TV, WATCH)
-#define LIBC_TARGET_OS_IS_IPHONE
-#endif
-#endif
-
 #if defined(__Fuchsia__)
 #define LIBC_TARGET_OS_IS_FUCHSIA
 #endif
diff --git a/src/__support/macros/properties/types.h b/src/__support/macros/properties/types.h
index 30c742c..6293b9d 100644
--- a/src/__support/macros/properties/types.h
+++ b/src/__support/macros/properties/types.h
@@ -31,6 +31,11 @@
 #define LIBC_TYPES_LONG_DOUBLE_IS_DOUBLE_DOUBLE
 #endif
 
+#if defined(LIBC_TYPES_HAS_FLOAT128) &&                                        \
+    !defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
+#define LIBC_TYPES_FLOAT128_IS_NOT_LONG_DOUBLE
+#endif
+
 // int64 / uint64 support
 #if defined(UINT64_MAX)
 #define LIBC_TYPES_HAS_INT64
diff --git a/src/__support/math_extras.h b/src/__support/math_extras.h
index 6f4a006..47df2a4 100644
--- a/src/__support/math_extras.h
+++ b/src/__support/math_extras.h
@@ -146,8 +146,7 @@ first_trailing_zero(T value) {
 template <typename T>
 [[nodiscard]] LIBC_INLINE constexpr cpp::enable_if_t<cpp::is_unsigned_v<T>, int>
 first_trailing_one(T value) {
-  return value == cpp::numeric_limits<T>::max() ? 0
-                                                : cpp::countr_zero(value) + 1;
+  return value == 0 ? 0 : cpp::countr_zero(value) + 1;
 }
 
 template <typename T>
diff --git a/src/__support/memory_size.h b/src/__support/memory_size.h
index cdd6a10..3d40b11 100644
--- a/src/__support/memory_size.h
+++ b/src/__support/memory_size.h
@@ -77,7 +77,8 @@ public:
     if (!cpp::has_single_bit(alignment) || alignment > MAX_MEM_SIZE || !valid())
       return SafeMemSize{type{-1}};
 
-    type offset = offset_to(value, alignment);
+    type offset =
+        static_cast<type>(offset_to(static_cast<size_t>(value), alignment));
 
     if (LIBC_UNLIKELY(offset > static_cast<type>(MAX_MEM_SIZE) - value))
       return SafeMemSize{type{-1}};
diff --git a/src/__support/sign.h b/src/__support/sign.h
index 4a629e4..e0de0e0 100644
--- a/src/__support/sign.h
+++ b/src/__support/sign.h
@@ -29,6 +29,8 @@ struct Sign {
   static const Sign POS;
   static const Sign NEG;
 
+  LIBC_INLINE constexpr Sign negate() const { return Sign(!is_negative); }
+
 private:
   LIBC_INLINE constexpr explicit Sign(bool is_negative)
       : is_negative(is_negative) {}
diff --git a/src/__support/str_to_float.h b/src/__support/str_to_float.h
index 80ea334..48c8830 100644
--- a/src/__support/str_to_float.h
+++ b/src/__support/str_to_float.h
@@ -108,11 +108,11 @@ eisel_lemire(ExpandedFloat<T> init_num,
   }
 
   // Normalization
-  uint32_t clz = cpp::countl_zero<StorageType>(mantissa);
+  uint32_t clz = static_cast<uint32_t>(cpp::countl_zero<StorageType>(mantissa));
   mantissa <<= clz;
 
-  int32_t exp2 =
-      exp10_to_exp2(exp10) + FPBits::STORAGE_LEN + FPBits::EXP_BIAS - clz;
+  int32_t exp2 = exp10_to_exp2(exp10) + FPBits::STORAGE_LEN + FPBits::EXP_BIAS -
+                 static_cast<int32_t>(clz);
 
   // Multiplication
   const uint64_t *power_of_ten =
@@ -225,8 +225,8 @@ eisel_lemire<long double>(ExpandedFloat<long double> init_num,
   }
 
   // Normalization
-  uint32_t clz = cpp::countl_zero(mantissa) -
-                 ((sizeof(UInt128) - sizeof(StorageType)) * CHAR_BIT);
+  int32_t clz = static_cast<int32_t>(cpp::countl_zero(mantissa)) -
+                ((sizeof(UInt128) - sizeof(StorageType)) * CHAR_BIT);
   mantissa <<= clz;
 
   int32_t exp2 =
@@ -802,7 +802,7 @@ LIBC_INLINE FloatConvertReturn<T> binary_exp_to_float(ExpandedFloat<T> init_num,
 
   // Handle subnormals.
   if (biased_exponent <= 0) {
-    amount_to_shift_right += 1 - biased_exponent;
+    amount_to_shift_right += static_cast<uint32_t>(1 - biased_exponent);
     biased_exponent = 0;
 
     if (amount_to_shift_right > FPBits::STORAGE_LEN) {
@@ -909,7 +909,7 @@ decimal_string_to_float(const char *__restrict src, const char DECIMAL_POINT,
       cpp::numeric_limits<StorageType>::max() / BASE;
   while (true) {
     if (isdigit(src[index])) {
-      uint32_t digit = src[index] - '0';
+      uint32_t digit = static_cast<uint32_t>(b36_char_to_int(src[index]));
       seen_digit = true;
 
       if (mantissa < bitstype_max_div_by_base) {
@@ -956,7 +956,7 @@ decimal_string_to_float(const char *__restrict src, const char DECIMAL_POINT,
       if (result.has_error())
         output.error = result.error;
       int32_t add_to_exponent = result.value;
-      index += result.parsed_len;
+      index += static_cast<size_t>(result.parsed_len);
 
       // Here we do this operation as int64 to avoid overflow.
       int64_t temp_exponent = static_cast<int64_t>(exponent) +
@@ -1020,7 +1020,7 @@ hexadecimal_string_to_float(const char *__restrict src,
       cpp::numeric_limits<StorageType>::max() / BASE;
   while (true) {
     if (isalnum(src[index])) {
-      uint32_t digit = b36_char_to_int(src[index]);
+      uint32_t digit = static_cast<uint32_t>(b36_char_to_int(src[index]));
       if (digit < BASE)
         seen_digit = true;
       else
@@ -1070,7 +1070,7 @@ hexadecimal_string_to_float(const char *__restrict src,
         output.error = result.error;
 
       int32_t add_to_exponent = result.value;
-      index += result.parsed_len;
+      index += static_cast<size_t>(result.parsed_len);
 
       // Here we do this operation as int64 to avoid overflow.
       int64_t temp_exponent = static_cast<int64_t>(exponent) +
@@ -1135,7 +1135,7 @@ LIBC_INLINE StrToNumResult<T> strtofloatingpoint(const char *__restrict src) {
 
   int error = 0;
 
-  ptrdiff_t index = first_non_whitespace(src) - src;
+  size_t index = static_cast<size_t>(first_non_whitespace(src) - src);
 
   if (src[index] == '+' || src[index] == '-') {
     sign = src[index];
@@ -1245,7 +1245,7 @@ LIBC_INLINE StrToNumResult<T> strtofloatingpoint(const char *__restrict src) {
   // special 80 bit long doubles. Otherwise it should be inlined out.
   set_implicit_bit<T>(result);
 
-  return {result.get_val(), index, error};
+  return {result.get_val(), static_cast<ptrdiff_t>(index), error};
 }
 
 template <class T> LIBC_INLINE StrToNumResult<T> strtonan(const char *arg) {
diff --git a/src/__support/str_to_integer.h b/src/__support/str_to_integer.h
index 86611f9..9212ad2 100644
--- a/src/__support/str_to_integer.h
+++ b/src/__support/str_to_integer.h
@@ -42,14 +42,6 @@ first_non_whitespace(const char *__restrict src,
   return src + src_cur;
 }
 
-LIBC_INLINE int b36_char_to_int(char input) {
-  if (isdigit(input))
-    return input - '0';
-  if (isalpha(input))
-    return (input | 32) + 10 - 'a';
-  return 0;
-}
-
 // checks if the next 3 characters of the string pointer are the start of a
 // hexadecimal number. Does not advance the string pointer.
 LIBC_INLINE bool
@@ -57,7 +49,7 @@ is_hex_start(const char *__restrict src,
              size_t src_len = cpp::numeric_limits<size_t>::max()) {
   if (src_len < 3)
     return false;
-  return *src == '0' && (*(src + 1) | 32) == 'x' && isalnum(*(src + 2)) &&
+  return *src == '0' && tolower(*(src + 1)) == 'x' && isalnum(*(src + 2)) &&
          b36_char_to_int(*(src + 2)) < 16;
 }
 
@@ -104,7 +96,7 @@ strtointeger(const char *__restrict src, int base,
   if (base < 0 || base == 1 || base > 36)
     return {0, 0, EINVAL};
 
-  src_cur = first_non_whitespace(src, src_len) - src;
+  src_cur = static_cast<size_t>(first_non_whitespace(src, src_len) - src);
 
   char result_sign = '+';
   if (src[src_cur] == '+' || src[src_cur] == '-') {
@@ -127,7 +119,7 @@ strtointeger(const char *__restrict src, int base,
   ResultType const abs_max =
       (is_positive ? cpp::numeric_limits<T>::max() : NEGATIVE_MAX);
   ResultType const abs_max_div_by_base =
-      static_cast<ResultType>(abs_max / base);
+      abs_max / static_cast<ResultType>(base);
 
   while (src_cur < src_len && isalnum(src[src_cur])) {
     int cur_digit = b36_char_to_int(src[src_cur]);
@@ -149,17 +141,17 @@ strtointeger(const char *__restrict src, int base,
       result = abs_max;
       error_val = ERANGE;
     } else {
-      result = static_cast<ResultType>(result * base);
+      result = result * static_cast<ResultType>(base);
     }
-    if (result > abs_max - cur_digit) {
+    if (result > abs_max - static_cast<ResultType>(cur_digit)) {
       result = abs_max;
       error_val = ERANGE;
     } else {
-      result = static_cast<ResultType>(result + cur_digit);
+      result = result + static_cast<ResultType>(cur_digit);
     }
   }
 
-  ptrdiff_t str_len = is_number ? (src_cur) : 0;
+  ptrdiff_t str_len = is_number ? static_cast<ptrdiff_t>(src_cur) : 0;
 
   if (error_val == ERANGE) {
     if (is_positive || IS_UNSIGNED)
diff --git a/src/__support/threads/linux/rwlock.h b/src/__support/threads/linux/rwlock.h
index 57fcc7b..f7aeb5b 100644
--- a/src/__support/threads/linux/rwlock.h
+++ b/src/__support/threads/linux/rwlock.h
@@ -162,7 +162,7 @@ public:
   LIBC_INLINE constexpr bool has_active_reader() const {
     return state >= ACTIVE_READER_COUNT_UNIT;
   }
-  LIBC_INLINE constexpr bool has_acitve_owner() const {
+  LIBC_INLINE constexpr bool has_active_owner() const {
     return has_active_reader() || has_active_writer();
   }
   LIBC_INLINE constexpr bool has_last_reader() const {
@@ -193,7 +193,7 @@ public:
       }
       __builtin_unreachable();
     } else
-      return !has_acitve_owner();
+      return !has_active_owner();
   }
 
   // This function check if it is possible to grow the reader count without
@@ -548,7 +548,7 @@ public:
   [[nodiscard]]
   LIBC_INLINE LockResult check_for_destroy() {
     RwState old = RwState::load(state, cpp::MemoryOrder::RELAXED);
-    if (old.has_acitve_owner())
+    if (old.has_active_owner())
       return LockResult::Busy;
     return LockResult::Success;
   }
diff --git a/src/__support/threads/spin_lock.h b/src/__support/threads/spin_lock.h
index e176ad9..3b424b3 100644
--- a/src/__support/threads/spin_lock.h
+++ b/src/__support/threads/spin_lock.h
@@ -34,7 +34,7 @@ public:
     // .LBB0_2:                          |                  jmp     .LBB0_4
     //         isb                       |         .LBB0_2:
     // .LBB0_3:                          |                  pause
-    //         ldrb    w9, [x0]          |         .LBB0_3:       
+    //         ldrb    w9, [x0]          |         .LBB0_3:
     //         tbnz    w9, #0, .LBB0_2   |                  movzx   eax, byte ptr [rdi]
     //         b       .LBB0_1           |                  test    al, 1
     // .LBB0_4:                          |                  jne     .LBB0_2
diff --git a/src/__support/threads/thread.cpp b/src/__support/threads/thread.cpp
index dad4f75..6f6b75b 100644
--- a/src/__support/threads/thread.cpp
+++ b/src/__support/threads/thread.cpp
@@ -117,7 +117,9 @@ public:
 
   int add_callback(AtExitCallback *callback, void *obj) {
     cpp::lock_guard lock(mtx);
-    return callback_list.push_back({callback, obj});
+    if (callback_list.push_back({callback, obj}))
+      return 0;
+    return -1;
   }
 
   void call() {
diff --git a/src/__support/time/linux/clock_gettime.h b/src/__support/time/clock_gettime.h
similarity index 72%
rename from src/__support/time/linux/clock_gettime.h
rename to src/__support/time/clock_gettime.h
index f7f996c..584bf54 100644
--- a/src/__support/time/linux/clock_gettime.h
+++ b/src/__support/time/clock_gettime.h
@@ -6,21 +6,17 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_GETTIME_H
-#define LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_GETTIME_H
+#ifndef LLVM_LIBC_SRC___SUPPORT_TIME_CLOCK_GETTIME_H
+#define LLVM_LIBC_SRC___SUPPORT_TIME_CLOCK_GETTIME_H
 
 #include "hdr/types/clockid_t.h"
 #include "hdr/types/struct_timespec.h"
 #include "src/__support/error_or.h"
 
-#if defined(SYS_clock_gettime64)
-#include <linux/time_types.h>
-#endif
-
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts);
 } // namespace internal
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_GETTIME_H
+#endif // LLVM_LIBC_SRC___SUPPORT_TIME_CLOCK_GETTIME_H
diff --git a/src/__support/time/gpu/clock_gettime.cpp b/src/__support/time/gpu/clock_gettime.cpp
new file mode 100644
index 0000000..cede72a
--- /dev/null
+++ b/src/__support/time/gpu/clock_gettime.cpp
@@ -0,0 +1,33 @@
+//===---------- GPU implementation of the clock_gettime function ----------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/clock_gettime.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/time/clock_gettime.h"
+#include "src/__support/time/gpu/time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
+
+ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts) {
+  if (clockid != CLOCK_MONOTONIC || !ts)
+    return cpp::unexpected(-1);
+
+  uint64_t ns_per_tick = TICKS_PER_SEC / GPU_CLOCKS_PER_SEC;
+  uint64_t ticks = gpu::fixed_frequency_clock();
+
+  ts->tv_nsec = (ticks * ns_per_tick) % TICKS_PER_SEC;
+  ts->tv_sec = (ticks * ns_per_tick) / TICKS_PER_SEC;
+
+  return 0;
+}
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/time_utils.cpp b/src/__support/time/gpu/time_utils.cpp
similarity index 100%
rename from src/time/gpu/time_utils.cpp
rename to src/__support/time/gpu/time_utils.cpp
diff --git a/src/time/gpu/time_utils.h b/src/__support/time/gpu/time_utils.h
similarity index 97%
rename from src/time/gpu/time_utils.h
rename to src/__support/time/gpu/time_utils.h
index c631a38..315506c 100644
--- a/src/time/gpu/time_utils.h
+++ b/src/__support/time/gpu/time_utils.h
@@ -38,6 +38,8 @@ extern gpu::Constant<uint64_t> __llvm_libc_clock_freq;
 #error "Unsupported target"
 #endif
 
+constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
+
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_TIME_GPU_TIME_UTILS_H
diff --git a/src/__support/time/linux/clock_conversion.h b/src/__support/time/linux/clock_conversion.h
index 7a52873..ac5357d 100644
--- a/src/__support/time/linux/clock_conversion.h
+++ b/src/__support/time/linux/clock_conversion.h
@@ -10,7 +10,7 @@
 #define LLVM_LIBC_SRC___SUPPORT_TIME_LINUX_CLOCK_CONVERSION_H
 
 #include "src/__support/macros/config.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/__support/time/units.h"
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/__support/time/linux/clock_gettime.cpp b/src/__support/time/linux/clock_gettime.cpp
index 3a0eca4..944fc0a 100644
--- a/src/__support/time/linux/clock_gettime.cpp
+++ b/src/__support/time/linux/clock_gettime.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "hdr/types/clockid_t.h"
 #include "hdr/types/struct_timespec.h"
 #include "src/__support/OSUtil/linux/vdso.h"
diff --git a/src/__support/time/windows/clock_gettime.cpp b/src/__support/time/windows/clock_gettime.cpp
new file mode 100644
index 0000000..813eae0
--- /dev/null
+++ b/src/__support/time/windows/clock_gettime.cpp
@@ -0,0 +1,134 @@
+//===--- clock_gettime windows implementation -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/time_macros.h"
+
+#include "src/__support/CPP/atomic.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/limits.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/time/clock_gettime.h"
+#include "src/__support/time/units.h"
+#include "src/__support/time/windows/performance_counter.h"
+
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+ErrorOr<int> clock_gettime(clockid_t clockid, timespec *ts) {
+  using namespace time_units;
+  constexpr unsigned long long HNS_PER_SEC = 1_s_ns / 100ULL;
+  constexpr long long SEC_LIMIT =
+      cpp::numeric_limits<decltype(ts->tv_sec)>::max();
+  ErrorOr<int> ret = 0;
+  switch (clockid) {
+  default:
+    ret = cpp::unexpected(EINVAL);
+    break;
+
+  case CLOCK_MONOTONIC: {
+    // see
+    // https://learn.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps
+    // Is the performance counter monotonic (non-decreasing)?
+    // Yes. performance_counter does not go backward.
+    [[clang::uninitialized]] LARGE_INTEGER buffer;
+    // On systems that run Windows XP or later, the function will always
+    // succeed and will thus never return zero.
+    ::QueryPerformanceCounter(&buffer);
+    long long freq = performance_counter::get_ticks_per_second();
+    long long ticks = buffer.QuadPart;
+    long long tv_sec = ticks / freq;
+    long long tv_nsec = (ticks % freq) * 1_s_ns / freq;
+    if (LIBC_UNLIKELY(tv_sec > SEC_LIMIT)) {
+      ret = cpp::unexpected(EOVERFLOW);
+      break;
+    }
+    ts->tv_sec = static_cast<decltype(ts->tv_sec)>(tv_sec);
+    ts->tv_nsec = static_cast<decltype(ts->tv_nsec)>(tv_nsec);
+    break;
+  }
+  case CLOCK_REALTIME: {
+    // https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime
+    // GetSystemTimePreciseAsFileTime
+    // This function is best suited for high-resolution time-of-day
+    // measurements, or time stamps that are synchronized to UTC
+    [[clang::uninitialized]] FILETIME file_time;
+    [[clang::uninitialized]] ULARGE_INTEGER time;
+    ::GetSystemTimePreciseAsFileTime(&file_time);
+    time.LowPart = file_time.dwLowDateTime;
+    time.HighPart = file_time.dwHighDateTime;
+
+    // adjust to POSIX epoch (from Jan 1, 1601 to Jan 1, 1970)
+    constexpr unsigned long long POSIX_TIME_SHIFT =
+        (11644473600ULL * HNS_PER_SEC);
+    if (LIBC_UNLIKELY(POSIX_TIME_SHIFT > time.QuadPart)) {
+      ret = cpp::unexpected(EOVERFLOW);
+      break;
+    }
+    time.QuadPart -= (11644473600ULL * HNS_PER_SEC);
+    unsigned long long tv_sec = time.QuadPart / HNS_PER_SEC;
+    unsigned long long tv_nsec = (time.QuadPart % HNS_PER_SEC) * 100ULL;
+    if (LIBC_UNLIKELY(tv_sec > SEC_LIMIT)) {
+      ret = cpp::unexpected(EOVERFLOW);
+      break;
+    }
+    ts->tv_sec = static_cast<decltype(ts->tv_sec)>(tv_sec);
+    ts->tv_nsec = static_cast<decltype(ts->tv_nsec)>(tv_nsec);
+    break;
+  }
+  case CLOCK_PROCESS_CPUTIME_ID:
+  case CLOCK_THREAD_CPUTIME_ID: {
+    [[clang::uninitialized]] FILETIME creation_time;
+    [[clang::uninitialized]] FILETIME exit_time;
+    [[clang::uninitialized]] FILETIME kernel_time;
+    [[clang::uninitialized]] FILETIME user_time;
+    bool success;
+    if (clockid == CLOCK_PROCESS_CPUTIME_ID) {
+      // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes
+      success = ::GetProcessTimes(::GetCurrentProcess(), &creation_time,
+                                  &exit_time, &kernel_time, &user_time);
+    } else {
+      // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes
+      success = ::GetThreadTimes(::GetCurrentThread(), &creation_time,
+                                 &exit_time, &kernel_time, &user_time);
+    }
+    if (!success) {
+      ret = cpp::unexpected(EINVAL);
+      break;
+    }
+    // https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime
+    // It is not recommended that you add and subtract values from the FILETIME
+    // structure to obtain relative times. Instead, you should copy the low- and
+    // high-order parts of the file time to a ULARGE_INTEGER structure, perform
+    // 64-bit arithmetic on the QuadPart member, and copy the LowPart and
+    // HighPart members into the FILETIME structure.
+    auto kernel_time_hns = cpp::bit_cast<ULARGE_INTEGER>(kernel_time);
+    auto user_time_hns = cpp::bit_cast<ULARGE_INTEGER>(user_time);
+    unsigned long long total_time_hns =
+        kernel_time_hns.QuadPart + user_time_hns.QuadPart;
+
+    unsigned long long tv_sec = total_time_hns / HNS_PER_SEC;
+    unsigned long long tv_nsec = (total_time_hns % HNS_PER_SEC) * 100ULL;
+
+    if (LIBC_UNLIKELY(tv_sec > SEC_LIMIT)) {
+      ret = cpp::unexpected(EOVERFLOW);
+      break;
+    }
+
+    ts->tv_sec = static_cast<decltype(ts->tv_sec)>(tv_sec);
+    ts->tv_nsec = static_cast<decltype(ts->tv_nsec)>(tv_nsec);
+
+    break;
+  }
+  }
+  return ret;
+}
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/__support/time/windows/performance_counter.h b/src/__support/time/windows/performance_counter.h
new file mode 100644
index 0000000..3df81b3
--- /dev/null
+++ b/src/__support/time/windows/performance_counter.h
@@ -0,0 +1,35 @@
+//===--- Cached Performance Counter Frequency  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/CPP/atomic.h"
+#include "src/__support/common.h"
+
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace performance_counter {
+LIBC_INLINE long long get_ticks_per_second() {
+  static cpp::Atomic<long long> frequency = 0;
+  // Relaxed ordering is enough. It is okay to record the frequency multiple
+  // times. The store operation itself is atomic and the value must propagate
+  // as required by cache coherence.
+  auto freq = frequency.load(cpp::MemoryOrder::RELAXED);
+  if (!freq) {
+    [[clang::uninitialized]] LARGE_INTEGER buffer;
+    // On systems that run Windows XP or later, the function will always
+    // succeed and will thus never return zero.
+    ::QueryPerformanceFrequency(&buffer);
+    frequency.store(buffer.QuadPart, cpp::MemoryOrder::RELAXED);
+    return buffer.QuadPart;
+  }
+  return freq;
+}
+} // namespace performance_counter
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/network/htonl.cpp b/src/arpa/inet/htonl.cpp
similarity index 95%
rename from src/network/htonl.cpp
rename to src/arpa/inet/htonl.cpp
index 681786a..fb0404a 100644
--- a/src/network/htonl.cpp
+++ b/src/arpa/inet/htonl.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/network/htonl.h"
+#include "src/arpa/inet/htonl.h"
 #include "src/__support/common.h"
 #include "src/__support/endian_internal.h"
 #include "src/__support/macros/config.h"
diff --git a/src/network/htonl.h b/src/arpa/inet/htonl.h
similarity index 81%
rename from src/network/htonl.h
rename to src/arpa/inet/htonl.h
index 1421731..e444972 100644
--- a/src/network/htonl.h
+++ b/src/arpa/inet/htonl.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_NETWORK_HTONL_H
-#define LLVM_LIBC_SRC_NETWORK_HTONL_H
+#ifndef LLVM_LIBC_SRC_ARPA_INET_HTONL_H
+#define LLVM_LIBC_SRC_ARPA_INET_HTONL_H
 
 #include "src/__support/macros/config.h"
 #include <stdint.h>
@@ -18,4 +18,4 @@ uint32_t htonl(uint32_t hostlong);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_NETWORK_HTONL_H
+#endif // LLVM_LIBC_SRC_ARPA_INET_HTONL_H
diff --git a/src/network/htons.cpp b/src/arpa/inet/htons.cpp
similarity index 95%
rename from src/network/htons.cpp
rename to src/arpa/inet/htons.cpp
index 675f53c..1fcbbdf 100644
--- a/src/network/htons.cpp
+++ b/src/arpa/inet/htons.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/network/htons.h"
+#include "src/arpa/inet/htons.h"
 #include "src/__support/common.h"
 #include "src/__support/endian_internal.h"
 #include "src/__support/macros/config.h"
diff --git a/src/network/htons.h b/src/arpa/inet/htons.h
similarity index 81%
rename from src/network/htons.h
rename to src/arpa/inet/htons.h
index 8f5c68a..35c2acd 100644
--- a/src/network/htons.h
+++ b/src/arpa/inet/htons.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_NETWORK_HTONS_H
-#define LLVM_LIBC_SRC_NETWORK_HTONS_H
+#ifndef LLVM_LIBC_SRC_ARPA_INET_HTONS_H
+#define LLVM_LIBC_SRC_ARPA_INET_HTONS_H
 
 #include "src/__support/macros/config.h"
 #include <stdint.h>
@@ -18,4 +18,4 @@ uint16_t htons(uint16_t hostshort);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_NETWORK_HTONS_H
+#endif // LLVM_LIBC_SRC_ARPA_INET_HTONS_H
diff --git a/src/network/ntohl.cpp b/src/arpa/inet/ntohl.cpp
similarity index 95%
rename from src/network/ntohl.cpp
rename to src/arpa/inet/ntohl.cpp
index 6a309e9..d472107 100644
--- a/src/network/ntohl.cpp
+++ b/src/arpa/inet/ntohl.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/network/ntohl.h"
+#include "src/arpa/inet/ntohl.h"
 #include "src/__support/common.h"
 #include "src/__support/endian_internal.h"
 #include "src/__support/macros/config.h"
diff --git a/src/network/ntohl.h b/src/arpa/inet/ntohl.h
similarity index 81%
rename from src/network/ntohl.h
rename to src/arpa/inet/ntohl.h
index c325951..4007965 100644
--- a/src/network/ntohl.h
+++ b/src/arpa/inet/ntohl.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_NETWORK_NTOHL_H
-#define LLVM_LIBC_SRC_NETWORK_NTOHL_H
+#ifndef LLVM_LIBC_SRC_ARPA_INET_NTOHL_H
+#define LLVM_LIBC_SRC_ARPA_INET_NTOHL_H
 
 #include "src/__support/macros/config.h"
 #include <stdint.h>
@@ -18,4 +18,4 @@ uint32_t ntohl(uint32_t netlong);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_NETWORK_NTOHL_H
+#endif // LLVM_LIBC_SRC_ARPA_INET_NTOHL_H
diff --git a/src/network/ntohs.cpp b/src/arpa/inet/ntohs.cpp
similarity index 95%
rename from src/network/ntohs.cpp
rename to src/arpa/inet/ntohs.cpp
index b51ecb9..9082ed9 100644
--- a/src/network/ntohs.cpp
+++ b/src/arpa/inet/ntohs.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/network/ntohs.h"
+#include "src/arpa/inet/ntohs.h"
 #include "src/__support/common.h"
 #include "src/__support/endian_internal.h"
 #include "src/__support/macros/config.h"
diff --git a/src/network/ntohs.h b/src/arpa/inet/ntohs.h
similarity index 81%
rename from src/network/ntohs.h
rename to src/arpa/inet/ntohs.h
index f555914..5fe3ebc 100644
--- a/src/network/ntohs.h
+++ b/src/arpa/inet/ntohs.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_NETWORK_NTOHS_H
-#define LLVM_LIBC_SRC_NETWORK_NTOHS_H
+#ifndef LLVM_LIBC_SRC_ARPA_INET_NTOHS_H
+#define LLVM_LIBC_SRC_ARPA_INET_NTOHS_H
 
 #include "src/__support/macros/config.h"
 #include <stdint.h>
@@ -18,4 +18,4 @@ uint16_t ntohs(uint16_t netshort);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_NETWORK_NTOHS_H
+#endif // LLVM_LIBC_SRC_ARPA_INET_NTOHS_H
diff --git a/src/compiler/generic/__stack_chk_fail.cpp b/src/compiler/generic/__stack_chk_fail.cpp
index c76ec14..00e976a 100644
--- a/src/compiler/generic/__stack_chk_fail.cpp
+++ b/src/compiler/generic/__stack_chk_fail.cpp
@@ -9,9 +9,12 @@
 #include "src/compiler/__stack_chk_fail.h"
 #include "src/__support/OSUtil/io.h"
 #include "src/stdlib/abort.h"
+#include <stdint.h> // For uintptr_t
 
 extern "C" {
 
+uintptr_t __stack_chk_guard = static_cast<uintptr_t>(0xa9fff01234);
+
 void __stack_chk_fail(void) {
   LIBC_NAMESPACE::write_to_stderr("stack smashing detected\n");
   LIBC_NAMESPACE::abort();
diff --git a/src/complex/cimagf128.h b/src/complex/cimagf128.h
index ab8f9ac..aaf52cf 100644
--- a/src/complex/cimagf128.h
+++ b/src/complex/cimagf128.h
@@ -6,15 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/macros/properties/complex_types.h"
-#include "src/__support/macros/properties/types.h"
-
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 #ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
 #define LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
 
 #include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -23,5 +20,3 @@ float128 cimagf128(cfloat128 x);
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_COMPLEX_CIMAGF128_H
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/cimagf16.h b/src/complex/cimagf16.h
index 5c5de2e..81ed4d2 100644
--- a/src/complex/cimagf16.h
+++ b/src/complex/cimagf16.h
@@ -6,15 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/macros/properties/complex_types.h"
-#include "src/__support/macros/properties/types.h"
-
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 #ifndef LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
 #define LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
 
 #include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -23,5 +20,3 @@ float16 cimagf16(cfloat16 x);
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_COMPLEX_CIMAGF16_H
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/sys/mman/process_mrelease.h b/src/complex/conj.h
similarity index 53%
rename from src/sys/mman/process_mrelease.h
rename to src/complex/conj.h
index 6c800f2..2ff82d2 100644
--- a/src/sys/mman/process_mrelease.h
+++ b/src/complex/conj.h
@@ -1,21 +1,20 @@
-//===-- Implementation header for process_mrelease function -*- C++ -*-===//
+//===-- Implementation header for conj --------------------------*- C++ -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
-//===------------------------------------------------------------------===//
+//===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
-#define LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
+#ifndef LLVM_LIBC_SRC_COMPLEX_CONJ_H
+#define LLVM_LIBC_SRC_COMPLEX_CONJ_H
 
 #include "src/__support/macros/config.h"
-#include <sys/mman.h> // For size_t and off_t
 
 namespace LIBC_NAMESPACE_DECL {
 
-int process_mrelease(int pidfd, unsigned int flags);
+_Complex double conj(_Complex double x);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_SYS_MMAN_PROCESS_MRELEASE_H
+#endif // LLVM_LIBC_SRC_COMPLEX_CONJ_H
diff --git a/src/complex/conjf.h b/src/complex/conjf.h
new file mode 100644
index 0000000..6b3bd61
--- /dev/null
+++ b/src/complex/conjf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for conjf -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CONJF_H
+#define LLVM_LIBC_SRC_COMPLEX_CONJF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+_Complex float conjf(_Complex float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CONJF_H
diff --git a/src/complex/conjf128.h b/src/complex/conjf128.h
new file mode 100644
index 0000000..cae01d3
--- /dev/null
+++ b/src/complex/conjf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for conjf128 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CONJF128_H
+#define LLVM_LIBC_SRC_COMPLEX_CONJF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+cfloat128 conjf128(cfloat128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CONJF128_H
diff --git a/src/complex/conjf16.h b/src/complex/conjf16.h
new file mode 100644
index 0000000..dde1221
--- /dev/null
+++ b/src/complex/conjf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for conjf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CONJF16_H
+#define LLVM_LIBC_SRC_COMPLEX_CONJF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+cfloat16 conjf16(cfloat16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CONJF16_H
diff --git a/src/complex/conjl.h b/src/complex/conjl.h
new file mode 100644
index 0000000..aec640f
--- /dev/null
+++ b/src/complex/conjl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for conjl -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CONJL_H
+#define LLVM_LIBC_SRC_COMPLEX_CONJL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+_Complex long double conjl(_Complex long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CONJL_H
diff --git a/src/complex/cproj.h b/src/complex/cproj.h
new file mode 100644
index 0000000..62d41bc
--- /dev/null
+++ b/src/complex/cproj.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cproj -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CPROJ_H
+#define LLVM_LIBC_SRC_COMPLEX_CPROJ_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+_Complex double cproj(_Complex double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CPROJ_H
diff --git a/src/complex/cprojf.h b/src/complex/cprojf.h
new file mode 100644
index 0000000..76124f9
--- /dev/null
+++ b/src/complex/cprojf.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cprojf ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CPROJF_H
+#define LLVM_LIBC_SRC_COMPLEX_CPROJF_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+_Complex float cprojf(_Complex float x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CPROJF_H
diff --git a/src/complex/cprojf128.h b/src/complex/cprojf128.h
new file mode 100644
index 0000000..71c1bbe
--- /dev/null
+++ b/src/complex/cprojf128.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for cprojf128 ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CPROJF128_H
+#define LLVM_LIBC_SRC_COMPLEX_CPROJF128_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+cfloat128 cprojf128(cfloat128 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CPROJF128_H
diff --git a/src/complex/cprojf16.h b/src/complex/cprojf16.h
new file mode 100644
index 0000000..f12a46d
--- /dev/null
+++ b/src/complex/cprojf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for cprojf16 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CPROJF16_H
+#define LLVM_LIBC_SRC_COMPLEX_CPROJF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+cfloat16 cprojf16(cfloat16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CPROJF16_H
diff --git a/src/complex/cprojl.h b/src/complex/cprojl.h
new file mode 100644
index 0000000..ecc8dce
--- /dev/null
+++ b/src/complex/cprojl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for cprojl ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_COMPLEX_CPROJL_H
+#define LLVM_LIBC_SRC_COMPLEX_CPROJL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+_Complex long double cprojl(_Complex long double x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_COMPLEX_CPROJL_H
diff --git a/src/complex/crealf128.h b/src/complex/crealf128.h
index 4922ae7..b90c3e7 100644
--- a/src/complex/crealf128.h
+++ b/src/complex/crealf128.h
@@ -6,15 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/macros/properties/complex_types.h"
-#include "src/__support/macros/properties/types.h"
-
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 #ifndef LLVM_LIBC_SRC_COMPLEX_CREALF128_H
 #define LLVM_LIBC_SRC_COMPLEX_CREALF128_H
 
 #include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -23,5 +20,3 @@ float128 crealf128(cfloat128 x);
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_COMPLEX_CREALF128_H
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/crealf16.h b/src/complex/crealf16.h
index e6098a2..09d6664 100644
--- a/src/complex/crealf16.h
+++ b/src/complex/crealf16.h
@@ -6,15 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/macros/properties/complex_types.h"
-#include "src/__support/macros/properties/types.h"
-
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 #ifndef LLVM_LIBC_SRC_COMPLEX_CREALF16_H
 #define LLVM_LIBC_SRC_COMPLEX_CREALF16_H
 
 #include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/complex_types.h"
+#include "src/__support/macros/properties/types.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -23,5 +20,3 @@ float16 crealf16(cfloat16 x);
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_COMPLEX_CREALF16_H
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/generic/cimagf128.cpp b/src/complex/generic/cimagf128.cpp
index c21bd7f..78dbb8e 100644
--- a/src/complex/generic/cimagf128.cpp
+++ b/src/complex/generic/cimagf128.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/complex/cimagf128.h"
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/complex_type.h"
@@ -21,5 +19,3 @@ LLVM_LIBC_FUNCTION(float128, cimagf128, (cfloat128 x)) {
 }
 
 } // namespace LIBC_NAMESPACE_DECL
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/generic/cimagf16.cpp b/src/complex/generic/cimagf16.cpp
index 3616879..25d9b3d 100644
--- a/src/complex/generic/cimagf16.cpp
+++ b/src/complex/generic/cimagf16.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/complex/cimagf16.h"
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/complex_type.h"
@@ -21,5 +19,3 @@ LLVM_LIBC_FUNCTION(float16, cimagf16, (cfloat16 x)) {
 }
 
 } // namespace LIBC_NAMESPACE_DECL
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/complex/generic/conj.cpp b/src/complex/generic/conj.cpp
new file mode 100644
index 0000000..ec1f528
--- /dev/null
+++ b/src/complex/generic/conj.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of conj function -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/conj.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex double, conj, (_Complex double x)) {
+  return conjugate<_Complex double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/conjf.cpp b/src/complex/generic/conjf.cpp
new file mode 100644
index 0000000..bf376bc
--- /dev/null
+++ b/src/complex/generic/conjf.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of conjf function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/conjf.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex float, conjf, (_Complex float x)) {
+  return conjugate<_Complex float>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/conjf128.cpp b/src/complex/generic/conjf128.cpp
new file mode 100644
index 0000000..d5faba7
--- /dev/null
+++ b/src/complex/generic/conjf128.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of conjf128 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/conjf128.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(cfloat128, conjf128, (cfloat128 x)) {
+  return conjugate<cfloat128>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/conjf16.cpp b/src/complex/generic/conjf16.cpp
new file mode 100644
index 0000000..31e8f93
--- /dev/null
+++ b/src/complex/generic/conjf16.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of conjf16 function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/conjf16.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(cfloat16, conjf16, (cfloat16 x)) {
+  return conjugate<cfloat16>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/conjl.cpp b/src/complex/generic/conjl.cpp
new file mode 100644
index 0000000..351fa60
--- /dev/null
+++ b/src/complex/generic/conjl.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of conjl function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/conjl.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex long double, conjl, (_Complex long double x)) {
+  return conjugate<_Complex long double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cproj.cpp b/src/complex/generic/cproj.cpp
new file mode 100644
index 0000000..2a9f457
--- /dev/null
+++ b/src/complex/generic/cproj.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of cproj function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cproj.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex double, cproj, (_Complex double x)) {
+  return project<_Complex double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cprojf.cpp b/src/complex/generic/cprojf.cpp
new file mode 100644
index 0000000..d4e83dd
--- /dev/null
+++ b/src/complex/generic/cprojf.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of cprojf function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cprojf.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex float, cprojf, (_Complex float x)) {
+  return project<_Complex float>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cprojf128.cpp b/src/complex/generic/cprojf128.cpp
new file mode 100644
index 0000000..72a741d
--- /dev/null
+++ b/src/complex/generic/cprojf128.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of cprojf128 function ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cprojf128.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(cfloat128, cprojf128, (cfloat128 x)) {
+  return project<cfloat128>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cprojf16.cpp b/src/complex/generic/cprojf16.cpp
new file mode 100644
index 0000000..0928345
--- /dev/null
+++ b/src/complex/generic/cprojf16.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of cprojf16 function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cprojf16.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(cfloat16, cprojf16, (cfloat16 x)) {
+  return project<cfloat16>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/cprojl.cpp b/src/complex/generic/cprojl.cpp
new file mode 100644
index 0000000..849a6f7
--- /dev/null
+++ b/src/complex/generic/cprojl.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation of cprojl function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/complex/cprojl.h"
+#include "src/__support/common.h"
+#include "src/__support/complex_basic_ops.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(_Complex long double, cprojl, (_Complex long double x)) {
+  return project<_Complex long double>(x);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/complex/generic/crealf128.cpp b/src/complex/generic/crealf128.cpp
index e72a778..e755498 100644
--- a/src/complex/generic/crealf128.cpp
+++ b/src/complex/generic/crealf128.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/complex/crealf128.h"
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/complex_type.h"
@@ -21,5 +19,3 @@ LLVM_LIBC_FUNCTION(float128, crealf128, (cfloat128 x)) {
 }
 
 } // namespace LIBC_NAMESPACE_DECL
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/src/complex/generic/crealf16.cpp b/src/complex/generic/crealf16.cpp
index 3514207..c9e8626 100644
--- a/src/complex/generic/crealf16.cpp
+++ b/src/complex/generic/crealf16.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/complex/crealf16.h"
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 #include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/complex_type.h"
@@ -21,5 +19,3 @@ LLVM_LIBC_FUNCTION(float16, crealf16, (cfloat16 x)) {
 }
 
 } // namespace LIBC_NAMESPACE_DECL
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/src/ctype/isxdigit.cpp b/src/ctype/isxdigit.cpp
index 6b730c3..81f645c 100644
--- a/src/ctype/isxdigit.cpp
+++ b/src/ctype/isxdigit.cpp
@@ -16,7 +16,8 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, isxdigit, (int c)) {
   const unsigned ch = static_cast<unsigned>(c);
-  return static_cast<int>(internal::isdigit(ch) || (ch | 32) - 'a' < 6);
+  return static_cast<int>(internal::isalnum(ch) &&
+                          internal::b36_char_to_int(ch) < 16);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/isxdigit_l.cpp b/src/ctype/isxdigit_l.cpp
index 8a5c7d4..eddfd20 100644
--- a/src/ctype/isxdigit_l.cpp
+++ b/src/ctype/isxdigit_l.cpp
@@ -16,7 +16,8 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, isxdigit_l, (int c, locale_t)) {
   const unsigned ch = static_cast<unsigned>(c);
-  return static_cast<int>(internal::isdigit(ch) || (ch | 32) - 'a' < 6);
+  return static_cast<int>(internal::isalnum(ch) &&
+                          internal::b36_char_to_int(ch) < 16);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/toupper.cpp b/src/ctype/toupper.cpp
index b5a23fc..1e1e8fc 100644
--- a/src/ctype/toupper.cpp
+++ b/src/ctype/toupper.cpp
@@ -14,10 +14,6 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(int, toupper, (int c)) {
-  if (internal::islower(c))
-    return c - ('a' - 'A');
-  return c;
-}
+LLVM_LIBC_FUNCTION(int, toupper, (int c)) { return internal::toupper(c); }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/ctype/toupper_l.cpp b/src/ctype/toupper_l.cpp
index f536ff3..a435ca1 100644
--- a/src/ctype/toupper_l.cpp
+++ b/src/ctype/toupper_l.cpp
@@ -15,9 +15,7 @@
 namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, toupper_l, (int c, locale_t)) {
-  if (internal::islower(c))
-    return c - ('a' - 'A');
-  return c;
+  return internal::toupper(c);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/dirent/readdir.h b/src/dirent/readdir.h
index 2dcf536..bc46a1b 100644
--- a/src/dirent/readdir.h
+++ b/src/dirent/readdir.h
@@ -9,7 +9,7 @@
 #ifndef LLVM_LIBC_SRC_DIRENT_READDIR_H
 #define LLVM_LIBC_SRC_DIRENT_READDIR_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include <dirent.h>
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/gpu/rpc_host_call.cpp b/src/gpu/rpc_host_call.cpp
deleted file mode 100644
index 1181e95..0000000
--- a/src/gpu/rpc_host_call.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-//===---------- GPU implementation of the external RPC call function ------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/gpu/rpc_host_call.h"
-
-#include "src/__support/GPU/utils.h"
-#include "src/__support/RPC/rpc_client.h"
-#include "src/__support/common.h"
-#include "src/__support/macros/config.h"
-
-namespace LIBC_NAMESPACE_DECL {
-
-// This calls the associated function pointer on the RPC server with the given
-// arguments. We expect that the pointer here is a valid pointer on the server.
-LLVM_LIBC_FUNCTION(unsigned long long, rpc_host_call,
-                   (void *fn, void *data, size_t size)) {
-  rpc::Client::Port port = rpc::client.open<RPC_HOST_CALL>();
-  port.send_n(data, size);
-  port.send([=](rpc::Buffer *buffer, uint32_t) {
-    buffer->data[0] = reinterpret_cast<uintptr_t>(fn);
-  });
-  unsigned long long ret;
-  port.recv([&](rpc::Buffer *buffer, uint32_t) {
-    ret = static_cast<unsigned long long>(buffer->data[0]);
-  });
-  port.close();
-  return ret;
-}
-
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/link/dl_iterate_phdr.cpp b/src/link/dl_iterate_phdr.cpp
new file mode 100644
index 0000000..7964411
--- /dev/null
+++ b/src/link/dl_iterate_phdr.cpp
@@ -0,0 +1,25 @@
+//===-- Implementation of dl_iterate_phdr --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#include "dl_iterate_phdr.h"
+
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, dl_iterate_phdr,
+                   (__dl_iterate_phdr_callback_t callback, void *arg)) {
+  // FIXME: For pure static linking, this can report just the executable with
+  // info from __ehdr_start or AT_{PHDR,PHNUM} decoding, and its PT_TLS; and it
+  // could report the vDSO.
+  (void)callback, (void)arg;
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/link/dl_iterate_phdr.h b/src/link/dl_iterate_phdr.h
new file mode 100644
index 0000000..2d75e71
--- /dev/null
+++ b/src/link/dl_iterate_phdr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header of dl_iterate_phdr ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_DLFCN_DL_ITERATE_PHDR_H
+#define LLVM_LIBC_SRC_DLFCN_DL_ITERATE_PHDR_H
+
+#include "hdr/types/struct_dl_phdr_info.h"
+#include "include/llvm-libc-types/__dl_iterate_phdr_callback_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int dl_iterate_phdr(__dl_iterate_phdr_callback_t, void *);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_DLFCN_DL_ITERATE_PHDR_H
diff --git a/src/locale/duplocale.cpp b/src/locale/duplocale.cpp
index d1bd083..572aff8 100644
--- a/src/locale/duplocale.cpp
+++ b/src/locale/duplocale.cpp
@@ -7,10 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/locale/duplocale.h"
-#include "include/llvm-libc-macros/locale-macros.h"
-#include "src/locale/locale.h"
-
-#include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
diff --git a/src/locale/freelocale.cpp b/src/locale/freelocale.cpp
index 2008995..2e1631d 100644
--- a/src/locale/freelocale.cpp
+++ b/src/locale/freelocale.cpp
@@ -7,10 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/locale/freelocale.h"
-#include "include/llvm-libc-macros/locale-macros.h"
-#include "src/locale/locale.h"
-
-#include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
diff --git a/src/locale/locale.cpp b/src/locale/locale.cpp
index 1610fb5..2f7e13f 100644
--- a/src/locale/locale.cpp
+++ b/src/locale/locale.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/locale/locale.h"
-
-#include "include/llvm-libc-macros/locale-macros.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
diff --git a/src/locale/newlocale.cpp b/src/locale/newlocale.cpp
index 379e7e6..2c36465 100644
--- a/src/locale/newlocale.cpp
+++ b/src/locale/newlocale.cpp
@@ -7,12 +7,11 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/locale/newlocale.h"
-#include "include/llvm-libc-macros/locale-macros.h"
-#include "src/locale/locale.h"
-
+#include "hdr/locale_macros.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
+#include "src/locale/locale.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/locale/newlocale.h b/src/locale/newlocale.h
index 08a0071..07972fa 100644
--- a/src/locale/newlocale.h
+++ b/src/locale/newlocale.h
@@ -9,9 +9,8 @@
 #ifndef LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
 #define LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
 
-#include "src/__support/macros/config.h"
-
 #include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/locale/setlocale.cpp b/src/locale/setlocale.cpp
index 0950ad7..2dec497 100644
--- a/src/locale/setlocale.cpp
+++ b/src/locale/setlocale.cpp
@@ -7,9 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/locale/setlocale.h"
-#include "include/llvm-libc-macros/locale-macros.h"
-#include "src/locale/locale.h"
-
+#include "hdr/locale_macros.h"
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
diff --git a/src/locale/setlocale.h b/src/locale/setlocale.h
index a9213cf..8e32fd4 100644
--- a/src/locale/setlocale.h
+++ b/src/locale/setlocale.h
@@ -9,9 +9,8 @@
 #ifndef LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
 #define LLVM_LIBC_SRC_LOCALE_SETLOCALE_H
 
-#include "src/__support/macros/config.h"
-
 #include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/math/acosf16.h b/src/math/acosf16.h
new file mode 100644
index 0000000..df30be2
--- /dev/null
+++ b/src/math/acosf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for acosf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ACOSF16_H
+#define LLVM_LIBC_SRC_MATH_ACOSF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 acosf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ACOSF16_H
diff --git a/src/math/asinf16.h b/src/math/asinf16.h
new file mode 100644
index 0000000..f16647e
--- /dev/null
+++ b/src/math/asinf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for asinf16 -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_ASINF16_H
+#define LLVM_LIBC_SRC_MATH_ASINF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 asinf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_ASINF16_H
diff --git a/src/math/cosf16.h b/src/math/cosf16.h
new file mode 100644
index 0000000..cc179a6
--- /dev/null
+++ b/src/math/cosf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for cosf16 ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_COSF16_H
+#define LLVM_LIBC_SRC_MATH_COSF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 cosf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_COSF16_H
diff --git a/src/math/generic/acosf.cpp b/src/math/generic/acosf.cpp
index 3c097a7..509a5eb 100644
--- a/src/math/generic/acosf.cpp
+++ b/src/math/generic/acosf.cpp
@@ -20,6 +20,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr size_t N_EXCEPTS = 4;
 
 // Exceptional values when |x| <= 0.5
@@ -34,6 +35,7 @@ static constexpr fputil::ExceptValues<float, N_EXCEPTS> ACOSF_EXCEPTS = {{
     // x = -0x1.04c444p-12, acosf(x) = 0x1.923p0 (RZ)
     {0xb9826222, 0x3fc91800, 1, 0, 1},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, acosf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -51,9 +53,11 @@ LLVM_LIBC_FUNCTION(float, acosf, (float x)) {
       //   acos(x) = pi/2 - asin(x)
       //           ~ pi/2 - x - x^3 / 6
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       // Check for exceptional values
       if (auto r = ACOSF_EXCEPTS.lookup(x_uint); LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       double xd = static_cast<double>(x);
       return static_cast<float>(fputil::multiply_add(
diff --git a/src/math/generic/acosf16.cpp b/src/math/generic/acosf16.cpp
new file mode 100644
index 0000000..202a950
--- /dev/null
+++ b/src/math/generic/acosf16.cpp
@@ -0,0 +1,151 @@
+//===-- Half-precision acosf16(x) function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/acosf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// Generated by Sollya using the following command:
+// > round(pi/2, SG, RN);
+// > round(pi, SG, RN);
+static constexpr float PI_OVER_2 = 0x1.921fb6p0f;
+static constexpr float PI = 0x1.921fb6p1f;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+static constexpr size_t N_EXCEPTS = 2;
+
+static constexpr fputil::ExceptValues<float16, N_EXCEPTS> ACOSF16_EXCEPTS{{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    {0xacaf, 0x3e93, 1, 0, 0},
+    {0xb874, 0x4052, 1, 0, 1},
+}};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+LLVM_LIBC_FUNCTION(float16, acosf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  uint16_t x_sign = x_u >> 15;
+
+  // |x| > 0x1p0, |x| > 1, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs > 0x3c00)) {
+    // acosf16(NaN) = NaN
+    if (xbits.is_nan()) {
+      if (xbits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // 1 < |x| <= +/-inf
+    fputil::raise_except_if_required(FE_INVALID);
+    fputil::set_errno_if_required(EDOM);
+
+    return FPBits::quiet_nan().get_val();
+  }
+
+  float xf = x;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  // Handle exceptional values
+  if (auto r = ACOSF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+  // |x| == 0x1p0, x is 1 or -1
+  // if x is (-)1, return pi, else
+  // if x is (+)1, return 0
+  if (LIBC_UNLIKELY(x_abs == 0x3c00))
+    return fputil::cast<float16>(x_sign ? PI : 0.0f);
+
+  float xsq = xf * xf;
+
+  // |x| <= 0x1p-1, |x| <= 0.5
+  if (x_abs <= 0x3800) {
+    // if x is 0, return pi/2
+    if (LIBC_UNLIKELY(x_abs == 0))
+      return fputil::cast<float16>(PI_OVER_2);
+
+    // Note that: acos(x) = pi/2 + asin(-x) = pi/2 - asin(x)
+    // Degree-6 minimax polynomial of asin(x) generated by Sollya with:
+    // > P = fpminimax(asin(x)/x, [|0, 2, 4, 6, 8|], [|SG...|], [0, 0.5]);
+    float interm =
+        fputil::polyeval(xsq, 0x1.000002p0f, 0x1.554c2ap-3f, 0x1.3541ccp-4f,
+                         0x1.43b2d6p-5f, 0x1.a0d73ep-5f);
+    return fputil::cast<float16>(fputil::multiply_add(-xf, interm, PI_OVER_2));
+  }
+
+  // When |x| > 0.5, assume that 0.5 < |x| <= 1
+  //
+  // Step-by-step range-reduction proof:
+  // 1:  Let y = asin(x), such that, x = sin(y)
+  // 2:  From complimentary angle identity:
+  //       x = sin(y) = cos(pi/2 - y)
+  // 3:  Let z = pi/2 - y, such that x = cos(z)
+  // 4:  From double angle formula; cos(2A) = 1 - 2 * sin^2(A):
+  //       z = 2A, z/2 = A
+  //       cos(z) = 1 - 2 * sin^2(z/2)
+  // 5:  Make sin(z/2) subject of the formula:
+  //       sin(z/2) = sqrt((1 - cos(z))/2)
+  // 6:  Recall [3]; x = cos(z). Therefore:
+  //       sin(z/2) = sqrt((1 - x)/2)
+  // 7:  Let u = (1 - x)/2
+  // 8:  Therefore:
+  //       asin(sqrt(u)) = z/2
+  //       2 * asin(sqrt(u)) = z
+  // 9:  Recall [3]; z = pi/2 - y. Therefore:
+  //       y = pi/2 - z
+  //       y = pi/2 - 2 * asin(sqrt(u))
+  // 10: Recall [1], y = asin(x). Therefore:
+  //       asin(x) = pi/2 - 2 * asin(sqrt(u))
+  // 11: Recall that: acos(x) = pi/2 + asin(-x) = pi/2 - asin(x)
+  //     Therefore:
+  //       acos(x) = pi/2 - (pi/2 - 2 * asin(sqrt(u)))
+  //       acos(x) = 2 * asin(sqrt(u))
+  //
+  // THE RANGE REDUCTION, HOW?
+  // 12: Recall [7], u = (1 - x)/2
+  // 13: Since 0.5 < x <= 1, therefore:
+  //       0 <= u <= 0.25 and 0 <= sqrt(u) <= 0.5
+  //
+  // Hence, we can reuse the same [0, 0.5] domain polynomial approximation for
+  // Step [11] as `sqrt(u)` is in range.
+  // When -1 < x <= -0.5, the identity:
+  //       acos(x) = pi - acos(-x)
+  // allows us to compute for the negative x value (lhs)
+  // with a positive x value instead (rhs).
+
+  float xf_abs = (xf < 0 ? -xf : xf);
+  float u = fputil::multiply_add(-0.5f, xf_abs, 0.5f);
+  float sqrt_u = fputil::sqrt<float>(u);
+
+  // Degree-6 minimax polynomial of asin(x) generated by Sollya with:
+  // > P = fpminimax(asin(x)/x, [|0, 2, 4, 6, 8|], [|SG...|], [0, 0.5]);
+  float asin_sqrt_u =
+      sqrt_u * fputil::polyeval(u, 0x1.000002p0f, 0x1.554c2ap-3f,
+                                0x1.3541ccp-4f, 0x1.43b2d6p-5f, 0x1.a0d73ep-5f);
+
+  return fputil::cast<float16>(
+      x_sign ? fputil::multiply_add(-2.0f, asin_sqrt_u, PI) : 2 * asin_sqrt_u);
+}
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/acoshf.cpp b/src/math/generic/acoshf.cpp
index 6158063..c4927fa 100644
--- a/src/math/generic/acoshf.cpp
+++ b/src/math/generic/acoshf.cpp
@@ -22,7 +22,6 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(float, acoshf, (float x)) {
   using FPBits_t = typename fputil::FPBits<float>;
   FPBits_t xbits(x);
-  uint32_t x_u = xbits.uintval();
 
   if (LIBC_UNLIKELY(x <= 1.0f)) {
     if (x == 1.0f)
@@ -33,6 +32,8 @@ LLVM_LIBC_FUNCTION(float, acoshf, (float x)) {
     return FPBits_t::quiet_nan().get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  uint32_t x_u = xbits.uintval();
   if (LIBC_UNLIKELY(x_u >= 0x4f8ffb03)) {
     if (LIBC_UNLIKELY(xbits.is_inf_or_nan()))
       return x;
@@ -64,6 +65,10 @@ LLVM_LIBC_FUNCTION(float, acoshf, (float x)) {
       return round_result_slightly_up(0x1.451436p6f);
     }
   }
+#else
+  if (LIBC_UNLIKELY(xbits.is_inf_or_nan()))
+    return x;
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   double x_d = static_cast<double>(x);
   // acosh(x) = log(x + sqrt(x^2 - 1))
diff --git a/src/math/generic/asinf.cpp b/src/math/generic/asinf.cpp
index 3a89def..da85441 100644
--- a/src/math/generic/asinf.cpp
+++ b/src/math/generic/asinf.cpp
@@ -21,6 +21,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr size_t N_EXCEPTS = 2;
 
 // Exceptional values when |x| <= 0.5
@@ -40,6 +41,7 @@ static constexpr fputil::ExceptValues<float, N_EXCEPTS> ASINF_EXCEPTS_HI = {{
     // x = 0x1.ee836cp-1, asinf(x) = 0x1.4f0654p0 (RZ)
     {0x3f7741b6, 0x3fa7832a, 1, 0, 0},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, asinf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -74,18 +76,20 @@ LLVM_LIBC_FUNCTION(float, asinf, (float x)) {
       // |x| < 2^-125. For targets without FMA instructions, we simply use
       // double for intermediate results as it is more efficient than using an
       // emulated version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
       return fputil::multiply_add(x, 0x1.0p-25f, x);
 #else
       double xd = static_cast<double>(x);
       return static_cast<float>(fputil::multiply_add(xd, 0x1.0p-25, xd));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Check for exceptional values
     if (auto r = ASINF_EXCEPTS_LO.lookup_odd(x_abs, x_sign);
         LIBC_UNLIKELY(r.has_value()))
       return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
     // For |x| <= 0.5, we approximate asinf(x) by:
     //   asin(x) = x * P(x^2)
@@ -111,10 +115,12 @@ LLVM_LIBC_FUNCTION(float, asinf, (float x)) {
     return FPBits::quiet_nan().get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Check for exceptional values
   if (auto r = ASINF_EXCEPTS_HI.lookup_odd(x_abs, x_sign);
       LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // When |x| > 0.5, we perform range reduction as follow:
   //
diff --git a/src/math/generic/asinf16.cpp b/src/math/generic/asinf16.cpp
new file mode 100644
index 0000000..518c384
--- /dev/null
+++ b/src/math/generic/asinf16.cpp
@@ -0,0 +1,133 @@
+//===-- Half-precision asinf16(x) function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/asinf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/PolyEval.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// Generated by Sollya using the following command:
+// > round(pi/2, D, RN);
+static constexpr float PI_2 = 0x1.921fb54442d18p0f;
+
+LLVM_LIBC_FUNCTION(float16, asinf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+  // |x| > 0x1p0, |x| > 1, or x is NaN.
+  if (LIBC_UNLIKELY(x_abs > 0x3c00)) {
+    // asinf16(NaN) = NaN
+    if (xbits.is_nan()) {
+      if (xbits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+
+      return x;
+    }
+
+    // 1 < |x| <= +/-inf
+    fputil::raise_except_if_required(FE_INVALID);
+    fputil::set_errno_if_required(EDOM);
+
+    return FPBits::quiet_nan().get_val();
+  }
+
+  float xsq = xf * xf;
+
+  // |x| <= 0x1p-1, |x| <= 0.5
+  if (x_abs <= 0x3800) {
+    // asinf16(+/-0) = +/-0
+    if (LIBC_UNLIKELY(x_abs == 0))
+      return x;
+
+    // Exhaustive tests show that,
+    // for |x| <= 0x1.878p-9, when:
+    // x > 0, and rounding upward, or
+    // x < 0, and rounding downward, then,
+    // asin(x) = x * 2^-11 + x
+    // else, in other rounding modes,
+    // asin(x) = x
+    if (LIBC_UNLIKELY(x_abs <= 0x1a1e)) {
+      int rounding = fputil::quick_get_round();
+
+      if ((xbits.is_pos() && rounding == FE_UPWARD) ||
+          (xbits.is_neg() && rounding == FE_DOWNWARD))
+        return fputil::cast<float16>(fputil::multiply_add(xf, 0x1.0p-11f, xf));
+      return x;
+    }
+
+    // Degree-6 minimax odd polynomial of asin(x) generated by Sollya with:
+    // > P = fpminimax(asin(x)/x, [|0, 2, 4, 6, 8|], [|SG...|], [0, 0.5]);
+    float result =
+        fputil::polyeval(xsq, 0x1.000002p0f, 0x1.554c2ap-3f, 0x1.3541ccp-4f,
+                         0x1.43b2d6p-5f, 0x1.a0d73ep-5f);
+    return fputil::cast<float16>(xf * result);
+  }
+
+  // When |x| > 0.5, assume that 0.5 < |x| <= 1,
+  //
+  // Step-by-step range-reduction proof:
+  // 1:  Let y = asin(x), such that, x = sin(y)
+  // 2:  From complimentary angle identity:
+  //       x = sin(y) = cos(pi/2 - y)
+  // 3:  Let z = pi/2 - y, such that x = cos(z)
+  // 4:  From double angle formula; cos(2A) = 1 - sin^2(A):
+  //       z = 2A, z/2 = A
+  //       cos(z) = 1 - 2 * sin^2(z/2)
+  // 5:  Make sin(z/2) subject of the formula:
+  //       sin(z/2) = sqrt((1 - cos(z))/2)
+  // 6:  Recall [3]; x = cos(z). Therefore:
+  //       sin(z/2) = sqrt((1 - x)/2)
+  // 7:  Let u = (1 - x)/2
+  // 8:  Therefore:
+  //       asin(sqrt(u)) = z/2
+  //       2 * asin(sqrt(u)) = z
+  // 9:  Recall [3], z = pi/2 - y. Therefore:
+  //       y = pi/2 - z
+  //       y = pi/2 - 2 * asin(sqrt(u))
+  // 10: Recall [1], y = asin(x). Therefore:
+  //       asin(x) = pi/2 - 2 * asin(sqrt(u))
+  //
+  // WHY?
+  // 11: Recall [7], u = (1 - x)/2
+  // 12: Since 0.5 < x <= 1, therefore:
+  //       0 <= u <= 0.25 and 0 <= sqrt(u) <= 0.5
+  //
+  // Hence, we can reuse the same [0, 0.5] domain polynomial approximation for
+  // Step [10] as `sqrt(u)` is in range.
+
+  // 0x1p-1 < |x| <= 0x1p0, 0.5 < |x| <= 1.0
+  float xf_abs = (xf < 0 ? -xf : xf);
+  float sign = (xbits.uintval() >> 15 == 1 ? -1.0 : 1.0);
+  float u = fputil::multiply_add(-0.5f, xf_abs, 0.5f);
+  float u_sqrt = fputil::sqrt<float>(u);
+
+  // Degree-6 minimax odd polynomial of asin(x) generated by Sollya with:
+  // > P = fpminimax(asin(x)/x, [|0, 2, 4, 6, 8|], [|SG...|], [0, 0.5]);
+  float asin_sqrt_u =
+      u_sqrt * fputil::polyeval(u, 0x1.000002p0f, 0x1.554c2ap-3f,
+                                0x1.3541ccp-4f, 0x1.43b2d6p-5f, 0x1.a0d73ep-5f);
+
+  return fputil::cast<float16>(sign *
+                               fputil::multiply_add(-2.0f, asin_sqrt_u, PI_2));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/asinhf.cpp b/src/math/generic/asinhf.cpp
index 1d68ac9..37b87a8 100644
--- a/src/math/generic/asinhf.cpp
+++ b/src/math/generic/asinhf.cpp
@@ -36,7 +36,7 @@ LLVM_LIBC_FUNCTION(float, asinhf, (float x)) {
     double x_d = x;
     double x_sq = x_d * x_d;
     // Generated by Sollya with:
-    // > P = fpminimax(asinh(x)/x, [|0, 2, 4, 6, 8, 10, 12, 14, 16], [|D...|],
+    // > P = fpminimax(asinh(x)/x, [|0, 2, 4, 6, 8, 10, 12, 14, 16|], [|D...|],
     //                 [0, 2^-2]);
     double p = fputil::polyeval(
         x_sq, 0.0, -0x1.555555555551ep-3, 0x1.3333333325495p-4,
@@ -49,6 +49,7 @@ LLVM_LIBC_FUNCTION(float, asinhf, (float x)) {
   double x_sign = SIGN[x_u >> 31];
   double x_d = x;
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Helper functions to set results for exceptional cases.
   auto round_result_slightly_down = [x_sign](float r) -> float {
     return fputil::multiply_add(static_cast<float>(x_sign), r,
@@ -95,6 +96,10 @@ LLVM_LIBC_FUNCTION(float, asinhf, (float x)) {
       return round_result_slightly_down(0x1.e1b92p3f);
     }
   }
+#else
+  if (LIBC_UNLIKELY(xbits.is_inf_or_nan()))
+    return x;
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // asinh(x) = log(x + sqrt(x^2 + 1))
   return static_cast<float>(
diff --git a/src/math/generic/atan.cpp b/src/math/generic/atan.cpp
new file mode 100644
index 0000000..cbca605
--- /dev/null
+++ b/src/math/generic/atan.cpp
@@ -0,0 +1,179 @@
+//===-- Double-precision atan function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/atan.h"
+#include "atan_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+
+namespace LIBC_NAMESPACE_DECL {
+
+// To compute atan(x), we divided it into the following cases:
+// * |x| < 2^-26:
+//      Since |x| > atan(|x|) > |x| - |x|^3/3, and |x|^3/3 < ulp(x)/2, we simply
+//      return atan(x) = x - sign(x) * epsilon.
+// * 2^-26 <= |x| < 1:
+//      We perform range reduction mod 2^-6 = 1/64 as follow:
+//      Let k = 2^(-6) * round(|x| * 2^6), then
+//        atan(x) = sign(x) * atan(|x|)
+//                = sign(x) * (atan(k) + atan((|x| - k) / (1 + |x|*k)).
+//      We store atan(k) in a look up table, and perform intermediate steps in
+//      double-double.
+// * 1 < |x| < 2^53:
+//      First we perform the transformation y = 1/|x|:
+//        atan(x) = sign(x) * (pi/2 - atan(1/|x|))
+//                = sign(x) * (pi/2 - atan(y)).
+//      Then we compute atan(y) using range reduction mod 2^-6 = 1/64 as the
+//      previous case:
+//      Let k = 2^(-6) * round(y * 2^6), then
+//        atan(y) = atan(k) + atan((y - k) / (1 + y*k))
+//                = atan(k) + atan((1/|x| - k) / (1 + k/|x|)
+//                = atan(k) + atan((1 - k*|x|) / (|x| + k)).
+// * |x| >= 2^53:
+//      Using the reciprocal transformation:
+//        atan(x) = sign(x) * (pi/2 - atan(1/|x|)).
+//      We have that:
+//        atan(1/|x|) <= 1/|x| <= 2^-53,
+//      which is smaller than ulp(pi/2) / 2.
+//      So we can return:
+//        atan(x) = sign(x) * (pi/2 - epsilon)
+
+LLVM_LIBC_FUNCTION(double, atan, (double x)) {
+  using FPBits = fputil::FPBits<double>;
+
+  constexpr double IS_NEG[2] = {1.0, -1.0};
+  constexpr DoubleDouble PI_OVER_2 = {0x1.1a62633145c07p-54,
+                                      0x1.921fb54442d18p0};
+  constexpr DoubleDouble MPI_OVER_2 = {-0x1.1a62633145c07p-54,
+                                       -0x1.921fb54442d18p0};
+
+  FPBits xbits(x);
+  bool x_sign = xbits.is_neg();
+  xbits = xbits.abs();
+  uint64_t x_abs = xbits.uintval();
+  int x_exp =
+      static_cast<int>(x_abs >> FPBits::FRACTION_LEN) - FPBits::EXP_BIAS;
+
+  // |x| < 1.
+  if (x_exp < 0) {
+    if (LIBC_UNLIKELY(x_exp < -26)) {
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+      return x;
+#else
+      if (x == 0.0)
+        return x;
+      // |x| < 2^-26
+      return fputil::multiply_add(-0x1.0p-54, x, x);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+    }
+
+    double x_d = xbits.get_val();
+    // k = 2^-6 * round(2^6 * |x|)
+    double k = fputil::nearest_integer(0x1.0p6 * x_d);
+    unsigned idx = static_cast<unsigned>(k);
+    k *= 0x1.0p-6;
+
+    // numerator = |x| - k
+    DoubleDouble num, den;
+    num.lo = 0.0;
+    num.hi = x_d - k;
+
+    // denominator = 1 - k * |x|
+    den.hi = fputil::multiply_add(x_d, k, 1.0);
+    DoubleDouble prod = fputil::exact_mult(x_d, k);
+    // Using Dekker's 2SUM algorithm to compute the lower part.
+    den.lo = ((1.0 - den.hi) + prod.hi) + prod.lo;
+
+    // x_r = (|x| - k) / (1 + k * |x|)
+    DoubleDouble x_r = fputil::div(num, den);
+
+    // Approximating atan(x_r) using Taylor polynomial.
+    DoubleDouble p = atan_eval(x_r);
+
+    // atan(x) = sign(x) * (atan(k) + atan(x_r))
+    //         = sign(x) * (atan(k) + atan( (|x| - k) / (1 + k * |x|) ))
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+    return IS_NEG[x_sign] * (ATAN_I[idx].hi + (p.hi + (p.lo + ATAN_I[idx].lo)));
+#else
+
+    DoubleDouble c0 = fputil::exact_add(ATAN_I[idx].hi, p.hi);
+    double c1 = c0.lo + (ATAN_I[idx].lo + p.lo);
+    double r = IS_NEG[x_sign] * (c0.hi + c1);
+
+    return r;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  }
+
+  // |x| >= 2^53 or x is NaN.
+  if (LIBC_UNLIKELY(x_exp >= 53)) {
+    // x is nan
+    if (xbits.is_nan()) {
+      if (xbits.is_signaling_nan()) {
+        fputil::raise_except_if_required(FE_INVALID);
+        return FPBits::quiet_nan().get_val();
+      }
+      return x;
+    }
+    // |x| >= 2^53
+    // atan(x) ~ sign(x) * pi/2.
+    if (x_exp >= 53)
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+      return IS_NEG[x_sign] * PI_OVER_2.hi;
+#else
+      return fputil::multiply_add(IS_NEG[x_sign], PI_OVER_2.hi,
+                                  IS_NEG[x_sign] * PI_OVER_2.lo);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  }
+
+  double x_d = xbits.get_val();
+  double y = 1.0 / x_d;
+
+  // k = 2^-6 * round(2^6 / |x|)
+  double k = fputil::nearest_integer(0x1.0p6 * y);
+  unsigned idx = static_cast<unsigned>(k);
+  k *= 0x1.0p-6;
+
+  // denominator = |x| + k
+  DoubleDouble den = fputil::exact_add(x_d, k);
+  // numerator = 1 - k * |x|
+  DoubleDouble num;
+  num.hi = fputil::multiply_add(-x_d, k, 1.0);
+  DoubleDouble prod = fputil::exact_mult(x_d, k);
+  // Using Dekker's 2SUM algorithm to compute the lower part.
+  num.lo = ((1.0 - num.hi) - prod.hi) - prod.lo;
+
+  // x_r = (1/|x| - k) / (1 - k/|x|)
+  //     = (1 - k * |x|) / (|x| - k)
+  DoubleDouble x_r = fputil::div(num, den);
+
+  // Approximating atan(x_r) using Taylor polynomial.
+  DoubleDouble p = atan_eval(x_r);
+
+  // atan(x) = sign(x) * (pi/2 - atan(1/|x|))
+  //         = sign(x) * (pi/2 - atan(k) - atan(x_r))
+  //         = (-sign(x)) * (-pi/2 + atan(k) + atan((1 - k*|x|)/(|x| - k)))
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  double lo_part = p.lo + ATAN_I[idx].lo + MPI_OVER_2.lo;
+  return IS_NEG[!x_sign] * (MPI_OVER_2.hi + ATAN_I[idx].hi + (p.hi + lo_part));
+#else
+  DoubleDouble c0 = fputil::exact_add(MPI_OVER_2.hi, ATAN_I[idx].hi);
+  DoubleDouble c1 = fputil::exact_add(c0.hi, p.hi);
+  double c2 = c1.lo + (c0.lo + p.lo) + (ATAN_I[idx].lo + MPI_OVER_2.lo);
+
+  double r = IS_NEG[!x_sign] * (c1.hi + c2);
+
+  return r;
+#endif
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atan2.cpp b/src/math/generic/atan2.cpp
index 1b16e15..8adfe33 100644
--- a/src/math/generic/atan2.cpp
+++ b/src/math/generic/atan2.cpp
@@ -7,133 +7,16 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/math/atan2.h"
-#include "inv_trigf_utils.h"
+#include "atan_utils.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/double_double.h"
 #include "src/__support/FPUtil/multiply_add.h"
 #include "src/__support/FPUtil/nearest_integer.h"
-#include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
 namespace LIBC_NAMESPACE_DECL {
 
-namespace {
-
-using DoubleDouble = fputil::DoubleDouble;
-
-// atan(i/64) with i = 0..64, generated by Sollya with:
-// > for i from 0 to 64 do {
-//     a = round(atan(i/64), D, RN);
-//     b = round(atan(i/64) - a, D, RN);
-//     print("{", b, ",", a, "},");
-//   };
-constexpr fputil::DoubleDouble ATAN_I[65] = {
-    {0.0, 0.0},
-    {-0x1.220c39d4dff5p-61, 0x1.fff555bbb729bp-7},
-    {-0x1.5ec431444912cp-60, 0x1.ffd55bba97625p-6},
-    {-0x1.86ef8f794f105p-63, 0x1.7fb818430da2ap-5},
-    {-0x1.c934d86d23f1dp-60, 0x1.ff55bb72cfdeap-5},
-    {0x1.ac4ce285df847p-58, 0x1.3f59f0e7c559dp-4},
-    {-0x1.cfb654c0c3d98p-58, 0x1.7ee182602f10fp-4},
-    {0x1.f7b8f29a05987p-58, 0x1.be39ebe6f07c3p-4},
-    {-0x1.cd37686760c17p-59, 0x1.fd5ba9aac2f6ep-4},
-    {-0x1.b485914dacf8cp-59, 0x1.1e1fafb043727p-3},
-    {0x1.61a3b0ce9281bp-57, 0x1.3d6eee8c6626cp-3},
-    {-0x1.054ab2c010f3dp-58, 0x1.5c9811e3ec26ap-3},
-    {0x1.347b0b4f881cap-58, 0x1.7b97b4bce5b02p-3},
-    {0x1.cf601e7b4348ep-59, 0x1.9a6a8e96c8626p-3},
-    {0x1.17b10d2e0e5abp-61, 0x1.b90d7529260a2p-3},
-    {0x1.c648d1534597ep-57, 0x1.d77d5df205736p-3},
-    {0x1.8ab6e3cf7afbdp-57, 0x1.f5b75f92c80ddp-3},
-    {0x1.62e47390cb865p-56, 0x1.09dc597d86362p-2},
-    {0x1.30ca4748b1bf9p-57, 0x1.18bf5a30bf178p-2},
-    {-0x1.077cdd36dfc81p-56, 0x1.278372057ef46p-2},
-    {-0x1.963a544b672d8p-57, 0x1.362773707ebccp-2},
-    {-0x1.5d5e43c55b3bap-56, 0x1.44aa436c2af0ap-2},
-    {-0x1.2566480884082p-57, 0x1.530ad9951cd4ap-2},
-    {-0x1.a725715711fp-56, 0x1.614840309cfe2p-2},
-    {-0x1.c63aae6f6e918p-56, 0x1.6f61941e4def1p-2},
-    {0x1.69c885c2b249ap-56, 0x1.7d5604b63b3f7p-2},
-    {0x1.b6d0ba3748fa8p-56, 0x1.8b24d394a1b25p-2},
-    {0x1.9e6c988fd0a77p-56, 0x1.98cd5454d6b18p-2},
-    {-0x1.24dec1b50b7ffp-56, 0x1.a64eec3cc23fdp-2},
-    {0x1.ae187b1ca504p-56, 0x1.b3a911da65c6cp-2},
-    {-0x1.cc1ce70934c34p-56, 0x1.c0db4c94ec9fp-2},
-    {-0x1.a2cfa4418f1adp-56, 0x1.cde53432c1351p-2},
-    {0x1.a2b7f222f65e2p-56, 0x1.dac670561bb4fp-2},
-    {0x1.0e53dc1bf3435p-56, 0x1.e77eb7f175a34p-2},
-    {-0x1.a3992dc382a23p-57, 0x1.f40dd0b541418p-2},
-    {-0x1.b32c949c9d593p-55, 0x1.0039c73c1a40cp-1},
-    {-0x1.d5b495f6349e6p-56, 0x1.0657e94db30dp-1},
-    {0x1.974fa13b5404fp-58, 0x1.0c6145b5b43dap-1},
-    {-0x1.2bdaee1c0ee35p-58, 0x1.1255d9bfbd2a9p-1},
-    {0x1.c621cec00c301p-55, 0x1.1835a88be7c13p-1},
-    {-0x1.928df287a668fp-58, 0x1.1e00babdefeb4p-1},
-    {0x1.c421c9f38224ep-57, 0x1.23b71e2cc9e6ap-1},
-    {-0x1.09e73b0c6c087p-56, 0x1.2958e59308e31p-1},
-    {0x1.c5d5e9ff0cf8dp-55, 0x1.2ee628406cbcap-1},
-    {0x1.1021137c71102p-55, 0x1.345f01cce37bbp-1},
-    {-0x1.2304331d8bf46p-55, 0x1.39c391cd4171ap-1},
-    {0x1.ecf8b492644fp-56, 0x1.3f13fb89e96f4p-1},
-    {-0x1.f76d0163f79c8p-56, 0x1.445065b795b56p-1},
-    {0x1.2419a87f2a458p-56, 0x1.4978fa3269ee1p-1},
-    {0x1.4a33dbeb3796cp-55, 0x1.4e8de5bb6ec04p-1},
-    {-0x1.1bb74abda520cp-55, 0x1.538f57b89061fp-1},
-    {-0x1.5e5c9d8c5a95p-56, 0x1.587d81f732fbbp-1},
-    {0x1.0028e4bc5e7cap-57, 0x1.5d58987169b18p-1},
-    {-0x1.2b785350ee8c1p-57, 0x1.6220d115d7b8ep-1},
-    {-0x1.6ea6febe8bbbap-56, 0x1.66d663923e087p-1},
-    {-0x1.a80386188c50ep-55, 0x1.6b798920b3d99p-1},
-    {-0x1.8c34d25aadef6p-56, 0x1.700a7c5784634p-1},
-    {0x1.7b2a6165884a1p-59, 0x1.748978fba8e0fp-1},
-    {0x1.406a08980374p-55, 0x1.78f6bbd5d315ep-1},
-    {0x1.560821e2f3aa9p-55, 0x1.7d528289fa093p-1},
-    {-0x1.bf76229d3b917p-56, 0x1.819d0b7158a4dp-1},
-    {0x1.6b66e7fc8b8c3p-57, 0x1.85d69576cc2c5p-1},
-    {-0x1.55b9a5e177a1bp-55, 0x1.89ff5ff57f1f8p-1},
-    {-0x1.ec182ab042f61p-56, 0x1.8e17aa99cc05ep-1},
-    {0x1.1a62633145c07p-55, 0x1.921fb54442d18p-1},
-};
-
-// Approximate atan(x) for |x| <= 2^-7.
-// Using degree-9 Taylor polynomial:
-//  P = x - x^3/3 + x^5/5 -x^7/7 + x^9/9;
-// Then the absolute error is bounded by:
-//   |atan(x) - P(x)| < |x|^11/11 < 2^(-7*11) / 11 < 2^-80.
-// And the relative error is bounded by:
-//   |(atan(x) - P(x))/atan(x)| < |x|^10 / 10 < 2^-73.
-// For x = x_hi + x_lo, fully expand the polynomial and drop any terms less than
-//   ulp(x_hi^3 / 3) gives us:
-// P(x) ~ x_hi - x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
-//        + x_lo * (1 - x_hi^2 + x_hi^4)
-DoubleDouble atan_eval(const DoubleDouble &x) {
-  DoubleDouble p;
-  p.hi = x.hi;
-  double x_hi_sq = x.hi * x.hi;
-  // c0 ~ x_hi^2 * 1/5 - 1/3
-  double c0 = fputil::multiply_add(x_hi_sq, 0x1.999999999999ap-3,
-                                   -0x1.5555555555555p-2);
-  // c1 ~ x_hi^2 * 1/9 - 1/7
-  double c1 = fputil::multiply_add(x_hi_sq, 0x1.c71c71c71c71cp-4,
-                                   -0x1.2492492492492p-3);
-  // x_hi^3
-  double x_hi_3 = x_hi_sq * x.hi;
-  // x_hi^4
-  double x_hi_4 = x_hi_sq * x_hi_sq;
-  // d0 ~ 1/3 - x_hi^2 / 5 + x_hi^4 / 7 - x_hi^6 / 9
-  double d0 = fputil::multiply_add(x_hi_4, c1, c0);
-  // x_lo - x_lo * x_hi^2 + x_lo * x_hi^4
-  double d1 = fputil::multiply_add(x_hi_4 - x_hi_sq, x.lo, x.lo);
-  // p.lo ~ -x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
-  //        + x_lo * (1 - x_hi^2 + x_hi^4)
-  p.lo = fputil::multiply_add(x_hi_3, d0, d1);
-  return p;
-}
-
-} // anonymous namespace
-
 // There are several range reduction steps we can take for atan2(y, x) as
 // follow:
 
diff --git a/src/math/generic/atan2f.cpp b/src/math/generic/atan2f.cpp
index a2e5499..726cae9 100644
--- a/src/math/generic/atan2f.cpp
+++ b/src/math/generic/atan2f.cpp
@@ -17,10 +17,20 @@
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 
+#if defined(LIBC_MATH_HAS_SKIP_ACCURATE_PASS) &&                               \
+    defined(LIBC_MATH_HAS_INTERMEDIATE_COMP_IN_FLOAT)
+
+// We use float-float implementation to reduce size.
+#include "src/math/generic/atan2f_float.h"
+
+#else
+
 namespace LIBC_NAMESPACE_DECL {
 
 namespace {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
 // Look up tables for accurate pass:
 
 // atan(i/16) with i = 0..16, generated by Sollya with:
@@ -121,7 +131,7 @@ float atan2f_double_double(double num_d, double den_d, double q_d, int idx,
     num_r = num_d;
     den_r = den_d;
   }
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   q.lo = fputil::multiply_add(q.hi, -den_r, num_r) / den_r;
 #else
   // Compute `(num_r - q.hi * den_r) / den_r` accurately without FMA
@@ -130,7 +140,7 @@ float atan2f_double_double(double num_d, double den_d, double q_d, int idx,
   double t1 = fputil::multiply_add(q_hi_dd.hi, -den_r, num_r); // Exact
   double t2 = fputil::multiply_add(q_hi_dd.lo, -den_r, t1);
   q.lo = t2 / den_r;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // Taylor polynomial, evaluating using Horner's scheme:
   //   P = x - x^3/3 + x^5/5 -x^7/7 + x^9/9 - x^11/11 + x^13/13 - x^15/15
@@ -163,6 +173,8 @@ float atan2f_double_double(double num_d, double den_d, double q_d, int idx,
   return static_cast<float>(cpp::bit_cast<double>(rr_bits));
 }
 
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
 } // anonymous namespace
 
 // There are several range reduction steps we can take for atan2(y, x) as
@@ -283,14 +295,24 @@ LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
   fputil::DoubleDouble const_term = CONST_ADJ[x_sign][y_sign][recip];
   double q_d = num_d / den_d;
 
-  double k_d = fputil::nearest_integer(q_d * 0x1.0p4f);
+  double k_d = fputil::nearest_integer(q_d * 0x1.0p4);
   int idx = static_cast<int>(k_d);
+  double r;
+
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+  double p = atan_eval_no_table(num_d, den_d, k_d * 0x1.0p-4);
+  r = final_sign * (p + (const_term.hi + ATAN_K_OVER_16[idx]));
+#else
   q_d = fputil::multiply_add(k_d, -0x1.0p-4, q_d);
 
   double p = atan_eval(q_d, idx);
-  double r = final_sign *
-             fputil::multiply_add(q_d, p, const_term.hi + ATAN_COEFFS[idx][0]);
+  r = final_sign *
+      fputil::multiply_add(q_d, p, const_term.hi + ATAN_COEFFS[idx][0]);
+#endif // LIBC_MATH_HAS_SMALL_TABLES
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return static_cast<float>(r);
+#else
   constexpr uint32_t LOWER_ERR = 4;
   // Mask sticky bits in double precision before rounding to single precision.
   constexpr uint32_t MASK =
@@ -306,6 +328,9 @@ LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
 
   return atan2f_double_double(num_d, den_d, q_d, idx, k_d, final_sign,
                               const_term);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
+
+#endif
diff --git a/src/math/generic/atan2f_float.h b/src/math/generic/atan2f_float.h
new file mode 100644
index 0000000..1fd853d
--- /dev/null
+++ b/src/math/generic/atan2f_float.h
@@ -0,0 +1,237 @@
+//===-- Single-precision atan2f function ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/FPUtil/nearest_integer.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
+#include "src/math/atan2f.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace {
+
+using FloatFloat = fputil::FloatFloat;
+
+// atan(i/64) with i = 0..16, generated by Sollya with:
+// > for i from 0 to 16 do {
+//     a = round(atan(i/16), SG, RN);
+//     b = round(atan(i/16) - a, SG, RN);
+//     print("{", b, ",", a, "},");
+//   };
+constexpr FloatFloat ATAN_I[17] = {
+    {0.0f, 0.0f},
+    {-0x1.1a6042p-30f, 0x1.ff55bcp-5f},
+    {-0x1.54f424p-30f, 0x1.fd5baap-4f},
+    {0x1.79cb6p-28f, 0x1.7b97b4p-3f},
+    {-0x1.b4dfc8p-29f, 0x1.f5b76p-3f},
+    {-0x1.1f0286p-27f, 0x1.362774p-2f},
+    {0x1.e4defp-30f, 0x1.6f6194p-2f},
+    {0x1.e611fep-29f, 0x1.a64eecp-2f},
+    {0x1.586ed4p-28f, 0x1.dac67p-2f},
+    {-0x1.6499e6p-26f, 0x1.0657eap-1f},
+    {0x1.7bdfd6p-26f, 0x1.1e00bap-1f},
+    {-0x1.98e422p-28f, 0x1.345f02p-1f},
+    {0x1.934f7p-28f, 0x1.4978fap-1f},
+    {0x1.c5a6c6p-27f, 0x1.5d5898p-1f},
+    {0x1.5e118cp-27f, 0x1.700a7cp-1f},
+    {-0x1.1d4eb6p-26f, 0x1.819d0cp-1f},
+    {-0x1.777a5cp-26f, 0x1.921fb6p-1f},
+};
+
+// Approximate atan(x) for |x| <= 2^-5.
+// Using degree-3 Taylor polynomial:
+//  P = x - x^3/3
+// Then the absolute error is bounded by:
+//   |atan(x) - P(x)| < |x|^5/5 < 2^(-5*5) / 5 < 2^-27.
+// And the relative error is bounded by:
+//   |(atan(x) - P(x))/atan(x)| < |x|^4 / 4 < 2^-22.
+// For x = x_hi + x_lo, fully expand the polynomial and drop any terms less than
+//   ulp(x_hi^3 / 3) gives us:
+// P(x) ~ x_hi - x_hi^3/3 + x_lo * (1 - x_hi^2)
+FloatFloat atan_eval(const FloatFloat &x) {
+  FloatFloat p;
+  p.hi = x.hi;
+  float x_hi_sq = x.hi * x.hi;
+  // c0 ~ - x_hi^2 / 3
+  float c0 = -0x1.555556p-2f * x_hi_sq;
+  // c1 ~ x_lo * (1 - x_hi^2)
+  float c1 = fputil::multiply_add(x_hi_sq, -x.lo, x.lo);
+  // p.lo ~ - x_hi^3 / 3 + x_lo * (1 - x_hi*2)
+  p.lo = fputil::multiply_add(x.hi, c0, c1);
+  return p;
+}
+
+} // anonymous namespace
+
+// There are several range reduction steps we can take for atan2(y, x) as
+// follow:
+
+// * Range reduction 1: signness
+// atan2(y, x) will return a number between -PI and PI representing the angle
+// forming by the 0x axis and the vector (x, y) on the 0xy-plane.
+// In particular, we have that:
+//   atan2(y, x) = atan( y/x )         if x >= 0 and y >= 0 (I-quadrant)
+//               = pi + atan( y/x )    if x < 0 and y >= 0  (II-quadrant)
+//               = -pi + atan( y/x )   if x < 0 and y < 0   (III-quadrant)
+//               = atan( y/x )         if x >= 0 and y < 0  (IV-quadrant)
+// Since atan function is odd, we can use the formula:
+//   atan(-u) = -atan(u)
+// to adjust the above conditions a bit further:
+//   atan2(y, x) = atan( |y|/|x| )         if x >= 0 and y >= 0 (I-quadrant)
+//               = pi - atan( |y|/|x| )    if x < 0 and y >= 0  (II-quadrant)
+//               = -pi + atan( |y|/|x| )   if x < 0 and y < 0   (III-quadrant)
+//               = -atan( |y|/|x| )        if x >= 0 and y < 0  (IV-quadrant)
+// Which can be simplified to:
+//   atan2(y, x) = sign(y) * atan( |y|/|x| )             if x >= 0
+//               = sign(y) * (pi - atan( |y|/|x| ))      if x < 0
+
+// * Range reduction 2: reciprocal
+// Now that the argument inside atan is positive, we can use the formula:
+//   atan(1/x) = pi/2 - atan(x)
+// to make the argument inside atan <= 1 as follow:
+//   atan2(y, x) = sign(y) * atan( |y|/|x|)            if 0 <= |y| <= x
+//               = sign(y) * (pi/2 - atan( |x|/|y| )   if 0 <= x < |y|
+//               = sign(y) * (pi - atan( |y|/|x| ))    if 0 <= |y| <= -x
+//               = sign(y) * (pi/2 + atan( |x|/|y| ))  if 0 <= -x < |y|
+
+// * Range reduction 3: look up table.
+// After the previous two range reduction steps, we reduce the problem to
+// compute atan(u) with 0 <= u <= 1, or to be precise:
+//   atan( n / d ) where n = min(|x|, |y|) and d = max(|x|, |y|).
+// An accurate polynomial approximation for the whole [0, 1] input range will
+// require a very large degree.  To make it more efficient, we reduce the input
+// range further by finding an integer idx such that:
+//   | n/d - idx/16 | <= 1/32.
+// In particular,
+//   idx := 2^-4 * round(2^4 * n/d)
+// Then for the fast pass, we find a polynomial approximation for:
+//   atan( n/d ) ~ atan( idx/16 ) + (n/d - idx/16) * Q(n/d - idx/16)
+// with Q(x) = x - x^3/3 be the cubic Taylor polynomial of atan(x).
+// It's error in float-float precision is estimated in Sollya to be:
+// > P = x - x^3/3;
+// > dirtyinfnorm(atan(x) - P, [-2^-5, 2^-5]);
+// 0x1.995...p-28.
+
+LLVM_LIBC_FUNCTION(float, atan2f, (float y, float x)) {
+  using FPBits = typename fputil::FPBits<float>;
+  constexpr float IS_NEG[2] = {1.0f, -1.0f};
+  constexpr FloatFloat ZERO = {0.0f, 0.0f};
+  constexpr FloatFloat MZERO = {-0.0f, -0.0f};
+  constexpr FloatFloat PI = {-0x1.777a5cp-24f, 0x1.921fb6p1f};
+  constexpr FloatFloat MPI = {0x1.777a5cp-24f, -0x1.921fb6p1f};
+  constexpr FloatFloat PI_OVER_4 = {-0x1.777a5cp-26f, 0x1.921fb6p-1f};
+  constexpr FloatFloat PI_OVER_2 = {-0x1.777a5cp-25f, 0x1.921fb6p0f};
+  constexpr FloatFloat MPI_OVER_2 = {-0x1.777a5cp-25f, 0x1.921fb6p0f};
+  constexpr FloatFloat THREE_PI_OVER_4 = {-0x1.99bc5cp-28f, 0x1.2d97c8p1f};
+  // Adjustment for constant term:
+  //   CONST_ADJ[x_sign][y_sign][recip]
+  constexpr FloatFloat CONST_ADJ[2][2][2] = {
+      {{ZERO, MPI_OVER_2}, {MZERO, MPI_OVER_2}},
+      {{MPI, PI_OVER_2}, {MPI, PI_OVER_2}}};
+
+  FPBits x_bits(x), y_bits(y);
+  bool x_sign = x_bits.sign().is_neg();
+  bool y_sign = y_bits.sign().is_neg();
+  x_bits = x_bits.abs();
+  y_bits = y_bits.abs();
+  uint32_t x_abs = x_bits.uintval();
+  uint32_t y_abs = y_bits.uintval();
+  bool recip = x_abs < y_abs;
+  uint32_t min_abs = recip ? x_abs : y_abs;
+  uint32_t max_abs = !recip ? x_abs : y_abs;
+  auto min_exp = static_cast<unsigned>(min_abs >> FPBits::FRACTION_LEN);
+  auto max_exp = static_cast<unsigned>(max_abs >> FPBits::FRACTION_LEN);
+
+  float num = FPBits(min_abs).get_val();
+  float den = FPBits(max_abs).get_val();
+
+  // Check for exceptional cases, whether inputs are 0, inf, nan, or close to
+  // overflow, or close to underflow.
+  if (LIBC_UNLIKELY(max_exp > 0xffU - 64U || min_exp < 64U)) {
+    if (x_bits.is_nan() || y_bits.is_nan())
+      return FPBits::quiet_nan().get_val();
+    unsigned x_except = x == 0.0f ? 0 : (FPBits(x_abs).is_inf() ? 2 : 1);
+    unsigned y_except = y == 0.0f ? 0 : (FPBits(y_abs).is_inf() ? 2 : 1);
+
+    // Exceptional cases:
+    //   EXCEPT[y_except][x_except][x_is_neg]
+    // with x_except & y_except:
+    //   0: zero
+    //   1: finite, non-zero
+    //   2: infinity
+    constexpr FloatFloat EXCEPTS[3][3][2] = {
+        {{ZERO, PI}, {ZERO, PI}, {ZERO, PI}},
+        {{PI_OVER_2, PI_OVER_2}, {ZERO, ZERO}, {ZERO, PI}},
+        {{PI_OVER_2, PI_OVER_2},
+         {PI_OVER_2, PI_OVER_2},
+         {PI_OVER_4, THREE_PI_OVER_4}},
+    };
+
+    if ((x_except != 1) || (y_except != 1)) {
+      FloatFloat r = EXCEPTS[y_except][x_except][x_sign];
+      return fputil::multiply_add(IS_NEG[y_sign], r.hi, IS_NEG[y_sign] * r.lo);
+    }
+    bool scale_up = min_exp < 64U;
+    bool scale_down = max_exp > 0xffU - 64U;
+    // At least one input is denormal, multiply both numerator and denominator
+    // by some large enough power of 2 to normalize denormal inputs.
+    if (scale_up) {
+      num *= 0x1.0p32f;
+      if (!scale_down)
+        den *= 0x1.0p32f;
+    } else if (scale_down) {
+      den *= 0x1.0p-32f;
+      num *= 0x1.0p-32f;
+    }
+
+    min_abs = FPBits(num).uintval();
+    max_abs = FPBits(den).uintval();
+    min_exp = static_cast<unsigned>(min_abs >> FPBits::FRACTION_LEN);
+    max_exp = static_cast<unsigned>(max_abs >> FPBits::FRACTION_LEN);
+  }
+
+  float final_sign = IS_NEG[(x_sign != y_sign) != recip];
+  FloatFloat const_term = CONST_ADJ[x_sign][y_sign][recip];
+  unsigned exp_diff = max_exp - min_exp;
+  // We have the following bound for normalized n and d:
+  //   2^(-exp_diff - 1) < n/d < 2^(-exp_diff + 1).
+  if (LIBC_UNLIKELY(exp_diff > 25))
+    return fputil::multiply_add(final_sign, const_term.hi,
+                                final_sign * (const_term.lo + num / den));
+
+  float k = fputil::nearest_integer(16.0f * num / den);
+  unsigned idx = static_cast<unsigned>(k);
+  // k = idx / 16
+  k *= 0x1.0p-4f;
+
+  // Range reduction:
+  // atan(n/d) - atan(k/64) = atan((n/d - k/16) / (1 + (n/d) * (k/16)))
+  //                        = atan((n - d * k/16)) / (d + n * k/16))
+  FloatFloat num_k = fputil::exact_mult(num, k);
+  FloatFloat den_k = fputil::exact_mult(den, k);
+
+  // num_dd = n - d * k
+  FloatFloat num_ff = fputil::exact_add(num - den_k.hi, -den_k.lo);
+  // den_dd = d + n * k
+  FloatFloat den_ff = fputil::exact_add(den, num_k.hi);
+  den_ff.lo += num_k.lo;
+
+  // q = (n - d * k) / (d + n * k)
+  FloatFloat q = fputil::div(num_ff, den_ff);
+  // p ~ atan(q)
+  FloatFloat p = atan_eval(q);
+
+  FloatFloat r = fputil::add(const_term, fputil::add(ATAN_I[idx], p));
+  return final_sign * r.hi;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/atan_utils.h b/src/math/generic/atan_utils.h
new file mode 100644
index 0000000..3331843
--- /dev/null
+++ b/src/math/generic/atan_utils.h
@@ -0,0 +1,137 @@
+//===-- Collection of utils for atan/atan2 ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_GENERIC_ATAN_UTILS_H
+#define LLVM_LIBC_SRC_MATH_GENERIC_ATAN_UTILS_H
+
+#include "src/__support/FPUtil/double_double.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace {
+
+using DoubleDouble = fputil::DoubleDouble;
+
+// atan(i/64) with i = 0..64, generated by Sollya with:
+// > for i from 0 to 64 do {
+//     a = round(atan(i/64), D, RN);
+//     b = round(atan(i/64) - a, D, RN);
+//     print("{", b, ",", a, "},");
+//   };
+constexpr fputil::DoubleDouble ATAN_I[65] = {
+    {0.0, 0.0},
+    {-0x1.220c39d4dff5p-61, 0x1.fff555bbb729bp-7},
+    {-0x1.5ec431444912cp-60, 0x1.ffd55bba97625p-6},
+    {-0x1.86ef8f794f105p-63, 0x1.7fb818430da2ap-5},
+    {-0x1.c934d86d23f1dp-60, 0x1.ff55bb72cfdeap-5},
+    {0x1.ac4ce285df847p-58, 0x1.3f59f0e7c559dp-4},
+    {-0x1.cfb654c0c3d98p-58, 0x1.7ee182602f10fp-4},
+    {0x1.f7b8f29a05987p-58, 0x1.be39ebe6f07c3p-4},
+    {-0x1.cd37686760c17p-59, 0x1.fd5ba9aac2f6ep-4},
+    {-0x1.b485914dacf8cp-59, 0x1.1e1fafb043727p-3},
+    {0x1.61a3b0ce9281bp-57, 0x1.3d6eee8c6626cp-3},
+    {-0x1.054ab2c010f3dp-58, 0x1.5c9811e3ec26ap-3},
+    {0x1.347b0b4f881cap-58, 0x1.7b97b4bce5b02p-3},
+    {0x1.cf601e7b4348ep-59, 0x1.9a6a8e96c8626p-3},
+    {0x1.17b10d2e0e5abp-61, 0x1.b90d7529260a2p-3},
+    {0x1.c648d1534597ep-57, 0x1.d77d5df205736p-3},
+    {0x1.8ab6e3cf7afbdp-57, 0x1.f5b75f92c80ddp-3},
+    {0x1.62e47390cb865p-56, 0x1.09dc597d86362p-2},
+    {0x1.30ca4748b1bf9p-57, 0x1.18bf5a30bf178p-2},
+    {-0x1.077cdd36dfc81p-56, 0x1.278372057ef46p-2},
+    {-0x1.963a544b672d8p-57, 0x1.362773707ebccp-2},
+    {-0x1.5d5e43c55b3bap-56, 0x1.44aa436c2af0ap-2},
+    {-0x1.2566480884082p-57, 0x1.530ad9951cd4ap-2},
+    {-0x1.a725715711fp-56, 0x1.614840309cfe2p-2},
+    {-0x1.c63aae6f6e918p-56, 0x1.6f61941e4def1p-2},
+    {0x1.69c885c2b249ap-56, 0x1.7d5604b63b3f7p-2},
+    {0x1.b6d0ba3748fa8p-56, 0x1.8b24d394a1b25p-2},
+    {0x1.9e6c988fd0a77p-56, 0x1.98cd5454d6b18p-2},
+    {-0x1.24dec1b50b7ffp-56, 0x1.a64eec3cc23fdp-2},
+    {0x1.ae187b1ca504p-56, 0x1.b3a911da65c6cp-2},
+    {-0x1.cc1ce70934c34p-56, 0x1.c0db4c94ec9fp-2},
+    {-0x1.a2cfa4418f1adp-56, 0x1.cde53432c1351p-2},
+    {0x1.a2b7f222f65e2p-56, 0x1.dac670561bb4fp-2},
+    {0x1.0e53dc1bf3435p-56, 0x1.e77eb7f175a34p-2},
+    {-0x1.a3992dc382a23p-57, 0x1.f40dd0b541418p-2},
+    {-0x1.b32c949c9d593p-55, 0x1.0039c73c1a40cp-1},
+    {-0x1.d5b495f6349e6p-56, 0x1.0657e94db30dp-1},
+    {0x1.974fa13b5404fp-58, 0x1.0c6145b5b43dap-1},
+    {-0x1.2bdaee1c0ee35p-58, 0x1.1255d9bfbd2a9p-1},
+    {0x1.c621cec00c301p-55, 0x1.1835a88be7c13p-1},
+    {-0x1.928df287a668fp-58, 0x1.1e00babdefeb4p-1},
+    {0x1.c421c9f38224ep-57, 0x1.23b71e2cc9e6ap-1},
+    {-0x1.09e73b0c6c087p-56, 0x1.2958e59308e31p-1},
+    {0x1.c5d5e9ff0cf8dp-55, 0x1.2ee628406cbcap-1},
+    {0x1.1021137c71102p-55, 0x1.345f01cce37bbp-1},
+    {-0x1.2304331d8bf46p-55, 0x1.39c391cd4171ap-1},
+    {0x1.ecf8b492644fp-56, 0x1.3f13fb89e96f4p-1},
+    {-0x1.f76d0163f79c8p-56, 0x1.445065b795b56p-1},
+    {0x1.2419a87f2a458p-56, 0x1.4978fa3269ee1p-1},
+    {0x1.4a33dbeb3796cp-55, 0x1.4e8de5bb6ec04p-1},
+    {-0x1.1bb74abda520cp-55, 0x1.538f57b89061fp-1},
+    {-0x1.5e5c9d8c5a95p-56, 0x1.587d81f732fbbp-1},
+    {0x1.0028e4bc5e7cap-57, 0x1.5d58987169b18p-1},
+    {-0x1.2b785350ee8c1p-57, 0x1.6220d115d7b8ep-1},
+    {-0x1.6ea6febe8bbbap-56, 0x1.66d663923e087p-1},
+    {-0x1.a80386188c50ep-55, 0x1.6b798920b3d99p-1},
+    {-0x1.8c34d25aadef6p-56, 0x1.700a7c5784634p-1},
+    {0x1.7b2a6165884a1p-59, 0x1.748978fba8e0fp-1},
+    {0x1.406a08980374p-55, 0x1.78f6bbd5d315ep-1},
+    {0x1.560821e2f3aa9p-55, 0x1.7d528289fa093p-1},
+    {-0x1.bf76229d3b917p-56, 0x1.819d0b7158a4dp-1},
+    {0x1.6b66e7fc8b8c3p-57, 0x1.85d69576cc2c5p-1},
+    {-0x1.55b9a5e177a1bp-55, 0x1.89ff5ff57f1f8p-1},
+    {-0x1.ec182ab042f61p-56, 0x1.8e17aa99cc05ep-1},
+    {0x1.1a62633145c07p-55, 0x1.921fb54442d18p-1},
+};
+
+// Approximate atan(x) for |x| <= 2^-7.
+// Using degree-9 Taylor polynomial:
+//  P = x - x^3/3 + x^5/5 -x^7/7 + x^9/9;
+// Then the absolute error is bounded by:
+//   |atan(x) - P(x)| < |x|^11/11 < 2^(-7*11) / 11 < 2^-80.
+// And the relative error is bounded by:
+//   |(atan(x) - P(x))/atan(x)| < |x|^10 / 10 < 2^-73.
+// For x = x_hi + x_lo, fully expand the polynomial and drop any terms less than
+//   ulp(x_hi^3 / 3) gives us:
+// P(x) ~ x_hi - x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
+//        + x_lo * (1 - x_hi^2 + x_hi^4)
+// Since p.lo is ~ x^3/3, the relative error from rounding is bounded by:
+//   |(atan(x) - P(x))/atan(x)| < ulp(x^2) <= 2^(-14-52) = 2^-66.
+DoubleDouble atan_eval(const DoubleDouble &x) {
+  DoubleDouble p;
+  p.hi = x.hi;
+  double x_hi_sq = x.hi * x.hi;
+  // c0 ~ x_hi^2 * 1/5 - 1/3
+  double c0 = fputil::multiply_add(x_hi_sq, 0x1.999999999999ap-3,
+                                   -0x1.5555555555555p-2);
+  // c1 ~ x_hi^2 * 1/9 - 1/7
+  double c1 = fputil::multiply_add(x_hi_sq, 0x1.c71c71c71c71cp-4,
+                                   -0x1.2492492492492p-3);
+  // x_hi^3
+  double x_hi_3 = x_hi_sq * x.hi;
+  // x_hi^4
+  double x_hi_4 = x_hi_sq * x_hi_sq;
+  // d0 ~ 1/3 - x_hi^2 / 5 + x_hi^4 / 7 - x_hi^6 / 9
+  double d0 = fputil::multiply_add(x_hi_4, c1, c0);
+  // x_lo - x_lo * x_hi^2 + x_lo * x_hi^4
+  double d1 = fputil::multiply_add(x_hi_4 - x_hi_sq, x.lo, x.lo);
+  // p.lo ~ -x_hi^3/3 + x_hi^5/5 - x_hi^7/7 + x_hi^9/9 +
+  //        + x_lo * (1 - x_hi^2 + x_hi^4)
+  p.lo = fputil::multiply_add(x_hi_3, d0, d1);
+  return p;
+}
+
+} // anonymous namespace
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_GENERIC_ATAN_UTILS_H
diff --git a/src/math/generic/atanf.cpp b/src/math/generic/atanf.cpp
index 5e0788e..46196db 100644
--- a/src/math/generic/atanf.cpp
+++ b/src/math/generic/atanf.cpp
@@ -52,12 +52,12 @@ LLVM_LIBC_FUNCTION(float, atanf, (float x)) {
       return x;
     // x <= 2^-12;
     if (LIBC_UNLIKELY(x_abs < 0x3980'0000)) {
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
       return fputil::multiply_add(x, -0x1.0p-25f, x);
 #else
       double x_d = static_cast<double>(x);
       return static_cast<float>(fputil::multiply_add(x_d, -0x1.0p-25, x_d));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     }
     // Use Taylor polynomial:
     //   atan(x) ~ x * (1 - x^2 / 3 + x^4 / 5 - x^6 / 7 + x^8 / 9 - x^10 / 11).
diff --git a/src/math/generic/cbrt.cpp b/src/math/generic/cbrt.cpp
index ee7d69b..ce227e6 100644
--- a/src/math/generic/cbrt.cpp
+++ b/src/math/generic/cbrt.cpp
@@ -58,7 +58,7 @@ double intial_approximation(double x) {
 
 // Get the error term for Newton iteration:
 //   h(x) = x^3 * a^2 - 1,
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 double get_error(const DoubleDouble &x_3, const DoubleDouble &a_sq) {
   return fputil::multiply_add(x_3.hi, a_sq.hi, -1.0) +
          fputil::multiply_add(x_3.lo, a_sq.hi, x_3.hi * a_sq.lo);
diff --git a/src/math/generic/cbrtf.cpp b/src/math/generic/cbrtf.cpp
index 0abbf6e..71b23c4 100644
--- a/src/math/generic/cbrtf.cpp
+++ b/src/math/generic/cbrtf.cpp
@@ -25,7 +25,7 @@ constexpr double CBRT2[3] = {1.0, 0x1.428a2f98d728bp0, 0x1.965fea53d6e3dp0};
 // Degree-7 polynomials approximation of ((1 + x)^(1/3) - 1)/x for 0 <= x <= 1
 // generated by Sollya with:
 // > for i from 0 to 15 do {
-//     P = fpminimax((1 + x)^(1/3) - 1)/x, 6, [|D...|], [i/16, (i + 1)/16]);
+//     P = fpminimax(((1 + x)^(1/3) - 1)/x, 6, [|D...|], [i/16, (i + 1)/16]);
 //     print("{", coeff(P, 0), ",", coeff(P, 1), ",", coeff(P, 2), ",",
 //           coeff(P, 3), ",", coeff(P, 4), ",", coeff(P, 5), ",",
 //           coeff(P, 6), "},");
diff --git a/src/math/generic/common_constants.cpp b/src/math/generic/common_constants.cpp
index e29c083..3088ef9 100644
--- a/src/math/generic/common_constants.cpp
+++ b/src/math/generic/common_constants.cpp
@@ -112,7 +112,7 @@ const double LOG_F[128] = {
 // precision, and -2^-8 <= v < 2^-7.
 // TODO(lntue): Add reference to how the constants are derived after the
 // resulting paper is ready.
-alignas(32) const float R[128] = {
+alignas(8) const float R[128] = {
     0x1p0,     0x1.fcp-1, 0x1.f8p-1, 0x1.f4p-1, 0x1.fp-1,  0x1.ecp-1, 0x1.e8p-1,
     0x1.e4p-1, 0x1.ep-1,  0x1.dep-1, 0x1.dap-1, 0x1.d6p-1, 0x1.d4p-1, 0x1.dp-1,
     0x1.ccp-1, 0x1.cap-1, 0x1.c6p-1, 0x1.c4p-1, 0x1.cp-1,  0x1.bep-1, 0x1.bap-1,
@@ -133,7 +133,7 @@ alignas(32) const float R[128] = {
     0x1.0ap-1, 0x1.08p-1, 0x1.08p-1, 0x1.06p-1, 0x1.06p-1, 0x1.04p-1, 0x1.04p-1,
     0x1.02p-1, 0x1.0p-1};
 
-alignas(64) const double RD[128] = {
+const double RD[128] = {
     0x1p0,     0x1.fcp-1, 0x1.f8p-1, 0x1.f4p-1, 0x1.fp-1,  0x1.ecp-1, 0x1.e8p-1,
     0x1.e4p-1, 0x1.ep-1,  0x1.dep-1, 0x1.dap-1, 0x1.d6p-1, 0x1.d4p-1, 0x1.dp-1,
     0x1.ccp-1, 0x1.cap-1, 0x1.c6p-1, 0x1.c4p-1, 0x1.cp-1,  0x1.bep-1, 0x1.bap-1,
@@ -158,7 +158,7 @@ alignas(64) const double RD[128] = {
 // available.
 // Generated by Sollya with the formula: CD[i] = RD[i]*(1 + i*2^-7) - 1
 // for RD[i] defined on the table above.
-alignas(64) const double CD[128] = {
+const double CD[128] = {
     0.0,        -0x1p-14,   -0x1p-12,   -0x1.2p-11,  -0x1p-10,   -0x1.9p-10,
     -0x1.2p-9,  -0x1.88p-9, -0x1p-8,    -0x1.9p-11,  -0x1.fp-10, -0x1.9cp-9,
     -0x1p-12,   -0x1.cp-10, -0x1.bp-9,  -0x1.5p-11,  -0x1.4p-9,  0x1p-14,
@@ -183,7 +183,7 @@ alignas(64) const double CD[128] = {
     -0x1p-14,   -0x1p-8,
 };
 
-alignas(64) const double LOG_R[128] = {
+const double LOG_R[128] = {
     0x0.0000000000000p0,  0x1.010157588de71p-7, 0x1.0205658935847p-6,
     0x1.8492528c8cabfp-6, 0x1.0415d89e74444p-5, 0x1.466aed42de3eap-5,
     0x1.894aa149fb343p-5, 0x1.ccb73cdddb2ccp-5, 0x1.08598b59e3a07p-4,
@@ -228,7 +228,7 @@ alignas(64) const double LOG_R[128] = {
     0x1.5707a26bb8c66p-1, 0x1.5af405c3649ep-1,  0x1.5af405c3649ep-1,
     0x1.5ee82aa24192p-1,  0x0.000000000000p0};
 
-alignas(64) const double LOG2_R[128] = {
+const double LOG2_R[128] = {
     0x0.0000000000000p+0, 0x1.72c7ba20f7327p-7, 0x1.743ee861f3556p-6,
     0x1.184b8e4c56af8p-5, 0x1.77394c9d958d5p-5, 0x1.d6ebd1f1febfep-5,
     0x1.1bb32a600549dp-4, 0x1.4c560fe68af88p-4, 0x1.7d60496cfbb4cp-4,
@@ -281,7 +281,7 @@ alignas(64) const double LOG2_R[128] = {
 //     print("{", -c, ",", -b, "},");
 //   };
 // We replace LOG_R[0] with log10(1.0) == 0.0
-alignas(64) const NumberPair<double> LOG_R_DD[128] = {
+alignas(16) const NumberPair<double> LOG_R_DD[128] = {
     {0.0, 0.0},
     {-0x1.0c76b999d2be8p-46, 0x1.010157589p-7},
     {-0x1.3dc5b06e2f7d2p-45, 0x1.0205658938p-6},
@@ -417,7 +417,7 @@ alignas(64) const NumberPair<double> LOG_R_DD[128] = {
 // Output range:
 //   [-0x1.3ffcp-15, 0x1.3e3dp-15]
 // We store S2[i] = 2^16 (r(i - 2^6) - 1).
-alignas(64) const int S2[193] = {
+alignas(8) const int S2[193] = {
     0x101,  0xfd,   0xf9,   0xf5,   0xf1,   0xed,   0xe9,   0xe5,   0xe1,
     0xdd,   0xd9,   0xd5,   0xd1,   0xcd,   0xc9,   0xc5,   0xc1,   0xbd,
     0xb9,   0xb4,   0xb0,   0xac,   0xa8,   0xa4,   0xa0,   0x9c,   0x98,
@@ -441,7 +441,7 @@ alignas(64) const int S2[193] = {
     -0x1cd, -0x1d1, -0x1d5, -0x1d9, -0x1dd, -0x1e0, -0x1e4, -0x1e8, -0x1ec,
     -0x1f0, -0x1f4, -0x1f8, -0x1fc};
 
-alignas(64) const double R2[193] = {
+const double R2[193] = {
     0x1.0101p0,  0x1.00fdp0,  0x1.00f9p0,  0x1.00f5p0,  0x1.00f1p0,
     0x1.00edp0,  0x1.00e9p0,  0x1.00e5p0,  0x1.00e1p0,  0x1.00ddp0,
     0x1.00d9p0,  0x1.00d5p0,  0x1.00d1p0,  0x1.00cdp0,  0x1.00c9p0,
@@ -488,7 +488,7 @@ alignas(64) const double R2[193] = {
 // Output range:
 //   [-0x1.01928p-22 , 0x1p-22]
 // We store S[i] = 2^21 (r(i - 80) - 1).
-alignas(64) const int S3[161] = {
+alignas(8) const int S3[161] = {
     0x50,  0x4f,  0x4e,  0x4d,  0x4c,  0x4b,  0x4a,  0x49,  0x48,  0x47,  0x46,
     0x45,  0x44,  0x43,  0x42,  0x41,  0x40,  0x3f,  0x3e,  0x3d,  0x3c,  0x3b,
     0x3a,  0x39,  0x38,  0x37,  0x36,  0x35,  0x34,  0x33,  0x32,  0x31,  0x30,
@@ -511,7 +511,7 @@ alignas(64) const int S3[161] = {
 // Output range:
 //   [-0x1.0002143p-29 , 0x1p-29]
 // We store S[i] = 2^28 (r(i - 65) - 1).
-alignas(64) const int S4[130] = {
+alignas(8) const int S4[130] = {
     0x41,  0x40,  0x3f,  0x3e,  0x3d,  0x3c,  0x3b,  0x3a,  0x39,  0x38,  0x37,
     0x36,  0x35,  0x34,  0x33,  0x32,  0x31,  0x30,  0x2f,  0x2e,  0x2d,  0x2c,
     0x2b,  0x2a,  0x29,  0x28,  0x27,  0x26,  0x25,  0x24,  0x23,  0x22,  0x21,
@@ -661,7 +661,7 @@ const double EXP_M2[128] = {
 //     d = round(a - b - c, D, RN);
 //     print("{", d, ",", c, ",", b, "},");
 //   };
-const fputil::TripleDouble EXP2_MID1[64] = {
+alignas(16) const fputil::TripleDouble EXP2_MID1[64] = {
     {0, 0, 0x1p0},
     {-0x1.9085b0a3d74d5p-110, -0x1.19083535b085dp-56, 0x1.02c9a3e778061p0},
     {0x1.05ff94f8d257ep-110, 0x1.d73e2a475b465p-55, 0x1.059b0d3158574p0},
@@ -739,7 +739,7 @@ const fputil::TripleDouble EXP2_MID1[64] = {
 //     d = round(a - b - c, D, RN);
 //     print("{", d, ",", c, ",", b, "},");
 //   };
-const fputil::TripleDouble EXP2_MID2[64] = {
+alignas(16) const fputil::TripleDouble EXP2_MID2[64] = {
     {0, 0, 0x1p0},
     {0x1.39726694630e3p-108, 0x1.ae8e38c59c72ap-54, 0x1.000b175effdc7p0},
     {0x1.e5e06ddd31156p-112, -0x1.7b5d0d58ea8f4p-58, 0x1.00162f3904052p0},
diff --git a/src/math/generic/cos.cpp b/src/math/generic/cos.cpp
index 568b125..b60082b 100644
--- a/src/math/generic/cos.cpp
+++ b/src/math/generic/cos.cpp
@@ -20,11 +20,11 @@
 #include "src/math/generic/range_reduction_double_common.h"
 #include "src/math/generic/sincos_eval.h"
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 #include "range_reduction_double_fma.h"
 #else
 #include "range_reduction_double_nofma.h"
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/math/generic/cosf.cpp b/src/math/generic/cosf.cpp
index 972ffa9..6ea24f9 100644
--- a/src/math/generic/cosf.cpp
+++ b/src/math/generic/cosf.cpp
@@ -20,6 +20,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Exceptional cases for cosf.
 static constexpr size_t N_EXCEPTS = 6;
 
@@ -38,6 +39,7 @@ static constexpr fputil::ExceptValues<float, N_EXCEPTS> COSF_EXCEPTS{{
     // x = 0x1.ddebdep120, cos(x) = 0x1.114438p-1 (RZ)
     {0x7beef5ef, 0x3f08a21c, 1, 0, 0},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, cosf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -101,15 +103,17 @@ LLVM_LIBC_FUNCTION(float, cosf, (float x)) {
     // |x| < 2^-125. For targets without FMA instructions, we simply use
     // double for intermediate results as it is more efficient than using an
     // emulated version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
     return fputil::multiply_add(xbits.get_val(), -0x1.0p-25f, 1.0f);
 #else
     return static_cast<float>(fputil::multiply_add(xd, -0x1.0p-25, 1.0));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = COSF_EXCEPTS.lookup(x_abs); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // x is inf or nan.
   if (LIBC_UNLIKELY(x_abs >= 0x7f80'0000U)) {
diff --git a/src/math/generic/cosf16.cpp b/src/math/generic/cosf16.cpp
new file mode 100644
index 0000000..4d42db9
--- /dev/null
+++ b/src/math/generic/cosf16.cpp
@@ -0,0 +1,88 @@
+//===-- Half-precision cos(x) function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cosf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+constexpr size_t N_EXCEPTS = 4;
+
+constexpr fputil::ExceptValues<float16, N_EXCEPTS> COSF16_EXCEPTS{{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    {0x2b7c, 0x3bfc, 1, 0, 1},
+    {0x4ac1, 0x38b5, 1, 0, 0},
+    {0x5c49, 0xb8c6, 0, 1, 0},
+    {0x7acc, 0xa474, 0, 1, 0},
+}};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+LLVM_LIBC_FUNCTION(float16, cosf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+  // Range reduction:
+  // For |x| > pi/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * pi/32
+  //   k is an integer, |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32/pi)
+  //   y = x * 32/pi - k
+  //
+  // Once k and y are computed, we then deduce the answer by the cosine of sum
+  // formula:
+  //   cos(x) = cos((k + y) * pi/32)
+  //          = cos(k * pi/32) * cos(y * pi/32) -
+  //            sin(k * pi/32) * sin(y * pi/32)
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  // Handle exceptional values
+  if (auto r = COSF16_EXCEPTS.lookup(x_abs); LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+  // cos(+/-0) = 1
+  if (LIBC_UNLIKELY(x_abs == 0U))
+    return fputil::cast<float16>(1.0f);
+
+  // cos(+/-inf) = NaN, and cos(NaN) = NaN
+  if (xbits.is_inf_or_nan()) {
+    if (xbits.is_inf()) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+    }
+
+    return x + FPBits::quiet_nan().get_val();
+  }
+
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincosf16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+  // Since, cosm1_y = cos_y - 1, therefore:
+  //   cos(x) = cos_k * cos_y - sin_k * sin_y
+  //          = cos_k * (cos_y - 1 + 1) - sin_k * sin_y
+  //          = cos_k * cosm1_y - sin_k * sin_y + cos_k
+  return fputil::cast<float16>(fputil::multiply_add(
+      cos_k, cosm1_y, fputil::multiply_add(-sin_k, sin_y, cos_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/coshf16.cpp b/src/math/generic/coshf16.cpp
index cca7581..6668e77 100644
--- a/src/math/generic/coshf16.cpp
+++ b/src/math/generic/coshf16.cpp
@@ -20,6 +20,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 9> COSHF16_EXCEPTS_POS = {{
     // x = 0x1.6ap-5, coshf16(x) = 0x1p+0 (RZ)
     {0x29a8U, 0x3c00U, 1U, 0U, 1U},
@@ -51,6 +52,7 @@ static constexpr fputil::ExceptValues<float16, 4> COSHF16_EXCEPTS_NEG = {{
     // x = -0x1.5fp+3, coshf16(x) = 0x1.c54p+14 (RZ)
     {0xc97cU, 0x7715U, 1U, 0U, 1U},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, coshf16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -89,6 +91,7 @@ LLVM_LIBC_FUNCTION(float16, coshf16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (x_bits.is_pos()) {
     if (auto r = COSHF16_EXCEPTS_POS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
       return r.value();
@@ -96,6 +99,7 @@ LLVM_LIBC_FUNCTION(float16, coshf16, (float16 x)) {
     if (auto r = COSHF16_EXCEPTS_NEG.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
       return r.value();
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   return eval_sinh_or_cosh</*IsSinh=*/false>(x);
 }
diff --git a/src/math/generic/cospif.cpp b/src/math/generic/cospif.cpp
index 4ef1539..29566f4 100644
--- a/src/math/generic/cospif.cpp
+++ b/src/math/generic/cospif.cpp
@@ -50,11 +50,11 @@ LLVM_LIBC_FUNCTION(float, cospif, (float x)) {
   // The exhautive test passes for smaller values
   if (LIBC_UNLIKELY(x_abs < 0x38A2'F984U)) {
 
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
     return fputil::multiply_add(xbits.get_val(), -0x1.0p-25f, 1.0f);
 #else
     return static_cast<float>(fputil::multiply_add(xd, -0x1.0p-25, 1.0));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
   }
 
   // Numbers greater or equal to 2^23 are always integers or NaN
diff --git a/src/math/generic/cospif16.cpp b/src/math/generic/cospif16.cpp
index 384b39f..ee74bdb 100644
--- a/src/math/generic/cospif16.cpp
+++ b/src/math/generic/cospif16.cpp
@@ -73,7 +73,7 @@ LLVM_LIBC_FUNCTION(float16, cospif16, (float16 x)) {
     return fputil::cast<float16>(0.0f);
 
   // Since, cosm1_y = cos_y - 1, therefore:
-  // 	cos(x * pi) = cos_k(cosm1_y) + cos_k - sin_k * sin_y
+  //   cos(x * pi) = cos_k(cosm1_y) + cos_k - sin_k * sin_y
   return fputil::cast<float16>(fputil::multiply_add(
       cos_k, cosm1_y, fputil::multiply_add(-sin_k, sin_y, cos_k)));
 }
diff --git a/src/math/generic/erff.cpp b/src/math/generic/erff.cpp
index 1535745..016afe4 100644
--- a/src/math/generic/erff.cpp
+++ b/src/math/generic/erff.cpp
@@ -141,6 +141,7 @@ LLVM_LIBC_FUNCTION(float, erff, (float x)) {
     return ONE[sign] + SMALL[sign];
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Exceptional mask = common 0 bits of 2 exceptional values.
   constexpr uint32_t EXCEPT_MASK = 0x809a'6184U;
 
@@ -155,6 +156,7 @@ LLVM_LIBC_FUNCTION(float, erff, (float x)) {
     if (x_abs == 0U)
       return x;
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // Polynomial approximation:
   //   erf(x) ~ x * (c0 + c1 * x^2 + c2 * x^4 + ... + c7 * x^14)
diff --git a/src/math/generic/exp.cpp b/src/math/generic/exp.cpp
index 38b683a..143800c 100644
--- a/src/math/generic/exp.cpp
+++ b/src/math/generic/exp.cpp
@@ -39,8 +39,11 @@ constexpr double LOG2_E = 0x1.71547652b82fep+0;
 // Error bounds:
 // Errors when using double precision.
 constexpr double ERR_D = 0x1.8p-63;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Errors when using double-double precision.
 constexpr double ERR_DD = 0x1.0p-99;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 // -2^-12 * log(2)
 // > a = -2^-12 * log(2);
@@ -50,8 +53,11 @@ constexpr double ERR_DD = 0x1.0p-99;
 // Errors < 1.5 * 2^-133
 constexpr double MLOG_2_EXP2_M12_HI = -0x1.62e42ffp-13;
 constexpr double MLOG_2_EXP2_M12_MID = 0x1.718432a1b0e26p-47;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 constexpr double MLOG_2_EXP2_M12_MID_30 = 0x1.718432ap-47;
 constexpr double MLOG_2_EXP2_M12_LO = 0x1.b0e2633fe0685p-79;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 namespace {
 
@@ -72,6 +78,7 @@ LIBC_INLINE double poly_approx_d(double dx) {
   return p;
 }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Polynomial approximation with double-double precision:
 // Return exp(dx) ~ 1 + dx + dx^2 / 2 + ... + dx^6 / 720
 // For |dx| < 2^-13 + 2^-30:
@@ -171,6 +178,7 @@ DoubleDouble exp_double_double(double x, double kd,
 
   return r;
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 // Check for exceptional cases when
 // |x| <= 2^-53 or x < log(2^-1075) or x >= 0x1.6232bdd7abcd3p+9
@@ -373,6 +381,19 @@ LLVM_LIBC_FUNCTION(double, exp, (double x)) {
 
   double lo = fputil::multiply_add(p, mid_lo, exp_mid.lo);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  if (LIBC_UNLIKELY(denorm)) {
+    return ziv_test_denorm</*SKIP_ZIV_TEST=*/true>(hi, exp_mid.hi, lo, ERR_D)
+        .value();
+  } else {
+    // to multiply by 2^hi, a fast way is to simply add hi to the exponent
+    // field.
+    int64_t exp_hi = static_cast<int64_t>(hi) << FPBits::FRACTION_LEN;
+    double r =
+        cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(exp_mid.hi + lo));
+    return r;
+  }
+#else
   if (LIBC_UNLIKELY(denorm)) {
     if (auto r = ziv_test_denorm(hi, exp_mid.hi, lo, ERR_D);
         LIBC_LIKELY(r.has_value()))
@@ -413,6 +434,7 @@ LLVM_LIBC_FUNCTION(double, exp, (double x)) {
   Float128 r_f128 = exp_f128(x, kd, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10.cpp b/src/math/generic/exp10.cpp
index 748c8a2..c464979 100644
--- a/src/math/generic/exp10.cpp
+++ b/src/math/generic/exp10.cpp
@@ -44,15 +44,20 @@ constexpr double LOG2_10 = 0x1.a934f0979a371p+1;
 // Errors < 1.5 * 2^-144
 constexpr double MLOG10_2_EXP2_M12_HI = -0x1.3441350ap-14;
 constexpr double MLOG10_2_EXP2_M12_MID = 0x1.0c0219dc1da99p-51;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 constexpr double MLOG10_2_EXP2_M12_MID_32 = 0x1.0c0219dcp-51;
 constexpr double MLOG10_2_EXP2_M12_LO = 0x1.da994fd20dba2p-87;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 // Error bounds:
 // Errors when using double precision.
 constexpr double ERR_D = 0x1.8p-63;
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Errors when using double-double precision.
 constexpr double ERR_DD = 0x1.8p-99;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 namespace {
 
@@ -72,6 +77,7 @@ LIBC_INLINE double poly_approx_d(double dx) {
   return p;
 }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Polynomial approximation with double-double precision.  Generated by Solya
 // with:
 // > P = fpminimax((10^x - 1)/x, 5, [|DD...|], [-2^-14, 2^-14]);
@@ -171,6 +177,7 @@ DoubleDouble exp10_double_double(double x, double kd,
 
   return r;
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 // When output is denormal.
 double exp10_denorm(double x) {
@@ -199,6 +206,10 @@ double exp10_denorm(double x) {
 
   double lo = fputil::multiply_add(p, mid_lo, exp_mid.lo);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return ziv_test_denorm</*SKIP_ZIV_TEST=*/true>(hi, exp_mid.hi, lo, ERR_D)
+      .value();
+#else
   if (auto r = ziv_test_denorm(hi, exp_mid.hi, lo, ERR_D);
       LIBC_LIKELY(r.has_value()))
     return r.value();
@@ -214,6 +225,7 @@ double exp10_denorm(double x) {
   Float128 r_f128 = exp10_f128(x, kd, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 // Check for exceptional cases when:
@@ -391,6 +403,12 @@ LLVM_LIBC_FUNCTION(double, exp10, (double x)) {
 
   double lo = fputil::multiply_add(p, mid_lo, exp_mid.lo);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  int64_t exp_hi = static_cast<int64_t>(hi) << FPBits::FRACTION_LEN;
+  double r =
+      cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(exp_mid.hi + lo));
+  return r;
+#else
   double upper = exp_mid.hi + (lo + ERR_D);
   double lower = exp_mid.hi + (lo - ERR_D);
 
@@ -473,6 +491,7 @@ LLVM_LIBC_FUNCTION(double, exp10, (double x)) {
   Float128 r_f128 = exp10_f128(x, kd, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp10f16.cpp b/src/math/generic/exp10f16.cpp
index 006dd5c..31abf3b 100644
--- a/src/math/generic/exp10f16.cpp
+++ b/src/math/generic/exp10f16.cpp
@@ -26,7 +26,8 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_EXP10F16_EXCEPTS = 5;
 #else
 static constexpr size_t N_EXP10F16_EXCEPTS = 8;
@@ -44,7 +45,7 @@ static constexpr fputil::ExceptValues<float16, N_EXP10F16_EXCEPTS>
         {0xbf0aU, 0x2473U, 1U, 0U, 0U},
         // x = -0x1.e1cp+1, exp10f16(x) = 0x1.694p-13 (RZ)
         {0xc387U, 0x09a5U, 1U, 0U, 0U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.0cp+1, exp10f16(x) = 0x1.f04p+6 (RZ)
         {0x4030U, 0x57c1U, 1U, 0U, 1U},
         // x = 0x1.1b8p+1, exp10f16(x) = 0x1.47cp+7 (RZ)
@@ -53,6 +54,7 @@ static constexpr fputil::ExceptValues<float16, N_EXP10F16_EXCEPTS>
         {0x446eU, 0x7690U, 1U, 0U, 1U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, exp10f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -119,8 +121,10 @@ LLVM_LIBC_FUNCTION(float16, exp10f16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP10F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // 10^x = 2^((hi + mid) * log2(10)) * 10^lo
   auto [exp2_hi_mid, exp10_lo] = exp10_range_reduction(x);
diff --git a/src/math/generic/exp10f_impl.h b/src/math/generic/exp10f_impl.h
index d741318..975fd01 100644
--- a/src/math/generic/exp10f_impl.h
+++ b/src/math/generic/exp10f_impl.h
@@ -10,12 +10,9 @@
 #define LLVM_LIBC_SRC_MATH_GENERIC_EXP10F_IMPL_H
 
 #include "explogxf.h"
-#include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
-#include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/multiply_add.h"
-#include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
diff --git a/src/math/generic/exp10m1f.cpp b/src/math/generic/exp10m1f.cpp
index c0e302e..e973b29 100644
--- a/src/math/generic/exp10m1f.cpp
+++ b/src/math/generic/exp10m1f.cpp
@@ -22,6 +22,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr size_t N_EXCEPTS_LO = 11;
 
 static constexpr fputil::ExceptValues<float, N_EXCEPTS_LO> EXP10M1F_EXCEPTS_LO =
@@ -94,6 +95,7 @@ static constexpr fputil::ExceptValues<float, N_EXCEPTS_HI> EXP10M1F_EXCEPTS_HI =
         // x = -0x1.ca4322p-5, exp10m1f(x) = -0x1.ef073p-4 (RZ)
         {0xbd65'2191U, 0xbdf7'8398U, 0U, 1U, 1U},
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, exp10m1f, (float x)) {
   using FPBits = fputil::FPBits<float>;
@@ -119,8 +121,10 @@ LLVM_LIBC_FUNCTION(float, exp10m1f, (float x)) {
 
   // When |x| <= log10(2) * 2^(-6)
   if (LIBC_UNLIKELY(x_abs <= 0x3b9a'209bU)) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     if (auto r = EXP10M1F_EXCEPTS_LO.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
       return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
     double dx = x;
     double dx_sq = dx * dx;
@@ -192,8 +196,10 @@ LLVM_LIBC_FUNCTION(float, exp10m1f, (float x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP10M1F_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // Range reduction: 10^x = 2^(mid + hi) * 10^lo
   //   rr = (2^(mid + hi), lo)
diff --git a/src/math/generic/exp10m1f16.cpp b/src/math/generic/exp10m1f16.cpp
index 449aedf..545c479 100644
--- a/src/math/generic/exp10m1f16.cpp
+++ b/src/math/generic/exp10m1f16.cpp
@@ -24,6 +24,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 3> EXP10M1F16_EXCEPTS_LO = {{
     // (input, RZ output, RU offset, RD offset, RN offset)
     // x = 0x1.5c4p-4, exp10m1f16(x) = 0x1.bacp-3 (RZ)
@@ -34,7 +35,7 @@ static constexpr fputil::ExceptValues<float16, 3> EXP10M1F16_EXCEPTS_LO = {{
     {0x9788U, 0x9c53U, 0U, 1U, 0U},
 }};
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_EXP10M1F16_EXCEPTS_HI = 3;
 #else
 static constexpr size_t N_EXP10M1F16_EXCEPTS_HI = 6;
@@ -49,7 +50,7 @@ static constexpr fputil::ExceptValues<float16, N_EXP10M1F16_EXCEPTS_HI>
         {0x3657U, 0x3df6U, 1U, 0U, 0U},
         // x = 0x1.d04p-2, exp10m1f16(x) = 0x1.d7p+0 (RZ)
         {0x3741U, 0x3f5cU, 1U, 0U, 1U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.0cp+1, exp10m1f16(x) = 0x1.ec4p+6 (RZ)
         {0x4030U, 0x57b1U, 1U, 0U, 1U},
         // x = 0x1.1b8p+1, exp10m1f16(x) = 0x1.45cp+7 (RZ)
@@ -58,6 +59,7 @@ static constexpr fputil::ExceptValues<float16, N_EXP10M1F16_EXCEPTS_HI>
         {0x44bdU, 0x7aaeU, 1U, 0U, 1U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, exp10m1f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -122,9 +124,11 @@ LLVM_LIBC_FUNCTION(float16, exp10m1f16, (float16 x)) {
       if (LIBC_UNLIKELY(x_abs == 0))
         return x;
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       if (auto r = EXP10M1F16_EXCEPTS_LO.lookup(x_u);
           LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       float xf = x;
       // Degree-5 minimax polynomial generated by Sollya with the following
@@ -153,8 +157,10 @@ LLVM_LIBC_FUNCTION(float16, exp10m1f16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP10M1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // exp10(x) = exp2((hi + mid) * log2(10)) * exp10(lo)
   auto [exp2_hi_mid, exp10_lo] = exp10_range_reduction(x);
diff --git a/src/math/generic/exp2.cpp b/src/math/generic/exp2.cpp
index 935548b..726f88b 100644
--- a/src/math/generic/exp2.cpp
+++ b/src/math/generic/exp2.cpp
@@ -35,14 +35,16 @@ using LIBC_NAMESPACE::operator""_u128;
 
 // Error bounds:
 // Errors when using double precision.
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 constexpr double ERR_D = 0x1.0p-63;
 #else
 constexpr double ERR_D = 0x1.8p-63;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Errors when using double-double precision.
 constexpr double ERR_DD = 0x1.0p-100;
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 namespace {
 
@@ -62,6 +64,7 @@ LIBC_INLINE double poly_approx_d(double dx) {
   return p;
 }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Polynomial approximation with double-double precision.  Generated by Solya
 // with:
 // > P = fpminimax((2^x - 1)/x, 5, [|DD...|], [-2^-13 - 2^-30, 2^-13 + 2^-30]);
@@ -147,6 +150,7 @@ DoubleDouble exp2_double_double(double x, const DoubleDouble &exp_mid) {
 
   return r;
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 // When output is denormal.
 double exp2_denorm(double x) {
@@ -174,6 +178,10 @@ double exp2_denorm(double x) {
 
   double lo = fputil::multiply_add(p, mid_lo, exp_mid.lo);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return ziv_test_denorm</*SKIP_ZIV_TEST=*/true>(hi, exp_mid.hi, lo, ERR_D)
+      .value();
+#else
   if (auto r = ziv_test_denorm(hi, exp_mid.hi, lo, ERR_D);
       LIBC_LIKELY(r.has_value()))
     return r.value();
@@ -189,6 +197,7 @@ double exp2_denorm(double x) {
   Float128 r_f128 = exp2_f128(dx, hi, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 // Check for exceptional cases when:
@@ -358,6 +367,14 @@ LLVM_LIBC_FUNCTION(double, exp2, (double x)) {
 
   double lo = fputil::multiply_add(p, mid_lo, exp_mid.lo);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  // To multiply by 2^hi, a fast way is to simply add hi to the exponent
+  // field.
+  int64_t exp_hi = static_cast<int64_t>(hi) << FPBits::FRACTION_LEN;
+  double r =
+      cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(exp_mid.hi + lo));
+  return r;
+#else
   double upper = exp_mid.hi + (lo + ERR_D);
   double lower = exp_mid.hi + (lo - ERR_D);
 
@@ -387,6 +404,7 @@ LLVM_LIBC_FUNCTION(double, exp2, (double x)) {
   Float128 r_f128 = exp2_f128(dx, hi, idx1, idx2);
 
   return static_cast<double>(r_f128);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/exp2f16.cpp b/src/math/generic/exp2f16.cpp
index 858053f..5c039c5 100644
--- a/src/math/generic/exp2f16.cpp
+++ b/src/math/generic/exp2f16.cpp
@@ -21,6 +21,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 3> EXP2F16_EXCEPTS = {{
     // (input, RZ output, RU offset, RD offset, RN offset)
     // x = 0x1.714p-11, exp2f16(x) = 0x1p+0 (RZ)
@@ -30,6 +31,7 @@ static constexpr fputil::ExceptValues<float16, 3> EXP2F16_EXCEPTS = {{
     // x = -0x1.d5cp-4, exp2f16(x) = 0x1.d8cp-1 (RZ)
     {0xaf57U, 0x3b63U, 1U, 0U, 0U},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, exp2f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -82,8 +84,10 @@ LLVM_LIBC_FUNCTION(float16, exp2f16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP2F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // exp2(x) = exp2(hi + mid) * exp2(lo)
   auto [exp2_hi_mid, exp2_lo] = exp2_range_reduction(x);
diff --git a/src/math/generic/exp2f_impl.h b/src/math/generic/exp2f_impl.h
index ae2d062..5c6c2bd 100644
--- a/src/math/generic/exp2f_impl.h
+++ b/src/math/generic/exp2f_impl.h
@@ -27,10 +27,6 @@ namespace LIBC_NAMESPACE_DECL {
 namespace generic {
 
 LIBC_INLINE float exp2f(float x) {
-  constexpr uint32_t EXVAL1 = 0x3b42'9d37U;
-  constexpr uint32_t EXVAL2 = 0xbcf3'a937U;
-  constexpr uint32_t EXVAL_MASK = EXVAL1 & EXVAL2;
-
   using FPBits = typename fputil::FPBits<float>;
   FPBits xbits(x);
 
@@ -46,6 +42,11 @@ LIBC_INLINE float exp2f(float x) {
         return 1.0f + x;
       }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+      constexpr uint32_t EXVAL1 = 0x3b42'9d37U;
+      constexpr uint32_t EXVAL2 = 0xbcf3'a937U;
+      constexpr uint32_t EXVAL_MASK = EXVAL1 & EXVAL2;
+
       // Check exceptional values.
       if (LIBC_UNLIKELY((x_u & EXVAL_MASK) == EXVAL_MASK)) {
         if (LIBC_UNLIKELY(x_u == EXVAL1)) { // x = 0x1.853a6ep-9f
@@ -54,6 +55,7 @@ LIBC_INLINE float exp2f(float x) {
           return fputil::round_result_slightly_down(0x1.f58d62p-1f);
         }
       }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       // Minimax polynomial generated by Sollya with:
       // > P = fpminimax((2^x - 1)/x, 5, [|D...|], [-2^-5, 2^-5]);
diff --git a/src/math/generic/exp2m1f.cpp b/src/math/generic/exp2m1f.cpp
index 2060dc3..4913a5e 100644
--- a/src/math/generic/exp2m1f.cpp
+++ b/src/math/generic/exp2m1f.cpp
@@ -23,6 +23,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr size_t N_EXCEPTS_LO = 8;
 
 static constexpr fputil::ExceptValues<float, N_EXCEPTS_LO> EXP2M1F_EXCEPTS_LO =
@@ -58,6 +59,7 @@ static constexpr fputil::ExceptValues<float, N_EXCEPTS_HI> EXP2M1F_EXCEPTS_HI =
         // x = -0x1.de7b9cp-5, exp2m1f(x) = -0x1.4508f4p-5 (RZ)
         {0xbd6f'3dceU, 0xbd22'847aU, 0U, 1U, 1U},
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, exp2m1f, (float x)) {
   using FPBits = fputil::FPBits<float>;
@@ -70,8 +72,10 @@ LLVM_LIBC_FUNCTION(float, exp2m1f, (float x)) {
   if (LIBC_UNLIKELY(x_abs >= 0x4300'0000U || x_abs <= 0x3d00'0000U)) {
     // |x| <= 2^-5
     if (x_abs <= 0x3d00'0000U) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       if (auto r = EXP2M1F_EXCEPTS_LO.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       // Minimax polynomial generated by Sollya with:
       // > display = hexadecimal;
@@ -121,8 +125,10 @@ LLVM_LIBC_FUNCTION(float, exp2m1f, (float x)) {
     return -1.0f;
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP2M1F_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // For -25 < x < 128, to compute 2^x, we perform the following range
   // reduction: find hi, mid, lo such that:
diff --git a/src/math/generic/exp2m1f16.cpp b/src/math/generic/exp2m1f16.cpp
index 6a1cd23..61633cd 100644
--- a/src/math/generic/exp2m1f16.cpp
+++ b/src/math/generic/exp2m1f16.cpp
@@ -24,6 +24,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 6> EXP2M1F16_EXCEPTS_LO = {{
     // (input, RZ output, RU offset, RD offset, RN offset)
     // x = 0x1.cf4p-13, exp2m1f16(x) = 0x1.41p-13 (RZ)
@@ -40,7 +41,7 @@ static constexpr fputil::ExceptValues<float16, 6> EXP2M1F16_EXCEPTS_LO = {{
     {0x973fU, 0x9505U, 0U, 1U, 0U},
 }};
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_EXP2M1F16_EXCEPTS_HI = 6;
 #else
 static constexpr size_t N_EXP2M1F16_EXCEPTS_HI = 7;
@@ -51,13 +52,13 @@ static constexpr fputil::ExceptValues<float16, N_EXP2M1F16_EXCEPTS_HI>
         // (input, RZ output, RU offset, RD offset, RN offset)
         // x = 0x1.e58p-3, exp2m1f16(x) = 0x1.6dcp-3 (RZ)
         {0x3396U, 0x31b7U, 1U, 0U, 0U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.2e8p-2, exp2m1f16(x) = 0x1.d14p-3 (RZ)
         {0x34baU, 0x3345U, 1U, 0U, 0U},
 #endif
         // x = 0x1.ad8p-2, exp2m1f16(x) = 0x1.598p-2 (RZ)
         {0x36b6U, 0x3566U, 1U, 0U, 0U},
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.edcp-2, exp2m1f16(x) = 0x1.964p-2 (RZ)
         {0x37b7U, 0x3659U, 1U, 0U, 1U},
 #endif
@@ -67,11 +68,12 @@ static constexpr fputil::ExceptValues<float16, N_EXP2M1F16_EXCEPTS_HI>
         {0xb3ccU, 0xb0f9U, 0U, 1U, 0U},
         // x = -0x1.294p-1, exp2m1f16(x) = -0x1.53p-2 (RZ)
         {0xb8a5U, 0xb54cU, 0U, 1U, 1U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = -0x1.a34p-1, exp2m1f16(x) = -0x1.bb4p-2 (RZ)
         {0xba8dU, 0xb6edU, 0U, 1U, 1U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, exp2m1f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -132,9 +134,11 @@ LLVM_LIBC_FUNCTION(float16, exp2m1f16, (float16 x)) {
 
     // When |x| <= 2^(-3).
     if (x_abs <= 0x3000U) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       if (auto r = EXP2M1F16_EXCEPTS_LO.lookup(x_u);
           LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       float xf = x;
       // Degree-5 minimax polynomial generated by Sollya with the following
@@ -149,8 +153,10 @@ LLVM_LIBC_FUNCTION(float16, exp2m1f16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXP2M1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // exp2(x) = exp2(hi + mid) * exp2(lo)
   auto [exp2_hi_mid, exp2_lo] = exp2_range_reduction(x);
diff --git a/src/math/generic/expf.cpp b/src/math/generic/expf.cpp
index ee5c2a3..fa507d4 100644
--- a/src/math/generic/expf.cpp
+++ b/src/math/generic/expf.cpp
@@ -28,10 +28,12 @@ LLVM_LIBC_FUNCTION(float, expf, (float x)) {
   uint32_t x_u = xbits.uintval();
   uint32_t x_abs = x_u & 0x7fff'ffffU;
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Exceptional values
   if (LIBC_UNLIKELY(x_u == 0xc236'bd8cU)) { // x = -0x1.6d7b18p+5f
     return 0x1.108a58p-66f - x * 0x1.0p-95f;
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // When |x| >= 89, |x| < 2^-25, or x is nan
   if (LIBC_UNLIKELY(x_abs >= 0x42b2'0000U || x_abs <= 0x3280'0000U)) {
diff --git a/src/math/generic/expf16.cpp b/src/math/generic/expf16.cpp
index 0548ef3..1af9b3e 100644
--- a/src/math/generic/expf16.cpp
+++ b/src/math/generic/expf16.cpp
@@ -22,6 +22,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 2> EXPF16_EXCEPTS_LO = {{
     // (input, RZ output, RU offset, RD offset, RN offset)
     // x = 0x1.de4p-8, expf16(x) = 0x1.01cp+0 (RZ)
@@ -39,6 +40,7 @@ static constexpr fputil::ExceptValues<float16, 3> EXPF16_EXCEPTS_HI = {{
     // x = -0x1.55p-5, expf16(x) = 0x1.ebp-1 (RZ)
     {0xa954U, 0x3bacU, 1U, 0U, 0U},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, expf16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -95,8 +97,10 @@ LLVM_LIBC_FUNCTION(float16, expf16, (float16 x)) {
 
     // When 0 < |x| <= 2^(-5).
     if (x_abs <= 0x2800U && !x_bits.is_zero()) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       if (auto r = EXPF16_EXCEPTS_LO.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       float xf = x;
       // Degree-3 minimax polynomial generated by Sollya with the following
@@ -109,8 +113,10 @@ LLVM_LIBC_FUNCTION(float16, expf16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXPF16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // exp(x) = exp(hi + mid) * exp(lo)
   auto [exp_hi_mid, exp_lo] = exp_range_reduction(x);
diff --git a/src/math/generic/explogxf.cpp b/src/math/generic/explogxf.cpp
index 9e945ec..d38efa0 100644
--- a/src/math/generic/explogxf.cpp
+++ b/src/math/generic/explogxf.cpp
@@ -12,7 +12,7 @@
 namespace LIBC_NAMESPACE_DECL {
 
 // N[Table[Log[2, 1 + x], {x, 0/64, 63/64, 1/64}], 40]
-alignas(64) const double LOG_P1_LOG2[LOG_P1_SIZE] = {
+alignas(8) const double LOG_P1_LOG2[LOG_P1_SIZE] = {
     0x0.0000000000000p+0, 0x1.6e79685c2d22ap-6, 0x1.6bad3758efd87p-5,
     0x1.0eb389fa29f9bp-4, 0x1.663f6fac91316p-4, 0x1.bc84240adabbap-4,
     0x1.08c588cda79e4p-3, 0x1.32ae9e278ae1ap-3, 0x1.5c01a39fbd688p-3,
@@ -38,7 +38,7 @@ alignas(64) const double LOG_P1_LOG2[LOG_P1_SIZE] = {
 };
 
 // N[Table[1/(1 + x), {x, 0/64, 63/64, 1/64}], 40]
-alignas(64) const double LOG_P1_1_OVER[LOG_P1_SIZE] = {
+alignas(8) const double LOG_P1_1_OVER[LOG_P1_SIZE] = {
     0x1.0000000000000p+0, 0x1.f81f81f81f820p-1, 0x1.f07c1f07c1f08p-1,
     0x1.e9131abf0b767p-1, 0x1.e1e1e1e1e1e1ep-1, 0x1.dae6076b981dbp-1,
     0x1.d41d41d41d41dp-1, 0x1.cd85689039b0bp-1, 0x1.c71c71c71c71cp-1,
@@ -64,11 +64,11 @@ alignas(64) const double LOG_P1_1_OVER[LOG_P1_SIZE] = {
 
 // Taylos series expansion for Log[2, 1 + x] splitted to EVEN AND ODD numbers
 // K_LOG2_ODD starts from x^3
-alignas(64) const
+alignas(8) const
     double K_LOG2_ODD[4] = {0x1.ec709dc3a03fdp-2, 0x1.2776c50ef9bfep-2,
                             0x1.a61762a7aded9p-3, 0x1.484b13d7c02a9p-3};
 
-alignas(64) const
+alignas(8) const
     double K_LOG2_EVEN[4] = {-0x1.71547652b82fep-1, -0x1.71547652b82fep-2,
                              -0x1.ec709dc3a03fdp-3, -0x1.2776c50ef9bfep-3};
 
diff --git a/src/math/generic/explogxf.h b/src/math/generic/explogxf.h
index 651524a..e79aa13 100644
--- a/src/math/generic/explogxf.h
+++ b/src/math/generic/explogxf.h
@@ -338,8 +338,9 @@ LIBC_INLINE static double log_eval(double x) {
 //   double(2^-1022 + x) - 2^-1022 = double(x).
 // So if we scale x up by 2^1022, we can use
 //   double(1.0 + 2^1022 * x) - 1.0 to test how x is rounded in denormal range.
-LIBC_INLINE cpp::optional<double> ziv_test_denorm(int hi, double mid, double lo,
-                                                  double err) {
+template <bool SKIP_ZIV_TEST = false>
+LIBC_INLINE static cpp::optional<double>
+ziv_test_denorm(int hi, double mid, double lo, double err) {
   using FPBits = typename fputil::FPBits<double>;
 
   // Scaling factor = 1/(min normal number) = 2^1022
@@ -360,22 +361,27 @@ LIBC_INLINE cpp::optional<double> ziv_test_denorm(int hi, double mid, double lo,
     scale_down = 0x3FF0'0000'0000'0000; // 1023 in the exponent field.
   }
 
-  double err_scaled =
-      cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(err));
-
-  double lo_u = lo_scaled + err_scaled;
-  double lo_l = lo_scaled - err_scaled;
-
   // By adding 1.0, the results will have similar rounding points as denormal
   // outputs.
-  double upper = extra_factor + (mid_hi + lo_u);
-  double lower = extra_factor + (mid_hi + lo_l);
+  if constexpr (SKIP_ZIV_TEST) {
+    double r = extra_factor + (mid_hi + lo_scaled);
+    return cpp::bit_cast<double>(cpp::bit_cast<uint64_t>(r) - scale_down);
+  } else {
+    double err_scaled =
+        cpp::bit_cast<double>(exp_hi + cpp::bit_cast<int64_t>(err));
 
-  if (LIBC_LIKELY(upper == lower)) {
-    return cpp::bit_cast<double>(cpp::bit_cast<uint64_t>(upper) - scale_down);
-  }
+    double lo_u = lo_scaled + err_scaled;
+    double lo_l = lo_scaled - err_scaled;
 
-  return cpp::nullopt;
+    double upper = extra_factor + (mid_hi + lo_u);
+    double lower = extra_factor + (mid_hi + lo_l);
+
+    if (LIBC_LIKELY(upper == lower)) {
+      return cpp::bit_cast<double>(cpp::bit_cast<uint64_t>(upper) - scale_down);
+    }
+
+    return cpp::nullopt;
+  }
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/expm1f.cpp b/src/math/generic/expm1f.cpp
index d5e9e85..1e44e94 100644
--- a/src/math/generic/expm1f.cpp
+++ b/src/math/generic/expm1f.cpp
@@ -38,14 +38,14 @@ LLVM_LIBC_FUNCTION(float, expm1f, (float x)) {
     return 0x1.8dbe62p-3f;
   }
 
-#if !defined(LIBC_TARGET_CPU_HAS_FMA)
+#if !defined(LIBC_TARGET_CPU_HAS_FMA_DOUBLE)
   if (LIBC_UNLIKELY(x_u == 0xbdc1'c6cbU)) { // x = -0x1.838d96p-4f
     int round_mode = fputil::quick_get_round();
     if (round_mode == FE_TONEAREST || round_mode == FE_DOWNWARD)
       return -0x1.71c884p-4f;
     return -0x1.71c882p-4f;
   }
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // When |x| > 25*log(2), or nan
   if (LIBC_UNLIKELY(x_abs >= 0x418a'a123U)) {
@@ -102,12 +102,12 @@ LLVM_LIBC_FUNCTION(float, expm1f, (float x)) {
         // 2^-76. For targets without FMA instructions, we simply use double for
         // intermediate results as it is more efficient than using an emulated
         // version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
-      return fputil::fma<float>(x, x, x);
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
+      return fputil::multiply_add(x, x, x);
 #else
       double xd = x;
       return static_cast<float>(fputil::multiply_add(xd, xd, xd));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     }
 
     constexpr double COEFFS[] = {0x1p-1,
diff --git a/src/math/generic/expm1f16.cpp b/src/math/generic/expm1f16.cpp
index 4ce0efd..2188dfb 100644
--- a/src/math/generic/expm1f16.cpp
+++ b/src/math/generic/expm1f16.cpp
@@ -23,13 +23,14 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 1> EXPM1F16_EXCEPTS_LO = {{
     // (input, RZ output, RU offset, RD offset, RN offset)
     // x = 0x1.564p-5, expm1f16(x) = 0x1.5d4p-5 (RZ)
     {0x2959U, 0x2975U, 1U, 0U, 1U},
 }};
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_EXPM1F16_EXCEPTS_HI = 2;
 #else
 static constexpr size_t N_EXPM1F16_EXCEPTS_HI = 3;
@@ -42,11 +43,12 @@ static constexpr fputil::ExceptValues<float16, N_EXPM1F16_EXCEPTS_HI>
         {0x3f0dU, 0x44d3U, 1U, 0U, 1U},
         // x = -0x1.e28p-3, expm1f16(x) = -0x1.adcp-3 (RZ)
         {0xb38aU, 0xb2b7U, 0U, 1U, 1U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.a08p-3, exp10m1f(x) = 0x1.cdcp-3 (RZ)
         {0x3282U, 0x3337U, 1U, 0U, 0U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, expm1f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -105,9 +107,12 @@ LLVM_LIBC_FUNCTION(float16, expm1f16, (float16 x)) {
 
     // When 0 < |x| <= 2^(-3).
     if (x_abs <= 0x3000U && !x_bits.is_zero()) {
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       if (auto r = EXPM1F16_EXCEPTS_LO.lookup(x_u);
           LIBC_UNLIKELY(r.has_value()))
         return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       float xf = x;
       // Degree-5 minimax polynomial generated by Sollya with the following
@@ -121,8 +126,10 @@ LLVM_LIBC_FUNCTION(float16, expm1f16, (float16 x)) {
     }
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = EXPM1F16_EXCEPTS_HI.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // exp(x) = exp(hi + mid) * exp(lo)
   auto [exp_hi_mid, exp_lo] = exp_range_reduction(x);
diff --git a/src/math/generic/fmul.cpp b/src/math/generic/fmul.cpp
index e759e48..daad648 100644
--- a/src/math/generic/fmul.cpp
+++ b/src/math/generic/fmul.cpp
@@ -21,7 +21,7 @@ LLVM_LIBC_FUNCTION(float, fmul, (double x, double y)) {
   // correctly rounded for all rounding modes, so we fall
   // back to the generic `fmul` implementation
 
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   return fputil::generic::mul<float>(x, y);
 #else
   fputil::DoubleDouble prod = fputil::exact_mult(x, y);
diff --git a/src/math/generic/hypotf.cpp b/src/math/generic/hypotf.cpp
index 959c042..ec48f62 100644
--- a/src/math/generic/hypotf.cpp
+++ b/src/math/generic/hypotf.cpp
@@ -55,7 +55,7 @@ LLVM_LIBC_FUNCTION(float, hypotf, (float x, float y)) {
 
   // These squares are exact.
   double a_sq = ad * ad;
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   double sum_sq = fputil::multiply_add(bd, bd, a_sq);
 #else
   double b_sq = bd * bd;
@@ -72,7 +72,7 @@ LLVM_LIBC_FUNCTION(float, hypotf, (float x, float y)) {
     double r_d = result.get_val();
 
     // Perform rounding correction.
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     double sum_sq_lo = fputil::multiply_add(bd, bd, a_sq - sum_sq);
     double err = sum_sq_lo - fputil::multiply_add(r_d, r_d, -sum_sq);
 #else
diff --git a/src/math/generic/inv_trigf_utils.h b/src/math/generic/inv_trigf_utils.h
index bdabec9..8b47aba 100644
--- a/src/math/generic/inv_trigf_utils.h
+++ b/src/math/generic/inv_trigf_utils.h
@@ -17,14 +17,35 @@
 namespace LIBC_NAMESPACE_DECL {
 
 // PI and PI / 2
-constexpr double M_MATH_PI = 0x1.921fb54442d18p+1;
-constexpr double M_MATH_PI_2 = 0x1.921fb54442d18p+0;
+static constexpr double M_MATH_PI = 0x1.921fb54442d18p+1;
+static constexpr double M_MATH_PI_2 = 0x1.921fb54442d18p+0;
 
 extern double ATAN_COEFFS[17][9];
 
+// Look-up table for atan(k/16) with k = 0..16.
+static constexpr double ATAN_K_OVER_16[17] = {
+    0.0,
+    0x1.ff55bb72cfdeap-5,
+    0x1.fd5ba9aac2f6ep-4,
+    0x1.7b97b4bce5b02p-3,
+    0x1.f5b75f92c80ddp-3,
+    0x1.362773707ebccp-2,
+    0x1.6f61941e4def1p-2,
+    0x1.a64eec3cc23fdp-2,
+    0x1.dac670561bb4fp-2,
+    0x1.0657e94db30dp-1,
+    0x1.1e00babdefeb4p-1,
+    0x1.345f01cce37bbp-1,
+    0x1.4978fa3269ee1p-1,
+    0x1.5d58987169b18p-1,
+    0x1.700a7c5784634p-1,
+    0x1.819d0b7158a4dp-1,
+    0x1.921fb54442d18p-1,
+};
+
 // For |x| <= 1/32 and 0 <= i <= 16, return Q(x) such that:
 //   Q(x) ~ (atan(x + i/16) - atan(i/16)) / x.
-LIBC_INLINE double atan_eval(double x, int i) {
+LIBC_INLINE static double atan_eval(double x, unsigned i) {
   double x2 = x * x;
 
   double c0 = fputil::multiply_add(x, ATAN_COEFFS[i][2], ATAN_COEFFS[i][1]);
@@ -39,16 +60,43 @@ LIBC_INLINE double atan_eval(double x, int i) {
   return p;
 }
 
+// Evaluate atan without big lookup table.
+//   atan(n/d) - atan(k/16) = atan((n/d - k/16) / (1 + (n/d) * (k/16)))
+//                          = atan((n - d * k/16)) / (d + n * k/16))
+// So we let q = (n - d * k/16) / (d + n * k/16),
+// and approximate with Taylor polynomial:
+//   atan(q) ~ q - q^3/3 + q^5/5 - q^7/7 + q^9/9
+LIBC_INLINE static double atan_eval_no_table(double num, double den,
+                                             double k_over_16) {
+  double num_r = fputil::multiply_add(den, -k_over_16, num);
+  double den_r = fputil::multiply_add(num, k_over_16, den);
+  double q = num_r / den_r;
+
+  constexpr double ATAN_TAYLOR[] = {
+      -0x1.5555555555555p-2,
+      0x1.999999999999ap-3,
+      -0x1.2492492492492p-3,
+      0x1.c71c71c71c71cp-4,
+  };
+  double q2 = q * q;
+  double q3 = q2 * q;
+  double q4 = q2 * q2;
+  double c0 = fputil::multiply_add(q2, ATAN_TAYLOR[1], ATAN_TAYLOR[0]);
+  double c1 = fputil::multiply_add(q2, ATAN_TAYLOR[3], ATAN_TAYLOR[2]);
+  double d = fputil::multiply_add(q4, c1, c0);
+  return fputil::multiply_add(q3, d, q);
+}
+
 // > Q = fpminimax(asin(x)/x, [|0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20|],
 //                 [|1, D...|], [0, 0.5]);
-constexpr double ASIN_COEFFS[10] = {0x1.5555555540fa1p-3, 0x1.333333512edc2p-4,
-                                    0x1.6db6cc1541b31p-5, 0x1.f1caff324770ep-6,
-                                    0x1.6e43899f5f4f4p-6, 0x1.1f847cf652577p-6,
-                                    0x1.9b60f47f87146p-7, 0x1.259e2634c494fp-6,
-                                    -0x1.df946fa875ddp-8, 0x1.02311ecf99c28p-5};
+static constexpr double ASIN_COEFFS[10] = {
+    0x1.5555555540fa1p-3, 0x1.333333512edc2p-4, 0x1.6db6cc1541b31p-5,
+    0x1.f1caff324770ep-6, 0x1.6e43899f5f4f4p-6, 0x1.1f847cf652577p-6,
+    0x1.9b60f47f87146p-7, 0x1.259e2634c494fp-6, -0x1.df946fa875ddp-8,
+    0x1.02311ecf99c28p-5};
 
 // Evaluate P(x^2) - 1, where P(x^2) ~ asin(x)/x
-LIBC_INLINE double asin_eval(double xsq) {
+LIBC_INLINE static double asin_eval(double xsq) {
   double x4 = xsq * xsq;
   double r1 = fputil::polyeval(x4, ASIN_COEFFS[0], ASIN_COEFFS[2],
                                ASIN_COEFFS[4], ASIN_COEFFS[6], ASIN_COEFFS[8]);
diff --git a/src/math/generic/log.cpp b/src/math/generic/log.cpp
index 4302c64..0cd4424 100644
--- a/src/math/generic/log.cpp
+++ b/src/math/generic/log.cpp
@@ -30,6 +30,7 @@ using LIBC_NAMESPACE::operator""_u128;
 
 namespace {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // A simple upper bound for the error of e_x * log(2) - log(r).
 constexpr double HI_ERR = 0x1.0p-85;
 
@@ -47,7 +48,7 @@ constexpr double P_ERR = 0x1.0p-50;
 constexpr Float128 LOG_2(Sign::POS, /*exponent=*/-128, /*mantissa=*/
                          0xb17217f7'd1cf79ab'c9e3b398'03f2f6af_u128);
 
-alignas(64) constexpr LogRR LOG_TABLE = {
+alignas(16) constexpr LogRR LOG_TABLE = {
     // -log(r) with 128-bit precision generated by SageMath with:
     // for i in range(128):
     //   r = 2^-8 * ceil( 2^8 * (1 - 2^(-8)) / (1 + i*2^(-7)) );
@@ -731,6 +732,7 @@ double log_accurate(int e_x, int index, double m_x) {
 
   return static_cast<double>(r);
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 } // namespace
 
@@ -794,17 +796,17 @@ LLVM_LIBC_FUNCTION(double, log, (double x)) {
   uint64_t x_m = (x_u & 0x000F'FFFF'FFFF'FFFFULL) | 0x3FF0'0000'0000'0000ULL;
   double m = FPBits_t(x_m).get_val();
 
-  double u, u_sq, err;
+  double u, u_sq;
   fputil::DoubleDouble r1;
 
   // Perform exact range reduction
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   u = fputil::multiply_add(r, m, -1.0); // exact
 #else
   uint64_t c_m = x_m & 0x3FFF'E000'0000'0000ULL;
   double c = FPBits_t(c_m).get_val();
   u = fputil::multiply_add(r, m - c, CD[index]); // exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // Exact sum:
   //   r1.hi + r1.lo = e_x * log(2)_hi - log(r)_hi + u
@@ -819,12 +821,15 @@ LLVM_LIBC_FUNCTION(double, log, (double x)) {
   double p2 = fputil::multiply_add(u, LOG_COEFFS[5], LOG_COEFFS[4]);
   double p = fputil::polyeval(u_sq, lo + r1.lo, p0, p1, p2);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return r1.hi + p;
+#else
   // Technicallly error of r1.lo is bounded by:
   //    hi*ulp(log(2)_lo) + C*ulp(u^2)
   // To simplify the error computation a bit, we replace |hi|*ulp(log(2)_lo)
   // with the upper bound: 2^11 * ulp(log(2)_lo) = 2^-85.
   // Total error is bounded by ~ C * ulp(u^2) + 2^-85.
-  err = fputil::multiply_add(u_sq, P_ERR, HI_ERR);
+  double err = fputil::multiply_add(u_sq, P_ERR, HI_ERR);
 
   // Lower bound from the result
   double left = r1.hi + (p - err);
@@ -836,6 +841,7 @@ LLVM_LIBC_FUNCTION(double, log, (double x)) {
     return left;
 
   return log_accurate(x_e, index, u);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log10.cpp b/src/math/generic/log10.cpp
index 7df57ef..1c4e559 100644
--- a/src/math/generic/log10.cpp
+++ b/src/math/generic/log10.cpp
@@ -33,6 +33,7 @@ namespace {
 constexpr fputil::DoubleDouble LOG10_E = {0x1.95355baaafad3p-57,
                                           0x1.bcb7b1526e50ep-2};
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // A simple upper bound for the error of e_x * log(2) - log(r).
 constexpr double HI_ERR = 0x1.0p-85;
 
@@ -50,7 +51,7 @@ constexpr double P_ERR = 0x1.0p-51;
 constexpr Float128 LOG10_2(Sign::POS, /*exponent=*/-129, /*mantissa=*/
                            0x9a209a84'fbcff798'8f8959ac'0b7c9178_u128);
 
-alignas(64) constexpr LogRR LOG10_TABLE = {
+alignas(16) constexpr LogRR LOG10_TABLE = {
     // -log10(r) with 128-bit precision generated by SageMath with:
     //
     // for i in range(128):
@@ -733,6 +734,7 @@ double log10_accurate(int e_x, int index, double m_x) {
 
   return static_cast<double>(r);
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 } // namespace
 
@@ -796,17 +798,17 @@ LLVM_LIBC_FUNCTION(double, log10, (double x)) {
   uint64_t x_m = (x_u & 0x000F'FFFF'FFFF'FFFFULL) | 0x3FF0'0000'0000'0000ULL;
   double m = FPBits_t(x_m).get_val();
 
-  double u, u_sq, err;
+  double u, u_sq;
   fputil::DoubleDouble r1;
 
   // Perform exact range reduction
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   u = fputil::multiply_add(r, m, -1.0); // exact
 #else
   uint64_t c_m = x_m & 0x3FFF'E000'0000'0000ULL;
   double c = FPBits_t(c_m).get_val();
   u = fputil::multiply_add(r, m - c, CD[index]); // exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // Error of u_sq = ulp(u^2);
   u_sq = u * u;
@@ -827,12 +829,15 @@ LLVM_LIBC_FUNCTION(double, log10, (double x)) {
   //   4*ulp( ulp(r2.hi) )
   fputil::DoubleDouble r2 = fputil::quick_mult(r1, LOG10_E);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return r2.hi + r2.lo;
+#else
   // Technicallly error of r1.lo is bounded by:
   //    |hi|*ulp(log(2)_lo) + C*ulp(u^2)
   // To simplify the error computation a bit, we replace |hi|*ulp(log(2)_lo)
   // with the upper bound: 2^11 * ulp(log(2)_lo) = 2^-85.
   // Total error is bounded by ~ C * ulp(u^2) + 2^-85.
-  err = fputil::multiply_add(u_sq, P_ERR, HI_ERR);
+  double err = fputil::multiply_add(u_sq, P_ERR, HI_ERR);
 
   // Lower bound from the result
   double left = r2.hi + (r2.lo - err);
@@ -897,6 +902,7 @@ LLVM_LIBC_FUNCTION(double, log10, (double x)) {
   }
 
   return log10_accurate(x_e, index, u);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log10f.cpp b/src/math/generic/log10f.cpp
index c635fa4..81e7cdb 100644
--- a/src/math/generic/log10f.cpp
+++ b/src/math/generic/log10f.cpp
@@ -139,13 +139,14 @@ LLVM_LIBC_FUNCTION(float, log10f, (float x)) {
       return 9.0f;
     case 0x5015'02f9U: // x = 10,000,000,000
       return 10.0f;
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     case 0x0efe'ee7aU: // x = 0x1.fddcf4p-98f
       return fputil::round_result_slightly_up(-0x1.d33a46p+4f);
     case 0x3f5f'de1bU: // x = 0x1.bfbc36p-1f
       return fputil::round_result_slightly_up(-0x1.dd2c6ep-5f);
     case 0x3f80'70d8U: // x = 0x1.00e1bp0f
       return fputil::round_result_slightly_up(0x1.8762c4p-10f);
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     case 0x08ae'a356U: // x = 0x1.5d46acp-110f
       return fputil::round_result_slightly_up(-0x1.07d3b4p+5f);
     case 0x120b'93dcU: // x = 0x1.1727b8p-91f
@@ -156,7 +157,8 @@ LLVM_LIBC_FUNCTION(float, log10f, (float x)) {
       return fputil::round_result_slightly_down(0x1.2c9314p+3f);
     case 0x7956'ba5eU: // x = 69683218960000541503257137270226944.0
       return fputil::round_result_slightly_up(0x1.16bebap+5f);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     }
   }
 
@@ -194,12 +196,12 @@ LLVM_LIBC_FUNCTION(float, log10f, (float x)) {
 
   float u = xbits.get_val();
   double v;
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
   v = static_cast<double>(fputil::multiply_add(u, R[index], -1.0f)); // Exact.
 #else
   v = fputil::multiply_add(static_cast<double>(u),
                            static_cast<double>(R[index]), -1.0); // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
   // Degree-5 polynomial approximation of log10 generated by:
   // > P = fpminimax(log10(1 + x)/x, 4, [|D...|], [-2^-8, 2^-7]);
diff --git a/src/math/generic/log10f16.cpp b/src/math/generic/log10f16.cpp
index 990bcab..2626af4 100644
--- a/src/math/generic/log10f16.cpp
+++ b/src/math/generic/log10f16.cpp
@@ -23,7 +23,8 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_LOG10F16_EXCEPTS = 11;
 #else
 static constexpr size_t N_LOG10F16_EXCEPTS = 17;
@@ -36,7 +37,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG10F16_EXCEPTS>
         {0x338fU, 0xb903U, 0U, 1U, 0U},
         // x = 0x1.fep-3, log10f16(x) = -0x1.35p-1 (RZ)
         {0x33f8U, 0xb8d4U, 0U, 1U, 1U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.394p-1, log10f16(x) = -0x1.b4cp-3 (RZ)
         {0x38e5U, 0xb2d3U, 0U, 1U, 1U},
 #endif
@@ -47,7 +48,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG10F16_EXCEPTS>
         // x = 0x1.f3p-1, log10f16(x) = -0x1.6dcp-7 (RZ)
         {0x3bccU, 0xa1b7U, 0U, 1U, 1U},
 // x = 0x1.f38p-1, log10f16(x) = -0x1.5f8p-7 (RZ)
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         {0x3bceU, 0xa17eU, 0U, 1U, 1U},
         // x = 0x1.fd8p-1, log10f16(x) = -0x1.168p-9 (RZ)
         {0x3bf6U, 0x985aU, 0U, 1U, 1U},
@@ -71,6 +72,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG10F16_EXCEPTS>
         // x = 0x1.674p+13, log10f16(x) = 0x1.03cp+2 (RZ)
         {0x719dU, 0x440fU, 1U, 0U, 0U},
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, log10f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -110,8 +112,10 @@ LLVM_LIBC_FUNCTION(float16, log10f16, (float16 x)) {
     return FPBits::inf().get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = LOG10F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // To compute log10(x), we perform the following range reduction:
   //   x = 2^m * 1.mant,
diff --git a/src/math/generic/log1p.cpp b/src/math/generic/log1p.cpp
index b9c58b8..058409f 100644
--- a/src/math/generic/log1p.cpp
+++ b/src/math/generic/log1p.cpp
@@ -29,21 +29,6 @@ using LIBC_NAMESPACE::operator""_u128;
 
 namespace {
 
-// Extra errors from P is from using x^2 to reduce evaluation latency and
-// directional rounding.
-constexpr double P_ERR = 0x1.0p-49;
-
-// log(2) with 128-bit precision generated by SageMath with:
-// def format_hex(value):
-//     l = hex(value)[2:]
-//     n = 8
-//     x = [l[i:i + n] for i in range(0, len(l), n)]
-//     return "0x" + "'".join(x) + "_u128"
-// (s, m, e) = RealField(128)(2).log().sign_mantissa_exponent();
-// print(format_hex(m));
-constexpr Float128 LOG_2(Sign::POS, /*exponent=*/-128, /*mantissa=*/
-                         0xb17217f7'd1cf79ab'c9e3b398'03f2f6af_u128);
-
 // R1[i] = 2^-8 * nearestint( 2^8 / (1 + i * 2^-7) )
 constexpr double R1[129] = {
     0x1p0,     0x1.fcp-1, 0x1.f8p-1, 0x1.f4p-1, 0x1.fp-1,  0x1.ecp-1, 0x1.eap-1,
@@ -105,7 +90,7 @@ constexpr double R1[129] = {
 //     print("{", -c, ",", -b, "},");
 //   };
 // We replace LOG_R1_DD[128] with log(1.0) == 0.0
-constexpr fputil::DoubleDouble LOG_R1_DD[129] = {
+alignas(16) constexpr fputil::DoubleDouble LOG_R1_DD[129] = {
     {0.0, 0.0},
     {-0x1.0c76b999d2be8p-46, 0x1.010157589p-7},
     {-0x1.3dc5b06e2f7d2p-45, 0x1.0205658938p-6},
@@ -248,6 +233,22 @@ constexpr double P_COEFFS[6] = {-0x1p-1,
                                 -0x1.555874ce8ce22p-3,
                                 0x1.24335555ddbe5p-3};
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+// Extra errors from P is from using x^2 to reduce evaluation latency and
+// directional rounding.
+constexpr double P_ERR = 0x1.0p-49;
+
+// log(2) with 128-bit precision generated by SageMath with:
+// def format_hex(value):
+//     l = hex(value)[2:]
+//     n = 8
+//     x = [l[i:i + n] for i in range(0, len(l), n)]
+//     return "0x" + "'".join(x) + "_u128"
+// (s, m, e) = RealField(128)(2).log().sign_mantissa_exponent();
+// print(format_hex(m));
+constexpr Float128 LOG_2(Sign::POS, /*exponent=*/-128, /*mantissa=*/
+                         0xb17217f7'd1cf79ab'c9e3b398'03f2f6af_u128);
+
 // -log(r1) with 128-bit precision generated by SageMath with:
 //
 // for i in range(129):
@@ -874,6 +875,7 @@ constexpr Float128 BIG_COEFFS[4]{
 
   return static_cast<double>(r);
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 } // namespace
 
@@ -969,9 +971,11 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   //           <= 2^11 * 2^(-43-53) = 2^-85
   double lo = fputil::multiply_add(e_x, LOG_2_LO, LOG_R1_DD[idx].lo);
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Error bound of e_x * log(2) - log(r1)
   constexpr double ERR_HI[2] = {0x1.0p-85, 0.0};
   double err_hi = ERR_HI[hi == 0.0];
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // Scale x_dd by 2^(-xh_bits.get_exponent()).
   int64_t s_u = static_cast<int64_t>(x_u & FPBits_t::EXP_MASK) -
@@ -1005,7 +1009,7 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   fputil::DoubleDouble v_lo = fputil::exact_mult(m_dd.lo, r);
 
   // Perform exact range reduction
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   v_hi = fputil::multiply_add(r, m_dd.hi, -1.0); // Exact.
 #else
   // c = 1 + idx * 2^-7.
@@ -1013,7 +1017,7 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
                       uint64_t(0x3FF0'0000'0000'0000ULL))
                  .get_val();
   v_hi = fputil::multiply_add(r, m_dd.hi - c, RCM1[idx]); // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // Range reduction output:
   //   -0x1.69000000000edp-8 < v_hi + v_lo < 0x1.7f00000000081p-8
@@ -1033,6 +1037,9 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
   double p2 = fputil::multiply_add(v_dd.hi, P_COEFFS[5], P_COEFFS[4]);
   double p = fputil::polyeval(v_sq, (v_dd.lo + r1.lo) + lo, p0, p1, p2);
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return r1.hi + p;
+#else
   double err = fputil::multiply_add(v_sq, P_ERR, err_hi);
 
   double left = r1.hi + (p - err);
@@ -1043,6 +1050,7 @@ LLVM_LIBC_FUNCTION(double, log1p, (double x)) {
     return left;
 
   return log1p_accurate(x_e, idx, v_dd);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log1pf.cpp b/src/math/generic/log1pf.cpp
index 869cb07..7f61429 100644
--- a/src/math/generic/log1pf.cpp
+++ b/src/math/generic/log1pf.cpp
@@ -90,6 +90,7 @@ LLVM_LIBC_FUNCTION(float, log1pf, (float x)) {
 
   // Use log1p(x) = log(1 + x) for |x| > 2^-6;
   if (x_a > 0x3c80'0000U) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Hard-to-round cases.
     switch (x_u) {
     case 0x41078febU: // x = 0x1.0f1fd6p3
@@ -108,7 +109,7 @@ LLVM_LIBC_FUNCTION(float, log1pf, (float x)) {
       fputil::set_errno_if_required(ERANGE);
       fputil::raise_except_if_required(FE_DIVBYZERO);
       return FPBits::inf(Sign::NEG).get_val();
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     case 0x4cc1c80bU: // x = 0x1.839016p+26f
       return fputil::round_result_slightly_down(0x1.26fc04p+4f);
     case 0x5ee8984eU: // x = 0x1.d1309cp+62f
@@ -117,13 +118,21 @@ LLVM_LIBC_FUNCTION(float, log1pf, (float x)) {
       return fputil::round_result_slightly_up(0x1.af66cp+5f);
     case 0x79e7ec37U: // x = 0x1.cfd86ep+116f
       return fputil::round_result_slightly_up(0x1.43ff6ep+6f);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     }
+#else
+    if (x == -1.0f) {
+      fputil::set_errno_if_required(ERANGE);
+      fputil::raise_except_if_required(FE_DIVBYZERO);
+      return FPBits::inf(Sign::NEG).get_val();
+    }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
     return internal::log(xd + 1.0);
   }
 
   // |x| <= 2^-6.
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Hard-to round cases.
   switch (x_u) {
   case 0x35400003U: // x = 0x1.800006p-21f
@@ -137,6 +146,7 @@ LLVM_LIBC_FUNCTION(float, log1pf, (float x)) {
   case 0xbb0ec8c4U: // x = -0x1.1d9188p-9
     return fputil::round_result_slightly_up(-0x1.1de14ap-9f);
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // Polymial generated by Sollya with:
   // > fpminimax(log(1 + x)/x, 7, [|D...|], [-2^-6; 2^-6]);
diff --git a/src/math/generic/log2.cpp b/src/math/generic/log2.cpp
index 37ea0c8..27ca2fc 100644
--- a/src/math/generic/log2.cpp
+++ b/src/math/generic/log2.cpp
@@ -33,10 +33,7 @@ namespace {
 constexpr fputil::DoubleDouble LOG2_E = {0x1.777d0ffda0d24p-56,
                                          0x1.71547652b82fep0};
 
-// Extra errors from P is from using x^2 to reduce evaluation latency.
-constexpr double P_ERR = 0x1.0p-49;
-
-const fputil::DoubleDouble LOG_R1[128] = {
+alignas(16) const fputil::DoubleDouble LOG_R1[128] = {
     {0.0, 0.0},
     {0x1.46662d417cedp-62, 0x1.010157588de71p-7},
     {0x1.27c8e8416e71fp-60, 0x1.0205658935847p-6},
@@ -167,7 +164,11 @@ const fputil::DoubleDouble LOG_R1[128] = {
     {0.0, 0.0},
 };
 
-alignas(64) constexpr LogRR LOG2_TABLE = {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+// Extra errors from P is from using x^2 to reduce evaluation latency.
+constexpr double P_ERR = 0x1.0p-49;
+
+alignas(16) constexpr LogRR LOG2_TABLE = {
     // -log2(r) with 128-bit precision generated by SageMath with:
     // def format_hex(value):
     //     l = hex(value)[2:]
@@ -853,6 +854,7 @@ double log2_accurate(int e_x, int index, double m_x) {
 
   return static_cast<double>(r);
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 } // namespace
 
@@ -909,17 +911,17 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
   uint64_t x_m = (x_u & 0x000F'FFFF'FFFF'FFFFULL) | 0x3FF0'0000'0000'0000ULL;
   double m = FPBits_t(x_m).get_val();
 
-  double u, u_sq, err;
+  double u, u_sq;
   fputil::DoubleDouble r1;
 
   // Perform exact range reduction
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   u = fputil::multiply_add(r, m, -1.0); // exact
 #else
   uint64_t c_m = x_m & 0x3FFF'E000'0000'0000ULL;
   double c = FPBits_t(c_m).get_val();
   u = fputil::multiply_add(r, m - c, CD[index]); // exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // Exact sum:
   //   r1.hi + r1.lo = e_x * log(2)_hi - log(r)_hi + u
@@ -927,8 +929,6 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
 
   // Error of u_sq = ulp(u^2);
   u_sq = u * u;
-  // Total error is bounded by ~ C * ulp(u^2).
-  err = u_sq * P_ERR;
   // Degree-7 minimax polynomial
   double p0 = fputil::multiply_add(u, LOG_COEFFS[1], LOG_COEFFS[0]);
   double p1 = fputil::multiply_add(u, LOG_COEFFS[3], LOG_COEFFS[2]);
@@ -948,6 +948,11 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
   // Overall, if we choose sufficiently large constant C, the total error is
   // bounded by (C * ulp(u^2)).
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return r3.hi + r3.lo;
+#else
+  // Total error is bounded by ~ C * ulp(u^2).
+  double err = u_sq * P_ERR;
   // Lower bound from the result
   double left = r3.hi + (r3.lo - err);
   // Upper bound from the result
@@ -958,6 +963,7 @@ LLVM_LIBC_FUNCTION(double, log2, (double x)) {
     return left;
 
   return log2_accurate(x_e, index, u);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/log2f.cpp b/src/math/generic/log2f.cpp
index 111f3f1..b25ec41 100644
--- a/src/math/generic/log2f.cpp
+++ b/src/math/generic/log2f.cpp
@@ -97,11 +97,11 @@ LLVM_LIBC_FUNCTION(float, log2f, (float x)) {
 
   float u = xbits.get_val();
   double v;
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
   v = static_cast<double>(fputil::multiply_add(u, R[index], -1.0f)); // Exact.
 #else
   v = fputil::multiply_add(static_cast<double>(u), RD[index], -1.0); // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
   double extra_factor = static_cast<double>(m) + LOG2_R[index];
 
diff --git a/src/math/generic/log2f16.cpp b/src/math/generic/log2f16.cpp
index ff4e026..34be780 100644
--- a/src/math/generic/log2f16.cpp
+++ b/src/math/generic/log2f16.cpp
@@ -23,7 +23,8 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_LOG2F16_EXCEPTS = 2;
 #else
 static constexpr size_t N_LOG2F16_EXCEPTS = 9;
@@ -32,7 +33,7 @@ static constexpr size_t N_LOG2F16_EXCEPTS = 9;
 static constexpr fputil::ExceptValues<float16, N_LOG2F16_EXCEPTS>
     LOG2F16_EXCEPTS = {{
 // (input, RZ output, RU offset, RD offset, RN offset)
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.224p-1, log2f16(x) = -0x1.a34p-1 (RZ)
         {0x3889U, 0xba8dU, 0U, 1U, 0U},
         // x = 0x1.e34p-1, log2f16(x) = -0x1.558p-4 (RZ)
@@ -40,7 +41,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG2F16_EXCEPTS>
 #endif
         // x = 0x1.e8cp-1, log2f16(x) = -0x1.128p-4 (RZ)
         {0x3ba3U, 0xac4aU, 0U, 1U, 0U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.f98p-1, log2f16(x) = -0x1.2ep-6 (RZ)
         {0x3be6U, 0xa4b8U, 0U, 1U, 0U},
         // x = 0x1.facp-1, log2f16(x) = -0x1.e7p-7 (RZ)
@@ -48,7 +49,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG2F16_EXCEPTS>
 #endif
         // x = 0x1.fb4p-1, log2f16(x) = -0x1.b88p-7 (RZ)
         {0x3bedU, 0xa2e2U, 0U, 1U, 1U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.fecp-1, log2f16(x) = -0x1.cep-9 (RZ)
         {0x3bfbU, 0x9b38U, 0U, 1U, 1U},
         // x = 0x1.ffcp-1, log2f16(x) = -0x1.714p-11 (RZ)
@@ -57,6 +58,7 @@ static constexpr fputil::ExceptValues<float16, N_LOG2F16_EXCEPTS>
         {0x3c89U, 0x31cbU, 1U, 0U, 1U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, log2f16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -96,8 +98,10 @@ LLVM_LIBC_FUNCTION(float16, log2f16, (float16 x)) {
     return FPBits::inf().get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = LOG2F16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // To compute log2(x), we perform the following range reduction:
   //   x = 2^m * 1.mant,
diff --git a/src/math/generic/logf.cpp b/src/math/generic/logf.cpp
index 30c00ed..032d658 100644
--- a/src/math/generic/logf.cpp
+++ b/src/math/generic/logf.cpp
@@ -66,6 +66,7 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
 
   // Small inputs
   if (x_u < 0x4c5d65a5U) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Hard-to-round cases.
     switch (x_u) {
     case 0x3f7f4d6fU: // x = 0x1.fe9adep-1f
@@ -80,6 +81,7 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
       return round_result_slightly_up(-0x1.6d7b18p+5f);
 #endif // LIBC_TARGET_CPU_HAS_FMA
     }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Subnormal inputs.
     if (LIBC_UNLIKELY(x_u < FPBits::min_normal().uintval())) {
       if (x == 0.0f) {
@@ -94,6 +96,7 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
       x_u = xbits.uintval();
     }
   } else {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Hard-to-round cases.
     switch (x_u) {
     case 0x4c5d65a5U: // x = 0x1.bacb4ap+25f
@@ -104,15 +107,16 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
       return round_result_slightly_down(0x1.08b512p+6f);
     case 0x7a17f30aU: // x = 0x1.2fe614p+117f
       return round_result_slightly_up(0x1.451436p+6f);
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     case 0x500ffb03U: // x = 0x1.1ff606p+33f
       return round_result_slightly_up(0x1.6fdd34p+4f);
     case 0x5cd69e88U: // x = 0x1.ad3d1p+58f
       return round_result_slightly_up(0x1.45c146p+5f);
     case 0x5ee8984eU: // x = 0x1.d1309cp+62f;
       return round_result_slightly_up(0x1.5c9442p+5f);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
     }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Exceptional inputs.
     if (LIBC_UNLIKELY(x_u > FPBits::max_normal().uintval())) {
       if (x_u == 0x8000'0000U) {
@@ -152,11 +156,11 @@ LLVM_LIBC_FUNCTION(float, logf, (float x)) {
 
   float u = xbits.get_val();
   double v;
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
   v = static_cast<double>(fputil::multiply_add(u, R[index], -1.0f)); // Exact.
 #else
   v = fputil::multiply_add(static_cast<double>(u), RD[index], -1.0); // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
   // Degree-5 polynomial approximation of log generated by Sollya with:
   // > P = fpminimax(log(1 + x)/x, 4, [|1, D...|], [-2^-8, 2^-7]);
diff --git a/src/math/generic/logf16.cpp b/src/math/generic/logf16.cpp
index 802225a..8e0d7d8 100644
--- a/src/math/generic/logf16.cpp
+++ b/src/math/generic/logf16.cpp
@@ -23,7 +23,8 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
 static constexpr size_t N_LOGF16_EXCEPTS = 5;
 #else
 static constexpr size_t N_LOGF16_EXCEPTS = 11;
@@ -32,7 +33,7 @@ static constexpr size_t N_LOGF16_EXCEPTS = 11;
 static constexpr fputil::ExceptValues<float16, N_LOGF16_EXCEPTS>
     LOGF16_EXCEPTS = {{
 // (input, RZ output, RU offset, RD offset, RN offset)
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.61cp-13, logf16(x) = -0x1.16p+3 (RZ)
         {0x0987U, 0xc858U, 0U, 1U, 0U},
         // x = 0x1.f2p-12, logf16(x) = -0x1.e98p+2 (RZ)
@@ -42,7 +43,7 @@ static constexpr fputil::ExceptValues<float16, N_LOGF16_EXCEPTS>
         {0x1935U, 0xc5f9U, 0U, 1U, 0U},
         // x = 0x1.5ep-8, logf16(x) = -0x1.4ecp+2 (RZ)
         {0x1d78U, 0xc53bU, 0U, 1U, 0U},
-#ifndef LIBC_TARGET_CPU_HAS_FMA
+#ifndef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.fdp-1, logf16(x) = -0x1.81p-8 (RZ)
         {0x3bf4U, 0x9e04U, 0U, 1U, 1U},
         // x = 0x1.fep-1, logf16(x) = -0x1.008p-8 (RZ)
@@ -52,7 +53,7 @@ static constexpr fputil::ExceptValues<float16, N_LOGF16_EXCEPTS>
         {0x3bfcU, 0x9801U, 0U, 1U, 0U},
         // x = 0x1.ff8p-1, logf16(x) = -0x1p-10 (RZ)
         {0x3bfeU, 0x9400U, 0U, 1U, 1U},
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
         // x = 0x1.4c4p+1, logf16(x) = 0x1.e84p-1 (RZ)
         {0x4131U, 0x3ba1U, 1U, 0U, 1U},
 #else
@@ -64,6 +65,7 @@ static constexpr fputil::ExceptValues<float16, N_LOGF16_EXCEPTS>
         {0x6354U, 0x46d7U, 1U, 0U, 1U},
 #endif
     }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, logf16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -103,8 +105,10 @@ LLVM_LIBC_FUNCTION(float16, logf16, (float16 x)) {
     return FPBits::inf().get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = LOGF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // To compute log(x), we perform the following range reduction:
   //   x = 2^m * 1.mant,
diff --git a/src/math/generic/pow.cpp b/src/math/generic/pow.cpp
index 213dbd9..8a12934 100644
--- a/src/math/generic/pow.cpp
+++ b/src/math/generic/pow.cpp
@@ -394,14 +394,14 @@ LLVM_LIBC_FUNCTION(double, pow, (double x, double y)) {
   DoubleDouble dx_c0;
 
   // Perform exact range reduction and exact product dx * c0.
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   dx = fputil::multiply_add(RD[idx_x], m_x.get_val(), -1.0); // Exact
   dx_c0 = fputil::exact_mult(COEFFS[0], dx);
 #else
   double c = FPBits(m_x.uintval() & 0x3fff'e000'0000'0000).get_val();
   dx = fputil::multiply_add(RD[idx_x], m_x.get_val() - c, CD[idx_x]); // Exact
-  dx_c0 = fputil::exact_mult<28>(dx, COEFFS[0]);                      // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+  dx_c0 = fputil::exact_mult<double, 28>(dx, COEFFS[0]);              // Exact
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   double dx2 = dx * dx;
   double c0 = fputil::multiply_add(dx, COEFFS[2], COEFFS[1]);
diff --git a/src/math/generic/powf.cpp b/src/math/generic/powf.cpp
index c84ce0d..2d7deca 100644
--- a/src/math/generic/powf.cpp
+++ b/src/math/generic/powf.cpp
@@ -32,11 +32,144 @@ using fputil::TripleDouble;
 
 namespace {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+alignas(16) constexpr DoubleDouble LOG2_R_DD[128] = {
+    {0.0, 0.0},
+    {-0x1.177c23362928cp-25, 0x1.72c8p-7},
+    {-0x1.179e0caa9c9abp-22, 0x1.744p-6},
+    {-0x1.c6cea541f5b7p-23, 0x1.184cp-5},
+    {-0x1.66c4d4e554434p-22, 0x1.773ap-5},
+    {-0x1.70700a00fdd55p-24, 0x1.d6ecp-5},
+    {0x1.53002a4e86631p-23, 0x1.1bb3p-4},
+    {0x1.fcd15f101c142p-25, 0x1.4c56p-4},
+    {0x1.25b3eed319cedp-22, 0x1.7d6p-4},
+    {-0x1.4195120d8486fp-22, 0x1.960dp-4},
+    {0x1.45b878e27d0d9p-23, 0x1.c7b5p-4},
+    {0x1.770744593a4cbp-22, 0x1.f9c9p-4},
+    {0x1.c673032495d24p-22, 0x1.097ep-3},
+    {-0x1.1eaa65b49696ep-22, 0x1.22dbp-3},
+    {0x1.b2866f2850b22p-22, 0x1.3c6f8p-3},
+    {0x1.8ee37cd2ea9d3p-25, 0x1.494f8p-3},
+    {0x1.7e86f9c2154fbp-24, 0x1.633a8p-3},
+    {0x1.8e3cfc25f0ce6p-26, 0x1.7046p-3},
+    {0x1.57f7a64ccd537p-28, 0x1.8a898p-3},
+    {-0x1.a761c09fbd2aep-22, 0x1.97c2p-3},
+    {0x1.24bea9a2c66f3p-22, 0x1.b26p-3},
+    {-0x1.60002ccfe43f5p-25, 0x1.bfc68p-3},
+    {0x1.69f220e97f22cp-22, 0x1.dac2p-3},
+    {-0x1.6164f64c210ep-22, 0x1.e858p-3},
+    {-0x1.0c1678ae89767p-24, 0x1.01d9cp-2},
+    {-0x1.f26a05c813d57p-22, 0x1.08bdp-2},
+    {0x1.4d8fc561c8d44p-24, 0x1.169cp-2},
+    {-0x1.362ad8f7ca2dp-22, 0x1.1d984p-2},
+    {0x1.2b13cd6c4d042p-22, 0x1.249ccp-2},
+    {-0x1.1c8f11979a5dbp-22, 0x1.32cp-2},
+    {0x1.c2ab3edefe569p-23, 0x1.39de8p-2},
+    {0x1.7c3eca28e69cap-26, 0x1.4106p-2},
+    {-0x1.34c4e99e1c6c6p-24, 0x1.4f6fcp-2},
+    {-0x1.194a871b63619p-22, 0x1.56b24p-2},
+    {0x1.e3dd5c1c885aep-23, 0x1.5dfdcp-2},
+    {-0x1.6ccf3b1129b7cp-23, 0x1.6552cp-2},
+    {-0x1.2f346e2bf924bp-23, 0x1.6cb1p-2},
+    {-0x1.fa61aaa59c1d8p-23, 0x1.7b8ap-2},
+    {0x1.90c11fd32a3abp-22, 0x1.8304cp-2},
+    {0x1.57f7a64ccd537p-27, 0x1.8a898p-2},
+    {0x1.249ba76fee235p-27, 0x1.9218p-2},
+    {-0x1.aad2729b21ae5p-23, 0x1.99b08p-2},
+    {0x1.71810a5e1818p-22, 0x1.a8ff8p-2},
+    {-0x1.6172fe015e13cp-27, 0x1.b0b68p-2},
+    {0x1.5ec6c1bfbf89ap-24, 0x1.b877cp-2},
+    {0x1.678bf6cdedf51p-24, 0x1.c0438p-2},
+    {0x1.c2d45fe43895ep-22, 0x1.c819cp-2},
+    {-0x1.9ee52ed49d71dp-22, 0x1.cffbp-2},
+    {0x1.5786af187a96bp-27, 0x1.d7e6cp-2},
+    {0x1.3ab0dc56138c9p-23, 0x1.dfdd8p-2},
+    {0x1.fe538ab34efb5p-22, 0x1.e7df4p-2},
+    {-0x1.e4fee07aa4b68p-22, 0x1.efec8p-2},
+    {-0x1.172f32fe67287p-22, 0x1.f804cp-2},
+    {-0x1.9a83ff9ab9cc8p-22, 0x1.00144p-1},
+    {-0x1.68cb06cece193p-22, 0x1.042bep-1},
+    {0x1.8cd71ddf82e2p-22, 0x1.08494p-1},
+    {0x1.5e18ab2df3ae6p-22, 0x1.0c6cap-1},
+    {0x1.5dee4d9d8a273p-25, 0x1.1096p-1},
+    {0x1.fcd15f101c142p-26, 0x1.14c56p-1},
+    {-0x1.2474b0f992ba1p-23, 0x1.18faep-1},
+    {0x1.4b5a92a606047p-24, 0x1.1d368p-1},
+    {0x1.16186fcf54bbdp-22, 0x1.21786p-1},
+    {0x1.18efabeb7d722p-27, 0x1.25c0ap-1},
+    {-0x1.e5fc7d238691dp-24, 0x1.2a0f4p-1},
+    {0x1.f5809faf6283cp-22, 0x1.2e644p-1},
+    {0x1.f5809faf6283cp-22, 0x1.2e644p-1},
+    {0x1.c6e1dcd0cb449p-22, 0x1.32bfep-1},
+    {0x1.76e0e8f74b4d5p-22, 0x1.37222p-1},
+    {-0x1.cb82c89692d99p-24, 0x1.3b8b2p-1},
+    {-0x1.63161c5432aebp-22, 0x1.3ffaep-1},
+    {0x1.458104c41b901p-22, 0x1.44716p-1},
+    {0x1.458104c41b901p-22, 0x1.44716p-1},
+    {-0x1.cd9d0cde578d5p-22, 0x1.48efp-1},
+    {0x1.b9884591add87p-26, 0x1.4d738p-1},
+    {0x1.c6042978605ffp-22, 0x1.51ff2p-1},
+    {-0x1.fc4c96b37dcf6p-22, 0x1.56922p-1},
+    {-0x1.2f346e2bf924bp-24, 0x1.5b2c4p-1},
+    {-0x1.2f346e2bf924bp-24, 0x1.5b2c4p-1},
+    {0x1.c4e4fbb68a4d1p-22, 0x1.5fcdcp-1},
+    {-0x1.9d499bd9b3226p-23, 0x1.6476ep-1},
+    {-0x1.f89b355ede26fp-23, 0x1.69278p-1},
+    {-0x1.f89b355ede26fp-23, 0x1.69278p-1},
+    {0x1.53c7e319f6e92p-24, 0x1.6ddfcp-1},
+    {-0x1.b291f070528c7p-22, 0x1.729fep-1},
+    {0x1.2967a451a7b48p-25, 0x1.7767cp-1},
+    {0x1.2967a451a7b48p-25, 0x1.7767cp-1},
+    {0x1.244fcff690fcep-22, 0x1.7c37ap-1},
+    {0x1.46fd97f5dc572p-23, 0x1.810fap-1},
+    {0x1.46fd97f5dc572p-23, 0x1.810fap-1},
+    {-0x1.f3a7352663e5p-22, 0x1.85efep-1},
+    {0x1.b3cda690370b5p-23, 0x1.8ad84p-1},
+    {0x1.b3cda690370b5p-23, 0x1.8ad84p-1},
+    {0x1.3226b211bf1d9p-23, 0x1.8fc92p-1},
+    {0x1.d24b136c101eep-23, 0x1.94c28p-1},
+    {0x1.d24b136c101eep-23, 0x1.94c28p-1},
+    {0x1.7c40c7907e82ap-22, 0x1.99c48p-1},
+    {-0x1.e81781d97ee91p-22, 0x1.9ecf6p-1},
+    {-0x1.e81781d97ee91p-22, 0x1.9ecf6p-1},
+    {-0x1.6a77813f94e01p-22, 0x1.a3e3p-1},
+    {-0x1.1cfdeb43cfdp-22, 0x1.a8ffap-1},
+    {-0x1.1cfdeb43cfdp-22, 0x1.a8ffap-1},
+    {-0x1.f983f74d3138fp-23, 0x1.ae256p-1},
+    {-0x1.e278ae1a1f51fp-23, 0x1.b3546p-1},
+    {-0x1.e278ae1a1f51fp-23, 0x1.b3546p-1},
+    {-0x1.97552b7b5ea45p-23, 0x1.b88ccp-1},
+    {-0x1.97552b7b5ea45p-23, 0x1.b88ccp-1},
+    {-0x1.19b4f3c72c4f8p-24, 0x1.bdceap-1},
+    {0x1.f7402d26f1a12p-23, 0x1.c31a2p-1},
+    {0x1.f7402d26f1a12p-23, 0x1.c31a2p-1},
+    {-0x1.2056d5dd31d96p-23, 0x1.c86f8p-1},
+    {-0x1.2056d5dd31d96p-23, 0x1.c86f8p-1},
+    {-0x1.6e46335aae723p-24, 0x1.cdcecp-1},
+    {-0x1.beb244c59f331p-22, 0x1.d3382p-1},
+    {-0x1.beb244c59f331p-22, 0x1.d3382p-1},
+    {0x1.16c071e93fd97p-27, 0x1.d8abap-1},
+    {0x1.16c071e93fd97p-27, 0x1.d8abap-1},
+    {0x1.d8175819530c2p-22, 0x1.de298p-1},
+    {0x1.d8175819530c2p-22, 0x1.de298p-1},
+    {0x1.51bd552842c1cp-23, 0x1.e3b2p-1},
+    {0x1.51bd552842c1cp-23, 0x1.e3b2p-1},
+    {0x1.914e204f19d94p-22, 0x1.e9452p-1},
+    {0x1.914e204f19d94p-22, 0x1.e9452p-1},
+    {0x1.c55d997da24fdp-22, 0x1.eee32p-1},
+    {0x1.c55d997da24fdp-22, 0x1.eee32p-1},
+    {-0x1.685c2d2298a6ep-22, 0x1.f48c4p-1},
+    {-0x1.685c2d2298a6ep-22, 0x1.f48c4p-1},
+    {0x1.7a4887bd74039p-22, 0x1.fa406p-1},
+    {0.0, 1.0},
+};
+#else
+
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 constexpr uint64_t ERR = 64;
 #else
 constexpr uint64_t ERR = 128;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 // We choose the precision of the high part to be 53 - 24 - 8, so that when
 //   y * (e_x + LOG2_R_DD[i].hi) is exact.
@@ -384,6 +517,7 @@ static constexpr DoubleDouble LOG2_R2_DD[] = {
     {0x1.3d979ddf4746cp-61, 0x1.6cf6ddd2611d4p-7},
     {-0x1.dc930484501f8p-63, 0x1.6fdf461d2e4f8p-7},
 };
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LIBC_INLINE bool is_odd_integer(float x) {
   using FPBits = typename fputil::FPBits<float>;
@@ -407,6 +541,7 @@ LIBC_INLINE bool is_integer(float x) {
   return (x_e + lsb >= UNIT_EXPONENT);
 }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 LIBC_INLINE bool larger_exponent(double a, double b) {
   using DoubleBits = typename fputil::FPBits<double>;
   return DoubleBits(a).get_biased_exponent() >=
@@ -506,6 +641,7 @@ double powf_double_double(int idx_x, double dx, double y6, double lo6_hi,
 
   return cpp::bit_cast<double>(r_bits);
 }
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 } // namespace
 
@@ -627,12 +763,14 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
     case 0x3f80'0000: // x = 1.0f
       return 1.0f;
     // TODO: Put these 2 entrypoint dependency under control flag.
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     case 0x4000'0000: // x = 2.0f
       // pow(2, y) = exp2(y)
       return generic::exp2f(y);
     case 0x4120'0000: // x = 10.0f
       // pow(10, y) = exp10(y)
       return generic::exp10f(y);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     }
 
     const bool x_is_neg = x_u >= FloatBits::SIGN_MASK;
@@ -713,11 +851,11 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   //   log2(m_x) = log2( (1 + dx) / r )
   //             = log2(1 + dx) - log2(r).
   double dx;
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_FLOAT
   dx = static_cast<double>(fputil::multiply_add(m_x, R[idx_x], -1.0f)); // Exact
 #else
   dx = fputil::multiply_add(static_cast<double>(m_x), RD[idx_x], -1.0); // Exact
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
 
   // Degree-5 polynomial approximation:
   //   dx * P(dx) ~ log2(1 + dx)
@@ -782,6 +920,16 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   //   lo6 = 2^6 * lo = 2^6 * (y - (hi + mid)) = y6 * log2(x) - hm.
   double y6 = static_cast<double>(y * 0x1.0p6f); // Exact.
   double hm = fputil::nearest_integer(s * y6);
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  // lo6 = 2^6 * lo.
+  double lo6_hi =
+      fputil::multiply_add(y6, e_x + LOG2_R_DD[idx_x].hi, -hm); // Exact
+  // Error bounds:
+  //   | (y*log2(x) - hm * 2^-6 - lo) / y| < err(dx * p) + err(LOG2_R_DD.lo)
+  //                                       < 2^-51 + 2^-75
+  double lo6 = fputil::multiply_add(
+      y6, fputil::multiply_add(dx, p, LOG2_R_DD[idx_x].lo), lo6_hi);
+#else
   // lo6 = 2^6 * lo.
   double lo6_hi =
       fputil::multiply_add(y6, e_x + LOG2_R_TD[idx_x].hi, -hm); // Exact
@@ -790,6 +938,7 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   //                                       < 2^-51 + 2^-75
   double lo6 = fputil::multiply_add(
       y6, fputil::multiply_add(dx, p, LOG2_R_TD[idx_x].mid), lo6_hi);
+#endif
 
   // |2^(hi + mid) - exp2_hi_mid| <= ulp(exp2_hi_mid) / 2
   // Clamp the exponent part into smaller range that fits double precision.
@@ -830,6 +979,9 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
 
   double r = pp * exp2_hi_mid;
 
+#ifdef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  return static_cast<float>(r);
+#else
   // Ziv accuracy test.
   uint64_t r_u = cpp::bit_cast<uint64_t>(r);
   float r_upper = static_cast<float>(cpp::bit_cast<double>(r_u + ERR));
@@ -861,6 +1013,7 @@ LLVM_LIBC_FUNCTION(float, powf, (float x, float y)) {
   double r_dd = powf_double_double(idx_x, dx, y6, lo6_hi, exp2_hi_mid_dd);
 
   return static_cast<float>(r_dd);
+#endif // LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/range_reduction_double_common.h b/src/math/generic/range_reduction_double_common.h
index bcab82f..f3dcdb9 100644
--- a/src/math/generic/range_reduction_double_common.h
+++ b/src/math/generic/range_reduction_double_common.h
@@ -9,7 +9,6 @@
 #ifndef LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_COMMON_H
 #define LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_COMMON_H
 
-#include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/double_double.h"
 #include "src/__support/FPUtil/dyadic_float.h"
 #include "src/__support/FPUtil/multiply_add.h"
@@ -21,14 +20,14 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
-static constexpr unsigned SPLIT = DEFAULT_DOUBLE_SPLIT;
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
+static constexpr unsigned SPLIT = fputil::DefaultSplit<double>::VALUE;
 #else
 // When there is no-FMA instructions, in order to have exact product of 2 double
 // precision with directional roundings, we need to lower the precision of the
 // constants by at least 1 bit, and use a different splitting constant.
 static constexpr unsigned SPLIT = 28;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 using LIBC_NAMESPACE::fputil::DoubleDouble;
 using Float128 = LIBC_NAMESPACE::fputil::DyadicFloat<128>;
diff --git a/src/math/generic/range_reduction_double_fma.h b/src/math/generic/range_reduction_double_fma.h
index cab031c..160fb24 100644
--- a/src/math/generic/range_reduction_double_fma.h
+++ b/src/math/generic/range_reduction_double_fma.h
@@ -33,14 +33,14 @@ LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
   // 2^62 <= |x_reduced| < 2^(62 + 16) = 2^78
   x_reduced = xbits.get_val();
   // x * c_hi = ph.hi + ph.lo exactly.
-  DoubleDouble ph =
-      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
+  DoubleDouble ph = fputil::exact_mult<double, SPLIT>(
+      x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
   // x * c_mid = pm.hi + pm.lo exactly.
-  DoubleDouble pm =
-      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
+  DoubleDouble pm = fputil::exact_mult<double, SPLIT>(
+      x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
   // x * c_lo = pl.hi + pl.lo exactly.
-  DoubleDouble pl =
-      fputil::exact_mult<SPLIT>(x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
+  DoubleDouble pl = fputil::exact_mult<double, SPLIT>(
+      x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
   // Extract integral parts and fractional parts of (ph.lo + pm.hi).
   double sum_hi = ph.lo + pm.hi;
   double kd = fputil::nearest_integer(sum_hi);
@@ -80,7 +80,7 @@ LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
 //     b = D(sin(k * pi/128) - a);
 //     print("{", b, ",", a, "},");
 //   };
-LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[256] = {
+LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[] = {
     {0, 0},
     {-0x1.b1d63091a013p-64, 0x1.92155f7a3667ep-6},
     {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
diff --git a/src/math/generic/range_reduction_double_nofma.h b/src/math/generic/range_reduction_double_nofma.h
index 5640732..9d13d24 100644
--- a/src/math/generic/range_reduction_double_nofma.h
+++ b/src/math/generic/range_reduction_double_nofma.h
@@ -34,14 +34,14 @@ LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
   x_reduced = xbits.get_val();
   // x * c_hi = ph.hi + ph.lo exactly.
   DoubleDouble x_split = fputil::split(x_reduced);
-  DoubleDouble ph = fputil::exact_mult<SPLIT>(x_split, x_reduced,
-                                              ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
+  DoubleDouble ph = fputil::exact_mult<double, SPLIT>(
+      x_split, x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][0]);
   // x * c_mid = pm.hi + pm.lo exactly.
-  DoubleDouble pm = fputil::exact_mult<SPLIT>(x_split, x_reduced,
-                                              ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
+  DoubleDouble pm = fputil::exact_mult<double, SPLIT>(
+      x_split, x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][1]);
   // x * c_lo = pl.hi + pl.lo exactly.
-  DoubleDouble pl = fputil::exact_mult<SPLIT>(x_split, x_reduced,
-                                              ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
+  DoubleDouble pl = fputil::exact_mult<double, SPLIT>(
+      x_split, x_reduced, ONE_TWENTY_EIGHT_OVER_PI[idx][2]);
   // Extract integral parts and fractional parts of (ph.lo + pm.hi).
   double sum_hi = ph.lo + pm.hi;
   double kd = fputil::nearest_integer(sum_hi);
@@ -81,7 +81,7 @@ LIBC_INLINE unsigned LargeRangeReduction::fast(double x, DoubleDouble &u) {
 //     b = round(sin(k * pi/128) - a, D, RN);
 //     print("{", b, ",", a, "},");
 //   };
-LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[256] = {
+LIBC_INLINE constexpr DoubleDouble SIN_K_PI_OVER_128[] = {
     {0, 0},
     {0x1.f938a73db97fbp-58, 0x1.92155f7a3667cp-6},
     {-0x1.912bd0d569a9p-61, 0x1.91f65f10dd814p-5},
diff --git a/src/math/generic/sin.cpp b/src/math/generic/sin.cpp
index b32486d..4a58dcf 100644
--- a/src/math/generic/sin.cpp
+++ b/src/math/generic/sin.cpp
@@ -21,11 +21,11 @@
 #include "src/math/generic/range_reduction_double_common.h"
 #include "src/math/generic/sincos_eval.h"
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 #include "range_reduction_double_fma.h"
 #else
 #include "range_reduction_double_nofma.h"
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -52,7 +52,7 @@ LLVM_LIBC_FUNCTION(double, sin, (double x)) {
         if (LIBC_UNLIKELY(x == 0.0))
           return x + x; // Make sure it works with FTZ/DAZ.
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
         return fputil::multiply_add(x, -0x1.0p-54, x);
 #else
         if (LIBC_UNLIKELY(x_e < 4)) {
@@ -63,7 +63,7 @@ LLVM_LIBC_FUNCTION(double, sin, (double x)) {
             return FPBits(xbits.uintval() - 1).get_val();
         }
         return fputil::multiply_add(x, -0x1.0p-54, x);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
       }
       // No range reduction needed.
       k = 0;
diff --git a/src/math/generic/sincos.cpp b/src/math/generic/sincos.cpp
index 166ce46..0ac2f7f 100644
--- a/src/math/generic/sincos.cpp
+++ b/src/math/generic/sincos.cpp
@@ -22,11 +22,11 @@
 #include "src/math/generic/range_reduction_double_common.h"
 #include "src/math/generic/sincos_eval.h"
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 #include "range_reduction_double_fma.h"
 #else
 #include "range_reduction_double_nofma.h"
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -57,7 +57,7 @@ LLVM_LIBC_FUNCTION(void, sincos, (double x, double *sin_x, double *cos_x)) {
         }
 
         // For |x| < 2^-27, max(|sin(x) - x|, |cos(x) - 1|) < ulp(x)/2.
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
         *sin_x = fputil::multiply_add(x, -0x1.0p-54, x);
         *cos_x = fputil::multiply_add(x, -x, 1.0);
 #else
@@ -71,7 +71,7 @@ LLVM_LIBC_FUNCTION(void, sincos, (double x, double *sin_x, double *cos_x)) {
             *sin_x = FPBits(xbits.uintval() - 1).get_val();
         }
         *sin_x = fputil::multiply_add(x, -0x1.0p-54, x);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
         return;
       }
       // No range reduction needed.
diff --git a/src/math/generic/sincos_eval.h b/src/math/generic/sincos_eval.h
index 6cd1da4..41a4c75 100644
--- a/src/math/generic/sincos_eval.h
+++ b/src/math/generic/sincos_eval.h
@@ -65,7 +65,7 @@ LIBC_INLINE double sincos_eval(const DoubleDouble &u, DoubleDouble &sin_u,
   double u_hi_neg_half = (-0.5) * u.hi;
   DoubleDouble v;
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
   v.hi = fputil::multiply_add(u.hi, u_hi_neg_half, 1.0);
   v.lo = 1.0 - v.hi; // Exact
   v.lo = fputil::multiply_add(u.hi, u_hi_neg_half, v.lo);
@@ -73,7 +73,7 @@ LIBC_INLINE double sincos_eval(const DoubleDouble &u, DoubleDouble &sin_u,
   DoubleDouble u_hi_sq_neg_half = fputil::exact_mult(u.hi, u_hi_neg_half);
   v = fputil::exact_add(1.0, u_hi_sq_neg_half.hi);
   v.lo += u_hi_sq_neg_half.lo;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
   // r1 ~ -1/720 + u_hi^2 / 40320
   double r1 = fputil::multiply_add(u_hi_sq, 0x1.a01a01a01a01ap-16,
diff --git a/src/math/generic/sincosf.cpp b/src/math/generic/sincosf.cpp
index ccaa29c..623ef63 100644
--- a/src/math/generic/sincosf.cpp
+++ b/src/math/generic/sincosf.cpp
@@ -19,6 +19,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Exceptional values
 static constexpr int N_EXCEPTS = 6;
 
@@ -48,6 +49,7 @@ static constexpr uint32_t EXCEPT_OUTPUTS_COS[N_EXCEPTS][4] = {
     {0x3f78142e, 1, 0, 1}, // x = 0x1.2b9622p67, cos(x) = 0x1.f0285cp-1 (RZ)
     {0x3f08a21c, 1, 0, 0}, // x = 0x1.ddebdep120, cos(x) = 0x1.114438p-1 (RZ)
 };
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinp, float *cosp)) {
   using FPBits = typename fputil::FPBits<float>;
@@ -130,14 +132,14 @@ LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinp, float *cosp)) {
     // |x| < 2^-125. For targets without FMA instructions, we simply use
     // double for intermediate results as it is more efficient than using an
     // emulated version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
     *sinp = fputil::multiply_add(x, -0x1.0p-25f, x);
     *cosp = fputil::multiply_add(FPBits(x_abs).get_val(), -0x1.0p-25f, 1.0f);
 #else
     *sinp = static_cast<float>(fputil::multiply_add(xd, -0x1.0p-25, xd));
     *cosp = static_cast<float>(fputil::multiply_add(
         static_cast<double>(FPBits(x_abs).get_val()), -0x1.0p-25, 1.0));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     return;
   }
 
@@ -152,6 +154,7 @@ LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinp, float *cosp)) {
     return;
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   // Check exceptional values.
   for (int i = 0; i < N_EXCEPTS; ++i) {
     if (LIBC_UNLIKELY(x_abs == EXCEPT_INPUTS[i])) {
@@ -178,6 +181,7 @@ LLVM_LIBC_FUNCTION(void, sincosf, (float x, float *sinp, float *cosp)) {
       return;
     }
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // Combine the results with the sine and cosine of sum formulas:
   //   sin(x) = sin((k + y)*pi/32)
diff --git a/src/math/generic/sincosf16_utils.h b/src/math/generic/sincosf16_utils.h
index 8351175..05cab09 100644
--- a/src/math/generic/sincosf16_utils.h
+++ b/src/math/generic/sincosf16_utils.h
@@ -9,7 +9,6 @@
 #ifndef LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
 #define LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
 
-#include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/PolyEval.h"
 #include "src/__support/FPUtil/nearest_integer.h"
 #include "src/__support/common.h"
@@ -41,15 +40,35 @@ constexpr float SIN_K_PI_OVER_32[64] = {
 
 LIBC_INLINE int32_t range_reduction_sincospif16(float x, float &y) {
   float kf = fputil::nearest_integer(x * 32);
-  y = fputil::multiply_add<float>(x, 32.0, -kf);
+  y = fputil::multiply_add(x, 32.0f, -kf);
 
   return static_cast<int32_t>(kf);
 }
 
-LIBC_INLINE void sincospif16_eval(float xf, float &sin_k, float &cos_k,
-                                  float &sin_y, float &cosm1_y) {
-  float y;
-  int32_t k = range_reduction_sincospif16(xf, y);
+// Recall, range reduction:
+//   k = round(x * 32/pi)
+//
+// The precision choice of 'double' in the following function is to minimize
+// rounding errors in this initial scaling step,
+// preserving enough bits so errors accumulated while computing the subtraction:
+// y = x * 32/pi - round(x * 32/pi)
+// are beyond the least-significant bit of single-precision used during
+// further intermediate computation.
+LIBC_INLINE int32_t range_reduction_sincosf16(float x, float &y) {
+  // Generated by Sollya with:
+  // > D(32/pi);
+  constexpr double THIRTYTWO_OVER_PI = 0x1.45f306dc9c883p3;
+
+  double prod = x * THIRTYTWO_OVER_PI;
+  double kd = fputil::nearest_integer(prod);
+  y = static_cast<float>(prod - kd);
+
+  return static_cast<int32_t>(kd);
+}
+
+static LIBC_INLINE void sincosf16_poly_eval(int32_t k, float y, float &sin_k,
+                                            float &cos_k, float &sin_y,
+                                            float &cosm1_y) {
 
   sin_k = SIN_K_PI_OVER_32[k & 63];
   cos_k = SIN_K_PI_OVER_32[(k + 16) & 63];
@@ -72,6 +91,22 @@ LIBC_INLINE void sincospif16_eval(float xf, float &sin_k, float &cos_k,
                                    0x1.a6f7a2p-29f);
 }
 
+LIBC_INLINE void sincosf16_eval(float xf, float &sin_k, float &cos_k,
+                                float &sin_y, float &cosm1_y) {
+  float y;
+  int32_t k = range_reduction_sincosf16(xf, y);
+
+  sincosf16_poly_eval(k, y, sin_k, cos_k, sin_y, cosm1_y);
+}
+
+LIBC_INLINE void sincospif16_eval(float xf, float &sin_k, float &cos_k,
+                                  float &sin_y, float &cosm1_y) {
+  float y;
+  int32_t k = range_reduction_sincospif16(xf, y);
+
+  sincosf16_poly_eval(k, y, sin_k, cos_k, sin_y, cosm1_y);
+}
+
 } // namespace LIBC_NAMESPACE_DECL
 
 #endif // LLVM_LIBC_SRC_MATH_GENERIC_SINCOSF16_UTILS_H
diff --git a/src/math/generic/sincosf_utils.h b/src/math/generic/sincosf_utils.h
index 726a5ab..6eaf820 100644
--- a/src/math/generic/sincosf_utils.h
+++ b/src/math/generic/sincosf_utils.h
@@ -14,7 +14,7 @@
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_DOUBLE)
 #include "range_reduction_fma.h"
 // using namespace LIBC_NAMESPACE::fma;
 using LIBC_NAMESPACE::fma::FAST_PASS_BOUND;
@@ -27,7 +27,7 @@ using LIBC_NAMESPACE::fma::small_range_reduction;
 using LIBC_NAMESPACE::generic::FAST_PASS_BOUND;
 using LIBC_NAMESPACE::generic::large_range_reduction;
 using LIBC_NAMESPACE::generic::small_range_reduction;
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -108,7 +108,7 @@ LIBC_INLINE void sincosf_eval(double xd, uint32_t x_abs, double &sin_k,
 //   => pi * x = (k + y) * pi / 32
 static LIBC_INLINE int64_t range_reduction_sincospi(double x, double &y) {
   double kd = fputil::nearest_integer(x * 32);
-  y = fputil::multiply_add<double>(x, 32.0, -kd);
+  y = fputil::multiply_add(x, 32.0, -kd);
 
   return static_cast<int64_t>(kd);
 }
diff --git a/src/math/generic/sinf.cpp b/src/math/generic/sinf.cpp
index cea267d..d27ce84 100644
--- a/src/math/generic/sinf.cpp
+++ b/src/math/generic/sinf.cpp
@@ -19,7 +19,7 @@
 #include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_DOUBLE)
 #include "range_reduction_fma.h"
 #else
 #include "range_reduction.h"
@@ -101,11 +101,11 @@ LLVM_LIBC_FUNCTION(float, sinf, (float x)) {
       // |x| < 2^-125. For targets without FMA instructions, we simply use
       // double for intermediate results as it is more efficient than using an
       // emulated version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
       return fputil::multiply_add(x, -0x1.0p-25f, x);
 #else
       return static_cast<float>(fputil::multiply_add(xd, -0x1.0p-25, xd));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     }
 
     // |x| < pi/16.
@@ -124,6 +124,7 @@ LLVM_LIBC_FUNCTION(float, sinf, (float x)) {
     return static_cast<float>(xd * result);
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (LIBC_UNLIKELY(x_abs == 0x4619'9998U)) { // x = 0x1.33333p13
     float r = -0x1.63f4bap-2f;
     int rounding = fputil::quick_get_round();
@@ -132,6 +133,7 @@ LLVM_LIBC_FUNCTION(float, sinf, (float x)) {
       r = -0x1.63f4bcp-2f;
     return xbits.is_neg() ? -r : r;
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   if (LIBC_UNLIKELY(x_abs >= 0x7f80'0000U)) {
     if (x_abs == 0x7f80'0000U) {
diff --git a/src/math/generic/sinf16.cpp b/src/math/generic/sinf16.cpp
new file mode 100644
index 0000000..85e55a6
--- /dev/null
+++ b/src/math/generic/sinf16.cpp
@@ -0,0 +1,110 @@
+//===-- Half-precision sin(x) function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+constexpr size_t N_EXCEPTS = 4;
+
+constexpr fputil::ExceptValues<float16, N_EXCEPTS> SINF16_EXCEPTS{{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    {0x2b45, 0x2b43, 1, 0, 1},
+    {0x585c, 0x3ba3, 1, 0, 1},
+    {0x5cb0, 0xbbff, 0, 1, 0},
+    {0x51f5, 0xb80f, 0, 1, 0},
+}};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+LLVM_LIBC_FUNCTION(float16, sinf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+  // Range reduction:
+  // For |x| > pi/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * pi/32
+  //   k is an integer, |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32/pi)
+  //   y = x * 32/pi - k
+  //
+  // Once k and y are computed, we then deduce the answer by the sine of sum
+  // formula:
+  //   sin(x) = sin((k + y) * pi/32)
+  //   	      = sin(k * pi/32) * cos(y * pi/32) +
+  //   	        sin(y * pi/32) * cos(k * pi/32)
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  // Handle exceptional values
+  bool x_sign = x_u >> 15;
+
+  if (auto r = SINF16_EXCEPTS.lookup_odd(x_abs, x_sign);
+      LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+  int rounding = fputil::quick_get_round();
+
+  // Exhaustive tests show that for |x| <= 0x1.f4p-11, 1ULP rounding errors
+  // occur. To fix this, the following apply:
+  if (LIBC_UNLIKELY(x_abs <= 0x13d0)) {
+    // sin(+/-0) = +/-0
+    if (LIBC_UNLIKELY(x_abs == 0U))
+      return x;
+
+    // When x > 0, and rounding upward, sin(x) == x.
+    // When x < 0, and rounding downward, sin(x) == x.
+    if ((rounding == FE_UPWARD && xbits.is_pos()) ||
+        (rounding == FE_DOWNWARD && xbits.is_neg()))
+      return x;
+
+    // When x < 0, and rounding upward, sin(x) == (x - 1ULP)
+    if (rounding == FE_UPWARD && xbits.is_neg()) {
+      x_u--;
+      return FPBits(x_u).get_val();
+    }
+  }
+
+  if (xbits.is_inf_or_nan()) {
+    if (xbits.is_inf()) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+    }
+
+    return x + FPBits::quiet_nan().get_val();
+  }
+
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincosf16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+
+  if (LIBC_UNLIKELY(sin_y == 0 && sin_k == 0))
+    return FPBits::zero(xbits.sign()).get_val();
+
+  // Since, cosm1_y = cos_y - 1, therefore:
+  //   sin(x) = cos_k * sin_y + sin_k + (cosm1_y * sin_k)
+  return fputil::cast<float16>(fputil::multiply_add(
+      sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/sinhf.cpp b/src/math/generic/sinhf.cpp
index 371dd6e..d6158fd 100644
--- a/src/math/generic/sinhf.cpp
+++ b/src/math/generic/sinhf.cpp
@@ -24,11 +24,13 @@ LLVM_LIBC_FUNCTION(float, sinhf, (float x)) {
   if (LIBC_UNLIKELY(x_abs >= 0x42b4'0000U || x_abs <= 0x3da0'0000U)) {
     // |x| <= 0.078125
     if (x_abs <= 0x3da0'0000U) {
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
       // |x| = 0.0005589424981735646724700927734375
       if (LIBC_UNLIKELY(x_abs == 0x3a12'85ffU)) {
         if (fputil::fenv_is_round_to_nearest())
           return x;
       }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
       // |x| <= 2^-26
       if (LIBC_UNLIKELY(x_abs <= 0x3280'0000U)) {
diff --git a/src/math/generic/sinhf16.cpp b/src/math/generic/sinhf16.cpp
index e2dd009..680e1cc 100644
--- a/src/math/generic/sinhf16.cpp
+++ b/src/math/generic/sinhf16.cpp
@@ -20,6 +20,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 16> SINHF16_EXCEPTS_POS = {{
     // x = 0x1.714p-5, sinhf16(x) = 0x1.714p-5 (RZ)
     {0x29c5U, 0x29c5U, 1U, 0U, 1U},
@@ -81,6 +82,7 @@ static constexpr fputil::ExceptValues<float16, 12> SINHF16_EXCEPTS_NEG = {{
     // x = -0x1.5fp+3, sinhf16(x) = -0x1.c54p+14 (RZ)
     {0xc97cU, 0xf715U, 0U, 1U, 1U},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, sinhf16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -130,6 +132,7 @@ LLVM_LIBC_FUNCTION(float16, sinhf16, (float16 x)) {
     return FPBits(static_cast<uint16_t>(x_u)).get_val();
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (x_bits.is_pos()) {
     if (auto r = SINHF16_EXCEPTS_POS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
       return r.value();
@@ -137,6 +140,7 @@ LLVM_LIBC_FUNCTION(float16, sinhf16, (float16 x)) {
     if (auto r = SINHF16_EXCEPTS_NEG.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
       return r.value();
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   return eval_sinh_or_cosh</*IsSinh=*/true>(x);
 }
diff --git a/src/math/generic/sqrtf128.cpp b/src/math/generic/sqrtf128.cpp
index f87066b..3aa7db8 100644
--- a/src/math/generic/sqrtf128.cpp
+++ b/src/math/generic/sqrtf128.cpp
@@ -7,14 +7,432 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/math/sqrtf128.h"
-#include "src/__support/FPUtil/sqrt.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/common.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/uint128.h"
+
+// Compute sqrtf128 with correct rounding for all rounding modes using integer
+// arithmetic by Alexei Sibidanov (sibid@uvic.ca):
+//   https://github.com/sibidanov/llvm-project/tree/as_sqrt_v2
+//   https://github.com/sibidanov/llvm-project/tree/as_sqrt_v3
+// TODO: Update the reference once Alexei's implementation is in the CORE-MATH
+// project. https://github.com/llvm/llvm-project/issues/126794
+
+// Let the input be expressed as x = 2^e * m_x,
+// - Step 1: Range reduction
+//   Let x_reduced = 2^(e % 2) * m_x,
+//   Then sqrt(x) = 2^(e / 2) * sqrt(x_reduced), with
+//     1 <= x_reduced < 4.
+// - Step 2: Polynomial approximation
+//   Approximate 1/sqrt(x_reduced) using polynomial approximation with the
+//   result errors bounded by:
+//     |r0 - 1/sqrt(x_reduced)| < 2^-32.
+//   The computations are done in uint64_t.
+// - Step 3: First Newton iteration
+//   Let the scaled error defined by:
+//     h0 = r0^2 * x_reduced - 1.
+//   Then we compute the first Newton iteration:
+//     r1 = r0 - r0 * h0 / 2.
+//   The result is then bounded by:
+//     |r1 - 1 / sqrt(x_reduced)| < 2^-62.
+// - Step 4: Second Newton iteration
+//   We calculate the scaled error from Step 3:
+//     h1 = r1^2 * x_reduced - 1.
+//   Then the second Newton iteration is computed by:
+//     r2 = x_reduced * (r1 - r1 * h0 / 2)
+//        ~ x_reduced * (1/sqrt(x_reduced)) = sqrt(x_reduced)
+// - Step 5: Perform rounding test and correction if needed.
+//     Rounding correction is done by computing the exact rounding errors:
+//       x_reduced - r2^2.
 
 namespace LIBC_NAMESPACE_DECL {
 
+using FPBits = fputil::FPBits<float128>;
+
+namespace {
+
+template <typename T, typename U = T> static inline constexpr T prod_hi(T, U);
+
+// Get high part of integer multiplications.
+// Use template to prevent implicit conversion.
+template <>
+inline constexpr uint64_t prod_hi<uint64_t>(uint64_t x, uint64_t y) {
+  return static_cast<uint64_t>(
+      (static_cast<UInt128>(x) * static_cast<UInt128>(y)) >> 64);
+}
+
+// Get high part of unsigned 128x64 bit multiplication.
+template <>
+inline constexpr UInt128 prod_hi<UInt128, uint64_t>(UInt128 x, uint64_t y) {
+  uint64_t x_lo = static_cast<uint64_t>(x);
+  uint64_t x_hi = static_cast<uint64_t>(x >> 64);
+  UInt128 xyl = static_cast<UInt128>(x_lo) * static_cast<UInt128>(y);
+  UInt128 xyh = static_cast<UInt128>(x_hi) * static_cast<UInt128>(y);
+  return xyh + (xyl >> 64);
+}
+
+// Get high part of signed 64x64 bit multiplication.
+template <> inline constexpr int64_t prod_hi<int64_t>(int64_t x, int64_t y) {
+  return static_cast<int64_t>(
+      (static_cast<Int128>(x) * static_cast<Int128>(y)) >> 64);
+}
+
+// Get high 128-bit part of unsigned 128x128 bit multiplication.
+template <> inline constexpr UInt128 prod_hi<UInt128>(UInt128 x, UInt128 y) {
+  uint64_t x_lo = static_cast<uint64_t>(x);
+  uint64_t x_hi = static_cast<uint64_t>(x >> 64);
+  uint64_t y_lo = static_cast<uint64_t>(y);
+  uint64_t y_hi = static_cast<uint64_t>(y >> 64);
+
+  UInt128 xh_yh = static_cast<UInt128>(x_hi) * static_cast<UInt128>(y_hi);
+  UInt128 xh_yl = static_cast<UInt128>(x_hi) * static_cast<UInt128>(y_lo);
+  UInt128 xl_yh = static_cast<UInt128>(x_lo) * static_cast<UInt128>(y_hi);
+
+  xh_yh += xh_yl >> 64;
+
+  return xh_yh + (xl_yh >> 64);
+}
+
+// Get high 128-bit part of mixed sign 128x128 bit multiplication.
+template <>
+inline constexpr Int128 prod_hi<Int128, UInt128>(Int128 x, UInt128 y) {
+  UInt128 mask = static_cast<UInt128>(x >> 127);
+  UInt128 negative_part = y & mask;
+  UInt128 prod = prod_hi(static_cast<UInt128>(x), y);
+  return static_cast<Int128>(prod - negative_part);
+}
+
+// Newton-Raphson first order step to improve accuracy of the result.
+// For the initial approximation r0 ~ 1/sqrt(x), let
+//   h = r0^2 * x - 1
+// be its scaled error.  Then the first-order Newton-Raphson iteration is:
+//   r1 = r0 - r0 * h / 2
+// which has error bounded by:
+//   |r1 - 1/sqrt(x)| < h^2 / 2.
+LIBC_INLINE uint64_t rsqrt_newton_raphson(uint64_t m, uint64_t r) {
+  uint64_t r2 = prod_hi(r, r);
+  // h = r0^2*x - 1.
+  int64_t h = static_cast<int64_t>(prod_hi(m, r2) + r2);
+  // hr = r * h / 2
+  int64_t hr = prod_hi(h, static_cast<int64_t>(r >> 1));
+  return r - hr;
+}
+
+#ifdef LIBC_MATH_HAS_SMALL_TABLES
+// Degree-12 minimax polynomials for 1/sqrt(x) on [1, 2].
+constexpr uint32_t RSQRT_COEFFS[12] = {
+    0xb5947a4a, 0x2d651e32, 0x9ad50532, 0x2d28d093, 0x0d8be653, 0x04239014,
+    0x01492449, 0x0066ff7d, 0x001e74a1, 0x000984cc, 0x00049abc, 0x00018340,
+};
+
+LIBC_INLINE uint64_t rsqrt_approx(uint64_t m) {
+  int64_t x = static_cast<uint64_t>(m) ^ (uint64_t(1) << 63);
+  int64_t x_26 = x >> 2;
+  int64_t z = x >> 31;
+
+  if (LIBC_UNLIKELY(z <= -4294967296))
+    return ~(m >> 1);
+
+  uint64_t x2 = static_cast<uint64_t>(z) * static_cast<uint64_t>(z);
+  uint64_t x2_26 = x2 >> 5;
+  x2 >>= 32;
+  // Calculate the odd part of the polynomial using Horner's method.
+  uint64_t c0 = RSQRT_COEFFS[8] + ((x2 * RSQRT_COEFFS[10]) >> 32);
+  uint64_t c1 = RSQRT_COEFFS[6] + ((x2 * c0) >> 32);
+  uint64_t c2 = RSQRT_COEFFS[4] + ((x2 * c1) >> 32);
+  uint64_t c3 = RSQRT_COEFFS[2] + ((x2 * c2) >> 32);
+  uint64_t c4 = RSQRT_COEFFS[0] + ((x2 * c3) >> 32);
+  uint64_t odd =
+      static_cast<uint64_t>((x >> 34) * static_cast<int64_t>(c4 >> 3)) + x_26;
+  // Calculate the even part of the polynomial using Horner's method.
+  uint64_t d0 = RSQRT_COEFFS[9] + ((x2 * RSQRT_COEFFS[11]) >> 32);
+  uint64_t d1 = RSQRT_COEFFS[7] + ((x2 * d0) >> 32);
+  uint64_t d2 = RSQRT_COEFFS[5] + ((x2 * d1) >> 32);
+  uint64_t d3 = RSQRT_COEFFS[3] + ((x2 * d2) >> 32);
+  uint64_t d4 = RSQRT_COEFFS[1] + ((x2 * d3) >> 32);
+  uint64_t even = 0xd105eb806655d608ul + ((x2 * d4) >> 6) + x2_26;
+
+  uint64_t r = even - odd; // error < 1.5e-10
+  // Newton-Raphson first order step to improve accuracy of the result to almost
+  // 64 bits.
+  return rsqrt_newton_raphson(m, r);
+}
+
+#else
+// Cubic minimax polynomials for 1/sqrt(x) on [1 + k/64, 1 + (k + 1)/64]
+// for k = 0..63.
+constexpr uint32_t RSQRT_COEFFS[64][4] = {
+    {0xffffffff, 0xfffff780, 0xbff55815, 0x9bb5b6e7},
+    {0xfc0bd889, 0xfa1d6e7d, 0xb8a95a89, 0x938bf8f0},
+    {0xf82ec882, 0xf473bea9, 0xb1bf4705, 0x8bed0079},
+    {0xf467f280, 0xeefff2a1, 0xab309d4a, 0x84cdb431},
+    {0xf0b6848c, 0xe9bf46f4, 0xa4f76232, 0x7e24037b},
+    {0xed19b75e, 0xe4af2628, 0x9f0e1340, 0x77e6ca62},
+    {0xe990cdad, 0xdfcd2521, 0x996f9b96, 0x720db8df},
+    {0xe61b138e, 0xdb16ffde, 0x94174a00, 0x6c913cff},
+    {0xe2b7dddf, 0xd68a967b, 0x8f00c812, 0x676a6f92},
+    {0xdf6689b7, 0xd225ea80, 0x8a281226, 0x62930308},
+    {0xdc267bea, 0xcde71c63, 0x8589702c, 0x5e05343e},
+    {0xd8f7208e, 0xc9cc6948, 0x81216f2e, 0x59bbbcf8},
+    {0xd5d7ea91, 0xc5d428ee, 0x7cecdb76, 0x55b1c7d6},
+    {0xd2c8534e, 0xc1fccbc9, 0x78e8bb45, 0x51e2e592},
+    {0xcfc7da32, 0xbe44d94a, 0x75124a0a, 0x4e4b0369},
+    {0xccd6045f, 0xbaaaee41, 0x7166f40f, 0x4ae66284},
+    {0xc9f25c5c, 0xb72dbb69, 0x6de45288, 0x47b19045},
+    {0xc71c71c7, 0xb3cc040f, 0x6a882804, 0x44a95f5f},
+    {0xc453d90f, 0xb0849cd4, 0x67505d2a, 0x41cae1a0},
+    {0xc1982b2e, 0xad566a85, 0x643afdc8, 0x3f13625c},
+    {0xbee9056f, 0xaa406113, 0x6146361f, 0x3c806169},
+    {0xbc46092e, 0xa7418293, 0x5e70506d, 0x3a0f8e8e},
+    {0xb9aedba5, 0xa458de58, 0x5bb7b2b1, 0x37bec572},
+    {0xb72325b7, 0xa1859022, 0x591adc9a, 0x358c09e2},
+    {0xb4a293c2, 0x9ec6bf52, 0x569865a7, 0x33758476},
+    {0xb22cd56d, 0x9c1b9e36, 0x542efb6a, 0x31797f8a},
+    {0xafc19d86, 0x9983695c, 0x51dd5ffb, 0x2f96647a},
+    {0xad60a1d1, 0x96fd66f7, 0x4fa2687c, 0x2dcab91f},
+    {0xab099ae9, 0x9488e64b, 0x4d7cfbc9, 0x2c151d8a},
+    {0xa8bc441a, 0x92253f20, 0x4b6c1139, 0x2a7449ef},
+    {0xa6785b42, 0x8fd1d14a, 0x496eaf82, 0x28e70cc3},
+    {0xa43da0ae, 0x8d8e042a, 0x4783eba7, 0x276c4900},
+    {0xa20bd701, 0x8b594648, 0x45aae80a, 0x2602f493},
+    {0x9fe2c315, 0x89330ce4, 0x43e2d382, 0x24aa16ec},
+    {0x9dc22be4, 0x871ad399, 0x422ae88c, 0x2360c7af},
+    {0x9ba9da6c, 0x85101c05, 0x40826c88, 0x22262d7b},
+    {0x99999999, 0x83126d70, 0x3ee8af07, 0x20f97cd2},
+    {0x97913630, 0x81215480, 0x3d5d0922, 0x1fd9f714},
+    {0x95907eb8, 0x7f3c62ef, 0x3bdedce0, 0x1ec6e994},
+    {0x93974369, 0x7d632f45, 0x3a6d94a9, 0x1dbfacbb},
+    {0x91a55615, 0x7b955498, 0x3908a2be, 0x1cc3a33b},
+    {0x8fba8a1c, 0x79d2724e, 0x37af80bf, 0x1bd23960},
+    {0x8dd6b456, 0x781a2be4, 0x3661af39, 0x1aeae458},
+    {0x8bf9ab07, 0x766c28ba, 0x351eb539, 0x1a0d21a2},
+    {0x8a2345cc, 0x74c813dd, 0x33e61feb, 0x19387676},
+    {0x88535d90, 0x732d9bdc, 0x32b7823a, 0x186c6f3e},
+    {0x8689cc7e, 0x719c7297, 0x3192747d, 0x17a89f21},
+    {0x84c66df1, 0x70144d19, 0x30769424, 0x16ec9f89},
+    {0x83091e6a, 0x6e94e36c, 0x2f63836f, 0x16380fbf},
+    {0x8151bb87, 0x6d1df079, 0x2e58e925, 0x158a9484},
+    {0x7fa023f1, 0x6baf31de, 0x2d567053, 0x14e3d7ba},
+    {0x7df43758, 0x6a4867d3, 0x2c5bc811, 0x1443880e},
+    {0x7c4dd664, 0x68e95508, 0x2b68a346, 0x13a958ab},
+    {0x7aace2b0, 0x6791be86, 0x2a7cb871, 0x131500ee},
+    {0x79113ebc, 0x66416b95, 0x2997c17a, 0x12863c29},
+    {0x777acde8, 0x64f825a1, 0x28b97b82, 0x11fcc95c},
+    {0x75e9746a, 0x63b5b822, 0x27e1a6b4, 0x11786b03},
+    {0x745d1746, 0x6279f081, 0x2710061d, 0x10f8e6da},
+    {0x72d59c46, 0x61449e06, 0x26445f86, 0x107e05ac},
+    {0x7152e9f4, 0x601591be, 0x257e7b4d, 0x10079327},
+    {0x6fd4e793, 0x5eec9e6b, 0x24be2445, 0x0f955da9},
+    {0x6e5b7d16, 0x5dc9986e, 0x24032795, 0x0f273620},
+    {0x6ce6931d, 0x5cac55b7, 0x234d5496, 0x0ebcefdb},
+    {0x6b7612ec, 0x5b94adb2, 0x229c7cbc, 0x0e56606e},
+};
+
+// Approximate rsqrt with cubic polynomials.
+// The range [1,2] is splitted into 64 equal sub-ranges and the reciprocal
+// square root is approximated by a cubic polynomial by the minimax method in
+// each subrange. The approximation accuracy fits into 32-33 bits and thus it is
+// natural to round coefficients into 32 bit. The constant coefficient can be
+// rounded to 33 bits since the most significant bit is always 1 and implicitly
+// assumed in the table.
+LIBC_INLINE uint64_t rsqrt_approx(uint64_t m) {
+  // ULP(m) = 2^-64.
+  // Use the top 6 bits as index for looking up polynomial coeffs.
+  uint64_t indx = m >> 58;
+
+  uint64_t c0 = static_cast<uint64_t>(RSQRT_COEFFS[indx][0]);
+  c0 <<= 31;        // to 64 bit with the space for the implicit bit
+  c0 |= 1ull << 63; // add implicit bit
+
+  uint64_t c1 = static_cast<uint64_t>(RSQRT_COEFFS[indx][1]);
+  c1 <<= 25; // to 64 bit format
+
+  uint64_t c2 = static_cast<uint64_t>(RSQRT_COEFFS[indx][2]);
+  uint64_t c3 = static_cast<uint64_t>(RSQRT_COEFFS[indx][3]);
+
+  uint64_t d = (m << 6) >> 32; // local coordinate in the subrange [0, 2^32]
+  uint64_t d2 = (d * d) >> 32; // square of the local coordinate
+  uint64_t re = c0 + (d2 * c2 >> 13); // even part of the polynomial (positive)
+  uint64_t ro = d * ((c1 + ((d2 * c3) >> 19)) >> 26) >>
+                6;      // odd part of the polynomial (negative)
+  uint64_t r = re - ro; // maximal error < 1.55e-10 and it is less than 2^-32
+  // Newton-Raphson first order step to improve accuracy of the result to almost
+  // 64 bits.
+  r = rsqrt_newton_raphson(m, r);
+  // Adjust in the unlucky case x~1;
+  if (LIBC_UNLIKELY(!r))
+    --r;
+  return r;
+}
+#endif // LIBC_MATH_HAS_SMALL_TABLES
+
+} // anonymous namespace
+
 LLVM_LIBC_FUNCTION(float128, sqrtf128, (float128 x)) {
-  return fputil::sqrt<float128>(x);
+  using FPBits = fputil::FPBits<float128>;
+  // Get rounding mode.
+  uint32_t rm = fputil::get_round();
+
+  FPBits xbits(x);
+  UInt128 x_u = xbits.uintval();
+  // Bring leading bit of the mantissa to the highest bit.
+  //   ulp(x_frac) = 2^-128.
+  UInt128 x_frac = xbits.get_mantissa() << (FPBits::EXP_LEN + 1);
+
+  int sign_exp = static_cast<int>(x_u >> FPBits::FRACTION_LEN);
+
+  if (LIBC_UNLIKELY(sign_exp == 0 || sign_exp >= 0x7fff)) {
+    // Special cases: NAN, inf, negative numbers
+    if (sign_exp >= 0x7fff) {
+      // x = -0 or x = inf
+      if (xbits.is_zero() || xbits == xbits.inf())
+        return x;
+      // x is nan
+      if (xbits.is_nan()) {
+        // pass through quiet nan
+        if (xbits.is_quiet_nan())
+          return x;
+        // transform signaling nan to quiet and return
+        return xbits.quiet_nan().get_val();
+      }
+      // x < 0 or x = -inf
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+      return xbits.quiet_nan().get_val();
+    }
+    // Now x is subnormal or x = +0.
+
+    // x is +0.
+    if (x_frac == 0)
+      return x;
+
+    // Normalize subnormal inputs.
+    sign_exp = -cpp::countl_zero(x_frac);
+    int normal_shifts = 1 - sign_exp;
+    x_frac <<= normal_shifts;
+  }
+
+  // For sign_exp = biased exponent of x = real_exponent + 16383,
+  // let f be the real exponent of the output:
+  //   f = floor(real_exponent / 2)
+  // Then:
+  //   floor((sign_exp + 1) / 2) = f + 8192
+  // Hence, the biased exponent of the final result is:
+  //   f + 16383 = floor((sign_exp + 1) / 2) + 8191.
+  // Since the output mantissa will include the hidden bit, we can define the
+  // output exponent part:
+  //   e2 = floor((sign_exp + 1) / 2) + 8190
+  unsigned i = static_cast<unsigned>(1 - (sign_exp & 1));
+  uint32_t q2 = (sign_exp + 1) >> 1;
+  // Exponent of the final result
+  uint32_t e2 = q2 + 8190;
+
+  constexpr uint64_t RSQRT_2[2] = {~0ull,
+                                   0xb504f333f9de6484 /* 2^64/sqrt(2) */};
+
+  // Approximate 1/sqrt(1 + x_frac)
+  // Error: |r_1 - 1/sqrt(x)| < 2^-62.
+  uint64_t r1 = rsqrt_approx(static_cast<uint64_t>(x_frac >> 64));
+  // Adjust for the even/odd exponent.
+  uint64_t r2 = prod_hi(r1, RSQRT_2[i]);
+  unsigned shift = 2 - i;
+
+  // Normalized input:
+  //   1 <= x_reduced < 4
+  UInt128 x_reduced = (x_frac >> shift) | (UInt128(1) << (126 + i));
+  // With r2 ~ 1/sqrt(x) up to 2^-63, we perform another round of Newton-Raphson
+  // iteration:
+  //   r3 = r2 - r2 * h / 2,
+  // for h = r2^2 * x - 1.
+  // Then:
+  //   sqrt(x) = x * (1 / sqrt(x))
+  //           ~ x * r3
+  //           = x * (r2 - r2 * h / 2)
+  //           = (x * r2) - (x * r2) * h / 2
+  UInt128 sx = prod_hi(x_reduced, r2);
+  UInt128 h = prod_hi(sx, r2) << 2;
+  UInt128 ds = static_cast<UInt128>(prod_hi(static_cast<Int128>(h), sx));
+  UInt128 v = (sx << 1) - ds;
+
+  uint32_t nrst = rm == FE_TONEAREST;
+  // The result lies within (-2,5) of true square root so we now
+  // test that we can correctly round the result taking into account
+  // the rounding mode.
+  // Check the lowest 14 bits (by clearing and sign-extending the top
+  // 32 - 14 = 18 bits).
+  int dd = (static_cast<int>(v) << 18) >> 18;
+
+  if (LIBC_UNLIKELY(dd < 4 && dd >= -8)) { // can round correctly?
+    // m is almost the final result it can be only 1 ulp off so we
+    // just need to test both possibilities. We square it and
+    // compare with the initial argument.
+    UInt128 m = v >> 15;
+    UInt128 m2 = m * m;
+    // The difference of the squared result and the argument
+    Int128 t0 = static_cast<Int128>(m2 - (x_reduced << 98));
+    if (t0 == 0) {
+      // the square root is exact
+      v = m << 15;
+    } else {
+      // Add +-1 ulp to m depend on the sign of the difference. Here
+      // we do not need to square again since (m+1)^2 = m^2 + 2*m +
+      // 1 so just need to add shifted m and 1.
+      Int128 t1 = t0;
+      Int128 sgn = t0 >> 127; // sign of the difference
+      Int128 m_xor_sgn = static_cast<Int128>(m << 1) ^ sgn;
+      t1 -= m_xor_sgn;
+      t1 += Int128(1) + sgn;
+
+      Int128 sgn1 = t1 >> 127;
+      if (LIBC_UNLIKELY(sgn == sgn1)) {
+        t0 = t1;
+        v -= sgn << 15;
+        t1 -= m_xor_sgn;
+        t1 += Int128(1) + sgn;
+      }
+
+      if (t1 == 0) {
+        // 1 ulp offset brings again an exact root
+        v = (m - static_cast<UInt128>((sgn << 1) + 1)) << 15;
+      } else {
+        t1 += t0;
+        Int128 side = t1 >> 127; // select what is closer m or m+-1
+        v &= ~UInt128(0) << 15;  // wipe the fractional bits
+        v -= ((sgn & side) | (~sgn & 1)) << (15 + static_cast<int>(side));
+        v |= 1; // add sticky bit since we cannot have an exact mid-point
+                // situation
+      }
+    }
+  }
+
+  unsigned frac = static_cast<unsigned>(v) & 0x7fff; // fractional part
+  unsigned rnd;                                      // round bit
+  if (LIBC_LIKELY(nrst != 0)) {
+    rnd = frac >> 14; // round to nearest tie to even
+  } else if (rm == FE_UPWARD) {
+    rnd = !!frac; // round up
+  } else {
+    rnd = 0; // round down or round to zero
+  }
+
+  v >>= 15; // position mantissa
+  v += rnd; // round
+
+  // Set inexact flag only if square root is inexact
+  // TODO: We will have to raise FE_INEXACT most of the time, but this
+  // operation is very costly, especially in x86-64, since technically, it
+  // needs to synchronize both SSE and x87 flags.  Need to investigate
+  // further to see how we can make this performant.
+  // https://github.com/llvm/llvm-project/issues/126753
+
+  // if(frac) fputil::raise_except_if_required(FE_INEXACT);
+
+  v += static_cast<UInt128>(e2) << FPBits::FRACTION_LEN; // place exponent
+  return cpp::bit_cast<float128>(v);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tan.cpp b/src/math/generic/tan.cpp
index 19d31a8..a899a21 100644
--- a/src/math/generic/tan.cpp
+++ b/src/math/generic/tan.cpp
@@ -22,11 +22,11 @@
 #include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA
 #include "src/math/generic/range_reduction_double_common.h"
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 #include "range_reduction_double_fma.h"
 #else
 #include "range_reduction_double_nofma.h"
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
 
 namespace LIBC_NAMESPACE_DECL {
 
@@ -140,7 +140,7 @@ LLVM_LIBC_FUNCTION(double, tan, (double x)) {
         if (LIBC_UNLIKELY(x == 0.0))
           return x + x; // Make sure it works with FTZ/DAZ.
 
-#ifdef LIBC_TARGET_CPU_HAS_FMA
+#ifdef LIBC_TARGET_CPU_HAS_FMA_DOUBLE
         return fputil::multiply_add(x, 0x1.0p-54, x);
 #else
         if (LIBC_UNLIKELY(x_e < 4)) {
@@ -150,7 +150,7 @@ LLVM_LIBC_FUNCTION(double, tan, (double x)) {
             return FPBits(xbits.uintval() + 1).get_val();
         }
         return fputil::multiply_add(x, 0x1.0p-54, x);
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_DOUBLE
       }
       // No range reduction needed.
       k = 0;
diff --git a/src/math/generic/tanf.cpp b/src/math/generic/tanf.cpp
index 6fd5f9a..a15aa97 100644
--- a/src/math/generic/tanf.cpp
+++ b/src/math/generic/tanf.cpp
@@ -21,6 +21,7 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 // Exceptional cases for tanf.
 constexpr size_t N_EXCEPTS = 6;
 
@@ -39,11 +40,11 @@ constexpr fputil::ExceptValues<float, N_EXCEPTS> TANF_EXCEPTS{{
     // x = 0x1.a6ce12p86, tan(x) = -0x1.c5612ep-1 (RZ)
     {0x6ad36709, 0xbf62b097, 0, 1, 0},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
   using FPBits = typename fputil::FPBits<float>;
   FPBits xbits(x);
-  bool x_sign = xbits.uintval() >> 31;
   uint32_t x_abs = xbits.uintval() & 0x7fff'ffffU;
 
   // |x| < pi/32
@@ -74,11 +75,11 @@ LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
       // |x| < 2^-125. For targets without FMA instructions, we simply use
       // double for intermediate results as it is more efficient than using an
       // emulated version of FMA.
-#if defined(LIBC_TARGET_CPU_HAS_FMA)
+#if defined(LIBC_TARGET_CPU_HAS_FMA_FLOAT)
       return fputil::multiply_add(x, 0x1.0p-25f, x);
 #else
       return static_cast<float>(fputil::multiply_add(xd, 0x1.0p-25, xd));
-#endif // LIBC_TARGET_CPU_HAS_FMA
+#endif // LIBC_TARGET_CPU_HAS_FMA_FLOAT
     }
 
     // |x| < pi/32
@@ -92,6 +93,8 @@ LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
     return static_cast<float>(xd * result);
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  bool x_sign = xbits.uintval() >> 31;
   // Check for exceptional values
   if (LIBC_UNLIKELY(x_abs == 0x3f8a1f62U)) {
     // |x| = 0x1.143ec4p0
@@ -104,6 +107,7 @@ LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
 
     return tmp;
   }
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // |x| > 0x1.ada6a8p+27f
   if (LIBC_UNLIKELY(x_abs > 0x4d56'd354U)) {
@@ -115,10 +119,12 @@ LLVM_LIBC_FUNCTION(float, tanf, (float x)) {
       }
       return x + FPBits::quiet_nan().get_val();
     }
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     // Other large exceptional values
     if (auto r = TANF_EXCEPTS.lookup_odd(x_abs, x_sign);
         LIBC_UNLIKELY(r.has_value()))
       return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   }
 
   // For |x| >= pi/32, we use the definition of tan(x) function:
diff --git a/src/math/generic/tanf16.cpp b/src/math/generic/tanf16.cpp
new file mode 100644
index 0000000..97d201b
--- /dev/null
+++ b/src/math/generic/tanf16.cpp
@@ -0,0 +1,119 @@
+//===-- Half-precision tan(x) function ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanf16.h"
+#include "hdr/errno_macros.h"
+#include "hdr/fenv_macros.h"
+#include "sincosf16_utils.h"
+#include "src/__support/FPUtil/FEnvImpl.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/cast.h"
+#include "src/__support/FPUtil/except_value_utils.h"
+#include "src/__support/FPUtil/multiply_add.h"
+#include "src/__support/macros/optimization.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+constexpr size_t N_EXCEPTS = 9;
+
+constexpr fputil::ExceptValues<float16, N_EXCEPTS> TANF16_EXCEPTS{{
+    // (input, RZ output, RU offset, RD offset, RN offset)
+    {0x2894, 0x2894, 1, 0, 1},
+    {0x3091, 0x3099, 1, 0, 0},
+    {0x3098, 0x30a0, 1, 0, 0},
+    {0x55ed, 0x3911, 1, 0, 0},
+    {0x607b, 0xc638, 0, 1, 1},
+    {0x674e, 0x3b7d, 1, 0, 0},
+    {0x6807, 0x4014, 1, 0, 1},
+    {0x6f4d, 0xbe19, 0, 1, 1},
+    {0x7330, 0xcb62, 0, 1, 0},
+}};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+LLVM_LIBC_FUNCTION(float16, tanf16, (float16 x)) {
+  using FPBits = fputil::FPBits<float16>;
+  FPBits xbits(x);
+
+  uint16_t x_u = xbits.uintval();
+  uint16_t x_abs = x_u & 0x7fff;
+  float xf = x;
+
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+  bool x_sign = x_u >> 15;
+  // Handle exceptional values
+  if (auto r = TANF16_EXCEPTS.lookup_odd(x_abs, x_sign);
+      LIBC_UNLIKELY(r.has_value()))
+    return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
+
+  // |x| <= 0x1.d1p-5
+  if (LIBC_UNLIKELY(x_abs <= 0x2b44)) {
+    // |x| <= 0x1.398p-11
+    if (LIBC_UNLIKELY(x_abs <= 0x10e6)) {
+      // tan(+/-0) = +/-0
+      if (LIBC_UNLIKELY(x_abs == 0))
+        return x;
+
+      int rounding = fputil::quick_get_round();
+
+      // Exhaustive tests show that, when:
+      // x > 0, and rounding upward or
+      // x < 0, and rounding downward then,
+      // tan(x) = x * 2^-11 + x
+      if ((xbits.is_pos() && rounding == FE_UPWARD) ||
+          (xbits.is_neg() && rounding == FE_DOWNWARD))
+        return fputil::cast<float16>(fputil::multiply_add(xf, 0x1.0p-11f, xf));
+      return x;
+    }
+
+    float xsq = xf * xf;
+
+    // Degree-6 minimax odd polynomial of tan(x) generated by Sollya with:
+    // > P = fpminimax(tan(x)/x, [|0, 2, 4, 6|], [|1, SG...|], [0, pi/32]);
+    float result = fputil::polyeval(xsq, 0x1p0f, 0x1.555556p-2f, 0x1.110ee4p-3f,
+                                    0x1.be80f6p-5f);
+
+    return fputil::cast<float16>(xf * result);
+  }
+
+  // tan(+/-inf) = NaN, and tan(NaN) = NaN
+  if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
+    // x = +/-inf
+    if (x_abs == 0x7c00) {
+      fputil::set_errno_if_required(EDOM);
+      fputil::raise_except_if_required(FE_INVALID);
+    }
+
+    return x + FPBits::quiet_nan().get_val();
+  }
+
+  // Range reduction:
+  // For |x| > pi/32, we perform range reduction as follows:
+  // Find k and y such that:
+  //   x = (k + y) * pi/32;
+  //   k is an integer, |y| < 0.5
+  //
+  // This is done by performing:
+  //   k = round(x * 32/pi)
+  //   y = x * 32/pi - k
+  //
+  // Once k and y are computed, we then deduce the answer by the formula:
+  // tan(x) = sin(x) / cos(x)
+  // 	    = (sin_y * cos_k + cos_y * sin_k) / (cos_y * cos_k - sin_y * sin_k)
+  float sin_k, cos_k, sin_y, cosm1_y;
+  sincosf16_eval(xf, sin_k, cos_k, sin_y, cosm1_y);
+
+  // Note that, cosm1_y = cos_y - 1:
+  using fputil::multiply_add;
+  return fputil::cast<float16>(
+      multiply_add(sin_y, cos_k, multiply_add(cosm1_y, sin_k, sin_k)) /
+      multiply_add(sin_y, -sin_k, multiply_add(cosm1_y, cos_k, cos_k)));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/math/generic/tanhf16.cpp b/src/math/generic/tanhf16.cpp
index 0266b5c..4c43cfd 100644
--- a/src/math/generic/tanhf16.cpp
+++ b/src/math/generic/tanhf16.cpp
@@ -24,12 +24,14 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 static constexpr fputil::ExceptValues<float16, 2> TANHF16_EXCEPTS = {{
     // x = 0x1.f54p+0, tanhf16(x) = 0x1.ecp-1 (RZ)
     {0x3fd5U, 0x3bb0U, 1U, 0U, 0U},
     // x = -0x1.f54p+0, tanhf16(x) = -0x1.ecp-1 (RZ)
     {0xbfd5U, 0xbbb0U, 0U, 1U, 0U},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, tanhf16, (float16 x)) {
   using FPBits = fputil::FPBits<float16>;
@@ -98,8 +100,10 @@ LLVM_LIBC_FUNCTION(float16, tanhf16, (float16 x)) {
     return fputil::cast<float16>(-0x1.ffcp-1);
   }
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   if (auto r = TANHF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
     return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
   // For atanh(-1 + 2^(-11)) < x < atanh(1 - 2^(-11)), to compute tanh(x), we
   // perform the following range reduction: find hi, mid, lo, such that:
diff --git a/src/math/generic/tanpif16.cpp b/src/math/generic/tanpif16.cpp
index ab3c9cb..71cf25c 100644
--- a/src/math/generic/tanpif16.cpp
+++ b/src/math/generic/tanpif16.cpp
@@ -19,9 +19,10 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 constexpr size_t N_EXCEPTS = 21;
 
-constexpr fputil::ExceptValues<float16, N_EXCEPTS> TANF16_EXCEPTS{{
+constexpr fputil::ExceptValues<float16, N_EXCEPTS> TANPIF16_EXCEPTS{{
     // (input, RZ output, RU offset, RD offset, RN offset)
     {0x07f2, 0x0e3d, 1, 0, 0}, {0x086a, 0x0eee, 1, 0, 1},
     {0x08db, 0x0fa0, 1, 0, 0}, {0x094c, 0x1029, 1, 0, 0},
@@ -35,6 +36,7 @@ constexpr fputil::ExceptValues<float16, N_EXCEPTS> TANF16_EXCEPTS{{
     {0x4135, 0xc1ee, 0, 1, 0}, {0x42cb, 0x41ee, 1, 0, 0},
     {0x4335, 0xc1ee, 0, 1, 0},
 }};
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
 
 LLVM_LIBC_FUNCTION(float16, tanpif16, (float16 x)) {
   using FPBits = typename fputil::FPBits<float16>;
@@ -48,10 +50,13 @@ LLVM_LIBC_FUNCTION(float16, tanpif16, (float16 x)) {
     if (LIBC_UNLIKELY(x_abs == 0U))
       return x;
 
+#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
     bool x_sign = x_u >> 15;
-    if (auto r = TANF16_EXCEPTS.lookup_odd(x_abs, x_sign);
+
+    if (auto r = TANPIF16_EXCEPTS.lookup_odd(x_abs, x_sign);
         LIBC_UNLIKELY(r.has_value()))
       return r.value();
+#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS
   }
 
   // Numbers greater or equal to 2^10 are integers, or infinity, or NaN
@@ -79,7 +84,7 @@ LLVM_LIBC_FUNCTION(float16, tanpif16, (float16 x)) {
   //   k = round(x * 32)
   //   y = x * 32 - k
   //
-  // Once k and y are computed, we then deduce the answer by tthe formula:
+  // Once k and y are computed, we then deduce the answer by the formula:
   // tan(x) = sin(x) / cos(x)
   //        = (sin_y * cos_k + cos_y * sin_k) / (cos_y * cos_k - sin_y * sin_k)
   float xf = x;
diff --git a/src/math/sinf16.h b/src/math/sinf16.h
new file mode 100644
index 0000000..23f1aa9
--- /dev/null
+++ b/src/math/sinf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for sinf16 ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_SINF16_H
+#define LLVM_LIBC_SRC_MATH_SINF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 sinf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_SINF16_H
diff --git a/src/math/tanf16.h b/src/math/tanf16.h
new file mode 100644
index 0000000..bf1b61e
--- /dev/null
+++ b/src/math/tanf16.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for tanf16 ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_MATH_TANF16_H
+#define LLVM_LIBC_SRC_MATH_TANF16_H
+
+#include "src/__support/macros/config.h"
+#include "src/__support/macros/properties/types.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+float16 tanf16(float16 x);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_MATH_TANF16_H
diff --git a/src/poll/linux/poll.cpp b/src/poll/linux/poll.cpp
new file mode 100644
index 0000000..d7c1958
--- /dev/null
+++ b/src/poll/linux/poll.cpp
@@ -0,0 +1,51 @@
+//===-- Implementation of poll --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/poll/poll.h"
+
+#include "hdr/types/nfds_t.h"
+#include "hdr/types/struct_pollfd.h"
+#include "hdr/types/struct_timespec.h"
+#include "src/__support/OSUtil/syscall.h" // syscall_impl
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+
+#include <sys/syscall.h> // SYS_poll, SYS_ppoll
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, poll, (pollfd * fds, nfds_t nfds, int timeout)) {
+  int ret = 0;
+
+#ifdef SYS_poll
+  ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_poll, fds, nfds, timeout);
+#elif defined(SYS_ppoll)
+  timespec ts, *tsp;
+  if (timeout >= 0) {
+    ts.tv_sec = timeout / 1000;
+    ts.tv_nsec = (timeout % 1000) * 1000000;
+    tsp = &ts;
+  } else {
+    tsp = nullptr;
+  }
+  ret =
+      LIBC_NAMESPACE::syscall_impl<int>(SYS_ppoll, fds, nfds, tsp, nullptr, 0);
+#else
+// TODO: https://github.com/llvm/llvm-project/issues/125940
+#error "SYS_ppoll_time64?"
+#endif
+
+  if (ret < 0) {
+    libc_errno = -ret;
+    return -1;
+  }
+  return ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/poll/poll.h b/src/poll/poll.h
new file mode 100644
index 0000000..ac3cc1d
--- /dev/null
+++ b/src/poll/poll.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for poll ----------------------------*-C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_POLL_POLL_H
+#define LLVM_LIBC_SRC_POLL_POLL_H
+
+#include "hdr/types/nfds_t.h"
+#include "hdr/types/struct_pollfd.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int poll(pollfd *fds, nfds_t nfds, int timeout);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif //  LLVM_LIBC_SRC_POLL_POLL_H
diff --git a/src/pthread/pthread_condattr_init.cpp b/src/pthread/pthread_condattr_init.cpp
index 12005b8..b360804 100644
--- a/src/pthread/pthread_condattr_init.cpp
+++ b/src/pthread/pthread_condattr_init.cpp
@@ -11,8 +11,8 @@
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
-#include <pthread.h> // pthread_condattr_t, PTHREAD_PROCESS_PRIVATE
-#include <time.h>    // CLOCK_REALTIME
+#include "hdr/time_macros.h" // CLOCK_REALTIME
+#include <pthread.h>         // pthread_condattr_t, PTHREAD_PROCESS_PRIVATE
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/pthread/pthread_condattr_setclock.cpp b/src/pthread/pthread_condattr_setclock.cpp
index 37fbd6b..5e825d5 100644
--- a/src/pthread/pthread_condattr_setclock.cpp
+++ b/src/pthread/pthread_condattr_setclock.cpp
@@ -12,9 +12,9 @@
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
-#include <pthread.h>   // pthread_condattr_t
-#include <sys/types.h> // clockid_t
-#include <time.h>      // CLOCK_MONOTONIC, CLOCK_REALTIME
+#include "hdr/time_macros.h" // CLOCK_MONOTONIC, CLOCK_REALTIME
+#include <pthread.h>         // pthread_condattr_t
+#include <sys/types.h>       // clockid_t
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/sched/linux/sched_getcpucount.cpp b/src/sched/linux/sched_getcpucount.cpp
index dbda4b2..7ae166e 100644
--- a/src/sched/linux/sched_getcpucount.cpp
+++ b/src/sched/linux/sched_getcpucount.cpp
@@ -8,6 +8,7 @@
 
 #include "src/sched/sched_getcpucount.h"
 
+#include "src/__support/CPP/bit.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 
@@ -20,7 +21,7 @@ LLVM_LIBC_FUNCTION(int, __sched_getcpucount,
                    (size_t cpuset_size, const cpu_set_t *mask)) {
   int result = 0;
   for (size_t i = 0; i < cpuset_size / sizeof(long); ++i) {
-    result += __builtin_popcountl(mask->__mask[i]);
+    result += cpp::popcount(mask->__mask[i]);
   }
   return result;
 }
diff --git a/src/sched/linux/sched_getcpuisset.cpp b/src/sched/linux/sched_getcpuisset.cpp
new file mode 100644
index 0000000..da9f971
--- /dev/null
+++ b/src/sched/linux/sched_getcpuisset.cpp
@@ -0,0 +1,36 @@
+//===-- Implementation of sched_getcpuisset -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sched/sched_getcpuisset.h"
+
+#include "src/__support/common.h"            // LLVM_LIBC_FUNCTION
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
+#include "src/__support/macros/null_check.h" // LIBC_CRASH_ON_NULLPTR
+
+#include "hdr/sched_macros.h" // NCPUBITS
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, __sched_getcpuisset,
+                   (int cpu, const size_t cpuset_size, cpu_set_t *set)) {
+  LIBC_CRASH_ON_NULLPTR(set);
+
+  if (static_cast<size_t>(cpu) / 8 < cpuset_size) {
+    const size_t element_index = static_cast<size_t>(cpu) / NCPUBITS;
+    const size_t bit_position = static_cast<size_t>(cpu) % NCPUBITS;
+
+    const unsigned long mask = 1UL << bit_position;
+    return (set->__mask[element_index] & mask) != 0;
+  }
+
+  return 0;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_setcpuset.cpp b/src/sched/linux/sched_setcpuset.cpp
new file mode 100644
index 0000000..88209d8
--- /dev/null
+++ b/src/sched/linux/sched_setcpuset.cpp
@@ -0,0 +1,33 @@
+//===-- Implementation of sched_setcpuset ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sched/sched_setcpuset.h"
+
+#include "src/__support/common.h"            // LLVM_LIBC_FUNCTION
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
+#include "src/__support/macros/null_check.h" // LIBC_CRASH_ON_NULLPTR
+
+#include "hdr/sched_macros.h" // NCPUBITS
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void, __sched_setcpuset,
+                   (int cpu, const size_t cpuset_size, cpu_set_t *set)) {
+  LIBC_CRASH_ON_NULLPTR(set);
+  if (static_cast<size_t>(cpu) / 8 < cpuset_size) {
+    const size_t element_index = static_cast<size_t>(cpu) / NCPUBITS;
+    const size_t bit_position = static_cast<size_t>(cpu) % NCPUBITS;
+
+    const unsigned long mask = 1UL << bit_position;
+    set->__mask[element_index] |= mask;
+  }
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/linux/sched_setcpuzero.cpp b/src/sched/linux/sched_setcpuzero.cpp
new file mode 100644
index 0000000..28c789a
--- /dev/null
+++ b/src/sched/linux/sched_setcpuzero.cpp
@@ -0,0 +1,26 @@
+//===-- Implementation of sched_setcpuzero --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/sched/sched_setcpuzero.h"
+
+#include "src/__support/common.h"            // LLVM_LIBC_FUNCTION
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
+#include "src/__support/macros/null_check.h" // LIBC_CRASH_ON_NULLPTR
+
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void, __sched_setcpuzero,
+                   (const size_t cpuset_size, cpu_set_t *set)) {
+  LIBC_CRASH_ON_NULLPTR(set);
+  __builtin_memset(set, 0, cpuset_size);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sched/sched_getcpuisset.h b/src/sched/sched_getcpuisset.h
new file mode 100644
index 0000000..8e6f69c
--- /dev/null
+++ b/src/sched/sched_getcpuisset.h
@@ -0,0 +1,24 @@
+//===-- Implementation header for sched_getcpuisset -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SCHED_SCHED_GETCPUISSET_H
+#define LLVM_LIBC_SRC_SCHED_SCHED_GETCPUISSET_H
+
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// for internal use in the CPU_ISSET macro
+int __sched_getcpuisset(int cpu, const size_t cpuset_size, cpu_set_t *set);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SCHED_SCHED_GETCPUISSET_H
diff --git a/src/sched/sched_setcpuset.h b/src/sched/sched_setcpuset.h
new file mode 100644
index 0000000..38d6cd2
--- /dev/null
+++ b/src/sched/sched_setcpuset.h
@@ -0,0 +1,24 @@
+//===-- Implementation header for sched_setcpuset ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SCHED_SCHED_SETCPUSET_H
+#define LLVM_LIBC_SRC_SCHED_SCHED_SETCPUSET_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// for internal use in the CPU_SET macro
+void __sched_setcpuset(int cpu, const size_t cpuset_size, cpu_set_t *set);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SCHED_SCHED_SETCPUSET_H
diff --git a/src/sched/sched_setcpuzero.h b/src/sched/sched_setcpuzero.h
new file mode 100644
index 0000000..53a0b45
--- /dev/null
+++ b/src/sched/sched_setcpuzero.h
@@ -0,0 +1,24 @@
+//===-- Implementation header for sched_setcpuzero --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SCHED_SCHED_SETCPUZERO_H
+#define LLVM_LIBC_SRC_SCHED_SCHED_SETCPUZERO_H
+
+#include "src/__support/macros/config.h"
+
+#include "hdr/types/cpu_set_t.h"
+#include "hdr/types/size_t.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// for internal use in the CPU_ZERO macro
+void __sched_setcpuzero(const size_t cpuset_size, cpu_set_t *set);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SCHED_SCHED_SETCPUZERO_H
diff --git a/src/search/lfind.cpp b/src/search/lfind.cpp
index c8bf07d..b10065a 100644
--- a/src/search/lfind.cpp
+++ b/src/search/lfind.cpp
@@ -1,4 +1,4 @@
-//===-- Implementation of lfind   -------------------------------*- C++ -*-===//
+//===-- Implementation of lfind ---------------------------------*- C++ -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
diff --git a/src/search/lsearch.cpp b/src/search/lsearch.cpp
new file mode 100644
index 0000000..e28dc34
--- /dev/null
+++ b/src/search/lsearch.cpp
@@ -0,0 +1,39 @@
+//===-- Implementation of lsearch -------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/search/lsearch.h"
+#include "src/__support/CPP/cstddef.h" // cpp::byte
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/memory_size.h"
+#include "src/string/memory_utils/inline_memcpy.h"
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(void *, lsearch,
+                   (const void *key, void *base, size_t *nmemb, size_t size,
+                    int (*compar)(const void *, const void *))) {
+  if (key == nullptr || base == nullptr || nmemb == nullptr ||
+      compar == nullptr)
+    return nullptr;
+
+  size_t byte_len = 0;
+  if (internal::mul_overflow(*nmemb, size, &byte_len))
+    return nullptr;
+
+  const cpp::byte *next = reinterpret_cast<const cpp::byte *>(base);
+  const cpp::byte *end = next + byte_len;
+  for (; next < end; next += size)
+    if (compar(key, next) == 0)
+      return const_cast<cpp::byte *>(next);
+
+  *nmemb += 1;
+  inline_memcpy(const_cast<cpp::byte *>(end), key, size);
+  return const_cast<cpp::byte *>(end);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/gpu/rpc_host_call.h b/src/search/lsearch.h
similarity index 58%
rename from src/gpu/rpc_host_call.h
rename to src/search/lsearch.h
index 861149d..c95e01d 100644
--- a/src/gpu/rpc_host_call.h
+++ b/src/search/lsearch.h
@@ -1,4 +1,4 @@
-//===-- Implementation header for RPC functions -----------------*- C++ -*-===//
+//===-- Implementation header for lsearch -----------------------*- C++ -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,16 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
-#define LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
+#ifndef LLVM_LIBC_SRC_SEARCH_LSEARCH_H
+#define LLVM_LIBC_SRC_SEARCH_LSEARCH_H
 
 #include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
 
 namespace LIBC_NAMESPACE_DECL {
-
-unsigned long long rpc_host_call(void *fn, void *buffer, size_t size);
-
+void *lsearch(const void *key, void *base, size_t *nmemb, size_t size,
+              int (*compar)(const void *, const void *));
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_GPU_RPC_HOST_CALL_H
+#endif // LLVM_LIBC_SRC_SEARCH_LSEARCH_H
diff --git a/src/setjmp/setjmp_impl.h b/src/setjmp/setjmp_impl.h
index d035409..669f720 100644
--- a/src/setjmp/setjmp_impl.h
+++ b/src/setjmp/setjmp_impl.h
@@ -29,7 +29,7 @@ namespace LIBC_NAMESPACE_DECL {
 #ifdef LIBC_COMPILER_IS_GCC
 [[gnu::nothrow]]
 #endif
-int setjmp(jmp_buf buf);
+__attribute__((returns_twice)) int setjmp(jmp_buf buf);
 
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/signal/linux/signal.cpp b/src/signal/linux/signal.cpp
index 1da0ef8..7c8ea16 100644
--- a/src/signal/linux/signal.cpp
+++ b/src/signal/linux/signal.cpp
@@ -8,14 +8,17 @@
 
 #include "src/signal/signal.h"
 #include "hdr/signal_macros.h"
-#include "hdr/types/sighandler_t.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 #include "src/signal/sigaction.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(sighandler_t, signal, (int signum, sighandler_t handler)) {
+// Our LLVM_LIBC_FUNCTION macro doesn't handle function pointer return types.
+using signal_handler = void (*)(int);
+
+LLVM_LIBC_FUNCTION(signal_handler, signal,
+                   (int signum, signal_handler handler)) {
   struct sigaction action, old;
   action.sa_handler = handler;
   action.sa_flags = SA_RESTART;
diff --git a/src/signal/signal.h b/src/signal/signal.h
index 06e77e1..e1f31a8 100644
--- a/src/signal/signal.h
+++ b/src/signal/signal.h
@@ -9,12 +9,11 @@
 #ifndef LLVM_LIBC_SRC_SIGNAL_SIGNAL_H
 #define LLVM_LIBC_SRC_SIGNAL_SIGNAL_H
 
-#include "hdr/types/sighandler_t.h"
 #include "src/__support/macros/config.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-sighandler_t signal(int signum, sighandler_t handler);
+void (*signal(int signum, void (*handler)(int)))(int);
 
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/stdfix/bitshk.cpp b/src/stdfix/bitshk.cpp
new file mode 100644
index 0000000..d0a3e12
--- /dev/null
+++ b/src/stdfix/bitshk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitshk function  --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitshk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // short accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_hk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_hk_t, bitshk, (short accum f)) {
+  return fixed_point::bitsfx<short accum, int_hk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitshk.h b/src/stdfix/bitshk.h
new file mode 100644
index 0000000..a1505e2
--- /dev/null
+++ b/src/stdfix/bitshk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitshk function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSHK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSHK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // short accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_hk_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_hk_t bitshk(short accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSHK_H
diff --git a/src/stdfix/bitshr.cpp b/src/stdfix/bitshr.cpp
new file mode 100644
index 0000000..394d1f0
--- /dev/null
+++ b/src/stdfix/bitshr.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitshr function  --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitshr.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // short fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_hr_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_hr_t, bitshr, (short fract f)) {
+  return fixed_point::bitsfx<short fract, int_hr_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitshr.h b/src/stdfix/bitshr.h
new file mode 100644
index 0000000..d5b4b8f
--- /dev/null
+++ b/src/stdfix/bitshr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitshr function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSHR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSHR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // short fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_hr_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_hr_t bitshr(short fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSHR_H
diff --git a/src/stdfix/bitsk.cpp b/src/stdfix/bitsk.cpp
new file mode 100644
index 0000000..f8c9d77
--- /dev/null
+++ b/src/stdfix/bitsk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation for bitsk function  --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_k_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_k_t, bitsk, (accum f)) {
+  return fixed_point::bitsfx<accum, int_k_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsk.h b/src/stdfix/bitsk.h
new file mode 100644
index 0000000..32d5a72
--- /dev/null
+++ b/src/stdfix/bitsk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsk function ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_k_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_k_t bitsk(accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSK_H
diff --git a/src/stdfix/bitslk.cpp b/src/stdfix/bitslk.cpp
new file mode 100644
index 0000000..f4af2a8
--- /dev/null
+++ b/src/stdfix/bitslk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation for bitslk function  -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitslk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // long accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_lk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_lk_t, bitslk, (long accum f)) {
+  return fixed_point::bitsfx<long accum, int_lk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitslk.h b/src/stdfix/bitslk.h
new file mode 100644
index 0000000..821116b
--- /dev/null
+++ b/src/stdfix/bitslk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitslk function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSLK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSLK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // long accum
+#include "include/llvm-libc-types/stdfix-types.h"   // int_lk_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_lk_t bitslk(long accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSLK_H
diff --git a/src/stdfix/bitslr.cpp b/src/stdfix/bitslr.cpp
new file mode 100644
index 0000000..3b38aa2
--- /dev/null
+++ b/src/stdfix/bitslr.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitslr function  --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitslr.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // long fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_lr_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_lr_t, bitslr, (long fract f)) {
+  return fixed_point::bitsfx<long fract, int_lr_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitslr.h b/src/stdfix/bitslr.h
new file mode 100644
index 0000000..0cb5972
--- /dev/null
+++ b/src/stdfix/bitslr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitslr function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSLR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSLR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // long fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_lr_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_lr_t bitslr(long fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSLR_H
diff --git a/src/stdfix/bitsr.cpp b/src/stdfix/bitsr.cpp
new file mode 100644
index 0000000..2b6ad2c
--- /dev/null
+++ b/src/stdfix/bitsr.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitsr function  ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsr.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_r_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int_r_t, bitsr, (fract f)) {
+  return fixed_point::bitsfx<fract, int_r_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsr.h b/src/stdfix/bitsr.h
new file mode 100644
index 0000000..e071f03
--- /dev/null
+++ b/src/stdfix/bitsr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsr function ----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // fract
+#include "include/llvm-libc-types/stdfix-types.h"   // int_r_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int_r_t bitsr(fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSR_H
diff --git a/src/stdfix/bitsuhk.cpp b/src/stdfix/bitsuhk.cpp
new file mode 100755
index 0000000..1b0bf59
--- /dev/null
+++ b/src/stdfix/bitsuhk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitsuhk function  -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsuhk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned short accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uhk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_uhk_t, bitsuhk, (unsigned short accum f)) {
+  return fixed_point::bitsfx<unsigned short accum, uint_uhk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsuhk.h b/src/stdfix/bitsuhk.h
new file mode 100755
index 0000000..1e80286
--- /dev/null
+++ b/src/stdfix/bitsuhk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsuhk function --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSUHK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSUHK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned short accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uhk_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_uhk_t bitsuhk(unsigned short accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSUHK_H
diff --git a/src/stdfix/bitsuhr.cpp b/src/stdfix/bitsuhr.cpp
new file mode 100755
index 0000000..66152e1
--- /dev/null
+++ b/src/stdfix/bitsuhr.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitsuhr function  -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsuhr.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned short fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uhr_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_uhr_t, bitsuhr, (unsigned short fract f)) {
+  return fixed_point::bitsfx<unsigned short fract, uint_uhr_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsuhr.h b/src/stdfix/bitsuhr.h
new file mode 100755
index 0000000..0311665
--- /dev/null
+++ b/src/stdfix/bitsuhr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsuhr function --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSUHR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSUHR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned short fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uhr_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_uhr_t bitsuhr(unsigned short fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSUHR_H
diff --git a/src/stdfix/bitsuk.cpp b/src/stdfix/bitsuk.cpp
new file mode 100755
index 0000000..b0a92bd
--- /dev/null
+++ b/src/stdfix/bitsuk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation for bitsuk function  -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsuk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_uk_t, bitsuk, (unsigned accum f)) {
+  return fixed_point::bitsfx<unsigned accum, uint_uk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsuk.h b/src/stdfix/bitsuk.h
new file mode 100755
index 0000000..fce37e8
--- /dev/null
+++ b/src/stdfix/bitsuk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsuk function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSUK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSUK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uk_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_uk_t bitsuk(unsigned accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSUK_H
diff --git a/src/stdfix/bitsulk.cpp b/src/stdfix/bitsulk.cpp
new file mode 100755
index 0000000..b8f61a1
--- /dev/null
+++ b/src/stdfix/bitsulk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation for bitsulk function  ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsulk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned long accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ulk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_ulk_t, bitsulk, (unsigned long accum f)) {
+  return fixed_point::bitsfx<unsigned long accum, uint_ulk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsulk.h b/src/stdfix/bitsulk.h
new file mode 100755
index 0000000..1bf681e
--- /dev/null
+++ b/src/stdfix/bitsulk.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsulk function --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSLK_H
+#define LLVM_LIBC_SRC_STDFIX_BITSLK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned long accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ulk_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_ulk_t bitsulk(unsigned long accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSLK_H
diff --git a/src/stdfix/bitsulr.cpp b/src/stdfix/bitsulr.cpp
new file mode 100755
index 0000000..9fd1b15
--- /dev/null
+++ b/src/stdfix/bitsulr.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitsulr function  -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsulr.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned long fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ulr_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_ulr_t, bitsulr, (unsigned long fract f)) {
+  return fixed_point::bitsfx<unsigned long fract, uint_ulr_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsulr.h b/src/stdfix/bitsulr.h
new file mode 100755
index 0000000..cf0f6fb
--- /dev/null
+++ b/src/stdfix/bitsulr.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsulr function --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSULR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSULR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned long fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ulr_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_ulr_t bitsulr(unsigned long fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSULR_H
diff --git a/src/stdfix/bitsur.cpp b/src/stdfix/bitsur.cpp
new file mode 100755
index 0000000..ffb52de
--- /dev/null
+++ b/src/stdfix/bitsur.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation of bitsur function ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsur.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ur_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_ur_t, bitsur, (unsigned fract f)) {
+  return fixed_point::bitsfx<unsigned fract, uint_ur_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/bitsur.h b/src/stdfix/bitsur.h
new file mode 100755
index 0000000..4c938bb
--- /dev/null
+++ b/src/stdfix/bitsur.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for bitsur function ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_BITSUR_H
+#define LLVM_LIBC_SRC_STDFIX_BITSUR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned fract
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_ur_t
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+uint_ur_t bitsur(unsigned fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_BITSUR_H
diff --git a/src/stdfix/bitusk.cpp b/src/stdfix/bitusk.cpp
new file mode 100755
index 0000000..ac0852e
--- /dev/null
+++ b/src/stdfix/bitusk.cpp
@@ -0,0 +1,22 @@
+//===-- Implementation for bitsuk function --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bitsuk.h"
+#include "include/llvm-libc-macros/stdfix-macros.h" // unsigned accum
+#include "include/llvm-libc-types/stdfix-types.h"   // uint_uk_t
+#include "src/__support/common.h"                   // LLVM_LIBC_FUNCTION
+#include "src/__support/fixed_point/fx_bits.h"      // fixed_point
+#include "src/__support/macros/config.h"            // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(uint_uk_t, bitsuk, (unsigned accum f)) {
+  return fixed_point::bitsfx<unsigned accum, uint_uk_t>(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlshk.cpp b/src/stdfix/countlshk.cpp
new file mode 100644
index 0000000..f94728b
--- /dev/null
+++ b/src/stdfix/countlshk.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlshk function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlshk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlshk, (short accum f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlshk.h b/src/stdfix/countlshk.h
new file mode 100644
index 0000000..ab33424
--- /dev/null
+++ b/src/stdfix/countlshk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlshk function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSHK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSHK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlshk(short accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSHK_H
diff --git a/src/stdfix/countlshr.cpp b/src/stdfix/countlshr.cpp
new file mode 100644
index 0000000..d77d3e9
--- /dev/null
+++ b/src/stdfix/countlshr.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlshr function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlshr.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlshr, (short fract f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlshr.h b/src/stdfix/countlshr.h
new file mode 100644
index 0000000..579b7b6
--- /dev/null
+++ b/src/stdfix/countlshr.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlshr function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSHR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSHR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlshr(short fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSHR_H
diff --git a/src/stdfix/countlsk.cpp b/src/stdfix/countlsk.cpp
new file mode 100644
index 0000000..b6f56ad
--- /dev/null
+++ b/src/stdfix/countlsk.cpp
@@ -0,0 +1,18 @@
+//===-- Implementation for countlsk function  -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsk, (accum f)) { return fixed_point::countls(f); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsk.h b/src/stdfix/countlsk.h
new file mode 100644
index 0000000..d0c893b
--- /dev/null
+++ b/src/stdfix/countlsk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsk function -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsk(accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSK_H
diff --git a/src/stdfix/countlslk.cpp b/src/stdfix/countlslk.cpp
new file mode 100644
index 0000000..9bf30ff
--- /dev/null
+++ b/src/stdfix/countlslk.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlslk function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlslk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlslk, (long accum f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlslk.h b/src/stdfix/countlslk.h
new file mode 100644
index 0000000..60fa469
--- /dev/null
+++ b/src/stdfix/countlslk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlslk function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSLK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSLK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlslk(long accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSLK_H
diff --git a/src/stdfix/countlslr.cpp b/src/stdfix/countlslr.cpp
new file mode 100644
index 0000000..774023c
--- /dev/null
+++ b/src/stdfix/countlslr.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlslr function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlslr.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlslr, (long fract f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlslr.h b/src/stdfix/countlslr.h
new file mode 100644
index 0000000..c909551
--- /dev/null
+++ b/src/stdfix/countlslr.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlslr function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSLR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSLR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlslr(long fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSLR_H
diff --git a/src/stdfix/countlsr.cpp b/src/stdfix/countlsr.cpp
new file mode 100644
index 0000000..1456312
--- /dev/null
+++ b/src/stdfix/countlsr.cpp
@@ -0,0 +1,18 @@
+//===-- Implementation for countlsr function  -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsr.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsr, (fract f)) { return fixed_point::countls(f); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsr.h b/src/stdfix/countlsr.h
new file mode 100644
index 0000000..75dcf4a
--- /dev/null
+++ b/src/stdfix/countlsr.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsr function -------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsr(fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSR_H
diff --git a/src/stdfix/countlsuhk.cpp b/src/stdfix/countlsuhk.cpp
new file mode 100644
index 0000000..2cc266f
--- /dev/null
+++ b/src/stdfix/countlsuhk.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsuhk function  ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsuhk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsuhk, (unsigned short accum f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsuhk.h b/src/stdfix/countlsuhk.h
new file mode 100644
index 0000000..fcb2fec
--- /dev/null
+++ b/src/stdfix/countlsuhk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsuhk function -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSUHK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSUHK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsuhk(unsigned short accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSUHK_H
diff --git a/src/stdfix/countlsuhr.cpp b/src/stdfix/countlsuhr.cpp
new file mode 100644
index 0000000..f30b0dd
--- /dev/null
+++ b/src/stdfix/countlsuhr.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsuhr function  ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsuhr.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsuhr, (unsigned short fract f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsuhr.h b/src/stdfix/countlsuhr.h
new file mode 100644
index 0000000..b60132d
--- /dev/null
+++ b/src/stdfix/countlsuhr.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsuhr function -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSUHR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSUHR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsuhr(unsigned short fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSUHR_H
diff --git a/src/stdfix/countlsuk.cpp b/src/stdfix/countlsuk.cpp
new file mode 100644
index 0000000..90617cf
--- /dev/null
+++ b/src/stdfix/countlsuk.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsuk function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsuk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsuk, (unsigned accum f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsuk.h b/src/stdfix/countlsuk.h
new file mode 100644
index 0000000..7ad0e70
--- /dev/null
+++ b/src/stdfix/countlsuk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsuk function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSUK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSUK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsuk(unsigned accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSUK_H
diff --git a/src/stdfix/countlsulk.cpp b/src/stdfix/countlsulk.cpp
new file mode 100644
index 0000000..04090dd
--- /dev/null
+++ b/src/stdfix/countlsulk.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsulk function  ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsulk.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsulk, (unsigned long accum f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsulk.h b/src/stdfix/countlsulk.h
new file mode 100644
index 0000000..55ca9d2
--- /dev/null
+++ b/src/stdfix/countlsulk.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsulk function -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSULK_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSULK_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsulk(unsigned long accum f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSULK_H
diff --git a/src/stdfix/countlsulr.cpp b/src/stdfix/countlsulr.cpp
new file mode 100644
index 0000000..d9d6ff4
--- /dev/null
+++ b/src/stdfix/countlsulr.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsulr function  ---------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsulr.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsulr, (unsigned long fract f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsulr.h b/src/stdfix/countlsulr.h
new file mode 100644
index 0000000..59e7d72
--- /dev/null
+++ b/src/stdfix/countlsulr.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsulr function -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSULR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSULR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsulr(unsigned long fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSULR_H
diff --git a/src/stdfix/countlsur.cpp b/src/stdfix/countlsur.cpp
new file mode 100644
index 0000000..777e5f3
--- /dev/null
+++ b/src/stdfix/countlsur.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation for countlsur function  ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "countlsur.h"
+#include "src/__support/common.h"
+#include "src/__support/fixed_point/fx_bits.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, countlsur, (unsigned fract f)) {
+  return fixed_point::countls(f);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdfix/countlsur.h b/src/stdfix/countlsur.h
new file mode 100644
index 0000000..1d34e97
--- /dev/null
+++ b/src/stdfix/countlsur.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for countlsur function ------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDFIX_COUNTLSUR_H
+#define LLVM_LIBC_SRC_STDFIX_COUNTLSUR_H
+
+#include "include/llvm-libc-macros/stdfix-macros.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
+
+namespace LIBC_NAMESPACE_DECL {
+
+int countlsur(unsigned fract f);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDFIX_COUNTLSUR_H
diff --git a/src/stdio/baremetal/getchar.cpp b/src/stdio/baremetal/getchar.cpp
index 0a78a1f..8fb7bc3 100644
--- a/src/stdio/baremetal/getchar.cpp
+++ b/src/stdio/baremetal/getchar.cpp
@@ -17,7 +17,7 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, getchar, ()) {
   char buf[1];
   auto result = read_from_stdin(buf, sizeof(buf));
-  if (result < 0)
+  if (result <= 0)
     return EOF;
   return buf[0];
 }
diff --git a/src/stdio/baremetal/printf.cpp b/src/stdio/baremetal/printf.cpp
index 04aa284..c94698e 100644
--- a/src/stdio/baremetal/printf.cpp
+++ b/src/stdio/baremetal/printf.cpp
@@ -38,8 +38,9 @@ LLVM_LIBC_FUNCTION(int, printf, (const char *__restrict format, ...)) {
   constexpr size_t BUFF_SIZE = 1024;
   char buffer[BUFF_SIZE];
 
-  printf_core::WriteBuffer wb(buffer, BUFF_SIZE, &raw_write_hook, nullptr);
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::WriteMode::FLUSH_TO_STREAM> wb(
+      buffer, BUFF_SIZE, &raw_write_hook, nullptr);
+  printf_core::Writer<printf_core::WriteMode::FLUSH_TO_STREAM> writer(wb);
 
   int retval = printf_core::printf_main(&writer, format, args);
 
diff --git a/src/stdio/baremetal/scanf.cpp b/src/stdio/baremetal/scanf.cpp
new file mode 100644
index 0000000..8d07aa1
--- /dev/null
+++ b/src/stdio/baremetal/scanf.cpp
@@ -0,0 +1,37 @@
+//===-- Implementation of scanf ---------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/scanf.h"
+
+#include "hdr/stdio_macros.h"
+#include "src/__support/OSUtil/io.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/baremetal/scanf_internal.h"
+#include "src/stdio/scanf_core/scanf_main.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, scanf, (const char *__restrict format, ...)) {
+  va_list vlist;
+  va_start(vlist, format);
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  va_end(vlist);
+
+  scanf_core::StdinReader reader;
+  int retval = scanf_core::scanf_main(&reader, format, args);
+  // This is done to avoid including stdio.h in the internals. On most systems
+  // EOF is -1, so this will be transformed into just "return retval".
+  return (retval == -1) ? EOF : retval;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/scanf_internal.h b/src/stdio/baremetal/scanf_internal.h
new file mode 100644
index 0000000..57d4b8c
--- /dev/null
+++ b/src/stdio/baremetal/scanf_internal.h
@@ -0,0 +1,30 @@
+//===-- Internal implementation header of scanf -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/OSUtil/io.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/reader.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+namespace scanf_core {
+
+struct StdinReader : public Reader<StdinReader> {
+  LIBC_INLINE char getc() {
+    char buf[1];
+    auto result = read_from_stdin(buf, sizeof(buf));
+    if (result <= 0)
+      return EOF;
+    return buf[0];
+  }
+  LIBC_INLINE void ungetc(int) {}
+};
+
+} // namespace scanf_core
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/baremetal/vprintf.cpp b/src/stdio/baremetal/vprintf.cpp
index 617b5f4..3e8631a 100644
--- a/src/stdio/baremetal/vprintf.cpp
+++ b/src/stdio/baremetal/vprintf.cpp
@@ -36,8 +36,9 @@ LLVM_LIBC_FUNCTION(int, vprintf,
   constexpr size_t BUFF_SIZE = 1024;
   char buffer[BUFF_SIZE];
 
-  printf_core::WriteBuffer wb(buffer, BUFF_SIZE, &raw_write_hook, nullptr);
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::WriteMode::FLUSH_TO_STREAM> wb(
+      buffer, BUFF_SIZE, &raw_write_hook, nullptr);
+  printf_core::Writer<printf_core::WriteMode::FLUSH_TO_STREAM> writer(wb);
 
   int retval = printf_core::printf_main(&writer, format, args);
 
diff --git a/src/stdio/baremetal/vscanf.cpp b/src/stdio/baremetal/vscanf.cpp
new file mode 100644
index 0000000..249f8fd
--- /dev/null
+++ b/src/stdio/baremetal/vscanf.cpp
@@ -0,0 +1,36 @@
+//===-- Implementation of vscanf --------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdio/vscanf.h"
+
+#include "hdr/stdio_macros.h"
+#include "src/__support/OSUtil/io.h"
+#include "src/__support/arg_list.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/baremetal/scanf_internal.h"
+#include "src/stdio/scanf_core/scanf_main.h"
+
+#include <stdarg.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, vscanf,
+                   (const char *__restrict format, va_list vlist)) {
+  internal::ArgList args(vlist); // This holder class allows for easier copying
+                                 // and pointer semantics, as well as handling
+                                 // destruction automatically.
+  va_end(vlist);
+
+  scanf_core::StdinReader reader;
+  int retval = scanf_core::scanf_main(&reader, format, args);
+  // This is done to avoid including stdio.h in the internals. On most systems
+  // EOF is -1, so this will be transformed into just "return retval".
+  return (retval == -1) ? EOF : retval;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/generic/fileno.cpp b/src/stdio/generic/fileno.cpp
index 0bec180..8fa73d1 100644
--- a/src/stdio/generic/fileno.cpp
+++ b/src/stdio/generic/fileno.cpp
@@ -1,5 +1,4 @@
-//===-- Implementation of fileno
-//-------------------------------------------===//
+//===-- Implementation of fileno ------------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
diff --git a/src/stdio/fscanf.cpp b/src/stdio/generic/fscanf.cpp
similarity index 100%
rename from src/stdio/fscanf.cpp
rename to src/stdio/generic/fscanf.cpp
diff --git a/src/stdio/scanf.cpp b/src/stdio/generic/scanf.cpp
similarity index 100%
rename from src/stdio/scanf.cpp
rename to src/stdio/generic/scanf.cpp
diff --git a/src/stdio/vfscanf.cpp b/src/stdio/generic/vfscanf.cpp
similarity index 100%
rename from src/stdio/vfscanf.cpp
rename to src/stdio/generic/vfscanf.cpp
diff --git a/src/stdio/vscanf.cpp b/src/stdio/generic/vscanf.cpp
similarity index 100%
rename from src/stdio/vscanf.cpp
rename to src/stdio/generic/vscanf.cpp
diff --git a/src/stdio/gpu/clearerr.cpp b/src/stdio/gpu/clearerr.cpp
index 4c631b9..4d843e4 100644
--- a/src/stdio/gpu/clearerr.cpp
+++ b/src/stdio/gpu/clearerr.cpp
@@ -15,7 +15,7 @@
 namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, clearerr, (::FILE * stream)) {
-  rpc::Client::Port port = rpc::client.open<RPC_CLEARERR>();
+  rpc::Client::Port port = rpc::client.open<LIBC_CLEARERR>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/fclose.cpp b/src/stdio/gpu/fclose.cpp
index 683e054..847d6b8 100644
--- a/src/stdio/gpu/fclose.cpp
+++ b/src/stdio/gpu/fclose.cpp
@@ -18,7 +18,7 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, fclose, (::FILE * stream)) {
   uint64_t ret = 0;
   uintptr_t file = reinterpret_cast<uintptr_t>(stream);
-  rpc::Client::Port port = rpc::client.open<RPC_CLOSE_FILE>();
+  rpc::Client::Port port = rpc::client.open<LIBC_CLOSE_FILE>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) { buffer->data[0] = file; },
       [&](rpc::Buffer *buffer, uint32_t) { ret = buffer->data[0]; });
diff --git a/src/stdio/gpu/feof.cpp b/src/stdio/gpu/feof.cpp
index 02adb4c..a15e487 100644
--- a/src/stdio/gpu/feof.cpp
+++ b/src/stdio/gpu/feof.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, feof, (::FILE * stream)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_FEOF>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FEOF>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/ferror.cpp b/src/stdio/gpu/ferror.cpp
index ca77713..8273820 100644
--- a/src/stdio/gpu/ferror.cpp
+++ b/src/stdio/gpu/ferror.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ferror, (::FILE * stream)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_FERROR>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FERROR>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/fflush.cpp b/src/stdio/gpu/fflush.cpp
index 577325b..5a5137b 100644
--- a/src/stdio/gpu/fflush.cpp
+++ b/src/stdio/gpu/fflush.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fflush, (::FILE * stream)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_FFLUSH>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FFLUSH>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/fgets.cpp b/src/stdio/gpu/fgets.cpp
index fbc1b0c..d90b7aa 100644
--- a/src/stdio/gpu/fgets.cpp
+++ b/src/stdio/gpu/fgets.cpp
@@ -26,7 +26,7 @@ LLVM_LIBC_FUNCTION(char *, fgets,
 
   uint64_t recv_size;
   void *buf = nullptr;
-  rpc::Client::Port port = rpc::client.open<RPC_READ_FGETS>();
+  rpc::Client::Port port = rpc::client.open<LIBC_READ_FGETS>();
   port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = count;
     buffer->data[1] = file::from_stream(stream);
diff --git a/src/stdio/gpu/file.h b/src/stdio/gpu/file.h
index 6ca792b..437ee99 100644
--- a/src/stdio/gpu/file.h
+++ b/src/stdio/gpu/file.h
@@ -54,7 +54,7 @@ LIBC_INLINE uint64_t write_impl(::FILE *file, const void *data, size_t size) {
   uint64_t ret = 0;
   rpc::Client::Port port = rpc::client.open<opcode>();
 
-  if constexpr (opcode == RPC_WRITE_TO_STREAM) {
+  if constexpr (opcode == LIBC_WRITE_TO_STREAM) {
     port.send([&](rpc::Buffer *buffer, uint32_t) {
       buffer->data[0] = reinterpret_cast<uintptr_t>(file);
     });
@@ -70,17 +70,17 @@ LIBC_INLINE uint64_t write_impl(::FILE *file, const void *data, size_t size) {
 
 LIBC_INLINE uint64_t write(::FILE *f, const void *data, size_t size) {
   if (f == stdout)
-    return write_impl<RPC_WRITE_TO_STDOUT>(f, data, size);
+    return write_impl<LIBC_WRITE_TO_STDOUT>(f, data, size);
   else if (f == stderr)
-    return write_impl<RPC_WRITE_TO_STDERR>(f, data, size);
+    return write_impl<LIBC_WRITE_TO_STDERR>(f, data, size);
   else
-    return write_impl<RPC_WRITE_TO_STREAM>(f, data, size);
+    return write_impl<LIBC_WRITE_TO_STREAM>(f, data, size);
 }
 
 LIBC_INLINE uint64_t read_from_stream(::FILE *file, void *buf, size_t size) {
   uint64_t ret = 0;
   uint64_t recv_size;
-  rpc::Client::Port port = rpc::client.open<RPC_READ_FROM_STREAM>();
+  rpc::Client::Port port = rpc::client.open<LIBC_READ_FROM_STREAM>();
   port.send([=](rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = size;
     buffer->data[1] = from_stream(file);
diff --git a/src/stdio/gpu/fopen.cpp b/src/stdio/gpu/fopen.cpp
index e165d2a..18dd719 100644
--- a/src/stdio/gpu/fopen.cpp
+++ b/src/stdio/gpu/fopen.cpp
@@ -18,7 +18,7 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(::FILE *, fopen,
                    (const char *__restrict path, const char *__restrict mode)) {
   uintptr_t file;
-  rpc::Client::Port port = rpc::client.open<RPC_OPEN_FILE>();
+  rpc::Client::Port port = rpc::client.open<LIBC_OPEN_FILE>();
   port.send_n(path, internal::string_length(path) + 1);
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
diff --git a/src/stdio/gpu/fseek.cpp b/src/stdio/gpu/fseek.cpp
index 37c40bc..5ada5de 100644
--- a/src/stdio/gpu/fseek.cpp
+++ b/src/stdio/gpu/fseek.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, fseek, (::FILE * stream, long offset, int whence)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_FSEEK>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FSEEK>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/ftell.cpp b/src/stdio/gpu/ftell.cpp
index 226aeda..04bb0dd 100644
--- a/src/stdio/gpu/ftell.cpp
+++ b/src/stdio/gpu/ftell.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(long, ftell, (::FILE * stream)) {
   long ret;
-  rpc::Client::Port port = rpc::client.open<RPC_FSEEK>();
+  rpc::Client::Port port = rpc::client.open<LIBC_FSEEK>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = file::from_stream(stream);
diff --git a/src/stdio/gpu/puts.cpp b/src/stdio/gpu/puts.cpp
index 20f7a88..fc252ab 100644
--- a/src/stdio/gpu/puts.cpp
+++ b/src/stdio/gpu/puts.cpp
@@ -18,7 +18,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, puts, (const char *__restrict str)) {
   cpp::string_view str_view(str);
-  auto written = file::write_impl<RPC_WRITE_TO_STDOUT_NEWLINE>(stdout, str,
+  auto written = file::write_impl<LIBC_WRITE_TO_STDOUT_NEWLINE>(stdout, str,
                                                                str_view.size());
   if (written != str_view.size() + 1)
     return EOF;
diff --git a/src/stdio/gpu/remove.cpp b/src/stdio/gpu/remove.cpp
index 6604be1..4bfb5d3 100644
--- a/src/stdio/gpu/remove.cpp
+++ b/src/stdio/gpu/remove.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, remove, (const char *path)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_REMOVE>();
+  rpc::Client::Port port = rpc::client.open<LIBC_REMOVE>();
   port.send_n(path, internal::string_length(path) + 1);
   port.recv([&](rpc::Buffer *buffer, uint32_t) {
     ret = static_cast<int>(buffer->data[0]);
diff --git a/src/stdio/gpu/rename.cpp b/src/stdio/gpu/rename.cpp
index e6396e2..589bf24 100644
--- a/src/stdio/gpu/rename.cpp
+++ b/src/stdio/gpu/rename.cpp
@@ -17,7 +17,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, rename, (const char *oldpath, const char *newpath)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_RENAME>();
+  rpc::Client::Port port = rpc::client.open<LIBC_RENAME>();
   port.send_n(oldpath, internal::string_length(oldpath) + 1);
   port.send_n(newpath, internal::string_length(newpath) + 1);
   port.recv([&](rpc::Buffer *buffer, uint32_t) {
diff --git a/src/stdio/gpu/ungetc.cpp b/src/stdio/gpu/ungetc.cpp
index dce1439..fd1db46 100644
--- a/src/stdio/gpu/ungetc.cpp
+++ b/src/stdio/gpu/ungetc.cpp
@@ -16,7 +16,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, ungetc, (int c, ::FILE *stream)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_UNGETC>();
+  rpc::Client::Port port = rpc::client.open<LIBC_UNGETC>();
   port.send_and_recv(
       [=](rpc::Buffer *buffer, uint32_t) {
         buffer->data[0] = c;
diff --git a/src/stdio/gpu/vfprintf_utils.h b/src/stdio/gpu/vfprintf_utils.h
index a0a8c39..df157d3 100644
--- a/src/stdio/gpu/vfprintf_utils.h
+++ b/src/stdio/gpu/vfprintf_utils.h
@@ -23,8 +23,8 @@ LIBC_INLINE int vfprintf_impl(::FILE *__restrict file,
   uint64_t mask = gpu::get_lane_mask();
   rpc::Client::Port port = rpc::client.open<opcode>();
 
-  if constexpr (opcode == RPC_PRINTF_TO_STREAM ||
-                opcode == RPC_PRINTF_TO_STREAM_PACKED) {
+  if constexpr (opcode == LIBC_PRINTF_TO_STREAM ||
+                opcode == LIBC_PRINTF_TO_STREAM_PACKED) {
     port.send([&](rpc::Buffer *buffer, uint32_t) {
       buffer->data[0] = reinterpret_cast<uintptr_t>(file);
     });
@@ -63,24 +63,24 @@ LIBC_INLINE int vfprintf_internal(::FILE *__restrict stream,
   // separate opcode so the server knows how much to advance the pointers.
 #if defined(LIBC_TARGET_ARCH_IS_AMDGPU)
   if (stream == stdout)
-    return vfprintf_impl<RPC_PRINTF_TO_STDOUT_PACKED>(stream, format,
-                                                      format_size, vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STDOUT_PACKED>(stream, format,
+                                                       format_size, vlist);
   else if (stream == stderr)
-    return vfprintf_impl<RPC_PRINTF_TO_STDERR_PACKED>(stream, format,
-                                                      format_size, vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STDERR_PACKED>(stream, format,
+                                                       format_size, vlist);
   else
-    return vfprintf_impl<RPC_PRINTF_TO_STREAM_PACKED>(stream, format,
-                                                      format_size, vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STREAM_PACKED>(stream, format,
+                                                       format_size, vlist);
 #else
   if (stream == stdout)
-    return vfprintf_impl<RPC_PRINTF_TO_STDOUT>(stream, format, format_size,
-                                               vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STDOUT>(stream, format, format_size,
+                                                vlist);
   else if (stream == stderr)
-    return vfprintf_impl<RPC_PRINTF_TO_STDERR>(stream, format, format_size,
-                                               vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STDERR>(stream, format, format_size,
+                                                vlist);
   else
-    return vfprintf_impl<RPC_PRINTF_TO_STREAM>(stream, format, format_size,
-                                               vlist);
+    return vfprintf_impl<LIBC_PRINTF_TO_STREAM>(stream, format, format_size,
+                                                vlist);
 #endif
 }
 
diff --git a/src/stdio/printf_core/char_converter.h b/src/stdio/printf_core/char_converter.h
index 2596cba..fd2eb25 100644
--- a/src/stdio/printf_core/char_converter.h
+++ b/src/stdio/printf_core/char_converter.h
@@ -17,7 +17,9 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_char(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_char(Writer<write_mode> *writer,
+                             const FormatSection &to_conv) {
   char c = static_cast<char>(to_conv.conv_val_raw);
 
   constexpr int STRING_LEN = 1;
diff --git a/src/stdio/printf_core/converter.cpp b/src/stdio/printf_core/converter.cpp
deleted file mode 100644
index b1c6645..0000000
--- a/src/stdio/printf_core/converter.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//===-- Format specifier converter implmentation for printf -----*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/printf_core/converter.h"
-
-#include "src/__support/macros/config.h"
-#include "src/stdio/printf_core/core_structs.h"
-#include "src/stdio/printf_core/printf_config.h"
-#include "src/stdio/printf_core/strerror_converter.h"
-#include "src/stdio/printf_core/writer.h"
-
-// This option allows for replacing all of the conversion functions with custom
-// replacements. This allows conversions to be replaced at compile time.
-#ifndef LIBC_COPT_PRINTF_CONV_ATLAS
-#include "src/stdio/printf_core/converter_atlas.h"
-#else
-#include LIBC_COPT_PRINTF_CONV_ATLAS
-#endif
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace printf_core {
-
-int convert(Writer *writer, const FormatSection &to_conv) {
-  if (!to_conv.has_conv)
-    return writer->write(to_conv.raw_string);
-
-#if !defined(LIBC_COPT_PRINTF_DISABLE_FLOAT) &&                                \
-    defined(LIBC_COPT_PRINTF_HEX_LONG_DOUBLE)
-  if (to_conv.length_modifier == LengthModifier::L) {
-    switch (to_conv.conv_name) {
-    case 'f':
-    case 'F':
-    case 'e':
-    case 'E':
-    case 'g':
-    case 'G':
-      return convert_float_hex_exp(writer, to_conv);
-    default:
-      break;
-    }
-  }
-#endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
-
-  switch (to_conv.conv_name) {
-  case '%':
-    return writer->write("%");
-  case 'c':
-    return convert_char(writer, to_conv);
-  case 's':
-    return convert_string(writer, to_conv);
-  case 'd':
-  case 'i':
-  case 'u':
-  case 'o':
-  case 'x':
-  case 'X':
-  case 'b':
-  case 'B':
-    return convert_int(writer, to_conv);
-#ifndef LIBC_COPT_PRINTF_DISABLE_FLOAT
-  case 'f':
-  case 'F':
-    return convert_float_decimal(writer, to_conv);
-  case 'e':
-  case 'E':
-    return convert_float_dec_exp(writer, to_conv);
-  case 'a':
-  case 'A':
-    return convert_float_hex_exp(writer, to_conv);
-  case 'g':
-  case 'G':
-    return convert_float_dec_auto(writer, to_conv);
-#endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
-#ifdef LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
-  case 'r':
-  case 'R':
-  case 'k':
-  case 'K':
-    return convert_fixed(writer, to_conv);
-#endif // LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
-#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
-  case 'm':
-    return convert_strerror(writer, to_conv);
-#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
-#ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
-  case 'n':
-    return convert_write_int(writer, to_conv);
-#endif // LIBC_COPT_PRINTF_DISABLE_WRITE_INT
-  case 'p':
-    return convert_pointer(writer, to_conv);
-  default:
-    return writer->write(to_conv.raw_string);
-  }
-  return -1;
-}
-
-} // namespace printf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/converter.h b/src/stdio/printf_core/converter.h
index 2b3f06d..f26ed72 100644
--- a/src/stdio/printf_core/converter.h
+++ b/src/stdio/printf_core/converter.h
@@ -11,8 +11,18 @@
 
 #include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/core_structs.h"
+#include "src/stdio/printf_core/printf_config.h"
+#include "src/stdio/printf_core/strerror_converter.h"
 #include "src/stdio/printf_core/writer.h"
 
+// This option allows for replacing all of the conversion functions with custom
+// replacements. This allows conversions to be replaced at compile time.
+#ifndef LIBC_COPT_PRINTF_CONV_ATLAS
+#include "src/stdio/printf_core/converter_atlas.h"
+#else
+#include LIBC_COPT_PRINTF_CONV_ATLAS
+#endif
+
 #include <stddef.h>
 
 namespace LIBC_NAMESPACE_DECL {
@@ -21,7 +31,80 @@ namespace printf_core {
 // convert will call a conversion function to convert the FormatSection into
 // its string representation, and then that will write the result to the
 // writer.
-int convert(Writer *writer, const FormatSection &to_conv);
+template <WriteMode write_mode>
+int convert(Writer<write_mode> *writer, const FormatSection &to_conv) {
+  if (!to_conv.has_conv)
+    return writer->write(to_conv.raw_string);
+
+#if !defined(LIBC_COPT_PRINTF_DISABLE_FLOAT) &&                                \
+    defined(LIBC_COPT_PRINTF_HEX_LONG_DOUBLE)
+  if (to_conv.length_modifier == LengthModifier::L) {
+    switch (to_conv.conv_name) {
+    case 'f':
+    case 'F':
+    case 'e':
+    case 'E':
+    case 'g':
+    case 'G':
+      return convert_float_hex_exp(writer, to_conv);
+    default:
+      break;
+    }
+  }
+#endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
+
+  switch (to_conv.conv_name) {
+  case '%':
+    return writer->write("%");
+  case 'c':
+    return convert_char(writer, to_conv);
+  case 's':
+    return convert_string(writer, to_conv);
+  case 'd':
+  case 'i':
+  case 'u':
+  case 'o':
+  case 'x':
+  case 'X':
+  case 'b':
+  case 'B':
+    return convert_int(writer, to_conv);
+#ifndef LIBC_COPT_PRINTF_DISABLE_FLOAT
+  case 'f':
+  case 'F':
+    return convert_float_decimal(writer, to_conv);
+  case 'e':
+  case 'E':
+    return convert_float_dec_exp(writer, to_conv);
+  case 'a':
+  case 'A':
+    return convert_float_hex_exp(writer, to_conv);
+  case 'g':
+  case 'G':
+    return convert_float_dec_auto(writer, to_conv);
+#endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
+#ifdef LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
+  case 'r':
+  case 'R':
+  case 'k':
+  case 'K':
+    return convert_fixed(writer, to_conv);
+#endif // LIBC_INTERNAL_PRINTF_HAS_FIXED_POINT
+#ifndef LIBC_COPT_PRINTF_DISABLE_STRERROR
+  case 'm':
+    return convert_strerror(writer, to_conv);
+#endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
+#ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
+  case 'n':
+    return convert_write_int(writer, to_conv);
+#endif // LIBC_COPT_PRINTF_DISABLE_WRITE_INT
+  case 'p':
+    return convert_pointer(writer, to_conv);
+  default:
+    return writer->write(to_conv.raw_string);
+  }
+  return -1;
+}
 
 } // namespace printf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/converter_atlas.h b/src/stdio/printf_core/converter_atlas.h
index 18cfe1e..dfb91b3 100644
--- a/src/stdio/printf_core/converter_atlas.h
+++ b/src/stdio/printf_core/converter_atlas.h
@@ -26,7 +26,11 @@
 // defines convert_float_decimal
 // defines convert_float_dec_exp
 // defines convert_float_dec_auto
+#ifdef LIBC_COPT_FLOAT_TO_STR_USE_FLOAT320
+#include "src/stdio/printf_core/float_dec_converter_limited.h"
+#else
 #include "src/stdio/printf_core/float_dec_converter.h"
+#endif
 // defines convert_float_hex_exp
 #include "src/stdio/printf_core/float_hex_converter.h"
 #endif // LIBC_COPT_PRINTF_DISABLE_FLOAT
diff --git a/src/stdio/printf_core/fixed_converter.h b/src/stdio/printf_core/fixed_converter.h
index c8812d7..e8a3314 100644
--- a/src/stdio/printf_core/fixed_converter.h
+++ b/src/stdio/printf_core/fixed_converter.h
@@ -11,6 +11,7 @@
 
 #include "include/llvm-libc-macros/stdfix-macros.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/fixed_point/fx_bits.h"
 #include "src/__support/fixed_point/fx_rep.h"
 #include "src/__support/integer_to_string.h"
@@ -62,16 +63,14 @@ LIBC_INLINE constexpr uint32_t const_ten_exp(uint32_t exponent) {
     }                                                                          \
   } while (false)
 
-LIBC_INLINE int convert_fixed(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_fixed(Writer<write_mode> *writer,
+                              const FormatSection &to_conv) {
   // Long accum should be the largest type, so we can store all the smaller
   // numbers in things sized for it.
   using LARep = fixed_point::FXRep<unsigned long accum>;
   using StorageType = LARep::StorageType;
 
-  // All of the letters will be defined relative to variable a, which will be
-  // the appropriate case based on the name of the conversion. This converts any
-  // conversion name into the letter 'a' with the appropriate case.
-  const char a = (to_conv.conv_name & 32) | 'A';
   FormatFlags flags = to_conv.flags;
 
   bool is_negative;
@@ -179,9 +178,9 @@ LIBC_INLINE int convert_fixed(Writer *writer, const FormatSection &to_conv) {
     // unspecified.
     RoundDirection round;
     char first_digit_after = fraction_digits[precision];
-    if (first_digit_after > '5') {
+    if (internal::b36_char_to_int(first_digit_after) > 5) {
       round = RoundDirection::Up;
-    } else if (first_digit_after < '5') {
+    } else if (internal::b36_char_to_int(first_digit_after) < 5) {
       round = RoundDirection::Down;
     } else {
       // first_digit_after == '5'
@@ -204,7 +203,8 @@ LIBC_INLINE int convert_fixed(Writer *writer, const FormatSection &to_conv) {
         keep_rounding = false;
         char cur_digit = fraction_digits[digit_to_round];
         // if the digit should not be rounded up
-        if (round == RoundDirection::Even && ((cur_digit - '0') % 2) == 0) {
+        if (round == RoundDirection::Even &&
+            (internal::b36_char_to_int(cur_digit) % 2) == 0) {
           // break out of the loop
           break;
         }
@@ -246,7 +246,7 @@ LIBC_INLINE int convert_fixed(Writer *writer, const FormatSection &to_conv) {
   char sign_char = 0;
 
   // Check if the conv name is uppercase
-  if (a == 'A') {
+  if (internal::isupper(to_conv.conv_name)) {
     // These flags are only for signed conversions, so this removes them if the
     // conversion is unsigned.
     flags = FormatFlags(flags &
diff --git a/src/stdio/printf_core/float_dec_converter.h b/src/stdio/printf_core/float_dec_converter.h
index e39ba6e..ee55498 100644
--- a/src/stdio/printf_core/float_dec_converter.h
+++ b/src/stdio/printf_core/float_dec_converter.h
@@ -13,6 +13,7 @@
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/rounding_mode.h"
 #include "src/__support/big_int.h" // is_big_int_v
+#include "src/__support/ctype_utils.h"
 #include "src/__support/float_to_string.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/libc_assert.h"
@@ -92,7 +93,7 @@ zero_after_digits(int32_t base_2_exp, int32_t digits_after_point, T mantissa,
   return has_trailing_zeros;
 }
 
-class PaddingWriter {
+template <WriteMode write_mode> class PaddingWriter {
   bool left_justified = false;
   bool leading_zeroes = false;
   char sign_char = 0;
@@ -106,7 +107,8 @@ public:
         sign_char(init_sign_char),
         min_width(to_conv.min_width > 0 ? to_conv.min_width : 0) {}
 
-  LIBC_INLINE int write_left_padding(Writer *writer, size_t total_digits) {
+  LIBC_INLINE int write_left_padding(Writer<write_mode> *writer,
+                                     size_t total_digits) {
     // The pattern is (spaces) (sign) (zeroes), but only one of spaces and
     // zeroes can be written, and only if the padding amount is positive.
     int padding_amount =
@@ -129,7 +131,8 @@ public:
     return 0;
   }
 
-  LIBC_INLINE int write_right_padding(Writer *writer, size_t total_digits) {
+  LIBC_INLINE int write_right_padding(Writer<write_mode> *writer,
+                                      size_t total_digits) {
     // If and only if the conversion is left justified, there may be trailing
     // spaces.
     int padding_amount =
@@ -154,7 +157,7 @@ public:
   This FloatWriter class does the buffering and counting, and writes to the
   output when necessary.
 */
-class FloatWriter {
+template <WriteMode write_mode> class FloatWriter {
   char block_buffer[BLOCK_SIZE]; // The buffer that holds a block.
   size_t buffered_digits = 0;    // The number of digits held in the buffer.
   bool has_written = false;      // True once any digits have been output.
@@ -163,8 +166,9 @@ class FloatWriter {
   size_t digits_before_decimal = 0; // The # of digits to write before the '.'
   size_t total_digits_written = 0;  // The # of digits that have been output.
   bool has_decimal_point;           // True if the number has a decimal point.
-  Writer *writer;                   // Writes to the final output.
-  PaddingWriter padding_writer; // Handles prefixes/padding, uses total_digits.
+  Writer<write_mode> *writer;       // Writes to the final output.
+  PaddingWriter<write_mode>
+      padding_writer; // Handles prefixes/padding, uses total_digits.
 
   LIBC_INLINE int flush_buffer(bool round_up_max_blocks = false) {
     const char MAX_BLOCK_DIGIT = (round_up_max_blocks ? '0' : '9');
@@ -244,8 +248,9 @@ class FloatWriter {
   static_assert(fputil::FPBits<long double>::EXP_LEN < (sizeof(int) * 8));
 
 public:
-  LIBC_INLINE FloatWriter(Writer *init_writer, bool init_has_decimal_point,
-                          const PaddingWriter &init_padding_writer)
+  LIBC_INLINE FloatWriter(Writer<write_mode> *init_writer,
+                          bool init_has_decimal_point,
+                          const PaddingWriter<write_mode> &init_padding_writer)
       : has_decimal_point(init_has_decimal_point), writer(init_writer),
         padding_writer(init_padding_writer) {}
 
@@ -465,12 +470,24 @@ public:
   }
 };
 
+// Class-template auto deduction helpers, add more if needed.
+FloatWriter(Writer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>, bool,
+            const PaddingWriter<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>)
+    -> FloatWriter<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>;
+FloatWriter(Writer<WriteMode::RESIZE_AND_FILL_BUFF>, bool,
+            const PaddingWriter<WriteMode::RESIZE_AND_FILL_BUFF>)
+    -> FloatWriter<WriteMode::RESIZE_AND_FILL_BUFF>;
+FloatWriter(Writer<WriteMode::FLUSH_TO_STREAM>, bool,
+            const PaddingWriter<WriteMode::FLUSH_TO_STREAM>)
+    -> FloatWriter<WriteMode::FLUSH_TO_STREAM>;
+
 // This implementation is based on the Ryu Printf algorithm by Ulf Adams:
 // Ulf Adams. 2019. Ry revisited: printf floating point conversion.
 // Proc. ACM Program. Lang. 3, OOPSLA, Article 169 (October 2019), 23 pages.
 // https://doi.org/10.1145/3360595
-template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
-LIBC_INLINE int convert_float_decimal_typed(Writer *writer,
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_decimal_typed(Writer<write_mode> *writer,
                                             const FormatSection &to_conv,
                                             fputil::FPBits<T> float_bits) {
   // signed because later we use -FRACTION_LEN
@@ -497,7 +514,7 @@ LIBC_INLINE int convert_float_decimal_typed(Writer *writer,
   // ignored.
   bool nonzero = false;
 
-  PaddingWriter padding_writer(to_conv, sign_char);
+  PaddingWriter<write_mode> padding_writer(to_conv, sign_char);
   FloatWriter float_writer(writer, has_decimal_point, padding_writer);
   FloatToString<T> float_converter(float_bits.get_val());
 
@@ -578,8 +595,9 @@ LIBC_INLINE int convert_float_decimal_typed(Writer *writer,
   return WRITE_OK;
 }
 
-template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
-LIBC_INLINE int convert_float_dec_exp_typed(Writer *writer,
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_dec_exp_typed(Writer<write_mode> *writer,
                                             const FormatSection &to_conv,
                                             fputil::FPBits<T> float_bits) {
   // signed because later we use -FRACTION_LEN
@@ -587,8 +605,6 @@ LIBC_INLINE int convert_float_dec_exp_typed(Writer *writer,
   int exponent = float_bits.get_explicit_exponent();
   StorageType mantissa = float_bits.get_explicit_mantissa();
 
-  const char a = (to_conv.conv_name & 32) | 'A';
-
   char sign_char = 0;
 
   if (float_bits.is_neg())
@@ -604,7 +620,7 @@ LIBC_INLINE int convert_float_dec_exp_typed(Writer *writer,
   bool has_decimal_point =
       (precision > 0) || ((to_conv.flags & FormatFlags::ALTERNATE_FORM) != 0);
 
-  PaddingWriter padding_writer(to_conv, sign_char);
+  PaddingWriter<write_mode> padding_writer(to_conv, sign_char);
   FloatWriter float_writer(writer, has_decimal_point, padding_writer);
   FloatToString<T> float_converter(float_bits.get_val());
 
@@ -734,14 +750,16 @@ LIBC_INLINE int convert_float_dec_exp_typed(Writer *writer,
   round = get_round_direction(last_digit, truncated, float_bits.sign());
 
   RET_IF_RESULT_NEGATIVE(float_writer.write_last_block(
-      digits, maximum, round, final_exponent, a + 'E' - 'A'));
+      digits, maximum, round, final_exponent,
+      internal::islower(to_conv.conv_name) ? 'e' : 'E'));
 
   RET_IF_RESULT_NEGATIVE(float_writer.right_pad());
   return WRITE_OK;
 }
 
-template <typename T, cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
-LIBC_INLINE int convert_float_dec_auto_typed(Writer *writer,
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_dec_auto_typed(Writer<write_mode> *writer,
                                              const FormatSection &to_conv,
                                              fputil::FPBits<T> float_bits) {
   // signed because later we use -FRACTION_LEN
@@ -1107,7 +1125,9 @@ LIBC_INLINE int convert_float_dec_auto_typed(Writer *writer,
 }
 
 // TODO: unify the float converters to remove the duplicated checks for inf/nan.
-LIBC_INLINE int convert_float_decimal(Writer *writer,
+
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_decimal(Writer<write_mode> *writer,
                                       const FormatSection &to_conv) {
   if (to_conv.length_modifier == LengthModifier::L) {
     fputil::FPBits<long double>::StorageType float_raw = to_conv.conv_val_raw;
@@ -1128,7 +1148,8 @@ LIBC_INLINE int convert_float_decimal(Writer *writer,
   return convert_inf_nan(writer, to_conv);
 }
 
-LIBC_INLINE int convert_float_dec_exp(Writer *writer,
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_dec_exp(Writer<write_mode> *writer,
                                       const FormatSection &to_conv) {
   if (to_conv.length_modifier == LengthModifier::L) {
     fputil::FPBits<long double>::StorageType float_raw = to_conv.conv_val_raw;
@@ -1149,7 +1170,8 @@ LIBC_INLINE int convert_float_dec_exp(Writer *writer,
   return convert_inf_nan(writer, to_conv);
 }
 
-LIBC_INLINE int convert_float_dec_auto(Writer *writer,
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_dec_auto(Writer<write_mode> *writer,
                                        const FormatSection &to_conv) {
   if (to_conv.length_modifier == LengthModifier::L) {
     fputil::FPBits<long double>::StorageType float_raw = to_conv.conv_val_raw;
diff --git a/src/stdio/printf_core/float_dec_converter_limited.h b/src/stdio/printf_core/float_dec_converter_limited.h
new file mode 100644
index 0000000..f468dbc
--- /dev/null
+++ b/src/stdio/printf_core/float_dec_converter_limited.h
@@ -0,0 +1,699 @@
+//===-- Decimal Float Converter for printf (320-bit float) ------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements an alternative to the Ry printf algorithm in
+// float_dec_converter.h. Instead of generating output digits 9 at a time on
+// demand, in this implementation, a float is converted to decimal by computing
+// just one power of 10 and multiplying/dividing the entire input by it,
+// generating the whole string of decimal output digits in one go.
+//
+// This avoids the large constant lookup table of Ry, making it more suitable
+// for low-memory embedded contexts; but it's also faster than the fallback
+// version of Ry which computes table entries on demand using DyadicFloat,
+// because those must calculate a potentially large power of 10 per 9-digit
+// output block, whereas this computes just one, which does the whole job.
+//
+// The calculation is done in 320-bit DyadicFloat, which provides enough
+// precision to generate 39 correct digits of output from any floating-point
+// size up to and including 128-bit long double, because the rounding errors in
+// computing the largest necessary power of 10 are still smaller than the
+// distance (in the 320-bit float format) between adjacent 39-decimal-digit
+// outputs.
+//
+// No further digits beyond the 39th are generated: if the printf format string
+// asks for more precision than that, the answer is padded with 0s. This is a
+// permitted option in IEEE 754-2019 (section 5.12.2): you're allowed to define
+// a limit H on the number of decimal digits you can generate, and pad with 0s
+// if asked for more than that, subject to the constraint that H must be
+// consistent across all float formats you support (you can't use a smaller H
+// for single precision than double or long double), and must be large enough
+// that even in the largest supported precision the only numbers misrounded are
+// ones extremely close to a rounding boundary. 39 digits is the smallest
+// permitted value for an implementation supporting binary128.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_DEC_CONVERTER_LIMITED_H
+#define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_DEC_CONVERTER_LIMITED_H
+
+#include "src/__support/CPP/algorithm.h"
+#include "src/__support/CPP/string.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/FPUtil/dyadic_float.h"
+#include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/integer_to_string.h"
+#include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/core_structs.h"
+#include "src/stdio/printf_core/float_inf_nan_converter.h"
+#include "src/stdio/printf_core/writer.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace printf_core {
+
+enum class ConversionType { E, F, G };
+using StorageType = fputil::FPBits<long double>::StorageType;
+
+constexpr unsigned MAX_DIGITS = 39;
+constexpr size_t DF_BITS = 320;
+constexpr char DECIMAL_POINT = '.';
+
+struct DigitsInput {
+  // Input mantissa, stored with the explicit leading 1 bit (if any) at the
+  // top. So either it has a value in the range [2^127,2^128) representing a
+  // real number in [1,2), or it has the value 0, representing 0.
+  UInt128 mantissa;
+
+  // Input exponent, as a power of 2 to multiply into mantissa.
+  int exponent;
+
+  // Input sign.
+  Sign sign;
+
+  // Constructor which accepts a mantissa direct from a floating-point format,
+  // and shifts it up to the top of the UInt128 so that a function consuming
+  // this struct afterwards doesn't have to remember which format it came from.
+  DigitsInput(int32_t fraction_len, StorageType mantissa_, int exponent_,
+              Sign sign)
+      : mantissa(UInt128(mantissa_) << (127 - fraction_len)),
+        exponent(exponent_), sign(sign) {
+    if (!(mantissa & (UInt128(1) << 127)) && mantissa != 0) {
+      // Normalize a denormalized input.
+      int shift = cpp::countl_zero(mantissa);
+      mantissa <<= shift;
+      exponent -= shift;
+    }
+  }
+};
+
+struct DigitsOutput {
+  // Output from decimal_digits().
+  //
+  // `digits` is a buffer containing nothing but ASCII digits. Even if the
+  // decimal point needs to appear somewhere in the final output string, it
+  // isn't represented in _this_ string; the client of this object will insert
+  // it in an appropriate place. `ndigits` gives the buffer size.
+  //
+  // `exponent` represents the exponent you would display if the decimal point
+  // comes after the first digit of decimal_digits, e.g. if digits == "1234"
+  // and exponent = 3 then this represents 1.234e3, or just the integer 1234.
+  size_t ndigits;
+  int exponent;
+  char digits[MAX_DIGITS + 1];
+};
+
+// Estimate log10 of a power of 2, by multiplying its exponent by
+// 1292913986/2^32. That is a rounded-down approximation to log10(2), accurate
+// enough that for any binary exponent in the range of float128 it will give
+// the correct value of floor(log10(2^n)).
+LIBC_INLINE int estimate_log10(int exponent_of_2) {
+  return static_cast<int>((exponent_of_2 * 1292913986LL) >> 32);
+}
+
+// Calculate the actual digits of a decimal representation of an FP number.
+//
+// If `e_mode` is true, then `precision` indicates the desired number of output
+// decimal digits. On return, `decimal_digits` will be a string of length
+// exactly `precision` starting with a nonzero digit; `decimal_exponent` will
+// be filled in to indicate the exponent as shown above.
+//
+// If `e_mode` is false, then `precision` indicates the desired number of
+// digits after the decimal point. On return, the last digit in the string
+// `decimal_digits` has a place value of _at least_ 10^-precision. But also, at
+// most `MAX_DIGITS` digits are returned, so the caller may need to pad it at
+// the end with the appropriate number of extra 0s.
+LIBC_INLINE
+DigitsOutput decimal_digits(DigitsInput input, int precision, bool e_mode) {
+  if (input.mantissa == 0) {
+    // Special-case zero, by manually generating the right number of zero
+    // digits and setting an appropriate exponent.
+    DigitsOutput output;
+    if (!e_mode) {
+      // In F mode, it's enough to return an empty string of digits. That's the
+      // same thing we do when given a nonzero number that rounds down to 0.
+      output.ndigits = 0;
+      output.exponent = -precision - 1;
+    } else {
+      // In E mode, generate a string containing the expected number of 0s.
+      __builtin_memset(output.digits, '0', precision);
+      output.ndigits = precision;
+      output.exponent = 0;
+    }
+    return output;
+  }
+
+  // Calculate bounds on log10 of the input value. Its binary exponent bounds
+  // the value between two powers of 2, and we use estimate_log10 to determine
+  // log10 of each of those.
+  //
+  // If a power of 10 falls in the interval between those powers of 2, then
+  // log10_input_min and log10_input_max will differ by 1, and the correct
+  // decimal exponent of the output will be one of those two values. If no
+  // power of 10 is in the interval, then these two values will be equal and
+  // there is only one choice for the decimal exponent.
+  int log10_input_min = estimate_log10(input.exponent - 1);
+  int log10_input_max = estimate_log10(input.exponent);
+
+  // Make a DyadicFloat containing the value 10, to use as the base for
+  // exponentiation.
+  fputil::DyadicFloat<DF_BITS> ten(Sign::POS, 1, 5);
+
+  // Compute the exponent of the lowest-order digit we want as output. In F
+  // mode this depends only on the desired precision. In E mode it's based on
+  // log10_input, which is (an estimate of) the exponent corresponding to the
+  // _high_-order decimal digit of the number.
+  int log10_low_digit = e_mode ? log10_input_min + 1 - precision : -precision;
+
+  // The general plan is to calculate an integer whose decimal representation
+  // is precisely the string of output digits, by doing a DyadicFloat
+  // computation of (input_mantissa / 10^(log10_low_digit)) and then rounding
+  // that to an integer.
+  //
+  // The number of output decimal digits (if the mathematical result of this
+  // operation were computed without overflow) will be one of these:
+  //   (log10_input_min - log10_low_digit + 1)
+  //   (log10_input_max - log10_low_digit + 1)
+  //
+  // In E mode, this means we'll either get the correct number of output digits
+  // immediately, or else one too many (in which case we can correct for that
+  // at the rounding stage). But in F mode, if the number is very large
+  // compared to the number of decimal places the user asked for, we might be
+  // about to generate far too many digits and overflow our float format. In
+  // that case, reset to E mode immediately, to avoid having to detect the
+  // overflow _after_ the multiplication and retry. So if even the smaller
+  // number of possible output digits is too many, we might as well change our
+  // mind right now and switch into E mode.
+  if (log10_input_max - log10_low_digit + 1 > int(MAX_DIGITS)) {
+    precision = MAX_DIGITS;
+    e_mode = true;
+    log10_low_digit = log10_input_min + 1 - precision;
+  }
+
+  // Now actually calculate (input_mantissa / 10^(log10_low_digit)).
+  //
+  // If log10_low_digit < 0, then we calculate 10^(-log10_low_digit) and
+  // multiply by it instead, so that the exponent is non-negative in all cases.
+  // This ensures that the power of 10 is always mathematically speaking an
+  // integer, so that it can be represented exactly in binary (without a
+  // recurring fraction), and when it's small enough to fit in DF_BITS,
+  // fputil::pow_n should return the exact answer, and then
+  // fputil::rounded_{div,mul} will introduce only the unavoidable rounding
+  // error of up to 1/2 ULP.
+  //
+  // Beyond that point, pow_n will be imprecise. But DF_BITS is set high enough
+  // that even for the most difficult cases in 128-bit long double, the extra
+  // precision in the calculation is enough to ensure we still get the right
+  // answer.
+  //
+  // If the output integer doesn't fit in DF_BITS, we set the `overflow` flag.
+
+  // Calculate the power of 10 to divide or multiply by.
+  fputil::DyadicFloat<DF_BITS> power_of_10 =
+      fputil::pow_n(ten, cpp::abs(log10_low_digit));
+
+  // Convert the mantissa into a DyadicFloat, making sure it has the right
+  // sign, so that directed rounding will go in the right direction, if
+  // enabled.
+  fputil::DyadicFloat<DF_BITS> flt_mantissa(
+      input.sign,
+      input.exponent -
+          (cpp::numeric_limits<decltype(input.mantissa)>::digits - 1),
+      input.mantissa);
+
+  // Divide or multiply, depending on whether log10_low_digit was positive
+  // or negative.
+  fputil::DyadicFloat<DF_BITS> flt_quotient =
+      log10_low_digit > 0 ? fputil::rounded_div(flt_mantissa, power_of_10)
+                          : fputil::rounded_mul(flt_mantissa, power_of_10);
+
+  // Convert to an integer.
+  int round_dir;
+  UInt<DF_BITS> integer = flt_quotient.as_mantissa_type_rounded(&round_dir);
+
+  // And take the absolute value.
+  if (flt_quotient.sign.is_neg())
+    integer = -integer;
+
+  // Convert the mantissa integer into a string of decimal digits, and check
+  // to see if it's the right size.
+  const IntegerToString<decltype(integer), radix::Dec> buf{integer};
+  cpp::string_view view = buf.view();
+
+  // Start making the output struct, by copying in the digits from the above
+  // object. At this stage we may also have one digit too many (but that's OK,
+  // there's space for it in the DigitsOutput buffer).
+  DigitsOutput output;
+  output.ndigits = view.size();
+  __builtin_memcpy(output.digits, view.data(), output.ndigits);
+
+  // Set up the output exponent, which is done differently depending on mode.
+  // Also, figure out whether we have one digit too many, and if so, set the
+  // `need_reround` flag and adjust the exponent appropriately.
+  bool need_reround = false;
+  if (e_mode) {
+    // In E mode, the output exponent is the exponent of the first decimal
+    // digit, which we already calculated.
+    output.exponent = log10_input_min;
+
+    // In E mode, we're returning a fixed number of digits, given by
+    // `precision`, so if we have more than that, then we must shorten the
+    // buffer by one digit.
+    //
+    // If this happens, it's because the actual log10 of the input is
+    // log10_input_min + 1. Equivalently, we guessed we'd see something like
+    // X.YZe+NN and instead got WX.YZe+NN. So when we shorten the digit string
+    // by one, we'll also need to increment the output exponent.
+    if (output.ndigits > size_t(precision)) {
+      LIBC_ASSERT(output.ndigits == size_t(precision) + 1);
+      need_reround = true;
+      output.exponent++;
+    }
+  } else {
+    // In F mode, the output exponent is based on the place value of the _last_
+    // digit, so we must recover the exponent of the first digit by adding
+    // the number of digits.
+    //
+    // Because this takes the length of the buffer into account, it sets the
+    // correct decimal exponent even if this digit string is one too long. So
+    // we don't need to adjust the exponent if we reround.
+    output.exponent = int(output.ndigits) - precision - 1;
+
+    // In F mode, the number of returned digits isn't based on `precision`:
+    // it's variable, and we don't mind how many digits we get as long as it
+    // isn't beyond the limit MAX_DIGITS. If it is, we expect that it's only
+    // one digit too long, or else we'd have spotted the problem in advance and
+    // flipped into E mode already.
+    if (output.ndigits > MAX_DIGITS) {
+      LIBC_ASSERT(output.ndigits == MAX_DIGITS + 1);
+      need_reround = true;
+    }
+  }
+
+  if (need_reround) {
+    // If either of the branches above decided that we had one digit too many,
+    // we must now shorten the digit buffer by one. But we can't just truncate:
+    // we need to make sure the remaining n-1 digits are correctly rounded, as
+    // if we'd rounded just once from the original `flt_quotient`.
+    //
+    // In directed rounding modes this can't go wrong. If you had a real number
+    // x, and the first rounding produced floor(x), then the second rounding
+    // wants floor(x/10), and it doesn't matter if you actually compute
+    // floor(floor(x)/10): the result is the same, because each rounding
+    // boundary in the second rounding aligns with one in the first rounding,
+    // which nothing could have crossed. Similarly for rounding away from zero,
+    // with 'floor' replaced with 'ceil' throughout.
+    //
+    // In rounding to nearest, the danger is in the boundary case where the
+    // final digit of the original output is 5. Then if we just rerounded the
+    // digit string to remove the last digit, it would look like an exact
+    // halfway case, and we'd break the tie by choosing the even one of the two
+    // outputs. But if the original value before the first rounding was on one
+    // side or the other of 5, then that supersedes the 'round to even' tie
+    // break. So we need to consult `round_dir` from above, which tells us
+    // which way (if either) the value was adjusted during the first rounding.
+    // Effectively, we treat the last digit as 5+ or 5-.
+    //
+    // To make this work in both directed modes and round-to-nearest mode
+    // without having to look up the rounding direction, a simple rule is: take
+    // account of round_dir if and only if the round digit (the one we're
+    // removing when shortening the buffer) is 5. In directed rounding modes
+    // this makes no difference.
+
+    // Extract the two relevant digits. round_digit is the one we're removing;
+    // new_low_digit is the last one we're keeping, so we need to know if it's
+    // even or odd to handle exact tie cases (when round_dir == 0).
+    --output.ndigits;
+    int round_digit = internal::b36_char_to_int(output.digits[output.ndigits]);
+    int new_low_digit =
+        output.ndigits == 0
+            ? 0
+            : internal::b36_char_to_int(output.digits[output.ndigits - 1]);
+
+    // Make a binary number that we can pass to `fputil::rounding_direction`.
+    // We put new_low_digit at bit 8, and imagine that we're rounding away the
+    // bottom 8 bits. Therefore round_digit must be "just below" bit 8, in the
+    // sense that we set the bottom 8 bits to (256/10 * round_digit) so that
+    // round_digit==5 corresponds to the binary half-way case of 0x80.
+    //
+    // Then we adjust by +1 or -1 based on round_dir if the round digit is 5,
+    // as described above.
+    //
+    // The subexpression `(round_digit * 0x19a) >> 4` is computing the
+    // expression (256/10 * round_digit) mentioned above, accurately enough to
+    // map 5 to exactly 128 but avoiding an integer division (for platforms
+    // where it's slow, e.g. not in hardware).
+    LIBC_NAMESPACE::UInt<64> round_word = (new_low_digit * 256) +
+                                          ((round_digit * 0x19a) >> 4) +
+                                          (round_digit == 5 ? -round_dir : 0);
+
+    // Now we can call the existing binary rounding helper function, which
+    // takes account of the rounding mode.
+    if (fputil::rounding_direction(round_word, 8, flt_quotient.sign) > 0) {
+      // If that returned a positive answer, we must round the number up.
+      //
+      // The number is already in decimal, so we need to increment it one digit
+      // at a time. (A bit painful, but better than going back to the integer
+      // we made it from and doing the decimal conversion all over again.)
+      for (size_t i = output.ndigits; i-- > 0;) {
+        if (output.digits[i] != '9') {
+          output.digits[i] = static_cast<char>(internal::int_to_b36_char(
+              internal::b36_char_to_int(output.digits[i]) + 1));
+          break;
+        } else {
+          output.digits[i] = '0';
+        }
+      }
+    }
+  }
+
+  return output;
+}
+
+template <WriteMode write_mode>
+LIBC_INLINE int
+convert_float_inner(Writer<write_mode> *writer, const FormatSection &to_conv,
+                    int32_t fraction_len, int exponent, StorageType mantissa,
+                    Sign sign, ConversionType ctype) {
+  // If to_conv doesn't specify a precision, the precision defaults to 6.
+  unsigned precision = to_conv.precision < 0 ? 6 : to_conv.precision;
+
+  // Decide if we're displaying a sign character, depending on the format flags
+  // and whether the input is negative.
+  char sign_char = 0;
+  if (sign.is_neg())
+    sign_char = '-';
+  else if ((to_conv.flags & FormatFlags::FORCE_SIGN) == FormatFlags::FORCE_SIGN)
+    sign_char = '+'; // FORCE_SIGN has precedence over SPACE_PREFIX
+  else if ((to_conv.flags & FormatFlags::SPACE_PREFIX) ==
+           FormatFlags::SPACE_PREFIX)
+    sign_char = ' ';
+
+  // Prepare the input to decimal_digits().
+  DigitsInput input(fraction_len, mantissa, exponent, sign);
+
+  // Call decimal_digits() in a different way, based on whether the format
+  // character is 'e', 'f', or 'g'. After this loop we expect to have filled
+  // in the following variables:
+
+  // The decimal digits, and the exponent of the topmost one.
+  DigitsOutput output;
+  // The start and end of the digit string we're displaying, as indices into
+  // `output.digits`. The indices may be out of bounds in either direction, in
+  // which case digits beyond the bounds of the buffer should be displayed as
+  // zeroes.
+  //
+  // As usual, the index 'start' is included, and 'limit' is not.
+  int start, limit;
+  // The index of the digit that we display a decimal point immediately after.
+  // Again, represented as an index in `output.digits`, and may be out of
+  // bounds.
+  int pointpos;
+  // Whether we need to display an "e+NNN" exponent suffix at all.
+  bool show_exponent;
+
+  switch (ctype) {
+  case ConversionType::E:
+    // In E mode, we display one digit more than the specified precision
+    // (`%.6e` means six digits _after_ the decimal point, like 1.123456e+00).
+    //
+    // Also, bound the number of digits we request at MAX_DIGITS.
+    output = decimal_digits(input, cpp::min(precision + 1, MAX_DIGITS), true);
+
+    // We display digits from the start of the buffer, and always output
+    // `precision+1` of them (which will append zeroes if the user requested
+    // more than MAX_DIGITS).
+    start = 0;
+    limit = precision + 1;
+
+    // The decimal point is always after the first digit of the buffer.
+    pointpos = start;
+
+    // The exponent is always displayed explicitly.
+    show_exponent = true;
+    break;
+  case ConversionType::F:
+    // In F mode, we provide decimal_digits() with the unmodified input
+    // precision, and let it give us as many digits as we can.
+    output = decimal_digits(input, precision, false);
+
+    // Initialize (start, limit) to display everything from the first nonzero
+    // digit (necessarily at the start of the output buffer) to the digit at
+    // the correct distance after the decimal point.
+    start = 0;
+    limit = 1 + output.exponent + precision;
+
+    // But we must display at least one digit _before_ the decimal point, i.e.
+    // at least precision+1 digits in total. So if we're not already doing
+    // that, we must correct those values.
+    if (limit <= int(precision))
+      start -= precision + 1 - limit;
+
+    // The decimal point appears precisely 'precision' digits before the end of
+    // the digits we output.
+    pointpos = limit - 1 - precision;
+
+    // The exponent is never displayed.
+    show_exponent = false;
+    break;
+  case ConversionType::G:
+    // In G mode, the precision says exactly how many significant digits you
+    // want. (In that respect it's subtly unlike E mode: %.6g means six digits
+    // _including_ the one before the point, whereas %.6e means six digits
+    // _excluding_ that one.)
+    //
+    // Also, a precision of 0 is treated the same as 1.
+    precision = cpp::max(precision, 1u);
+    output = decimal_digits(input, cpp::min(precision, MAX_DIGITS), true);
+
+    // As in E mode, we default to displaying precisely the digits in the
+    // output buffer.
+    start = 0;
+    limit = precision;
+
+    // If we're not in ALTERNATE_FORM mode, trailing zeroes on the mantissa are
+    // removed (although not to the extent of leaving no digits at all - if the
+    // entire output mantissa is all 0 then we keep a single zero digit).
+    if (!(to_conv.flags & FormatFlags::ALTERNATE_FORM)) {
+      // Start by removing trailing zeroes that were outside the buffer
+      // entirely.
+      limit = cpp::min(limit, int(output.ndigits));
+
+      // Then check the digits in the buffer and remove as many as possible.
+      while (limit > 1 && output.digits[limit - 1] == '0')
+        limit--;
+    }
+
+    // Decide whether to display in %e style with an explicit exponent, or %f
+    // style with the decimal point after the units place.
+    //
+    // %e mode is used to avoid an excessive number of leading zeroes after the
+    // decimal point but before the first nonzero digit (specifically, 0.0001
+    // is fine as it is, but 0.00001 prints as 1e-5), and also to avoid adding
+    // trailing zeroes if the last digit in the buffer is still higher than the
+    // units place.
+    //
+    // output.exponent is an int whereas precision is unsigned, so we must
+    // check output.exponent >= 0 before comparing it against precision to
+    // prevent a negative exponent from wrapping round to a large unsigned int.
+    if ((output.exponent >= 0 && output.exponent >= int(precision)) ||
+        output.exponent < -4) {
+      // Display in %e style, so the point goes after the first digit and the
+      // exponent is shown.
+      pointpos = start;
+      show_exponent = true;
+    } else {
+      // Display in %f style, so the point goes at its true mathematical
+      // location and the exponent is not shown.
+      pointpos = output.exponent;
+      show_exponent = false;
+
+      if (output.exponent < 0) {
+        // If the first digit is below the decimal point, add leading zeroes.
+        // (This _decreases_ start, because output.exponent is negative here.)
+        start += output.exponent;
+      } else if (limit <= output.exponent) {
+        // If the last digit is above the decimal point, add trailing zeroes.
+        // (This may involve putting back some zeroes that we trimmed in the
+        // loop above!)
+        limit = output.exponent + 1;
+      }
+    }
+    break;
+  }
+
+  // Find out for sure whether we're displaying the decimal point, so that we
+  // can include it in the calculation of the total string length for padding.
+  //
+  // We never expect pointpos to be _before_ the start of the displayed range
+  // of digits. (If it had been, we'd have added leading zeroes.) But it might
+  // be beyond the end.
+  //
+  // We don't display the point if it appears immediately after the _last_
+  // digit we display, except in ALTERNATE_FORM mode.
+  int last_point_digit =
+      (to_conv.flags & FormatFlags::ALTERNATE_FORM) ? limit - 1 : limit - 2;
+  bool show_point = pointpos <= last_point_digit;
+
+  // Format the exponent suffix (e+NN, e-NN) into a buffer, or leave the buffer
+  // empty if we're not displaying one.
+  char expbuf[16]; // more than enough space for e+NNNN
+  size_t explen = 0;
+  if (show_exponent) {
+    const IntegerToString<decltype(output.exponent),
+                          radix::Dec::WithWidth<2>::WithSign>
+        expcvt{output.exponent};
+    cpp::string_view expview = expcvt.view();
+    expbuf[0] = internal::islower(to_conv.conv_name) ? 'e' : 'E';
+    explen = expview.size() + 1;
+    __builtin_memcpy(expbuf + 1, expview.data(), expview.size());
+  }
+
+  // Now we know enough to work out the length of the unpadded output:
+  //  * whether to write a sign
+  //  * how many mantissa digits to write
+  //  * whether to write a decimal point
+  //  * the length of the trailing exponent string.
+  size_t unpadded_len =
+      (sign_char != 0) + (limit - start) + show_point + explen;
+
+  // Work out how much padding is needed.
+  size_t min_width = to_conv.min_width > 0 ? to_conv.min_width : 0;
+  size_t padding_amount = cpp::max(min_width, unpadded_len) - unpadded_len;
+
+  // Work out what the padding looks like and where it appears.
+  enum class Padding {
+    LeadingSpace,  // spaces at the start of the string
+    Zero,          // zeroes between sign and mantissa
+    TrailingSpace, // spaces at the end of the string
+  } padding = Padding::LeadingSpace;
+  // The '-' flag for left-justification takes priority over the '0' flag
+  if (to_conv.flags & FormatFlags::LEFT_JUSTIFIED)
+    padding = Padding::TrailingSpace;
+  else if (to_conv.flags & FormatFlags::LEADING_ZEROES)
+    padding = Padding::Zero;
+
+  // Finally, write all the output!
+
+  // Leading-space padding, if any
+  if (padding == Padding::LeadingSpace)
+    RET_IF_RESULT_NEGATIVE(writer->write(' ', padding_amount));
+
+  // Sign, if any
+  if (sign_char)
+    RET_IF_RESULT_NEGATIVE(writer->write(sign_char));
+
+  // Zero padding, if any
+  if (padding == Padding::Zero)
+    RET_IF_RESULT_NEGATIVE(writer->write('0', padding_amount));
+
+  // Mantissa digits, maybe with a decimal point
+  for (int pos = start; pos < limit; ++pos) {
+    if (pos >= 0 && pos < int(output.ndigits)) {
+      // Fetch a digit from the buffer
+      RET_IF_RESULT_NEGATIVE(writer->write(output.digits[pos]));
+    } else {
+      // This digit is outside the buffer, so write a zero
+      RET_IF_RESULT_NEGATIVE(writer->write('0'));
+    }
+
+    // Show the decimal point, if this is the digit it comes after
+    if (show_point && pos == pointpos)
+      RET_IF_RESULT_NEGATIVE(writer->write(DECIMAL_POINT));
+  }
+
+  // Exponent
+  RET_IF_RESULT_NEGATIVE(writer->write(cpp::string_view(expbuf, explen)));
+
+  // Trailing-space padding, if any
+  if (padding == Padding::TrailingSpace)
+    RET_IF_RESULT_NEGATIVE(writer->write(' ', padding_amount));
+
+  return WRITE_OK;
+}
+
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int
+convert_float_typed(Writer<write_mode> *writer, const FormatSection &to_conv,
+                    fputil::FPBits<T> float_bits, ConversionType ctype) {
+  return convert_float_inner(writer, to_conv, float_bits.FRACTION_LEN,
+                             float_bits.get_explicit_exponent(),
+                             float_bits.get_explicit_mantissa(),
+                             float_bits.sign(), ctype);
+}
+
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_outer(Writer<write_mode> *writer,
+                                    const FormatSection &to_conv,
+                                    ConversionType ctype) {
+  if (to_conv.length_modifier == LengthModifier::L) {
+    fputil::FPBits<long double>::StorageType float_raw = to_conv.conv_val_raw;
+    fputil::FPBits<long double> float_bits(float_raw);
+    if (!float_bits.is_inf_or_nan()) {
+      return convert_float_typed<long double>(writer, to_conv, float_bits,
+                                              ctype);
+    }
+  } else {
+    fputil::FPBits<double>::StorageType float_raw =
+        static_cast<fputil::FPBits<double>::StorageType>(to_conv.conv_val_raw);
+    fputil::FPBits<double> float_bits(float_raw);
+    if (!float_bits.is_inf_or_nan()) {
+      return convert_float_typed<double>(writer, to_conv, float_bits, ctype);
+    }
+  }
+
+  return convert_inf_nan(writer, to_conv);
+}
+
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_decimal_typed(Writer<write_mode> *writer,
+                                            const FormatSection &to_conv,
+                                            fputil::FPBits<T> float_bits) {
+  return convert_float_typed<T>(writer, to_conv, float_bits, ConversionType::F);
+}
+
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_dec_exp_typed(Writer<write_mode> *writer,
+                                            const FormatSection &to_conv,
+                                            fputil::FPBits<T> float_bits) {
+  return convert_float_typed<T>(writer, to_conv, float_bits, ConversionType::E);
+}
+
+template <typename T, WriteMode write_mode,
+          cpp::enable_if_t<cpp::is_floating_point_v<T>, int> = 0>
+LIBC_INLINE int convert_float_dec_auto_typed(Writer<write_mode> *writer,
+                                             const FormatSection &to_conv,
+                                             fputil::FPBits<T> float_bits) {
+  return convert_float_typed<T>(writer, to_conv, float_bits, ConversionType::G);
+}
+
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_decimal(Writer<write_mode> *writer,
+                                      const FormatSection &to_conv) {
+  return convert_float_outer(writer, to_conv, ConversionType::F);
+}
+
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_dec_exp(Writer<write_mode> *writer,
+                                      const FormatSection &to_conv) {
+  return convert_float_outer(writer, to_conv, ConversionType::E);
+}
+
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_dec_auto(Writer<write_mode> *writer,
+                                       const FormatSection &to_conv) {
+  return convert_float_outer(writer, to_conv, ConversionType::G);
+}
+
+} // namespace printf_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_DEC_CONVERTER_LIMITED_H
diff --git a/src/stdio/printf_core/float_hex_converter.h b/src/stdio/printf_core/float_hex_converter.h
index 0b3ff3d..16592e7 100644
--- a/src/stdio/printf_core/float_hex_converter.h
+++ b/src/stdio/printf_core/float_hex_converter.h
@@ -12,6 +12,7 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/rounding_mode.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
@@ -24,14 +25,11 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_float_hex_exp(Writer *writer,
+template <WriteMode write_mode>
+LIBC_INLINE int convert_float_hex_exp(Writer<write_mode> *writer,
                                       const FormatSection &to_conv) {
   using LDBits = fputil::FPBits<long double>;
   using StorageType = LDBits::StorageType;
-  // All of the letters will be defined relative to variable a, which will be
-  // the appropriate case based on the name of the conversion. This converts any
-  // conversion name into the letter 'a' with the appropriate case.
-  const char a = (to_conv.conv_name & 32) | 'A';
 
   bool is_negative;
   int exponent;
@@ -138,9 +136,10 @@ LIBC_INLINE int convert_float_hex_exp(Writer *writer,
   size_t mant_cur = mant_len;
   size_t first_non_zero = 1;
   for (; mant_cur > 0; --mant_cur, mantissa >>= 4) {
-    char mant_mod_16 = static_cast<char>(mantissa) & 15;
-    char new_digit = static_cast<char>(
-        (mant_mod_16 > 9) ? (mant_mod_16 - 10 + a) : (mant_mod_16 + '0'));
+    char mant_mod_16 = static_cast<char>(mantissa % 16);
+    char new_digit = static_cast<char>(internal::int_to_b36_char(mant_mod_16));
+    if (internal::isupper(to_conv.conv_name))
+      new_digit = static_cast<char>(internal::toupper(new_digit));
     mant_buffer[mant_cur - 1] = new_digit;
     if (new_digit != '0' && first_non_zero < mant_cur)
       first_non_zero = mant_cur;
@@ -168,7 +167,8 @@ LIBC_INLINE int convert_float_hex_exp(Writer *writer,
 
   size_t exp_cur = EXP_LEN;
   for (; exponent > 0; --exp_cur, exponent /= 10) {
-    exp_buffer[exp_cur - 1] = static_cast<char>((exponent % 10) + '0');
+    exp_buffer[exp_cur - 1] =
+        static_cast<char>(internal::int_to_b36_char(exponent % 10));
   }
   if (exp_cur == EXP_LEN) { // if nothing else was written, write a 0.
     exp_buffer[EXP_LEN - 1] = '0';
@@ -187,7 +187,7 @@ LIBC_INLINE int convert_float_hex_exp(Writer *writer,
   constexpr size_t PREFIX_LEN = 2;
   char prefix[PREFIX_LEN];
   prefix[0] = '0';
-  prefix[1] = a + ('x' - 'a');
+  prefix[1] = internal::islower(to_conv.conv_name) ? 'x' : 'X';
   const cpp::string_view prefix_str(prefix, PREFIX_LEN);
 
   // If the precision is greater than the actual result, pad with 0s
@@ -200,7 +200,7 @@ LIBC_INLINE int convert_float_hex_exp(Writer *writer,
   constexpr cpp::string_view HEXADECIMAL_POINT(".");
 
   // This is for the letter 'p' before the exponent.
-  const char exp_separator = a + ('p' - 'a');
+  const char exp_separator = internal::islower(to_conv.conv_name) ? 'p' : 'P';
   constexpr int EXP_SEPARATOR_LEN = 1;
 
   padding = static_cast<int>(to_conv.min_width - (sign_char > 0 ? 1 : 0) -
diff --git a/src/stdio/printf_core/float_inf_nan_converter.h b/src/stdio/printf_core/float_inf_nan_converter.h
index a7da682..ce31d7a 100644
--- a/src/stdio/printf_core/float_inf_nan_converter.h
+++ b/src/stdio/printf_core/float_inf_nan_converter.h
@@ -10,6 +10,7 @@
 #define LLVM_LIBC_SRC_STDIO_PRINTF_CORE_FLOAT_INF_NAN_CONVERTER_H
 
 #include "src/__support/FPUtil/FPBits.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
 #include "src/stdio/printf_core/core_structs.h"
@@ -23,11 +24,11 @@ namespace printf_core {
 
 using StorageType = fputil::FPBits<long double>::StorageType;
 
-LIBC_INLINE int convert_inf_nan(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_inf_nan(Writer<write_mode> *writer,
+                                const FormatSection &to_conv) {
   // All of the letters will be defined relative to variable a, which will be
   // the appropriate case based on the case of the conversion.
-  const char a = (to_conv.conv_name & 32) | 'A';
-
   bool is_negative;
   StorageType mantissa;
   if (to_conv.length_modifier == LengthModifier::L) {
@@ -66,9 +67,11 @@ LIBC_INLINE int convert_inf_nan(Writer *writer, const FormatSection &to_conv) {
   if (sign_char)
     RET_IF_RESULT_NEGATIVE(writer->write(sign_char));
   if (mantissa == 0) { // inf
-    RET_IF_RESULT_NEGATIVE(writer->write(a == 'a' ? "inf" : "INF"));
+    RET_IF_RESULT_NEGATIVE(
+        writer->write(internal::islower(to_conv.conv_name) ? "inf" : "INF"));
   } else { // nan
-    RET_IF_RESULT_NEGATIVE(writer->write(a == 'a' ? "nan" : "NAN"));
+    RET_IF_RESULT_NEGATIVE(
+        writer->write(internal::islower(to_conv.conv_name) ? "nan" : "NAN"));
   }
 
   if (padding > 0 && ((to_conv.flags & FormatFlags::LEFT_JUSTIFIED) ==
diff --git a/src/stdio/printf_core/int_converter.h b/src/stdio/printf_core/int_converter.h
index f345e86..11234c3 100644
--- a/src/stdio/printf_core/int_converter.h
+++ b/src/stdio/printf_core/int_converter.h
@@ -11,6 +11,7 @@
 
 #include "src/__support/CPP/span.h"
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/integer_to_string.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/printf_core/converter_utils.h"
@@ -23,11 +24,6 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-// These functions only work on characters that are already known to be in the
-// alphabet. Their behavior is undefined otherwise.
-LIBC_INLINE constexpr char to_lower(char a) { return a | 32; }
-LIBC_INLINE constexpr bool is_lower(char a) { return (a & 32) > 0; }
-
 namespace details {
 
 using HexFmt = IntegerToString<uintmax_t, radix::Hex>;
@@ -49,14 +45,14 @@ LIBC_INLINE constexpr size_t num_buf_size() {
 
 LIBC_INLINE cpp::optional<cpp::string_view>
 num_to_strview(uintmax_t num, cpp::span<char> bufref, char conv_name) {
-  if (to_lower(conv_name) == 'x') {
-    if (is_lower(conv_name))
+  if (internal::tolower(conv_name) == 'x') {
+    if (internal::islower(conv_name))
       return HexFmt::format_to(bufref, num);
     else
       return HexFmtUppercase::format_to(bufref, num);
   } else if (conv_name == 'o') {
     return OctFmt::format_to(bufref, num);
-  } else if (to_lower(conv_name) == 'b') {
+  } else if (internal::tolower(conv_name) == 'b') {
     return BinFmt::format_to(bufref, num);
   } else {
     return DecFmt::format_to(bufref, num);
@@ -65,14 +61,15 @@ num_to_strview(uintmax_t num, cpp::span<char> bufref, char conv_name) {
 
 } // namespace details
 
-LIBC_INLINE int convert_int(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_int(Writer<write_mode> *writer,
+                            const FormatSection &to_conv) {
   static constexpr size_t BITS_IN_BYTE = 8;
   static constexpr size_t BITS_IN_NUM = sizeof(uintmax_t) * BITS_IN_BYTE;
 
   uintmax_t num = static_cast<uintmax_t>(to_conv.conv_val_raw);
   bool is_negative = false;
   FormatFlags flags = to_conv.flags;
-  const char a = is_lower(to_conv.conv_name) ? 'a' : 'A';
 
   // If the conversion is signed, then handle negative values.
   if (to_conv.conv_name == 'd' || to_conv.conv_name == 'i') {
@@ -116,16 +113,16 @@ LIBC_INLINE int convert_int(Writer *writer, const FormatSection &to_conv) {
   // conversions. Since hexadecimal is unsigned these will never conflict.
   size_t prefix_len;
   char prefix[2];
-  if ((to_lower(to_conv.conv_name) == 'x') &&
+  if ((internal::tolower(to_conv.conv_name) == 'x') &&
       ((flags & FormatFlags::ALTERNATE_FORM) != 0) && num != 0) {
     prefix_len = 2;
     prefix[0] = '0';
-    prefix[1] = a + ('x' - 'a');
-  } else if ((to_lower(to_conv.conv_name) == 'b') &&
+    prefix[1] = internal::islower(to_conv.conv_name) ? 'x' : 'X';
+  } else if ((internal::tolower(to_conv.conv_name) == 'b') &&
              ((flags & FormatFlags::ALTERNATE_FORM) != 0) && num != 0) {
     prefix_len = 2;
     prefix[0] = '0';
-    prefix[1] = a + ('b' - 'a');
+    prefix[1] = internal::islower(to_conv.conv_name) ? 'b' : 'B';
   } else {
     prefix_len = (sign_char == 0 ? 0 : 1);
     prefix[0] = sign_char;
diff --git a/src/stdio/printf_core/parser.h b/src/stdio/printf_core/parser.h
index acbbaa2..89556f1 100644
--- a/src/stdio/printf_core/parser.h
+++ b/src/stdio/printf_core/parser.h
@@ -57,7 +57,8 @@ template <typename T> using int_type_of_v = typename int_type_of<T>::type;
     if (!temp.has_value()) {                                                   \
       section.has_conv = false;                                                \
     } else {                                                                   \
-      dst = cpp::bit_cast<int_type_of_v<arg_type>>(temp.value());              \
+      dst = static_cast<decltype(dst)>(                                        \
+          cpp::bit_cast<int_type_of_v<arg_type>>(temp.value()));               \
     }                                                                          \
   }
 #else
@@ -130,7 +131,7 @@ public:
       } else if (internal::isdigit(str[cur_pos])) {
         auto result = internal::strtointeger<int>(str + cur_pos, 10);
         section.min_width = result.value;
-        cur_pos = cur_pos + result.parsed_len;
+        cur_pos = cur_pos + static_cast<size_t>(result.parsed_len);
       }
       if (section.min_width < 0) {
         section.min_width =
@@ -153,7 +154,7 @@ public:
         } else if (internal::isdigit(str[cur_pos])) {
           auto result = internal::strtointeger<int>(str + cur_pos, 10);
           section.precision = result.value;
-          cur_pos = cur_pos + result.parsed_len;
+          cur_pos = cur_pos + static_cast<size_t>(result.parsed_len);
         }
       }
 
@@ -265,7 +266,8 @@ public:
       case ('m'):
         // %m is an odd conversion in that it doesn't consume an argument, it
         // just takes the current value of errno as its argument.
-        section.conv_val_raw = static_cast<int>(libc_errno);
+        section.conv_val_raw =
+            static_cast<fputil::FPBits<double>::StorageType>(libc_errno);
         break;
 #endif // LIBC_COPT_PRINTF_DISABLE_STRERROR
 #ifndef LIBC_COPT_PRINTF_DISABLE_WRITE_INT
@@ -356,7 +358,7 @@ private:
       }
       if (internal::isdigit(str[*local_pos])) {
         const auto result = internal::strtointeger<int>(str + *local_pos, 10);
-        *local_pos += result.parsed_len;
+        *local_pos += static_cast<size_t>(result.parsed_len);
         return {lm, static_cast<size_t>(cpp::max(0, result.value))};
       }
       return {lm, 0};
@@ -405,10 +407,10 @@ private:
   LIBC_INLINE size_t parse_index(size_t *local_pos) {
     if (internal::isdigit(str[*local_pos])) {
       auto result = internal::strtointeger<int>(str + *local_pos, 10);
-      size_t index = result.value;
-      if (str[*local_pos + result.parsed_len] != '$')
+      size_t index = static_cast<size_t>(result.value);
+      if (str[*local_pos + static_cast<size_t>(result.parsed_len)] != '$')
         return 0;
-      *local_pos = 1 + result.parsed_len + *local_pos;
+      *local_pos = static_cast<size_t>(1 + result.parsed_len) + *local_pos;
       return index;
     }
     return 0;
diff --git a/src/stdio/printf_core/printf_main.cpp b/src/stdio/printf_core/printf_main.cpp
deleted file mode 100644
index bd4a5a1..0000000
--- a/src/stdio/printf_core/printf_main.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-//===-- Starting point for printf -------------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/printf_core/printf_main.h"
-
-#include "src/__support/arg_list.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/printf_core/converter.h"
-#include "src/stdio/printf_core/core_structs.h"
-#include "src/stdio/printf_core/parser.h"
-#include "src/stdio/printf_core/writer.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace printf_core {
-
-int printf_main(Writer *writer, const char *__restrict str,
-                internal::ArgList &args) {
-  Parser<internal::ArgList> parser(str, args);
-  int result = 0;
-  for (FormatSection cur_section = parser.get_next_section();
-       !cur_section.raw_string.empty();
-       cur_section = parser.get_next_section()) {
-    if (cur_section.has_conv)
-      result = convert(writer, cur_section);
-    else
-      result = writer->write(cur_section.raw_string);
-
-    if (result < 0)
-      return result;
-  }
-
-  return writer->get_chars_written();
-}
-
-} // namespace printf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/printf_main.h b/src/stdio/printf_core/printf_main.h
index 3e73bf3..57f2985 100644
--- a/src/stdio/printf_core/printf_main.h
+++ b/src/stdio/printf_core/printf_main.h
@@ -11,6 +11,9 @@
 
 #include "src/__support/arg_list.h"
 #include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/converter.h"
+#include "src/stdio/printf_core/core_structs.h"
+#include "src/stdio/printf_core/parser.h"
 #include "src/stdio/printf_core/writer.h"
 
 #include <stddef.h>
@@ -18,8 +21,25 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-int printf_main(Writer *writer, const char *__restrict str,
-                internal::ArgList &args);
+template <WriteMode write_mode>
+int printf_main(Writer<write_mode> *writer, const char *__restrict str,
+                internal::ArgList &args) {
+  Parser<internal::ArgList> parser(str, args);
+  int result = 0;
+  for (FormatSection cur_section = parser.get_next_section();
+       !cur_section.raw_string.empty();
+       cur_section = parser.get_next_section()) {
+    if (cur_section.has_conv)
+      result = convert(writer, cur_section);
+    else
+      result = writer->write(cur_section.raw_string);
+
+    if (result < 0)
+      return result;
+  }
+
+  return writer->get_chars_written();
+}
 
 } // namespace printf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/ptr_converter.h b/src/stdio/printf_core/ptr_converter.h
index bf84718..c2a74e3 100644
--- a/src/stdio/printf_core/ptr_converter.h
+++ b/src/stdio/printf_core/ptr_converter.h
@@ -18,7 +18,9 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_pointer(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_pointer(Writer<write_mode> *writer,
+                                const FormatSection &to_conv) {
   FormatSection new_conv = to_conv;
 
   if (to_conv.conv_val_ptr == nullptr) {
diff --git a/src/stdio/printf_core/strerror_converter.h b/src/stdio/printf_core/strerror_converter.h
index 2902fd3..2cd6df0 100644
--- a/src/stdio/printf_core/strerror_converter.h
+++ b/src/stdio/printf_core/strerror_converter.h
@@ -19,7 +19,9 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_strerror(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_strerror(Writer<write_mode> *writer,
+                                 const FormatSection &to_conv) {
   FormatSection new_conv = to_conv;
   const int error_num = static_cast<int>(to_conv.conv_val_raw);
 
diff --git a/src/stdio/printf_core/string_converter.h b/src/stdio/printf_core/string_converter.h
index 1f36d51..74c9f59 100644
--- a/src/stdio/printf_core/string_converter.h
+++ b/src/stdio/printf_core/string_converter.h
@@ -20,7 +20,9 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_string(Writer *writer, const FormatSection &to_conv) {
+template <WriteMode write_mode>
+LIBC_INLINE int convert_string(Writer<write_mode> *writer,
+                               const FormatSection &to_conv) {
   size_t string_len = 0;
   const char *str_ptr = reinterpret_cast<const char *>(to_conv.conv_val_ptr);
 
diff --git a/src/stdio/printf_core/vasprintf_internal.h b/src/stdio/printf_core/vasprintf_internal.h
index 0e446f8..9d46617 100644
--- a/src/stdio/printf_core/vasprintf_internal.h
+++ b/src/stdio/printf_core/vasprintf_internal.h
@@ -19,8 +19,9 @@ namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
 LIBC_INLINE int resize_overflow_hook(cpp::string_view new_str, void *target) {
-  printf_core::WriteBuffer *wb =
-      reinterpret_cast<printf_core::WriteBuffer *>(target);
+  WriteBuffer<Mode<WriteMode::RESIZE_AND_FILL_BUFF>::value> *wb =
+      reinterpret_cast<
+          WriteBuffer<Mode<WriteMode::RESIZE_AND_FILL_BUFF>::value> *>(target);
   size_t new_size = new_str.size() + wb->buff_cur;
   const bool isBuffOnStack = (wb->buff == wb->init_buff);
   char *new_buff = static_cast<char *>(
@@ -45,9 +46,9 @@ constexpr size_t DEFAULT_BUFFER_SIZE = 200;
 LIBC_INLINE int vasprintf_internal(char **ret, const char *__restrict format,
                                    internal::ArgList args) {
   char init_buff_on_stack[DEFAULT_BUFFER_SIZE];
-  printf_core::WriteBuffer wb(init_buff_on_stack, DEFAULT_BUFFER_SIZE,
-                              resize_overflow_hook);
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<Mode<WriteMode::RESIZE_AND_FILL_BUFF>::value> wb(
+      init_buff_on_stack, DEFAULT_BUFFER_SIZE, resize_overflow_hook);
+  printf_core::Writer writer(wb);
 
   auto ret_val = printf_core::printf_main(&writer, format, args);
   if (ret_val < 0) {
diff --git a/src/stdio/printf_core/vfprintf_internal.h b/src/stdio/printf_core/vfprintf_internal.h
index 3becfee..630de9d 100644
--- a/src/stdio/printf_core/vfprintf_internal.h
+++ b/src/stdio/printf_core/vfprintf_internal.h
@@ -72,9 +72,9 @@ LIBC_INLINE int vfprintf_internal(::FILE *__restrict stream,
                                   internal::ArgList &args) {
   constexpr size_t BUFF_SIZE = 1024;
   char buffer[BUFF_SIZE];
-  printf_core::WriteBuffer wb(buffer, BUFF_SIZE, &file_write_hook,
-                              reinterpret_cast<void *>(stream));
-  Writer writer(&wb);
+  printf_core::WriteBuffer<Mode<WriteMode::FLUSH_TO_STREAM>::value> wb(
+      buffer, BUFF_SIZE, &file_write_hook, reinterpret_cast<void *>(stream));
+  Writer writer(wb);
   internal::flockfile(stream);
   int retval = printf_main(&writer, format, args);
   int flushval = wb.overflow_write("");
diff --git a/src/stdio/printf_core/write_int_converter.h b/src/stdio/printf_core/write_int_converter.h
index a47cb41..efcff27 100644
--- a/src/stdio/printf_core/write_int_converter.h
+++ b/src/stdio/printf_core/write_int_converter.h
@@ -19,7 +19,8 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-LIBC_INLINE int convert_write_int(Writer *writer,
+template <WriteMode write_mode>
+LIBC_INLINE int convert_write_int(Writer<write_mode> *writer,
                                   const FormatSection &to_conv) {
 
 #ifndef LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS
diff --git a/src/stdio/printf_core/writer.cpp b/src/stdio/printf_core/writer.cpp
deleted file mode 100644
index d1cf85d..0000000
--- a/src/stdio/printf_core/writer.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//===-- Writer definition for printf ----------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "writer.h"
-#include "src/__support/CPP/string_view.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/printf_core/core_structs.h"
-#include "src/string/memory_utils/inline_memset.h"
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace printf_core {
-
-int Writer::pad(char new_char, size_t length) {
-  // First, fill as much of the buffer as possible with the padding char.
-  size_t written = 0;
-  const size_t buff_space = wb->buff_len - wb->buff_cur;
-  // ASSERT: length > buff_space
-  if (buff_space > 0) {
-    inline_memset(wb->buff + wb->buff_cur, new_char, buff_space);
-    wb->buff_cur += buff_space;
-    written = buff_space;
-  }
-
-  // Next, overflow write the rest of length using the mini_buff.
-  constexpr size_t MINI_BUFF_SIZE = 64;
-  char mini_buff[MINI_BUFF_SIZE];
-  inline_memset(mini_buff, new_char, MINI_BUFF_SIZE);
-  cpp::string_view mb_string_view(mini_buff, MINI_BUFF_SIZE);
-  while (written + MINI_BUFF_SIZE < length) {
-    int result = wb->overflow_write(mb_string_view);
-    if (result != WRITE_OK)
-      return result;
-    written += MINI_BUFF_SIZE;
-  }
-  cpp::string_view mb_substr = mb_string_view.substr(0, length - written);
-  return wb->overflow_write(mb_substr);
-}
-
-} // namespace printf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/printf_core/writer.h b/src/stdio/printf_core/writer.h
index 5526a47..1d4734a 100644
--- a/src/stdio/printf_core/writer.h
+++ b/src/stdio/printf_core/writer.h
@@ -21,12 +21,24 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace printf_core {
 
-struct WriteBuffer {
-  enum class WriteMode {
-    FILL_BUFF_AND_DROP_OVERFLOW,
-    FLUSH_TO_STREAM,
-    RESIZE_AND_FILL_BUFF,
-  };
+enum class WriteMode {
+  FILL_BUFF_AND_DROP_OVERFLOW,
+  FLUSH_TO_STREAM,
+  RESIZE_AND_FILL_BUFF,
+  RUNTIME_DISPATCH,
+};
+
+// Helper to omit the template argument if we are using runtime dispatch and
+// avoid multiple copies of the converter functions.
+template <WriteMode write_mode> struct Mode {
+#ifdef LIBC_COPT_PRINTF_RUNTIME_DISPATCH
+  static constexpr WriteMode value = WriteMode::RUNTIME_DISPATCH;
+#else
+  static constexpr WriteMode value = write_mode;
+#endif
+};
+
+template <WriteMode write_mode> struct WriteBuffer {
   using StreamWriter = int (*)(cpp::string_view, void *);
   char *buff;
   const char *init_buff; // for checking when resize.
@@ -35,23 +47,26 @@ struct WriteBuffer {
 
   // The stream writer will be called when the buffer is full. It will be passed
   // string_views to write to the stream.
-  StreamWriter stream_writer;
+  const StreamWriter stream_writer;
   void *output_target;
-  WriteMode write_mode;
 
-  LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len, StreamWriter hook,
+  // The current writing mode in case the user wants runtime dispatch of the
+  // stream writer with function pointers.
+  [[maybe_unused]] WriteMode write_mode_;
+
+  LIBC_INLINE WriteBuffer(char *buff, size_t buff_len, StreamWriter hook,
                           void *target)
-      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(hook),
-        output_target(target), write_mode(WriteMode::FLUSH_TO_STREAM) {}
+      : buff(buff), init_buff(buff), buff_len(buff_len), stream_writer(hook),
+        output_target(target), write_mode_(WriteMode::FLUSH_TO_STREAM) {}
 
-  LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len)
-      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(nullptr),
+  LIBC_INLINE WriteBuffer(char *buff, size_t buff_len)
+      : buff(buff), init_buff(buff), buff_len(buff_len), stream_writer(nullptr),
         output_target(nullptr),
-        write_mode(WriteMode::FILL_BUFF_AND_DROP_OVERFLOW) {}
+        write_mode_(WriteMode::FILL_BUFF_AND_DROP_OVERFLOW) {}
 
-  LIBC_INLINE WriteBuffer(char *Buff, size_t Buff_len, StreamWriter hook)
-      : buff(Buff), init_buff(Buff), buff_len(Buff_len), stream_writer(hook),
-        output_target(this), write_mode(WriteMode::RESIZE_AND_FILL_BUFF) {}
+  LIBC_INLINE WriteBuffer(char *buff, size_t buff_len, StreamWriter hook)
+      : buff(buff), init_buff(buff), buff_len(buff_len), stream_writer(hook),
+        output_target(this), write_mode_(WriteMode::RESIZE_AND_FILL_BUFF) {}
 
   LIBC_INLINE int flush_to_stream(cpp::string_view new_str) {
     if (buff_cur > 0) {
@@ -92,40 +107,68 @@ struct WriteBuffer {
   // this with an empty string will flush the buffer if relevant.
 
   LIBC_INLINE int overflow_write(cpp::string_view new_str) {
-    switch (write_mode) {
-    case WriteMode::FILL_BUFF_AND_DROP_OVERFLOW:
+    if constexpr (write_mode == WriteMode::RUNTIME_DISPATCH) {
+      if (write_mode_ == WriteMode::FILL_BUFF_AND_DROP_OVERFLOW)
+        return fill_remaining_to_buff(new_str);
+      else if (write_mode_ == WriteMode::FLUSH_TO_STREAM)
+        return flush_to_stream(new_str);
+      else if (write_mode_ == WriteMode::RESIZE_AND_FILL_BUFF)
+        return resize_and_write(new_str);
+    } else if constexpr (write_mode == WriteMode::FILL_BUFF_AND_DROP_OVERFLOW) {
       return fill_remaining_to_buff(new_str);
-    case WriteMode::FLUSH_TO_STREAM:
+    } else if constexpr (write_mode == WriteMode::FLUSH_TO_STREAM) {
       return flush_to_stream(new_str);
-    case WriteMode::RESIZE_AND_FILL_BUFF:
+    } else if constexpr (write_mode == WriteMode::RESIZE_AND_FILL_BUFF) {
       return resize_and_write(new_str);
     }
     __builtin_unreachable();
   }
 };
 
-class Writer final {
-  WriteBuffer *wb;
+template <WriteMode write_mode> class Writer final {
+  WriteBuffer<write_mode> &wb;
   int chars_written = 0;
 
-  // This is a separate, non-inlined function so that the inlined part of the
-  // write function is shorter.
-  int pad(char new_char, size_t length);
+  LIBC_INLINE int pad(char new_char, size_t length) {
+    // First, fill as much of the buffer as possible with the padding char.
+    size_t written = 0;
+    const size_t buff_space = wb.buff_len - wb.buff_cur;
+    // ASSERT: length > buff_space
+    if (buff_space > 0) {
+      inline_memset(wb.buff + wb.buff_cur, new_char, buff_space);
+      wb.buff_cur += buff_space;
+      written = buff_space;
+    }
+
+    // Next, overflow write the rest of length using the mini_buff.
+    constexpr size_t MINI_BUFF_SIZE = 64;
+    char mini_buff[MINI_BUFF_SIZE];
+    inline_memset(mini_buff, new_char, MINI_BUFF_SIZE);
+    cpp::string_view mb_string_view(mini_buff, MINI_BUFF_SIZE);
+    while (written + MINI_BUFF_SIZE < length) {
+      int result = wb.overflow_write(mb_string_view);
+      if (result != WRITE_OK)
+        return result;
+      written += MINI_BUFF_SIZE;
+    }
+    cpp::string_view mb_substr = mb_string_view.substr(0, length - written);
+    return wb.overflow_write(mb_substr);
+  }
 
 public:
-  LIBC_INLINE Writer(WriteBuffer *WB) : wb(WB) {}
+  LIBC_INLINE Writer(WriteBuffer<write_mode> &wb) : wb(wb) {}
 
   // Takes a string, copies it into the buffer if there is space, else passes it
   // to the overflow mechanism to be handled separately.
   LIBC_INLINE int write(cpp::string_view new_string) {
     chars_written += static_cast<int>(new_string.size());
-    if (LIBC_LIKELY(wb->buff_cur + new_string.size() <= wb->buff_len)) {
-      inline_memcpy(wb->buff + wb->buff_cur, new_string.data(),
+    if (LIBC_LIKELY(wb.buff_cur + new_string.size() <= wb.buff_len)) {
+      inline_memcpy(wb.buff + wb.buff_cur, new_string.data(),
                     new_string.size());
-      wb->buff_cur += new_string.size();
+      wb.buff_cur += new_string.size();
       return WRITE_OK;
     }
-    return wb->overflow_write(new_string);
+    return wb.overflow_write(new_string);
   }
 
   // Takes a char and a length, memsets the next length characters of the buffer
@@ -134,9 +177,10 @@ public:
   LIBC_INLINE int write(char new_char, size_t length) {
     chars_written += static_cast<int>(length);
 
-    if (LIBC_LIKELY(wb->buff_cur + length <= wb->buff_len)) {
-      inline_memset(wb->buff + wb->buff_cur, new_char, length);
-      wb->buff_cur += length;
+    if (LIBC_LIKELY(wb.buff_cur + length <= wb.buff_len)) {
+      inline_memset(wb.buff + wb.buff_cur, static_cast<unsigned char>(new_char),
+                    length);
+      wb.buff_cur += length;
       return WRITE_OK;
     }
     return pad(new_char, length);
@@ -146,18 +190,26 @@ public:
   // to the overflow mechanism to be handled separately.
   LIBC_INLINE int write(char new_char) {
     chars_written += 1;
-    if (LIBC_LIKELY(wb->buff_cur + 1 <= wb->buff_len)) {
-      wb->buff[wb->buff_cur] = new_char;
-      wb->buff_cur += 1;
+    if (LIBC_LIKELY(wb.buff_cur + 1 <= wb.buff_len)) {
+      wb.buff[wb.buff_cur] = new_char;
+      wb.buff_cur += 1;
       return WRITE_OK;
     }
     cpp::string_view char_string_view(&new_char, 1);
-    return wb->overflow_write(char_string_view);
+    return wb.overflow_write(char_string_view);
   }
 
   LIBC_INLINE int get_chars_written() { return chars_written; }
 };
 
+// Class-template auto deduction helpers.
+Writer(WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>)
+    -> Writer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>;
+Writer(WriteBuffer<WriteMode::RESIZE_AND_FILL_BUFF>)
+    -> Writer<WriteMode::RESIZE_AND_FILL_BUFF>;
+Writer(WriteBuffer<WriteMode::FLUSH_TO_STREAM>)
+    -> Writer<WriteMode::FLUSH_TO_STREAM>;
+
 } // namespace printf_core
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/stdio/scanf_core/converter.cpp b/src/stdio/scanf_core/converter.cpp
deleted file mode 100644
index b1ee8cd..0000000
--- a/src/stdio/scanf_core/converter.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-//===-- Format specifier converter implmentation for scanf -----*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/converter.h"
-
-#include "src/__support/ctype_utils.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#ifndef LIBC_COPT_SCANF_DISABLE_FLOAT
-#include "src/stdio/scanf_core/float_converter.h"
-#endif // LIBC_COPT_SCANF_DISABLE_FLOAT
-#include "src/stdio/scanf_core/current_pos_converter.h"
-#include "src/stdio/scanf_core/int_converter.h"
-#include "src/stdio/scanf_core/ptr_converter.h"
-#include "src/stdio/scanf_core/string_converter.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-int convert(Reader *reader, const FormatSection &to_conv) {
-  int ret_val = 0;
-  switch (to_conv.conv_name) {
-  case '%':
-    return raw_match(reader, "%");
-  case 's':
-    ret_val = raw_match(reader, " ");
-    if (ret_val != READ_OK)
-      return ret_val;
-    return convert_string(reader, to_conv);
-  case 'c':
-  case '[':
-    return convert_string(reader, to_conv);
-  case 'd':
-  case 'i':
-  case 'u':
-  case 'o':
-  case 'x':
-  case 'X':
-    ret_val = raw_match(reader, " ");
-    if (ret_val != READ_OK)
-      return ret_val;
-    return convert_int(reader, to_conv);
-#ifndef LIBC_COPT_SCANF_DISABLE_FLOAT
-  case 'f':
-  case 'F':
-  case 'e':
-  case 'E':
-  case 'a':
-  case 'A':
-  case 'g':
-  case 'G':
-    ret_val = raw_match(reader, " ");
-    if (ret_val != READ_OK)
-      return ret_val;
-    return convert_float(reader, to_conv);
-#endif // LIBC_COPT_SCANF_DISABLE_FLOAT
-  case 'n':
-    return convert_current_pos(reader, to_conv);
-  case 'p':
-    ret_val = raw_match(reader, " ");
-    if (ret_val != READ_OK)
-      return ret_val;
-    return convert_pointer(reader, to_conv);
-  default:
-    return raw_match(reader, to_conv.raw_string);
-  }
-  return -1;
-}
-
-// raw_string is assumed to have a positive size.
-int raw_match(Reader *reader, cpp::string_view raw_string) {
-  char cur_char = reader->getc();
-  int ret_val = READ_OK;
-  for (size_t i = 0; i < raw_string.size(); ++i) {
-    // Any space character matches any number of space characters.
-    if (internal::isspace(raw_string[i])) {
-      while (internal::isspace(cur_char)) {
-        cur_char = reader->getc();
-      }
-    } else {
-      if (raw_string[i] == cur_char) {
-        cur_char = reader->getc();
-      } else {
-        ret_val = MATCHING_FAILURE;
-        break;
-      }
-    }
-  }
-  reader->ungetc(cur_char);
-  return ret_val;
-}
-
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/converter.h b/src/stdio/scanf_core/converter.h
index 3f514ee..3df43e9 100644
--- a/src/stdio/scanf_core/converter.h
+++ b/src/stdio/scanf_core/converter.h
@@ -10,10 +10,19 @@
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_CONVERTER_H
 
 #include "src/__support/CPP/string_view.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
+#ifndef LIBC_COPT_SCANF_DISABLE_FLOAT
+#include "src/stdio/scanf_core/float_converter.h"
+#endif // LIBC_COPT_SCANF_DISABLE_FLOAT
+#include "src/stdio/scanf_core/current_pos_converter.h"
+#include "src/stdio/scanf_core/int_converter.h"
+#include "src/stdio/scanf_core/ptr_converter.h"
+#include "src/stdio/scanf_core/string_converter.h"
+
 #include <stddef.h>
 
 namespace LIBC_NAMESPACE_DECL {
@@ -22,11 +31,81 @@ namespace scanf_core {
 // convert will call a conversion function to convert the FormatSection into
 // its string representation, and then that will write the result to the
 // reader.
-int convert(Reader *reader, const FormatSection &to_conv);
+template <typename T>
+int convert(Reader<T> *reader, const FormatSection &to_conv) {
+  int ret_val = 0;
+  switch (to_conv.conv_name) {
+  case '%':
+    return raw_match(reader, "%");
+  case 's':
+    ret_val = raw_match(reader, " ");
+    if (ret_val != READ_OK)
+      return ret_val;
+    return convert_string(reader, to_conv);
+  case 'c':
+  case '[':
+    return convert_string(reader, to_conv);
+  case 'd':
+  case 'i':
+  case 'u':
+  case 'o':
+  case 'x':
+  case 'X':
+    ret_val = raw_match(reader, " ");
+    if (ret_val != READ_OK)
+      return ret_val;
+    return convert_int(reader, to_conv);
+#ifndef LIBC_COPT_SCANF_DISABLE_FLOAT
+  case 'f':
+  case 'F':
+  case 'e':
+  case 'E':
+  case 'a':
+  case 'A':
+  case 'g':
+  case 'G':
+    ret_val = raw_match(reader, " ");
+    if (ret_val != READ_OK)
+      return ret_val;
+    return convert_float(reader, to_conv);
+#endif // LIBC_COPT_SCANF_DISABLE_FLOAT
+  case 'n':
+    return convert_current_pos(reader, to_conv);
+  case 'p':
+    ret_val = raw_match(reader, " ");
+    if (ret_val != READ_OK)
+      return ret_val;
+    return convert_pointer(reader, to_conv);
+  default:
+    return raw_match(reader, to_conv.raw_string);
+  }
+  return -1;
+}
 
 // raw_match takes a raw string and matches it to the characters obtained from
 // the reader.
-int raw_match(Reader *reader, cpp::string_view raw_string);
+template <typename T>
+int raw_match(Reader<T> *reader, cpp::string_view raw_string) {
+  char cur_char = reader->getc();
+  int ret_val = READ_OK;
+  for (size_t i = 0; i < raw_string.size(); ++i) {
+    // Any space character matches any number of space characters.
+    if (internal::isspace(raw_string[i])) {
+      while (internal::isspace(cur_char)) {
+        cur_char = reader->getc();
+      }
+    } else {
+      if (raw_string[i] == cur_char) {
+        cur_char = reader->getc();
+      } else {
+        ret_val = MATCHING_FAILURE;
+        break;
+      }
+    }
+  }
+  reader->ungetc(cur_char);
+  return ret_val;
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/converter_utils.h b/src/stdio/scanf_core/converter_utils.h
index 6195455..6f4d16c 100644
--- a/src/stdio/scanf_core/converter_utils.h
+++ b/src/stdio/scanf_core/converter_utils.h
@@ -19,16 +19,6 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-LIBC_INLINE constexpr char to_lower(char a) { return a | 32; }
-
-LIBC_INLINE constexpr int b36_char_to_int(char input) {
-  if (internal::isdigit(input))
-    return input - '0';
-  if (internal::isalpha(input))
-    return to_lower(input) + 10 - 'a';
-  return 0;
-}
-
 LIBC_INLINE void write_int_with_length(uintmax_t output_val,
                                        const FormatSection &to_conv) {
   if ((to_conv.flags & NO_WRITE) != 0) {
diff --git a/src/stdio/scanf_core/current_pos_converter.h b/src/stdio/scanf_core/current_pos_converter.h
index 8af1cc0..8708490 100644
--- a/src/stdio/scanf_core/current_pos_converter.h
+++ b/src/stdio/scanf_core/current_pos_converter.h
@@ -19,7 +19,8 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-LIBC_INLINE int convert_current_pos(Reader *reader,
+template <typename T>
+LIBC_INLINE int convert_current_pos(Reader<T> *reader,
                                     const FormatSection &to_conv) {
   write_int_with_length(reader->chars_read(), to_conv);
   return READ_OK;
diff --git a/src/stdio/scanf_core/float_converter.cpp b/src/stdio/scanf_core/float_converter.cpp
deleted file mode 100644
index b2d60a2..0000000
--- a/src/stdio/scanf_core/float_converter.cpp
+++ /dev/null
@@ -1,227 +0,0 @@
-//===-- Int type specifier converters for scanf -----------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/float_converter.h"
-
-#include "src/__support/CPP/limits.h"
-#include "src/__support/char_vector.h"
-#include "src/__support/ctype_utils.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/converter_utils.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-// All of the floating point conversions are the same for scanf, every name will
-// accept every style.
-int convert_float(Reader *reader, const FormatSection &to_conv) {
-  // %a/A/e/E/f/F/g/G "Matches an optionally signed floating-point number,
-  // infinity, or NaN, whose format is the same as expected for the subject
-  // sequence of the strtod function. The corresponding argument shall be a
-  // pointer to floating."
-
-  CharVector out_str = CharVector();
-  bool is_number = false;
-
-  size_t max_width = cpp::numeric_limits<size_t>::max();
-  if (to_conv.max_width > 0) {
-    max_width = to_conv.max_width;
-  }
-
-  char cur_char = reader->getc();
-  // Handle the sign.
-  if (cur_char == '+' || cur_char == '-') {
-    if (!out_str.append(cur_char)) {
-      return ALLOCATION_FAILURE;
-    }
-    if (out_str.length() == max_width) {
-      return MATCHING_FAILURE;
-    } else {
-      cur_char = reader->getc();
-    }
-  }
-
-  static constexpr char DECIMAL_POINT = '.';
-  static const char inf_string[] = "infinity";
-
-  // Handle inf
-
-  if (to_lower(cur_char) == inf_string[0]) {
-    size_t inf_index = 0;
-
-    for (; inf_index < sizeof(inf_string) && out_str.length() < max_width &&
-           to_lower(cur_char) == inf_string[inf_index];
-         ++inf_index) {
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      cur_char = reader->getc();
-    }
-
-    if (inf_index == 3 || inf_index == sizeof(inf_string) - 1) {
-      write_float_with_length(out_str.c_str(), to_conv);
-      return READ_OK;
-    } else {
-      return MATCHING_FAILURE;
-    }
-  }
-
-  static const char nan_string[] = "nan";
-
-  // Handle nan
-  if (to_lower(cur_char) == nan_string[0]) {
-    size_t nan_index = 0;
-
-    for (; nan_index < sizeof(nan_string) && out_str.length() < max_width &&
-           to_lower(cur_char) == nan_string[nan_index];
-         ++nan_index) {
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      cur_char = reader->getc();
-    }
-
-    if (nan_index == sizeof(nan_string) - 1) {
-      write_float_with_length(out_str.c_str(), to_conv);
-      return READ_OK;
-    } else {
-      return MATCHING_FAILURE;
-    }
-  }
-
-  // Assume base of 10 by default but check if it is actually base 16.
-  int base = 10;
-
-  // If the string starts with 0 it might be in hex.
-  if (cur_char == '0') {
-    is_number = true;
-    // Read the next character to check.
-    if (!out_str.append(cur_char)) {
-      return ALLOCATION_FAILURE;
-    }
-    // If we've hit the end, then this is "0", which is valid.
-    if (out_str.length() == max_width) {
-      write_float_with_length(out_str.c_str(), to_conv);
-      return READ_OK;
-    } else {
-      cur_char = reader->getc();
-    }
-
-    // If that next character is an 'x' then this is a hexadecimal number.
-    if (to_lower(cur_char) == 'x') {
-      base = 16;
-
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      // If we've hit the end here, we have "0x" which is a valid prefix to a
-      // floating point number, and will be evaluated to 0.
-      if (out_str.length() == max_width) {
-        write_float_with_length(out_str.c_str(), to_conv);
-        return READ_OK;
-      } else {
-        cur_char = reader->getc();
-      }
-    }
-  }
-
-  const char exponent_mark = ((base == 10) ? 'e' : 'p');
-  bool after_decimal = false;
-
-  // The format for the remaining characters at this point is DD.DDe+/-DD for
-  // base 10 and XX.XXp+/-DD for base 16
-
-  // This handles the digits before and after the decimal point, but not the
-  // exponent.
-  while (out_str.length() < max_width) {
-    if (internal::isalnum(cur_char) &&
-        internal::b36_char_to_int(cur_char) < base) {
-      is_number = true;
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      cur_char = reader->getc();
-    } else if (cur_char == DECIMAL_POINT && !after_decimal) {
-      after_decimal = true;
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      cur_char = reader->getc();
-    } else {
-      break;
-    }
-  }
-
-  // Handle the exponent, which has an exponent mark, an optional sign, and
-  // decimal digits.
-  if (to_lower(cur_char) == exponent_mark) {
-    if (!out_str.append(cur_char)) {
-      return ALLOCATION_FAILURE;
-    }
-    if (out_str.length() == max_width) {
-      // This is laid out in the standard as being a matching error (100e is not
-      // a valid float) but may conflict with existing implementations.
-      return MATCHING_FAILURE;
-    } else {
-      cur_char = reader->getc();
-    }
-
-    if (cur_char == '+' || cur_char == '-') {
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      if (out_str.length() == max_width) {
-        return MATCHING_FAILURE;
-      } else {
-        cur_char = reader->getc();
-      }
-    }
-
-    // It is specified by the standard that "100er" is a matching failure since
-    // the longest prefix of a possibly valid floating-point number (which is
-    // "100e") is not a valid floating-point number. If there is an exponent
-    // mark then there must be a digit after it else the number is not valid.
-    // Some implementations will roll back two characters (to just "100") and
-    // accept that since the prefix is not valid, and some will interpret an
-    // exponent mark followed by no digits as an additional exponent of 0
-    // (accepting "100e" and returning 100.0). Both of these behaviors are wrong
-    // by the standard, but they may be used in real code, see Hyrum's law. This
-    // code follows the standard, but may be incompatible due to code expecting
-    // these bugs.
-    if (!internal::isdigit(cur_char)) {
-      return MATCHING_FAILURE;
-    }
-
-    while (internal::isdigit(cur_char) && out_str.length() < max_width) {
-      if (!out_str.append(cur_char)) {
-        return ALLOCATION_FAILURE;
-      }
-      cur_char = reader->getc();
-    }
-  }
-
-  // We always read one more character than will be used, so we have to put the
-  // last one back.
-  reader->ungetc(cur_char);
-
-  // If we haven't actually found any digits, this is a matching failure (this
-  // catches cases like "+.")
-  if (!is_number) {
-    return MATCHING_FAILURE;
-  }
-  write_float_with_length(out_str.c_str(), to_conv);
-
-  return READ_OK;
-}
-
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/float_converter.h b/src/stdio/scanf_core/float_converter.h
index bd44847..6bbba37 100644
--- a/src/stdio/scanf_core/float_converter.h
+++ b/src/stdio/scanf_core/float_converter.h
@@ -9,7 +9,11 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_FLOAT_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_FLOAT_CONVERTER_H
 
+#include "src/__support/CPP/limits.h"
+#include "src/__support/char_vector.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
@@ -18,7 +22,210 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-int convert_float(Reader *reader, const FormatSection &to_conv);
+// All of the floating point conversions are the same for scanf, every name will
+// accept every style.
+template <typename T>
+int convert_float(Reader<T> *reader, const FormatSection &to_conv) {
+  // %a/A/e/E/f/F/g/G "Matches an optionally signed floating-point number,
+  // infinity, or NaN, whose format is the same as expected for the subject
+  // sequence of the strtod function. The corresponding argument shall be a
+  // pointer to floating."
+
+  CharVector out_str = CharVector();
+  bool is_number = false;
+
+  size_t max_width = cpp::numeric_limits<size_t>::max();
+  if (to_conv.max_width > 0) {
+    max_width = to_conv.max_width;
+  }
+
+  char cur_char = reader->getc();
+  // Handle the sign.
+  if (cur_char == '+' || cur_char == '-') {
+    if (!out_str.append(cur_char)) {
+      return ALLOCATION_FAILURE;
+    }
+    if (out_str.length() == max_width) {
+      return MATCHING_FAILURE;
+    } else {
+      cur_char = reader->getc();
+    }
+  }
+
+  static constexpr char DECIMAL_POINT = '.';
+  static const char inf_string[] = "infinity";
+
+  // Handle inf
+
+  if (internal::tolower(cur_char) == inf_string[0]) {
+    size_t inf_index = 0;
+
+    for (;
+         inf_index < (sizeof(inf_string) - 1) && out_str.length() < max_width &&
+         internal::tolower(cur_char) == inf_string[inf_index];
+         ++inf_index) {
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      cur_char = reader->getc();
+    }
+
+    if (inf_index == 3 || inf_index == sizeof(inf_string) - 1) {
+      write_float_with_length(out_str.c_str(), to_conv);
+      return READ_OK;
+    } else {
+      return MATCHING_FAILURE;
+    }
+  }
+
+  static const char nan_string[] = "nan";
+
+  // Handle nan
+  if (internal::tolower(cur_char) == nan_string[0]) {
+    size_t nan_index = 0;
+
+    for (;
+         nan_index < (sizeof(nan_string) - 1) && out_str.length() < max_width &&
+         internal::tolower(cur_char) == nan_string[nan_index];
+         ++nan_index) {
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      cur_char = reader->getc();
+    }
+
+    if (nan_index == sizeof(nan_string) - 1) {
+      write_float_with_length(out_str.c_str(), to_conv);
+      return READ_OK;
+    } else {
+      return MATCHING_FAILURE;
+    }
+  }
+
+  // Assume base of 10 by default but check if it is actually base 16.
+  int base = 10;
+
+  // If the string starts with 0 it might be in hex.
+  if (cur_char == '0') {
+    is_number = true;
+    // Read the next character to check.
+    if (!out_str.append(cur_char)) {
+      return ALLOCATION_FAILURE;
+    }
+    // If we've hit the end, then this is "0", which is valid.
+    if (out_str.length() == max_width) {
+      write_float_with_length(out_str.c_str(), to_conv);
+      return READ_OK;
+    } else {
+      cur_char = reader->getc();
+    }
+
+    // If that next character is an 'x' then this is a hexadecimal number.
+    if (internal::tolower(cur_char) == 'x') {
+      base = 16;
+
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      // If we've hit the end here, we have "0x" which is a valid prefix to a
+      // floating point number, and will be evaluated to 0.
+      if (out_str.length() == max_width) {
+        write_float_with_length(out_str.c_str(), to_conv);
+        return READ_OK;
+      } else {
+        cur_char = reader->getc();
+      }
+    }
+  }
+
+  const char exponent_mark = ((base == 10) ? 'e' : 'p');
+  bool after_decimal = false;
+
+  // The format for the remaining characters at this point is DD.DDe+/-DD for
+  // base 10 and XX.XXp+/-DD for base 16
+
+  // This handles the digits before and after the decimal point, but not the
+  // exponent.
+  while (out_str.length() < max_width) {
+    if (internal::isalnum(cur_char) &&
+        internal::b36_char_to_int(cur_char) < base) {
+      is_number = true;
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      cur_char = reader->getc();
+    } else if (cur_char == DECIMAL_POINT && !after_decimal) {
+      after_decimal = true;
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      cur_char = reader->getc();
+    } else {
+      break;
+    }
+  }
+
+  // Handle the exponent, which has an exponent mark, an optional sign, and
+  // decimal digits.
+  if (internal::tolower(cur_char) == exponent_mark) {
+    if (!out_str.append(cur_char)) {
+      return ALLOCATION_FAILURE;
+    }
+    if (out_str.length() == max_width) {
+      // This is laid out in the standard as being a matching error (100e is not
+      // a valid float) but may conflict with existing implementations.
+      return MATCHING_FAILURE;
+    } else {
+      cur_char = reader->getc();
+    }
+
+    if (cur_char == '+' || cur_char == '-') {
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      if (out_str.length() == max_width) {
+        return MATCHING_FAILURE;
+      } else {
+        cur_char = reader->getc();
+      }
+    }
+
+    // It is specified by the standard that "100er" is a matching failure since
+    // the longest prefix of a possibly valid floating-point number (which is
+    // "100e") is not a valid floating-point number. If there is an exponent
+    // mark then there must be a digit after it else the number is not valid.
+    // Some implementations will roll back two characters (to just "100") and
+    // accept that since the prefix is not valid, and some will interpret an
+    // exponent mark followed by no digits as an additional exponent of 0
+    // (accepting "100e" and returning 100.0). Both of these behaviors are wrong
+    // by the standard, but they may be used in real code, see Hyrum's law. This
+    // code follows the standard, but may be incompatible due to code expecting
+    // these bugs.
+    if (!internal::isdigit(cur_char)) {
+      return MATCHING_FAILURE;
+    }
+
+    while (internal::isdigit(cur_char) && out_str.length() < max_width) {
+      if (!out_str.append(cur_char)) {
+        return ALLOCATION_FAILURE;
+      }
+      cur_char = reader->getc();
+    }
+  }
+
+  // We always read one more character than will be used, so we have to put the
+  // last one back.
+  reader->ungetc(cur_char);
+
+  // If we haven't actually found any digits, this is a matching failure (this
+  // catches cases like "+.")
+  if (!is_number) {
+    return MATCHING_FAILURE;
+  }
+  write_float_with_length(out_str.c_str(), to_conv);
+
+  return READ_OK;
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/int_converter.cpp b/src/stdio/scanf_core/int_converter.cpp
deleted file mode 100644
index ecdac52..0000000
--- a/src/stdio/scanf_core/int_converter.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-//===-- Int type specifier converters for scanf -----------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/int_converter.h"
-
-#include "src/__support/CPP/limits.h"
-#include "src/__support/ctype_utils.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/converter_utils.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-// This code is very similar to the code in __support/str_to_integer.h but is
-// not quite the same. Here is the list of differences and why they exist:
-//  1) This takes a reader and a format section instead of a char* and the base.
-//      This should be fairly self explanatory. While the char* could be adapted
-//      to a reader and the base could be calculated ahead of time, the
-//      semantics are slightly different, specifically a char* can be indexed
-//      freely (I can read str[2] and then str[0]) whereas a File (which the
-//      reader may contain) cannot.
-//  2) Because this uses a Reader, this function can only unget once.
-//      This is relevant because scanf specifies it reads the "longest sequence
-//      of input characters which does not exceed any specified field width and
-//      which is, or is a prefix of, a matching input sequence." Whereas the
-//      strtol function accepts "the longest initial subsequence of the input
-//      string (...) that is of the expected form." This is demonstrated by the
-//      differences in how they deal with the string "0xZZZ" when parsing as
-//      hexadecimal. Scanf will read the "0x" as a valid prefix and return 0,
-//      since it reads the first 'Z', sees that it's not a valid hex digit, and
-//      reverses one character. The strtol function on the other hand only
-//      accepts the "0" since that's the longest valid hexadecimal sequence. It
-//      sees the 'Z' after the "0x" and determines that this is not the prefix
-//      to a valid hex string.
-//  3) This conversion may have a maximum width.
-//      If a maximum width is specified, this conversion is only allowed to
-//      accept a certain number of characters. Strtol doesn't have any such
-//      limitation.
-int convert_int(Reader *reader, const FormatSection &to_conv) {
-  // %d "Matches an optionally signed decimal integer [...] with the value 10
-  // for the base argument. The corresponding argument shall be a pointer to
-  // signed integer."
-
-  // %i "Matches an optionally signed integer [...] with the value 0 for the
-  // base argument. The corresponding argument shall be a pointer to signed
-  // integer."
-
-  // %u "Matches an optionally signed decimal integer [...] with the value 10
-  // for the base argument. The corresponding argument shall be a pointer to
-  // unsigned integer"
-
-  // %o "Matches an optionally signed octal integer [...] with the value 8 for
-  // the base argument. The corresponding argument shall be a pointer to
-  // unsigned integer"
-
-  // %x/X "Matches an optionally signed hexadecimal integer [...] with the value
-  // 16 for the base argument. The corresponding argument shall be a pointer to
-  // unsigned integer"
-
-  size_t max_width = cpp::numeric_limits<size_t>::max();
-  if (to_conv.max_width > 0) {
-    max_width = to_conv.max_width;
-  }
-
-  uintmax_t result = 0;
-  bool is_number = false;
-  bool is_signed = false;
-  int base = 0;
-  if (to_conv.conv_name == 'i') {
-    base = 0;
-    is_signed = true;
-  } else if (to_conv.conv_name == 'o') {
-    base = 8;
-  } else if (to_lower(to_conv.conv_name) == 'x' || to_conv.conv_name == 'p') {
-    base = 16;
-  } else if (to_conv.conv_name == 'd') {
-    base = 10;
-    is_signed = true;
-  } else { // conv_name must be 'u'
-    base = 10;
-  }
-
-  char cur_char = reader->getc();
-
-  char result_sign = '+';
-  if (cur_char == '+' || cur_char == '-') {
-    result_sign = cur_char;
-    if (max_width > 1) {
-      --max_width;
-      cur_char = reader->getc();
-    } else {
-      // If the max width has been hit already, then the return value must be 0
-      // since no actual digits of the number have been parsed yet.
-      write_int_with_length(0, to_conv);
-      return MATCHING_FAILURE;
-    }
-  }
-  const bool is_negative = result_sign == '-';
-
-  // Base of 0 means automatically determine the base. Base of 16 may have a
-  // prefix of "0x"
-  if (base == 0 || base == 16) {
-    // If the first character is 0, then it could be octal or hex.
-    if (cur_char == '0') {
-      is_number = true;
-
-      // Read the next character to check.
-      if (max_width > 1) {
-        --max_width;
-        cur_char = reader->getc();
-      } else {
-        write_int_with_length(0, to_conv);
-        return READ_OK;
-      }
-
-      if (to_lower(cur_char) == 'x') {
-        // This is a valid hex prefix.
-
-        is_number = false;
-        // A valid hex prefix is not necessarily a valid number. For the
-        // conversion to be valid it needs to use all of the characters it
-        // consumes. From the standard:
-        // 7.23.6.2 paragraph 9: "An input item is defined as the longest
-        // sequence of input characters which does not exceed any specified
-        // field width and which is, or is a prefix of, a matching input
-        // sequence."
-        // 7.23.6.2 paragraph 10: "If the input item is not a matching sequence,
-        // the execution of the directive fails: this condition is a matching
-        // failure"
-        base = 16;
-        if (max_width > 1) {
-          --max_width;
-          cur_char = reader->getc();
-        } else {
-          return MATCHING_FAILURE;
-        }
-
-      } else {
-        if (base == 0) {
-          base = 8;
-        }
-      }
-    } else if (base == 0) {
-      if (internal::isdigit(cur_char)) {
-        // If the first character is a different number, then it's 10.
-        base = 10;
-      } else {
-        // If the first character isn't a valid digit, then there are no valid
-        // digits at all. The number is 0.
-        reader->ungetc(cur_char);
-        write_int_with_length(0, to_conv);
-        return MATCHING_FAILURE;
-      }
-    }
-  }
-
-  constexpr uintmax_t UNSIGNED_MAX = cpp::numeric_limits<uintmax_t>::max();
-  constexpr uintmax_t SIGNED_MAX =
-      static_cast<uintmax_t>(cpp::numeric_limits<intmax_t>::max());
-  constexpr uintmax_t NEGATIVE_SIGNED_MAX =
-      static_cast<uintmax_t>(cpp::numeric_limits<intmax_t>::max()) + 1;
-
-  const uintmax_t MAX =
-      (is_signed ? (is_negative ? NEGATIVE_SIGNED_MAX : SIGNED_MAX)
-                 : UNSIGNED_MAX);
-
-  const uintmax_t max_div_by_base = MAX / base;
-
-  if (internal::isalnum(cur_char) && b36_char_to_int(cur_char) < base) {
-    is_number = true;
-  }
-
-  bool has_overflow = false;
-  size_t i = 0;
-  for (; i < max_width && internal::isalnum(cur_char) &&
-         b36_char_to_int(cur_char) < base;
-       ++i, cur_char = reader->getc()) {
-
-    uintmax_t cur_digit = b36_char_to_int(cur_char);
-
-    if (result == MAX) {
-      has_overflow = true;
-      continue;
-    } else if (result > max_div_by_base) {
-      result = MAX;
-      has_overflow = true;
-    } else {
-      result = result * base;
-    }
-
-    if (result > MAX - cur_digit) {
-      result = MAX;
-      has_overflow = true;
-    } else {
-      result = result + cur_digit;
-    }
-  }
-
-  // We always read one more character than will be used, so we have to put the
-  // last one back.
-  reader->ungetc(cur_char);
-
-  if (!is_number)
-    return MATCHING_FAILURE;
-
-  if (has_overflow) {
-    write_int_with_length(MAX, to_conv);
-  } else {
-    if (is_negative)
-      result = -result;
-
-    write_int_with_length(result, to_conv);
-  }
-
-  return READ_OK;
-}
-
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/int_converter.h b/src/stdio/scanf_core/int_converter.h
index 5fc27ad..35f11d6 100644
--- a/src/stdio/scanf_core/int_converter.h
+++ b/src/stdio/scanf_core/int_converter.h
@@ -9,7 +9,10 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_INT_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_INT_CONVERTER_H
 
+#include "src/__support/CPP/limits.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/converter_utils.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
 
@@ -18,7 +21,212 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-int convert_int(Reader *reader, const FormatSection &to_conv);
+// This code is very similar to the code in __support/str_to_integer.h but is
+// not quite the same. Here is the list of differences and why they exist:
+//  1) This takes a reader and a format section instead of a char* and the base.
+//      This should be fairly self explanatory. While the char* could be adapted
+//      to a reader and the base could be calculated ahead of time, the
+//      semantics are slightly different, specifically a char* can be indexed
+//      freely (I can read str[2] and then str[0]) whereas a File (which the
+//      reader may contain) cannot.
+//  2) Because this uses a Reader, this function can only unget once.
+//      This is relevant because scanf specifies it reads the "longest sequence
+//      of input characters which does not exceed any specified field width and
+//      which is, or is a prefix of, a matching input sequence." Whereas the
+//      strtol function accepts "the longest initial subsequence of the input
+//      string (...) that is of the expected form." This is demonstrated by the
+//      differences in how they deal with the string "0xZZZ" when parsing as
+//      hexadecimal. Scanf will read the "0x" as a valid prefix and return 0,
+//      since it reads the first 'Z', sees that it's not a valid hex digit, and
+//      reverses one character. The strtol function on the other hand only
+//      accepts the "0" since that's the longest valid hexadecimal sequence. It
+//      sees the 'Z' after the "0x" and determines that this is not the prefix
+//      to a valid hex string.
+//  3) This conversion may have a maximum width.
+//      If a maximum width is specified, this conversion is only allowed to
+//      accept a certain number of characters. Strtol doesn't have any such
+//      limitation.
+template <typename T>
+int convert_int(Reader<T> *reader, const FormatSection &to_conv) {
+  // %d "Matches an optionally signed decimal integer [...] with the value 10
+  // for the base argument. The corresponding argument shall be a pointer to
+  // signed integer."
+
+  // %i "Matches an optionally signed integer [...] with the value 0 for the
+  // base argument. The corresponding argument shall be a pointer to signed
+  // integer."
+
+  // %u "Matches an optionally signed decimal integer [...] with the value 10
+  // for the base argument. The corresponding argument shall be a pointer to
+  // unsigned integer"
+
+  // %o "Matches an optionally signed octal integer [...] with the value 8 for
+  // the base argument. The corresponding argument shall be a pointer to
+  // unsigned integer"
+
+  // %x/X "Matches an optionally signed hexadecimal integer [...] with the value
+  // 16 for the base argument. The corresponding argument shall be a pointer to
+  // unsigned integer"
+
+  size_t max_width = cpp::numeric_limits<size_t>::max();
+  if (to_conv.max_width > 0) {
+    max_width = to_conv.max_width;
+  }
+
+  uintmax_t result = 0;
+  bool is_number = false;
+  bool is_signed = false;
+  int base = 0;
+  if (to_conv.conv_name == 'i') {
+    base = 0;
+    is_signed = true;
+  } else if (to_conv.conv_name == 'o') {
+    base = 8;
+  } else if (internal::tolower(to_conv.conv_name) == 'x' ||
+             to_conv.conv_name == 'p') {
+    base = 16;
+  } else if (to_conv.conv_name == 'd') {
+    base = 10;
+    is_signed = true;
+  } else { // conv_name must be 'u'
+    base = 10;
+  }
+
+  char cur_char = reader->getc();
+
+  char result_sign = '+';
+  if (cur_char == '+' || cur_char == '-') {
+    result_sign = cur_char;
+    if (max_width > 1) {
+      --max_width;
+      cur_char = reader->getc();
+    } else {
+      // If the max width has been hit already, then the return value must be 0
+      // since no actual digits of the number have been parsed yet.
+      write_int_with_length(0, to_conv);
+      return MATCHING_FAILURE;
+    }
+  }
+  const bool is_negative = result_sign == '-';
+
+  // Base of 0 means automatically determine the base. Base of 16 may have a
+  // prefix of "0x"
+  if (base == 0 || base == 16) {
+    // If the first character is 0, then it could be octal or hex.
+    if (cur_char == '0') {
+      is_number = true;
+
+      // Read the next character to check.
+      if (max_width > 1) {
+        --max_width;
+        cur_char = reader->getc();
+      } else {
+        write_int_with_length(0, to_conv);
+        return READ_OK;
+      }
+
+      if (internal::tolower(cur_char) == 'x') {
+        // This is a valid hex prefix.
+
+        is_number = false;
+        // A valid hex prefix is not necessarily a valid number. For the
+        // conversion to be valid it needs to use all of the characters it
+        // consumes. From the standard:
+        // 7.23.6.2 paragraph 9: "An input item is defined as the longest
+        // sequence of input characters which does not exceed any specified
+        // field width and which is, or is a prefix of, a matching input
+        // sequence."
+        // 7.23.6.2 paragraph 10: "If the input item is not a matching sequence,
+        // the execution of the directive fails: this condition is a matching
+        // failure"
+        base = 16;
+        if (max_width > 1) {
+          --max_width;
+          cur_char = reader->getc();
+        } else {
+          return MATCHING_FAILURE;
+        }
+
+      } else {
+        if (base == 0) {
+          base = 8;
+        }
+      }
+    } else if (base == 0) {
+      if (internal::isdigit(cur_char)) {
+        // If the first character is a different number, then it's 10.
+        base = 10;
+      } else {
+        // If the first character isn't a valid digit, then there are no valid
+        // digits at all. The number is 0.
+        reader->ungetc(cur_char);
+        write_int_with_length(0, to_conv);
+        return MATCHING_FAILURE;
+      }
+    }
+  }
+
+  constexpr uintmax_t UNSIGNED_MAX = cpp::numeric_limits<uintmax_t>::max();
+  constexpr uintmax_t SIGNED_MAX =
+      static_cast<uintmax_t>(cpp::numeric_limits<intmax_t>::max());
+  constexpr uintmax_t NEGATIVE_SIGNED_MAX =
+      static_cast<uintmax_t>(cpp::numeric_limits<intmax_t>::max()) + 1;
+
+  const uintmax_t MAX =
+      (is_signed ? (is_negative ? NEGATIVE_SIGNED_MAX : SIGNED_MAX)
+                 : UNSIGNED_MAX);
+
+  const uintmax_t max_div_by_base = MAX / base;
+
+  if (internal::isalnum(cur_char) &&
+      internal::b36_char_to_int(cur_char) < base) {
+    is_number = true;
+  }
+
+  bool has_overflow = false;
+  size_t i = 0;
+  for (; i < max_width && internal::isalnum(cur_char) &&
+         internal::b36_char_to_int(cur_char) < base;
+       ++i, cur_char = reader->getc()) {
+
+    uintmax_t cur_digit = internal::b36_char_to_int(cur_char);
+
+    if (result == MAX) {
+      has_overflow = true;
+      continue;
+    } else if (result > max_div_by_base) {
+      result = MAX;
+      has_overflow = true;
+    } else {
+      result = result * base;
+    }
+
+    if (result > MAX - cur_digit) {
+      result = MAX;
+      has_overflow = true;
+    } else {
+      result = result + cur_digit;
+    }
+  }
+
+  // We always read one more character than will be used, so we have to put the
+  // last one back.
+  reader->ungetc(cur_char);
+
+  if (!is_number)
+    return MATCHING_FAILURE;
+
+  if (has_overflow) {
+    write_int_with_length(MAX, to_conv);
+  } else {
+    if (is_negative)
+      result = -result;
+
+    write_int_with_length(result, to_conv);
+  }
+
+  return READ_OK;
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/parser.h b/src/stdio/scanf_core/parser.h
index 6cc5b30..1e2f26e 100644
--- a/src/stdio/scanf_core/parser.h
+++ b/src/stdio/scanf_core/parser.h
@@ -78,7 +78,7 @@ public:
       if (internal::isdigit(str[cur_pos])) {
         auto result = internal::strtointeger<int>(str + cur_pos, 10);
         section.max_width = result.value;
-        cur_pos = cur_pos + result.parsed_len;
+        cur_pos = cur_pos + static_cast<size_t>(result.parsed_len);
       }
 
       // TODO(michaelrj): add posix allocate flag support.
@@ -150,10 +150,11 @@ public:
             char b = str[cur_pos + 1];
             char start = (a < b ? a : b);
             char end = (a < b ? b : a);
-            scan_set.set_range(start, end);
+            scan_set.set_range(static_cast<size_t>(start),
+                               static_cast<size_t>(end));
             cur_pos += 2;
           } else {
-            scan_set.set(str[cur_pos]);
+            scan_set.set(static_cast<size_t>(str[cur_pos]));
             ++cur_pos;
           }
         }
@@ -237,10 +238,10 @@ private:
   LIBC_INLINE size_t parse_index(size_t *local_pos) {
     if (internal::isdigit(str[*local_pos])) {
       auto result = internal::strtointeger<int>(str + *local_pos, 10);
-      size_t index = result.value;
-      if (str[*local_pos + result.parsed_len] != '$')
+      size_t index = static_cast<size_t>(result.value);
+      if (str[*local_pos + static_cast<size_t>(result.parsed_len)] != '$')
         return 0;
-      *local_pos = 1 + result.parsed_len + *local_pos;
+      *local_pos = static_cast<size_t>(1 + result.parsed_len) + *local_pos;
       return index;
     }
     return 0;
diff --git a/src/stdio/scanf_core/ptr_converter.cpp b/src/stdio/scanf_core/ptr_converter.cpp
deleted file mode 100644
index 1a42a38..0000000
--- a/src/stdio/scanf_core/ptr_converter.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-//===-- Int type specifier converters for scanf -----------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/ptr_converter.h"
-
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/converter_utils.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/int_converter.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-int convert_pointer(Reader *reader, const FormatSection &to_conv) {
-  static const char nullptr_string[] = "(nullptr)";
-
-  // Check if it's exactly the nullptr string, if so then it's a nullptr.
-  char cur_char = reader->getc();
-  size_t i = 0;
-  for (; i < sizeof(nullptr_string) && to_lower(cur_char) == nullptr_string[i];
-       ++i) {
-    cur_char = reader->getc();
-  }
-  if (i == (sizeof(nullptr_string) - 1)) {
-    *reinterpret_cast<void **>(to_conv.output_ptr) = nullptr;
-    return READ_OK;
-  } else if (i > 0) {
-    return MATCHING_FAILURE;
-  }
-
-  reader->ungetc(cur_char);
-
-  // Else treat it as a hex int
-  return convert_int(reader, to_conv);
-}
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/ptr_converter.h b/src/stdio/scanf_core/ptr_converter.h
index 0732c1c..e74a17e 100644
--- a/src/stdio/scanf_core/ptr_converter.h
+++ b/src/stdio/scanf_core/ptr_converter.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_PTR_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_PTR_CONVERTER_H
 
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
+#include "src/stdio/scanf_core/int_converter.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
@@ -18,7 +20,30 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-int convert_pointer(Reader *reader, const FormatSection &to_conv);
+template <typename T>
+int convert_pointer(Reader<T> *reader, const FormatSection &to_conv) {
+  static const char nullptr_string[] = "(nullptr)";
+
+  // Check if it's exactly the nullptr string, if so then it's a nullptr.
+  char cur_char = reader->getc();
+  size_t i = 0;
+  for (; i < (sizeof(nullptr_string) - 1) &&
+         internal::tolower(cur_char) == nullptr_string[i];
+       ++i) {
+    cur_char = reader->getc();
+  }
+  if (i == (sizeof(nullptr_string) - 1)) {
+    *reinterpret_cast<void **>(to_conv.output_ptr) = nullptr;
+    return READ_OK;
+  } else if (i > 0) {
+    return MATCHING_FAILURE;
+  }
+
+  reader->ungetc(cur_char);
+
+  // Else treat it as a hex int
+  return convert_int(reader, to_conv);
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/reader.cpp b/src/stdio/scanf_core/reader.cpp
deleted file mode 100644
index ec1f5c0..0000000
--- a/src/stdio/scanf_core/reader.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-//===-- Reader definition for scanf -----------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/reader.h"
-#include "src/__support/macros/config.h"
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-void Reader::ungetc(char c) {
-  --cur_chars_read;
-  if (rb != nullptr && rb->buff_cur > 0) {
-    // While technically c should be written back to the buffer, in scanf we
-    // always write the character that was already there. Additionally, the
-    // buffer is most likely to contain a string that isn't part of a file,
-    // which may not be writable.
-    --(rb->buff_cur);
-    return;
-  }
-  stream_ungetc(static_cast<int>(c), input_stream);
-}
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/reader.h b/src/stdio/scanf_core/reader.h
index f984fd9..c71446e 100644
--- a/src/stdio/scanf_core/reader.h
+++ b/src/stdio/scanf_core/reader.h
@@ -11,60 +11,30 @@
 
 #include "src/__support/macros/attributes.h" // For LIBC_INLINE
 #include "src/__support/macros/config.h"
+
 #include <stddef.h>
 
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-using StreamGetc = int (*)(void *);
-using StreamUngetc = void (*)(int, void *);
-
-// This is intended to be either a raw string or a buffer syncronized with the
-// file's internal buffer.
-struct ReadBuffer {
-  const char *buffer;
-  size_t buff_len;
-  size_t buff_cur = 0;
-};
-
-class Reader {
-  ReadBuffer *rb;
-
-  void *input_stream = nullptr;
-
-  // TODO: Remove these unnecessary function pointers
-  StreamGetc stream_getc = nullptr;
-  StreamUngetc stream_ungetc = nullptr;
-
+template <typename Derived> class Reader {
   size_t cur_chars_read = 0;
 
 public:
-  // TODO: Set buff_len with a proper constant
-  LIBC_INLINE Reader(ReadBuffer *string_buffer) : rb(string_buffer) {}
-
-  LIBC_INLINE Reader(void *stream, StreamGetc stream_getc_in,
-                     StreamUngetc stream_ungetc_in,
-                     ReadBuffer *stream_buffer = nullptr)
-      : rb(stream_buffer), input_stream(stream), stream_getc(stream_getc_in),
-        stream_ungetc(stream_ungetc_in) {}
-
   // This returns the next character from the input and advances it by one
   // character. When it hits the end of the string or file it returns '\0' to
   // signal to stop parsing.
   LIBC_INLINE char getc() {
     ++cur_chars_read;
-    if (rb != nullptr) {
-      char output = rb->buffer[rb->buff_cur];
-      ++(rb->buff_cur);
-      return output;
-    }
-    // This should reset the buffer if applicable.
-    return static_cast<char>(stream_getc(input_stream));
+    return static_cast<Derived *>(this)->getc();
   }
 
   // This moves the input back by one character, placing c into the buffer if
   // this is a file reader, else c is ignored.
-  void ungetc(char c);
+  LIBC_INLINE void ungetc(int c) {
+    --cur_chars_read;
+    static_cast<Derived *>(this)->ungetc(c);
+  }
 
   LIBC_INLINE size_t chars_read() { return cur_chars_read; }
 };
diff --git a/src/stdio/scanf_core/scanf_main.cpp b/src/stdio/scanf_core/scanf_main.cpp
deleted file mode 100644
index eb48094..0000000
--- a/src/stdio/scanf_core/scanf_main.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//===-- Starting point for scanf --------------------------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/scanf_main.h"
-
-#include "src/__support/arg_list.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/converter.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/parser.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-int scanf_main(Reader *reader, const char *__restrict str,
-               internal::ArgList &args) {
-  Parser<internal::ArgList> parser(str, args);
-  int ret_val = READ_OK;
-  int conversions = 0;
-  for (FormatSection cur_section = parser.get_next_section();
-       !cur_section.raw_string.empty() && ret_val == READ_OK;
-       cur_section = parser.get_next_section()) {
-    if (cur_section.has_conv) {
-      ret_val = convert(reader, cur_section);
-      // The %n (current position) conversion doesn't increment the number of
-      // assignments.
-      if (cur_section.conv_name != 'n')
-        conversions += ret_val == READ_OK ? 1 : 0;
-    } else {
-      ret_val = raw_match(reader, cur_section.raw_string);
-    }
-  }
-
-  return conversions;
-}
-
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/scanf_main.h b/src/stdio/scanf_core/scanf_main.h
index 27c2469..f975d85 100644
--- a/src/stdio/scanf_core/scanf_main.h
+++ b/src/stdio/scanf_core/scanf_main.h
@@ -11,6 +11,9 @@
 
 #include "src/__support/arg_list.h"
 #include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/converter.h"
+#include "src/stdio/scanf_core/core_structs.h"
+#include "src/stdio/scanf_core/parser.h"
 #include "src/stdio/scanf_core/reader.h"
 
 #include <stddef.h>
@@ -18,8 +21,28 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-int scanf_main(Reader *reader, const char *__restrict str,
-               internal::ArgList &args);
+template <typename T>
+int scanf_main(Reader<T> *reader, const char *__restrict str,
+               internal::ArgList &args) {
+  Parser<internal::ArgList> parser(str, args);
+  int ret_val = READ_OK;
+  int conversions = 0;
+  for (FormatSection cur_section = parser.get_next_section();
+       !cur_section.raw_string.empty() && ret_val == READ_OK;
+       cur_section = parser.get_next_section()) {
+    if (cur_section.has_conv) {
+      ret_val = convert(reader, cur_section);
+      // The %n (current position) conversion doesn't increment the number of
+      // assignments.
+      if (cur_section.conv_name != 'n')
+        conversions += ret_val == READ_OK ? 1 : 0;
+    } else {
+      ret_val = raw_match(reader, cur_section.raw_string);
+    }
+  }
+
+  return conversions;
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/string_converter.cpp b/src/stdio/scanf_core/string_converter.cpp
deleted file mode 100644
index 0de2eee..0000000
--- a/src/stdio/scanf_core/string_converter.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-//===-- String type specifier converters for scanf --------------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/stdio/scanf_core/string_converter.h"
-
-#include "src/__support/CPP/limits.h"
-#include "src/__support/ctype_utils.h"
-#include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/reader.h"
-
-#include <stddef.h>
-
-namespace LIBC_NAMESPACE_DECL {
-namespace scanf_core {
-
-int convert_string(Reader *reader, const FormatSection &to_conv) {
-  // %s "Matches a sequence of non-white-space characters"
-
-  // %c "Matches a sequence of characters of exactly the number specified by the
-  // field width (1 if no field width is present in the directive)"
-
-  // %[ "Matches a nonempty sequence of characters from a set of expected
-  // characters (the scanset)."
-  size_t max_width = 0;
-  if (to_conv.max_width > 0) {
-    max_width = to_conv.max_width;
-  } else {
-    if (to_conv.conv_name == 'c') {
-      max_width = 1;
-    } else {
-      max_width = cpp::numeric_limits<size_t>::max();
-    }
-  }
-
-  char *output = reinterpret_cast<char *>(to_conv.output_ptr);
-
-  char cur_char = reader->getc();
-  size_t i = 0;
-  for (; i < max_width && cur_char != '\0'; ++i) {
-    // If this is %s and we've hit a space, or if this is %[] and we've found
-    // something not in the scanset.
-    if ((to_conv.conv_name == 's' && internal::isspace(cur_char)) ||
-        (to_conv.conv_name == '[' && !to_conv.scan_set.test(cur_char))) {
-      break;
-    }
-    // if the NO_WRITE flag is not set, write to the output.
-    if ((to_conv.flags & NO_WRITE) == 0)
-      output[i] = cur_char;
-    cur_char = reader->getc();
-  }
-
-  // We always read one more character than will be used, so we have to put the
-  // last one back.
-  reader->ungetc(cur_char);
-
-  // If this is %s or %[]
-  if (to_conv.conv_name != 'c' && (to_conv.flags & NO_WRITE) == 0) {
-    // Always null terminate the string. This may cause a write to the
-    // (max_width + 1) byte, which is correct. The max width describes the max
-    // number of characters read from the input string, and doesn't necessarily
-    // correspond to the output.
-    output[i] = '\0';
-  }
-
-  if (i == 0)
-    return MATCHING_FAILURE;
-  return READ_OK;
-}
-
-} // namespace scanf_core
-} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/string_converter.h b/src/stdio/scanf_core/string_converter.h
index 552dc22..3879f8c 100644
--- a/src/stdio/scanf_core/string_converter.h
+++ b/src/stdio/scanf_core/string_converter.h
@@ -9,6 +9,8 @@
 #ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_CONVERTER_H
 #define LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_CONVERTER_H
 
+#include "src/__support/CPP/limits.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "src/stdio/scanf_core/core_structs.h"
 #include "src/stdio/scanf_core/reader.h"
@@ -18,7 +20,60 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace scanf_core {
 
-int convert_string(Reader *reader, const FormatSection &to_conv);
+template <typename T>
+int convert_string(Reader<T> *reader, const FormatSection &to_conv) {
+  // %s "Matches a sequence of non-white-space characters"
+
+  // %c "Matches a sequence of characters of exactly the number specified by the
+  // field width (1 if no field width is present in the directive)"
+
+  // %[ "Matches a nonempty sequence of characters from a set of expected
+  // characters (the scanset)."
+  size_t max_width = 0;
+  if (to_conv.max_width > 0) {
+    max_width = to_conv.max_width;
+  } else {
+    if (to_conv.conv_name == 'c') {
+      max_width = 1;
+    } else {
+      max_width = cpp::numeric_limits<size_t>::max();
+    }
+  }
+
+  char *output = reinterpret_cast<char *>(to_conv.output_ptr);
+
+  char cur_char = reader->getc();
+  size_t i = 0;
+  for (; i < max_width && cur_char != '\0'; ++i) {
+    // If this is %s and we've hit a space, or if this is %[] and we've found
+    // something not in the scanset.
+    if ((to_conv.conv_name == 's' && internal::isspace(cur_char)) ||
+        (to_conv.conv_name == '[' && !to_conv.scan_set.test(cur_char))) {
+      break;
+    }
+    // if the NO_WRITE flag is not set, write to the output.
+    if ((to_conv.flags & NO_WRITE) == 0)
+      output[i] = cur_char;
+    cur_char = reader->getc();
+  }
+
+  // We always read one more character than will be used, so we have to put the
+  // last one back.
+  reader->ungetc(cur_char);
+
+  // If this is %s or %[]
+  if (to_conv.conv_name != 'c' && (to_conv.flags & NO_WRITE) == 0) {
+    // Always null terminate the string. This may cause a write to the
+    // (max_width + 1) byte, which is correct. The max width describes the max
+    // number of characters read from the input string, and doesn't necessarily
+    // correspond to the output.
+    output[i] = '\0';
+  }
+
+  if (i == 0)
+    return MATCHING_FAILURE;
+  return READ_OK;
+}
 
 } // namespace scanf_core
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdio/scanf_core/string_reader.h b/src/stdio/scanf_core/string_reader.h
new file mode 100644
index 0000000..95ca22d
--- /dev/null
+++ b/src/stdio/scanf_core/string_reader.h
@@ -0,0 +1,49 @@
+//===-- Reader definition for scanf -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_READER_H
+#define LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_READER_H
+
+#include "src/__support/macros/attributes.h" // For LIBC_INLINE
+#include "src/__support/macros/config.h"
+#include "src/stdio/scanf_core/reader.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace scanf_core {
+
+class StringReader : public Reader<StringReader> {
+  const char *buffer;
+  [[maybe_unused]] size_t buff_len;
+  size_t buff_cur = 0;
+
+public:
+  LIBC_INLINE StringReader(const char *buffer, size_t buff_len)
+      : buffer(buffer), buff_len(buff_len) {}
+
+  LIBC_INLINE char getc() {
+    char output = buffer[buff_cur];
+    ++buff_cur;
+    return output;
+  }
+  LIBC_INLINE void ungetc(int) {
+    if (buff_cur > 0) {
+      // While technically c should be written back to the buffer, in scanf we
+      // always write the character that was already there. Additionally, the
+      // buffer is most likely to contain a string that isn't part of a file,
+      // which may not be writable.
+      --buff_cur;
+    }
+  }
+};
+
+} // namespace scanf_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_SCANF_CORE_STRING_READER_H
diff --git a/src/stdio/scanf_core/vfscanf_internal.h b/src/stdio/scanf_core/vfscanf_internal.h
index 6712643..eabfbd4 100644
--- a/src/stdio/scanf_core/vfscanf_internal.h
+++ b/src/stdio/scanf_core/vfscanf_internal.h
@@ -38,15 +38,11 @@ LIBC_INLINE void flockfile(::FILE *) { return; }
 
 LIBC_INLINE void funlockfile(::FILE *) { return; }
 
-LIBC_INLINE int getc(void *f) {
-  return LIBC_NAMESPACE::getc(reinterpret_cast<::FILE *>(f));
-}
+LIBC_INLINE int ferror_unlocked(::FILE *f) { return LIBC_NAMESPACE::ferror(f); }
 
-LIBC_INLINE void ungetc(int c, void *f) {
-  LIBC_NAMESPACE::ungetc(c, reinterpret_cast<::FILE *>(f));
-}
+LIBC_INLINE int getc(::FILE *f) { return LIBC_NAMESPACE::getc(f); }
 
-LIBC_INLINE int ferror_unlocked(::FILE *f) { return LIBC_NAMESPACE::ferror(f); }
+LIBC_INLINE void ungetc(int c, ::FILE *f) { LIBC_NAMESPACE::ungetc(c, f); }
 
 #elif !defined(LIBC_COPT_STDIO_USE_SYSTEM_FILE)
 
@@ -58,7 +54,11 @@ LIBC_INLINE void funlockfile(FILE *f) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(f)->unlock();
 }
 
-LIBC_INLINE int getc(void *f) {
+LIBC_INLINE int ferror_unlocked(FILE *f) {
+  return reinterpret_cast<LIBC_NAMESPACE::File *>(f)->error_unlocked();
+}
+
+LIBC_INLINE int getc(FILE *f) {
   unsigned char c;
   auto result =
       reinterpret_cast<LIBC_NAMESPACE::File *>(f)->read_unlocked(&c, 1);
@@ -69,14 +69,10 @@ LIBC_INLINE int getc(void *f) {
   return c;
 }
 
-LIBC_INLINE void ungetc(int c, void *f) {
+LIBC_INLINE void ungetc(int c, FILE *f) {
   reinterpret_cast<LIBC_NAMESPACE::File *>(f)->ungetc_unlocked(c);
 }
 
-LIBC_INLINE int ferror_unlocked(FILE *f) {
-  return reinterpret_cast<LIBC_NAMESPACE::File *>(f)->error_unlocked();
-}
-
 #else // defined(LIBC_COPT_STDIO_USE_SYSTEM_FILE)
 
 // Since ungetc_unlocked isn't always available, we don't acquire the lock for
@@ -85,13 +81,11 @@ LIBC_INLINE void flockfile(::FILE *) { return; }
 
 LIBC_INLINE void funlockfile(::FILE *) { return; }
 
-LIBC_INLINE int getc(void *f) { return ::getc(reinterpret_cast<::FILE *>(f)); }
+LIBC_INLINE int ferror_unlocked(::FILE *f) { return ::ferror(f); }
 
-LIBC_INLINE void ungetc(int c, void *f) {
-  ::ungetc(c, reinterpret_cast<::FILE *>(f));
-}
+LIBC_INLINE int getc(::FILE *f) { return ::getc(f); }
 
-LIBC_INLINE int ferror_unlocked(::FILE *f) { return ::ferror(f); }
+LIBC_INLINE void ungetc(int c, ::FILE *f) { ::ungetc(c, f); }
 
 #endif // LIBC_COPT_STDIO_USE_SYSTEM_FILE
 
@@ -99,11 +93,25 @@ LIBC_INLINE int ferror_unlocked(::FILE *f) { return ::ferror(f); }
 
 namespace scanf_core {
 
+class StreamReader : public Reader<StreamReader> {
+  ::FILE *stream;
+
+public:
+  LIBC_INLINE StreamReader(::FILE *stream) : stream(stream) {}
+
+  LIBC_INLINE char getc() {
+    return static_cast<char>(internal::getc(static_cast<FILE *>(stream)));
+  }
+  LIBC_INLINE void ungetc(int c) {
+    internal::ungetc(c, static_cast<FILE *>(stream));
+  }
+};
+
 LIBC_INLINE int vfscanf_internal(::FILE *__restrict stream,
                                  const char *__restrict format,
                                  internal::ArgList &args) {
   internal::flockfile(stream);
-  scanf_core::Reader reader(stream, &internal::getc, internal::ungetc);
+  scanf_core::StreamReader reader(stream);
   int retval = scanf_core::scanf_main(&reader, format, args);
   if (retval == 0 && internal::ferror_unlocked(stream))
     retval = EOF;
diff --git a/src/stdio/snprintf.cpp b/src/stdio/snprintf.cpp
index 12ad3cd..c894086 100644
--- a/src/stdio/snprintf.cpp
+++ b/src/stdio/snprintf.cpp
@@ -27,8 +27,10 @@ LLVM_LIBC_FUNCTION(int, snprintf,
                                  // and pointer semantics, as well as handling
                                  // destruction automatically.
   va_end(vlist);
-  printf_core::WriteBuffer wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
+  printf_core::Writer writer(wb);
 
   int ret_val = printf_core::printf_main(&writer, format, args);
   if (buffsz > 0) // if the buffsz is 0 the buffer may be a null pointer.
diff --git a/src/stdio/sprintf.cpp b/src/stdio/sprintf.cpp
index 1f59e6b..7be97d3 100644
--- a/src/stdio/sprintf.cpp
+++ b/src/stdio/sprintf.cpp
@@ -28,8 +28,10 @@ LLVM_LIBC_FUNCTION(int, sprintf,
                                  // destruction automatically.
   va_end(vlist);
 
-  printf_core::WriteBuffer wb(buffer, cpp::numeric_limits<size_t>::max());
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<
+      printf_core::Mode<printf_core::WriteMode::RESIZE_AND_FILL_BUFF>::value>
+      wb(buffer, cpp::numeric_limits<size_t>::max());
+  printf_core::Writer writer(wb);
 
   int ret_val = printf_core::printf_main(&writer, format, args);
   wb.buff[wb.buff_cur] = '\0';
diff --git a/src/stdio/sscanf.cpp b/src/stdio/sscanf.cpp
index 82de8a2..9fa2ede 100644
--- a/src/stdio/sscanf.cpp
+++ b/src/stdio/sscanf.cpp
@@ -11,8 +11,8 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/arg_list.h"
 #include "src/__support/macros/config.h"
-#include "src/stdio/scanf_core/reader.h"
 #include "src/stdio/scanf_core/scanf_main.h"
+#include "src/stdio/scanf_core/string_reader.h"
 
 #include "hdr/stdio_macros.h"
 #include "hdr/types/FILE.h"
@@ -29,8 +29,7 @@ LLVM_LIBC_FUNCTION(int, sscanf,
                                  // and pointer semantics, as well as handling
                                  // destruction automatically.
   va_end(vlist);
-  scanf_core::ReadBuffer rb{buffer, cpp::numeric_limits<size_t>::max()};
-  scanf_core::Reader reader(&rb);
+  scanf_core::StringReader reader(buffer, cpp::numeric_limits<size_t>::max());
   int ret_val = scanf_core::scanf_main(&reader, format, args);
   // This is done to avoid including stdio.h in the internals. On most systems
   // EOF is -1, so this will be transformed into just "return ret_val".
diff --git a/src/stdio/vsnprintf.cpp b/src/stdio/vsnprintf.cpp
index a584c76..b07a249 100644
--- a/src/stdio/vsnprintf.cpp
+++ b/src/stdio/vsnprintf.cpp
@@ -24,8 +24,10 @@ LLVM_LIBC_FUNCTION(int, vsnprintf,
   internal::ArgList args(vlist); // This holder class allows for easier copying
                                  // and pointer semantics, as well as handling
                                  // destruction automatically.
-  printf_core::WriteBuffer wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
+  printf_core::Writer writer(wb);
 
   int ret_val = printf_core::printf_main(&writer, format, args);
   if (buffsz > 0) // if the buffsz is 0 the buffer may be a null pointer.
diff --git a/src/stdio/vsprintf.cpp b/src/stdio/vsprintf.cpp
index b3978a0..26d497b 100644
--- a/src/stdio/vsprintf.cpp
+++ b/src/stdio/vsprintf.cpp
@@ -25,8 +25,10 @@ LLVM_LIBC_FUNCTION(int, vsprintf,
                                  // and pointer semantics, as well as handling
                                  // destruction automatically.
 
-  printf_core::WriteBuffer wb(buffer, cpp::numeric_limits<size_t>::max());
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(buffer, cpp::numeric_limits<size_t>::max());
+  printf_core::Writer writer(wb);
 
   int ret_val = printf_core::printf_main(&writer, format, args);
   wb.buff[wb.buff_cur] = '\0';
diff --git a/src/stdio/vsscanf.cpp b/src/stdio/vsscanf.cpp
index f3f56bc..7c7240a 100644
--- a/src/stdio/vsscanf.cpp
+++ b/src/stdio/vsscanf.cpp
@@ -11,8 +11,8 @@
 #include "hdr/stdio_macros.h"
 #include "src/__support/CPP/limits.h"
 #include "src/__support/arg_list.h"
-#include "src/stdio/scanf_core/reader.h"
 #include "src/stdio/scanf_core/scanf_main.h"
+#include "src/stdio/scanf_core/string_reader.h"
 
 #include <stdarg.h>
 
@@ -21,9 +21,7 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(int, vsscanf,
                    (const char *buffer, const char *format, va_list vlist)) {
   internal::ArgList args(vlist);
-  scanf_core::ReadBuffer rb{const_cast<char *>(buffer),
-                            cpp::numeric_limits<size_t>::max()};
-  scanf_core::Reader reader(&rb);
+  scanf_core::StringReader reader(buffer, cpp::numeric_limits<size_t>::max());
   int ret_val = scanf_core::scanf_main(&reader, format, args);
   // This is done to avoid including stdio.h in the internals. On most systems
   // EOF is -1, so this will be transformed into just "return ret_val".
diff --git a/src/stdlib/a64l.cpp b/src/stdlib/a64l.cpp
new file mode 100644
index 0000000..84be2d2
--- /dev/null
+++ b/src/stdlib/a64l.cpp
@@ -0,0 +1,65 @@
+//===-- Implementation of a64l --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/a64l.h"
+#include "hdr/types/size_t.h"
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+// I'm not sure this should go in ctype_utils since the specific ordering of
+// base64 is so very implementation specific, and also this set is unusual.
+// Returns -1 on any char without a specified value.
+constexpr static int32_t b64_char_to_int(char ch) {
+  // from the standard: "The characters used to represent digits are '.' (dot)
+  // for 0, '/' for 1, '0' through '9' for [2,11], 'A' through 'Z' for [12,37],
+  // and 'a' through 'z' for [38,63]."
+  if (ch == '.')
+    return 0;
+  if (ch == '/')
+    return 1;
+
+  // handle the case of an unspecified char.
+  if (!internal::isalnum(ch))
+    return -1;
+
+  bool is_lower = internal::islower(ch);
+  // add 2 to account for '.' and '/', then b36_char_to_int is case insensitive
+  // so add case sensitivity back.
+  return internal::b36_char_to_int(ch) + 2 + (is_lower ? 26 : 0);
+}
+
+// This function takes a base 64 string and writes it to the low 32 bits of a
+// long.
+// TODO: use LIBC_ADD_NULL_CHECKS for checking if the input is a null pointer.
+LLVM_LIBC_FUNCTION(long, a64l, (const char *s)) {
+  // the standard says to only use up to 6 characters.
+  constexpr size_t MAX_LENGTH = 6;
+  int32_t result = 0;
+
+  for (size_t i = 0; i < MAX_LENGTH && s[i] != '\0'; ++i) {
+    int32_t cur_val = b64_char_to_int(s[i]);
+    // The standard says what happens on an unspecified character is undefined,
+    // here we treat it as the end of the string.
+    if (cur_val == -1)
+      break;
+
+    // the first digit is the least significant, so for each subsequent digit we
+    // shift it more. 6 bits since 2^6 = 64
+    result += (cur_val << (6 * i));
+  }
+
+  // standard says to sign extend from 32 bits.
+  return static_cast<long>(result);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/a64l.h b/src/stdlib/a64l.h
new file mode 100644
index 0000000..024be05
--- /dev/null
+++ b/src/stdlib/a64l.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for a64l --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_A64L_H
+#define LLVM_LIBC_SRC_STDLIB_A64L_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+long a64l(const char *s);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_A64L_H
diff --git a/src/stdlib/freelist_malloc.cpp b/src/stdlib/baremetal/aligned_alloc.cpp
similarity index 53%
rename from src/stdlib/freelist_malloc.cpp
rename to src/stdlib/baremetal/aligned_alloc.cpp
index fe56fad..e954871 100644
--- a/src/stdlib/freelist_malloc.cpp
+++ b/src/stdlib/baremetal/aligned_alloc.cpp
@@ -6,35 +6,14 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/stdlib/aligned_alloc.h"
 #include "src/__support/freelist_heap.h"
 #include "src/__support/macros/config.h"
-#include "src/stdlib/aligned_alloc.h"
-#include "src/stdlib/calloc.h"
-#include "src/stdlib/free.h"
-#include "src/stdlib/malloc.h"
-#include "src/stdlib/realloc.h"
 
 #include <stddef.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
-static LIBC_CONSTINIT FreeListHeap freelist_heap_symbols;
-FreeListHeap *freelist_heap = &freelist_heap_symbols;
-
-LLVM_LIBC_FUNCTION(void *, malloc, (size_t size)) {
-  return freelist_heap->allocate(size);
-}
-
-LLVM_LIBC_FUNCTION(void, free, (void *ptr)) { return freelist_heap->free(ptr); }
-
-LLVM_LIBC_FUNCTION(void *, calloc, (size_t num, size_t size)) {
-  return freelist_heap->calloc(num, size);
-}
-
-LLVM_LIBC_FUNCTION(void *, realloc, (void *ptr, size_t size)) {
-  return freelist_heap->realloc(ptr, size);
-}
-
 LLVM_LIBC_FUNCTION(void *, aligned_alloc, (size_t alignment, size_t size)) {
   return freelist_heap->aligned_allocate(alignment, size);
 }
diff --git a/src/stdlib/baremetal/calloc.cpp b/src/stdlib/baremetal/calloc.cpp
new file mode 100644
index 0000000..2b3b83c
--- /dev/null
+++ b/src/stdlib/baremetal/calloc.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation for freelist_malloc --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/calloc.h"
+#include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, calloc, (size_t num, size_t size)) {
+  return freelist_heap->calloc(num, size);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/baremetal/free.cpp b/src/stdlib/baremetal/free.cpp
new file mode 100644
index 0000000..1e25fe5
--- /dev/null
+++ b/src/stdlib/baremetal/free.cpp
@@ -0,0 +1,19 @@
+//===-- Implementation for freelist_malloc --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/free.h"
+#include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void, free, (void *ptr)) { return freelist_heap->free(ptr); }
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/baremetal/malloc.cpp b/src/stdlib/baremetal/malloc.cpp
new file mode 100644
index 0000000..a299282
--- /dev/null
+++ b/src/stdlib/baremetal/malloc.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation for freelist_malloc --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/malloc.h"
+#include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, malloc, (size_t size)) {
+  return freelist_heap->allocate(size);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/baremetal/realloc.cpp b/src/stdlib/baremetal/realloc.cpp
new file mode 100644
index 0000000..fb25c68
--- /dev/null
+++ b/src/stdlib/baremetal/realloc.cpp
@@ -0,0 +1,21 @@
+//===-- Implementation for freelist_malloc --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/realloc.h"
+#include "src/__support/freelist_heap.h"
+#include "src/__support/macros/config.h"
+
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(void *, realloc, (void *ptr, size_t size)) {
+  return freelist_heap->realloc(ptr, size);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/exit_handler.h b/src/stdlib/exit_handler.h
index 9720c54..e9d163d 100644
--- a/src/stdlib/exit_handler.h
+++ b/src/stdlib/exit_handler.h
@@ -48,7 +48,7 @@ LIBC_INLINE void stdc_at_exit_func(void *payload) {
 LIBC_INLINE void call_exit_callbacks(ExitCallbackList &callbacks) {
   handler_list_mtx.lock();
   while (!callbacks.empty()) {
-    AtExitUnit &unit = callbacks.back();
+    AtExitUnit unit = callbacks.back();
     callbacks.pop_back();
     handler_list_mtx.unlock();
     unit.callback(unit.payload);
diff --git a/src/stdlib/gpu/abort.cpp b/src/stdlib/gpu/abort.cpp
index 3a06fb3..8a7e783 100644
--- a/src/stdlib/gpu/abort.cpp
+++ b/src/stdlib/gpu/abort.cpp
@@ -17,7 +17,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(void, abort, ()) {
   // We want to first make sure the server is listening before we abort.
-  rpc::Client::Port port = rpc::client.open<RPC_ABORT>();
+  rpc::Client::Port port = rpc::client.open<LIBC_ABORT>();
   port.send_and_recv([](rpc::Buffer *, uint32_t) {},
                      [](rpc::Buffer *, uint32_t) {});
   port.send([&](rpc::Buffer *, uint32_t) {});
diff --git a/src/stdlib/gpu/free.cpp b/src/stdlib/gpu/free.cpp
index 1f0e9ec..6ef9d71 100644
--- a/src/stdlib/gpu/free.cpp
+++ b/src/stdlib/gpu/free.cpp
@@ -14,6 +14,10 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+// FIXME: For now we just default to the NVIDIA device allocator which is
+// always available on NVPTX targets. This will be implemented fully later.
+#ifndef LIBC_TARGET_ARCH_IS_NVPTX
 LLVM_LIBC_FUNCTION(void, free, (void *ptr)) { gpu::deallocate(ptr); }
+#endif
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/malloc.cpp b/src/stdlib/gpu/malloc.cpp
index 54f2d88..b5909cb 100644
--- a/src/stdlib/gpu/malloc.cpp
+++ b/src/stdlib/gpu/malloc.cpp
@@ -14,8 +14,12 @@
 
 namespace LIBC_NAMESPACE_DECL {
 
+// FIXME: For now we just default to the NVIDIA device allocator which is
+// always available on NVPTX targets. This will be implemented fully later.
+#ifndef LIBC_TARGET_ARCH_IS_NVPTX
 LLVM_LIBC_FUNCTION(void *, malloc, (size_t size)) {
   return gpu::allocate(size);
 }
+#endif
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/gpu/system.cpp b/src/stdlib/gpu/system.cpp
index 1890006..1677e60 100644
--- a/src/stdlib/gpu/system.cpp
+++ b/src/stdlib/gpu/system.cpp
@@ -17,7 +17,7 @@ namespace LIBC_NAMESPACE_DECL {
 
 LLVM_LIBC_FUNCTION(int, system, (const char *command)) {
   int ret;
-  rpc::Client::Port port = rpc::client.open<RPC_SYSTEM>();
+  rpc::Client::Port port = rpc::client.open<LIBC_SYSTEM>();
   port.send_n(command, internal::string_length(command) + 1);
   port.recv([&](rpc::Buffer *buffer, uint32_t) {
     ret = static_cast<int>(buffer->data[0]);
diff --git a/src/stdlib/heap_sort.h b/src/stdlib/heap_sort.h
index ccb9ec5..b969977 100644
--- a/src/stdlib/heap_sort.h
+++ b/src/stdlib/heap_sort.h
@@ -18,11 +18,12 @@ namespace internal {
 // A simple in-place heapsort implementation.
 // Follow the implementation in https://en.wikipedia.org/wiki/Heapsort.
 
-LIBC_INLINE void heap_sort(const Array &array) {
-  size_t end = array.size();
+template <typename A, typename F>
+LIBC_INLINE void heap_sort(const A &array, const F &is_less) {
+  size_t end = array.len();
   size_t start = end / 2;
 
-  auto left_child = [](size_t i) -> size_t { return 2 * i + 1; };
+  const auto left_child = [](size_t i) -> size_t { return 2 * i + 1; };
 
   while (end > 1) {
     if (start > 0) {
@@ -40,12 +41,11 @@ LIBC_INLINE void heap_sort(const Array &array) {
     while (left_child(root) < end) {
       size_t child = left_child(root);
       // If there are two children, set child to the greater.
-      if (child + 1 < end &&
-          array.elem_compare(child, array.get(child + 1)) < 0)
+      if ((child + 1 < end) && is_less(array.get(child), array.get(child + 1)))
         ++child;
 
       // If the root is less than the greater child
-      if (array.elem_compare(root, array.get(child)) >= 0)
+      if (!is_less(array.get(root), array.get(child)))
         break;
 
       // Swap the root with the greater child and continue sifting down.
diff --git a/src/stdlib/l64a.cpp b/src/stdlib/l64a.cpp
new file mode 100644
index 0000000..b5506c3
--- /dev/null
+++ b/src/stdlib/l64a.cpp
@@ -0,0 +1,64 @@
+//===-- Implementation of l64a --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/l64a.h"
+#include "hdr/types/size_t.h"
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/libc_assert.h"
+#include "src/__support/macros/config.h"
+
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+// the standard says to only use up to 6 characters. Null terminator is
+// unnecessary, but we'll add it for ease-of-use. Also going from 48 -> 56 bits
+// probably won't matter since it's likely 32-bit aligned anyways.
+constexpr size_t MAX_BASE64_LENGTH = 6;
+LIBC_THREAD_LOCAL char BASE64_BUFFER[MAX_BASE64_LENGTH + 1];
+
+constexpr static char b64_int_to_char(uint32_t num) {
+  // from the standard: "The characters used to represent digits are '.' (dot)
+  // for 0, '/' for 1, '0' through '9' for [2,11], 'A' through 'Z' for [12,37],
+  // and 'a' through 'z' for [38,63]."
+  LIBC_ASSERT(num < 64);
+  if (num == 0)
+    return '.';
+  if (num == 1)
+    return '/';
+  if (num < 38)
+    return static_cast<char>(
+        internal::toupper(internal::int_to_b36_char(num - 2)));
+
+  // this tolower is technically unnecessary, but it provides safety if we
+  // change the default behavior of int_to_b36_char. Also the compiler
+  // completely elides it so there's no performance penalty, see:
+  // https://godbolt.org/z/o5ennv7fc
+  return static_cast<char>(
+      internal::tolower(internal::int_to_b36_char(num - 2 - 26)));
+}
+
+// This function takes a long and converts the low 32 bits of it into at most 6
+// characters. It's returned as a pointer to a static buffer.
+LLVM_LIBC_FUNCTION(char *, l64a, (long value)) {
+  // static cast to uint32_t to get just the low 32 bits in a consistent way.
+  // The standard says negative values are undefined, so I'm just defining them
+  // to be treated as unsigned.
+  uint32_t cur_value = static_cast<uint32_t>(value);
+  for (size_t i = 0; i < MAX_BASE64_LENGTH; ++i) {
+    uint32_t cur_char = cur_value % 64;
+    BASE64_BUFFER[i] = b64_int_to_char(cur_char);
+    cur_value /= 64;
+  }
+
+  BASE64_BUFFER[MAX_BASE64_LENGTH] = '\0'; // force null termination.
+  return BASE64_BUFFER;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/l64a.h b/src/stdlib/l64a.h
new file mode 100644
index 0000000..be01f04
--- /dev/null
+++ b/src/stdlib/l64a.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for l64a --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_l64a_H
+#define LLVM_LIBC_SRC_STDLIB_l64a_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+char *l64a(long value);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_l64a_H
diff --git a/src/stdlib/qsort.cpp b/src/stdlib/qsort.cpp
index 65a63c2..0bf5fc7 100644
--- a/src/stdlib/qsort.cpp
+++ b/src/stdlib/qsort.cpp
@@ -18,14 +18,12 @@ namespace LIBC_NAMESPACE_DECL {
 LLVM_LIBC_FUNCTION(void, qsort,
                    (void *array, size_t array_size, size_t elem_size,
                     int (*compare)(const void *, const void *))) {
-  if (array == nullptr || array_size == 0 || elem_size == 0)
-    return;
-  internal::Comparator c(compare);
 
-  auto arr = internal::Array(reinterpret_cast<uint8_t *>(array), array_size,
-                             elem_size, c);
+  const auto is_less = [compare](const void *a, const void *b) -> bool {
+    return compare(a, b) < 0;
+  };
 
-  internal::sort(arr);
+  internal::unstable_sort(array, array_size, elem_size, is_less);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/qsort_data.h b/src/stdlib/qsort_data.h
index c529d55..aa6d9bb 100644
--- a/src/stdlib/qsort_data.h
+++ b/src/stdlib/qsort_data.h
@@ -17,91 +17,122 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
-using Compare = int(const void *, const void *);
-using CompareWithState = int(const void *, const void *, void *);
-
-enum class CompType { COMPARE, COMPARE_WITH_STATE };
-
-struct Comparator {
-  union {
-    Compare *comp_func;
-    CompareWithState *comp_func_r;
-  };
-  const CompType comp_type;
-
-  void *arg;
-
-  Comparator(Compare *func)
-      : comp_func(func), comp_type(CompType::COMPARE), arg(nullptr) {}
-
-  Comparator(CompareWithState *func, void *arg_val)
-      : comp_func_r(func), comp_type(CompType::COMPARE_WITH_STATE),
-        arg(arg_val) {}
-
-#if defined(__clang__)
-  // Recent upstream changes to -fsanitize=function find more instances of
-  // function type mismatches. One case is with the comparator passed to this
-  // class. Libraries will tend to pass comparators that take pointers to
-  // varying types while this comparator expects to accept const void pointers.
-  // Ideally those tools would pass a function that strictly accepts const
-  // void*s to avoid UB, or would use qsort_r to pass their own comparator.
-  [[clang::no_sanitize("function")]]
-#endif
-  int comp_vals(const void *a, const void *b) const {
-    if (comp_type == CompType::COMPARE) {
-      return comp_func(a, b);
-    } else {
-      return comp_func_r(a, b, arg);
+class ArrayGenericSize {
+  cpp::byte *array_base;
+  size_t array_len;
+  size_t elem_size;
+
+  LIBC_INLINE cpp::byte *get_internal(size_t i) const {
+    return array_base + (i * elem_size);
+  }
+
+public:
+  LIBC_INLINE ArrayGenericSize(void *a, size_t s, size_t e)
+      : array_base(reinterpret_cast<cpp::byte *>(a)), array_len(s),
+        elem_size(e) {}
+
+  static constexpr bool has_fixed_size() { return false; }
+
+  LIBC_INLINE void *get(size_t i) const { return get_internal(i); }
+
+  LIBC_INLINE void swap(size_t i, size_t j) const {
+    // It's possible to use 8 byte blocks with `uint64_t`, but that
+    // generates more machine code as the remainder loop gets
+    // unrolled, plus 4 byte operations are more likely to be
+    // efficient on a wider variety of hardware. On x86 LLVM tends
+    // to unroll the block loop again into 2 16 byte swaps per
+    // iteration which is another reason that 4 byte blocks yields
+    // good performance even for big types.
+    using block_t = uint32_t;
+    constexpr size_t BLOCK_SIZE = sizeof(block_t);
+
+    alignas(block_t) cpp::byte tmp_block[BLOCK_SIZE];
+
+    cpp::byte *elem_i = get_internal(i);
+    cpp::byte *elem_j = get_internal(j);
+
+    const size_t elem_size_rem = elem_size % BLOCK_SIZE;
+    const cpp::byte *elem_i_block_end = elem_i + (elem_size - elem_size_rem);
+
+    while (elem_i != elem_i_block_end) {
+      __builtin_memcpy(tmp_block, elem_i, BLOCK_SIZE);
+      __builtin_memcpy(elem_i, elem_j, BLOCK_SIZE);
+      __builtin_memcpy(elem_j, tmp_block, BLOCK_SIZE);
+
+      elem_i += BLOCK_SIZE;
+      elem_j += BLOCK_SIZE;
+    }
+
+    for (size_t n = 0; n < elem_size_rem; ++n) {
+      cpp::byte tmp = elem_i[n];
+      elem_i[n] = elem_j[n];
+      elem_j[n] = tmp;
     }
   }
+
+  LIBC_INLINE size_t len() const { return array_len; }
+
+  // Make an Array starting at index |i| and length |s|.
+  LIBC_INLINE ArrayGenericSize make_array(size_t i, size_t s) const {
+    return ArrayGenericSize(get_internal(i), s, elem_size);
+  }
+
+  // Reset this Array to point at a different interval of the same
+  // items starting at index |i|.
+  LIBC_INLINE void reset_bounds(size_t i, size_t s) {
+    array_base = get_internal(i);
+    array_len = s;
+  }
 };
 
-class Array {
-  uint8_t *array;
-  size_t array_size;
-  size_t elem_size;
-  Comparator compare;
+// Having a specialized Array type for sorting that knows at
+// compile-time what the size of the element is, allows for much more
+// efficient swapping and for cheaper offset calculations.
+template <size_t ELEM_SIZE> class ArrayFixedSize {
+  cpp::byte *array_base;
+  size_t array_len;
 
-public:
-  Array(uint8_t *a, size_t s, size_t e, Comparator c)
-      : array(a), array_size(s), elem_size(e), compare(c) {}
-
-  uint8_t *get(size_t i) const { return array + i * elem_size; }
-
-  void swap(size_t i, size_t j) const {
-    uint8_t *elem_i = get(i);
-    uint8_t *elem_j = get(j);
-    for (size_t b = 0; b < elem_size; ++b) {
-      uint8_t temp = elem_i[b];
-      elem_i[b] = elem_j[b];
-      elem_j[b] = temp;
-    }
+  LIBC_INLINE cpp::byte *get_internal(size_t i) const {
+    return array_base + (i * ELEM_SIZE);
   }
 
-  int elem_compare(size_t i, const uint8_t *other) const {
-    // An element must compare equal to itself so we don't need to consult the
-    // user provided comparator.
-    if (get(i) == other)
-      return 0;
-    return compare.comp_vals(get(i), other);
+public:
+  LIBC_INLINE ArrayFixedSize(void *a, size_t s)
+      : array_base(reinterpret_cast<cpp::byte *>(a)), array_len(s) {}
+
+  // Beware this function is used a heuristic for cheap to swap types, so
+  // instantiating `ArrayFixedSize` with `ELEM_SIZE > 100` is probably a bad
+  // idea perf wise.
+  static constexpr bool has_fixed_size() { return true; }
+
+  LIBC_INLINE void *get(size_t i) const { return get_internal(i); }
+
+  LIBC_INLINE void swap(size_t i, size_t j) const {
+    alignas(32) cpp::byte tmp[ELEM_SIZE];
+
+    cpp::byte *elem_i = get_internal(i);
+    cpp::byte *elem_j = get_internal(j);
+
+    __builtin_memcpy(tmp, elem_i, ELEM_SIZE);
+    __builtin_memmove(elem_i, elem_j, ELEM_SIZE);
+    __builtin_memcpy(elem_j, tmp, ELEM_SIZE);
   }
 
-  size_t size() const { return array_size; }
+  LIBC_INLINE size_t len() const { return array_len; }
 
-  // Make an Array starting at index |i| and size |s|.
-  LIBC_INLINE Array make_array(size_t i, size_t s) const {
-    return Array(get(i), s, elem_size, compare);
+  // Make an Array starting at index |i| and length |s|.
+  LIBC_INLINE ArrayFixedSize<ELEM_SIZE> make_array(size_t i, size_t s) const {
+    return ArrayFixedSize<ELEM_SIZE>(get_internal(i), s);
   }
 
-  // Reset this Array to point at a different interval of the same items.
-  LIBC_INLINE void reset_bounds(uint8_t *a, size_t s) {
-    array = a;
-    array_size = s;
+  // Reset this Array to point at a different interval of the same
+  // items starting at index |i|.
+  LIBC_INLINE void reset_bounds(size_t i, size_t s) {
+    array_base = get_internal(i);
+    array_len = s;
   }
 };
 
-using SortingRoutine = void(const Array &);
-
 } // namespace internal
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/stdlib/qsort_pivot.h b/src/stdlib/qsort_pivot.h
new file mode 100644
index 0000000..6507f95
--- /dev/null
+++ b/src/stdlib/qsort_pivot.h
@@ -0,0 +1,88 @@
+//===-- Implementation header for qsort utilities ---------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDLIB_QSORT_PIVOT_H
+#define LLVM_LIBC_SRC_STDLIB_QSORT_PIVOT_H
+
+#include "src/__support/macros/attributes.h"
+
+#include <stddef.h> // For size_t
+
+namespace LIBC_NAMESPACE_DECL {
+namespace internal {
+
+// Recursively select a pseudomedian if above this threshold.
+constexpr size_t PSEUDO_MEDIAN_REC_THRESHOLD = 64;
+
+// Selects a pivot from `array`. Algorithm taken from glidesort by Orson Peters.
+//
+// This chooses a pivot by sampling an adaptive amount of points, approximating
+// the quality of a median of sqrt(n) elements.
+template <typename A, typename F>
+LIBC_INLINE size_t choose_pivot(const A &array, const F &is_less) {
+  const size_t len = array.len();
+
+  if (len < 8) {
+    return 0;
+  }
+
+  const size_t len_div_8 = len / 8;
+
+  const size_t a = 0;             // [0, floor(n/8))
+  const size_t b = len_div_8 * 4; // [4*floor(n/8), 5*floor(n/8))
+  const size_t c = len_div_8 * 7; // [7*floor(n/8), 8*floor(n/8))
+
+  if (len < PSEUDO_MEDIAN_REC_THRESHOLD)
+    return median3(array, a, b, c, is_less);
+  else
+    return median3_rec(array, a, b, c, len_div_8, is_less);
+}
+
+// Calculates an approximate median of 3 elements from sections a, b, c, or
+// recursively from an approximation of each, if they're large enough. By
+// dividing the size of each section by 8 when recursing we have logarithmic
+// recursion depth and overall sample from f(n) = 3*f(n/8) -> f(n) =
+// O(n^(log(3)/log(8))) ~= O(n^0.528) elements.
+template <typename A, typename F>
+LIBC_INLINE size_t median3_rec(const A &array, size_t a, size_t b, size_t c,
+                               size_t n, const F &is_less) {
+  if (n * 8 >= PSEUDO_MEDIAN_REC_THRESHOLD) {
+    const size_t n8 = n / 8;
+    a = median3_rec(array, a, a + (n8 * 4), a + (n8 * 7), n8, is_less);
+    b = median3_rec(array, b, b + (n8 * 4), b + (n8 * 7), n8, is_less);
+    c = median3_rec(array, c, c + (n8 * 4), c + (n8 * 7), n8, is_less);
+  }
+  return median3(array, a, b, c, is_less);
+}
+
+/// Calculates the median of 3 elements.
+template <typename A, typename F>
+LIBC_INLINE size_t median3(const A &array, size_t a, size_t b, size_t c,
+                           const F &is_less) {
+  const void *a_ptr = array.get(a);
+  const void *b_ptr = array.get(b);
+  const void *c_ptr = array.get(c);
+
+  const bool x = is_less(a_ptr, b_ptr);
+  const bool y = is_less(a_ptr, c_ptr);
+  if (x == y) {
+    // If x=y=0 then b, c <= a. In this case we want to return max(b, c).
+    // If x=y=1 then a < b, c. In this case we want to return min(b, c).
+    // By toggling the outcome of b < c using XOR x we get this behavior.
+    const bool z = is_less(b_ptr, c_ptr);
+    return z ^ x ? c : b;
+  } else {
+    // Either c <= a < b or b <= a < c, thus a is our median.
+    return a;
+  }
+}
+
+} // namespace internal
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDLIB_QSORT_PIVOT_H
diff --git a/src/stdlib/qsort_r.cpp b/src/stdlib/qsort_r.cpp
index bf61a40..4e60998 100644
--- a/src/stdlib/qsort_r.cpp
+++ b/src/stdlib/qsort_r.cpp
@@ -19,13 +19,12 @@ LLVM_LIBC_FUNCTION(void, qsort_r,
                    (void *array, size_t array_size, size_t elem_size,
                     int (*compare)(const void *, const void *, void *),
                     void *arg)) {
-  if (array == nullptr || array_size == 0 || elem_size == 0)
-    return;
-  internal::Comparator c(compare, arg);
-  auto arr = internal::Array(reinterpret_cast<uint8_t *>(array), array_size,
-                             elem_size, c);
 
-  internal::sort(arr);
+  const auto is_less = [compare, arg](const void *a, const void *b) -> bool {
+    return compare(a, b, arg) < 0;
+  };
+
+  internal::unstable_sort(array, array_size, elem_size, is_less);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/qsort_util.h b/src/stdlib/qsort_util.h
index d42adde..7882b82 100644
--- a/src/stdlib/qsort_util.h
+++ b/src/stdlib/qsort_util.h
@@ -27,11 +27,48 @@
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
-#if LIBC_QSORT_IMPL == LIBC_QSORT_QUICK_SORT
-constexpr auto sort = quick_sort;
-#elif LIBC_QSORT_IMPL == LIBC_QSORT_HEAP_SORT
-constexpr auto sort = heap_sort;
-#endif
+template <bool USE_QUICKSORT, typename F>
+LIBC_INLINE void unstable_sort_impl(void *array, size_t array_len,
+                                    size_t elem_size, const F &is_less) {
+  if (array == nullptr || array_len == 0 || elem_size == 0)
+    return;
+
+  if constexpr (USE_QUICKSORT) {
+    switch (elem_size) {
+    case 4: {
+      auto arr_fixed_size = internal::ArrayFixedSize<4>(array, array_len);
+      quick_sort(arr_fixed_size, is_less);
+      return;
+    }
+    case 8: {
+      auto arr_fixed_size = internal::ArrayFixedSize<8>(array, array_len);
+      quick_sort(arr_fixed_size, is_less);
+      return;
+    }
+    case 16: {
+      auto arr_fixed_size = internal::ArrayFixedSize<16>(array, array_len);
+      quick_sort(arr_fixed_size, is_less);
+      return;
+    }
+    default:
+      auto arr_generic_size =
+          internal::ArrayGenericSize(array, array_len, elem_size);
+      quick_sort(arr_generic_size, is_less);
+      return;
+    }
+  } else {
+    auto arr_generic_size =
+        internal::ArrayGenericSize(array, array_len, elem_size);
+    heap_sort(arr_generic_size, is_less);
+  }
+}
+
+template <typename F>
+LIBC_INLINE void unstable_sort(void *array, size_t array_len, size_t elem_size,
+                               const F &is_less) {
+#define USE_QUICK_SORT ((LIBC_QSORT_IMPL) == (LIBC_QSORT_QUICK_SORT))
+  unstable_sort_impl<USE_QUICK_SORT, F>(array, array_len, elem_size, is_less);
+}
 
 } // namespace internal
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/stdlib/quick_sort.h b/src/stdlib/quick_sort.h
index 82b90a7..8ba0098 100644
--- a/src/stdlib/quick_sort.h
+++ b/src/stdlib/quick_sort.h
@@ -9,84 +9,177 @@
 #ifndef LLVM_LIBC_SRC_STDLIB_QUICK_SORT_H
 #define LLVM_LIBC_SRC_STDLIB_QUICK_SORT_H
 
-#include "src/__support/macros/attributes.h"
+#include "src/__support/CPP/bit.h"
+#include "src/__support/CPP/cstddef.h"
 #include "src/__support/macros/config.h"
-#include "src/stdlib/qsort_data.h"
+#include "src/stdlib/qsort_pivot.h"
 
 #include <stdint.h>
 
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
 
-// A simple quicksort implementation using the Hoare partition scheme.
-LIBC_INLINE size_t partition(const Array &array) {
-  const size_t array_size = array.size();
-  size_t pivot_index = array_size / 2;
-  uint8_t *pivot = array.get(pivot_index);
-  size_t i = 0;
-  size_t j = array_size - 1;
+// Branchless Lomuto partition based on the implementation by Lukas
+// Bergdoll and Orson Peters
+// https://github.com/Voultapher/sort-research-rs/blob/main/writeup/lomcyc_partition/text.md.
+// Simplified to avoid having to stack allocate.
+template <typename A, typename F>
+LIBC_INLINE size_t partition_lomuto_branchless(const A &array,
+                                               const void *pivot,
+                                               const F &is_less) {
+  const size_t array_len = array.len();
+
+  size_t left = 0;
+  size_t right = 0;
+
+  while (right < array_len) {
+    const bool right_is_lt = is_less(array.get(right), pivot);
+    array.swap(left, right);
+    left += static_cast<size_t>(right_is_lt);
+    right += 1;
+  }
+
+  return left;
+}
+
+// Optimized for large types that are expensive to move. Not optimized
+// for integers. It's possible to use a cyclic permutation here for
+// large types as done in ipnsort but the advantages of this are limited
+// as `is_less` is a small wrapper around a call to a function pointer
+// and won't incur much binary-size overhead. The other reason to use
+// cyclic permutation is to have more efficient swapping, but we don't
+// know the element size so this isn't applicable here either.
+template <typename A, typename F>
+LIBC_INLINE size_t partition_hoare_branchy(const A &array, const void *pivot,
+                                           const F &is_less) {
+  const size_t array_len = array.len();
+
+  size_t left = 0;
+  size_t right = array_len;
 
   while (true) {
-    int compare_i, compare_j;
-
-    while ((compare_i = array.elem_compare(i, pivot)) < 0)
-      ++i;
-    while ((compare_j = array.elem_compare(j, pivot)) > 0)
-      --j;
-
-    // At some point i will crossover j so we will definitely break out of
-    // this while loop.
-    if (i >= j)
-      return j + 1;
-
-    array.swap(i, j);
-
-    // The pivot itself might have got swapped so we will update the pivot.
-    if (i == pivot_index) {
-      pivot = array.get(j);
-      pivot_index = j;
-    } else if (j == pivot_index) {
-      pivot = array.get(i);
-      pivot_index = i;
+    while (left < right && is_less(array.get(left), pivot))
+      ++left;
+
+    while (true) {
+      --right;
+      if (left >= right || is_less(array.get(right), pivot)) {
+        break;
+      }
     }
 
-    if (compare_i == 0 && compare_j == 0) {
-      // If we do not move the pointers, we will end up with an
-      // infinite loop as i and j will be stuck without advancing.
-      ++i;
-      --j;
-    }
+    if (left >= right)
+      break;
+
+    array.swap(left, right);
+    ++left;
+  }
+
+  return left;
+}
+
+template <typename A, typename F>
+LIBC_INLINE size_t partition(const A &array, size_t pivot_index,
+                             const F &is_less) {
+  // Place the pivot at the beginning of the array.
+  if (pivot_index != 0) {
+    array.swap(0, pivot_index);
   }
+
+  const A array_without_pivot = array.make_array(1, array.len() - 1);
+  const void *pivot = array.get(0);
+
+  size_t num_lt;
+  if constexpr (A::has_fixed_size()) {
+    // Branchless Lomuto avoid branch misprediction penalties, but
+    // it also swaps more often which is only faster if the swap is a fast
+    // constant operation.
+    num_lt = partition_lomuto_branchless(array_without_pivot, pivot, is_less);
+  } else {
+    num_lt = partition_hoare_branchy(array_without_pivot, pivot, is_less);
+  }
+
+  // Place the pivot between the two partitions.
+  array.swap(0, num_lt);
+
+  return num_lt;
 }
 
-LIBC_INLINE void quick_sort(Array array) {
+template <typename A, typename F>
+LIBC_INLINE void quick_sort_impl(A &array, const void *ancestor_pivot,
+                                 size_t limit, const F &is_less) {
   while (true) {
-    const size_t array_size = array.size();
-    if (array_size <= 1)
+    const size_t array_len = array.len();
+    if (array_len <= 1)
       return;
-    size_t split_index = partition(array);
-    if (array_size == 2)
-      // The partition operation sorts the two element array.
+
+    // If too many bad pivot choices were made, simply fall back to
+    // heapsort in order to guarantee `O(N x log(N))` worst-case.
+    if (limit == 0) {
+      heap_sort(array, is_less);
       return;
+    }
 
-    // Make Arrays describing the two sublists that still need sorting.
-    Array left = array.make_array(0, split_index);
-    Array right = array.make_array(split_index, array.size() - split_index);
-
-    // Recurse to sort the smaller of the two, and then loop round within this
-    // function to sort the larger. This way, recursive call depth is bounded
-    // by log2 of the total array size, because every recursive call is sorting
-    // a list at most half the length of the one in its caller.
-    if (left.size() < right.size()) {
-      quick_sort(left);
-      array.reset_bounds(right.get(0), right.size());
-    } else {
-      quick_sort(right);
-      array.reset_bounds(left.get(0), left.size());
+    limit -= 1;
+
+    const size_t pivot_index = choose_pivot(array, is_less);
+
+    // If the chosen pivot is equal to the predecessor, then it's the smallest
+    // element in the slice. Partition the slice into elements equal to and
+    // elements greater than the pivot. This case is usually hit when the slice
+    // contains many duplicate elements.
+    if (ancestor_pivot) {
+      if (!is_less(ancestor_pivot, array.get(pivot_index))) {
+        const size_t num_lt =
+            partition(array, pivot_index,
+                      [is_less](const void *a, const void *b) -> bool {
+                        return !is_less(b, a);
+                      });
+
+        // Continue sorting elements greater than the pivot. We know that
+        // `num_lt` cont
+        array.reset_bounds(num_lt + 1, array.len() - (num_lt + 1));
+        ancestor_pivot = nullptr;
+        continue;
+      }
     }
+
+    size_t split_index = partition(array, pivot_index, is_less);
+
+    if (array_len == 2)
+      // The partition operation sorts the two element array.
+      return;
+
+    // Split the array into `left`, `pivot`, and `right`.
+    A left = array.make_array(0, split_index);
+    const void *pivot = array.get(split_index);
+    const size_t right_start = split_index + 1;
+    A right = array.make_array(right_start, array.len() - right_start);
+
+    // Recurse into the left side. We have a fixed recursion limit,
+    // testing shows no real benefit for recursing into the shorter
+    // side.
+    quick_sort_impl(left, ancestor_pivot, limit, is_less);
+
+    // Continue with the right side.
+    array = right;
+    ancestor_pivot = pivot;
   }
 }
 
+constexpr size_t ilog2(size_t n) {
+  return static_cast<size_t>(cpp::bit_width(n)) - 1;
+}
+
+template <typename A, typename F>
+LIBC_INLINE void quick_sort(A &array, const F &is_less) {
+  const void *ancestor_pivot = nullptr;
+  // Limit the number of imbalanced partitions to `2 * floor(log2(len))`.
+  // The binary OR by one is used to eliminate the zero-check in the logarithm.
+  const size_t limit = 2 * ilog2((array.len() | 1));
+  quick_sort_impl(array, ancestor_pivot, limit, is_less);
+}
+
 } // namespace internal
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/stdlib/str_from_util.h b/src/stdlib/str_from_util.h
index 7f54bdf..61e6ba2 100644
--- a/src/stdlib/str_from_util.h
+++ b/src/stdlib/str_from_util.h
@@ -104,8 +104,8 @@ printf_core::FormatSection parse_format_string(const char *__restrict format,
   return section;
 }
 
-template <typename T>
-int strfromfloat_convert(printf_core::Writer *writer,
+template <typename T, printf_core::WriteMode write_mode>
+int strfromfloat_convert(printf_core::Writer<write_mode> *writer,
                          const printf_core::FormatSection &section) {
   if (!section.has_conv)
     return writer->write(section.raw_string);
diff --git a/src/stdlib/strfromd.cpp b/src/stdlib/strfromd.cpp
index 4c51e4c..f51e6d4 100644
--- a/src/stdlib/strfromd.cpp
+++ b/src/stdlib/strfromd.cpp
@@ -19,8 +19,10 @@ LLVM_LIBC_FUNCTION(int, strfromd,
 
   printf_core::FormatSection section =
       internal::parse_format_string(format, fp);
-  printf_core::WriteBuffer wb(s, (n > 0 ? n - 1 : 0));
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(s, (n > 0 ? n - 1 : 0));
+  printf_core::Writer writer(wb);
 
   int result = 0;
   if (section.has_conv)
diff --git a/src/stdlib/strfromf.cpp b/src/stdlib/strfromf.cpp
index ea98a69..14dbfdb 100644
--- a/src/stdlib/strfromf.cpp
+++ b/src/stdlib/strfromf.cpp
@@ -19,8 +19,10 @@ LLVM_LIBC_FUNCTION(int, strfromf,
 
   printf_core::FormatSection section =
       internal::parse_format_string(format, fp);
-  printf_core::WriteBuffer wb(s, (n > 0 ? n - 1 : 0));
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(s, (n > 0 ? n - 1 : 0));
+  printf_core::Writer writer(wb);
 
   int result = 0;
   if (section.has_conv)
diff --git a/src/stdlib/strfroml.cpp b/src/stdlib/strfroml.cpp
index d5bee76..12f22a8 100644
--- a/src/stdlib/strfroml.cpp
+++ b/src/stdlib/strfroml.cpp
@@ -24,8 +24,10 @@ LLVM_LIBC_FUNCTION(int, strfroml,
   // the length modifier has to be set to LenghtModifier::L
   section.length_modifier = printf_core::LengthModifier::L;
 
-  printf_core::WriteBuffer wb(s, (n > 0 ? n - 1 : 0));
-  printf_core::Writer writer(&wb);
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(s, (n > 0 ? n - 1 : 0));
+  printf_core::Writer writer(wb);
 
   int result = 0;
   if (section.has_conv)
diff --git a/src/string/allocating_string_utils.h b/src/string/allocating_string_utils.h
index b3a8663..1dece51 100644
--- a/src/string/allocating_string_utils.h
+++ b/src/string/allocating_string_utils.h
@@ -11,7 +11,7 @@
 
 #include "src/__support/CPP/new.h"
 #include "src/__support/CPP/optional.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/inline_memcpy.h"
 #include "src/string/string_utils.h"
 
diff --git a/src/string/memory_utils/aarch64/inline_bcmp.h b/src/string/memory_utils/aarch64/inline_bcmp.h
index 9319641..e41ac20 100644
--- a/src/string/memory_utils/aarch64/inline_bcmp.h
+++ b/src/string/memory_utils/aarch64/inline_bcmp.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h"   // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h"       // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_generic.h"
diff --git a/src/string/memory_utils/aarch64/inline_memset.h b/src/string/memory_utils/aarch64/inline_memset.h
index a2c0553..efcbfd0 100644
--- a/src/string/memory_utils/aarch64/inline_memset.h
+++ b/src/string/memory_utils/aarch64/inline_memset.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_AARCH64_INLINE_MEMSET_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/op_aarch64.h"
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/generic/builtin.h b/src/string/memory_utils/generic/builtin.h
index 5670a4e..2b9ecc0 100644
--- a/src/string/memory_utils/generic/builtin.h
+++ b/src/string/memory_utils/generic/builtin.h
@@ -10,7 +10,7 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_GENERIC_BUILTIN_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
 
 #include <stddef.h> // size_t
diff --git a/src/string/memory_utils/generic/byte_per_byte.h b/src/string/memory_utils/generic/byte_per_byte.h
index 2aecf01..862aeec 100644
--- a/src/string/memory_utils/generic/byte_per_byte.h
+++ b/src/string/memory_utils/generic/byte_per_byte.h
@@ -38,7 +38,8 @@ inline_memmove_byte_per_byte(Ptr dst, CPtr src, size_t count) {
       dst[offset] = src[offset];
   } else {
     LIBC_LOOP_NOUNROLL
-    for (ptrdiff_t offset = count - 1; offset >= 0; --offset)
+    for (ptrdiff_t offset = static_cast<ptrdiff_t>(count - 1); offset >= 0;
+         --offset)
       dst[offset] = src[offset];
   }
 }
diff --git a/src/string/memory_utils/inline_bcmp.h b/src/string/memory_utils/inline_bcmp.h
index 14cf16e..3c1dc80 100644
--- a/src/string/memory_utils/inline_bcmp.h
+++ b/src/string/memory_utils/inline_bcmp.h
@@ -10,7 +10,8 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_BCMP_H
 
 #include "src/__support/common.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_
 
 #include <stddef.h> // size_t
@@ -24,11 +25,9 @@
 #elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #include "src/string/memory_utils/riscv/inline_bcmp.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_BCMP inline_bcmp_riscv
-#elif defined(LIBC_TARGET_ARCH_IS_ARM) || defined(LIBC_TARGET_ARCH_IS_GPU)
+#else
 #include "src/string/memory_utils/generic/byte_per_byte.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_BCMP inline_bcmp_byte_per_byte
-#else
-#error "Unsupported architecture"
 #endif
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_bzero.h b/src/string/memory_utils/inline_bzero.h
index 4a92e8b..a131b68 100644
--- a/src/string/memory_utils/inline_bzero.h
+++ b/src/string/memory_utils/inline_bzero.h
@@ -10,7 +10,8 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_BZERO_H
 
 #include "src/__support/common.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/inline_memset.h"
 
 #include <stddef.h> // size_t
diff --git a/src/string/memory_utils/inline_memcmp.h b/src/string/memory_utils/inline_memcmp.h
index cb7a07c..a2ca9af 100644
--- a/src/string/memory_utils/inline_memcmp.h
+++ b/src/string/memory_utils/inline_memcmp.h
@@ -24,11 +24,9 @@
 #elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #include "src/string/memory_utils/riscv/inline_memcmp.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMCMP inline_memcmp_riscv
-#elif defined(LIBC_TARGET_ARCH_IS_ARM) || defined(LIBC_TARGET_ARCH_IS_GPU)
+#else
 #include "src/string/memory_utils/generic/byte_per_byte.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMCMP inline_memcmp_byte_per_byte
-#else
-#error "Unsupported architecture"
 #endif
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_memcpy.h b/src/string/memory_utils/inline_memcpy.h
index 3e84397..f98e553 100644
--- a/src/string/memory_utils/inline_memcpy.h
+++ b/src/string/memory_utils/inline_memcpy.h
@@ -28,14 +28,12 @@
 #elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #include "src/string/memory_utils/riscv/inline_memcpy.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMCPY inline_memcpy_riscv
-#elif defined(LIBC_TARGET_ARCH_IS_ARM)
-#include "src/string/memory_utils/generic/byte_per_byte.h"
-#define LIBC_SRC_STRING_MEMORY_UTILS_MEMCPY inline_memcpy_byte_per_byte
 #elif defined(LIBC_TARGET_ARCH_IS_GPU)
 #include "src/string/memory_utils/generic/builtin.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMCPY inline_memcpy_builtin
 #else
-#error "Unsupported architecture"
+#include "src/string/memory_utils/generic/byte_per_byte.h"
+#define LIBC_SRC_STRING_MEMORY_UTILS_MEMCPY inline_memcpy_byte_per_byte
 #endif
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_memmem.h b/src/string/memory_utils/inline_memmem.h
index 15e3d63..1e9649c 100644
--- a/src/string/memory_utils/inline_memmem.h
+++ b/src/string/memory_utils/inline_memmem.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMEM_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMEM_H
 
-#include "src/__support/macros/attributes.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 
 #include <stddef.h>
 
diff --git a/src/string/memory_utils/inline_memmove.h b/src/string/memory_utils/inline_memmove.h
index 85d0159..71a28c3 100644
--- a/src/string/memory_utils/inline_memmove.h
+++ b/src/string/memory_utils/inline_memmove.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMOVE_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_MEMMOVE_H
 
-#include "src/__support/macros/config.h"
-#include <stddef.h> // size_t, ptrdiff_t
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
+#include <stddef.h>                          // size_t, ptrdiff_t
 
 #if defined(LIBC_TARGET_ARCH_IS_X86)
 #include "src/string/memory_utils/x86_64/inline_memmove.h"
@@ -28,19 +29,17 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_SMALL_SIZE                        \
   inline_memmove_no_small_size
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_FOLLOW_UP inline_memmove_riscv
-#elif defined(LIBC_TARGET_ARCH_IS_ARM)
-#include "src/string/memory_utils/generic/byte_per_byte.h"
-#define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_SMALL_SIZE                        \
-  inline_memmove_no_small_size
-#define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_FOLLOW_UP                         \
-  inline_memmove_byte_per_byte
 #elif defined(LIBC_TARGET_ARCH_IS_GPU)
 #include "src/string/memory_utils/generic/builtin.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_SMALL_SIZE                        \
   inline_memmove_no_small_size
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_FOLLOW_UP inline_memmove_builtin
 #else
-#error "Unsupported architecture"
+#include "src/string/memory_utils/generic/byte_per_byte.h"
+#define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_SMALL_SIZE                        \
+  inline_memmove_no_small_size
+#define LIBC_SRC_STRING_MEMORY_UTILS_MEMMOVE_FOLLOW_UP                         \
+  inline_memmove_byte_per_byte
 #endif
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_memset.h b/src/string/memory_utils/inline_memset.h
index 0206a02..aed3707 100644
--- a/src/string/memory_utils/inline_memset.h
+++ b/src/string/memory_utils/inline_memset.h
@@ -24,14 +24,12 @@
 #elif defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
 #include "src/string/memory_utils/riscv/inline_memset.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMSET inline_memset_riscv
-#elif defined(LIBC_TARGET_ARCH_IS_ARM)
-#include "src/string/memory_utils/generic/byte_per_byte.h"
-#define LIBC_SRC_STRING_MEMORY_UTILS_MEMSET inline_memset_byte_per_byte
 #elif defined(LIBC_TARGET_ARCH_IS_GPU)
 #include "src/string/memory_utils/generic/builtin.h"
 #define LIBC_SRC_STRING_MEMORY_UTILS_MEMSET inline_memset_builtin
 #else
-#error "Unsupported architecture"
+#include "src/string/memory_utils/generic/byte_per_byte.h"
+#define LIBC_SRC_STRING_MEMORY_UTILS_MEMSET inline_memset_byte_per_byte
 #endif
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_strcmp.h b/src/string/memory_utils/inline_strcmp.h
index 281d5b1..6758e79 100644
--- a/src/string/memory_utils/inline_strcmp.h
+++ b/src/string/memory_utils/inline_strcmp.h
@@ -9,7 +9,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRCMP_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRCMP_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include <stddef.h>
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/inline_strstr.h b/src/string/memory_utils/inline_strstr.h
index 9c99e92..5495cc4 100644
--- a/src/string/memory_utils/inline_strstr.h
+++ b/src/string/memory_utils/inline_strstr.h
@@ -9,7 +9,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRSTR_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_INLINE_STRSTR_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/inline_memmem.h"
 #include "src/string/string_utils.h"
 #include <stddef.h>
diff --git a/src/string/memory_utils/op_aarch64.h b/src/string/memory_utils/op_aarch64.h
index 1090ea2..868c644 100644
--- a/src/string/memory_utils/op_aarch64.h
+++ b/src/string/memory_utils/op_aarch64.h
@@ -13,7 +13,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_AARCH64_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_AARCH64_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_AARCH64)
diff --git a/src/string/memory_utils/op_builtin.h b/src/string/memory_utils/op_builtin.h
index d7c1b1f..27b621d 100644
--- a/src/string/memory_utils/op_builtin.h
+++ b/src/string/memory_utils/op_builtin.h
@@ -16,7 +16,8 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_BUILTIN_H
 
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/string/memory_utils/op_generic.h b/src/string/memory_utils/op_generic.h
index da20a84..9349cfd 100644
--- a/src/string/memory_utils/op_generic.h
+++ b/src/string/memory_utils/op_generic.h
@@ -27,7 +27,8 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/common.h"
 #include "src/__support/endian_internal.h"
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/optimization.h"
 #include "src/__support/macros/properties/types.h" // LIBC_TYPES_HAS_INT64
 #include "src/string/memory_utils/op_builtin.h"
diff --git a/src/string/memory_utils/op_riscv.h b/src/string/memory_utils/op_riscv.h
index 2d211de..4292d7a 100644
--- a/src/string/memory_utils/op_riscv.h
+++ b/src/string/memory_utils/op_riscv.h
@@ -12,7 +12,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_RISCV_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_RISCV_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_ANY_RISCV)
diff --git a/src/string/memory_utils/op_x86.h b/src/string/memory_utils/op_x86.h
index 309610e..8bd8412 100644
--- a/src/string/memory_utils/op_x86.h
+++ b/src/string/memory_utils/op_x86.h
@@ -12,7 +12,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_X86_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_OP_X86_H
 
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h"
 
 #if defined(LIBC_TARGET_ARCH_IS_X86)
diff --git a/src/string/memory_utils/riscv/inline_bcmp.h b/src/string/memory_utils/riscv/inline_bcmp.h
index 4bdde27..666ad63 100644
--- a/src/string/memory_utils/riscv/inline_bcmp.h
+++ b/src/string/memory_utils/riscv/inline_bcmp.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/riscv/inline_memcmp.h b/src/string/memory_utils/riscv/inline_memcmp.h
index ca83495..c49e8d0 100644
--- a/src/string/memory_utils/riscv/inline_memcmp.h
+++ b/src/string/memory_utils/riscv/inline_memcmp.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCMP_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/riscv/inline_memcpy.h b/src/string/memory_utils/riscv/inline_memcpy.h
index 8eb87e0..e907ae4 100644
--- a/src/string/memory_utils/riscv/inline_memcpy.h
+++ b/src/string/memory_utils/riscv/inline_memcpy.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMCPY_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/riscv/inline_memmove.h b/src/string/memory_utils/riscv/inline_memmove.h
index 28de4c2..01a9fa5 100644
--- a/src/string/memory_utils/riscv/inline_memmove.h
+++ b/src/string/memory_utils/riscv/inline_memmove.h
@@ -9,7 +9,7 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMMOVE_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/byte_per_byte.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/riscv/inline_memset.h b/src/string/memory_utils/riscv/inline_memset.h
index d6ab523..09a7a76 100644
--- a/src/string/memory_utils/riscv/inline_memset.h
+++ b/src/string/memory_utils/riscv/inline_memset.h
@@ -9,7 +9,7 @@
 #define LIBC_SRC_STRING_MEMORY_UTILS_RISCV_INLINE_MEMSET_H
 
 #include "src/__support/macros/attributes.h"               // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h" // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h" // LIBC_TARGET_ARCH_IS_RISCV64
 #include "src/string/memory_utils/generic/aligned_access.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/utils.h b/src/string/memory_utils/utils.h
index cae65bd..bdf0b86 100644
--- a/src/string/memory_utils/utils.h
+++ b/src/string/memory_utils/utils.h
@@ -14,7 +14,7 @@
 #include "src/__support/CPP/type_traits.h"
 #include "src/__support/endian_internal.h"
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/__support/macros/properties/architectures.h"
 
 #include <stddef.h> // size_t
@@ -263,7 +263,7 @@ LIBC_INLINE void store_aligned(ValueType value, Ptr dst) {
   static_assert(sizeof(ValueType) >= (sizeof(T) + ... + sizeof(TS)));
   constexpr size_t SHIFT = sizeof(T) * 8;
   if constexpr (Endian::IS_LITTLE) {
-    store<T>(assume_aligned<sizeof(T)>(dst), value & ~T(0));
+    store<T>(assume_aligned<sizeof(T)>(dst), T(value & T(~0)));
     if constexpr (sizeof...(TS) > 0)
       store_aligned<ValueType, TS...>(value >> SHIFT, dst + sizeof(T));
   } else if constexpr (Endian::IS_BIG) {
@@ -297,7 +297,7 @@ LIBC_INLINE void adjust(ptrdiff_t offset, T1 *__restrict &p1,
                         T2 *__restrict &p2, size_t &count) {
   p1 += offset;
   p2 += offset;
-  count -= offset;
+  count -= static_cast<size_t>(offset);
 }
 
 // Advances p1 and p2 so p1 gets aligned to the next SIZE bytes boundary
@@ -306,7 +306,8 @@ LIBC_INLINE void adjust(ptrdiff_t offset, T1 *__restrict &p1,
 template <size_t SIZE, typename T1, typename T2>
 void align_p1_to_next_boundary(T1 *__restrict &p1, T2 *__restrict &p2,
                                size_t &count) {
-  adjust(distance_to_next_aligned<SIZE>(p1), p1, p2, count);
+  adjust(static_cast<ptrdiff_t>(distance_to_next_aligned<SIZE>(p1)), p1, p2,
+         count);
   p1 = assume_aligned<SIZE>(p1);
 }
 
diff --git a/src/string/memory_utils/x86_64/inline_bcmp.h b/src/string/memory_utils/x86_64/inline_bcmp.h
index cc54c41..8be391b 100644
--- a/src/string/memory_utils/x86_64/inline_bcmp.h
+++ b/src/string/memory_utils/x86_64/inline_bcmp.h
@@ -9,7 +9,7 @@
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_BCMP_H
 
 #include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/memory_utils/x86_64/inline_memset.h b/src/string/memory_utils/x86_64/inline_memset.h
index 9f8e584..35719a8 100644
--- a/src/string/memory_utils/x86_64/inline_memset.h
+++ b/src/string/memory_utils/x86_64/inline_memset.h
@@ -8,8 +8,8 @@
 #ifndef LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMSET_H
 #define LLVM_LIBC_SRC_STRING_MEMORY_UTILS_X86_64_INLINE_MEMSET_H
 
-#include "src/__support/macros/attributes.h" // LIBC_INLINE
-#include "src/__support/macros/config.h"
+#include "src/__support/macros/attributes.h" // LIBC_INLINE, LIBC_INLINE_VAR
+#include "src/__support/macros/config.h"     // LIBC_NAMESPACE_DECL
 #include "src/string/memory_utils/op_generic.h"
 #include "src/string/memory_utils/op_x86.h"
 #include "src/string/memory_utils/utils.h" // Ptr, CPtr
diff --git a/src/string/string_utils.h b/src/string/string_utils.h
index fc617bd..e4659f6 100644
--- a/src/string/string_utils.h
+++ b/src/string/string_utils.h
@@ -14,12 +14,13 @@
 #ifndef LLVM_LIBC_SRC_STRING_STRING_UTILS_H
 #define LLVM_LIBC_SRC_STRING_STRING_UTILS_H
 
+#include "hdr/types/size_t.h"
 #include "src/__support/CPP/bitset.h"
+#include "src/__support/CPP/type_traits.h" // cpp::is_same_v
 #include "src/__support/macros/config.h"
 #include "src/__support/macros/optimization.h" // LIBC_UNLIKELY
 #include "src/string/memory_utils/inline_bzero.h"
 #include "src/string/memory_utils/inline_memcpy.h"
-#include <stddef.h> // For size_t
 
 namespace LIBC_NAMESPACE_DECL {
 namespace internal {
@@ -65,7 +66,7 @@ LIBC_INLINE size_t string_length_wide_read(const char *src) {
   for (; reinterpret_cast<uintptr_t>(char_ptr) % sizeof(Word) != 0;
        ++char_ptr) {
     if (*char_ptr == '\0')
-      return char_ptr - src;
+      return static_cast<size_t>(char_ptr - src);
   }
   // Step 2: read blocks
   for (const Word *block_ptr = reinterpret_cast<const Word *>(char_ptr);
@@ -76,27 +77,24 @@ LIBC_INLINE size_t string_length_wide_read(const char *src) {
   for (; *char_ptr != '\0'; ++char_ptr) {
     ;
   }
-  return char_ptr - src;
-}
-
-LIBC_INLINE size_t string_length_byte_read(const char *src) {
-  size_t length;
-  for (length = 0; *src; ++src, ++length)
-    ;
-  return length;
+  return static_cast<size_t>(char_ptr - src);
 }
 
 // Returns the length of a string, denoted by the first occurrence
 // of a null terminator.
-LIBC_INLINE size_t string_length(const char *src) {
+template <typename T> LIBC_INLINE size_t string_length(const T *src) {
 #ifdef LIBC_COPT_STRING_UNSAFE_WIDE_READ
   // Unsigned int is the default size for most processors, and on x86-64 it
   // performs better than larger sizes when the src pointer can't be assumed to
   // be aligned to a word boundary, so it's the size we use for reading the
   // string a block at a time.
-  return string_length_wide_read<unsigned int>(src);
+  if constexpr (cpp::is_same_v<T, char>)
+    return string_length_wide_read<unsigned int>(src);
 #else
-  return string_length_byte_read(src);
+  size_t length;
+  for (length = 0; *src; ++src, ++length)
+    ;
+  return length;
 #endif
 }
 
@@ -171,7 +169,7 @@ LIBC_INLINE size_t complementary_span(const char *src, const char *segment) {
   for (; *src && !bitset.test(*reinterpret_cast<const unsigned char *>(src));
        ++src)
     ;
-  return src - initial;
+  return static_cast<size_t>(src - initial);
 }
 
 // Given the similarities between strtok and strtok_r, we can implement both
@@ -191,12 +189,14 @@ LIBC_INLINE char *string_token(char *__restrict src,
   if (LIBC_UNLIKELY(src == nullptr && ((src = *saveptr) == nullptr)))
     return nullptr;
 
+  static_assert(sizeof(char) == sizeof(cpp::byte),
+                "bitset of 256 assumes char is 8 bits");
   cpp::bitset<256> delimiter_set;
   for (; *delimiter_string != '\0'; ++delimiter_string)
-    delimiter_set.set(*delimiter_string);
+    delimiter_set.set(static_cast<size_t>(*delimiter_string));
 
   if constexpr (SkipDelim)
-    for (; *src != '\0' && delimiter_set.test(*src); ++src)
+    for (; *src != '\0' && delimiter_set.test(static_cast<size_t>(*src)); ++src)
       ;
   if (*src == '\0') {
     *saveptr = src;
@@ -204,7 +204,7 @@ LIBC_INLINE char *string_token(char *__restrict src,
   }
   char *token = src;
   for (; *src != '\0'; ++src) {
-    if (delimiter_set.test(*src)) {
+    if (delimiter_set.test(static_cast<size_t>(*src))) {
       *src = '\0';
       ++src;
       break;
diff --git a/src/string/bcmp.cpp b/src/strings/bcmp.cpp
similarity index 95%
rename from src/string/bcmp.cpp
rename to src/strings/bcmp.cpp
index 6e9c9ae..083f13d 100644
--- a/src/string/bcmp.cpp
+++ b/src/strings/bcmp.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/bcmp.h"
+#include "src/strings/bcmp.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_bcmp.h"
diff --git a/src/string/bcmp.h b/src/strings/bcmp.h
similarity index 83%
rename from src/string/bcmp.h
rename to src/strings/bcmp.h
index a82b529..46b4d71 100644
--- a/src/string/bcmp.h
+++ b/src/strings/bcmp.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_BCMP_H
-#define LLVM_LIBC_SRC_STRING_BCMP_H
+#ifndef LLVM_LIBC_SRC_STRINGS_BCMP_H
+#define LLVM_LIBC_SRC_STRINGS_BCMP_H
 
 #include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
@@ -18,4 +18,4 @@ int bcmp(const void *lhs, const void *rhs, size_t count);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_BCMP_H
+#endif // LLVM_LIBC_SRC_STRINGS_BCMP_H
diff --git a/src/string/bcopy.cpp b/src/strings/bcopy.cpp
similarity index 95%
rename from src/string/bcopy.cpp
rename to src/strings/bcopy.cpp
index 89aad71..eb0358c 100644
--- a/src/string/bcopy.cpp
+++ b/src/strings/bcopy.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/bcopy.h"
+#include "src/strings/bcopy.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_memmove.h"
diff --git a/src/string/bcopy.h b/src/strings/bcopy.h
similarity index 83%
rename from src/string/bcopy.h
rename to src/strings/bcopy.h
index 4cf0263..d8ee77e 100644
--- a/src/string/bcopy.h
+++ b/src/strings/bcopy.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_BCOPY_H
-#define LLVM_LIBC_SRC_STRING_BCOPY_H
+#ifndef LLVM_LIBC_SRC_STRINGS_BCOPY_H
+#define LLVM_LIBC_SRC_STRINGS_BCOPY_H
 
 #include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
@@ -18,4 +18,4 @@ void bcopy(const void *src, void *dest, size_t count);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_BCOPY_H
+#endif // LLVM_LIBC_SRC_STRINGS_BCOPY_H
diff --git a/src/string/bzero.cpp b/src/strings/bzero.cpp
similarity index 95%
rename from src/string/bzero.cpp
rename to src/strings/bzero.cpp
index 7bcbee3..9c2e970 100644
--- a/src/string/bzero.cpp
+++ b/src/strings/bzero.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/bzero.h"
+#include "src/strings/bzero.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 #include "src/string/memory_utils/inline_bzero.h"
diff --git a/src/string/bzero.h b/src/strings/bzero.h
similarity index 82%
rename from src/string/bzero.h
rename to src/strings/bzero.h
index d972219..3e270fe 100644
--- a/src/string/bzero.h
+++ b/src/strings/bzero.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_BZERO_H
-#define LLVM_LIBC_SRC_STRING_BZERO_H
+#ifndef LLVM_LIBC_SRC_STRINGS_BZERO_H
+#define LLVM_LIBC_SRC_STRINGS_BZERO_H
 
 #include "src/__support/macros/config.h"
 #include <stddef.h> // size_t
@@ -18,4 +18,4 @@ void bzero(void *ptr, size_t count);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_BZERO_H
+#endif // LLVM_LIBC_SRC_STRINGS_BZERO_H
diff --git a/src/strings/ffs.cpp b/src/strings/ffs.cpp
new file mode 100644
index 0000000..5e1efaf
--- /dev/null
+++ b/src/strings/ffs.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ffs ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffs.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/math_extras.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, ffs, (int i)) {
+  return first_trailing_one(static_cast<unsigned>(i));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/strings/ffs.h b/src/strings/ffs.h
new file mode 100644
index 0000000..bf43c43
--- /dev/null
+++ b/src/strings/ffs.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ffs ---------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRINGS_FFS_H
+#define LLVM_LIBC_SRC_STRINGS_FFS_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int ffs(int i);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRINGS_FFS_H
diff --git a/src/strings/ffsl.cpp b/src/strings/ffsl.cpp
new file mode 100644
index 0000000..b1b2559
--- /dev/null
+++ b/src/strings/ffsl.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ffsl --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffsl.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/math_extras.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, ffsl, (long i)) {
+  return first_trailing_one(static_cast<unsigned long>(i));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/strings/ffsl.h b/src/strings/ffsl.h
new file mode 100644
index 0000000..1feca01
--- /dev/null
+++ b/src/strings/ffsl.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ffsl --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRINGS_FFSL_H
+#define LLVM_LIBC_SRC_STRINGS_FFSL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int ffsl(long i);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRINGS_FFSL_H
diff --git a/src/strings/ffsll.cpp b/src/strings/ffsll.cpp
new file mode 100644
index 0000000..be16e81
--- /dev/null
+++ b/src/strings/ffsll.cpp
@@ -0,0 +1,20 @@
+//===-- Implementation of ffsll -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffsll.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/math_extras.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, ffsll, (long long i)) {
+  return first_trailing_one(static_cast<unsigned long long>(i));
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/strings/ffsll.h b/src/strings/ffsll.h
new file mode 100644
index 0000000..f059b8a
--- /dev/null
+++ b/src/strings/ffsll.h
@@ -0,0 +1,20 @@
+//===-- Implementation header for ffsll -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRINGS_FFSLL_H
+#define LLVM_LIBC_SRC_STRINGS_FFSLL_H
+
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int ffsll(long long i);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRINGS_FFSLL_H
diff --git a/src/string/index.cpp b/src/strings/index.cpp
similarity index 95%
rename from src/string/index.cpp
rename to src/strings/index.cpp
index 46cf548..33b2be9 100644
--- a/src/string/index.cpp
+++ b/src/strings/index.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/index.h"
+#include "src/strings/index.h"
 
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
diff --git a/src/string/index.h b/src/strings/index.h
similarity index 81%
rename from src/string/index.h
rename to src/strings/index.h
index 9843bcd..d382cdd 100644
--- a/src/string/index.h
+++ b/src/strings/index.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_INDEX_H
-#define LLVM_LIBC_SRC_STRING_INDEX_H
+#ifndef LLVM_LIBC_SRC_STRINGS_INDEX_H
+#define LLVM_LIBC_SRC_STRINGS_INDEX_H
 
 #include "src/__support/macros/config.h"
 
@@ -17,4 +17,4 @@ char *index(const char *src, int c);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_INDEX_H
+#endif // LLVM_LIBC_SRC_STRINGS_INDEX_H
diff --git a/src/string/rindex.cpp b/src/strings/rindex.cpp
similarity index 95%
rename from src/string/rindex.cpp
rename to src/strings/rindex.cpp
index 25879dd..1242e0f 100644
--- a/src/string/rindex.cpp
+++ b/src/strings/rindex.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/rindex.h"
+#include "src/strings/rindex.h"
 
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
diff --git a/src/string/rindex.h b/src/strings/rindex.h
similarity index 81%
rename from src/string/rindex.h
rename to src/strings/rindex.h
index cfc35da..f8aa7b9 100644
--- a/src/string/rindex.h
+++ b/src/strings/rindex.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_RINDEX_H
-#define LLVM_LIBC_SRC_STRING_RINDEX_H
+#ifndef LLVM_LIBC_SRC_STRINGS_RINDEX_H
+#define LLVM_LIBC_SRC_STRINGS_RINDEX_H
 
 #include "src/__support/macros/config.h"
 
@@ -17,4 +17,4 @@ char *rindex(const char *src, int c);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_RINDEX_H
+#endif // LLVM_LIBC_SRC_STRINGS_RINDEX_H
diff --git a/src/string/strcasecmp.cpp b/src/strings/strcasecmp.cpp
similarity index 96%
rename from src/string/strcasecmp.cpp
rename to src/strings/strcasecmp.cpp
index 1274c04..4bbe290 100644
--- a/src/string/strcasecmp.cpp
+++ b/src/strings/strcasecmp.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/strcasecmp.h"
+#include "src/strings/strcasecmp.h"
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
diff --git a/src/string/strcasecmp.h b/src/strings/strcasecmp.h
similarity index 80%
rename from src/string/strcasecmp.h
rename to src/strings/strcasecmp.h
index 2916b8d..b02fb31 100644
--- a/src/string/strcasecmp.h
+++ b/src/strings/strcasecmp.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_STRCASECMP_H
-#define LLVM_LIBC_SRC_STRING_STRCASECMP_H
+#ifndef LLVM_LIBC_SRC_STRINGS_STRCASECMP_H
+#define LLVM_LIBC_SRC_STRINGS_STRCASECMP_H
 
 #include "src/__support/macros/config.h"
 
@@ -17,4 +17,4 @@ int strcasecmp(const char *left, const char *right);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_STRCASECMP_H
+#endif // LLVM_LIBC_SRC_STRINGS_STRCASECMP_H
diff --git a/src/strings/strcasecmp_l.cpp b/src/strings/strcasecmp_l.cpp
new file mode 100644
index 0000000..95117cb
--- /dev/null
+++ b/src/strings/strcasecmp_l.cpp
@@ -0,0 +1,27 @@
+//===-- Implementation of strcasecmp_l ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/strcasecmp_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_strcmp.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, strcasecmp_l,
+                   (const char *left, const char *right, locale_t)) {
+  auto case_cmp = [](char a, char b) {
+    return LIBC_NAMESPACE::internal::tolower(a) -
+           LIBC_NAMESPACE::internal::tolower(b);
+  };
+  return inline_strcmp(left, right, case_cmp);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/strings/strcasecmp_l.h b/src/strings/strcasecmp_l.h
new file mode 100644
index 0000000..4807446
--- /dev/null
+++ b/src/strings/strcasecmp_l.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for strcasecmp_l ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRINGS_STRCASECMP_L_H
+#define LLVM_LIBC_SRC_STRINGS_STRCASECMP_L_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int strcasecmp_l(const char *left, const char *right, locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRINGS_STRCASECMP_L_H
diff --git a/src/string/strncasecmp.cpp b/src/strings/strncasecmp.cpp
similarity index 96%
rename from src/string/strncasecmp.cpp
rename to src/strings/strncasecmp.cpp
index 45f82c9..9c2f0ab 100644
--- a/src/string/strncasecmp.cpp
+++ b/src/strings/strncasecmp.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/strncasecmp.h"
+#include "src/strings/strncasecmp.h"
 
 #include "src/__support/common.h"
 #include "src/__support/ctype_utils.h"
diff --git a/src/string/strncasecmp.h b/src/strings/strncasecmp.h
similarity index 80%
rename from src/string/strncasecmp.h
rename to src/strings/strncasecmp.h
index 15f7499..59df517 100644
--- a/src/string/strncasecmp.h
+++ b/src/strings/strncasecmp.h
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#ifndef LLVM_LIBC_SRC_STRING_STRNCASECMP_H
-#define LLVM_LIBC_SRC_STRING_STRNCASECMP_H
+#ifndef LLVM_LIBC_SRC_STRINGS_STRNCASECMP_H
+#define LLVM_LIBC_SRC_STRINGS_STRNCASECMP_H
 
 #include "src/__support/macros/config.h"
 #include <stddef.h>
@@ -18,4 +18,4 @@ int strncasecmp(const char *left, const char *right, size_t n);
 
 } // namespace LIBC_NAMESPACE_DECL
 
-#endif // LLVM_LIBC_SRC_STRING_STRNCASECMP_H
+#endif // LLVM_LIBC_SRC_STRINGS_STRNCASECMP_H
diff --git a/src/strings/strncasecmp_l.cpp b/src/strings/strncasecmp_l.cpp
new file mode 100644
index 0000000..91ac7e5
--- /dev/null
+++ b/src/strings/strncasecmp_l.cpp
@@ -0,0 +1,27 @@
+//===-- Implementation of strncasecmp_l -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/strncasecmp_l.h"
+
+#include "src/__support/common.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+#include "src/string/memory_utils/inline_strcmp.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, strncasecmp_l,
+                   (const char *left, const char *right, size_t n, locale_t)) {
+  auto case_cmp = [](char a, char b) {
+    return LIBC_NAMESPACE::internal::tolower(a) -
+           LIBC_NAMESPACE::internal::tolower(b);
+  };
+  return inline_strncmp(left, right, n, case_cmp);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/strings/strncasecmp_l.h b/src/strings/strncasecmp_l.h
new file mode 100644
index 0000000..6c6c7f1
--- /dev/null
+++ b/src/strings/strncasecmp_l.h
@@ -0,0 +1,23 @@
+//===-- Implementation header for strncasecmp_l -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STRINGS_STRNCASECMP_L_H
+#define LLVM_LIBC_SRC_STRINGS_STRNCASECMP_L_H
+
+#include "hdr/types/locale_t.h"
+#include "src/__support/macros/config.h"
+#include <stddef.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+int strncasecmp_l(const char *left, const char *right, size_t n,
+                  locale_t locale);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STRINGS_STRNCASECMP_L_H
diff --git a/src/sys/uio/linux/readv.cpp b/src/sys/uio/linux/readv.cpp
new file mode 100644
index 0000000..f1393a9
--- /dev/null
+++ b/src/sys/uio/linux/readv.cpp
@@ -0,0 +1,29 @@
+//===-- Implementation file for readv -------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "src/sys/uio/readv.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_iovec.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+#include <sys/syscall.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, readv, (int fd, const iovec *iov, int iovcnt)) {
+  long ret = LIBC_NAMESPACE::syscall_impl<long>(SYS_readv, fd, iov, iovcnt);
+  // On failure, return -1 and set errno.
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+  // On success, return number of bytes read.
+  return static_cast<ssize_t>(ret);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/uio/linux/writev.cpp b/src/sys/uio/linux/writev.cpp
new file mode 100644
index 0000000..8992bed
--- /dev/null
+++ b/src/sys/uio/linux/writev.cpp
@@ -0,0 +1,29 @@
+//===-- Implementation file for writev ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#include "src/sys/uio/writev.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_iovec.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+#include <sys/syscall.h>
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(ssize_t, writev, (int fd, const iovec *iov, int iovcnt)) {
+  long ret = LIBC_NAMESPACE::syscall_impl<long>(SYS_writev, fd, iov, iovcnt);
+  // On failure, return -1 and set errno.
+  if (ret < 0) {
+    libc_errno = static_cast<int>(-ret);
+    return -1;
+  }
+  // On success, return number of bytes written.
+  return static_cast<ssize_t>(ret);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/uio/readv.h b/src/sys/uio/readv.h
new file mode 100644
index 0000000..135b1e6
--- /dev/null
+++ b/src/sys/uio/readv.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for readv -----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_UIO_READV_H
+#define LLVM_LIBC_SRC_SYS_UIO_READV_H
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_iovec.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t readv(int fd, const iovec *iov, int iovcnt);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_UIO_READV_H
diff --git a/src/sys/uio/writev.h b/src/sys/uio/writev.h
new file mode 100644
index 0000000..787bc4b
--- /dev/null
+++ b/src/sys/uio/writev.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for writev ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_SYS_UIO_WRITEV_H
+#define LLVM_LIBC_SRC_SYS_UIO_WRITEV_H
+
+#include "hdr/types/ssize_t.h"
+#include "hdr/types/struct_iovec.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+ssize_t writev(int fd, const iovec *iov, int iovcnt);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_SYS_UIO_WRITEV_H
diff --git a/src/sys/wait/wait4Impl.h b/src/sys/wait/wait4Impl.h
index 5c2cb3e..f2bdeb0 100644
--- a/src/sys/wait/wait4Impl.h
+++ b/src/sys/wait/wait4Impl.h
@@ -65,7 +65,9 @@ LIBC_INLINE ErrorOr<pid_t> wait4impl(pid_t pid, int *wait_status, int options,
       *wait_status = W_STOPCODE(info.si_status);
       break;
     case CLD_CONTINUED:
-      *wait_status = __W_CONTINUED;
+      // Set wait_status to a value that the caller can check via WIFCONTINUED.
+      // glibc has a non-POSIX macro definition __W_CONTINUED for this value.
+      *wait_status = 0xffff;
       break;
     default:
       *wait_status = 0;
diff --git a/src/time/asctime.cpp b/src/time/asctime.cpp
index d6fbe73..2b00c41 100644
--- a/src/time/asctime.cpp
+++ b/src/time/asctime.cpp
@@ -9,15 +9,15 @@
 #include "src/time/asctime.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
+#include "src/time/time_constants.h"
 #include "src/time/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 LLVM_LIBC_FUNCTION(char *, asctime, (const struct tm *timeptr)) {
-  static char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
-  return time_utils::asctime(timeptr, buffer, TimeConstants::ASCTIME_MAX_BYTES);
+  static char buffer[time_constants::ASCTIME_BUFFER_SIZE];
+  return time_utils::asctime(timeptr, buffer,
+                             time_constants::ASCTIME_MAX_BYTES);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/asctime.h b/src/time/asctime.h
index 623e6df..37325e7 100644
--- a/src/time/asctime.h
+++ b/src/time/asctime.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_TIME_ASCTIME_H
 #define LLVM_LIBC_SRC_TIME_ASCTIME_H
 
+#include "hdr/types/struct_tm.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/asctime_r.cpp b/src/time/asctime_r.cpp
index caa22f1..bf53bfd 100644
--- a/src/time/asctime_r.cpp
+++ b/src/time/asctime_r.cpp
@@ -9,15 +9,15 @@
 #include "src/time/asctime_r.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
+#include "src/time/time_constants.h"
 #include "src/time/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 LLVM_LIBC_FUNCTION(char *, asctime_r,
                    (const struct tm *timeptr, char *buffer)) {
-  return time_utils::asctime(timeptr, buffer, TimeConstants::ASCTIME_MAX_BYTES);
+  return time_utils::asctime(timeptr, buffer,
+                             time_constants::ASCTIME_MAX_BYTES);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/asctime_r.h b/src/time/asctime_r.h
index 328b7df..65a6b84 100644
--- a/src/time/asctime_r.h
+++ b/src/time/asctime_r.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_TIME_ASCTIME_R_H
 #define LLVM_LIBC_SRC_TIME_ASCTIME_R_H
 
+#include "hdr/types/struct_tm.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/baremetal/timespec_get.cpp b/src/time/baremetal/timespec_get.cpp
new file mode 100644
index 0000000..173fe0e
--- /dev/null
+++ b/src/time/baremetal/timespec_get.cpp
@@ -0,0 +1,27 @@
+//===-- Implementation of timespec_get for baremetal ----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/timespec_get.h"
+#include "hdr/time_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+extern "C" bool __llvm_libc_timespec_get_utc(struct timespec *ts);
+
+LLVM_LIBC_FUNCTION(int, timespec_get, (struct timespec * ts, int base)) {
+  if (base != TIME_UTC)
+    return 0;
+
+  if (!__llvm_libc_timespec_get_utc(ts))
+    return 0;
+  return base;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/clock_getres.h b/src/time/clock_getres.h
new file mode 100644
index 0000000..c1c581c
--- /dev/null
+++ b/src/time/clock_getres.h
@@ -0,0 +1,21 @@
+//===-- Implementation header of clock_getres -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef LLVM_LIBC_SRC_TIME_CLOCK_GETRES_H
+#define LLVM_LIBC_SRC_TIME_CLOCK_GETRES_H
+
+#include "hdr/types/clockid_t.h"
+#include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int clock_getres(clockid_t clockid, timespec *tp);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_CLOCK_GETRES_H
diff --git a/src/time/ctime.cpp b/src/time/ctime.cpp
index 8adae9b..ac0ffe5 100644
--- a/src/time/ctime.cpp
+++ b/src/time/ctime.cpp
@@ -6,23 +6,22 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ctime.h"
+#include "src/time/ctime.h"
 #include "src/__support/CPP/limits.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "time_utils.h"
+#include "src/time/time_constants.h"
+#include "src/time/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 LLVM_LIBC_FUNCTION(char *, ctime, (const time_t *t_ptr)) {
   if (t_ptr == nullptr || *t_ptr > cpp::numeric_limits<int32_t>::max()) {
     return nullptr;
   }
-  static char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  static char buffer[time_constants::ASCTIME_BUFFER_SIZE];
   return time_utils::asctime(time_utils::localtime(t_ptr), buffer,
-                             TimeConstants::ASCTIME_MAX_BYTES);
+                             time_constants::ASCTIME_MAX_BYTES);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/ctime_r.cpp b/src/time/ctime_r.cpp
index 63d93c4..7224f77 100644
--- a/src/time/ctime_r.cpp
+++ b/src/time/ctime_r.cpp
@@ -6,16 +6,15 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ctime_r.h"
+#include "src/time/ctime_r.h"
 #include "src/__support/CPP/limits.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "time_utils.h"
+#include "src/time/time_constants.h"
+#include "src/time/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 LLVM_LIBC_FUNCTION(char *, ctime_r, (const time_t *t_ptr, char *buffer)) {
   if (t_ptr == nullptr || buffer == nullptr ||
       *t_ptr > cpp::numeric_limits<int32_t>::max()) {
@@ -23,7 +22,7 @@ LLVM_LIBC_FUNCTION(char *, ctime_r, (const time_t *t_ptr, char *buffer)) {
   }
 
   return time_utils::asctime(time_utils::localtime(t_ptr), buffer,
-                             TimeConstants::ASCTIME_MAX_BYTES);
+                             time_constants::ASCTIME_MAX_BYTES);
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/difftime.h b/src/time/difftime.h
index d5cd593..12de567 100644
--- a/src/time/difftime.h
+++ b/src/time/difftime.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_TIME_DIFFTIME_H
 #define LLVM_LIBC_SRC_TIME_DIFFTIME_H
 
+#include "hdr/types/time_t.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/gmtime.h b/src/time/gmtime.h
index 3de3ceb..ac7f1be 100644
--- a/src/time/gmtime.h
+++ b/src/time/gmtime.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_TIME_GMTIME_H
 #define LLVM_LIBC_SRC_TIME_GMTIME_H
 
+#include "hdr/types/struct_tm.h"
+#include "hdr/types/time_t.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/gmtime_r.h b/src/time/gmtime_r.h
index b4f387e..4c88b22 100644
--- a/src/time/gmtime_r.h
+++ b/src/time/gmtime_r.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_TIME_GMTIME_R_H
 #define LLVM_LIBC_SRC_TIME_GMTIME_R_H
 
+#include "hdr/types/struct_tm.h"
+#include "hdr/types/time_t.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/gpu/clock.cpp b/src/time/gpu/clock.cpp
index 4cdb1d5..8609c5c 100644
--- a/src/time/gpu/clock.cpp
+++ b/src/time/gpu/clock.cpp
@@ -7,8 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/time/clock.h"
+
+#include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "src/time/gpu/time_utils.h"
+#include "src/__support/time/gpu/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/gpu/clock_gettime.cpp b/src/time/gpu/clock_gettime.cpp
index de7899a..81547ef 100644
--- a/src/time/gpu/clock_gettime.cpp
+++ b/src/time/gpu/clock_gettime.cpp
@@ -10,23 +10,16 @@
 
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "time_utils.h"
+#include "src/__support/time/clock_gettime.h"
+#include "src/__support/time/gpu/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
-
 LLVM_LIBC_FUNCTION(int, clock_gettime, (clockid_t clockid, timespec *ts)) {
-  if (clockid != CLOCK_MONOTONIC || !ts)
-    return -1;
-
-  uint64_t ns_per_tick = TICKS_PER_SEC / GPU_CLOCKS_PER_SEC;
-  uint64_t ticks = gpu::fixed_frequency_clock();
-
-  ts->tv_nsec = (ticks * ns_per_tick) % TICKS_PER_SEC;
-  ts->tv_sec = (ticks * ns_per_tick) / TICKS_PER_SEC;
-
-  return 0;
+  ErrorOr<int> result = internal::clock_gettime(clockid, ts);
+  if (result)
+    return result.value();
+  return result.error();
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/gpu/nanosleep.cpp b/src/time/gpu/nanosleep.cpp
index 3f4a609..d22d9d6 100644
--- a/src/time/gpu/nanosleep.cpp
+++ b/src/time/gpu/nanosleep.cpp
@@ -8,13 +8,12 @@
 
 #include "src/time/nanosleep.h"
 
+#include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "time_utils.h"
+#include "src/__support/time/gpu/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-constexpr uint64_t TICKS_PER_SEC = 1000000000UL;
-
 LLVM_LIBC_FUNCTION(int, nanosleep,
                    (const struct timespec *req, struct timespec *rem)) {
   if (!GPU_CLOCKS_PER_SEC || !req)
diff --git a/src/time/gpu/timespec_get.cpp b/src/time/gpu/timespec_get.cpp
new file mode 100644
index 0000000..0dd1284
--- /dev/null
+++ b/src/time/gpu/timespec_get.cpp
@@ -0,0 +1,30 @@
+//===-- Implementation of timespec_get for gpu ----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/timespec_get.h"
+#include "hdr/time_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/time/gpu/time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, timespec_get, (struct timespec * ts, int base)) {
+  if (base != TIME_MONOTONIC || !ts)
+    return 0;
+
+  uint64_t ns_per_tick = TICKS_PER_SEC / GPU_CLOCKS_PER_SEC;
+  uint64_t ticks = gpu::fixed_frequency_clock();
+
+  ts->tv_nsec = (ticks * ns_per_tick) % TICKS_PER_SEC;
+  ts->tv_sec = (ticks * ns_per_tick) / TICKS_PER_SEC;
+
+  return base;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/linux/clock.cpp b/src/time/linux/clock.cpp
index f43e1bc..ee4fa82 100644
--- a/src/time/linux/clock.cpp
+++ b/src/time/linux/clock.cpp
@@ -11,7 +11,7 @@
 #include "src/__support/CPP/limits.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/__support/time/units.h"
 #include "src/errno/libc_errno.h"
 
diff --git a/src/time/linux/clock_gettime.cpp b/src/time/linux/clock_gettime.cpp
index a2b20a6..743c644 100644
--- a/src/time/linux/clock_gettime.cpp
+++ b/src/time/linux/clock_gettime.cpp
@@ -9,7 +9,7 @@
 #include "src/time/clock_gettime.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/errno/libc_errno.h"
 
 namespace LIBC_NAMESPACE_DECL {
diff --git a/src/time/linux/gettimeofday.cpp b/src/time/linux/gettimeofday.cpp
index 19d9988..e8ddf48 100644
--- a/src/time/linux/gettimeofday.cpp
+++ b/src/time/linux/gettimeofday.cpp
@@ -11,7 +11,7 @@
 #include "hdr/types/suseconds_t.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/__support/time/units.h"
 #include "src/errno/libc_errno.h"
 
diff --git a/src/time/linux/timespec_get.cpp b/src/time/linux/timespec_get.cpp
new file mode 100644
index 0000000..cf51745
--- /dev/null
+++ b/src/time/linux/timespec_get.cpp
@@ -0,0 +1,45 @@
+//===-- Implementation of timespec_get for Linux --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/timespec_get.h"
+#include "hdr/time_macros.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/time/clock_gettime.h"
+#include "src/errno/libc_errno.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, timespec_get, (struct timespec * ts, int base)) {
+  clockid_t clockid;
+  switch (base) {
+  case TIME_UTC:
+    clockid = CLOCK_REALTIME;
+    break;
+  case TIME_MONOTONIC:
+    clockid = CLOCK_MONOTONIC;
+    break;
+  case TIME_ACTIVE:
+    clockid = CLOCK_PROCESS_CPUTIME_ID;
+    break;
+  case TIME_THREAD_ACTIVE:
+    clockid = CLOCK_THREAD_CPUTIME_ID;
+    break;
+  default:
+    return 0;
+  }
+
+  auto result = internal::clock_gettime(clockid, ts);
+  if (!result.has_value()) {
+    libc_errno = result.error();
+    return 0;
+  }
+  return base;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/mktime.cpp b/src/time/mktime.cpp
index 72cd229..fc05ff2 100644
--- a/src/time/mktime.cpp
+++ b/src/time/mktime.cpp
@@ -9,108 +9,13 @@
 #include "src/time/mktime.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
+#include "src/time/time_constants.h"
 #include "src/time/time_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
-static constexpr int NON_LEAP_YEAR_DAYS_IN_MONTH[] = {31, 28, 31, 30, 31, 30,
-                                                      31, 31, 30, 31, 30, 31};
-
-// Returns number of years from (1, year).
-static constexpr int64_t get_num_of_leap_years_before(int64_t year) {
-  return (year / 4) - (year / 100) + (year / 400);
-}
-
-// Returns True if year is a leap year.
-static constexpr bool is_leap_year(const int64_t year) {
-  return (((year) % 4) == 0 && (((year) % 100) != 0 || ((year) % 400) == 0));
-}
-
 LLVM_LIBC_FUNCTION(time_t, mktime, (struct tm * tm_out)) {
-  // Unlike most C Library functions, mktime doesn't just die on bad input.
-  // TODO(rtenneti); Handle leap seconds.
-  int64_t tm_year_from_base = tm_out->tm_year + TimeConstants::TIME_YEAR_BASE;
-
-  // 32-bit end-of-the-world is 03:14:07 UTC on 19 January 2038.
-  if (sizeof(time_t) == 4 &&
-      tm_year_from_base >= TimeConstants::END_OF32_BIT_EPOCH_YEAR) {
-    if (tm_year_from_base > TimeConstants::END_OF32_BIT_EPOCH_YEAR)
-      return time_utils::out_of_range();
-    if (tm_out->tm_mon > 0)
-      return time_utils::out_of_range();
-    if (tm_out->tm_mday > 19)
-      return time_utils::out_of_range();
-    else if (tm_out->tm_mday == 19) {
-      if (tm_out->tm_hour > 3)
-        return time_utils::out_of_range();
-      else if (tm_out->tm_hour == 3) {
-        if (tm_out->tm_min > 14)
-          return time_utils::out_of_range();
-        else if (tm_out->tm_min == 14) {
-          if (tm_out->tm_sec > 7)
-            return time_utils::out_of_range();
-        }
-      }
-    }
-  }
-
-  // Years are ints.  A 32-bit year will fit into a 64-bit time_t.
-  // A 64-bit year will not.
-  static_assert(
-      sizeof(int) == 4,
-      "ILP64 is unimplemented. This implementation requires 32-bit integers.");
-
-  // Calculate number of months and years from tm_mon.
-  int64_t month = tm_out->tm_mon;
-  if (month < 0 || month >= TimeConstants::MONTHS_PER_YEAR - 1) {
-    int64_t years = month / 12;
-    month %= 12;
-    if (month < 0) {
-      years--;
-      month += 12;
-    }
-    tm_year_from_base += years;
-  }
-  bool tm_year_is_leap = is_leap_year(tm_year_from_base);
-
-  // Calculate total number of days based on the month and the day (tm_mday).
-  int64_t total_days = tm_out->tm_mday - 1;
-  for (int64_t i = 0; i < month; ++i)
-    total_days += NON_LEAP_YEAR_DAYS_IN_MONTH[i];
-  // Add one day if it is a leap year and the month is after February.
-  if (tm_year_is_leap && month > 1)
-    total_days++;
-
-  // Calculate total numbers of days based on the year.
-  total_days += (tm_year_from_base - TimeConstants::EPOCH_YEAR) *
-                TimeConstants::DAYS_PER_NON_LEAP_YEAR;
-  if (tm_year_from_base >= TimeConstants::EPOCH_YEAR) {
-    total_days += get_num_of_leap_years_before(tm_year_from_base - 1) -
-                  get_num_of_leap_years_before(TimeConstants::EPOCH_YEAR);
-  } else if (tm_year_from_base >= 1) {
-    total_days -= get_num_of_leap_years_before(TimeConstants::EPOCH_YEAR) -
-                  get_num_of_leap_years_before(tm_year_from_base - 1);
-  } else {
-    // Calculate number of leap years until 0th year.
-    total_days -= get_num_of_leap_years_before(TimeConstants::EPOCH_YEAR) -
-                  get_num_of_leap_years_before(0);
-    if (tm_year_from_base <= 0) {
-      total_days -= 1; // Subtract 1 for 0th year.
-      // Calculate number of leap years until -1 year
-      if (tm_year_from_base < 0) {
-        total_days -= get_num_of_leap_years_before(-tm_year_from_base) -
-                      get_num_of_leap_years_before(1);
-      }
-    }
-  }
-
-  // TODO(rtenneti): Need to handle timezone and update of tm_isdst.
-  int64_t seconds = tm_out->tm_sec +
-                    tm_out->tm_min * TimeConstants::SECONDS_PER_MIN +
-                    tm_out->tm_hour * TimeConstants::SECONDS_PER_HOUR +
-                    total_days * TimeConstants::SECONDS_PER_DAY;
+  int64_t seconds = time_utils::mktime_internal(tm_out);
 
   // Update the tm structure's year, month, day, etc. from seconds.
   if (time_utils::update_from_seconds(seconds, tm_out) < 0)
diff --git a/src/time/mktime.h b/src/time/mktime.h
index 2b4c679..985c629 100644
--- a/src/time/mktime.h
+++ b/src/time/mktime.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_TIME_MKTIME_H
 #define LLVM_LIBC_SRC_TIME_MKTIME_H
 
+#include "hdr/types/struct_tm.h"
+#include "hdr/types/time_t.h"
 #include "src/__support/macros/config.h"
-#include <time.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/time/strftime.cpp b/src/time/strftime.cpp
new file mode 100644
index 0000000..f36091b
--- /dev/null
+++ b/src/time/strftime.cpp
@@ -0,0 +1,32 @@
+//===-- Implementation of strftime function -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/strftime.h"
+#include "hdr/types/size_t.h"
+#include "hdr/types/struct_tm.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/strftime_main.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(size_t, strftime,
+                   (char *__restrict buffer, size_t buffsz,
+                    const char *__restrict format, const tm *timeptr)) {
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
+  printf_core::Writer writer(wb);
+  int ret = strftime_core::strftime_main(&writer, format, timeptr);
+  if (buffsz > 0) // if the buffsz is 0 the buffer may be a null pointer.
+    wb.buff[wb.buff_cur] = '\0';
+  return (ret < 0 || static_cast<size_t>(ret) > buffsz) ? 0 : ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/strftime.h b/src/time/strftime.h
new file mode 100644
index 0000000..dadd046
--- /dev/null
+++ b/src/time/strftime.h
@@ -0,0 +1,23 @@
+//===-- Implementation header of strftime -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_STRFTIME_H
+#define LLVM_LIBC_SRC_TIME_STRFTIME_H
+
+#include "hdr/types/size_t.h"
+#include "hdr/types/struct_tm.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+size_t strftime(char *__restrict, size_t max, const char *__restrict format,
+                const tm *timeptr);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_STRFTIME_H
diff --git a/src/time/strftime_core/composite_converter.h b/src/time/strftime_core/composite_converter.h
new file mode 100644
index 0000000..53cb7e5
--- /dev/null
+++ b/src/time/strftime_core/composite_converter.h
@@ -0,0 +1,244 @@
+//===-- Composite converter for strftime ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See htto_conv.times://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_COMPOSITE_CONVERTER_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_COMPOSITE_CONVERTER_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/core_structs.h"
+#include "src/time/strftime_core/num_converter.h"
+#include "src/time/strftime_core/str_converter.h"
+#include "src/time/time_constants.h"
+#include "src/time/time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+LIBC_INLINE IntFormatSection
+get_specific_int_format(const tm *timeptr, const FormatSection &base_to_conv,
+                        char new_conv_name, int TRAILING_CONV_LEN = -1) {
+  // a negative padding will be treated as the default
+  const int NEW_MIN_WIDTH =
+      TRAILING_CONV_LEN > 0 ? base_to_conv.min_width - TRAILING_CONV_LEN : 0;
+  FormatSection new_conv = base_to_conv;
+  new_conv.conv_name = new_conv_name;
+  new_conv.min_width = NEW_MIN_WIDTH;
+
+  IntFormatSection result = get_int_format(new_conv, timeptr);
+
+  // If the user set the padding, but it's below the width of the trailing
+  // conversions, then there should be no padding.
+  if (base_to_conv.min_width > 0 && NEW_MIN_WIDTH < 0)
+    result.pad_to_len = 0;
+
+  return result;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_date_us(printf_core::Writer<write_mode> *writer,
+                                const FormatSection &to_conv,
+                                const tm *timeptr) {
+  // format is %m/%d/%y (month/day/year)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  constexpr int TRAILING_CONV_LEN = 1 + 2 + 1 + 2; // sizeof("/01/02")
+  IntFormatSection year_conv;
+  IntFormatSection mon_conv;
+  IntFormatSection mday_conv;
+
+  mon_conv = get_specific_int_format(timeptr, to_conv, 'm', TRAILING_CONV_LEN);
+  mday_conv = get_specific_int_format(timeptr, to_conv, 'd');
+  year_conv = get_specific_int_format(timeptr, to_conv, 'y');
+
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, mon_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write('/'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, mday_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write('/'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, year_conv));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_date_iso(printf_core::Writer<write_mode> *writer,
+                                 const FormatSection &to_conv,
+                                 const tm *timeptr) {
+  // format is "%Y-%m-%d" (year-month-day)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  constexpr int TRAILING_CONV_LEN = 1 + 2 + 1 + 2; // sizeof("-01-02")
+  IntFormatSection year_conv;
+  IntFormatSection mon_conv;
+  IntFormatSection mday_conv;
+
+  year_conv = get_specific_int_format(timeptr, to_conv, 'Y', TRAILING_CONV_LEN);
+  mon_conv = get_specific_int_format(timeptr, to_conv, 'm');
+  mday_conv = get_specific_int_format(timeptr, to_conv, 'd');
+
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, year_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write('-'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, mon_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write('-'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, mday_conv));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_time_am_pm(printf_core::Writer<write_mode> *writer,
+                                   const FormatSection &to_conv,
+                                   const tm *timeptr) {
+  // format is "%I:%M:%S %p" (hour:minute:second AM/PM)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  constexpr int TRAILING_CONV_LEN =
+      1 + 2 + 1 + 2 + 1 + 2; // sizeof(":01:02 AM")
+  IntFormatSection hour_conv;
+  IntFormatSection min_conv;
+  IntFormatSection sec_conv;
+
+  const time_utils::TMReader time_reader(timeptr);
+
+  hour_conv = get_specific_int_format(timeptr, to_conv, 'I', TRAILING_CONV_LEN);
+  min_conv = get_specific_int_format(timeptr, to_conv, 'M');
+  sec_conv = get_specific_int_format(timeptr, to_conv, 'S');
+
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, hour_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(':'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, min_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(':'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, sec_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(' '));
+  RET_IF_RESULT_NEGATIVE(writer->write(time_reader.get_am_pm()));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_time_minute(printf_core::Writer<write_mode> *writer,
+                                    const FormatSection &to_conv,
+                                    const tm *timeptr) {
+  // format is "%H:%M" (hour:minute)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  constexpr int TRAILING_CONV_LEN = 1 + 2; // sizeof(":01")
+  IntFormatSection hour_conv;
+  IntFormatSection min_conv;
+
+  hour_conv = get_specific_int_format(timeptr, to_conv, 'H', TRAILING_CONV_LEN);
+  min_conv = get_specific_int_format(timeptr, to_conv, 'M');
+
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, hour_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(':'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, min_conv));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_time_second(printf_core::Writer<write_mode> *writer,
+                                    const FormatSection &to_conv,
+                                    const tm *timeptr) {
+  // format is "%H:%M:%S" (hour:minute:second)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  constexpr int TRAILING_CONV_LEN = 1 + 2 + 1 + 2; // sizeof(":01:02")
+  IntFormatSection hour_conv;
+  IntFormatSection min_conv;
+  IntFormatSection sec_conv;
+
+  hour_conv = get_specific_int_format(timeptr, to_conv, 'H', TRAILING_CONV_LEN);
+  min_conv = get_specific_int_format(timeptr, to_conv, 'M');
+  sec_conv = get_specific_int_format(timeptr, to_conv, 'S');
+
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, hour_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(':'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, min_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(':'));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, sec_conv));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_full_date_time(printf_core::Writer<write_mode> *writer,
+                                       const FormatSection &to_conv,
+                                       const tm *timeptr) {
+  const time_utils::TMReader time_reader(timeptr);
+  // format is "%a %b %e %T %Y" (weekday month mday [time] year)
+  // we only pad the first conversion, and we assume all the other values are in
+  // their valid ranges.
+  // sizeof("Sun Jan 12 03:45:06 2025")
+  constexpr int FULL_CONV_LEN = 3 + 1 + 3 + 1 + 2 + 1 + 8 + 1 + 4;
+  // use the full conv len because this isn't being passed to a proper converter
+  // that will handle the width of the leading conversion. Instead it has to be
+  // handled below.
+  const int requested_padding = to_conv.min_width - FULL_CONV_LEN;
+
+  cpp::string_view wday_str = unwrap_opt(time_reader.get_weekday_short_name());
+  cpp::string_view month_str = unwrap_opt(time_reader.get_month_short_name());
+  IntFormatSection mday_conv;
+  IntFormatSection year_conv;
+
+  mday_conv = get_specific_int_format(timeptr, to_conv, 'e');
+  year_conv = get_specific_int_format(timeptr, to_conv, 'Y');
+
+  FormatSection raw_time_conv = to_conv;
+  raw_time_conv.conv_name = 'T';
+  raw_time_conv.min_width = 0;
+
+  if (requested_padding > 0)
+    RET_IF_RESULT_NEGATIVE(writer->write(' ', requested_padding));
+  RET_IF_RESULT_NEGATIVE(writer->write(wday_str));
+  RET_IF_RESULT_NEGATIVE(writer->write(' '));
+  RET_IF_RESULT_NEGATIVE(writer->write(month_str));
+  RET_IF_RESULT_NEGATIVE(writer->write(' '));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, mday_conv));
+  RET_IF_RESULT_NEGATIVE(writer->write(' '));
+  RET_IF_RESULT_NEGATIVE(convert_time_second(writer, raw_time_conv, timeptr));
+  RET_IF_RESULT_NEGATIVE(writer->write(' '));
+  RET_IF_RESULT_NEGATIVE(write_padded_int(writer, year_conv));
+
+  return WRITE_OK;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_composite(printf_core::Writer<write_mode> *writer,
+                                  const FormatSection &to_conv,
+                                  const tm *timeptr) {
+  switch (to_conv.conv_name) {
+  case 'c': // locale specified date and time
+            // in default locale Equivalent to %a %b %e %T %Y.
+    return convert_full_date_time(writer, to_conv, timeptr);
+  case 'D': // %m/%d/%y (month/day/year)
+    return convert_date_us(writer, to_conv, timeptr);
+  case 'F': // %Y-%m-%d (year-month-day)
+    return convert_date_iso(writer, to_conv, timeptr);
+  case 'r': // %I:%M:%S %p (hour:minute:second AM/PM)
+    return convert_time_am_pm(writer, to_conv, timeptr);
+  case 'R': // %H:%M (hour:minute)
+    return convert_time_minute(writer, to_conv, timeptr);
+  case 'T': // %H:%M:%S (hour:minute:second)
+    return convert_time_second(writer, to_conv, timeptr);
+  case 'x': // locale specified date
+            // in default locale Equivalent to %m/%d/%y. (same as %D)
+    return convert_date_us(writer, to_conv, timeptr);
+  case 'X': // locale specified time
+            // in default locale Equivalent to %T.
+    return convert_time_second(writer, to_conv, timeptr);
+  default:
+    __builtin_trap(); // this should be unreachable, but trap if you hit it.
+  }
+}
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_COMPOSITE_CONVERTER_H
diff --git a/src/time/strftime_core/converter.h b/src/time/strftime_core/converter.h
new file mode 100644
index 0000000..ff0faf3
--- /dev/null
+++ b/src/time/strftime_core/converter.h
@@ -0,0 +1,105 @@
+//===-- Format specifier converter for strftime -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CONVERTER_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CONVERTER_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/core_structs.h"
+
+#include "composite_converter.h"
+#include "num_converter.h"
+#include "str_converter.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+// convert will call a conversion function to convert the FormatSection into
+// its string representation, and then that will write the result to the
+// writer.
+template <printf_core::WriteMode write_mode>
+int convert(printf_core::Writer<write_mode> *writer,
+            const FormatSection &to_conv, const tm *timeptr) {
+  // TODO: Implement the locale support.
+  // Currently locale flags are ignored, as described by the posix standard for
+  // the default locale.
+
+  if (!to_conv.has_conv)
+    return writer->write(to_conv.raw_string);
+  switch (to_conv.conv_name) {
+    // The cases are grouped by type, then alphabetized with lowercase before
+    // uppercase.
+
+    // raw conversions
+  case '%':
+    return writer->write("%");
+  case 'n':
+    return writer->write("\n");
+  case 't':
+    return writer->write("\t");
+
+    // numeric conversions
+  case 'C': // Century [00-99]
+  case 'd': // Day of the month [01-31]
+  case 'e': // Day of the month [1-31]
+  case 'g': // last 2 digits of ISO year [00-99]
+  case 'G': // ISO year
+  case 'H': // 24-hour format [00-23]
+  case 'I': // 12-hour format [01-12]
+  case 'j': // Day of the year [001-366]
+  case 'm': // Month of the year [01-12]
+  case 'M': // Minute of the hour [00-59]
+  case 's': // Seconds since the epoch
+  case 'S': // Second of the minute [00-60]
+  case 'u': // ISO day of the week ([1-7] starting Monday)
+  case 'U': // Week of the year ([00-53] week 1 starts on first *Sunday*)
+  case 'V': // ISO week number ([01-53], 01 is first week majority in this year)
+  case 'w': // Day of week ([0-6] starting Sunday)
+  case 'W': // Week of the year ([00-53] week 1 starts on first *Monday*)
+  case 'y': // Year of the Century [00-99]
+  case 'Y': // Full year
+    return convert_int(writer, to_conv, timeptr);
+
+    // string conversions
+  case 'a': // Abbreviated weekday name
+  case 'A': // Full weekday name
+  case 'b': // Abbreviated month name
+  case 'B': // Full month name
+  case 'h': // same as %b
+  case 'p': // AM/PM designation
+    return convert_str(writer, to_conv, timeptr);
+
+    // composite conversions
+  case 'c': // locale specified date and time
+  case 'D': // %m/%d/%y (month/day/year)
+  case 'F': // %Y-%m-%d (year-month-day)
+  case 'r': // %I:%M:%S %p (hour:minute:second AM/PM)
+  case 'R': // %H:%M (hour:minute)
+  case 'T': // %H:%M:%S (hour:minute:second)
+  case 'x': // locale specified date
+  case 'X': // locale specified time
+    return convert_composite(writer, to_conv, timeptr);
+
+    // timezone conversions
+  case 'z': // Timezone offset (+/-hhmm) (num conv)
+  case 'Z': // Timezone name (string conv)
+    // the standard says if no time zone is determinable, write no characters.
+    // Leave this here until time zones are implemented.
+    return 0;
+  default:
+    return writer->write(to_conv.raw_string);
+  }
+  return 0;
+}
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CONVERTER_H
diff --git a/src/time/strftime_core/core_structs.h b/src/time/strftime_core/core_structs.h
new file mode 100644
index 0000000..25bf5e6
--- /dev/null
+++ b/src/time/strftime_core/core_structs.h
@@ -0,0 +1,53 @@
+//===-- Core Structures for strftime ----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CORE_STRUCTS_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CORE_STRUCTS_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/string_view.h"
+
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+enum class ConvModifier { none, E, O };
+
+// These flags intentionally have different values from the ones used by printf.
+// They have different meanings.
+enum FormatFlags : uint8_t {
+  FORCE_SIGN = 0x01,     // +
+  LEADING_ZEROES = 0x02, // 0
+  // TODO: look into the glibc extension flags ('_', '-', '^', and '#')
+};
+
+struct FormatSection {
+  bool has_conv = false;
+  cpp::string_view raw_string = {};
+
+  FormatFlags flags = FormatFlags(0);
+  ConvModifier modifier = ConvModifier::none;
+  char conv_name = '\0';
+  int min_width = 0;
+};
+
+// TODO: Move this to a better spot
+#define RET_IF_RESULT_NEGATIVE(func)                                           \
+  {                                                                            \
+    int result = (func);                                                       \
+    if (result < 0)                                                            \
+      return result;                                                           \
+  }
+
+constexpr int WRITE_OK = 0;
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_CORE_STRUCTS_H
diff --git a/src/time/strftime_core/num_converter.h b/src/time/strftime_core/num_converter.h
new file mode 100644
index 0000000..7da9195
--- /dev/null
+++ b/src/time/strftime_core/num_converter.h
@@ -0,0 +1,201 @@
+//===-- Numeric converter for strftime --------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See htto_conv.times://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_NUM_CONVERTER_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_NUM_CONVERTER_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/integer_to_string.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/core_structs.h"
+#include "src/time/time_constants.h"
+#include "src/time/time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+using DecFmt = IntegerToString<uintmax_t>;
+
+struct IntFormatSection {
+  uintmax_t num = 0;
+  char sign_char = '\0';
+  size_t pad_to_len = 0;
+  char padding_char = '0';
+};
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int write_padded_int(printf_core::Writer<write_mode> *writer,
+                                 const IntFormatSection &num_info) {
+
+  DecFmt d(num_info.num);
+  auto str = d.view();
+
+  size_t digits_written = str.size();
+
+  // one less digit of padding if there's a sign char
+  int zeroes = static_cast<int>(num_info.pad_to_len - digits_written -
+                                (num_info.sign_char == 0 ? 0 : 1));
+
+  // Format is (sign) (padding) digits
+  if (num_info.sign_char != 0)
+    RET_IF_RESULT_NEGATIVE(writer->write(num_info.sign_char));
+  if (zeroes > 0)
+    RET_IF_RESULT_NEGATIVE(writer->write(num_info.padding_char, zeroes))
+  RET_IF_RESULT_NEGATIVE(writer->write(str));
+
+  return WRITE_OK;
+}
+
+LIBC_INLINE IntFormatSection get_int_format(const FormatSection &to_conv,
+                                            const tm *timeptr) {
+  const time_utils::TMReader time_reader(timeptr);
+
+  intmax_t raw_num;
+
+  IntFormatSection result = {0, 0, 0, '0'};
+
+  // gets_plus_sign is only true for year conversions where the year would be
+  // positive and more than 4 digits, including leading spaces. Both the
+  // FORCE_SIGN flag and gets_plus_sign must be true for a plus sign to be
+  // output.
+  bool gets_plus_sign = false;
+
+  switch (to_conv.conv_name) {
+  case 'C': // Century [00-99]
+    raw_num = time_reader.get_year() / 100;
+    gets_plus_sign = raw_num > 99 || to_conv.min_width > 2;
+    result.pad_to_len = 2;
+    break;
+  case 'd':                           // Day of the month [01-31]
+    raw_num = time_reader.get_mday(); // get_mday is 1 indexed
+    result.pad_to_len = 2;
+    break;
+  case 'e':                           // Day of the month [1-31]
+    raw_num = time_reader.get_mday(); // get_mday is 1 indexed
+    result.pad_to_len = 2;
+    result.padding_char = ' ';
+    break;
+  case 'g': // last 2 digits of ISO year [00-99]
+    raw_num = time_reader.get_iso_year() % 100;
+    result.pad_to_len = 2;
+    break;
+  case 'G': // ISO year
+    raw_num = time_reader.get_iso_year();
+    gets_plus_sign = raw_num > 9999 || to_conv.min_width > 4;
+    result.pad_to_len = 4;
+    break;
+  case 'H': // 24-hour format [00-23]
+    raw_num = time_reader.get_hour();
+    result.pad_to_len = 2;
+    break;
+  case 'I': // 12-hour format [01-12]
+    raw_num = ((time_reader.get_hour() + 11) % 12) + 1;
+    result.pad_to_len = 2;
+    break;
+  case 'j':                               // Day of the year [001-366]
+    raw_num = time_reader.get_yday() + 1; // get_yday is 0 indexed
+    result.pad_to_len = 3;
+    break;
+  case 'm':                              // Month of the year [01-12]
+    raw_num = time_reader.get_mon() + 1; // get_mon is 0 indexed
+    result.pad_to_len = 2;
+    break;
+  case 'M': // Minute of the hour [00-59]
+    raw_num = time_reader.get_min();
+    result.pad_to_len = 2;
+    break;
+  case 's': // Seconds since the epoch
+    raw_num = time_reader.get_epoch();
+    result.pad_to_len = 0;
+    break;
+  case 'S': // Second of the minute [00-60]
+    raw_num = time_reader.get_sec();
+    result.pad_to_len = 2;
+    break;
+  case 'u': // ISO day of the week ([1-7] starting Monday)
+    raw_num = time_reader.get_iso_wday() + 1;
+    // need to add 1 because get_iso_wday returns the weekday [0-6].
+    result.pad_to_len = 1;
+    break;
+  case 'U': // Week of the year ([00-53] week 1 starts on first *Sunday*)
+    // This doesn't actually end up using tm_year, despite the standard saying
+    // it's needed. The end of the current year doesn't really matter, so leap
+    // years aren't relevant. If this is wrong, please tell me what I'm missing.
+    raw_num = time_reader.get_week(time_constants::SUNDAY);
+    result.pad_to_len = 2;
+    break;
+  case 'V': // ISO week number ([01-53], 01 is first week majority in this year)
+    // This does need to know the year, since it may affect what the week of the
+    // previous year it underflows to.
+    raw_num = time_reader.get_iso_week();
+    result.pad_to_len = 2;
+    break;
+  case 'w': // Day of week ([0-6] starting Sunday)
+    raw_num = time_reader.get_wday();
+    result.pad_to_len = 1;
+    break;
+  case 'W': // Week of the year ([00-53] week 1 starts on first *Monday*)
+    raw_num = time_reader.get_week(time_constants::MONDAY);
+    result.pad_to_len = 2;
+    break;
+  case 'y': // Year of the Century [00-99]
+    raw_num = time_reader.get_year() % 100;
+    result.pad_to_len = 2;
+    break;
+  case 'Y': // Full year
+    raw_num = time_reader.get_year();
+    gets_plus_sign = raw_num > 9999 || to_conv.min_width > 4;
+    result.pad_to_len = 4;
+    break;
+  case 'z': // Timezone offset [+/-HHMM]
+    raw_num = time_reader.get_timezone_offset();
+    result.sign_char = '+'; // force the '+' sign iff raw_num is non-negative
+    result.pad_to_len = 5;  // 4 + 1 for the sign
+    break;
+  default:
+    __builtin_trap(); // this should be unreachable, but trap if you hit it.
+  }
+
+  result.num = static_cast<uintmax_t>(raw_num < 0 ? -raw_num : raw_num);
+  const bool is_negative = raw_num < 0;
+
+  // TODO: Handle locale modifiers
+
+  if ((to_conv.flags & FormatFlags::LEADING_ZEROES) ==
+      FormatFlags::LEADING_ZEROES)
+    result.padding_char = '0';
+
+  if (is_negative)
+    result.sign_char = '-';
+  else if ((to_conv.flags & FormatFlags::FORCE_SIGN) ==
+               FormatFlags::FORCE_SIGN &&
+           gets_plus_sign)
+    result.sign_char = '+';
+
+  // sign isn't a problem because we're taking the max. The result is always
+  // non-negative. Also min_width can only be 0 if it's defaulted, since 0 is a
+  // flag.
+  if (to_conv.min_width > 0)
+    result.pad_to_len = to_conv.min_width;
+
+  return result;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_int(printf_core::Writer<write_mode> *writer,
+                            const FormatSection &to_conv, const tm *timeptr) {
+
+  return write_padded_int(writer, get_int_format(to_conv, timeptr));
+}
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif
diff --git a/src/time/strftime_core/parser.h b/src/time/strftime_core/parser.h
new file mode 100644
index 0000000..659587a
--- /dev/null
+++ b/src/time/strftime_core/parser.h
@@ -0,0 +1,111 @@
+//===-- Format string parser for printf -------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_PARSER_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_PARSER_H
+
+#include "core_structs.h"
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/ctype_utils.h"
+#include "src/__support/macros/config.h"
+#include "src/__support/str_to_integer.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+class Parser {
+  const char *str;
+  size_t cur_pos = 0;
+
+public:
+  LIBC_INLINE Parser(const char *new_str) : str(new_str) {}
+
+  // get_next_section will parse the format string until it has a fully
+  // specified format section. This can either be a raw format section with no
+  // conversion, or a format section with a conversion that has all of its
+  // variables stored in the format section.
+  LIBC_INLINE FormatSection get_next_section() {
+    FormatSection section;
+    size_t starting_pos = cur_pos;
+
+    if (str[cur_pos] != '%') {
+      // raw section
+      section.has_conv = false;
+      while (str[cur_pos] != '%' && str[cur_pos] != '\0')
+        ++cur_pos;
+      section.raw_string = {str + starting_pos, cur_pos - starting_pos};
+      return section;
+    }
+
+    // format section
+    section.has_conv = true;
+    ++cur_pos;
+
+    // flags
+    section.flags = parse_flags(&cur_pos);
+
+    // handle width
+    section.min_width = 0;
+    if (internal::isdigit(str[cur_pos])) {
+      auto result = internal::strtointeger<int>(str + cur_pos, 10);
+      section.min_width = result.value;
+      cur_pos = cur_pos + result.parsed_len;
+    }
+
+    // modifiers
+    switch (str[cur_pos]) {
+    case ('E'):
+      section.modifier = ConvModifier::E;
+      ++cur_pos;
+      break;
+    case ('O'):
+      section.modifier = ConvModifier::O;
+      ++cur_pos;
+      break;
+    default:
+      section.modifier = ConvModifier::none;
+    }
+
+    section.conv_name = str[cur_pos];
+
+    // If the end of the format section is on the '\0'. This means we need to
+    // not advance the cur_pos.
+    if (str[cur_pos] != '\0')
+      ++cur_pos;
+
+    section.raw_string = {str + starting_pos, cur_pos - starting_pos};
+    return section;
+  }
+
+private:
+  LIBC_INLINE FormatFlags parse_flags(size_t *local_pos) {
+    bool found_flag = true;
+    FormatFlags flags = FormatFlags(0);
+    while (found_flag) {
+      switch (str[*local_pos]) {
+      case '+':
+        flags = static_cast<FormatFlags>(flags | FormatFlags::FORCE_SIGN);
+        break;
+      case '0':
+        flags = static_cast<FormatFlags>(flags | FormatFlags::LEADING_ZEROES);
+        break;
+      default:
+        found_flag = false;
+      }
+      if (found_flag)
+        ++*local_pos;
+    }
+    return flags;
+  }
+};
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_PARSER_H
diff --git a/src/time/strftime_core/str_converter.h b/src/time/strftime_core/str_converter.h
new file mode 100644
index 0000000..13eccd3
--- /dev/null
+++ b/src/time/strftime_core/str_converter.h
@@ -0,0 +1,77 @@
+//===-- String converter for strftime ---------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See htto_conv.times://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STR_CONVERTER_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STR_CONVERTER_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/string_view.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/core_structs.h"
+#include "src/time/time_constants.h"
+#include "src/time/time_utils.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+static constexpr cpp::string_view OUT_OF_BOUNDS_STR = "?";
+
+LIBC_INLINE cpp::string_view
+unwrap_opt(cpp::optional<cpp::string_view> str_opt) {
+  return str_opt.has_value() ? *str_opt : OUT_OF_BOUNDS_STR;
+}
+
+template <printf_core::WriteMode write_mode>
+LIBC_INLINE int convert_str(printf_core::Writer<write_mode> *writer,
+                            const FormatSection &to_conv, const tm *timeptr) {
+  cpp::string_view str;
+  cpp::optional<cpp::string_view> str_opt;
+  const time_utils::TMReader time_reader(timeptr);
+
+  switch (to_conv.conv_name) {
+  case 'a': // Abbreviated weekday name
+    str_opt = time_reader.get_weekday_short_name();
+    str = unwrap_opt(str_opt);
+    break;
+  case 'A': // Full weekday name
+    str_opt = time_reader.get_weekday_full_name();
+    str = unwrap_opt(str_opt);
+    break;
+  case 'b': // Abbreviated month name
+  case 'h': // same as 'b'
+    str_opt = time_reader.get_month_short_name();
+    str = unwrap_opt(str_opt);
+    break;
+  case 'B': // Full month name
+    str_opt = time_reader.get_month_full_name();
+    str = unwrap_opt(str_opt);
+    break;
+  case 'p': // AM/PM designation
+    str = time_reader.get_am_pm();
+    break;
+  case 'Z': // Timezone name
+    // the standard says if no time zone is determinable, write no characters.
+    return WRITE_OK;
+    // str = time_reader.get_timezone_name();
+    break;
+  default:
+    __builtin_trap(); // this should be unreachable, but trap if you hit it.
+  }
+
+  int spaces = to_conv.min_width - static_cast<int>(str.size());
+  if (spaces > 0)
+    RET_IF_RESULT_NEGATIVE(writer->write(' ', spaces));
+  RET_IF_RESULT_NEGATIVE(writer->write(str));
+
+  return WRITE_OK;
+}
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STR_CONVERTER_H
diff --git a/src/time/strftime_core/strftime_main.h b/src/time/strftime_core/strftime_main.h
new file mode 100644
index 0000000..c7e5906
--- /dev/null
+++ b/src/time/strftime_core/strftime_main.h
@@ -0,0 +1,45 @@
+//===-- Starting point for strftime ------------------------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STRFTIME_MAIN_H
+#define LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STRFTIME_MAIN_H
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/converter.h"
+#include "src/time/strftime_core/core_structs.h"
+#include "src/time/strftime_core/parser.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace strftime_core {
+
+template <printf_core::WriteMode write_mode>
+int strftime_main(printf_core::Writer<write_mode> *writer,
+                  const char *__restrict str, const tm *timeptr) {
+  Parser parser(str);
+  int result = 0;
+  for (strftime_core::FormatSection cur_section = parser.get_next_section();
+       !cur_section.raw_string.empty();
+       cur_section = parser.get_next_section()) {
+    if (cur_section.has_conv)
+      result = convert(writer, cur_section, timeptr);
+    else
+      result = writer->write(cur_section.raw_string);
+
+    if (result < 0)
+      return result;
+  }
+
+  return writer->get_chars_written();
+}
+
+} // namespace strftime_core
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_STDIO_STRFTIME_CORE_STRFTIME_MAIN_H
diff --git a/src/time/strftime_l.cpp b/src/time/strftime_l.cpp
new file mode 100644
index 0000000..201b85d
--- /dev/null
+++ b/src/time/strftime_l.cpp
@@ -0,0 +1,35 @@
+//===-- Implementation of strftime_l function -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/time/strftime_l.h"
+#include "hdr/types/locale_t.h"
+#include "hdr/types/size_t.h"
+#include "hdr/types/struct_tm.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/stdio/printf_core/writer.h"
+#include "src/time/strftime_core/strftime_main.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+// TODO: Add support for locales.
+LLVM_LIBC_FUNCTION(size_t, strftime_l,
+                   (char *__restrict buffer, size_t buffsz,
+                    const char *__restrict format, const tm *timeptr,
+                    locale_t)) {
+  printf_core::WriteBuffer<printf_core::Mode<
+      printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>::value>
+      wb(buffer, (buffsz > 0 ? buffsz - 1 : 0));
+  printf_core::Writer writer(wb);
+  int ret = strftime_core::strftime_main(&writer, format, timeptr);
+  if (buffsz > 0) // if the buffsz is 0 the buffer may be a null pointer.
+    wb.buff[wb.buff_cur] = '\0';
+  return (ret < 0 || static_cast<size_t>(ret) > buffsz) ? 0 : ret;
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/time/strftime_l.h b/src/time/strftime_l.h
new file mode 100644
index 0000000..ead7a60
--- /dev/null
+++ b/src/time/strftime_l.h
@@ -0,0 +1,24 @@
+//===-- Implementation header for strftime_l --------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_STRFTIME_L_H
+#define LLVM_LIBC_SRC_TIME_STRFTIME_L_H
+
+#include "hdr/types/locale_t.h"
+#include "hdr/types/size_t.h"
+#include "hdr/types/struct_tm.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+size_t strftime_l(char *__restrict buffer, size_t count,
+                  const char *__restrict format, const tm *timeptr, locale_t);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_STRFTIME_L_H
diff --git a/src/time/linux/time.cpp b/src/time/time.cpp
similarity index 83%
rename from src/time/linux/time.cpp
rename to src/time/time.cpp
index 20fb86e..860909a 100644
--- a/src/time/linux/time.cpp
+++ b/src/time/time.cpp
@@ -6,17 +6,18 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/time/time_func.h"
+
 #include "hdr/time_macros.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/errno/libc_errno.h"
-#include "src/time/time_func.h"
 
 namespace LIBC_NAMESPACE_DECL {
-
-LLVM_LIBC_FUNCTION(time_t, time, (time_t * tp)) {
-  // TODO: Use the Linux VDSO to fetch the time and avoid the syscall.
+// avoid inconsitent clang-format behavior
+using time_ptr_t = time_t *;
+LLVM_LIBC_FUNCTION(time_t, time, (time_ptr_t tp)) {
   struct timespec ts;
   auto result = internal::clock_gettime(CLOCK_REALTIME, &ts);
   if (!result.has_value()) {
diff --git a/src/time/time_constants.h b/src/time/time_constants.h
new file mode 100644
index 0000000..0fcb7ff
--- /dev/null
+++ b/src/time/time_constants.h
@@ -0,0 +1,117 @@
+//===-- Collection of constants for time functions --------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_TIME_CONSTANTS_H
+#define LLVM_LIBC_SRC_TIME_TIME_CONSTANTS_H
+
+#include "hdr/types/time_t.h"
+#include "src/__support/CPP/array.h"
+#include "src/__support/CPP/string_view.h"
+#include <stdint.h>
+
+namespace LIBC_NAMESPACE_DECL {
+namespace time_constants {
+
+enum Month : int {
+  JANUARY = 0,
+  FEBRUARY,
+  MARCH,
+  APRIL,
+  MAY,
+  JUNE,
+  JULY,
+  AUGUST,
+  SEPTEMBER,
+  OCTOBER,
+  NOVEMBER,
+  DECEMBER
+};
+
+enum WeekDay : int {
+  SUNDAY = 0,
+  MONDAY,
+  TUESDAY,
+  WEDNESDAY,
+  THURSDAY,
+  FRIDAY,
+  SATURDAY
+};
+
+constexpr int SECONDS_PER_MIN = 60;
+constexpr int MINUTES_PER_HOUR = 60;
+constexpr int HOURS_PER_DAY = 24;
+constexpr int DAYS_PER_WEEK = 7;
+constexpr int WEEKS_PER_YEAR = 52;
+constexpr int MONTHS_PER_YEAR = 12;
+constexpr int MAX_DAYS_PER_MONTH = 31;
+constexpr int DAYS_PER_NON_LEAP_YEAR = 365;
+constexpr int DAYS_PER_LEAP_YEAR = 366;
+
+constexpr int LAST_DAY_OF_NON_LEAP_YEAR = DAYS_PER_NON_LEAP_YEAR - 1;
+constexpr int LAST_DAY_OF_LEAP_YEAR = DAYS_PER_LEAP_YEAR - 1;
+
+constexpr int SECONDS_PER_HOUR = SECONDS_PER_MIN * MINUTES_PER_HOUR;
+constexpr int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
+constexpr int NUMBER_OF_SECONDS_IN_LEAP_YEAR =
+    DAYS_PER_LEAP_YEAR * SECONDS_PER_DAY;
+
+constexpr int TIME_YEAR_BASE = 1900;
+constexpr int EPOCH_YEAR = 1970;
+constexpr int EPOCH_WEEK_DAY = 4;
+
+constexpr int ISO_FIRST_DAY_OF_YEAR = 3; // the 4th day of the year, 0-indexed.
+
+// For asctime the behavior is undefined if struct tm's tm_wday or tm_mon are
+// not within the normal ranges as defined in <time.h>, or if struct tm's
+// tm_year exceeds {INT_MAX}-1990, or if the below asctime_internal algorithm
+// would attempt to generate more than 26 bytes of output (including the
+// terminating null).
+constexpr int ASCTIME_BUFFER_SIZE = 256;
+constexpr int ASCTIME_MAX_BYTES = 26;
+
+/* 2000-03-01 (mod 400 year, immediately after feb29 */
+constexpr int64_t SECONDS_UNTIL2000_MARCH_FIRST =
+    (946684800LL + SECONDS_PER_DAY * (31 + 29));
+constexpr int WEEK_DAY_OF2000_MARCH_FIRST = 3;
+
+constexpr int DAYS_PER400_YEARS =
+    (DAYS_PER_NON_LEAP_YEAR * 400) + (400 / 4) - 3;
+constexpr int DAYS_PER100_YEARS =
+    (DAYS_PER_NON_LEAP_YEAR * 100) + (100 / 4) - 1;
+constexpr int DAYS_PER4_YEARS = (DAYS_PER_NON_LEAP_YEAR * 4) + 1;
+
+// The latest time that can be represented in this form is 03:14:07 UTC on
+// Tuesday, 19 January 2038 (corresponding to 2,147,483,647 seconds since the
+// start of the epoch). This means that systems using a 32-bit time_t type are
+// susceptible to the Year 2038 problem.
+constexpr int END_OF32_BIT_EPOCH_YEAR = 2038;
+
+constexpr time_t OUT_OF_RANGE_RETURN_VALUE = -1;
+
+constexpr cpp::array<cpp::string_view, DAYS_PER_WEEK> WEEK_DAY_NAMES = {
+    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+
+constexpr cpp::array<cpp::string_view, DAYS_PER_WEEK> WEEK_DAY_FULL_NAMES = {
+    "Sunday",   "Monday", "Tuesday", "Wednesday",
+    "Thursday", "Friday", "Saturday"};
+
+constexpr cpp::array<cpp::string_view, MONTHS_PER_YEAR> MONTH_NAMES = {
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+
+constexpr cpp::array<cpp::string_view, MONTHS_PER_YEAR> MONTH_FULL_NAMES = {
+    "January", "February", "March",     "April",   "May",      "June",
+    "July",    "August",   "September", "October", "November", "December"};
+
+constexpr int NON_LEAP_YEAR_DAYS_IN_MONTH[] = {31, 28, 31, 30, 31, 30,
+                                               31, 31, 30, 31, 30, 31};
+
+} // namespace time_constants
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_TIME_CONSTANTS_H
diff --git a/src/time/time_utils.cpp b/src/time/time_utils.cpp
index 509cad8..3ccb2dd 100644
--- a/src/time/time_utils.cpp
+++ b/src/time/time_utils.cpp
@@ -10,11 +10,104 @@
 #include "src/__support/CPP/limits.h" // INT_MIN, INT_MAX
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
+#include "src/time/time_constants.h"
+
+#include <stdint.h>
 
 namespace LIBC_NAMESPACE_DECL {
 namespace time_utils {
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
+// TODO: clean this up in a followup patch
+int64_t mktime_internal(const tm *tm_out) {
+  // Unlike most C Library functions, mktime doesn't just die on bad input.
+  // TODO(rtenneti); Handle leap seconds.
+  int64_t tm_year_from_base = tm_out->tm_year + time_constants::TIME_YEAR_BASE;
+
+  // 32-bit end-of-the-world is 03:14:07 UTC on 19 January 2038.
+  if (sizeof(time_t) == 4 &&
+      tm_year_from_base >= time_constants::END_OF32_BIT_EPOCH_YEAR) {
+    if (tm_year_from_base > time_constants::END_OF32_BIT_EPOCH_YEAR)
+      return time_utils::out_of_range();
+    if (tm_out->tm_mon > 0)
+      return time_utils::out_of_range();
+    if (tm_out->tm_mday > 19)
+      return time_utils::out_of_range();
+    else if (tm_out->tm_mday == 19) {
+      if (tm_out->tm_hour > 3)
+        return time_utils::out_of_range();
+      else if (tm_out->tm_hour == 3) {
+        if (tm_out->tm_min > 14)
+          return time_utils::out_of_range();
+        else if (tm_out->tm_min == 14) {
+          if (tm_out->tm_sec > 7)
+            return time_utils::out_of_range();
+        }
+      }
+    }
+  }
+
+  // Years are ints.  A 32-bit year will fit into a 64-bit time_t.
+  // A 64-bit year will not.
+  static_assert(
+      sizeof(int) == 4,
+      "ILP64 is unimplemented. This implementation requires 32-bit integers.");
+
+  // Calculate number of months and years from tm_mon.
+  int64_t month = tm_out->tm_mon;
+  if (month < 0 || month >= time_constants::MONTHS_PER_YEAR - 1) {
+    int64_t years = month / 12;
+    month %= 12;
+    if (month < 0) {
+      years--;
+      month += 12;
+    }
+    tm_year_from_base += years;
+  }
+  bool tm_year_is_leap = time_utils::is_leap_year(tm_year_from_base);
+
+  // Calculate total number of days based on the month and the day (tm_mday).
+  int64_t total_days = tm_out->tm_mday - 1;
+  for (int64_t i = 0; i < month; ++i)
+    total_days += time_constants::NON_LEAP_YEAR_DAYS_IN_MONTH[i];
+  // Add one day if it is a leap year and the month is after February.
+  if (tm_year_is_leap && month > 1)
+    total_days++;
+
+  // Calculate total numbers of days based on the year.
+  total_days += (tm_year_from_base - time_constants::EPOCH_YEAR) *
+                time_constants::DAYS_PER_NON_LEAP_YEAR;
+  if (tm_year_from_base >= time_constants::EPOCH_YEAR) {
+    total_days +=
+        time_utils::get_num_of_leap_years_before(tm_year_from_base - 1) -
+        time_utils::get_num_of_leap_years_before(time_constants::EPOCH_YEAR);
+  } else if (tm_year_from_base >= 1) {
+    total_days -=
+        time_utils::get_num_of_leap_years_before(time_constants::EPOCH_YEAR) -
+        time_utils::get_num_of_leap_years_before(tm_year_from_base - 1);
+  } else {
+    // Calculate number of leap years until 0th year.
+    total_days -=
+        time_utils::get_num_of_leap_years_before(time_constants::EPOCH_YEAR) -
+        time_utils::get_num_of_leap_years_before(0);
+    if (tm_year_from_base <= 0) {
+      total_days -= 1; // Subtract 1 for 0th year.
+      // Calculate number of leap years until -1 year
+      if (tm_year_from_base < 0) {
+        total_days -=
+            time_utils::get_num_of_leap_years_before(-tm_year_from_base) -
+            time_utils::get_num_of_leap_years_before(1);
+      }
+    }
+  }
+
+  // TODO: https://github.com/llvm/llvm-project/issues/121962
+  // Need to handle timezone and update of tm_isdst.
+  int64_t seconds = tm_out->tm_sec +
+                    tm_out->tm_min * time_constants::SECONDS_PER_MIN +
+                    tm_out->tm_hour * time_constants::SECONDS_PER_HOUR +
+                    total_days * time_constants::SECONDS_PER_DAY;
+  return seconds;
+}
 
 static int64_t computeRemainingYears(int64_t daysPerYears,
                                      int64_t quotientYears,
@@ -43,7 +136,7 @@ static int64_t computeRemainingYears(int64_t daysPerYears,
 //
 // Compute the number of months from the remaining days. Finally, adjust years
 // to be 1900 and months to be from January.
-int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
+int64_t update_from_seconds(int64_t total_seconds, tm *tm) {
   // Days in month starting from March in the year 2000.
   static const char daysInMonth[] = {31 /* Mar */, 30, 31, 30, 31, 31,
                                      30,           31, 30, 31, 31, 29};
@@ -52,36 +145,36 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
       (sizeof(time_t) == 4)
           ? INT_MIN
           : INT_MIN * static_cast<int64_t>(
-                          TimeConstants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
+                          time_constants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
   constexpr time_t time_max =
       (sizeof(time_t) == 4)
           ? INT_MAX
           : INT_MAX * static_cast<int64_t>(
-                          TimeConstants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
+                          time_constants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
 
   time_t ts = static_cast<time_t>(total_seconds);
   if (ts < time_min || ts > time_max)
     return time_utils::out_of_range();
 
   int64_t seconds =
-      total_seconds - TimeConstants::SECONDS_UNTIL2000_MARCH_FIRST;
-  int64_t days = seconds / TimeConstants::SECONDS_PER_DAY;
-  int64_t remainingSeconds = seconds % TimeConstants::SECONDS_PER_DAY;
+      total_seconds - time_constants::SECONDS_UNTIL2000_MARCH_FIRST;
+  int64_t days = seconds / time_constants::SECONDS_PER_DAY;
+  int64_t remainingSeconds = seconds % time_constants::SECONDS_PER_DAY;
   if (remainingSeconds < 0) {
-    remainingSeconds += TimeConstants::SECONDS_PER_DAY;
+    remainingSeconds += time_constants::SECONDS_PER_DAY;
     days--;
   }
 
-  int64_t wday = (TimeConstants::WEEK_DAY_OF2000_MARCH_FIRST + days) %
-                 TimeConstants::DAYS_PER_WEEK;
+  int64_t wday = (time_constants::WEEK_DAY_OF2000_MARCH_FIRST + days) %
+                 time_constants::DAYS_PER_WEEK;
   if (wday < 0)
-    wday += TimeConstants::DAYS_PER_WEEK;
+    wday += time_constants::DAYS_PER_WEEK;
 
   // Compute the number of 400 year cycles.
-  int64_t numOfFourHundredYearCycles = days / TimeConstants::DAYS_PER400_YEARS;
-  int64_t remainingDays = days % TimeConstants::DAYS_PER400_YEARS;
+  int64_t numOfFourHundredYearCycles = days / time_constants::DAYS_PER400_YEARS;
+  int64_t remainingDays = days % time_constants::DAYS_PER400_YEARS;
   if (remainingDays < 0) {
-    remainingDays += TimeConstants::DAYS_PER400_YEARS;
+    remainingDays += time_constants::DAYS_PER400_YEARS;
     numOfFourHundredYearCycles--;
   }
 
@@ -89,17 +182,17 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
   // "four hundred year cycles" will be 4 hundred year cycles or less in 400
   // years.
   int64_t numOfHundredYearCycles = computeRemainingYears(
-      TimeConstants::DAYS_PER100_YEARS, 4, &remainingDays);
+      time_constants::DAYS_PER100_YEARS, 4, &remainingDays);
 
   // The remaining number of years after computing the number of
   // "hundred year cycles" will be 25 four year cycles or less in 100 years.
-  int64_t numOfFourYearCycles =
-      computeRemainingYears(TimeConstants::DAYS_PER4_YEARS, 25, &remainingDays);
+  int64_t numOfFourYearCycles = computeRemainingYears(
+      time_constants::DAYS_PER4_YEARS, 25, &remainingDays);
 
   // The remaining number of years after computing the number of
   // "four year cycles" will be 4 one year cycles or less in 4 years.
   int64_t remainingYears = computeRemainingYears(
-      TimeConstants::DAYS_PER_NON_LEAP_YEAR, 4, &remainingDays);
+      time_constants::DAYS_PER_NON_LEAP_YEAR, 4, &remainingDays);
 
   // Calculate number of years from year 2000.
   int64_t years = remainingYears + 4 * numOfFourYearCycles +
@@ -112,8 +205,8 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
   // We add 31 and 28 for the number of days in January and February, since our
   // starting point was March 1st.
   int64_t yday = remainingDays + 31 + 28 + leapDay;
-  if (yday >= TimeConstants::DAYS_PER_NON_LEAP_YEAR + leapDay)
-    yday -= TimeConstants::DAYS_PER_NON_LEAP_YEAR + leapDay;
+  if (yday >= time_constants::DAYS_PER_NON_LEAP_YEAR + leapDay)
+    yday -= time_constants::DAYS_PER_NON_LEAP_YEAR + leapDay;
 
   int64_t months = 0;
   while (daysInMonth[months] <= remainingDays) {
@@ -121,8 +214,8 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
     months++;
   }
 
-  if (months >= TimeConstants::MONTHS_PER_YEAR - 2) {
-    months -= TimeConstants::MONTHS_PER_YEAR;
+  if (months >= time_constants::MONTHS_PER_YEAR - 2) {
+    months -= time_constants::MONTHS_PER_YEAR;
     years++;
   }
 
@@ -131,19 +224,19 @@ int64_t update_from_seconds(int64_t total_seconds, struct tm *tm) {
 
   // All the data (years, month and remaining days) was calculated from
   // March, 2000. Thus adjust the data to be from January, 1900.
-  tm->tm_year = static_cast<int>(years + 2000 - TimeConstants::TIME_YEAR_BASE);
+  tm->tm_year = static_cast<int>(years + 2000 - time_constants::TIME_YEAR_BASE);
   tm->tm_mon = static_cast<int>(months + 2);
   tm->tm_mday = static_cast<int>(remainingDays + 1);
   tm->tm_wday = static_cast<int>(wday);
   tm->tm_yday = static_cast<int>(yday);
 
   tm->tm_hour =
-      static_cast<int>(remainingSeconds / TimeConstants::SECONDS_PER_HOUR);
+      static_cast<int>(remainingSeconds / time_constants::SECONDS_PER_HOUR);
   tm->tm_min =
-      static_cast<int>(remainingSeconds / TimeConstants::SECONDS_PER_MIN %
-                       TimeConstants::SECONDS_PER_MIN);
+      static_cast<int>(remainingSeconds / time_constants::SECONDS_PER_MIN %
+                       time_constants::SECONDS_PER_MIN);
   tm->tm_sec =
-      static_cast<int>(remainingSeconds % TimeConstants::SECONDS_PER_MIN);
+      static_cast<int>(remainingSeconds % time_constants::SECONDS_PER_MIN);
   // TODO(rtenneti): Need to handle timezone and update of tm_isdst.
   tm->tm_isdst = 0;
 
diff --git a/src/time/time_utils.h b/src/time/time_utils.h
index 552ea92..68eaac8 100644
--- a/src/time/time_utils.h
+++ b/src/time/time_utils.h
@@ -9,82 +9,28 @@
 #ifndef LLVM_LIBC_SRC_TIME_TIME_UTILS_H
 #define LLVM_LIBC_SRC_TIME_TIME_UTILS_H
 
-#include <stddef.h> // For size_t.
-
+#include "hdr/types/size_t.h"
+#include "hdr/types/struct_tm.h"
+#include "hdr/types/time_t.h"
+#include "src/__support/CPP/optional.h"
+#include "src/__support/CPP/string_view.h"
 #include "src/__support/common.h"
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include "src/time/mktime.h"
+#include "time_constants.h"
 
 #include <stdint.h>
 
 namespace LIBC_NAMESPACE_DECL {
 namespace time_utils {
 
-enum Month : int {
-  JANUARY,
-  FEBRUARY,
-  MARCH,
-  APRIL,
-  MAY,
-  JUNE,
-  JULY,
-  AUGUST,
-  SEPTEMBER,
-  OCTOBER,
-  NOVEMBER,
-  DECEMBER
-};
-
-struct TimeConstants {
-  static constexpr int SECONDS_PER_MIN = 60;
-  static constexpr int MINUTES_PER_HOUR = 60;
-  static constexpr int HOURS_PER_DAY = 24;
-  static constexpr int DAYS_PER_WEEK = 7;
-  static constexpr int MONTHS_PER_YEAR = 12;
-  static constexpr int DAYS_PER_NON_LEAP_YEAR = 365;
-  static constexpr int DAYS_PER_LEAP_YEAR = 366;
-
-  static constexpr int SECONDS_PER_HOUR = SECONDS_PER_MIN * MINUTES_PER_HOUR;
-  static constexpr int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
-  static constexpr int NUMBER_OF_SECONDS_IN_LEAP_YEAR =
-      DAYS_PER_LEAP_YEAR * SECONDS_PER_DAY;
-
-  static constexpr int TIME_YEAR_BASE = 1900;
-  static constexpr int EPOCH_YEAR = 1970;
-  static constexpr int EPOCH_WEEK_DAY = 4;
-
-  // For asctime the behavior is undefined if struct tm's tm_wday or tm_mon are
-  // not within the normal ranges as defined in <time.h>, or if struct tm's
-  // tm_year exceeds {INT_MAX}-1990, or if the below asctime_internal algorithm
-  // would attempt to generate more than 26 bytes of output (including the
-  // terminating null).
-  static constexpr int ASCTIME_BUFFER_SIZE = 256;
-  static constexpr int ASCTIME_MAX_BYTES = 26;
-
-  /* 2000-03-01 (mod 400 year, immediately after feb29 */
-  static constexpr int64_t SECONDS_UNTIL2000_MARCH_FIRST =
-      (946684800LL + SECONDS_PER_DAY * (31 + 29));
-  static constexpr int WEEK_DAY_OF2000_MARCH_FIRST = 3;
-
-  static constexpr int DAYS_PER400_YEARS =
-      (DAYS_PER_NON_LEAP_YEAR * 400) + (400 / 4) - 3;
-  static constexpr int DAYS_PER100_YEARS =
-      (DAYS_PER_NON_LEAP_YEAR * 100) + (100 / 4) - 1;
-  static constexpr int DAYS_PER4_YEARS = (DAYS_PER_NON_LEAP_YEAR * 4) + 1;
-
-  // The latest time that can be represented in this form is 03:14:07 UTC on
-  // Tuesday, 19 January 2038 (corresponding to 2,147,483,647 seconds since the
-  // start of the epoch). This means that systems using a 32-bit time_t type are
-  // susceptible to the Year 2038 problem.
-  static constexpr int END_OF32_BIT_EPOCH_YEAR = 2038;
-
-  static constexpr time_t OUT_OF_RANGE_RETURN_VALUE = -1;
-};
+// calculates the seconds from the epoch for tm_in. Does not update the struct,
+// you must call update_from_seconds for that.
+int64_t mktime_internal(const tm *tm_out);
 
 // Update the "tm" structure's year, month, etc. members from seconds.
 // "total_seconds" is the number of seconds since January 1st, 1970.
-extern int64_t update_from_seconds(int64_t total_seconds, struct tm *tm);
+int64_t update_from_seconds(int64_t total_seconds, tm *tm);
 
 // TODO(michaelrj): move these functions to use ErrorOr instead of setting
 // errno. They always accompany a specific return value so we only need the one
@@ -98,44 +44,36 @@ LIBC_INLINE time_t out_of_range() {
   // require it.
   libc_errno = EOVERFLOW;
 #endif
-  return TimeConstants::OUT_OF_RANGE_RETURN_VALUE;
+  return time_constants::OUT_OF_RANGE_RETURN_VALUE;
 }
 
 LIBC_INLINE void invalid_value() { libc_errno = EINVAL; }
 
-LIBC_INLINE char *asctime(const struct tm *timeptr, char *buffer,
+LIBC_INLINE char *asctime(const tm *timeptr, char *buffer,
                           size_t bufferLength) {
   if (timeptr == nullptr || buffer == nullptr) {
     invalid_value();
     return nullptr;
   }
   if (timeptr->tm_wday < 0 ||
-      timeptr->tm_wday > (TimeConstants::DAYS_PER_WEEK - 1)) {
+      timeptr->tm_wday > (time_constants::DAYS_PER_WEEK - 1)) {
     invalid_value();
     return nullptr;
   }
   if (timeptr->tm_mon < 0 ||
-      timeptr->tm_mon > (TimeConstants::MONTHS_PER_YEAR - 1)) {
+      timeptr->tm_mon > (time_constants::MONTHS_PER_YEAR - 1)) {
     invalid_value();
     return nullptr;
   }
 
-  // TODO(rtenneti): i18n the following strings.
-  static const char *week_days_name[TimeConstants::DAYS_PER_WEEK] = {
-      "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
-
-  static const char *months_name[TimeConstants::MONTHS_PER_YEAR] = {
-      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
-
-  // TODO(michaelr): look into removing this call to __builtin_snprintf that may
-  // be emitted as a call to snprintf. Alternatively, look into using our
-  // internal printf machinery.
+  // TODO(michaelr): move this to use the strftime machinery
+  // equivalent to strftime(buffer, bufferLength, "%a %b %T %Y\n", timeptr)
   int written_size = __builtin_snprintf(
       buffer, bufferLength, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
-      week_days_name[timeptr->tm_wday], months_name[timeptr->tm_mon],
-      timeptr->tm_mday, timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec,
-      TimeConstants::TIME_YEAR_BASE + timeptr->tm_year);
+      time_constants::WEEK_DAY_NAMES[timeptr->tm_wday].data(),
+      time_constants::MONTH_NAMES[timeptr->tm_mon].data(), timeptr->tm_mday,
+      timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec,
+      time_constants::TIME_YEAR_BASE + timeptr->tm_year);
   if (written_size < 0)
     return nullptr;
   if (static_cast<size_t>(written_size) >= bufferLength) {
@@ -145,7 +83,7 @@ LIBC_INLINE char *asctime(const struct tm *timeptr, char *buffer,
   return buffer;
 }
 
-LIBC_INLINE struct tm *gmtime_internal(const time_t *timer, struct tm *result) {
+LIBC_INLINE tm *gmtime_internal(const time_t *timer, tm *result) {
   int64_t seconds = *timer;
   // Update the tm structure's year, month, day, etc. from seconds.
   if (update_from_seconds(seconds, result) < 0) {
@@ -158,11 +96,252 @@ LIBC_INLINE struct tm *gmtime_internal(const time_t *timer, struct tm *result) {
 
 // TODO: localtime is not yet implemented and a temporary solution is to
 //       use gmtime, https://github.com/llvm/llvm-project/issues/107597
-LIBC_INLINE struct tm *localtime(const time_t *t_ptr) {
-  static struct tm result;
+LIBC_INLINE tm *localtime(const time_t *t_ptr) {
+  static tm result;
   return time_utils::gmtime_internal(t_ptr, &result);
 }
 
+// Returns number of years from (1, year).
+LIBC_INLINE constexpr int64_t get_num_of_leap_years_before(int64_t year) {
+  return (year / 4) - (year / 100) + (year / 400);
+}
+
+// Returns True if year is a leap year.
+LIBC_INLINE constexpr bool is_leap_year(const int64_t year) {
+  return (((year) % 4) == 0 && (((year) % 100) != 0 || ((year) % 400) == 0));
+}
+
+LIBC_INLINE constexpr int get_days_in_year(const int year) {
+  return is_leap_year(year) ? time_constants::DAYS_PER_LEAP_YEAR
+                            : time_constants::DAYS_PER_NON_LEAP_YEAR;
+}
+
+// This is a helper class that takes a struct tm and lets you inspect its
+// values. Where relevant, results are bounds checked and returned as optionals.
+// This class does not, however, do data normalization except where necessary.
+// It will faithfully return a date of 9999-99-99, even though that makes no
+// sense.
+class TMReader final {
+  const tm *timeptr;
+
+  template <size_t N>
+  LIBC_INLINE constexpr cpp::optional<cpp::string_view>
+  bounds_check(const cpp::array<cpp::string_view, N> &arr, int index) const {
+    if (index >= 0 && index < static_cast<int>(arr.size()))
+      return arr[index];
+    return cpp::nullopt;
+  }
+
+public:
+  LIBC_INLINE constexpr explicit TMReader(const tm *tmptr) : timeptr(tmptr) {}
+
+  // Strings
+  LIBC_INLINE constexpr cpp::optional<cpp::string_view>
+  get_weekday_short_name() const {
+    return bounds_check(time_constants::WEEK_DAY_NAMES, timeptr->tm_wday);
+  }
+
+  LIBC_INLINE constexpr cpp::optional<cpp::string_view>
+  get_weekday_full_name() const {
+    return bounds_check(time_constants::WEEK_DAY_FULL_NAMES, timeptr->tm_wday);
+  }
+
+  LIBC_INLINE constexpr cpp::optional<cpp::string_view>
+  get_month_short_name() const {
+    return bounds_check(time_constants::MONTH_NAMES, timeptr->tm_mon);
+  }
+
+  LIBC_INLINE constexpr cpp::optional<cpp::string_view>
+  get_month_full_name() const {
+    return bounds_check(time_constants::MONTH_FULL_NAMES, timeptr->tm_mon);
+  }
+
+  LIBC_INLINE constexpr cpp::string_view get_am_pm() const {
+    if (timeptr->tm_hour < 12)
+      return "AM";
+    return "PM";
+  }
+
+  LIBC_INLINE constexpr cpp::string_view get_timezone_name() const {
+    // TODO: timezone support
+    return "UTC";
+  }
+
+  // Numbers
+  LIBC_INLINE constexpr int get_sec() const { return timeptr->tm_sec; }
+  LIBC_INLINE constexpr int get_min() const { return timeptr->tm_min; }
+  LIBC_INLINE constexpr int get_hour() const { return timeptr->tm_hour; }
+  LIBC_INLINE constexpr int get_mday() const { return timeptr->tm_mday; }
+  LIBC_INLINE constexpr int get_mon() const { return timeptr->tm_mon; }
+  LIBC_INLINE constexpr int get_yday() const { return timeptr->tm_yday; }
+  LIBC_INLINE constexpr int get_wday() const { return timeptr->tm_wday; }
+  LIBC_INLINE constexpr int get_isdst() const { return timeptr->tm_isdst; }
+
+  // returns the year, counting from 1900
+  LIBC_INLINE constexpr int get_year_raw() const { return timeptr->tm_year; }
+  // returns the year, counting from 0
+  LIBC_INLINE constexpr int get_year() const {
+    return timeptr->tm_year + time_constants::TIME_YEAR_BASE;
+  }
+
+  LIBC_INLINE constexpr int is_leap_year() const {
+    return time_utils::is_leap_year(get_year());
+  }
+
+  LIBC_INLINE constexpr int get_iso_wday() const {
+    using time_constants::DAYS_PER_WEEK;
+    using time_constants::MONDAY;
+    // ISO uses a week that starts on Monday, but struct tm starts its week on
+    // Sunday. This function normalizes the weekday so that it always returns a
+    // value 0-6
+    const int NORMALIZED_WDAY = timeptr->tm_wday % DAYS_PER_WEEK;
+    return (NORMALIZED_WDAY + (DAYS_PER_WEEK - MONDAY)) % DAYS_PER_WEEK;
+  }
+
+  // returns the week of the current year, with weeks starting on start_day.
+  LIBC_INLINE constexpr int get_week(time_constants::WeekDay start_day) const {
+    using time_constants::DAYS_PER_WEEK;
+    // The most recent start_day. The rest of the days into the current week
+    // don't count, so ignore them.
+    // Also add 7 to handle start_day > tm_wday
+    const int start_of_cur_week =
+        timeptr->tm_yday -
+        ((timeptr->tm_wday + DAYS_PER_WEEK - start_day) % DAYS_PER_WEEK);
+
+    // The original formula is ceil((start_of_cur_week + 1) / DAYS_PER_WEEK)
+    // That becomes (start_of_cur_week + 1 + DAYS_PER_WEEK - 1) / DAYS_PER_WEEK)
+    // Which simplifies to (start_of_cur_week + DAYS_PER_WEEK) / DAYS_PER_WEEK
+    const int ceil_weeks_since_start =
+        (start_of_cur_week + DAYS_PER_WEEK) / DAYS_PER_WEEK;
+
+    return ceil_weeks_since_start;
+  }
+
+  LIBC_INLINE constexpr int get_iso_week() const {
+    using time_constants::DAYS_PER_WEEK;
+    using time_constants::ISO_FIRST_DAY_OF_YEAR;
+    using time_constants::MONDAY;
+    using time_constants::WeekDay;
+    using time_constants::WEEKS_PER_YEAR;
+
+    constexpr WeekDay START_DAY = MONDAY;
+
+    // The most recent start_day. The rest of the days into the current week
+    // don't count, so ignore them.
+    // Also add 7 to handle start_day > tm_wday
+    const int start_of_cur_week =
+        timeptr->tm_yday -
+        ((timeptr->tm_wday + DAYS_PER_WEEK - START_DAY) % DAYS_PER_WEEK);
+
+    // if the week starts in the previous year, and also if the 4th of this year
+    // is not in this week.
+    if (start_of_cur_week < -3) {
+      const int days_into_prev_year =
+          get_days_in_year(get_year() - 1) + start_of_cur_week;
+      // Each year has at least 52 weeks, but a year's last week will be 53 if
+      // its first week starts in the previous year and its last week ends
+      // in the next year. We know get_year() - 1 must extend into get_year(),
+      // so here we check if it also extended into get_year() - 2 and add 1 week
+      // if it does.
+      return WEEKS_PER_YEAR +
+             ((days_into_prev_year % DAYS_PER_WEEK) > ISO_FIRST_DAY_OF_YEAR);
+    }
+
+    // subtract 1 to account for yday being 0 indexed
+    const int days_until_end_of_year =
+        get_days_in_year(get_year()) - start_of_cur_week - 1;
+
+    // if there are less than 3 days from the start of this week to the end of
+    // the year, then there must be 4 days in this week in the next year, which
+    // means that this week is the first week of that year.
+    if (days_until_end_of_year < 3)
+      return 1;
+
+    // else just calculate the current week like normal.
+    const int ceil_weeks_since_start =
+        (start_of_cur_week + DAYS_PER_WEEK) / DAYS_PER_WEEK;
+
+    // add 1 if this year's first week starts in the previous year.
+    const int WEEK_STARTS_IN_PREV_YEAR =
+        ((start_of_cur_week + time_constants::DAYS_PER_WEEK) %
+         time_constants::DAYS_PER_WEEK) > time_constants::ISO_FIRST_DAY_OF_YEAR;
+    return ceil_weeks_since_start + WEEK_STARTS_IN_PREV_YEAR;
+  }
+
+  LIBC_INLINE constexpr int get_iso_year() const {
+    const int BASE_YEAR = get_year();
+    // The ISO year is the same as a standard year for all dates after the start
+    // of the first week and before the last week. Since the first ISO week of a
+    // year starts on the 4th, anything after that is in this year.
+    if (timeptr->tm_yday >= time_constants::ISO_FIRST_DAY_OF_YEAR &&
+        timeptr->tm_yday < time_constants::DAYS_PER_NON_LEAP_YEAR -
+                               time_constants::DAYS_PER_WEEK)
+      return BASE_YEAR;
+
+    const int ISO_WDAY = get_iso_wday();
+    // The first week of the ISO year is defined as the week containing the
+    // 4th day of January.
+
+    // first week
+    if (timeptr->tm_yday < time_constants::ISO_FIRST_DAY_OF_YEAR) {
+      /*
+      If jan 4 is in this week, then we're in BASE_YEAR, else we're in the
+      previous year. The formula's been rearranged so here's the derivation:
+
+              +--------+-- days until jan 4
+              |        |
+       wday + (4 - yday) < 7
+       |               |
+       +---------------+-- weekday of jan 4
+
+       rearranged to get all the constants on one side:
+
+       wday - yday < 7 - 4
+      */
+      const int IS_CUR_YEAR = (ISO_WDAY - timeptr->tm_yday <
+                               time_constants::DAYS_PER_WEEK -
+                                   time_constants::ISO_FIRST_DAY_OF_YEAR);
+      return BASE_YEAR - !IS_CUR_YEAR;
+    }
+
+    // last week
+    const int DAYS_LEFT_IN_YEAR =
+        get_days_in_year(get_year()) - timeptr->tm_yday;
+    /*
+    Similar to above, we're checking if jan 4 (of next year) is in this week. If
+    it is, this is in the next year. Note that this also handles the case of
+    yday > days in year gracefully.
+
+           +------------------+-- days until jan 4 (of next year)
+           |                  |
+    wday + (4 + remaining days) < 7
+    |                         |
+    +-------------------------+-- weekday of jan 4
+
+    rearranging we get:
+
+    wday + remaining days < 7 - 4
+    */
+    const int IS_NEXT_YEAR =
+        (ISO_WDAY + DAYS_LEFT_IN_YEAR <
+         time_constants::DAYS_PER_WEEK - time_constants::ISO_FIRST_DAY_OF_YEAR);
+    return BASE_YEAR + IS_NEXT_YEAR;
+  }
+
+  LIBC_INLINE time_t get_epoch() const {
+    return static_cast<time_t>(mktime_internal(timeptr));
+  }
+
+  // returns the timezone offset in microwave time:
+  // return (hours * 100) + minutes;
+  // This means that a shift of -4:30 is returned as -430, simplifying
+  // conversion.
+  LIBC_INLINE constexpr int get_timezone_offset() const {
+    // TODO: timezone support
+    return 0;
+  }
+};
+
 } // namespace time_utils
 } // namespace LIBC_NAMESPACE_DECL
 
diff --git a/src/time/timespec_get.h b/src/time/timespec_get.h
new file mode 100644
index 0000000..2a176ff
--- /dev/null
+++ b/src/time/timespec_get.h
@@ -0,0 +1,21 @@
+//===-- Implementation header of timespec_get -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_TIME_TIMESPEC_GET_H
+#define LLVM_LIBC_SRC_TIME_TIMESPEC_GET_H
+
+#include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+int timespec_get(struct timespec *ts, int base);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_TIME_TIMESPEC_GET_H
diff --git a/src/time/windows/clock_getres.cpp b/src/time/windows/clock_getres.cpp
new file mode 100644
index 0000000..b8c0c82
--- /dev/null
+++ b/src/time/windows/clock_getres.cpp
@@ -0,0 +1,110 @@
+//===-- Windows implementation of clock_getres ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/errno_macros.h"
+#include "hdr/time_macros.h"
+#include "hdr/types/clockid_t.h"
+#include "hdr/types/struct_timespec.h"
+
+#include "src/__support/CPP/limits.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/optimization.h"
+#include "src/__support/time/units.h"
+#include "src/__support/time/windows/performance_counter.h"
+#include "src/errno/libc_errno.h"
+#include "src/time/clock_getres.h"
+
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+
+// add in dependencies for GetSystemTimeAdjustmentPrecise
+#pragma comment(lib, "mincore.lib")
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(int, clock_getres, (clockid_t id, struct timespec *res)) {
+  using namespace time_units;
+  // POSIX allows nullptr to be passed as res, in which case the function should
+  // do nothing.
+  if (res == nullptr)
+    return 0;
+  constexpr unsigned long long HNS_PER_SEC = 1_s_ns / 100ULL;
+  constexpr unsigned long long SEC_LIMIT =
+      cpp::numeric_limits<decltype(res->tv_sec)>::max();
+  // For CLOCK_MONOTONIC, we are using performance counter
+  // https://learn.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps
+  // Hence, the resolution is given by the performance counter frequency.
+  // For CLOCK_REALTIME, the precision is given by
+  // GetSystemTimeAdjustmentPrecise
+  // (https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeadjustmentprecise)
+  // For CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID, the precision is
+  // given by GetSystemTimeAdjustment
+  // (https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeadjustment)
+  switch (id) {
+  default:
+    libc_errno = EINVAL;
+    return -1;
+
+  case CLOCK_MONOTONIC: {
+    long long freq = performance_counter::get_ticks_per_second();
+    __builtin_assume(freq != 0);
+    // division of 1 second by frequency, rounded up.
+    long long tv_sec = static_cast<long long>(freq == 1);
+    long long tv_nsec =
+        LIBC_LIKELY(freq != 1) ? 1ll + ((1_s_ns - 1ll) / freq) : 0ll;
+    // not possible to overflow tv_sec, tv_nsec
+    res->tv_sec = static_cast<decltype(res->tv_sec)>(tv_sec);
+    res->tv_nsec = static_cast<decltype(res->tv_nsec)>(tv_nsec);
+    break;
+  }
+
+  case CLOCK_REALTIME: {
+    [[clang::uninitialized]] DWORD64 time_adjustment;
+    [[clang::uninitialized]] DWORD64 time_increment;
+    [[clang::uninitialized]] BOOL time_adjustment_disabled;
+    if (!::GetSystemTimeAdjustmentPrecise(&time_adjustment, &time_increment,
+                                          &time_adjustment_disabled)) {
+      libc_errno = EINVAL;
+      return -1;
+    }
+    DWORD64 tv_sec = time_increment / HNS_PER_SEC;
+    DWORD64 tv_nsec = (time_increment % HNS_PER_SEC) * 100ULL;
+    if (LIBC_UNLIKELY(tv_sec > SEC_LIMIT)) {
+      libc_errno = EOVERFLOW;
+      return -1;
+    }
+    res->tv_sec = static_cast<decltype(res->tv_sec)>(tv_sec);
+    res->tv_nsec = static_cast<decltype(res->tv_nsec)>(tv_nsec);
+    break;
+  }
+  case CLOCK_PROCESS_CPUTIME_ID:
+  case CLOCK_THREAD_CPUTIME_ID: {
+    [[clang::uninitialized]] DWORD time_adjustment;
+    [[clang::uninitialized]] DWORD time_increment;
+    [[clang::uninitialized]] BOOL time_adjustment_disabled;
+    if (!::GetSystemTimeAdjustment(&time_adjustment, &time_increment,
+                                   &time_adjustment_disabled)) {
+      libc_errno = EINVAL;
+      return -1;
+    }
+    DWORD hns_per_sec = static_cast<DWORD>(HNS_PER_SEC);
+    DWORD sec_limit = static_cast<DWORD>(SEC_LIMIT);
+    DWORD tv_sec = time_increment / hns_per_sec;
+    DWORD tv_nsec = (time_increment % hns_per_sec) * 100UL;
+    if (LIBC_UNLIKELY(tv_sec > sec_limit)) {
+      libc_errno = EOVERFLOW;
+      return -1;
+    }
+    res->tv_sec = static_cast<decltype(res->tv_sec)>(tv_sec);
+    res->tv_nsec = static_cast<decltype(res->tv_nsec)>(tv_nsec);
+    break;
+  }
+  }
+  return 0;
+}
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/dup.h b/src/unistd/dup.h
index 63f093c..5760145 100644
--- a/src/unistd/dup.h
+++ b/src/unistd/dup.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP_H
 #define LLVM_LIBC_SRC_UNISTD_DUP_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/dup2.h b/src/unistd/dup2.h
index 060c112..e2cf623 100644
--- a/src/unistd/dup2.h
+++ b/src/unistd/dup2.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP2_H
 #define LLVM_LIBC_SRC_UNISTD_DUP2_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/dup3.h b/src/unistd/dup3.h
index f386886..06d9b23 100644
--- a/src/unistd/dup3.h
+++ b/src/unistd/dup3.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_DUP3_H
 #define LLVM_LIBC_SRC_UNISTD_DUP3_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/fork.h b/src/unistd/fork.h
index b6fd576..a9f8a97 100644
--- a/src/unistd/fork.h
+++ b/src/unistd/fork.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FORK_H
 #define LLVM_LIBC_SRC_UNISTD_FORK_H
 
+#include "hdr/types/pid_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/ftruncate.h b/src/unistd/ftruncate.h
index cd8d363..95901c8 100644
--- a/src/unistd/ftruncate.h
+++ b/src/unistd/ftruncate.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_FTRUNCATE_H
 #define LLVM_LIBC_SRC_UNISTD_FTRUNCATE_H
 
+#include "hdr/types/off_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getcwd.h b/src/unistd/getcwd.h
index 8b63a91..3943c02 100644
--- a/src/unistd/getcwd.h
+++ b/src/unistd/getcwd.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETCWD_H
 #define LLVM_LIBC_SRC_UNISTD_GETCWD_H
 
+#include "hdr/types/size_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getentropy.h b/src/unistd/getentropy.h
new file mode 100644
index 0000000..27e13d2
--- /dev/null
+++ b/src/unistd/getentropy.h
@@ -0,0 +1,19 @@
+//===-- Implementation header for getentropy ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/size_t.h"
+#include "src/__support/common.h"
+
+#ifndef LLVM_LIBC_SRC_UNISTD_GETENTROPY_H
+#define LLVM_LIBC_SRC_UNISTD_GETENTROPY_H
+
+namespace LIBC_NAMESPACE_DECL {
+int getentropy(void *buffer, size_t length);
+}
+
+#endif // LLVM_LIBC_SRC_UNISTD_GETENTROPY_H
diff --git a/src/unistd/geteuid.h b/src/unistd/geteuid.h
index 9469797..6827266 100644
--- a/src/unistd/geteuid.h
+++ b/src/unistd/geteuid.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETEUID_H
 #define LLVM_LIBC_SRC_UNISTD_GETEUID_H
 
+#include "hdr/types/uid_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getopt.h b/src/unistd/getopt.h
index 1be3331..0be639d 100644
--- a/src/unistd/getopt.h
+++ b/src/unistd/getopt.h
@@ -10,8 +10,8 @@
 #define LLVM_LIBC_SRC_UNISTD_GETOPT_H
 
 #include "hdr/types/FILE.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getpid.h b/src/unistd/getpid.h
index c3c55b0..9e2f156 100644
--- a/src/unistd/getpid.h
+++ b/src/unistd/getpid.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETPID_H
 #define LLVM_LIBC_SRC_UNISTD_GETPID_H
 
+#include "hdr/types/pid_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getppid.h b/src/unistd/getppid.h
index d820791..8243fa9 100644
--- a/src/unistd/getppid.h
+++ b/src/unistd/getppid.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETPPID_H
 #define LLVM_LIBC_SRC_UNISTD_GETPPID_H
 
+#include "hdr/types/pid_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/getsid.h b/src/unistd/getsid.h
new file mode 100644
index 0000000..e788b5d
--- /dev/null
+++ b/src/unistd/getsid.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for getsid ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_GETSID_H
+#define LLVM_LIBC_SRC_UNISTD_GETSID_H
+
+#include "hdr/types/pid_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+pid_t getsid(pid_t);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_GETSID_H
diff --git a/src/unistd/getuid.h b/src/unistd/getuid.h
index dd82c71..f8b3731 100644
--- a/src/unistd/getuid.h
+++ b/src/unistd/getuid.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_GETUID_H
 #define LLVM_LIBC_SRC_UNISTD_GETUID_H
 
+#include "hdr/types/uid_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/isatty.h b/src/unistd/isatty.h
index 6dd1b7b..5c8be65 100644
--- a/src/unistd/isatty.h
+++ b/src/unistd/isatty.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_ISATTY_H
 #define LLVM_LIBC_SRC_UNISTD_ISATTY_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/link.h b/src/unistd/link.h
index 9b27aa1..c1c26c5 100644
--- a/src/unistd/link.h
+++ b/src/unistd/link.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_LINK_H
 #define LLVM_LIBC_SRC_UNISTD_LINK_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/linux/dup2.cpp b/src/unistd/linux/dup2.cpp
index c7c7c1a..7ffc151 100644
--- a/src/unistd/linux/dup2.cpp
+++ b/src/unistd/linux/dup2.cpp
@@ -32,7 +32,6 @@ LLVM_LIBC_FUNCTION(int, dup2, (int oldfd, int newfd)) {
     int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl, oldfd, F_GETFD);
 #elif defined(SYS_fcntl64)
     // Same as fcntl but can handle large offsets
-    static_assert(sizeof(off_t) == 8);
     int ret = LIBC_NAMESPACE::syscall_impl<int>(SYS_fcntl64, oldfd, F_GETFD);
 #else
 #error "SYS_fcntl and SYS_fcntl64 syscalls not available."
diff --git a/src/unistd/linux/ftruncate.cpp b/src/unistd/linux/ftruncate.cpp
index 39cb3b5..ccbb063 100644
--- a/src/unistd/linux/ftruncate.cpp
+++ b/src/unistd/linux/ftruncate.cpp
@@ -11,11 +11,11 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/linux/getentropy.cpp b/src/unistd/linux/getentropy.cpp
new file mode 100644
index 0000000..168a119
--- /dev/null
+++ b/src/unistd/linux/getentropy.cpp
@@ -0,0 +1,51 @@
+//===-- Linux implementation of getentropy --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/getentropy.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/OSUtil/syscall.h"
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+LLVM_LIBC_FUNCTION(int, getentropy, (void *buffer, size_t length)) {
+  // check the length limit
+  if (length > 256) {
+    libc_errno = EIO;
+    return -1;
+  }
+
+  char *cursor = static_cast<char *>(buffer);
+  while (length != 0) {
+    // 0 flag means urandom and blocking, which meets the assumption of
+    // getentropy
+    auto ret = syscall_impl<long>(SYS_getrandom, cursor, length, 0);
+
+    // on success, advance the buffer pointer
+    if (ret >= 0) {
+      length -= static_cast<size_t>(ret);
+      cursor += ret;
+      continue;
+    }
+
+    auto error = -static_cast<int>(ret);
+
+    // on EINTR, try again
+    if (error == EINTR)
+      continue;
+
+    // on ENOSYS, forward errno and exit;
+    // otherwise, set EIO and exit
+    libc_errno = (error == ENOSYS) ? ENOSYS : EIO;
+    return -1;
+  }
+  return 0;
+}
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/sys/mman/linux/process_mrelease.cpp b/src/unistd/linux/getsid.cpp
similarity index 57%
rename from src/sys/mman/linux/process_mrelease.cpp
rename to src/unistd/linux/getsid.cpp
index 7660f1e..5977c5b 100644
--- a/src/sys/mman/linux/process_mrelease.cpp
+++ b/src/unistd/linux/getsid.cpp
@@ -1,4 +1,4 @@
-//===---------- Linux implementation of the mrelease function -----------===//
+//===-- Linux implementation of getsid-------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,36 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/sys/mman/process_mrelease.h"
+#include "src/unistd/getsid.h"
 
+#include "hdr/types/pid_t.h"
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
-
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
-#include <linux/param.h> // For EXEC_PAGESIZE.
 #include <sys/syscall.h> // For syscall numbers.
 
 namespace LIBC_NAMESPACE_DECL {
 
-LLVM_LIBC_FUNCTION(int, process_mrelease, (int pidfd, unsigned int flags)) {
-#ifdef SYS_process_mrelease
-  long ret =
-      LIBC_NAMESPACE::syscall_impl<int>(SYS_process_mrelease, pidfd, flags);
-
+LLVM_LIBC_FUNCTION(pid_t, getsid, (pid_t pid)) {
+  pid_t ret = LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_getsid, pid);
   if (ret < 0) {
     libc_errno = static_cast<int>(-ret);
     return -1;
   }
-
-  return 0;
-#else
-  // The system call is not available.
-  (void)pidfd;
-  (void)flags;
-  libc_errno = ENOSYS;
-  return -1;
-#endif
+  return ret;
 }
 
 } // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/lseek.cpp b/src/unistd/linux/lseek.cpp
index 9486cec..0e95749 100644
--- a/src/unistd/linux/lseek.cpp
+++ b/src/unistd/linux/lseek.cpp
@@ -14,8 +14,8 @@
 #include "src/__support/OSUtil/syscall.h" // For internal syscall function.
 #include "src/__support/common.h"
 
+#include "hdr/types/off_t.h"
 #include <sys/syscall.h> // For syscall numbers.
-#include <unistd.h>      // For off_t.
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/linux/setsid.cpp b/src/unistd/linux/setsid.cpp
new file mode 100644
index 0000000..df4629b
--- /dev/null
+++ b/src/unistd/linux/setsid.cpp
@@ -0,0 +1,24 @@
+//===-- Linux implementation of setsid-------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/setsid.h"
+
+#include "hdr/types/pid_t.h"
+#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+
+#include <sys/syscall.h> // For syscall numbers.
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(pid_t, setsid, ()) {
+  return LIBC_NAMESPACE::syscall_impl<pid_t>(SYS_setsid);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/linux/sysconf.cpp b/src/unistd/linux/sysconf.cpp
index 1540eb4..f785ff3 100644
--- a/src/unistd/linux/sysconf.cpp
+++ b/src/unistd/linux/sysconf.cpp
@@ -10,11 +10,11 @@
 
 #include "src/__support/common.h"
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 #include "src/sys/auxv/getauxval.h"
 #include <sys/auxv.h>
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/linux/truncate.cpp b/src/unistd/linux/truncate.cpp
index 283cf40..8236edb 100644
--- a/src/unistd/linux/truncate.cpp
+++ b/src/unistd/linux/truncate.cpp
@@ -13,9 +13,9 @@
 #include "src/__support/macros/config.h"
 #include "src/errno/libc_errno.h"
 
+#include "hdr/unistd_macros.h"
 #include <stdint.h>      // For uint64_t.
 #include <sys/syscall.h> // For syscall numbers.
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/lseek.h b/src/unistd/lseek.h
index a8704ec..e844273 100644
--- a/src/unistd/lseek.h
+++ b/src/unistd/lseek.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_LSEEK_H
 #define LLVM_LIBC_SRC_UNISTD_LSEEK_H
 
+#include "hdr/types/off_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/pread.h b/src/unistd/pread.h
index 4723675..f8b66c5 100644
--- a/src/unistd/pread.h
+++ b/src/unistd/pread.h
@@ -9,8 +9,11 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_PREAD_H
 #define LLVM_LIBC_SRC_UNISTD_PREAD_H
 
+#include "hdr/types/off_t.h"
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/pwrite.h b/src/unistd/pwrite.h
index baffbe4..08ebb89 100644
--- a/src/unistd/pwrite.h
+++ b/src/unistd/pwrite.h
@@ -9,8 +9,11 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_PWRITE_H
 #define LLVM_LIBC_SRC_UNISTD_PWRITE_H
 
+#include "hdr/types/off_t.h"
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/read.h b/src/unistd/read.h
index 01231cb..5d35273 100644
--- a/src/unistd/read.h
+++ b/src/unistd/read.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READ_H
 #define LLVM_LIBC_SRC_UNISTD_READ_H
 
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/readlink.h b/src/unistd/readlink.h
index a73e974..b63643e 100644
--- a/src/unistd/readlink.h
+++ b/src/unistd/readlink.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READLINK_H
 #define LLVM_LIBC_SRC_UNISTD_READLINK_H
 
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/readlinkat.h b/src/unistd/readlinkat.h
index 6bdd48b..0f5657e 100644
--- a/src/unistd/readlinkat.h
+++ b/src/unistd/readlinkat.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_READLINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_READLINKAT_H
 
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/setsid.h b/src/unistd/setsid.h
new file mode 100644
index 0000000..44dd7dd
--- /dev/null
+++ b/src/unistd/setsid.h
@@ -0,0 +1,21 @@
+//===-- Implementation header for setsid ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_UNISTD_GETPID_H
+#define LLVM_LIBC_SRC_UNISTD_GETPID_H
+
+#include "hdr/types/pid_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+pid_t setsid();
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_UNISTD_GETPID_H
diff --git a/src/unistd/swab.h b/src/unistd/swab.h
index caa9c71..f6fa341 100644
--- a/src/unistd/swab.h
+++ b/src/unistd/swab.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SWAB_H
 #define LLVM_LIBC_SRC_UNISTD_SWAB_H
 
+#include "hdr/types/ssize_t.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h> // For ssize_t
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/symlink.h b/src/unistd/symlink.h
index 47f04f8..c743a32 100644
--- a/src/unistd/symlink.h
+++ b/src/unistd/symlink.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYMLINK_H
 #define LLVM_LIBC_SRC_UNISTD_SYMLINK_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/symlinkat.h b/src/unistd/symlinkat.h
index 9f8ad51..6697ce4 100644
--- a/src/unistd/symlinkat.h
+++ b/src/unistd/symlinkat.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYMLINKAT_H
 #define LLVM_LIBC_SRC_UNISTD_SYMLINKAT_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/syscall.h b/src/unistd/syscall.h
index db70745..7f82bd8 100644
--- a/src/unistd/syscall.h
+++ b/src/unistd/syscall.h
@@ -9,9 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYSCALL_H
 #define LLVM_LIBC_SRC_UNISTD_SYSCALL_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
 #include <stdarg.h>
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/sysconf.h b/src/unistd/sysconf.h
index 1b3f39e..470c4d8 100644
--- a/src/unistd/sysconf.h
+++ b/src/unistd/sysconf.h
@@ -9,8 +9,8 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_SYSCONF_H
 #define LLVM_LIBC_SRC_UNISTD_SYSCONF_H
 
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/truncate.h b/src/unistd/truncate.h
index 9ba5cf8..1e10663 100644
--- a/src/unistd/truncate.h
+++ b/src/unistd/truncate.h
@@ -9,8 +9,9 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_TRUNCATE_H
 #define LLVM_LIBC_SRC_UNISTD_TRUNCATE_H
 
+#include "hdr/types/off_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/unistd/windows/getentropy.cpp b/src/unistd/windows/getentropy.cpp
new file mode 100644
index 0000000..bfaec72
--- /dev/null
+++ b/src/unistd/windows/getentropy.cpp
@@ -0,0 +1,42 @@
+//===-- Windows implementation of getentropy ------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/getentropy.h"
+#include "hdr/errno_macros.h"
+#include "src/__support/common.h"
+#include "src/errno/libc_errno.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <bcrypt.h>
+#include <ntstatus.h>
+#pragma comment(lib, "bcrypt.lib")
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(int, getentropy, (void *buffer, size_t length)) {
+  __try {
+    // check the length limit
+    if (length > 256)
+      __leave;
+
+    NTSTATUS result = ::BCryptGenRandom(nullptr, static_cast<PUCHAR>(buffer),
+                                        static_cast<ULONG>(length),
+                                        BCRYPT_USE_SYSTEM_PREFERRED_RNG);
+
+    if (result == STATUS_SUCCESS)
+      return 0;
+
+  } __except (EXCEPTION_EXECUTE_HANDLER) {
+    // no need to handle exceptions specially
+  }
+
+  libc_errno = EIO;
+  return -1;
+}
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/unistd/write.h b/src/unistd/write.h
index e40ce19..c5ba6bf 100644
--- a/src/unistd/write.h
+++ b/src/unistd/write.h
@@ -9,8 +9,10 @@
 #ifndef LLVM_LIBC_SRC_UNISTD_WRITE_H
 #define LLVM_LIBC_SRC_UNISTD_WRITE_H
 
+#include "hdr/types/size_t.h"
+#include "hdr/types/ssize_t.h"
+#include "hdr/unistd_macros.h"
 #include "src/__support/macros/config.h"
-#include <unistd.h>
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/src/wchar/wcslen.cpp b/src/wchar/wcslen.cpp
new file mode 100644
index 0000000..5889e27
--- /dev/null
+++ b/src/wchar/wcslen.cpp
@@ -0,0 +1,23 @@
+//===-- Implementation of wcslen ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/wchar/wcslen.h"
+
+#include "hdr/types/size_t.h"
+#include "hdr/types/wchar_t.h"
+#include "src/__support/common.h"
+#include "src/__support/macros/config.h"
+#include "src/string/string_utils.h" // string_length_trivial
+
+namespace LIBC_NAMESPACE_DECL {
+
+LLVM_LIBC_FUNCTION(size_t, wcslen, (const wchar_t *src)) {
+  return internal::string_length(src);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/src/wchar/wcslen.h b/src/wchar/wcslen.h
new file mode 100644
index 0000000..8b2e7f5
--- /dev/null
+++ b/src/wchar/wcslen.h
@@ -0,0 +1,22 @@
+//===-- Implementation header for wcslen ----------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_SRC_WCHAR_WCSLEN_H
+#define LLVM_LIBC_SRC_WCHAR_WCSLEN_H
+
+#include "hdr/types/size_t.h"
+#include "hdr/types/wchar_t.h"
+#include "src/__support/macros/config.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+size_t wcslen(const wchar_t *src);
+
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_SRC_WCHAR_WCSLEN_H
diff --git a/test/UnitTest/ErrnoCheckingTest.h b/test/UnitTest/ErrnoCheckingTest.h
new file mode 100644
index 0000000..3d3b72f
--- /dev/null
+++ b/test/UnitTest/ErrnoCheckingTest.h
@@ -0,0 +1,40 @@
+//===-- ErrnoCheckingTest.h ------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===---------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_UNITTEST_ERRNOCHECKINGTEST_H
+#define LLVM_LIBC_TEST_UNITTEST_ERRNOCHECKINGTEST_H
+
+#include "src/__support/macros/config.h"
+#include "src/errno/libc_errno.h"
+#include "test/UnitTest/Test.h"
+
+namespace LIBC_NAMESPACE_DECL {
+namespace testing {
+
+// Provides a test fixture for tests that validate modifications of the errno.
+// It clears out the errno at the beginning of the test (e.g. in case it
+// contained the value pre-set by the system), and confirms it's still zero
+// at the end of the test, forcing the test author to explicitly account for all
+// non-zero values.
+class ErrnoCheckingTest : public Test {
+public:
+  void SetUp() override {
+    Test::SetUp();
+    LIBC_NAMESPACE::libc_errno = 0;
+  }
+
+  void TearDown() override {
+    ASSERT_ERRNO_SUCCESS();
+    Test::TearDown();
+  }
+};
+
+} // namespace testing
+} // namespace LIBC_NAMESPACE_DECL
+
+#endif // LLVM_LIBC_TEST_UNITTEST_ERRNOCHECKINGTEST_H
diff --git a/test/UnitTest/ErrnoSetterMatcher.h b/test/UnitTest/ErrnoSetterMatcher.h
index a895c50..c6eadd2 100644
--- a/test/UnitTest/ErrnoSetterMatcher.h
+++ b/test/UnitTest/ErrnoSetterMatcher.h
@@ -101,9 +101,13 @@ public:
 
     if constexpr (!ignore_errno()) {
       if (!errno_cmp.compare(actual_errno)) {
-        tlog << "Expected errno to be " << errno_cmp.str() << " \""
-             << get_error_string(errno_cmp.expected) << "\" but got \""
-             << get_error_string(actual_errno) << "\".\n";
+        auto expected_str = try_get_errno_name(errno_cmp.expected);
+        auto actual_str = try_get_errno_name(actual_errno);
+        tlog << "Expected errno to be " << errno_cmp.str() << " "
+             << (expected_str ? *expected_str : "<unknown>") << "("
+             << errno_cmp.expected << ") but got "
+             << (actual_str ? *actual_str : "<unknown>") << "(" << actual_errno
+             << ").\n";
       }
     }
   }
diff --git a/test/UnitTest/ExecuteFunction.h b/test/UnitTest/ExecuteFunction.h
index 511249b..93ab6e9 100644
--- a/test/UnitTest/ExecuteFunction.h
+++ b/test/UnitTest/ExecuteFunction.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_TEST_UNITTEST_EXECUTEFUNCTION_H
 #define LLVM_LIBC_TEST_UNITTEST_EXECUTEFUNCTION_H
 
+#include "src/__support/CPP/limits.h"
 #include "src/__support/macros/config.h"
 #include <stdint.h>
 
@@ -25,7 +26,7 @@ struct ProcessStatus {
   int platform_defined;
   const char *failure = nullptr;
 
-  static constexpr unsigned TIMEOUT = ~0U;
+  static constexpr int TIMEOUT = cpp::numeric_limits<int>::max();
 
   static ProcessStatus error(const char *error) { return {0, error}; }
   static ProcessStatus timed_out_ps() {
@@ -41,9 +42,8 @@ struct ProcessStatus {
   int get_fatal_signal();
 };
 
-ProcessStatus
-invoke_in_subprocess(FunctionCaller *func,
-                     unsigned timeout_ms = ProcessStatus::TIMEOUT);
+ProcessStatus invoke_in_subprocess(FunctionCaller *func,
+                                   int timeout_ms = ProcessStatus::TIMEOUT);
 
 const char *signal_as_string(int signum);
 
diff --git a/test/UnitTest/ExecuteFunctionUnix.cpp b/test/UnitTest/ExecuteFunctionUnix.cpp
index 3a657c0..c0e85c2 100644
--- a/test/UnitTest/ExecuteFunctionUnix.cpp
+++ b/test/UnitTest/ExecuteFunctionUnix.cpp
@@ -8,13 +8,13 @@
 
 #include "ExecuteFunction.h"
 #include "src/__support/macros/config.h"
-#include <cassert>
-#include <cstdlib>
-#include <cstring>
-#include <iostream>
-#include <memory>
+#include "test/UnitTest/ExecuteFunction.h" // FunctionCaller
+#include <assert.h>
 #include <poll.h>
 #include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <sys/wait.h>
 #include <unistd.h>
 
@@ -34,22 +34,26 @@ int ProcessStatus::get_fatal_signal() {
   return WTERMSIG(platform_defined);
 }
 
-ProcessStatus invoke_in_subprocess(FunctionCaller *func, unsigned timeout_ms) {
-  std::unique_ptr<FunctionCaller> X(func);
+ProcessStatus invoke_in_subprocess(FunctionCaller *func, int timeout_ms) {
   int pipe_fds[2];
-  if (::pipe(pipe_fds) == -1)
+  if (::pipe(pipe_fds) == -1) {
+    delete func;
     return ProcessStatus::error("pipe(2) failed");
+  }
 
   // Don't copy the buffers into the child process and print twice.
-  std::cout.flush();
-  std::cerr.flush();
+  ::fflush(stderr);
+  ::fflush(stdout);
   pid_t pid = ::fork();
-  if (pid == -1)
+  if (pid == -1) {
+    delete func;
     return ProcessStatus::error("fork(2) failed");
+  }
 
   if (!pid) {
     (*func)();
-    std::exit(0);
+    delete func;
+    ::exit(0);
   }
   ::close(pipe_fds[1]);
 
@@ -58,11 +62,14 @@ ProcessStatus invoke_in_subprocess(FunctionCaller *func, unsigned timeout_ms) {
   };
   // No events requested so this call will only return after the timeout or if
   // the pipes peer was closed, signaling the process exited.
-  if (::poll(&poll_fd, 1, timeout_ms) == -1)
+  if (::poll(&poll_fd, 1, timeout_ms) == -1) {
+    delete func;
     return ProcessStatus::error("poll(2) failed");
+  }
   // If the pipe wasn't closed by the child yet then timeout has expired.
   if (!(poll_fd.revents & POLLHUP)) {
     ::kill(pid, SIGKILL);
+    delete func;
     return ProcessStatus::timed_out_ps();
   }
 
@@ -70,9 +77,12 @@ ProcessStatus invoke_in_subprocess(FunctionCaller *func, unsigned timeout_ms) {
   // Wait on the pid of the subprocess here so it gets collected by the system
   // and doesn't turn into a zombie.
   pid_t status = ::waitpid(pid, &wstatus, 0);
-  if (status == -1)
+  if (status == -1) {
+    delete func;
     return ProcessStatus::error("waitpid(2) failed");
+  }
   assert(status == pid);
+  delete func;
   return {wstatus};
 }
 
diff --git a/test/UnitTest/FPExceptMatcher.cpp b/test/UnitTest/FPExceptMatcher.cpp
index 37ba0a0..d660660 100644
--- a/test/UnitTest/FPExceptMatcher.cpp
+++ b/test/UnitTest/FPExceptMatcher.cpp
@@ -9,11 +9,11 @@
 #include "FPExceptMatcher.h"
 
 #include "src/__support/macros/config.h"
+#include "test/UnitTest/ExecuteFunction.h" // FunctionCaller
 #include "test/UnitTest/Test.h"
 
 #include "hdr/types/fenv_t.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
-#include <memory>
 #include <setjmp.h>
 #include <signal.h>
 
@@ -37,14 +37,14 @@ static void sigfpeHandler(int sig) {
 }
 
 FPExceptMatcher::FPExceptMatcher(FunctionCaller *func) {
-  auto oldSIGFPEHandler = signal(SIGFPE, &sigfpeHandler);
-  std::unique_ptr<FunctionCaller> funcUP(func);
+  auto *oldSIGFPEHandler = signal(SIGFPE, &sigfpeHandler);
 
   caughtExcept = false;
   fenv_t oldEnv;
   fputil::get_env(&oldEnv);
   if (sigsetjmp(jumpBuffer, 1) == 0)
-    funcUP->call();
+    func->call();
+  delete func;
   // We restore the previous floating point environment after
   // the call to the function which can potentially raise SIGFPE.
   fputil::set_env(&oldEnv);
diff --git a/test/UnitTest/FPMatcher.h b/test/UnitTest/FPMatcher.h
index 9f2bae3..21b8a45 100644
--- a/test/UnitTest/FPMatcher.h
+++ b/test/UnitTest/FPMatcher.h
@@ -11,7 +11,6 @@
 
 #include "src/__support/CPP/array.h"
 #include "src/__support/CPP/type_traits.h"
-#include "src/__support/CPP/type_traits/is_complex.h"
 #include "src/__support/FPUtil/FEnvImpl.h"
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/__support/FPUtil/fpbits_str.h"
@@ -131,11 +130,11 @@ public:
     else if constexpr (cpp::is_complex_type_same<T, _Complex long double>())
       return matchComplex<long double>();
 #ifdef LIBC_TYPES_HAS_CFLOAT16
-    else if constexpr (cpp::is_complex_type_same<T, cfloat16>)
+    else if constexpr (cpp::is_complex_type_same<T, cfloat16>())
       return matchComplex<float16>();
 #endif
 #ifdef LIBC_TYPES_HAS_CFLOAT128
-    else if constexpr (cpp::is_complex_type_same<T, cfloat128>)
+    else if constexpr (cpp::is_complex_type_same<T, cfloat128>())
       return matchComplex<float128>();
 #endif
   }
@@ -148,11 +147,11 @@ public:
     else if constexpr (cpp::is_complex_type_same<T, _Complex long double>())
       return explainErrorComplex<long double>();
 #ifdef LIBC_TYPES_HAS_CFLOAT16
-    else if constexpr (cpp::is_complex_type_same<T, cfloat16>)
+    else if constexpr (cpp::is_complex_type_same<T, cfloat16>())
       return explainErrorComplex<float16>();
 #endif
 #ifdef LIBC_TYPES_HAS_CFLOAT128
-    else if constexpr (cpp::is_complex_type_same<T, cfloat128>)
+    else if constexpr (cpp::is_complex_type_same<T, cfloat128>())
       return explainErrorComplex<float128>();
 #endif
   }
@@ -331,27 +330,6 @@ private:
     EXPECT_FP_EXCEPTION(expected_except);                                      \
   } while (0)
 
-#define EXPECT_FP_EQ_ALL_ROUNDING(expected, actual)                            \
-  do {                                                                         \
-    using namespace LIBC_NAMESPACE::fputil::testing;                           \
-    ForceRoundingMode __r1(RoundingMode::Nearest);                             \
-    if (__r1.success) {                                                        \
-      EXPECT_FP_EQ((expected), (actual));                                      \
-    }                                                                          \
-    ForceRoundingMode __r2(RoundingMode::Upward);                              \
-    if (__r2.success) {                                                        \
-      EXPECT_FP_EQ((expected), (actual));                                      \
-    }                                                                          \
-    ForceRoundingMode __r3(RoundingMode::Downward);                            \
-    if (__r3.success) {                                                        \
-      EXPECT_FP_EQ((expected), (actual));                                      \
-    }                                                                          \
-    ForceRoundingMode __r4(RoundingMode::TowardZero);                          \
-    if (__r4.success) {                                                        \
-      EXPECT_FP_EQ((expected), (actual));                                      \
-    }                                                                          \
-  } while (0)
-
 #define EXPECT_FP_EQ_ROUNDING_MODE(expected, actual, rounding_mode)            \
   do {                                                                         \
     using namespace LIBC_NAMESPACE::fputil::testing;                           \
@@ -373,6 +351,61 @@ private:
 #define EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO(expected, actual)                    \
   EXPECT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::TowardZero)
 
+#define EXPECT_FP_EQ_ALL_ROUNDING_1(expected, actual)                          \
+  do {                                                                         \
+    EXPECT_FP_EQ_ROUNDING_NEAREST((expected), (actual));                       \
+    EXPECT_FP_EQ_ROUNDING_UPWARD((expected), (actual));                        \
+    EXPECT_FP_EQ_ROUNDING_DOWNWARD((expected), (actual));                      \
+    EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO((expected), (actual));                   \
+  } while (0)
+
+#define EXPECT_FP_EQ_ALL_ROUNDING_4(expected_nearest, expected_upward,         \
+                                    expected_downward, expected_toward_zero,   \
+                                    actual)                                    \
+  do {                                                                         \
+    EXPECT_FP_EQ_ROUNDING_NEAREST((expected_nearest), (actual));               \
+    EXPECT_FP_EQ_ROUNDING_UPWARD((expected_upward), (actual));                 \
+    EXPECT_FP_EQ_ROUNDING_DOWNWARD((expected_downward), (actual));             \
+    EXPECT_FP_EQ_ROUNDING_TOWARD_ZERO((expected_toward_zero), (actual));       \
+  } while (0)
+
+#define EXPECT_FP_EQ_ALL_ROUNDING_UNSUPPORTED(...)                             \
+  static_assert(false, "Unsupported number of arguments")
+
+#define EXPECT_FP_EQ_ALL_ROUNDING_GET_6TH_ARG(ARG1, ARG2, ARG3, ARG4, ARG5,    \
+                                              ARG6, ...)                       \
+  ARG6
+
+#define EXPECT_FP_EQ_ALL_ROUNDING_SELECTION(...)                               \
+  EXPECT_FP_EQ_ALL_ROUNDING_GET_6TH_ARG(                                       \
+      __VA_ARGS__, EXPECT_FP_EQ_ALL_ROUNDING_4,                                \
+      EXPECT_FP_EQ_ALL_ROUNDING_UNSUPPORTED,                                   \
+      EXPECT_FP_EQ_ALL_ROUNDING_UNSUPPORTED, EXPECT_FP_EQ_ALL_ROUNDING_1)
+
+#define EXPECT_FP_EQ_ALL_ROUNDING(...)                                         \
+  EXPECT_FP_EQ_ALL_ROUNDING_SELECTION(__VA_ARGS__)(__VA_ARGS__)
+
+#define ASSERT_FP_EQ_ROUNDING_MODE(expected, actual, rounding_mode)            \
+  do {                                                                         \
+    using namespace LIBC_NAMESPACE::fputil::testing;                           \
+    ForceRoundingMode __r((rounding_mode));                                    \
+    if (__r.success) {                                                         \
+      ASSERT_FP_EQ((expected), (actual));                                      \
+    }                                                                          \
+  } while (0)
+
+#define ASSERT_FP_EQ_ROUNDING_NEAREST(expected, actual)                        \
+  ASSERT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::Nearest)
+
+#define ASSERT_FP_EQ_ROUNDING_UPWARD(expected, actual)                         \
+  ASSERT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::Upward)
+
+#define ASSERT_FP_EQ_ROUNDING_DOWNWARD(expected, actual)                       \
+  ASSERT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::Downward)
+
+#define ASSERT_FP_EQ_ROUNDING_TOWARD_ZERO(expected, actual)                    \
+  ASSERT_FP_EQ_ROUNDING_MODE((expected), (actual), RoundingMode::TowardZero)
+
 #define EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_MODE(                             \
     expected, actual, expected_except, rounding_mode)                          \
   do {                                                                         \
diff --git a/test/UnitTest/HermeticTestUtils.cpp b/test/UnitTest/HermeticTestUtils.cpp
index 47f813b..a9494af 100644
--- a/test/UnitTest/HermeticTestUtils.cpp
+++ b/test/UnitTest/HermeticTestUtils.cpp
@@ -33,6 +33,8 @@ int atexit(void (*func)(void));
 
 } // namespace LIBC_NAMESPACE_DECL
 
+constexpr uint64_t ALIGNMENT = alignof(uintptr_t);
+
 namespace {
 
 // Integration tests cannot use the SCUDO standalone allocator as SCUDO pulls
@@ -42,7 +44,7 @@ namespace {
 // which just hands out continuous blocks from a statically allocated chunk of
 // memory.
 static constexpr uint64_t MEMORY_SIZE = 65336;
-static uint8_t memory[MEMORY_SIZE];
+alignas(ALIGNMENT) static uint8_t memory[MEMORY_SIZE];
 static uint8_t *ptr = memory;
 
 } // anonymous namespace
@@ -74,8 +76,6 @@ void *memset(void *ptr, int value, size_t count) {
 // This is needed if the test was compiled with '-fno-use-cxa-atexit'.
 int atexit(void (*func)(void)) { return LIBC_NAMESPACE::atexit(func); }
 
-constexpr uint64_t ALIGNMENT = alignof(uintptr_t);
-
 void *malloc(size_t s) {
   // Keep the bump pointer aligned on an eight byte boundary.
   s = ((s + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;
diff --git a/test/UnitTest/LibcDeathTestExecutors.cpp b/test/UnitTest/LibcDeathTestExecutors.cpp
index 77b0559..943e2c2 100644
--- a/test/UnitTest/LibcDeathTestExecutors.cpp
+++ b/test/UnitTest/LibcDeathTestExecutors.cpp
@@ -12,7 +12,7 @@
 #include "test/UnitTest/ExecuteFunction.h"
 #include "test/UnitTest/TestLogger.h"
 
-#include <cassert>
+#include <assert.h>
 
 namespace {
 constexpr unsigned TIMEOUT_MS = 10000;
diff --git a/test/UnitTest/LibcTest.cpp b/test/UnitTest/LibcTest.cpp
index afb1368..fec4598 100644
--- a/test/UnitTest/LibcTest.cpp
+++ b/test/UnitTest/LibcTest.cpp
@@ -158,13 +158,13 @@ int Test::runTests(const TestOptions &Options) {
     }
 
     tlog << green << "[ RUN      ] " << reset << TestName << '\n';
-    [[maybe_unused]] const uint64_t start_time = clock();
+    [[maybe_unused]] const uint64_t start_time = static_cast<uint64_t>(clock());
     RunContext Ctx;
     T->SetUp();
     T->setContext(&Ctx);
     T->Run();
     T->TearDown();
-    [[maybe_unused]] const uint64_t end_time = clock();
+    [[maybe_unused]] const uint64_t end_time = static_cast<uint64_t>(clock());
     switch (Ctx.status()) {
     case RunContext::RunResult::Fail:
       tlog << red << "[  FAILED  ] " << reset << TestName << '\n';
@@ -223,6 +223,7 @@ TEST_SPECIALIZATION(int);
 TEST_SPECIALIZATION(long);
 TEST_SPECIALIZATION(long long);
 
+TEST_SPECIALIZATION(signed char);
 TEST_SPECIALIZATION(unsigned char);
 TEST_SPECIALIZATION(unsigned short);
 TEST_SPECIALIZATION(unsigned int);
diff --git a/test/UnitTest/LibcTest.h b/test/UnitTest/LibcTest.h
index b4e3819..fbeafd0 100644
--- a/test/UnitTest/LibcTest.h
+++ b/test/UnitTest/LibcTest.h
@@ -400,6 +400,14 @@ CString libc_make_test_file_path_func(const char *file_name);
   SuiteClass##_##TestName SuiteClass##_##TestName##_Instance;                  \
   void SuiteClass##_##TestName::Run()
 
+// Helper to trick the compiler into ignoring lack of braces on the else
+// branch.  We cannot introduce braces at this point, since it would prevent
+// using `<< ...` after the test macro for additional failure output.
+#define LIBC_TEST_DISABLE_DANGLING_ELSE                                        \
+  switch (0)                                                                   \
+  case 0:                                                                      \
+  default: // NOLINT
+
 // If RET_OR_EMPTY is the 'return' keyword we perform an early return which
 // corresponds to an assert. If it is empty the execution continues, this
 // corresponds to an expect.
@@ -411,6 +419,7 @@ CString libc_make_test_file_path_func(const char *file_name);
 // returning a boolean. This expression is responsible for logging the
 // diagnostic in case of failure.
 #define LIBC_TEST_SCAFFOLDING_(TEST, RET_OR_EMPTY)                             \
+  LIBC_TEST_DISABLE_DANGLING_ELSE                                              \
   if (TEST)                                                                    \
     ;                                                                          \
   else                                                                         \
diff --git a/test/UnitTest/MemoryMatcher.cpp b/test/UnitTest/MemoryMatcher.cpp
index 244f255..3cd5174 100644
--- a/test/UnitTest/MemoryMatcher.cpp
+++ b/test/UnitTest/MemoryMatcher.cpp
@@ -8,6 +8,7 @@
 
 #include "MemoryMatcher.h"
 
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
@@ -40,7 +41,8 @@ bool MemoryMatcher::match(MemoryView actualValue) {
 
 static void display(char C) {
   const auto print = [](unsigned char I) {
-    tlog << static_cast<char>(I < 10 ? '0' + I : 'A' + I - 10);
+    tlog << static_cast<char>(LIBC_NAMESPACE::internal::toupper(
+        LIBC_NAMESPACE::internal::int_to_b36_char(I)));
   };
   print(static_cast<unsigned char>(C) / 16);
   print(static_cast<unsigned char>(C) & 15);
diff --git a/test/UnitTest/MemoryMatcher.h b/test/UnitTest/MemoryMatcher.h
index 6172315..cbbf328 100644
--- a/test/UnitTest/MemoryMatcher.h
+++ b/test/UnitTest/MemoryMatcher.h
@@ -49,7 +49,7 @@ class MemoryMatcher : public Matcher<MemoryView> {
   MemoryView expected;
   MemoryView actual;
   bool mismatch_size = false;
-  size_t mismatch_index = -1;
+  size_t mismatch_index = cpp::numeric_limits<size_t>::max();
 
 public:
   MemoryMatcher(MemoryView expectedValue) : expected(expectedValue) {}
diff --git a/test/UnitTest/Test.h b/test/UnitTest/Test.h
index c772960..95d48f4 100644
--- a/test/UnitTest/Test.h
+++ b/test/UnitTest/Test.h
@@ -41,10 +41,16 @@
 // they all provide.
 
 #define ASSERT_ERRNO_EQ(VAL)                                                   \
-  ASSERT_EQ(VAL, static_cast<int>(LIBC_NAMESPACE::libc_errno))
+  do {                                                                         \
+    ASSERT_EQ(VAL, static_cast<int>(LIBC_NAMESPACE::libc_errno));              \
+    LIBC_NAMESPACE::libc_errno = 0;                                            \
+  } while (0)
 #define ASSERT_ERRNO_SUCCESS()                                                 \
   ASSERT_EQ(0, static_cast<int>(LIBC_NAMESPACE::libc_errno))
 #define ASSERT_ERRNO_FAILURE()                                                 \
-  ASSERT_NE(0, static_cast<int>(LIBC_NAMESPACE::libc_errno))
+  do {                                                                         \
+    ASSERT_NE(0, static_cast<int>(LIBC_NAMESPACE::libc_errno));                \
+    LIBC_NAMESPACE::libc_errno = 0;                                            \
+  } while (0)
 
 #endif // LLVM_LIBC_TEST_UNITTEST_TEST_H
diff --git a/test/include/assert_test.cpp b/test/include/assert_test.cpp
index 78709bb..ff863ec 100644
--- a/test/include/assert_test.cpp
+++ b/test/include/assert_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/complex_test.cpp b/test/include/complex_test.cpp
index f6bfe99..da833fb 100644
--- a/test/include/complex_test.cpp
+++ b/test/include/complex_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/fpclassify_test.c b/test/include/fpclassify_test.c
index 9a9b62c..d52d999 100644
--- a/test/include/fpclassify_test.c
+++ b/test/include/fpclassify_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/fpclassify_test.cpp b/test/include/fpclassify_test.cpp
index 93c8e3c..819fabc 100644
--- a/test/include/fpclassify_test.cpp
+++ b/test/include/fpclassify_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/fpclassifyf_test.cpp b/test/include/fpclassifyf_test.cpp
index 875482a..0dda154 100644
--- a/test/include/fpclassifyf_test.cpp
+++ b/test/include/fpclassifyf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/fpclassifyl_test.cpp b/test/include/fpclassifyl_test.cpp
index 6627956..dcda270 100644
--- a/test/include/fpclassifyl_test.cpp
+++ b/test/include/fpclassifyl_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/header-test-template.c b/test/include/header-test-template.c
new file mode 100644
index 0000000..0fb99f3
--- /dev/null
+++ b/test/include/header-test-template.c
@@ -0,0 +1,14 @@
+/*===-- Test for <@HEADER_NAME@> ----------------------------------------===
+ *
+ * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+ * See https://llvm.org/LICENSE.txt for license information.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#include <@HEADER_NAME@>
+
+int main(int argc, char **argv) {
+  (void)argc;
+  (void)argv;
+  return 0;
+}
diff --git a/test/include/iscanonical_test.c b/test/include/iscanonical_test.c
index c0ad23b..670b48b 100644
--- a/test/include/iscanonical_test.c
+++ b/test/include/iscanonical_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 int iscanonical(double);
diff --git a/test/include/isfinite_test.c b/test/include/isfinite_test.c
index 5fbf4b4..9cc897d 100644
--- a/test/include/isfinite_test.c
+++ b/test/include/isfinite_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/isfinite_test.cpp b/test/include/isfinite_test.cpp
index 79ac442..4520048 100644
--- a/test/include/isfinite_test.cpp
+++ b/test/include/isfinite_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isfinitef_test.cpp b/test/include/isfinitef_test.cpp
index b1f66cd..4097e7d 100644
--- a/test/include/isfinitef_test.cpp
+++ b/test/include/isfinitef_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isfinitel_test.cpp b/test/include/isfinitel_test.cpp
index 9087cd6..fbfe262 100644
--- a/test/include/isfinitel_test.cpp
+++ b/test/include/isfinitel_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isinf_test.c b/test/include/isinf_test.c
index cc099cb..7dc6ce5 100644
--- a/test/include/isinf_test.c
+++ b/test/include/isinf_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/isinf_test.cpp b/test/include/isinf_test.cpp
index ecf19d0..4fe5fe9 100644
--- a/test/include/isinf_test.cpp
+++ b/test/include/isinf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isinff_test.cpp b/test/include/isinff_test.cpp
index a2170c7..b93b819 100644
--- a/test/include/isinff_test.cpp
+++ b/test/include/isinff_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isinfl_test.cpp b/test/include/isinfl_test.cpp
index e4fb91d..f43a12a 100644
--- a/test/include/isinfl_test.cpp
+++ b/test/include/isinfl_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnan_test.c b/test/include/isnan_test.c
index ec0f803..2234c2b 100644
--- a/test/include/isnan_test.c
+++ b/test/include/isnan_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/isnan_test.cpp b/test/include/isnan_test.cpp
index 07dfab7..c65e2d2 100644
--- a/test/include/isnan_test.cpp
+++ b/test/include/isnan_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnanf_test.cpp b/test/include/isnanf_test.cpp
index e78a8e4..e57ffd0 100644
--- a/test/include/isnanf_test.cpp
+++ b/test/include/isnanf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnanl_test.cpp b/test/include/isnanl_test.cpp
index 84759a3..3532c13 100644
--- a/test/include/isnanl_test.cpp
+++ b/test/include/isnanl_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnormal_test.c b/test/include/isnormal_test.c
index c076c5b..9f576d5 100644
--- a/test/include/isnormal_test.c
+++ b/test/include/isnormal_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/isnormal_test.cpp b/test/include/isnormal_test.cpp
index da10850..f59de33 100644
--- a/test/include/isnormal_test.cpp
+++ b/test/include/isnormal_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnormalf_test.cpp b/test/include/isnormalf_test.cpp
index 59c0909..87b242e 100644
--- a/test/include/isnormalf_test.cpp
+++ b/test/include/isnormalf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/isnormall_test.cpp b/test/include/isnormall_test.cpp
index a21f841..1679b8a 100644
--- a/test/include/isnormall_test.cpp
+++ b/test/include/isnormall_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/issignaling_test.c b/test/include/issignaling_test.c
index c89970c..30d17ed 100644
--- a/test/include/issignaling_test.c
+++ b/test/include/issignaling_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 int issignaling(double);
diff --git a/test/include/issubnormal_test.c b/test/include/issubnormal_test.c
index 8a45443..b5dea84 100644
--- a/test/include/issubnormal_test.c
+++ b/test/include/issubnormal_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/issubnormal_test.cpp b/test/include/issubnormal_test.cpp
index ff57a1f..7ed33f6 100644
--- a/test/include/issubnormal_test.cpp
+++ b/test/include/issubnormal_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/issubnormalf_test.cpp b/test/include/issubnormalf_test.cpp
index 7ffa07e..6ba1dfe 100644
--- a/test/include/issubnormalf_test.cpp
+++ b/test/include/issubnormalf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/issubnormall_test.cpp b/test/include/issubnormall_test.cpp
index 4546e2d..9ccf3bd 100644
--- a/test/include/issubnormall_test.cpp
+++ b/test/include/issubnormall_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/iszero_test.c b/test/include/iszero_test.c
index be2d34a..daffde5 100644
--- a/test/include/iszero_test.c
+++ b/test/include/iszero_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/iszero_test.cpp b/test/include/iszero_test.cpp
index c478097..759505b 100644
--- a/test/include/iszero_test.cpp
+++ b/test/include/iszero_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/iszerof_test.cpp b/test/include/iszerof_test.cpp
index 8bf5319..e71784f 100644
--- a/test/include/iszerof_test.cpp
+++ b/test/include/iszerof_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/iszerol_test.cpp b/test/include/iszerol_test.cpp
index 1b1249f..425657d 100644
--- a/test/include/iszerol_test.cpp
+++ b/test/include/iszerol_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/signbit_test.c b/test/include/signbit_test.c
index 7e2460f..2f25624 100644
--- a/test/include/signbit_test.c
+++ b/test/include/signbit_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 #include "include/llvm-libc-macros/math-function-macros.h"
diff --git a/test/include/signbit_test.cpp b/test/include/signbit_test.cpp
index d97ab0b..c50df9b 100644
--- a/test/include/signbit_test.cpp
+++ b/test/include/signbit_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/signbitf_test.cpp b/test/include/signbitf_test.cpp
index 3a4bf93..7bb7afc 100644
--- a/test/include/signbitf_test.cpp
+++ b/test/include/signbitf_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/signbitl_test.cpp b/test/include/signbitl_test.cpp
index 5859840..159b6b9 100644
--- a/test/include/signbitl_test.cpp
+++ b/test/include/signbitl_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/stdbit_stub.h b/test/include/stdbit_stub.h
index 65b1ca3..3d2e0fb 100644
--- a/test/include/stdbit_stub.h
+++ b/test/include/stdbit_stub.h
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -17,21 +17,11 @@
 #include <stdbool.h> // bool in C
 
 #define STDBIT_STUB_FUNCTION(FUNC_NAME, LEADING_VAL)                           \
-  unsigned FUNC_NAME##_uc(unsigned char x) __NOEXCEPT {                        \
-    return LEADING_VAL##AU;                                                    \
-  }                                                                            \
-  unsigned FUNC_NAME##_us(unsigned short x) __NOEXCEPT {                       \
-    return LEADING_VAL##BU;                                                    \
-  }                                                                            \
-  unsigned FUNC_NAME##_ui(unsigned int x) __NOEXCEPT {                         \
-    return LEADING_VAL##CU;                                                    \
-  }                                                                            \
-  unsigned FUNC_NAME##_ul(unsigned long x) __NOEXCEPT {                        \
-    return LEADING_VAL##DU;                                                    \
-  }                                                                            \
-  unsigned FUNC_NAME##_ull(unsigned long long x) __NOEXCEPT {                  \
-    return LEADING_VAL##EU;                                                    \
-  }
+  unsigned FUNC_NAME##_uc(unsigned char x) { return LEADING_VAL##AU; }         \
+  unsigned FUNC_NAME##_us(unsigned short x) { return LEADING_VAL##BU; }        \
+  unsigned FUNC_NAME##_ui(unsigned int x) { return LEADING_VAL##CU; }          \
+  unsigned FUNC_NAME##_ul(unsigned long x) { return LEADING_VAL##DU; }         \
+  unsigned FUNC_NAME##_ull(unsigned long long x) { return LEADING_VAL##EU; }
 
 __BEGIN_C_DECLS
 
@@ -46,28 +36,24 @@ STDBIT_STUB_FUNCTION(stdc_first_trailing_one, 0x1)
 STDBIT_STUB_FUNCTION(stdc_count_zeros, 0x2)
 STDBIT_STUB_FUNCTION(stdc_count_ones, 0x3)
 
-bool stdc_has_single_bit_uc(unsigned char x) __NOEXCEPT { return false; }
-bool stdc_has_single_bit_us(unsigned short x) __NOEXCEPT { return false; }
-bool stdc_has_single_bit_ui(unsigned x) __NOEXCEPT { return false; }
-bool stdc_has_single_bit_ul(unsigned long x) __NOEXCEPT { return false; }
-bool stdc_has_single_bit_ull(unsigned long long x) __NOEXCEPT { return false; }
+bool stdc_has_single_bit_uc(unsigned char x) { return false; }
+bool stdc_has_single_bit_us(unsigned short x) { return false; }
+bool stdc_has_single_bit_ui(unsigned x) { return false; }
+bool stdc_has_single_bit_ul(unsigned long x) { return false; }
+bool stdc_has_single_bit_ull(unsigned long long x) { return false; }
 
 STDBIT_STUB_FUNCTION(stdc_bit_width, 0x4)
 
-unsigned char stdc_bit_floor_uc(unsigned char x) __NOEXCEPT { return 0x5AU; }
-unsigned short stdc_bit_floor_us(unsigned short x) __NOEXCEPT { return 0x5BU; }
-unsigned stdc_bit_floor_ui(unsigned x) __NOEXCEPT { return 0x5CU; }
-unsigned long stdc_bit_floor_ul(unsigned long x) __NOEXCEPT { return 0x5DUL; }
-unsigned long long stdc_bit_floor_ull(unsigned long long x) __NOEXCEPT {
-  return 0x5EULL;
-}
-
-unsigned char stdc_bit_ceil_uc(unsigned char x) __NOEXCEPT { return 0x6AU; }
-unsigned short stdc_bit_ceil_us(unsigned short x) __NOEXCEPT { return 0x6BU; }
-unsigned stdc_bit_ceil_ui(unsigned x) __NOEXCEPT { return 0x6CU; }
-unsigned long stdc_bit_ceil_ul(unsigned long x) __NOEXCEPT { return 0x6DUL; }
-unsigned long long stdc_bit_ceil_ull(unsigned long long x) __NOEXCEPT {
-  return 0x6EULL;
-}
+unsigned char stdc_bit_floor_uc(unsigned char x) { return 0x5AU; }
+unsigned short stdc_bit_floor_us(unsigned short x) { return 0x5BU; }
+unsigned stdc_bit_floor_ui(unsigned x) { return 0x5CU; }
+unsigned long stdc_bit_floor_ul(unsigned long x) { return 0x5DUL; }
+unsigned long long stdc_bit_floor_ull(unsigned long long x) { return 0x5EULL; }
+
+unsigned char stdc_bit_ceil_uc(unsigned char x) { return 0x6AU; }
+unsigned short stdc_bit_ceil_us(unsigned short x) { return 0x6BU; }
+unsigned stdc_bit_ceil_ui(unsigned x) { return 0x6CU; }
+unsigned long stdc_bit_ceil_ul(unsigned long x) { return 0x6DUL; }
+unsigned long long stdc_bit_ceil_ull(unsigned long long x) { return 0x6EULL; }
 
 __END_C_DECLS
diff --git a/test/include/stdbit_test.c b/test/include/stdbit_test.c
index e278e9a..207609e 100644
--- a/test/include/stdbit_test.c
+++ b/test/include/stdbit_test.c
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/stdbit_test.cpp b/test/include/stdbit_test.cpp
index bee1a19..d8759bb 100644
--- a/test/include/stdbit_test.cpp
+++ b/test/include/stdbit_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/stdckdint_test.cpp b/test/include/stdckdint_test.cpp
index 1180a6d..748d110 100644
--- a/test/include/stdckdint_test.cpp
+++ b/test/include/stdckdint_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/include/sys/queue_test.cpp b/test/include/sys/queue_test.cpp
index a1fda90..ce3ae8e 100644
--- a/test/include/sys/queue_test.cpp
+++ b/test/include/sys/queue_test.cpp
@@ -2,7 +2,7 @@
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
-// SPDSList-License-Identifier: Apache-2.0 WITH LLVM-exception
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
diff --git a/test/integration/src/__support/GPU/match.cpp b/test/integration/src/__support/GPU/match.cpp
new file mode 100644
index 0000000..0eadb13
--- /dev/null
+++ b/test/integration/src/__support/GPU/match.cpp
@@ -0,0 +1,35 @@
+//===-- Test for the shuffle operations on the GPU ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/GPU/utils.h"
+#include "test/IntegrationTest/test.h"
+
+using namespace LIBC_NAMESPACE;
+
+// Test to ensure that match any / match all work.
+static void test_match() {
+  uint64_t mask = gpu::get_lane_mask();
+  EXPECT_EQ(1ull << gpu::get_lane_id(),
+            gpu::match_any(mask, gpu::get_lane_id()));
+  EXPECT_EQ(mask, gpu::match_any(mask, 1));
+
+  uint64_t expected = gpu::get_lane_id() < 16 ? 0xffff : 0xffff0000;
+  EXPECT_EQ(expected, gpu::match_any(mask, gpu::get_lane_id() < 16));
+  EXPECT_EQ(mask, gpu::match_all(mask, 1));
+  EXPECT_EQ(0ull, gpu::match_all(mask, gpu::get_lane_id()));
+}
+
+TEST_MAIN(int argc, char **argv, char **envp) {
+  if (gpu::get_thread_id() >= gpu::get_lane_size())
+    return 0;
+
+  test_match();
+
+  return 0;
+}
diff --git a/test/integration/src/__support/GPU/scan_reduce.cpp b/test/integration/src/__support/GPU/scan_reduce.cpp
index bc621c3..1d50e1f 100644
--- a/test/integration/src/__support/GPU/scan_reduce.cpp
+++ b/test/integration/src/__support/GPU/scan_reduce.cpp
@@ -53,10 +53,59 @@ static void test_scan() {
   EXPECT_EQ(z, gpu::get_lane_id() % 2 ? gpu::get_lane_id() / 2 + 1 : 0);
 }
 
+static uint32_t random(uint64_t *rand_next) {
+  uint64_t x = *rand_next;
+  x ^= x >> 12;
+  x ^= x << 25;
+  x ^= x >> 27;
+  *rand_next = x;
+  return static_cast<uint32_t>((x * 0x2545F4914F6CDD1Dul) >> 32);
+}
+
+// Scan operations can break down under thread divergence, make sure that the
+// function works under some random divergence. We do this by trivially
+// implementing a scan with shared scratch memory and then comparing the
+// results.
+static void test_scan_divergent() {
+  static uint32_t input[64] = {0};
+  static uint32_t result[64] = {0};
+  uint64_t state = gpu::processor_clock() + __gpu_lane_id();
+
+  for (int i = 0; i < 64; ++i) {
+    uint64_t lanemask = gpu::get_lane_mask();
+    if (random(&state) & (1ull << gpu::get_lane_id())) {
+      uint64_t divergent = gpu::get_lane_mask();
+      uint32_t value = random(&state) % 256;
+      input[gpu::get_lane_id()] = value;
+
+      if (gpu::is_first_lane(divergent)) {
+        uint32_t accumulator = 0;
+        for (uint32_t lane = 0; lane < gpu::get_lane_size(); ++lane) {
+          uint32_t tmp = input[lane];
+          result[lane] = tmp + accumulator;
+          accumulator += tmp;
+        }
+      }
+      gpu::sync_lane(divergent);
+
+      uint32_t scan = gpu::scan(divergent, value);
+      EXPECT_EQ(scan, result[gpu::get_lane_id()]);
+    }
+    if (gpu::is_first_lane(lanemask))
+      __builtin_memset(input, 0, sizeof(input));
+    gpu::sync_lane(lanemask);
+  }
+}
+
 TEST_MAIN(int argc, char **argv, char **envp) {
+  if (gpu::get_thread_id() >= gpu::get_lane_size())
+    return 0;
+
   test_reduce();
 
   test_scan();
 
+  test_scan_divergent();
+
   return 0;
 }
diff --git a/test/integration/src/__support/GPU/shuffle.cpp b/test/integration/src/__support/GPU/shuffle.cpp
new file mode 100644
index 0000000..c346a2e
--- /dev/null
+++ b/test/integration/src/__support/GPU/shuffle.cpp
@@ -0,0 +1,33 @@
+//===-- Test for the shuffle operations on the GPU ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/CPP/bit.h"
+#include "src/__support/GPU/utils.h"
+#include "test/IntegrationTest/test.h"
+
+using namespace LIBC_NAMESPACE;
+
+// Test to make sure the shuffle instruction works by doing a simple broadcast.
+// Each iteration reduces the width, so it will broadcast to a subset we check.
+static void test_shuffle() {
+  uint64_t mask = gpu::get_lane_mask();
+  EXPECT_EQ(cpp::popcount(mask), gpu::get_lane_size());
+
+  uint32_t x = gpu::get_lane_id();
+  for (uint32_t width = gpu::get_lane_size(); width > 0; width /= 2)
+    EXPECT_EQ(gpu::shuffle(mask, 0, x, width), (x / width) * width);
+}
+
+TEST_MAIN(int argc, char **argv, char **envp) {
+  if (gpu::get_thread_id() >= gpu::get_lane_size())
+    return 0;
+
+  test_shuffle();
+
+  return 0;
+}
diff --git a/test/integration/src/pthread/pthread_mutex_test.cpp b/test/integration/src/pthread/pthread_mutex_test.cpp
index ce2a353..137daed 100644
--- a/test/integration/src/pthread/pthread_mutex_test.cpp
+++ b/test/integration/src/pthread/pthread_mutex_test.cpp
@@ -186,6 +186,10 @@ void multiple_waiters() {
   LIBC_NAMESPACE::pthread_mutex_destroy(&counter_lock);
 }
 
+// Test the initializer
+[[maybe_unused]]
+static pthread_mutex_t test_initializer = PTHREAD_MUTEX_INITIALIZER;
+
 TEST_MAIN() {
   relay_counter();
   wait_and_step();
diff --git a/test/integration/src/pthread/pthread_rwlock_test.cpp b/test/integration/src/pthread/pthread_rwlock_test.cpp
index 4cd4255..205e9f7 100644
--- a/test/integration/src/pthread/pthread_rwlock_test.cpp
+++ b/test/integration/src/pthread/pthread_rwlock_test.cpp
@@ -324,8 +324,8 @@ struct ThreadGuard {
   ~ThreadGuard() {
     if (!LIBC_NAMESPACE::getenv("LIBC_PTHREAD_RWLOCK_TEST_VERBOSE"))
       return;
-    pid_t pid = LIBC_NAMESPACE::syscall_impl(SYS_getpid);
-    pid_t tid = LIBC_NAMESPACE::syscall_impl(SYS_gettid);
+    pid_t pid = static_cast<pid_t>(LIBC_NAMESPACE::syscall_impl(SYS_getpid));
+    pid_t tid = static_cast<pid_t>(LIBC_NAMESPACE::syscall_impl(SYS_gettid));
     io_mutex->lock(LIBC_NAMESPACE::cpp::nullopt, true);
     LIBC_NAMESPACE::printf("process %d thread %d: ", pid, tid);
     for (size_t i = 0; i < cursor; ++i)
diff --git a/test/integration/startup/gpu/rpc_stream_test.cpp b/test/integration/startup/gpu/rpc_stream_test.cpp
index 208130b..aba5b0b 100644
--- a/test/integration/startup/gpu/rpc_stream_test.cpp
+++ b/test/integration/startup/gpu/rpc_stream_test.cpp
@@ -81,7 +81,7 @@ static void test_divergent() {
   LIBC_NAMESPACE::rpc::Client::Port port =
       LIBC_NAMESPACE::rpc::client.open<RPC_TEST_STREAM>();
   port.send_n(buffer, offset);
-  inline_memset(buffer, offset, 0);
+  inline_memset(buffer, 0, offset);
   port.recv_n(&recv_ptr, &recv_size, [&](uint64_t) { return buffer; });
   port.close();
 
diff --git a/test/integration/startup/gpu/rpc_test.cpp b/test/integration/startup/gpu/rpc_test.cpp
index 3deb72b..d20f396 100644
--- a/test/integration/startup/gpu/rpc_test.cpp
+++ b/test/integration/startup/gpu/rpc_test.cpp
@@ -14,7 +14,7 @@
 using namespace LIBC_NAMESPACE;
 
 static void test_add_simple() {
-  uint32_t num_additions =
+  uint64_t num_additions =
       10 + 10 * gpu::get_thread_id() + 10 * gpu::get_block_id();
   uint64_t cnt = 0;
   for (uint32_t i = 0; i < num_additions; ++i) {
@@ -35,7 +35,7 @@ static void test_add_simple() {
 // Test to ensure that the RPC mechanism doesn't hang on divergence.
 static void test_noop(uint8_t data) {
   LIBC_NAMESPACE::rpc::Client::Port port =
-      LIBC_NAMESPACE::rpc::client.open<RPC_NOOP>();
+      LIBC_NAMESPACE::rpc::client.open<LIBC_NOOP>();
   port.send([=](LIBC_NAMESPACE::rpc::Buffer *buffer, uint32_t) {
     buffer->data[0] = data;
   });
diff --git a/test/src/__support/CPP/atomic_test.cpp b/test/src/__support/CPP/atomic_test.cpp
index 5b105c8..5c3f60e 100644
--- a/test/src/__support/CPP/atomic_test.cpp
+++ b/test/src/__support/CPP/atomic_test.cpp
@@ -32,3 +32,21 @@ TEST(LlvmLibcAtomicTest, CompareExchangeStrong) {
   ASSERT_FALSE(aint.compare_exchange_strong(desired, 100));
   ASSERT_EQ(aint.load(LIBC_NAMESPACE::cpp::MemoryOrder::RELAXED), 100);
 }
+
+struct alignas(void *) TrivialData {
+  char a;
+  char b;
+  char padding[sizeof(void *) - 2];
+};
+
+TEST(LlvmLibcAtomicTest, TrivialCompositeData) {
+  LIBC_NAMESPACE::cpp::Atomic<TrivialData> data({'a', 'b', {}});
+  ASSERT_EQ(data.load(LIBC_NAMESPACE::cpp::MemoryOrder::RELAXED).a, 'a');
+  ASSERT_EQ(data.load(LIBC_NAMESPACE::cpp::MemoryOrder::RELAXED).b, 'b');
+
+  auto old = data.exchange({'c', 'd', {}});
+  ASSERT_EQ(data.load(LIBC_NAMESPACE::cpp::MemoryOrder::RELAXED).a, 'c');
+  ASSERT_EQ(data.load(LIBC_NAMESPACE::cpp::MemoryOrder::RELAXED).b, 'd');
+  ASSERT_EQ(old.a, 'a');
+  ASSERT_EQ(old.b, 'b');
+}
diff --git a/test/src/__support/CPP/bit_test.cpp b/test/src/__support/CPP/bit_test.cpp
index 9429b66..89e2a75 100644
--- a/test/src/__support/CPP/bit_test.cpp
+++ b/test/src/__support/CPP/bit_test.cpp
@@ -24,6 +24,7 @@ using UnsignedTypes = testing::TypeList<
     unsigned char, unsigned short, unsigned int, unsigned long,
     unsigned long long, UInt<128>>;
 
+#ifdef FAKE_MACRO_DISABLE
 TYPED_TEST(LlvmLibcBitTest, HasSingleBit, UnsignedTypes) {
   constexpr auto ZERO = T(0);
   constexpr auto ALL_ONES = T(~ZERO);
@@ -41,36 +42,38 @@ TYPED_TEST(LlvmLibcBitTest, HasSingleBit, UnsignedTypes) {
   constexpr auto LSB = T(1);
   constexpr auto MSB = T(~(ALL_ONES >> 1));
   for (T value = 1; value; value <<= 1) {
-    auto two_bits_value = value | ((value <= MIDPOINT) ? MSB : LSB);
+    T two_bits_value =
+        static_cast<T>(value | ((value <= MIDPOINT) ? MSB : LSB));
     EXPECT_FALSE(has_single_bit<T>(two_bits_value));
   }
 }
+#endif
 
 TYPED_TEST(LlvmLibcBitTest, CountLZero, UnsignedTypes) {
   EXPECT_EQ(countl_zero<T>(T(0)), cpp::numeric_limits<T>::digits);
   int expected = 0;
-  for (T value = ~T(0); value; value >>= 1, ++expected)
+  for (T value = T(~0); value; value >>= 1, ++expected)
     EXPECT_EQ(countl_zero<T>(value), expected);
 }
 
 TYPED_TEST(LlvmLibcBitTest, CountRZero, UnsignedTypes) {
   EXPECT_EQ(countr_zero<T>(T(0)), cpp::numeric_limits<T>::digits);
   int expected = 0;
-  for (T value = ~T(0); value; value <<= 1, ++expected)
+  for (T value = T(~0); value; value <<= 1, ++expected)
     EXPECT_EQ(countr_zero<T>(value), expected);
 }
 
 TYPED_TEST(LlvmLibcBitTest, CountLOne, UnsignedTypes) {
   EXPECT_EQ(countl_one<T>(T(0)), 0);
   int expected = cpp::numeric_limits<T>::digits;
-  for (T value = ~T(0); value; value <<= 1, --expected)
+  for (T value = T(~0); value; value <<= 1, --expected)
     EXPECT_EQ(countl_one<T>(value), expected);
 }
 
 TYPED_TEST(LlvmLibcBitTest, CountROne, UnsignedTypes) {
   EXPECT_EQ(countr_one<T>(T(0)), 0);
   int expected = cpp::numeric_limits<T>::digits;
-  for (T value = ~T(0); value; value >>= 1, --expected)
+  for (T value = T(~0); value; value >>= 1, --expected)
     EXPECT_EQ(countr_one<T>(value), expected);
 }
 
@@ -162,7 +165,7 @@ TEST(LlvmLibcBitTest, BitFloor) {
 
 TYPED_TEST(LlvmLibcBitTest, RotateIsInvariantForZeroAndOne, UnsignedTypes) {
   constexpr T all_zeros = T(0);
-  constexpr T all_ones = ~T(0);
+  constexpr T all_ones = T(~0);
   for (int i = 0; i < cpp::numeric_limits<T>::digits; ++i) {
     EXPECT_EQ(rotl<T>(all_zeros, i), all_zeros);
     EXPECT_EQ(rotl<T>(all_ones, i), all_ones);
@@ -226,8 +229,9 @@ TEST(LlvmLibcBitTest, Rotr) {
 TYPED_TEST(LlvmLibcBitTest, CountOnes, UnsignedTypes) {
   EXPECT_EQ(popcount(T(0)), 0);
   for (int i = 0; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(popcount<T>(cpp::numeric_limits<T>::max() >> i),
-              cpp::numeric_limits<T>::digits - i);
+    EXPECT_EQ(
+        popcount<T>(cpp::numeric_limits<T>::max() >> static_cast<size_t>(i)),
+        cpp::numeric_limits<T>::digits - i);
 }
 
 } // namespace cpp
diff --git a/test/src/__support/CPP/stringview_test.cpp b/test/src/__support/CPP/stringview_test.cpp
index 6b68f2a..c934824 100644
--- a/test/src/__support/CPP/stringview_test.cpp
+++ b/test/src/__support/CPP/stringview_test.cpp
@@ -109,8 +109,6 @@ TEST(LlvmLibcStringViewTest, Observer) {
   ASSERT_EQ(ABC.back(), 'c');
 }
 
-bool isDigit(char c) { return c >= '0' && c <= '9'; }
-
 TEST(LlvmLibcStringViewTest, FindFirstOf) {
   string_view Tmp("abca");
   ASSERT_TRUE(Tmp.find_first_of('a') == 0);
@@ -236,6 +234,9 @@ TEST(LlvmLibcStringViewTest, FindFirstNotOf) {
 
 TEST(LlvmLibcStringViewTest, Contains) {
   string_view Empty;
+  static_assert(
+      'a' < 'z',
+      "This test only supports character encodings where 'a' is below 'z'");
   for (char c = 'a'; c < 'z'; ++c)
     EXPECT_FALSE(Empty.contains(c));
 
diff --git a/test/src/__support/CPP/type_traits_test.cpp b/test/src/__support/CPP/type_traits_test.cpp
index fa5298a..4b3e48c 100644
--- a/test/src/__support/CPP/type_traits_test.cpp
+++ b/test/src/__support/CPP/type_traits_test.cpp
@@ -439,6 +439,28 @@ TEST(LlvmLibcTypeTraitsTest, is_object) {
 
 TEST(LlvmLibcTypeTraitsTest, true_type) { EXPECT_TRUE((true_type::value)); }
 
+struct CompilerLeadingPadded {
+  char b;
+  int a;
+};
+
+struct CompilerTrailingPadded {
+  int a;
+  char b;
+};
+
+struct alignas(long long) ManuallyPadded {
+  int b;
+  char padding[sizeof(long long) - sizeof(int)];
+};
+
+TEST(LlvmLibcTypeTraitsTest, has_unique_object_representations) {
+  EXPECT_TRUE(has_unique_object_representations<int>::value);
+  EXPECT_FALSE(has_unique_object_representations_v<CompilerLeadingPadded>);
+  EXPECT_FALSE(has_unique_object_representations_v<CompilerTrailingPadded>);
+  EXPECT_TRUE(has_unique_object_representations_v<ManuallyPadded>);
+}
+
 // TODO type_identity
 
 // TODO void_t
diff --git a/test/src/__support/HashTable/table_test.cpp b/test/src/__support/HashTable/table_test.cpp
index c3b8697..a579bfa 100644
--- a/test/src/__support/HashTable/table_test.cpp
+++ b/test/src/__support/HashTable/table_test.cpp
@@ -43,11 +43,11 @@ TEST(LlvmLibcTableTest, Iteration) {
     counter[i] = 0;
     if (i >= 256) {
       keys[i].bytes[0] = 2;
-      keys[i].bytes[1] = i % 256;
+      keys[i].bytes[1] = static_cast<uint8_t>(i % 256);
       keys[i].bytes[2] = 0;
     } else {
       keys[i].bytes[0] = 1;
-      keys[i].bytes[1] = i;
+      keys[i].bytes[1] = static_cast<uint8_t>(i);
       keys[i].bytes[2] = 0;
     }
     HashTable::insert(table, {reinterpret_cast<char *>(keys[i].bytes),
diff --git a/test/src/__support/arg_list_test.cpp b/test/src/__support/arg_list_test.cpp
index 79a715e..645de26 100644
--- a/test/src/__support/arg_list_test.cpp
+++ b/test/src/__support/arg_list_test.cpp
@@ -72,9 +72,9 @@ long int check_primitives(int first, ...) {
   count += args.next_var<unsigned long>();
   count += args.next_var<long long>();
   count += args.next_var<unsigned long long>();
-  count += args.next_var<double>();
-  count += args.next_var<double>();
-  count += args.next_var<long double>();
+  count += static_cast<long int>(args.next_var<double>());
+  count += static_cast<long int>(args.next_var<double>());
+  count += static_cast<long int>(args.next_var<long double>());
   count += *args.next_var<int *>();
   return count;
 }
@@ -112,7 +112,7 @@ long int check_struct_type(int first, ...) {
 
   S s = args.next_var<S>();
   int last = args.next_var<int>();
-  return s.c + s.s + s.i + s.l + s.f + s.d + last;
+  return s.c + s.s + s.i + s.l + static_cast<long>(s.f + s.d) + last;
 }
 
 TEST(LlvmLibcArgListTest, TestStructTypes) {
diff --git a/test/src/__support/big_int_test.cpp b/test/src/__support/big_int_test.cpp
index 2666ed9..93a66d5 100644
--- a/test/src/__support/big_int_test.cpp
+++ b/test/src/__support/big_int_test.cpp
@@ -197,8 +197,8 @@ TYPED_TEST(LlvmLibcUIntClassTest, CountBits, Types) {
     for (size_t i = 0; i < T::BITS; ++i) {
       const auto l_one = T::all_ones() << i; // 0b111...000
       const auto r_one = T::all_ones() >> i; // 0b000...111
-      const int zeros = i;
-      const int ones = T::BITS - zeros;
+      const int zeros = static_cast<int>(i);
+      const int ones = static_cast<int>(T::BITS - static_cast<size_t>(zeros));
       ASSERT_EQ(cpp::countr_one(r_one), ones);
       ASSERT_EQ(cpp::countl_one(l_one), ones);
       ASSERT_EQ(cpp::countr_zero(l_one), zeros);
@@ -871,13 +871,13 @@ TEST(LlvmLibcUIntClassTest, ConstructorFromUInt128Tests) {
   ASSERT_EQ(static_cast<int>(c >> 64), 123);
   ASSERT_EQ(static_cast<uint64_t>(d), static_cast<uint64_t>(b));
   ASSERT_EQ(static_cast<uint64_t>(d >> 64), static_cast<uint64_t>(b >> 64));
-  ASSERT_EQ(c + d, LL_Int128(a + b));
+  ASSERT_EQ(c + d, LL_Int128(a + static_cast<__uint128_t>(b)));
 
   ASSERT_EQ(static_cast<int>(e), 1);
   ASSERT_EQ(static_cast<int>(e >> 64), 123);
   ASSERT_EQ(static_cast<uint64_t>(f), static_cast<uint64_t>(b));
   ASSERT_EQ(static_cast<uint64_t>(f >> 64), static_cast<uint64_t>(b >> 64));
-  ASSERT_EQ(LL_UInt192(e + f), LL_UInt192(a + b));
+  ASSERT_EQ(LL_UInt192(e + f), LL_UInt192(a + static_cast<__uint128_t>(b)));
 }
 
 TEST(LlvmLibcUIntClassTest, WordTypeUInt128Tests) {
diff --git a/test/src/__support/block_test.cpp b/test/src/__support/block_test.cpp
index 5e437db..904ac5c 100644
--- a/test/src/__support/block_test.cpp
+++ b/test/src/__support/block_test.cpp
@@ -22,23 +22,28 @@ using LIBC_NAMESPACE::cpp::span;
 
 TEST(LlvmLibcBlockTest, CanCreateSingleAlignedBlock) {
   constexpr size_t kN = 1024;
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  alignas(max_align_t) array<byte, kN> bytes;
 
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
 
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(block) % alignof(Block), size_t{0});
+  EXPECT_TRUE(block->is_usable_space_aligned(alignof(max_align_t)));
+
   Block *last = block->next();
   ASSERT_NE(last, static_cast<Block *>(nullptr));
-  constexpr size_t last_outer_size = Block::BLOCK_OVERHEAD;
-  EXPECT_EQ(last->outer_size(), last_outer_size);
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(last) % alignof(Block), size_t{0});
+
+  EXPECT_EQ(last->outer_size(), sizeof(Block));
   EXPECT_EQ(last->prev_free(), block);
   EXPECT_TRUE(last->used());
 
-  EXPECT_EQ(block->outer_size(), kN - last_outer_size);
-  constexpr size_t last_prev_field_size = sizeof(size_t);
-  EXPECT_EQ(block->inner_size(), kN - last_outer_size - Block::BLOCK_OVERHEAD +
-                                     last_prev_field_size);
+  size_t block_outer_size =
+      reinterpret_cast<uintptr_t>(last) - reinterpret_cast<uintptr_t>(block);
+  EXPECT_EQ(block->outer_size(), block_outer_size);
+  EXPECT_EQ(block->inner_size(),
+            block_outer_size - sizeof(Block) + Block::PREV_FIELD_SIZE);
   EXPECT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
   EXPECT_FALSE(block->used());
 }
@@ -47,11 +52,19 @@ TEST(LlvmLibcBlockTest, CanCreateUnalignedSingleBlock) {
   constexpr size_t kN = 1024;
 
   // Force alignment, so we can un-force it below
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  alignas(max_align_t) array<byte, kN> bytes;
   span<byte> aligned(bytes);
 
   auto result = Block::init(aligned.subspan(1));
   EXPECT_TRUE(result.has_value());
+
+  Block *block = *result;
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(block) % alignof(Block), size_t{0});
+  EXPECT_TRUE(block->is_usable_space_aligned(alignof(max_align_t)));
+
+  Block *last = block->next();
+  ASSERT_NE(last, static_cast<Block *>(nullptr));
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(last) % alignof(Block), size_t{0});
 }
 
 TEST(LlvmLibcBlockTest, CannotCreateTooSmallBlock) {
@@ -62,11 +75,13 @@ TEST(LlvmLibcBlockTest, CannotCreateTooSmallBlock) {
 
 TEST(LlvmLibcBlockTest, CanSplitBlock) {
   constexpr size_t kN = 1024;
-  constexpr size_t prev_field_size = sizeof(size_t);
-  // Give the split position a large alignment.
-  constexpr size_t kSplitN = 512 + prev_field_size;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  // Choose a split position such that the next block's usable space is 512
+  // bytes from this one's. This should be sufficient for any machine's
+  // alignment.
+  const size_t kSplitN = Block::inner_size(512);
+
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   auto *block1 = *result;
@@ -78,10 +93,12 @@ TEST(LlvmLibcBlockTest, CanSplitBlock) {
 
   EXPECT_EQ(block1->inner_size(), kSplitN);
   EXPECT_EQ(block1->outer_size(),
-            kSplitN - prev_field_size + Block::BLOCK_OVERHEAD);
+            kSplitN - Block::PREV_FIELD_SIZE + sizeof(Block));
 
   EXPECT_EQ(block2->outer_size(), orig_size - block1->outer_size());
   EXPECT_FALSE(block2->used());
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(block2) % alignof(Block), size_t{0});
+  EXPECT_TRUE(block2->is_usable_space_aligned(alignof(max_align_t)));
 
   EXPECT_EQ(block1->next(), block2);
   EXPECT_EQ(block2->prev_free(), block1);
@@ -90,28 +107,24 @@ TEST(LlvmLibcBlockTest, CanSplitBlock) {
 TEST(LlvmLibcBlockTest, CanSplitBlockUnaligned) {
   constexpr size_t kN = 1024;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
   size_t orig_size = block1->outer_size();
 
   constexpr size_t kSplitN = 513;
-  constexpr size_t prev_field_size = sizeof(size_t);
-  uintptr_t split_addr =
-      reinterpret_cast<uintptr_t>(block1) + (kSplitN - prev_field_size);
-  // Round split_addr up to a multiple of the alignment.
-  split_addr += alignof(Block) - (split_addr % alignof(Block));
-  uintptr_t split_len = split_addr - (uintptr_t)&bytes + prev_field_size;
 
   result = block1->split(kSplitN);
   ASSERT_TRUE(result.has_value());
   Block *block2 = *result;
 
-  EXPECT_EQ(block1->inner_size(), split_len);
+  EXPECT_GE(block1->inner_size(), kSplitN);
 
   EXPECT_EQ(block2->outer_size(), orig_size - block1->outer_size());
   EXPECT_FALSE(block2->used());
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(block2) % alignof(Block), size_t{0});
+  EXPECT_TRUE(block2->is_usable_space_aligned(alignof(max_align_t)));
 
   EXPECT_EQ(block1->next(), block2);
   EXPECT_EQ(block2->prev_free(), block1);
@@ -131,7 +144,7 @@ TEST(LlvmLibcBlockTest, CanSplitMidBlock) {
   constexpr size_t kSplit1 = 512;
   constexpr size_t kSplit2 = 256;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
@@ -152,27 +165,25 @@ TEST(LlvmLibcBlockTest, CanSplitMidBlock) {
 
 TEST(LlvmLibcBlockTest, CannotSplitTooSmallBlock) {
   constexpr size_t kN = 64;
-  constexpr size_t kSplitN = kN + 1;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
 
-  result = block->split(kSplitN);
+  result = block->split(block->inner_size() + 1);
   ASSERT_FALSE(result.has_value());
 }
 
 TEST(LlvmLibcBlockTest, CannotSplitBlockWithoutHeaderSpace) {
   constexpr size_t kN = 1024;
-  constexpr size_t kSplitN = kN - 2 * Block::BLOCK_OVERHEAD - 1;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
 
-  result = block->split(kSplitN);
+  result = block->split(block->inner_size() - sizeof(Block) + 1);
   ASSERT_FALSE(result.has_value());
 }
 
@@ -180,7 +191,7 @@ TEST(LlvmLibcBlockTest, CannotMakeBlockLargerInSplit) {
   // Ensure that we can't ask for more space than the block actually has...
   constexpr size_t kN = 1024;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
@@ -189,55 +200,41 @@ TEST(LlvmLibcBlockTest, CannotMakeBlockLargerInSplit) {
   ASSERT_FALSE(result.has_value());
 }
 
-TEST(LlvmLibcBlockTest, CannotMakeSecondBlockLargerInSplit) {
-  // Ensure that the second block in split is at least of the size of header.
-  constexpr size_t kN = 1024;
-
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
-  auto result = Block::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  Block *block = *result;
-
-  result = block->split(block->inner_size() - Block::BLOCK_OVERHEAD + 1);
-  ASSERT_FALSE(result.has_value());
-}
-
 TEST(LlvmLibcBlockTest, CanMakeMinimalSizeFirstBlock) {
   // This block does support splitting with minimal payload size.
   constexpr size_t kN = 1024;
-  constexpr size_t minimal_size = sizeof(size_t);
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
 
-  result = block->split(minimal_size);
+  result = block->split(0);
   ASSERT_TRUE(result.has_value());
-  EXPECT_EQ(block->inner_size(), minimal_size);
+  EXPECT_LE(block->outer_size(), sizeof(Block) + alignof(max_align_t));
 }
 
 TEST(LlvmLibcBlockTest, CanMakeMinimalSizeSecondBlock) {
   // Likewise, the split block can be minimal-width.
   constexpr size_t kN = 1024;
-  constexpr size_t minimal_size = sizeof(size_t);
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
 
-  result = block1->split(block1->inner_size() - Block::BLOCK_OVERHEAD);
+  result = block1->split(Block::prev_possible_block_start(
+                             reinterpret_cast<uintptr_t>(block1->next())) -
+                         reinterpret_cast<uintptr_t>(block1->usable_space()) +
+                         Block::PREV_FIELD_SIZE);
   ASSERT_TRUE(result.has_value());
-  Block *block2 = *result;
-
-  EXPECT_EQ(block2->inner_size(), minimal_size);
+  EXPECT_LE((*result)->outer_size(), sizeof(Block) + alignof(max_align_t));
 }
 
 TEST(LlvmLibcBlockTest, CanMarkBlockUsed) {
   constexpr size_t kN = 1024;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
@@ -255,7 +252,7 @@ TEST(LlvmLibcBlockTest, CannotSplitUsedBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
@@ -269,21 +266,19 @@ TEST(LlvmLibcBlockTest, CanMergeWithNextBlock) {
   // Do the three way merge from "CanSplitMidBlock", and let's
   // merge block 3 and 2
   constexpr size_t kN = 1024;
-  // Give the split positions large alignments.
-  constexpr size_t prev_field_size = sizeof(size_t);
-  constexpr size_t kSplit1 = 512 + prev_field_size;
-  constexpr size_t kSplit2 = 256 + prev_field_size;
-
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  constexpr size_t kSplit1 = 512;
+  constexpr size_t kSplit2 = 256;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
-  size_t orig_size = block1->outer_size();
+  size_t total_size = block1->outer_size();
 
   result = block1->split(kSplit1);
   ASSERT_TRUE(result.has_value());
 
   result = block1->split(kSplit2);
+  size_t block1_size = block1->outer_size();
   ASSERT_TRUE(result.has_value());
   Block *block3 = *result;
 
@@ -291,15 +286,15 @@ TEST(LlvmLibcBlockTest, CanMergeWithNextBlock) {
 
   EXPECT_EQ(block1->next(), block3);
   EXPECT_EQ(block3->prev_free(), block1);
-  EXPECT_EQ(block1->inner_size(), kSplit2);
-  EXPECT_EQ(block3->outer_size(), orig_size - block1->outer_size());
+  EXPECT_EQ(block1->outer_size(), block1_size);
+  EXPECT_EQ(block3->outer_size(), total_size - block1->outer_size());
 }
 
 TEST(LlvmLibcBlockTest, CannotMergeWithFirstOrLastBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
@@ -316,7 +311,7 @@ TEST(LlvmLibcBlockTest, CannotMergeUsedBlock) {
   constexpr size_t kN = 1024;
   constexpr size_t kSplitN = 512;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes;
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
@@ -330,9 +325,7 @@ TEST(LlvmLibcBlockTest, CannotMergeUsedBlock) {
 }
 
 TEST(LlvmLibcBlockTest, CanGetBlockFromUsableSpace) {
-  constexpr size_t kN = 1024;
-
-  array<byte, kN> bytes{};
+  array<byte, 1024> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block1 = *result;
@@ -355,93 +348,85 @@ TEST(LlvmLibcBlockTest, CanGetConstBlockFromUsableSpace) {
   EXPECT_EQ(block1, block2);
 }
 
-TEST(LlvmLibcBlockTest, CanAllocate) {
-  constexpr size_t kN = 1024 + Block::BLOCK_OVERHEAD;
+TEST(LlvmLibcBlockTest, Allocate) {
+  constexpr size_t kN = 1024;
 
   // Ensure we can allocate everything up to the block size within this block.
-  for (size_t i = 0; i < kN - 2 * Block::BLOCK_OVERHEAD; ++i) {
-    alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
+  for (size_t i = 0; i < kN; ++i) {
+    array<byte, kN> bytes;
     auto result = Block::init(bytes);
     ASSERT_TRUE(result.has_value());
     Block *block = *result;
 
-    constexpr size_t ALIGN = 1; // Effectively ignores alignment.
-    EXPECT_TRUE(block->can_allocate(ALIGN, i));
+    if (i > block->inner_size())
+      continue;
 
-    // For each can_allocate, we should be able to do a successful call to
-    // allocate.
-    auto info = Block::allocate(block, ALIGN, i);
+    auto info = Block::allocate(block, alignof(max_align_t), i);
     EXPECT_NE(info.block, static_cast<Block *>(nullptr));
   }
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
-  auto result = Block::init(bytes);
-  ASSERT_TRUE(result.has_value());
-  Block *block = *result;
+  // Ensure we can allocate a byte at every guaranteeable alignment.
+  for (size_t i = 1; i < kN / alignof(max_align_t); ++i) {
+    array<byte, kN> bytes;
+    auto result = Block::init(bytes);
+    ASSERT_TRUE(result.has_value());
+    Block *block = *result;
 
-  // Given a block of size N (assuming it's also a power of two), we should be
-  // able to allocate a block within it that's aligned to N/2. This is
-  // because regardless of where the buffer is located, we can always find a
-  // starting location within it that meets this alignment.
-  EXPECT_TRUE(block->can_allocate(block->outer_size() / 2, 1));
-  auto info = Block::allocate(block, block->outer_size() / 2, 1);
-  EXPECT_NE(info.block, static_cast<Block *>(nullptr));
+    size_t alignment = i * alignof(max_align_t);
+    if (Block::min_size_for_allocation(alignment, 1) > block->inner_size())
+      continue;
+
+    auto info = Block::allocate(block, alignment, 1);
+    EXPECT_NE(info.block, static_cast<Block *>(nullptr));
+  }
 }
 
 TEST(LlvmLibcBlockTest, AllocateAlreadyAligned) {
   constexpr size_t kN = 1024;
 
-  alignas(Block::ALIGNMENT) array<byte, kN> bytes{};
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
+  uintptr_t orig_end = reinterpret_cast<uintptr_t>(block) + block->outer_size();
 
-  // This should result in no new blocks.
-  constexpr size_t kAlignment = Block::ALIGNMENT;
-  constexpr size_t prev_field_size = sizeof(size_t);
-  constexpr size_t kExpectedSize = Block::ALIGNMENT + prev_field_size;
-  EXPECT_TRUE(block->can_allocate(kAlignment, kExpectedSize));
+  constexpr size_t SIZE = Block::PREV_FIELD_SIZE + 1;
 
   auto [aligned_block, prev, next] =
-      Block::allocate(block, Block::ALIGNMENT, kExpectedSize);
+      Block::allocate(block, alignof(max_align_t), SIZE);
 
   // Since this is already aligned, there should be no previous block.
   EXPECT_EQ(prev, static_cast<Block *>(nullptr));
 
-  // Ensure we the block is aligned and the size we expect.
+  // Ensure we the block is aligned and large enough.
   EXPECT_NE(aligned_block, static_cast<Block *>(nullptr));
-  EXPECT_TRUE(aligned_block->is_usable_space_aligned(Block::ALIGNMENT));
-  EXPECT_EQ(aligned_block->inner_size(), kExpectedSize);
+  EXPECT_TRUE(aligned_block->is_usable_space_aligned(alignof(max_align_t)));
+  EXPECT_GE(aligned_block->inner_size(), SIZE);
 
   // Check the next block.
   EXPECT_NE(next, static_cast<Block *>(nullptr));
   EXPECT_EQ(aligned_block->next(), next);
-  EXPECT_EQ(reinterpret_cast<byte *>(next) + next->outer_size(),
-            bytes.data() + bytes.size() - Block::BLOCK_OVERHEAD);
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(next) + next->outer_size(), orig_end);
 }
 
 TEST(LlvmLibcBlockTest, AllocateNeedsAlignment) {
   constexpr size_t kN = 1024;
 
-  alignas(kN) array<byte, kN> bytes{};
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
 
-  // Ensure first the usable_data is only aligned to the block alignment.
-  ASSERT_EQ(block->usable_space(), bytes.data() + Block::BLOCK_OVERHEAD);
-  ASSERT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
+  uintptr_t orig_end = reinterpret_cast<uintptr_t>(block) + block->outer_size();
 
   // Now pick an alignment such that the usable space is not already aligned to
   // it. We want to explicitly test that the block will split into one before
   // it.
-  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
-  ASSERT_FALSE(block->is_usable_space_aligned(kAlignment));
-
-  constexpr size_t kSize = 10;
-  EXPECT_TRUE(block->can_allocate(kAlignment, kSize));
+  size_t alignment = alignof(max_align_t);
+  while (block->is_usable_space_aligned(alignment))
+    alignment += alignof(max_align_t);
 
-  auto [aligned_block, prev, next] = Block::allocate(block, kAlignment, kSize);
+  auto [aligned_block, prev, next] = Block::allocate(block, alignment, 10);
 
   // Check the previous block was created appropriately. Since this block is the
   // first block, a new one should be made before this.
@@ -453,19 +438,18 @@ TEST(LlvmLibcBlockTest, AllocateNeedsAlignment) {
 
   // Ensure we the block is aligned and the size we expect.
   EXPECT_NE(next, static_cast<Block *>(nullptr));
-  EXPECT_TRUE(aligned_block->is_usable_space_aligned(kAlignment));
+  EXPECT_TRUE(aligned_block->is_usable_space_aligned(alignment));
 
   // Check the next block.
   EXPECT_NE(next, static_cast<Block *>(nullptr));
   EXPECT_EQ(aligned_block->next(), next);
-  EXPECT_EQ(reinterpret_cast<byte *>(next) + next->outer_size(),
-            bytes.data() + bytes.size() - Block::BLOCK_OVERHEAD);
+  EXPECT_EQ(reinterpret_cast<uintptr_t>(next) + next->outer_size(), orig_end);
 }
 
 TEST(LlvmLibcBlockTest, PreviousBlockMergedIfNotFirst) {
   constexpr size_t kN = 1024;
 
-  alignas(kN) array<byte, kN> bytes{};
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
@@ -480,15 +464,12 @@ TEST(LlvmLibcBlockTest, PreviousBlockMergedIfNotFirst) {
   // Now pick an alignment such that the usable space is not already aligned to
   // it. We want to explicitly test that the block will split into one before
   // it.
-  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
-  ASSERT_FALSE(newblock->is_usable_space_aligned(kAlignment));
+  size_t alignment = alignof(max_align_t);
+  while (newblock->is_usable_space_aligned(alignment))
+    alignment += alignof(max_align_t);
 
   // Ensure we can allocate in the new block.
-  constexpr size_t kSize = Block::ALIGNMENT;
-  EXPECT_TRUE(newblock->can_allocate(kAlignment, kSize));
-
-  auto [aligned_block, prev, next] =
-      Block::allocate(newblock, kAlignment, kSize);
+  auto [aligned_block, prev, next] = Block::allocate(newblock, alignment, 1);
 
   // Now there should be no new previous block. Instead, the padding we did
   // create should be merged into the original previous block.
@@ -505,26 +486,26 @@ TEST(LlvmLibcBlockTest, CanRemergeBlockAllocations) {
   // This is the same setup as with the `AllocateNeedsAlignment` test case.
   constexpr size_t kN = 1024;
 
-  alignas(kN) array<byte, kN> bytes{};
+  array<byte, kN> bytes;
   auto result = Block::init(bytes);
   ASSERT_TRUE(result.has_value());
   Block *block = *result;
+
+  Block *orig_block = block;
+  size_t orig_size = orig_block->outer_size();
+
   Block *last = block->next();
 
-  // Ensure first the usable_data is only aligned to the block alignment.
-  ASSERT_EQ(block->usable_space(), bytes.data() + Block::BLOCK_OVERHEAD);
   ASSERT_EQ(block->prev_free(), static_cast<Block *>(nullptr));
 
   // Now pick an alignment such that the usable space is not already aligned to
   // it. We want to explicitly test that the block will split into one before
   // it.
-  constexpr size_t kAlignment = bit_ceil(Block::BLOCK_OVERHEAD) * 8;
-  ASSERT_FALSE(block->is_usable_space_aligned(kAlignment));
-
-  constexpr size_t kSize = Block::ALIGNMENT;
-  EXPECT_TRUE(block->can_allocate(kAlignment, kSize));
+  size_t alignment = alignof(max_align_t);
+  while (block->is_usable_space_aligned(alignment))
+    alignment += alignof(max_align_t);
 
-  auto [aligned_block, prev, next] = Block::allocate(block, kAlignment, kSize);
+  auto [aligned_block, prev, next] = Block::allocate(block, alignment, 1);
 
   // Check we have the appropriate blocks.
   ASSERT_NE(prev, static_cast<Block *>(nullptr));
@@ -540,8 +521,6 @@ TEST(LlvmLibcBlockTest, CanRemergeBlockAllocations) {
   EXPECT_EQ(prev->next(), last);
 
   // We should have the original buffer.
-  EXPECT_EQ(reinterpret_cast<byte *>(prev), &*bytes.begin());
-  EXPECT_EQ(prev->outer_size(), bytes.size() - Block::BLOCK_OVERHEAD);
-  EXPECT_EQ(reinterpret_cast<byte *>(prev) + prev->outer_size(),
-            &*bytes.end() - Block::BLOCK_OVERHEAD);
+  EXPECT_EQ(prev, orig_block);
+  EXPECT_EQ(prev->outer_size(), orig_size);
 }
diff --git a/test/src/__support/blockstore_test.cpp b/test/src/__support/blockstore_test.cpp
index de7bd72..364155c 100644
--- a/test/src/__support/blockstore_test.cpp
+++ b/test/src/__support/blockstore_test.cpp
@@ -27,7 +27,7 @@ public:
     for (auto iter = block_store.begin(); iter != end; ++iter, ++i) {
       Element &e = *iter;
       if (REVERSE) {
-        int j = ELEMENT_COUNT - 1 - i;
+        int j = static_cast<int>(ELEMENT_COUNT - 1) - i;
         ASSERT_EQ(e.a, j);
         ASSERT_EQ(e.b, long(j * 2));
         ASSERT_EQ(e.c, unsigned(j * 3));
diff --git a/test/src/__support/fixed_point/fx_bits_test.cpp b/test/src/__support/fixed_point/fx_bits_test.cpp
index 3cbd800..804cfd3 100644
--- a/test/src/__support/fixed_point/fx_bits_test.cpp
+++ b/test/src/__support/fixed_point/fx_bits_test.cpp
@@ -27,7 +27,7 @@ public:
     EXPECT_EQ(LIBC_NAMESPACE::fixed_point::bit_or(T(0.75), T(0.375)), T(0.875));
     using StorageType = typename FXRep<T>::StorageType;
     StorageType a = LIBC_NAMESPACE::cpp::bit_cast<StorageType>(T(0.75));
-    a = ~a;
+    a = static_cast<StorageType>(~a);
     EXPECT_EQ(LIBC_NAMESPACE::fixed_point::bit_not(T(0.75)),
               FXBits<T>(a).get_val());
   }
diff --git a/test/src/__support/fixedvector_test.cpp b/test/src/__support/fixedvector_test.cpp
index b73df04..8be18a5 100644
--- a/test/src/__support/fixedvector_test.cpp
+++ b/test/src/__support/fixedvector_test.cpp
@@ -92,7 +92,7 @@ TEST(LlvmLibcFixedVectorTest, ForwardIteration) {
   LIBC_NAMESPACE::FixedVector<int, 5> vec(arr.begin(), arr.end());
   ASSERT_EQ(vec.size(), arr.size());
   for (auto it = vec.begin(); it != vec.end(); ++it) {
-    auto idx = it - vec.begin();
+    auto idx = static_cast<size_t>(it - vec.begin());
     ASSERT_EQ(*it, arr[idx]);
   }
 }
@@ -102,7 +102,7 @@ TEST(LlvmLibcFixedVectorTest, ConstForwardIteration) {
   const LIBC_NAMESPACE::FixedVector<int, 5> vec(arr.begin(), arr.end());
   ASSERT_EQ(vec.size(), arr.size());
   for (auto it = vec.begin(); it != vec.end(); ++it) {
-    auto idx = it - vec.begin();
+    auto idx = static_cast<size_t>(it - vec.begin());
     ASSERT_EQ(*it, arr[idx]);
   }
 }
diff --git a/test/src/__support/freelist_heap_test.cpp b/test/src/__support/freelist_heap_test.cpp
index 991c158..0623272 100644
--- a/test/src/__support/freelist_heap_test.cpp
+++ b/test/src/__support/freelist_heap_test.cpp
@@ -42,7 +42,7 @@ using LIBC_NAMESPACE::cpp::span;
     void RunTest(FreeListHeap &allocator, [[maybe_unused]] size_t N);          \
   };                                                                           \
   TEST_F(LlvmLibcFreeListHeapTest##TestCase, TestCase) {                       \
-    alignas(Block) byte buf[BufferSize] = {byte(0)};                           \
+    byte buf[BufferSize] = {byte(0)};                                          \
     FreeListHeap allocator(buf);                                               \
     RunTest(allocator, BufferSize);                                            \
     RunTest(*freelist_heap, freelist_heap->region().size());                   \
@@ -95,30 +95,31 @@ TEST_FOR_EACH_ALLOCATOR(ReturnsNullWhenAllocationTooLarge, 2048) {
 // is used for other test cases and we don't explicitly free them.
 TEST(LlvmLibcFreeListHeap, ReturnsNullWhenFull) {
   constexpr size_t N = 2048;
-  alignas(Block) byte buf[N] = {byte(0)};
+  byte buf[N];
 
   FreeListHeap allocator(buf);
 
-  // Use aligned_allocate so we don't need to worry about ensuring the `buf`
-  // being aligned to max_align_t.
-  EXPECT_NE(allocator.aligned_allocate(1, N - 2 * Block::BLOCK_OVERHEAD),
-            static_cast<void *>(nullptr));
+  bool went_null = false;
+  for (size_t i = 0; i < N; i++) {
+    if (!allocator.allocate(1)) {
+      went_null = true;
+      break;
+    }
+  }
+  EXPECT_TRUE(went_null);
   EXPECT_EQ(allocator.allocate(1), static_cast<void *>(nullptr));
 }
 
 TEST_FOR_EACH_ALLOCATOR(ReturnedPointersAreAligned, 2048) {
   void *ptr1 = allocator.allocate(1);
 
-  // Should be aligned to native pointer alignment
   uintptr_t ptr1_start = reinterpret_cast<uintptr_t>(ptr1);
-  size_t alignment = alignof(void *);
-
-  EXPECT_EQ(ptr1_start % alignment, static_cast<size_t>(0));
+  EXPECT_EQ(ptr1_start % alignof(max_align_t), static_cast<size_t>(0));
 
   void *ptr2 = allocator.allocate(1);
   uintptr_t ptr2_start = reinterpret_cast<uintptr_t>(ptr2);
 
-  EXPECT_EQ(ptr2_start % alignment, static_cast<size_t>(0));
+  EXPECT_EQ(ptr2_start % alignof(max_align_t), static_cast<size_t>(0));
 }
 
 TEST_FOR_EACH_ALLOCATOR(CanRealloc, 2048) {
@@ -241,16 +242,14 @@ TEST_FOR_EACH_ALLOCATOR(AlignedAlloc, 2048) {
 
 // This test is not part of the TEST_FOR_EACH_ALLOCATOR since we want to
 // explicitly ensure that the buffer can still return aligned allocations even
-// if the underlying buffer is at most aligned to the Block alignment. This
-// is so we can check that we can still get aligned allocations even if the
-// underlying buffer is not aligned to the alignments we request.
-TEST(LlvmLibcFreeListHeap, AlignedAllocOnlyBlockAligned) {
-  constexpr size_t BUFFER_SIZE = 4096;
-  constexpr size_t BUFFER_ALIGNMENT = alignof(Block) * 2;
-  alignas(BUFFER_ALIGNMENT) byte buf[BUFFER_SIZE] = {byte(0)};
-
-  // Ensure the underlying buffer is at most aligned to the block type.
-  FreeListHeap allocator(span<byte>(buf).subspan(alignof(Block)));
+// if the underlying buffer is unaligned. This is so we can check that we can
+// still get aligned allocations even if the underlying buffer is not aligned to
+// the alignments we request.
+TEST(LlvmLibcFreeListHeap, AlignedAllocUnalignedBuffer) {
+  byte buf[4096] = {byte(0)};
+
+  // Ensure the underlying buffer is poorly aligned.
+  FreeListHeap allocator(span<byte>(buf).subspan(1));
 
   constexpr size_t ALIGNMENTS[] = {1, 2, 4, 8, 16, 32, 64, 128, 256};
   constexpr size_t SIZE_SCALES[] = {1, 2, 3, 4, 5};
diff --git a/test/src/__support/freelist_malloc_test.cpp b/test/src/__support/freelist_malloc_test.cpp
deleted file mode 100644
index 793e249..0000000
--- a/test/src/__support/freelist_malloc_test.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-//===-- Unittests for freelist_malloc -------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/__support/freelist_heap.h"
-#include "src/stdlib/aligned_alloc.h"
-#include "src/stdlib/calloc.h"
-#include "src/stdlib/free.h"
-#include "src/stdlib/malloc.h"
-#include "test/UnitTest/Test.h"
-
-using LIBC_NAMESPACE::Block;
-using LIBC_NAMESPACE::freelist_heap;
-using LIBC_NAMESPACE::FreeListHeap;
-using LIBC_NAMESPACE::FreeListHeapBuffer;
-
-TEST(LlvmLibcFreeListMalloc, Malloc) {
-  constexpr size_t kAllocSize = 256;
-  constexpr size_t kCallocNum = 4;
-  constexpr size_t kCallocSize = 64;
-
-  void *ptr1 = LIBC_NAMESPACE::malloc(kAllocSize);
-  auto *block = Block::from_usable_space(ptr1);
-  EXPECT_GE(block->inner_size(), kAllocSize);
-
-  LIBC_NAMESPACE::free(ptr1);
-  ASSERT_NE(block->next(), static_cast<Block *>(nullptr));
-  ASSERT_EQ(block->next()->next(), static_cast<Block *>(nullptr));
-  size_t heap_size = block->inner_size();
-
-  void *ptr2 = LIBC_NAMESPACE::calloc(kCallocNum, kCallocSize);
-  ASSERT_EQ(ptr2, ptr1);
-  EXPECT_GE(block->inner_size(), kCallocNum * kCallocSize);
-
-  for (size_t i = 0; i < kCallocNum * kCallocSize; ++i)
-    EXPECT_EQ(reinterpret_cast<uint8_t *>(ptr2)[i], uint8_t(0));
-
-  LIBC_NAMESPACE::free(ptr2);
-  EXPECT_EQ(block->inner_size(), heap_size);
-
-  constexpr size_t ALIGN = kAllocSize;
-  void *ptr3 = LIBC_NAMESPACE::aligned_alloc(ALIGN, kAllocSize);
-  EXPECT_NE(ptr3, static_cast<void *>(nullptr));
-  EXPECT_EQ(reinterpret_cast<uintptr_t>(ptr3) % ALIGN, size_t(0));
-  auto *aligned_block = reinterpret_cast<Block *>(ptr3);
-  EXPECT_GE(aligned_block->inner_size(), kAllocSize);
-
-  LIBC_NAMESPACE::free(ptr3);
-  EXPECT_EQ(block->inner_size(), heap_size);
-}
diff --git a/test/src/__support/freestore_test.cpp b/test/src/__support/freestore_test.cpp
index 7960d32..39292b6 100644
--- a/test/src/__support/freestore_test.cpp
+++ b/test/src/__support/freestore_test.cpp
@@ -24,8 +24,12 @@ TEST(LlvmLibcFreeStore, TooSmall) {
   optional<Block *> maybeBlock = Block::init(mem);
   ASSERT_TRUE(maybeBlock.has_value());
   Block *too_small = *maybeBlock;
-  maybeBlock = too_small->split(sizeof(size_t));
+  maybeBlock = too_small->split(Block::PREV_FIELD_SIZE);
   ASSERT_TRUE(maybeBlock.has_value());
+  // On platforms with high alignment the smallest legal block may be large
+  // enough for a node.
+  if (too_small->outer_size() >= sizeof(Block) + sizeof(FreeList::Node))
+    return;
   Block *remainder = *maybeBlock;
 
   FreeStore store;
@@ -43,12 +47,12 @@ TEST(LlvmLibcFreeStore, RemoveBestFit) {
   ASSERT_TRUE(maybeBlock.has_value());
 
   Block *smallest = *maybeBlock;
-  maybeBlock = smallest->split(sizeof(FreeList::Node) + sizeof(size_t));
+  maybeBlock = smallest->split(sizeof(FreeList::Node) + Block::PREV_FIELD_SIZE);
   ASSERT_TRUE(maybeBlock.has_value());
 
   Block *largest_small = *maybeBlock;
-  maybeBlock = largest_small->split(sizeof(FreeTrie::Node) + sizeof(size_t) -
-                                    alignof(max_align_t));
+  maybeBlock = largest_small->split(
+      sizeof(FreeTrie::Node) + Block::PREV_FIELD_SIZE - alignof(max_align_t));
   ASSERT_TRUE(maybeBlock.has_value());
   if (largest_small->inner_size() == smallest->inner_size())
     largest_small = smallest;
@@ -86,7 +90,7 @@ TEST(LlvmLibcFreeStore, Remove) {
   ASSERT_TRUE(maybeBlock.has_value());
 
   Block *small = *maybeBlock;
-  maybeBlock = small->split(sizeof(FreeList::Node) + sizeof(size_t));
+  maybeBlock = small->split(sizeof(FreeList::Node) + Block::PREV_FIELD_SIZE);
   ASSERT_TRUE(maybeBlock.has_value());
 
   Block *remainder = *maybeBlock;
diff --git a/test/src/__support/hash_test.cpp b/test/src/__support/hash_test.cpp
index f23a43a..94c884c 100644
--- a/test/src/__support/hash_test.cpp
+++ b/test/src/__support/hash_test.cpp
@@ -78,7 +78,7 @@ TEST(LlvmLibcHashTest, Avalanche) {
       }
       for (size_t i = 0; i < sz; ++i) {
         for (size_t j = 0; j < 8; ++j) {
-          uint8_t mask = 1 << j;
+          uint8_t mask = static_cast<uint8_t>(1 << j);
           mem.data[i] ^= mask;
           {
             LIBC_NAMESPACE::internal::HashState state{0xabcdef1234567890};
diff --git a/test/src/__support/integer_to_string_test.cpp b/test/src/__support/integer_to_string_test.cpp
index e644751..7d40065 100644
--- a/test/src/__support/integer_to_string_test.cpp
+++ b/test/src/__support/integer_to_string_test.cpp
@@ -16,6 +16,7 @@
 
 #include "test/UnitTest/Test.h"
 
+using LIBC_NAMESPACE::BigInt;
 using LIBC_NAMESPACE::IntegerToString;
 using LIBC_NAMESPACE::cpp::span;
 using LIBC_NAMESPACE::cpp::string_view;
@@ -40,7 +41,7 @@ TEST(LlvmLibcIntegerToStringTest, UINT8) {
   EXPECT(type, 12, "12");
   EXPECT(type, 123, "123");
   EXPECT(type, UINT8_MAX, "255");
-  EXPECT(type, -1, "255");
+  EXPECT(type, static_cast<uint8_t>(-1), "255");
 }
 
 TEST(LlvmLibcIntegerToStringTest, INT8) {
@@ -64,7 +65,7 @@ TEST(LlvmLibcIntegerToStringTest, UINT16) {
   EXPECT(type, 1234, "1234");
   EXPECT(type, 12345, "12345");
   EXPECT(type, UINT16_MAX, "65535");
-  EXPECT(type, -1, "65535");
+  EXPECT(type, static_cast<uint16_t>(-1), "65535");
 }
 
 TEST(LlvmLibcIntegerToStringTest, INT16) {
@@ -98,7 +99,7 @@ TEST(LlvmLibcIntegerToStringTest, UINT32) {
   EXPECT(type, 123456789, "123456789");
   EXPECT(type, 1234567890, "1234567890");
   EXPECT(type, UINT32_MAX, "4294967295");
-  EXPECT(type, -1, "4294967295");
+  EXPECT(type, static_cast<uint32_t>(-1), "4294967295");
 }
 
 TEST(LlvmLibcIntegerToStringTest, INT32) {
@@ -143,7 +144,7 @@ TEST(LlvmLibcIntegerToStringTest, UINT64) {
   EXPECT(type, 1234567890, "1234567890");
   EXPECT(type, 1234567890123456789, "1234567890123456789");
   EXPECT(type, UINT64_MAX, "18446744073709551615");
-  EXPECT(type, -1, "18446744073709551615");
+  EXPECT(type, static_cast<uint64_t>(-1), "18446744073709551615");
 }
 
 TEST(LlvmLibcIntegerToStringTest, INT64) {
@@ -180,7 +181,8 @@ TEST(LlvmLibcIntegerToStringTest, UINT64_Base_8) {
   EXPECT(type, 0, "0");
   EXPECT(type, 012345, "12345");
   EXPECT(type, 0123456701234567012345, "123456701234567012345");
-  EXPECT(type, 01777777777777777777777, "1777777777777777777777");
+  EXPECT(type, static_cast<int64_t>(01777777777777777777777),
+         "1777777777777777777777");
 }
 
 TEST(LlvmLibcIntegerToStringTest, UINT64_Base_16) {
@@ -297,6 +299,107 @@ TEST(LlvmLibcIntegerToStringTest, Sign) {
   EXPECT(DEC, 1, "+1");
 }
 
+TEST(LlvmLibcIntegerToStringTest, BigInt_Base_10) {
+  uint64_t int256_max_w64[4] = {
+      0xFFFFFFFFFFFFFFFF,
+      0xFFFFFFFFFFFFFFFF,
+      0xFFFFFFFFFFFFFFFF,
+      0x7FFFFFFFFFFFFFFF,
+  };
+  uint64_t int256_min_w64[4] = {
+      0,
+      0,
+      0,
+      0x8000000000000000,
+  };
+  uint32_t int256_max_w32[8] = {
+      0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+      0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF,
+  };
+  uint32_t int256_min_w32[8] = {
+      0, 0, 0, 0, 0, 0, 0, 0x80000000,
+  };
+  uint16_t int256_max_w16[16] = {
+      0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
+      0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x7FFF,
+  };
+  uint16_t int256_min_w16[16] = {
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8000,
+  };
+
+  using unsigned_type_w64 = IntegerToString<BigInt<256, false, uint64_t>, Dec>;
+  EXPECT(unsigned_type_w64, 0, "0");
+  EXPECT(unsigned_type_w64, 1, "1");
+  EXPECT(unsigned_type_w64, -1,
+         "115792089237316195423570985008687907853269984665640564039457584007913"
+         "129639935");
+  EXPECT(unsigned_type_w64, int256_max_w64,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(unsigned_type_w64, int256_min_w64,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819968");
+
+  using unsigned_type_w32 = IntegerToString<BigInt<256, false, uint32_t>, Dec>;
+  EXPECT(unsigned_type_w32, 0, "0");
+  EXPECT(unsigned_type_w32, 1, "1");
+  EXPECT(unsigned_type_w32, -1,
+         "115792089237316195423570985008687907853269984665640564039457584007913"
+         "129639935");
+  EXPECT(unsigned_type_w32, int256_max_w32,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(unsigned_type_w32, int256_min_w32,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819968");
+
+  using unsigned_type_w16 = IntegerToString<BigInt<256, false, uint16_t>, Dec>;
+  EXPECT(unsigned_type_w16, 0, "0");
+  EXPECT(unsigned_type_w16, 1, "1");
+  EXPECT(unsigned_type_w16, -1,
+         "115792089237316195423570985008687907853269984665640564039457584007913"
+         "129639935");
+  EXPECT(unsigned_type_w16, int256_max_w16,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(unsigned_type_w16, int256_min_w16,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819968");
+
+  using signed_type_w64 = IntegerToString<BigInt<256, true, uint64_t>, Dec>;
+  EXPECT(signed_type_w64, 0, "0");
+  EXPECT(signed_type_w64, 1, "1");
+  EXPECT(signed_type_w64, -1, "-1");
+  EXPECT(signed_type_w64, int256_max_w64,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(signed_type_w64, int256_min_w64,
+         "-57896044618658097711785492504343953926634992332820282019728792003956"
+         "564819968");
+
+  using signed_type_w32 = IntegerToString<BigInt<256, true, uint32_t>, Dec>;
+  EXPECT(signed_type_w32, 0, "0");
+  EXPECT(signed_type_w32, 1, "1");
+  EXPECT(signed_type_w32, -1, "-1");
+  EXPECT(signed_type_w32, int256_max_w32,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(signed_type_w32, int256_min_w32,
+         "-57896044618658097711785492504343953926634992332820282019728792003956"
+         "564819968");
+
+  using signed_type_w16 = IntegerToString<BigInt<256, true, uint16_t>, Dec>;
+  EXPECT(signed_type_w16, 0, "0");
+  EXPECT(signed_type_w16, 1, "1");
+  EXPECT(signed_type_w16, -1, "-1");
+  EXPECT(signed_type_w16, int256_max_w16,
+         "578960446186580977117854925043439539266349923328202820197287920039565"
+         "64819967");
+  EXPECT(signed_type_w16, int256_min_w16,
+         "-57896044618658097711785492504343953926634992332820282019728792003956"
+         "564819968");
+}
+
 TEST(LlvmLibcIntegerToStringTest, BufferOverrun) {
   { // Writing '0' in an empty buffer requiring zero digits : works
     const auto view =
diff --git a/test/src/__support/math_extras_test.cpp b/test/src/__support/math_extras_test.cpp
index 08c0900..f5d4dae 100644
--- a/test/src/__support/math_extras_test.cpp
+++ b/test/src/__support/math_extras_test.cpp
@@ -72,34 +72,41 @@ TEST(LlvmLibcBlockMathExtrasTest, mask_trailing_ones) {
 
 TYPED_TEST(LlvmLibcBitTest, FirstLeadingZero, UnsignedTypesNoBigInt) {
   EXPECT_EQ(first_leading_zero<T>(cpp::numeric_limits<T>::max()), 0);
-  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(first_leading_zero<T>(~(T(1) << i)),
-              cpp::numeric_limits<T>::digits - i);
+  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i) {
+    auto lhs = T(~(T(1) << size_t(i)));
+    EXPECT_EQ(first_leading_zero<T>(lhs), cpp::numeric_limits<T>::digits - i);
+  }
 }
 
 TYPED_TEST(LlvmLibcBitTest, FirstLeadingOne, UnsignedTypesNoBigInt) {
   EXPECT_EQ(first_leading_one<T>(static_cast<T>(0)), 0);
-  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(first_leading_one<T>(T(1) << i),
-              cpp::numeric_limits<T>::digits - i);
+  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i) {
+    auto lhs = T(T(1) << size_t(i));
+    EXPECT_EQ(first_leading_one<T>(lhs), cpp::numeric_limits<T>::digits - i);
+  }
 }
 
 TYPED_TEST(LlvmLibcBitTest, FirstTrailingZero, UnsignedTypesNoBigInt) {
   EXPECT_EQ(first_trailing_zero<T>(cpp::numeric_limits<T>::max()), 0);
-  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(first_trailing_zero<T>(~(T(1) << i)), i + 1);
+  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i) {
+    auto lhs = T(~(T(1) << size_t(i)));
+    EXPECT_EQ(first_trailing_zero<T>(lhs), i + 1);
+  }
 }
 
 TYPED_TEST(LlvmLibcBitTest, FirstTrailingOne, UnsignedTypesNoBigInt) {
-  EXPECT_EQ(first_trailing_one<T>(cpp::numeric_limits<T>::max()), 0);
-  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(first_trailing_one<T>(T(1) << i), i + 1);
+  EXPECT_EQ(first_trailing_one<T>(static_cast<T>(0)), 0);
+  EXPECT_EQ(first_trailing_one<T>(cpp::numeric_limits<T>::max()), 1);
+  for (int i = 0U; i != cpp::numeric_limits<T>::digits; ++i) {
+    auto lhs = T(T(1) << size_t(i));
+    EXPECT_EQ(first_trailing_one<T>(lhs), i + 1);
+  }
 }
 
 TYPED_TEST(LlvmLibcBitTest, CountZeros, UnsignedTypesNoBigInt) {
   EXPECT_EQ(count_zeros(T(0)), cpp::numeric_limits<T>::digits);
   for (int i = 0; i != cpp::numeric_limits<T>::digits; ++i)
-    EXPECT_EQ(count_zeros<T>(cpp::numeric_limits<T>::max() >> i), i);
+    EXPECT_EQ(count_zeros<T>(cpp::numeric_limits<T>::max() >> size_t(i)), i);
 }
 
 using UnsignedTypes = testing::TypeList<
diff --git a/test/src/__support/str_to_double_test.cpp b/test/src/__support/str_to_double_test.cpp
index 03d2185..ccfa44f 100644
--- a/test/src/__support/str_to_double_test.cpp
+++ b/test/src/__support/str_to_double_test.cpp
@@ -104,7 +104,7 @@ TEST(LlvmLibcStrToDblTest, SimpleDecimalConversionExtraTypes) {
       internal::simple_decimal_conversion<double>("123456789012345678900");
 
   double_output_mantissa = double_result.num.mantissa;
-  output_exp2 = double_result.num.exponent;
+  output_exp2 = static_cast<uint32_t>(double_result.num.exponent);
 
   EXPECT_EQ(double_output_mantissa, uint64_t(0x1AC53A7E04BCDA));
   EXPECT_EQ(output_exp2, uint32_t(1089));
diff --git a/test/src/__support/str_to_float_test.cpp b/test/src/__support/str_to_float_test.cpp
index fa4c642..66f7db7 100644
--- a/test/src/__support/str_to_float_test.cpp
+++ b/test/src/__support/str_to_float_test.cpp
@@ -59,7 +59,7 @@ TEST(LlvmLibcStrToFltTest, SimpleDecimalConversionExtraTypes) {
   auto float_result =
       internal::simple_decimal_conversion<float>("123456789012345678900");
   float_output_mantissa = float_result.num.mantissa;
-  output_exp2 = float_result.num.exponent;
+  output_exp2 = static_cast<uint32_t>(float_result.num.exponent);
   EXPECT_EQ(float_output_mantissa, uint32_t(0xd629d4));
   EXPECT_EQ(output_exp2, uint32_t(193));
   EXPECT_EQ(float_result.error, 0);
diff --git a/test/src/__support/str_to_fp_test.h b/test/src/__support/str_to_fp_test.h
index db4e62a..c7bc57b 100644
--- a/test/src/__support/str_to_fp_test.h
+++ b/test/src/__support/str_to_fp_test.h
@@ -31,7 +31,7 @@ template <typename T> struct LlvmLibcStrToFloatTest : public testing::Test {
     ASSERT_TRUE(result.has_value());
 
     actual_output_mantissa = result->mantissa;
-    actual_output_exp2 = result->exponent;
+    actual_output_exp2 = static_cast<uint32_t>(result->exponent);
 
     EXPECT_EQ(actual_output_mantissa, expectedOutputMantissa);
     EXPECT_EQ(actual_output_exp2, expectedOutputExp2);
@@ -55,7 +55,7 @@ template <typename T> struct LlvmLibcStrToFloatTest : public testing::Test {
     ASSERT_TRUE(result.has_value());
 
     actual_output_mantissa = result->mantissa;
-    actual_output_exp2 = result->exponent;
+    actual_output_exp2 = static_cast<uint32_t>(result->exponent);
 
     EXPECT_EQ(actual_output_mantissa, expectedOutputMantissa);
     EXPECT_EQ(actual_output_exp2, expectedOutputExp2);
@@ -72,7 +72,7 @@ template <typename T> struct LlvmLibcStrToFloatTest : public testing::Test {
     auto result = internal::simple_decimal_conversion<T>(numStart);
 
     actual_output_mantissa = result.num.mantissa;
-    actual_output_exp2 = result.num.exponent;
+    actual_output_exp2 = static_cast<uint32_t>(result.num.exponent);
 
     EXPECT_EQ(actual_output_mantissa, expectedOutputMantissa);
     EXPECT_EQ(actual_output_exp2, expectedOutputExp2);
diff --git a/test/src/__support/threads/linux/raw_mutex_test.cpp b/test/src/__support/threads/linux/raw_mutex_test.cpp
index 918f5d3..dadc706 100644
--- a/test/src/__support/threads/linux/raw_mutex_test.cpp
+++ b/test/src/__support/threads/linux/raw_mutex_test.cpp
@@ -12,7 +12,7 @@
 #include "src/__support/OSUtil/syscall.h"
 #include "src/__support/threads/linux/raw_mutex.h"
 #include "src/__support/threads/sleep.h"
-#include "src/__support/time/linux/clock_gettime.h"
+#include "src/__support/time/clock_gettime.h"
 #include "src/stdlib/exit.h"
 #include "src/sys/mman/mmap.h"
 #include "src/sys/mman/munmap.h"
diff --git a/test/src/network/htonl_test.cpp b/test/src/arpa/inet/htonl_test.cpp
similarity index 93%
rename from test/src/network/htonl_test.cpp
rename to test/src/arpa/inet/htonl_test.cpp
index f2e2541..4cc1e4c 100644
--- a/test/src/network/htonl_test.cpp
+++ b/test/src/arpa/inet/htonl_test.cpp
@@ -7,8 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/endian_internal.h"
-#include "src/network/htonl.h"
-#include "src/network/ntohl.h"
+#include "src/arpa/inet/htonl.h"
+#include "src/arpa/inet/ntohl.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcHtonl, SmokeTest) {
diff --git a/test/src/network/htons_test.cpp b/test/src/arpa/inet/htons_test.cpp
similarity index 93%
rename from test/src/network/htons_test.cpp
rename to test/src/arpa/inet/htons_test.cpp
index 9668162..6a95ec5 100644
--- a/test/src/network/htons_test.cpp
+++ b/test/src/arpa/inet/htons_test.cpp
@@ -7,8 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/endian_internal.h"
-#include "src/network/htons.h"
-#include "src/network/ntohs.h"
+#include "src/arpa/inet/htons.h"
+#include "src/arpa/inet/ntohs.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcHtons, SmokeTest) {
diff --git a/test/src/network/ntohl_test.cpp b/test/src/arpa/inet/ntohl_test.cpp
similarity index 93%
rename from test/src/network/ntohl_test.cpp
rename to test/src/arpa/inet/ntohl_test.cpp
index b72456b..4256248 100644
--- a/test/src/network/ntohl_test.cpp
+++ b/test/src/arpa/inet/ntohl_test.cpp
@@ -7,8 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/endian_internal.h"
-#include "src/network/htonl.h"
-#include "src/network/ntohl.h"
+#include "src/arpa/inet/htonl.h"
+#include "src/arpa/inet/ntohl.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcNtohl, SmokeTest) {
diff --git a/test/src/network/ntohs_test.cpp b/test/src/arpa/inet/ntohs_test.cpp
similarity index 93%
rename from test/src/network/ntohs_test.cpp
rename to test/src/arpa/inet/ntohs_test.cpp
index 1104356..38b2c8d 100644
--- a/test/src/network/ntohs_test.cpp
+++ b/test/src/arpa/inet/ntohs_test.cpp
@@ -7,8 +7,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/endian_internal.h"
-#include "src/network/htons.h"
-#include "src/network/ntohs.h"
+#include "src/arpa/inet/htons.h"
+#include "src/arpa/inet/ntohs.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcNtohs, SmokeTest) {
diff --git a/test/src/compiler/stack_chk_guard_test.cpp b/test/src/compiler/stack_chk_guard_test.cpp
index 4ec8398..301031f 100644
--- a/test/src/compiler/stack_chk_guard_test.cpp
+++ b/test/src/compiler/stack_chk_guard_test.cpp
@@ -7,24 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "hdr/signal_macros.h"
-#include "src/__support/macros/sanitizer.h"
 #include "src/compiler/__stack_chk_fail.h"
-#include "src/string/memset.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStackChkFail, Death) {
   EXPECT_DEATH([] { __stack_chk_fail(); }, WITH_SIGNAL(SIGABRT));
 }
-
-// Disable the test when asan is enabled so that it doesn't immediately fail
-// after the memset, but before the stack canary is re-checked.
-#ifndef LIBC_HAS_ADDRESS_SANITIZER
-TEST(LlvmLibcStackChkFail, Smash) {
-  EXPECT_DEATH(
-      [] {
-        int arr[20];
-        LIBC_NAMESPACE::memset(arr, 0xAA, 2001);
-      },
-      WITH_SIGNAL(SIGABRT));
-}
-#endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/complex/CImagTest.h b/test/src/complex/CImagTest.h
index 6d2f935..e7c1bf4 100644
--- a/test/src/complex/CImagTest.h
+++ b/test/src/complex/CImagTest.h
@@ -38,9 +38,14 @@ public:
                  neg_min_denormal);
     EXPECT_FP_EQ(func(CFPT(1241.112 + max_denormal * 1.0i)), max_denormal);
     EXPECT_FP_EQ(func(CFPT(121.121 + zero * 1.0i)), zero);
-    EXPECT_FP_EQ(func(CFPT(neg_zero + zero * 1.0i)), zero);
-    EXPECT_FP_EQ(func(CFPT(neg_zero + neg_zero * 1.0i)), neg_zero);
-    EXPECT_FP_EQ(func(CFPT(zero + neg_zero * 1.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(0.0 + 0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0 + 0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(0.0 - 0.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0 - 0.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(0.0)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0)), zero);
+    EXPECT_FP_EQ(func(CFPT(0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0i)), neg_zero);
   }
 
   void testRoundedNumbers(CImagFunc func) {
diff --git a/test/src/complex/CRealTest.h b/test/src/complex/CRealTest.h
index a25555b..a1efe75 100644
--- a/test/src/complex/CRealTest.h
+++ b/test/src/complex/CRealTest.h
@@ -37,8 +37,14 @@ public:
     EXPECT_FP_EQ(func(CFPT(neg_min_denormal + 781.134i)), neg_min_denormal);
     EXPECT_FP_EQ(func(CFPT(max_denormal + 1241.112i)), max_denormal);
     EXPECT_FP_EQ(func(CFPT(zero + 121.121i)), zero);
-    EXPECT_FP_EQ(func(CFPT(neg_zero + neg_zero * 1.0i)), neg_zero);
-    EXPECT_FP_EQ(func(CFPT(neg_zero + zero * 1.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(0.0 + 0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0 + 0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(0.0 - 0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0 - 0.0i)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(0.0)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0)), neg_zero);
+    EXPECT_FP_EQ(func(CFPT(0.0i)), zero);
+    EXPECT_FP_EQ(func(CFPT(-0.0i)), neg_zero);
   }
 
   void testRoundedNumbers(CRealFunc func) {
diff --git a/test/src/complex/ConjTest.h b/test/src/complex/ConjTest.h
new file mode 100644
index 0000000..da4fb4f
--- /dev/null
+++ b/test/src/complex/ConjTest.h
@@ -0,0 +1,131 @@
+//===-- Utility class to test different flavors of conj ---------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_COMPLEX_CONJTEST_H
+#define LLVM_LIBC_TEST_SRC_COMPLEX_CONJTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "hdr/math_macros.h"
+
+template <typename CFPT, typename FPT>
+class ConjTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(FPT)
+
+public:
+  typedef CFPT (*ConjFunc)(CFPT);
+
+  void testSpecialNumbers(ConjFunc func) {
+    EXPECT_CFP_EQ(func(CFPT(aNaN + 67.123i)), CFPT(aNaN - 67.123i));
+    EXPECT_CFP_EQ(func(CFPT(neg_aNaN + 78.319i)), CFPT(neg_aNaN - 78.319i));
+    EXPECT_CFP_EQ(func(CFPT(sNaN + 7813.131i)), CFPT(sNaN - 7813.131i));
+    EXPECT_CFP_EQ(func(CFPT(neg_sNaN + 7824.152i)), CFPT(neg_sNaN - 7824.152i));
+    EXPECT_CFP_EQ(func(CFPT(inf + 9024.2442i)), CFPT(inf - 9024.2442i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf + 8923.124i)), CFPT(neg_inf - 8923.124i));
+    EXPECT_CFP_EQ(func(CFPT(min_normal + 782.124i)),
+                  CFPT(min_normal - 782.124i));
+    EXPECT_CFP_EQ(func(CFPT(max_normal + 2141.2352i)),
+                  CFPT(max_normal - 2141.2352i));
+    EXPECT_CFP_EQ(func(CFPT(neg_max_normal + 341.134i)),
+                  CFPT(neg_max_normal - 341.134i));
+    EXPECT_CFP_EQ(func(CFPT(min_denormal + 781.142i)),
+                  CFPT(min_denormal - 781.142i));
+    EXPECT_CFP_EQ(func(CFPT(neg_min_denormal + 781.134i)),
+                  CFPT(neg_min_denormal - 781.134i));
+    EXPECT_CFP_EQ(func(CFPT(max_denormal + 1241.112i)),
+                  CFPT(max_denormal - 1241.112i));
+    EXPECT_CFP_EQ(func(CFPT(zero + 121.121i)), CFPT(zero - 121.121i));
+    EXPECT_CFP_EQ(func(CFPT(67.123 + aNaN * 1.0i)), CFPT(67.123 - aNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(78.319 + neg_aNaN * 1.0i)),
+                  CFPT(78.319 - neg_aNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(7813.131 + sNaN * 1.0i)),
+                  CFPT(7813.131 - sNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(7824.152 + neg_sNaN * 1.0i)),
+                  CFPT(7824.152 - neg_sNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(9024.2442 + inf * 1.0i)),
+                  CFPT(9024.2442 - inf * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(8923.124 + neg_inf * 1.0i)),
+                  CFPT(8923.124 - neg_inf * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(782.124 + min_normal * 1.0i)),
+                  CFPT(782.124 - min_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(2141.2352 + max_normal * 1.0i)),
+                  CFPT(2141.2352 - max_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(341.134 + neg_max_normal * 1.0i)),
+                  CFPT(341.134 - neg_max_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(781.142 + min_denormal * 1.0i)),
+                  CFPT(781.142 - min_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(781.134 + neg_min_denormal * 1.0i)),
+                  CFPT(781.134 - neg_min_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(1241.112 + max_denormal * 1.0i)),
+                  CFPT(1241.112 - max_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(121.121 + zero * 1.0i)),
+                  CFPT(121.121 - zero * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0 - 0.0i)), CFPT(0.0 + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0 + 0.0i)), CFPT(0.0 - 0.0i));
+    // This test passes because the conjugate of -0.0 - 0.0i is CMPLX(-0.0, 0.0)
+    // which cannot be represented as -0.0 + 0.0i because -0.0 + 0.0i is
+    // actually CMPLX(-0.0, 0.0) + CMPLX(0.0, 0.0) = 0.0 + 0.0i so to represent
+    // CMPLX(-0.0, 0.0), we use -0.0
+    EXPECT_CFP_EQ(func(CFPT(-0.0 - 0.0i)), CFPT(-0.0));
+    // This test passes because -0.0 + 0.0i is actually
+    // CMPLX(-0.0, 0.0) + CMPLX(0.0, 0.0) = CMPLX(-0.0 + 0.0, 0.0) = 0.0 + 0.0i
+    EXPECT_CFP_EQ(func(CFPT(-0.0 + 0.0i)), CFPT(0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0)), CFPT(0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(-0.0)), CFPT(-0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0i)), CFPT(0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(-0.0i)), CFPT(-0.0));
+  }
+
+  void testRoundedNumbers(ConjFunc func) {
+    EXPECT_CFP_EQ(func((CFPT)(4523.1413 + 12413.1414i)),
+                  CFPT(4523.1413 - 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(-4523.1413 + 12413.1414i)),
+                  CFPT(-4523.1413 - 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(4523.1413 - 12413.1414i)),
+                  CFPT(4523.1413 + 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(-4523.1413 - 12413.1414i)),
+                  CFPT(-4523.1413 + 12413.1414i));
+
+    EXPECT_CFP_EQ(func((CFPT)(3210.5678 + 9876.5432i)),
+                  CFPT(3210.5678 - 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(-3210.5678 + 9876.5432i)),
+                  CFPT(-3210.5678 - 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(3210.5678 - 9876.5432i)),
+                  CFPT(3210.5678 + 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(-3210.5678 - 9876.5432i)),
+                  CFPT(-3210.5678 + 9876.5432i));
+
+    EXPECT_CFP_EQ(func((CFPT)(1234.4321 + 4321.1234i)),
+                  CFPT(1234.4321 - 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(-1234.4321 + 4321.1234i)),
+                  CFPT(-1234.4321 - 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(1234.4321 - 4321.1234i)),
+                  CFPT(1234.4321 + 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(-1234.4321 - 4321.1234i)),
+                  CFPT(-1234.4321 + 4321.1234i));
+
+    EXPECT_CFP_EQ(func((CFPT)(6789.1234 + 8765.6789i)),
+                  CFPT(6789.1234 - 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(-6789.1234 + 8765.6789i)),
+                  CFPT(-6789.1234 - 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(6789.1234 - 8765.6789i)),
+                  CFPT(6789.1234 + 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(-6789.1234 - 8765.6789i)),
+                  CFPT(-6789.1234 + 8765.6789i));
+  }
+};
+
+#define LIST_CONJ_TESTS(U, T, func)                                            \
+  using LlvmLibcConjTest = ConjTest<U, T>;                                     \
+  TEST_F(LlvmLibcConjTest, SpecialNumbers) { testSpecialNumbers(&func); }      \
+  TEST_F(LlvmLibcConjTest, RoundedNumbers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_COMPLEX_CONJTEST_H
diff --git a/test/src/complex/CprojTest.h b/test/src/complex/CprojTest.h
new file mode 100644
index 0000000..4e2f6cc
--- /dev/null
+++ b/test/src/complex/CprojTest.h
@@ -0,0 +1,131 @@
+//===-- Utility class to test different flavors of cproj --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_LIBC_TEST_SRC_COMPLEX_CPROJTEST_H
+#define LLVM_LIBC_TEST_SRC_COMPLEX_CPROJTEST_H
+
+#include "test/UnitTest/FEnvSafeTest.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+#include "hdr/math_macros.h"
+
+template <typename CFPT, typename FPT>
+class CprojTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
+
+  DECLARE_SPECIAL_CONSTANTS(FPT)
+
+public:
+  typedef CFPT (*CprojFunc)(CFPT);
+
+  void testSpecialNumbers(CprojFunc func) {
+    EXPECT_CFP_EQ(func(CFPT(inf + 9024.2442i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(inf - 9024.2442i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf + 8923.124i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf - 8923.124i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(9024.2442 + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(9024.2442 + neg_inf * 1.0i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(inf + neg_inf * 1.0i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(inf + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf + neg_inf * 1.0i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(neg_inf + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(aNaN + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(aNaN + neg_inf * 1.0i)), CFPT(inf - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(90.24 + inf * 1.0i)), CFPT(inf + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(89.12 + neg_inf * 1.0i)), CFPT(inf - 0.0i));
+
+    EXPECT_CFP_EQ(func(CFPT(aNaN + 67.123i)), CFPT(aNaN + 67.123i));
+    EXPECT_CFP_EQ(func(CFPT(neg_aNaN + 78.319i)), CFPT(neg_aNaN + 78.319i));
+    EXPECT_CFP_EQ(func(CFPT(sNaN + 7813.131i)), CFPT(sNaN + 7813.131i));
+    EXPECT_CFP_EQ(func(CFPT(neg_sNaN + 7824.152i)), CFPT(neg_sNaN + 7824.152i));
+    EXPECT_CFP_EQ(func(CFPT(min_normal + 782.124i)),
+                  CFPT(min_normal + 782.124i));
+    EXPECT_CFP_EQ(func(CFPT(max_normal + 2141.2352i)),
+                  CFPT(max_normal + 2141.2352i));
+    EXPECT_CFP_EQ(func(CFPT(neg_max_normal + 341.134i)),
+                  CFPT(neg_max_normal + 341.134i));
+    EXPECT_CFP_EQ(func(CFPT(min_denormal + 781.142i)),
+                  CFPT(min_denormal + 781.142i));
+    EXPECT_CFP_EQ(func(CFPT(neg_min_denormal + 781.134i)),
+                  CFPT(neg_min_denormal + 781.134i));
+    EXPECT_CFP_EQ(func(CFPT(max_denormal + 1241.112i)),
+                  CFPT(max_denormal + 1241.112i));
+    EXPECT_CFP_EQ(func(CFPT(zero + 121.121i)), CFPT(zero + 121.121i));
+    EXPECT_CFP_EQ(func(CFPT(67.123 + aNaN * 1.0i)), CFPT(67.123 + aNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(78.319 + neg_aNaN * 1.0i)),
+                  CFPT(78.319 + neg_aNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(7813.131 + sNaN * 1.0i)),
+                  CFPT(7813.131 + sNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(7824.152 + neg_sNaN * 1.0i)),
+                  CFPT(7824.152 + neg_sNaN * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(782.124 + min_normal * 1.0i)),
+                  CFPT(782.124 + min_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(2141.2352 + max_normal * 1.0i)),
+                  CFPT(2141.2352 + max_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(341.134 + neg_max_normal * 1.0i)),
+                  CFPT(341.134 + neg_max_normal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(781.142 + min_denormal * 1.0i)),
+                  CFPT(781.142 + min_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(781.134 + neg_min_denormal * 1.0i)),
+                  CFPT(781.134 + neg_min_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(1241.112 + max_denormal * 1.0i)),
+                  CFPT(1241.112 + max_denormal * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(121.121 + zero * 1.0i)),
+                  CFPT(121.121 + zero * 1.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0 - 0.0i)), CFPT(0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(0.0 + 0.0i)), CFPT(0.0 + 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(-0.0 - 0.0i)), CFPT(-0.0 - 0.0i));
+    EXPECT_CFP_EQ(func(CFPT(-0.0 + 0.0i)), CFPT(-0.0 + 0.0i));
+  }
+
+  void testRoundedNumbers(CprojFunc func) {
+    EXPECT_CFP_EQ(func((CFPT)(4523.1413 + 12413.1414i)),
+                  CFPT(4523.1413 + 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(-4523.1413 + 12413.1414i)),
+                  CFPT(-4523.1413 + 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(4523.1413 - 12413.1414i)),
+                  CFPT(4523.1413 - 12413.1414i));
+    EXPECT_CFP_EQ(func((CFPT)(-4523.1413 - 12413.1414i)),
+                  CFPT(-4523.1413 - 12413.1414i));
+
+    EXPECT_CFP_EQ(func((CFPT)(3210.5678 + 9876.5432i)),
+                  CFPT(3210.5678 + 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(-3210.5678 + 9876.5432i)),
+                  CFPT(-3210.5678 + 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(3210.5678 - 9876.5432i)),
+                  CFPT(3210.5678 - 9876.5432i));
+    EXPECT_CFP_EQ(func((CFPT)(-3210.5678 - 9876.5432i)),
+                  CFPT(-3210.5678 - 9876.5432i));
+
+    EXPECT_CFP_EQ(func((CFPT)(1234.4321 + 4321.1234i)),
+                  CFPT(1234.4321 + 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(-1234.4321 + 4321.1234i)),
+                  CFPT(-1234.4321 + 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(1234.4321 - 4321.1234i)),
+                  CFPT(1234.4321 - 4321.1234i));
+    EXPECT_CFP_EQ(func((CFPT)(-1234.4321 - 4321.1234i)),
+                  CFPT(-1234.4321 - 4321.1234i));
+
+    EXPECT_CFP_EQ(func((CFPT)(6789.1234 + 8765.6789i)),
+                  CFPT(6789.1234 + 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(-6789.1234 + 8765.6789i)),
+                  CFPT(-6789.1234 + 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(6789.1234 - 8765.6789i)),
+                  CFPT(6789.1234 - 8765.6789i));
+    EXPECT_CFP_EQ(func((CFPT)(-6789.1234 - 8765.6789i)),
+                  CFPT(-6789.1234 - 8765.6789i));
+  }
+};
+
+#define LIST_CPROJ_TESTS(U, T, func)                                           \
+  using LlvmLibcCprojTest = CprojTest<U, T>;                                   \
+  TEST_F(LlvmLibcCprojTest, SpecialNumbers) { testSpecialNumbers(&func); }     \
+  TEST_F(LlvmLibcCprojTest, RoundedNumbers) { testRoundedNumbers(&func); }
+
+#endif // LLVM_LIBC_TEST_SRC_COMPLEX_CPROJTEST_H
diff --git a/test/src/complex/cimagf128_test.cpp b/test/src/complex/cimagf128_test.cpp
index 50ddc0a..70ad0de 100644
--- a/test/src/complex/cimagf128_test.cpp
+++ b/test/src/complex/cimagf128_test.cpp
@@ -10,8 +10,4 @@
 
 #include "src/complex/cimagf128.h"
 
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 LIST_CIMAG_TESTS(cfloat128, float128, LIBC_NAMESPACE::cimagf128)
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/test/src/complex/cimagf16_test.cpp b/test/src/complex/cimagf16_test.cpp
index 65a6978..3842381 100644
--- a/test/src/complex/cimagf16_test.cpp
+++ b/test/src/complex/cimagf16_test.cpp
@@ -10,8 +10,4 @@
 
 #include "src/complex/cimagf16.h"
 
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 LIST_CIMAG_TESTS(cfloat16, float16, LIBC_NAMESPACE::cimagf16)
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/test/src/complex/conj_test.cpp b/test/src/complex/conj_test.cpp
new file mode 100644
index 0000000..97445fa
--- /dev/null
+++ b/test/src/complex/conj_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for conj ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ConjTest.h"
+
+#include "src/complex/conj.h"
+
+LIST_CONJ_TESTS(_Complex double, double, LIBC_NAMESPACE::conj)
diff --git a/test/src/complex/conjf128_test.cpp b/test/src/complex/conjf128_test.cpp
new file mode 100644
index 0000000..4c2a72c
--- /dev/null
+++ b/test/src/complex/conjf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for conjf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ConjTest.h"
+
+#include "src/complex/conjf128.h"
+
+LIST_CONJ_TESTS(cfloat128, float128, LIBC_NAMESPACE::conjf128)
diff --git a/test/src/complex/conjf16_test.cpp b/test/src/complex/conjf16_test.cpp
new file mode 100644
index 0000000..374f9ec
--- /dev/null
+++ b/test/src/complex/conjf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for conjf16 ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ConjTest.h"
+
+#include "src/complex/conjf16.h"
+
+LIST_CONJ_TESTS(cfloat16, float16, LIBC_NAMESPACE::conjf16)
diff --git a/test/src/complex/conjf_test.cpp b/test/src/complex/conjf_test.cpp
new file mode 100644
index 0000000..34b00b3
--- /dev/null
+++ b/test/src/complex/conjf_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for conjf -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ConjTest.h"
+
+#include "src/complex/conjf.h"
+
+LIST_CONJ_TESTS(_Complex float, float, LIBC_NAMESPACE::conjf)
diff --git a/test/src/complex/conjl_test.cpp b/test/src/complex/conjl_test.cpp
new file mode 100644
index 0000000..ec299f9
--- /dev/null
+++ b/test/src/complex/conjl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for conjl -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "ConjTest.h"
+
+#include "src/complex/conjl.h"
+
+LIST_CONJ_TESTS(_Complex long double, long double, LIBC_NAMESPACE::conjl)
diff --git a/test/src/complex/cproj_test.cpp b/test/src/complex/cproj_test.cpp
new file mode 100644
index 0000000..83e5760
--- /dev/null
+++ b/test/src/complex/cproj_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cproj -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CprojTest.h"
+
+#include "src/complex/cproj.h"
+
+LIST_CPROJ_TESTS(_Complex double, double, LIBC_NAMESPACE::cproj)
diff --git a/test/src/complex/cprojf128_test.cpp b/test/src/complex/cprojf128_test.cpp
new file mode 100644
index 0000000..7b41eb5
--- /dev/null
+++ b/test/src/complex/cprojf128_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cprojf128 -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CprojTest.h"
+
+#include "src/complex/cprojf128.h"
+
+LIST_CPROJ_TESTS(cfloat128, float128, LIBC_NAMESPACE::cprojf128)
diff --git a/test/src/complex/cprojf16_test.cpp b/test/src/complex/cprojf16_test.cpp
new file mode 100644
index 0000000..db9b7b9
--- /dev/null
+++ b/test/src/complex/cprojf16_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cprojf16 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CprojTest.h"
+
+#include "src/complex/cprojf16.h"
+
+LIST_CPROJ_TESTS(cfloat16, float16, LIBC_NAMESPACE::cprojf16)
diff --git a/test/src/complex/cprojf_test.cpp b/test/src/complex/cprojf_test.cpp
new file mode 100644
index 0000000..4635aa1
--- /dev/null
+++ b/test/src/complex/cprojf_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for cprojf ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CprojTest.h"
+
+#include "src/complex/cprojf.h"
+
+#include "utils/MPCWrapper/MPCUtils.h"
+
+using LlvmLibcCprojTestMPC = LIBC_NAMESPACE::testing::FPTest<float>;
+
+namespace mpc = LIBC_NAMESPACE::testing::mpc;
+
+TEST_F(LlvmLibcCprojTestMPC, MPCRND) {
+  _Complex float test = 5.0 + 10.0i;
+  EXPECT_MPC_MATCH_ALL_ROUNDING(mpc::Operation::Cproj, test,
+                                LIBC_NAMESPACE::cprojf(test), 0.5);
+}
+
+LIST_CPROJ_TESTS(_Complex float, float, LIBC_NAMESPACE::cprojf)
diff --git a/test/src/complex/cprojl_test.cpp b/test/src/complex/cprojl_test.cpp
new file mode 100644
index 0000000..0858bf4
--- /dev/null
+++ b/test/src/complex/cprojl_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for cprojl ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CprojTest.h"
+
+#include "src/complex/cprojl.h"
+
+LIST_CPROJ_TESTS(_Complex long double, long double, LIBC_NAMESPACE::cprojl)
diff --git a/test/src/complex/crealf128_test.cpp b/test/src/complex/crealf128_test.cpp
index 7626eee..0d1c26d 100644
--- a/test/src/complex/crealf128_test.cpp
+++ b/test/src/complex/crealf128_test.cpp
@@ -10,8 +10,4 @@
 
 #include "src/complex/crealf128.h"
 
-#if defined(LIBC_TYPES_HAS_CFLOAT128)
-
 LIST_CREAL_TESTS(cfloat128, float128, LIBC_NAMESPACE::crealf128)
-
-#endif // LIBC_TYPES_HAS_CFLOAT128
diff --git a/test/src/complex/crealf16_test.cpp b/test/src/complex/crealf16_test.cpp
index 97346aa..b8560d7 100644
--- a/test/src/complex/crealf16_test.cpp
+++ b/test/src/complex/crealf16_test.cpp
@@ -10,8 +10,4 @@
 
 #include "src/complex/crealf16.h"
 
-#if defined(LIBC_TYPES_HAS_CFLOAT16)
-
 LIST_CREAL_TESTS(cfloat16, float16, LIBC_NAMESPACE::crealf16)
-
-#endif // LIBC_TYPES_HAS_CFLOAT16
diff --git a/test/src/ctype/isalnum_test.cpp b/test/src/ctype/isalnum_test.cpp
index b71d361..cfc54e9 100644
--- a/test/src/ctype/isalnum_test.cpp
+++ b/test/src/ctype/isalnum_test.cpp
@@ -6,18 +6,49 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/isalnum.h"
 
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char ALNUM_ARRAY[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsAlNum, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::isalnum('a'), 0);
+  EXPECT_NE(LIBC_NAMESPACE::isalnum('B'), 0);
+  EXPECT_NE(LIBC_NAMESPACE::isalnum('3'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::isalnum(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalnum('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalnum('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalnum(-1), 0);
+}
+
 TEST(LlvmLibcIsAlNum, DefaultLocale) {
   // Loops through all characters, verifying that numbers and letters
   // return non-zero integer and everything else returns a zero.
-  for (int c = -255; c < 255; ++c) {
-    if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') ||
-        ('0' <= c && c <= '9'))
-      EXPECT_NE(LIBC_NAMESPACE::isalnum(c), 0);
+  for (int ch = -255; ch < 255; ++ch) {
+    if (in_span(ch, ALNUM_ARRAY))
+      EXPECT_NE(LIBC_NAMESPACE::isalnum(ch), 0);
     else
-      EXPECT_EQ(LIBC_NAMESPACE::isalnum(c), 0);
+      EXPECT_EQ(LIBC_NAMESPACE::isalnum(ch), 0);
   }
 }
diff --git a/test/src/ctype/isalpha_test.cpp b/test/src/ctype/isalpha_test.cpp
index 10cdb96..1e439cf 100644
--- a/test/src/ctype/isalpha_test.cpp
+++ b/test/src/ctype/isalpha_test.cpp
@@ -6,15 +6,47 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/isalpha.h"
 
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char ALPHA_ARRAY[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsAlpha, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::isalpha('a'), 0);
+  EXPECT_NE(LIBC_NAMESPACE::isalpha('B'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::isalpha('3'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalpha(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalpha('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalpha('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isalpha(-1), 0);
+}
+
 TEST(LlvmLibcIsAlpha, DefaultLocale) {
   // Loops through all characters, verifying that letters return a
   // non-zero integer and everything else returns zero.
+  // TODO: encoding indep
   for (int ch = -255; ch < 255; ++ch) {
-    if (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'))
+    if (in_span(ch, ALPHA_ARRAY))
       EXPECT_NE(LIBC_NAMESPACE::isalpha(ch), 0);
     else
       EXPECT_EQ(LIBC_NAMESPACE::isalpha(ch), 0);
diff --git a/test/src/ctype/isdigit_test.cpp b/test/src/ctype/isdigit_test.cpp
index a9f84db..0ee132d 100644
--- a/test/src/ctype/isdigit_test.cpp
+++ b/test/src/ctype/isdigit_test.cpp
@@ -6,15 +6,43 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/isdigit.h"
 
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char DIGIT_ARRAY[] = {
+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsDigit, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::isdigit('3'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit('a'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit('B'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isdigit(-1), 0);
+}
+
 TEST(LlvmLibcIsDigit, DefaultLocale) {
-  // Loops through all characters, verifying that numbers return a
-  // non-zero integer and everything else returns zero.
+  // Loops through all characters, verifying that numbers and letters
+  // return non-zero integer and everything else returns a zero.
   for (int ch = -255; ch < 255; ++ch) {
-    if ('0' <= ch && ch <= '9')
+    if (in_span(ch, DIGIT_ARRAY))
       EXPECT_NE(LIBC_NAMESPACE::isdigit(ch), 0);
     else
       EXPECT_EQ(LIBC_NAMESPACE::isdigit(ch), 0);
diff --git a/test/src/ctype/islower_test.cpp b/test/src/ctype/islower_test.cpp
index ba7caf6..f877171 100644
--- a/test/src/ctype/islower_test.cpp
+++ b/test/src/ctype/islower_test.cpp
@@ -6,14 +6,44 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/islower.h"
+
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char LOWER_ARRAY[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsLower, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::islower('a'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::islower('B'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::islower('3'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::islower(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::islower('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::islower('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::islower(-1), 0);
+}
+
 TEST(LlvmLibcIsLower, DefaultLocale) {
-  // Loops through all characters, verifying that lowercase letters
-  // return a non-zero integer and everything else returns zero.
+  // Loops through all characters, verifying that numbers and letters
+  // return non-zero integer and everything else returns a zero.
   for (int ch = -255; ch < 255; ++ch) {
-    if ('a' <= ch && ch <= 'z')
+    if (in_span(ch, LOWER_ARRAY))
       EXPECT_NE(LIBC_NAMESPACE::islower(ch), 0);
     else
       EXPECT_EQ(LIBC_NAMESPACE::islower(ch), 0);
diff --git a/test/src/ctype/isupper_test.cpp b/test/src/ctype/isupper_test.cpp
index 05b2fd0..151ed23 100644
--- a/test/src/ctype/isupper_test.cpp
+++ b/test/src/ctype/isupper_test.cpp
@@ -6,14 +6,44 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/isupper.h"
+
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char UPPER_ARRAY[] = {
+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsUpper, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::isupper('B'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::isupper('a'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isupper('3'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isupper(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isupper('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isupper('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isupper(-1), 0);
+}
+
 TEST(LlvmLibcIsUpper, DefaultLocale) {
-  // Loops through all characters, verifying that uppercase letters
-  // return a non-zero integer and everything else returns zero.
+  // Loops through all characters, verifying that numbers and letters
+  // return non-zero integer and everything else returns a zero.
   for (int ch = -255; ch < 255; ++ch) {
-    if ('A' <= ch && ch <= 'Z')
+    if (in_span(ch, UPPER_ARRAY))
       EXPECT_NE(LIBC_NAMESPACE::isupper(ch), 0);
     else
       EXPECT_EQ(LIBC_NAMESPACE::isupper(ch), 0);
diff --git a/test/src/ctype/isxdigit_test.cpp b/test/src/ctype/isxdigit_test.cpp
index b8f27a9..ec58f0d 100644
--- a/test/src/ctype/isxdigit_test.cpp
+++ b/test/src/ctype/isxdigit_test.cpp
@@ -6,13 +6,45 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/isxdigit.h"
+
 #include "test/UnitTest/Test.h"
 
-TEST(LlvmLibcIsXDigit, DefaultLocale) {
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+constexpr char XDIGIT_ARRAY[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E',
+    'F', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+};
+
+bool in_span(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return true;
+  return false;
+}
+
+} // namespace
+
+TEST(LlvmLibcIsXdigit, SimpleTest) {
+  EXPECT_NE(LIBC_NAMESPACE::isxdigit('a'), 0);
+  EXPECT_NE(LIBC_NAMESPACE::isxdigit('B'), 0);
+  EXPECT_NE(LIBC_NAMESPACE::isxdigit('3'), 0);
+
+  EXPECT_EQ(LIBC_NAMESPACE::isxdigit('z'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isxdigit(' '), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isxdigit('?'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isxdigit('\0'), 0);
+  EXPECT_EQ(LIBC_NAMESPACE::isxdigit(-1), 0);
+}
+
+TEST(LlvmLibcIsXdigit, DefaultLocale) {
+  // Loops through all characters, verifying that numbers and letters
+  // return non-zero integer and everything else returns a zero.
   for (int ch = -255; ch < 255; ++ch) {
-    if (('0' <= ch && ch <= '9') || ('a' <= ch && ch <= 'f') ||
-        ('A' <= ch && ch <= 'F'))
+    if (in_span(ch, XDIGIT_ARRAY))
       EXPECT_NE(LIBC_NAMESPACE::isxdigit(ch), 0);
     else
       EXPECT_EQ(LIBC_NAMESPACE::isxdigit(ch), 0);
diff --git a/test/src/ctype/tolower_test.cpp b/test/src/ctype/tolower_test.cpp
index 3770ce4..fbcc5b8 100644
--- a/test/src/ctype/tolower_test.cpp
+++ b/test/src/ctype/tolower_test.cpp
@@ -6,14 +6,55 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/tolower.h"
+
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+// Invariant: UPPER_ARR and LOWER_ARR are both the complete alphabet in the same
+// order.
+constexpr char UPPER_ARR[] = {
+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+};
+constexpr char LOWER_ARR[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+};
+
+static_assert(
+    sizeof(UPPER_ARR) == sizeof(LOWER_ARR),
+    "There must be the same number of uppercase and lowercase letters.");
+
+int span_index(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return static_cast<int>(i);
+  return -1;
+}
+
+} // namespace
+
+TEST(LlvmLibcToLower, SimpleTest) {
+  EXPECT_EQ(LIBC_NAMESPACE::tolower('a'), int('a'));
+  EXPECT_EQ(LIBC_NAMESPACE::tolower('B'), int('b'));
+  EXPECT_EQ(LIBC_NAMESPACE::tolower('3'), int('3'));
+
+  EXPECT_EQ(LIBC_NAMESPACE::tolower(' '), int(' '));
+  EXPECT_EQ(LIBC_NAMESPACE::tolower('?'), int('?'));
+  EXPECT_EQ(LIBC_NAMESPACE::tolower('\0'), int('\0'));
+  EXPECT_EQ(LIBC_NAMESPACE::tolower(-1), int(-1));
+}
+
 TEST(LlvmLibcToLower, DefaultLocale) {
   for (int ch = -255; ch < 255; ++ch) {
-    // This follows pattern 'A' + 32 = 'a'.
-    if ('A' <= ch && ch <= 'Z')
-      EXPECT_EQ(LIBC_NAMESPACE::tolower(ch), ch + 32);
+    int char_index = span_index(ch, UPPER_ARR);
+    if (char_index != -1)
+      EXPECT_EQ(LIBC_NAMESPACE::tolower(ch),
+                static_cast<int>(LOWER_ARR[char_index]));
     else
       EXPECT_EQ(LIBC_NAMESPACE::tolower(ch), ch);
   }
diff --git a/test/src/ctype/toupper_test.cpp b/test/src/ctype/toupper_test.cpp
index 0413b43..409b3cd 100644
--- a/test/src/ctype/toupper_test.cpp
+++ b/test/src/ctype/toupper_test.cpp
@@ -6,14 +6,55 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/CPP/span.h"
 #include "src/ctype/toupper.h"
+
 #include "test/UnitTest/Test.h"
 
+namespace {
+
+// TODO: Merge the ctype tests using this framework.
+// Invariant: UPPER_ARR and LOWER_ARR are both the complete alphabet in the same
+// order.
+constexpr char UPPER_ARR[] = {
+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+};
+constexpr char LOWER_ARR[] = {
+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+};
+
+static_assert(
+    sizeof(UPPER_ARR) == sizeof(LOWER_ARR),
+    "There must be the same number of uppercase and lowercase letters.");
+
+int span_index(int ch, LIBC_NAMESPACE::cpp::span<const char> arr) {
+  for (size_t i = 0; i < arr.size(); ++i)
+    if (static_cast<int>(arr[i]) == ch)
+      return static_cast<int>(i);
+  return -1;
+}
+
+} // namespace
+
+TEST(LlvmLibcToUpper, SimpleTest) {
+  EXPECT_EQ(LIBC_NAMESPACE::toupper('a'), int('A'));
+  EXPECT_EQ(LIBC_NAMESPACE::toupper('B'), int('B'));
+  EXPECT_EQ(LIBC_NAMESPACE::toupper('3'), int('3'));
+
+  EXPECT_EQ(LIBC_NAMESPACE::toupper(' '), int(' '));
+  EXPECT_EQ(LIBC_NAMESPACE::toupper('?'), int('?'));
+  EXPECT_EQ(LIBC_NAMESPACE::toupper('\0'), int('\0'));
+  EXPECT_EQ(LIBC_NAMESPACE::toupper(-1), int(-1));
+}
+
 TEST(LlvmLibcToUpper, DefaultLocale) {
   for (int ch = -255; ch < 255; ++ch) {
-    // This follows pattern 'a' - 32 = 'A'.
-    if ('a' <= ch && ch <= 'z')
-      EXPECT_EQ(LIBC_NAMESPACE::toupper(ch), ch - 32);
+    int char_index = span_index(ch, LOWER_ARR);
+    if (char_index != -1)
+      EXPECT_EQ(LIBC_NAMESPACE::toupper(ch),
+                static_cast<int>(UPPER_ARR[char_index]));
     else
       EXPECT_EQ(LIBC_NAMESPACE::toupper(ch), ch);
   }
diff --git a/test/src/fcntl/openat_test.cpp b/test/src/fcntl/openat_test.cpp
index 547359e..213b074 100644
--- a/test/src/fcntl/openat_test.cpp
+++ b/test/src/fcntl/openat_test.cpp
@@ -24,7 +24,7 @@ TEST(LlvmLibcUniStd, OpenAndReadTest) {
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(dir_fd, 0);
   constexpr const char TEST_MSG[] = "openat test";
-  constexpr int TEST_MSG_SIZE = sizeof(TEST_MSG) - 1;
+  constexpr ssize_t TEST_MSG_SIZE = sizeof(TEST_MSG) - 1;
 
   int read_fd = LIBC_NAMESPACE::openat(dir_fd, TEST_FILE, O_RDONLY);
   ASSERT_ERRNO_SUCCESS();
diff --git a/test/src/locale/locale_test.cpp b/test/src/locale/locale_test.cpp
index bc48bb8..d800e8f 100644
--- a/test/src/locale/locale_test.cpp
+++ b/test/src/locale/locale_test.cpp
@@ -6,14 +6,12 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/locale_macros.h"
 #include "src/locale/freelocale.h"
 #include "src/locale/newlocale.h"
 #include "src/locale/uselocale.h"
-
 #include "test/UnitTest/Test.h"
 
-#include "include/llvm-libc-macros/locale-macros.h"
-
 TEST(LlvmLibcLocale, DefaultLocale) {
   locale_t new_locale = LIBC_NAMESPACE::newlocale(LC_ALL, "C", nullptr);
   EXPECT_NE(new_locale, static_cast<locale_t>(nullptr));
diff --git a/test/src/locale/localeconv_test.cpp b/test/src/locale/localeconv_test.cpp
index 7926427..4a78881 100644
--- a/test/src/locale/localeconv_test.cpp
+++ b/test/src/locale/localeconv_test.cpp
@@ -6,9 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "include/llvm-libc-macros/locale-macros.h"
+#include "hdr/locale_macros.h"
 #include "src/locale/localeconv.h"
-
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcLocale, DefaultLocale) {
diff --git a/test/src/math/AddTest.h b/test/src/math/AddTest.h
index df0ef66..370cc2b 100644
--- a/test/src/math/AddTest.h
+++ b/test/src/math/AddTest.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
 #define LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
 
+#include "src/__support/CPP/algorithm.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
@@ -36,16 +37,19 @@ class AddTest : public LIBC_NAMESPACE::testing::FEnvSafeTest {
       InFPBits::min_subnormal().uintval();
 
 public:
-  typedef OutType (*AddFunc)(InType, InType);
+  using AddFunc = OutType (*)(InType, InType);
 
   void test_subnormal_range(AddFunc func) {
-    constexpr InStorageType COUNT = 100'001;
-    constexpr InStorageType STEP =
-        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
-    for (InStorageType i = 0, v = 0, w = IN_MAX_SUBNORMAL_U; i <= COUNT;
-         ++i, v += STEP, w -= STEP) {
-      InType x = InFPBits(v).get_val();
-      InType y = InFPBits(w).get_val();
+    constexpr int COUNT = 100'001;
+    constexpr InStorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<InStorageType>((IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) /
+                                   COUNT),
+        InStorageType(1));
+    for (InStorageType i = IN_MIN_SUBNORMAL_U; i <= IN_MAX_SUBNORMAL_U;
+         i += STEP) {
+      InType x = InFPBits(i).get_val();
+      InType y = InFPBits(static_cast<InStorageType>(IN_MAX_SUBNORMAL_U - i))
+                     .get_val();
       mpfr::BinaryInput<InType> input{x, y};
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Add, input, func(x, y),
                                      0.5);
@@ -53,12 +57,14 @@ public:
   }
 
   void test_normal_range(AddFunc func) {
-    constexpr InStorageType COUNT = 100'001;
-    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
-    for (InStorageType i = 0, v = 0, w = IN_MAX_NORMAL_U; i <= COUNT;
-         ++i, v += STEP, w -= STEP) {
-      InType x = InFPBits(v).get_val();
-      InType y = InFPBits(w).get_val();
+    constexpr int COUNT = 100'001;
+    constexpr InStorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<InStorageType>((IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT),
+        InStorageType(1));
+    for (InStorageType i = IN_MIN_NORMAL_U; i <= IN_MAX_NORMAL_U; i += STEP) {
+      InType x = InFPBits(i).get_val();
+      InType y =
+          InFPBits(static_cast<InStorageType>(IN_MAX_NORMAL_U - i)).get_val();
       mpfr::BinaryInput<InType> input{x, y};
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Add, input, func(x, y),
                                      0.5);
@@ -71,4 +77,11 @@ public:
   TEST_F(LlvmLibcAddTest, SubnormalRange) { test_subnormal_range(&func); }     \
   TEST_F(LlvmLibcAddTest, NormalRange) { test_normal_range(&func); }
 
+#define LIST_ADD_SAME_TYPE_TESTS(suffix, OutType, InType, func)                \
+  using LlvmLibcAddTest##suffix = AddTest<OutType, InType>;                    \
+  TEST_F(LlvmLibcAddTest##suffix, SubnormalRange) {                            \
+    test_subnormal_range(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcAddTest##suffix, NormalRange) { test_normal_range(&func); }
+
 #endif // LLVM_LIBC_TEST_SRC_MATH_ADDTEST_H
diff --git a/test/src/math/CopySignTest.h b/test/src/math/CopySignTest.h
index 8db4f69..7c46d1b 100644
--- a/test/src/math/CopySignTest.h
+++ b/test/src/math/CopySignTest.h
@@ -42,10 +42,10 @@ public:
       if (FPBits(v).is_nan() || FPBits(v).is_inf())
         continue;
 
-      double res1 = func(x, -x);
+      T res1 = func(x, -x);
       ASSERT_FP_EQ(res1, -x);
 
-      double res2 = func(x, x);
+      T res2 = func(x, x);
       ASSERT_FP_EQ(res2, x);
     }
   }
diff --git a/test/src/math/FMaxTest.h b/test/src/math/FMaxTest.h
index 43904a4..7724090 100644
--- a/test/src/math/FMaxTest.h
+++ b/test/src/math/FMaxTest.h
@@ -29,8 +29,8 @@ public:
   void testNaN(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(aNaN, inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -38,25 +38,25 @@ public:
 
   void testInfArg(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(inf, func(inf, 0.0));
-    EXPECT_FP_EQ(inf, func(-0.0, inf));
+    EXPECT_FP_EQ(inf, func(inf, zero));
+    EXPECT_FP_EQ(inf, func(neg_zero, inf));
     EXPECT_FP_EQ(inf, func(inf, T(1.2345)));
     EXPECT_FP_EQ(inf, func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMaxFunc func) {
     EXPECT_FP_EQ(inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(0.0, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(zero, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(T(-1.2345), func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMaxFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMaxFunc func) {
diff --git a/test/src/math/FMinTest.h b/test/src/math/FMinTest.h
index 51c21ae..3822d7c 100644
--- a/test/src/math/FMinTest.h
+++ b/test/src/math/FMinTest.h
@@ -30,8 +30,8 @@ public:
   void testNaN(FMinFunc func) {
     EXPECT_FP_EQ(inf, func(aNaN, inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, aNaN));
-    EXPECT_FP_EQ(0.0, func(aNaN, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, aNaN));
+    EXPECT_FP_EQ(zero, func(aNaN, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, aNaN));
     EXPECT_FP_EQ(T(-1.2345), func(aNaN, T(-1.2345)));
     EXPECT_FP_EQ(T(1.2345), func(T(1.2345), aNaN));
     EXPECT_FP_EQ(aNaN, func(aNaN, aNaN));
@@ -39,25 +39,25 @@ public:
 
   void testInfArg(FMinFunc func) {
     EXPECT_FP_EQ(neg_inf, func(neg_inf, inf));
-    EXPECT_FP_EQ(0.0, func(inf, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, inf));
+    EXPECT_FP_EQ(zero, func(inf, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, inf));
     EXPECT_FP_EQ(T(1.2345), func(inf, T(1.2345)));
     EXPECT_FP_EQ(T(-1.2345), func(T(-1.2345), inf));
   }
 
   void testNegInfArg(FMinFunc func) {
     EXPECT_FP_EQ(neg_inf, func(inf, neg_inf));
-    EXPECT_FP_EQ(neg_inf, func(neg_inf, 0.0));
-    EXPECT_FP_EQ(neg_inf, func(-0.0, neg_inf));
+    EXPECT_FP_EQ(neg_inf, func(neg_inf, zero));
+    EXPECT_FP_EQ(neg_inf, func(neg_zero, neg_inf));
     EXPECT_FP_EQ(neg_inf, func(neg_inf, T(-1.2345)));
     EXPECT_FP_EQ(neg_inf, func(T(1.2345), neg_inf));
   }
 
   void testBothZero(FMinFunc func) {
-    EXPECT_FP_EQ(0.0, func(0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, 0.0));
-    EXPECT_FP_EQ(-0.0, func(0.0, -0.0));
-    EXPECT_FP_EQ(-0.0, func(-0.0, -0.0));
+    EXPECT_FP_EQ(zero, func(zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, zero));
+    EXPECT_FP_EQ(neg_zero, func(zero, neg_zero));
+    EXPECT_FP_EQ(neg_zero, func(neg_zero, neg_zero));
   }
 
   void testRange(FMinFunc func) {
diff --git a/test/src/math/FModTest.h b/test/src/math/FModTest.h
index 32c009a..f761dba 100644
--- a/test/src/math/FModTest.h
+++ b/test/src/math/FModTest.h
@@ -54,7 +54,7 @@ public:
 
     // fmod (+inf, y) == aNaN plus invalid exception.
     TEST_SPECIAL(inf, 3.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(inf, -1.1L, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(inf, static_cast<float>(-1.1L), aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, 0.0, aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(inf, min_denormal, aNaN, true, FE_INVALID);
@@ -65,7 +65,7 @@ public:
 
     // fmod (-inf, y) == aNaN plus invalid exception.
     TEST_SPECIAL(neg_inf, 3.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(neg_inf, -1.1L, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(neg_inf, static_cast<float>(-1.1L), aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, 0.0, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_inf, min_denormal, aNaN, true, FE_INVALID);
@@ -76,7 +76,7 @@ public:
 
     // fmod (x, +0) == aNaN plus invalid exception.
     TEST_SPECIAL(3.0, 0.0, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(-1.1L, 0.0, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(static_cast<float>(-1.1L), 0.0, aNaN, true, FE_INVALID);
     TEST_SPECIAL(0.0, 0.0, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_zero, 0.0, aNaN, true, FE_INVALID);
     TEST_SPECIAL(min_denormal, 0.0, aNaN, true, FE_INVALID);
@@ -85,7 +85,7 @@ public:
 
     // fmod (x, -0) == aNaN plus invalid exception.
     TEST_SPECIAL(3.0, neg_zero, aNaN, true, FE_INVALID);
-    TEST_SPECIAL(-1.1L, neg_zero, aNaN, true, FE_INVALID);
+    TEST_SPECIAL(static_cast<float>(-1.1L), neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(0.0, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(neg_zero, neg_zero, aNaN, true, FE_INVALID);
     TEST_SPECIAL(min_denormal, neg_zero, aNaN, true, FE_INVALID);
diff --git a/test/src/math/FrexpTest.h b/test/src/math/FrexpTest.h
index 74a2d60..d1151c8 100644
--- a/test/src/math/FrexpTest.h
+++ b/test/src/math/FrexpTest.h
@@ -33,10 +33,10 @@ public:
     ASSERT_FP_EQ(inf, func(inf, &exponent));
     ASSERT_FP_EQ(neg_inf, func(neg_inf, &exponent));
 
-    ASSERT_FP_EQ(0.0, func(0.0, &exponent));
+    ASSERT_FP_EQ(zero, func(zero, &exponent));
     ASSERT_EQ(exponent, 0);
 
-    ASSERT_FP_EQ(-0.0, func(-0.0, &exponent));
+    ASSERT_FP_EQ(neg_zero, func(neg_zero, &exponent));
     ASSERT_EQ(exponent, 0);
   }
 
diff --git a/test/src/math/NextAfterTest.h b/test/src/math/NextAfterTest.h
index d97c264..82d5378 100644
--- a/test/src/math/NextAfterTest.h
+++ b/test/src/math/NextAfterTest.h
@@ -100,7 +100,7 @@ public:
     expected_bits = min_subnormal + 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ(result, expected);
-    ASSERT_FP_EQ(func(x, 0), 0);
+    ASSERT_FP_EQ(func(x, 0), zero);
 
     x = -x;
     result = func(x, -1);
diff --git a/test/src/math/SqrtTest.h b/test/src/math/SqrtTest.h
index 770cc94..fdfc4f9 100644
--- a/test/src/math/SqrtTest.h
+++ b/test/src/math/SqrtTest.h
@@ -29,14 +29,14 @@ public:
       FPBits denormal(zero);
       denormal.set_mantissa(mant);
       InType x = denormal.get_val();
-      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
 
     constexpr StorageType COUNT = 200'001;
     constexpr StorageType STEP = HIDDEN_BIT / COUNT;
     for (StorageType i = 0, v = 0; i <= COUNT; ++i, v += STEP) {
       InType x = FPBits(i).get_val();
-      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
   }
 
@@ -48,7 +48,7 @@ public:
       InType x = x_bits.get_val();
       if (x_bits.is_nan() || (x < 0))
         continue;
-      EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
+      ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, x, func(x), 0.5);
     }
   }
 };
diff --git a/test/src/math/SubTest.h b/test/src/math/SubTest.h
index 9b40353..b799d78 100644
--- a/test/src/math/SubTest.h
+++ b/test/src/math/SubTest.h
@@ -9,6 +9,7 @@
 #ifndef LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
 #define LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
 
+#include "src/__support/CPP/algorithm.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
 #include "test/UnitTest/Test.h"
@@ -39,13 +40,16 @@ public:
   using SubFunc = OutType (*)(InType, InType);
 
   void test_subnormal_range(SubFunc func) {
-    constexpr InStorageType COUNT = 100'001;
-    constexpr InStorageType STEP =
-        (IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) / COUNT;
-    for (InStorageType i = 0, v = 0, w = IN_MAX_SUBNORMAL_U; i <= COUNT;
-         ++i, v += STEP, w -= STEP) {
-      InType x = InFPBits(v).get_val();
-      InType y = InFPBits(w).get_val();
+    constexpr int COUNT = 100'001;
+    constexpr InStorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<InStorageType>((IN_MAX_SUBNORMAL_U - IN_MIN_SUBNORMAL_U) /
+                                   COUNT),
+        InStorageType(1));
+    for (InStorageType i = IN_MIN_SUBNORMAL_U; i <= IN_MAX_SUBNORMAL_U;
+         i += STEP) {
+      InType x = InFPBits(i).get_val();
+      InType y = InFPBits(static_cast<InStorageType>(IN_MAX_SUBNORMAL_U - i))
+                     .get_val();
       mpfr::BinaryInput<InType> input{x, y};
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sub, input, func(x, y),
                                      0.5);
@@ -53,12 +57,14 @@ public:
   }
 
   void test_normal_range(SubFunc func) {
-    constexpr InStorageType COUNT = 100'001;
-    constexpr InStorageType STEP = (IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT;
-    for (InStorageType i = 0, v = 0, w = IN_MAX_NORMAL_U; i <= COUNT;
-         ++i, v += STEP, w -= STEP) {
-      InType x = InFPBits(v).get_val();
-      InType y = InFPBits(w).get_val();
+    constexpr int COUNT = 100'001;
+    constexpr InStorageType STEP = LIBC_NAMESPACE::cpp::max(
+        static_cast<InStorageType>((IN_MAX_NORMAL_U - IN_MIN_NORMAL_U) / COUNT),
+        InStorageType(1));
+    for (InStorageType i = IN_MIN_NORMAL_U; i <= IN_MAX_NORMAL_U; i += STEP) {
+      InType x = InFPBits(i).get_val();
+      InType y =
+          InFPBits(static_cast<InStorageType>(IN_MAX_NORMAL_U - i)).get_val();
       mpfr::BinaryInput<InType> input{x, y};
       EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sub, input, func(x, y),
                                      0.5);
@@ -71,4 +77,11 @@ public:
   TEST_F(LlvmLibcSubTest, SubnormalRange) { test_subnormal_range(&func); }     \
   TEST_F(LlvmLibcSubTest, NormalRange) { test_normal_range(&func); }
 
+#define LIST_SUB_SAME_TYPE_TESTS(suffix, OutType, InType, func)                \
+  using LlvmLibcSubTest##suffix = SubTest<OutType, InType>;                    \
+  TEST_F(LlvmLibcSubTest##suffix, SubnormalRange) {                            \
+    test_subnormal_range(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcSubTest##suffix, NormalRange) { test_normal_range(&func); }
+
 #endif // LLVM_LIBC_TEST_SRC_MATH_SUBTEST_H
diff --git a/test/src/math/acosf16_test.cpp b/test/src/math/acosf16_test.cpp
new file mode 100644
index 0000000..f4890c8
--- /dev/null
+++ b/test/src/math/acosf16_test.cpp
@@ -0,0 +1,42 @@
+//===-- Exhaustive test for acosf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/acosf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcAcosf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcAcosf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Acos, x,
+                                   LIBC_NAMESPACE::acosf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcAcosf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Acos, x,
+                                   LIBC_NAMESPACE::acosf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/add_same_type_test.cpp b/test/src/math/add_same_type_test.cpp
new file mode 100644
index 0000000..13e1e3c
--- /dev/null
+++ b/test/src/math/add_same_type_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for fputil::generic::add --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/macros/properties/types.h"
+
+#define ADD_FUNC(T) (LIBC_NAMESPACE::fputil::generic::add<T, T>)
+
+LIST_ADD_SAME_TYPE_TESTS(Double, double, double, ADD_FUNC(double))
+LIST_ADD_SAME_TYPE_TESTS(Float, float, float, ADD_FUNC(float))
+LIST_ADD_SAME_TYPE_TESTS(LongDouble, long double, long double,
+                         ADD_FUNC(long double))
+#ifdef LIBC_TYPES_HAS_FLOAT16
+LIST_ADD_SAME_TYPE_TESTS(Float16, float16, float16, ADD_FUNC(float16))
+#endif
+#ifdef LIBC_TYPES_HAS_FLOAT128
+LIST_ADD_SAME_TYPE_TESTS(Float128, float128, float128, ADD_FUNC(float128))
+#endif
diff --git a/test/src/math/asinf16_test.cpp b/test/src/math/asinf16_test.cpp
new file mode 100644
index 0000000..9593cad
--- /dev/null
+++ b/test/src/math/asinf16_test.cpp
@@ -0,0 +1,42 @@
+//===-- Exhaustive test for asinf16 ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/asinf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcAsinf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcAsinf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Asin, x,
+                                   LIBC_NAMESPACE::asinf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcAsinf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Asin, x,
+                                   LIBC_NAMESPACE::asinf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/atan_test.cpp b/test/src/math/atan_test.cpp
new file mode 100644
index 0000000..7f52578
--- /dev/null
+++ b/test/src/math/atan_test.cpp
@@ -0,0 +1,84 @@
+//===-- Unittests for atan ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/FPUtil/FPBits.h"
+#include "src/math/atan.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcAtanTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+using LIBC_NAMESPACE::testing::tlog;
+
+TEST_F(LlvmLibcAtanTest, InDoubleRange) {
+  constexpr uint64_t COUNT = 123'451;
+  uint64_t START = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p-60).uintval();
+  uint64_t STOP = LIBC_NAMESPACE::fputil::FPBits<double>(0x1.0p60).uintval();
+  uint64_t STEP = (STOP - START) / COUNT;
+
+  auto test = [&](mpfr::RoundingMode rounding_mode) {
+    mpfr::ForceRoundingMode __r(rounding_mode);
+    if (!__r.success)
+      return;
+
+    uint64_t fails = 0;
+    uint64_t count = 0;
+    uint64_t cc = 0;
+    double mx, mr = 0.0;
+    double tol = 0.5;
+
+    for (uint64_t i = 0, v = START; i <= COUNT; ++i, v += STEP) {
+      double x = FPBits(v).get_val();
+      if (FPBits(v).is_nan() || FPBits(v).is_inf())
+        continue;
+      LIBC_NAMESPACE::libc_errno = 0;
+      double result = LIBC_NAMESPACE::atan(x);
+      ++cc;
+      if (FPBits(result).is_nan() || FPBits(result).is_inf())
+        continue;
+
+      ++count;
+
+      if (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Atan, x, result,
+                                             2.0, rounding_mode)) {
+        ++fails;
+        while (!TEST_MPFR_MATCH_ROUNDING_SILENTLY(mpfr::Operation::Atan, x,
+                                                  result, tol, rounding_mode)) {
+          mx = x;
+          mr = result;
+
+          if (tol > 1000.0)
+            break;
+
+          tol *= 2.0;
+        }
+      }
+    }
+    if (fails) {
+      tlog << " Atan failed: " << fails << "/" << count << "/" << cc
+           << " tests.\n";
+      tlog << "   Max ULPs is at most: " << static_cast<uint64_t>(tol) << ".\n";
+      EXPECT_MPFR_MATCH(mpfr::Operation::Atan, mx, mr, 0.5, rounding_mode);
+    }
+  };
+
+  tlog << " Test Rounding To Nearest...\n";
+  test(mpfr::RoundingMode::Nearest);
+
+  tlog << " Test Rounding Downward...\n";
+  test(mpfr::RoundingMode::Downward);
+
+  tlog << " Test Rounding Upward...\n";
+  test(mpfr::RoundingMode::Upward);
+
+  tlog << " Test Rounding Toward Zero...\n";
+  test(mpfr::RoundingMode::TowardZero);
+}
diff --git a/test/src/math/cosf16_test.cpp b/test/src/math/cosf16_test.cpp
new file mode 100644
index 0000000..b744e78
--- /dev/null
+++ b/test/src/math/cosf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for cosf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/cosf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcCosf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcCosf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cos, x,
+                                   LIBC_NAMESPACE::cosf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcCosf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Cos, x,
+                                   LIBC_NAMESPACE::cosf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/exhaustive/exhaustive_test.h b/test/src/math/exhaustive/exhaustive_test.h
index 94489d2..cdf459c 100644
--- a/test/src/math/exhaustive/exhaustive_test.h
+++ b/test/src/math/exhaustive/exhaustive_test.h
@@ -169,7 +169,8 @@ struct LlvmLibcExhaustiveMathTest
               range_end = stop;
             }
             current_value = range_end;
-            int pc = 100.0 * (range_end - start) / (stop - start);
+            int pc =
+                static_cast<int>(100.0 * (range_end - start) / (stop - start));
             if (current_percent != pc) {
               new_percent = pc;
               current_percent = pc;
@@ -225,7 +226,7 @@ struct LlvmLibcExhaustiveMathTest
     std::cout << "-- Testing for FE_TOWARDZERO in range [0x" << std::hex
               << start << ", 0x" << stop << ") --" << std::dec << std::endl;
     test_full_range(mpfr::RoundingMode::TowardZero, start, stop);
-  };
+  }
 
   void test_full_range_all_roundings(StorageType x_start, StorageType x_stop,
                                      StorageType y_start, StorageType y_stop) {
@@ -252,7 +253,7 @@ struct LlvmLibcExhaustiveMathTest
               << ", 0x" << y_stop << ") --" << std::dec << std::endl;
     test_full_range(mpfr::RoundingMode::TowardZero, x_start, x_stop, y_start,
                     y_stop);
-  };
+  }
 };
 
 template <typename FloatType, mpfr::Operation Op, UnaryOp<FloatType> Func>
diff --git a/test/src/math/exhaustive/fmod_generic_impl_test.cpp b/test/src/math/exhaustive/fmod_generic_impl_test.cpp
index b064b7e..fc3156d 100644
--- a/test/src/math/exhaustive/fmod_generic_impl_test.cpp
+++ b/test/src/math/exhaustive/fmod_generic_impl_test.cpp
@@ -48,13 +48,13 @@ public:
     int max2 = 3 + FPBits::MAX_BIASED_EXPONENT / 2;
     for (T by : TEST_BASES) {
       for (int iy = min2; iy < max2; iy++) {
-        T y = by * LIBC_NAMESPACE::fputil::ldexp(2.0, iy);
+        T y = by * LIBC_NAMESPACE::fputil::ldexp(T(2.0), iy);
         FPBits y_bits(y);
         if (y_bits.is_zero() || !y_bits.is_finite())
           continue;
         for (T bx : TEST_BASES) {
           for (int ix = min2; ix < max2; ix++) {
-            T x = bx * LIBC_NAMESPACE::fputil::ldexp(2.0, ix);
+            T x = bx * LIBC_NAMESPACE::fputil::ldexp(T(2.0), ix);
             if (!FPBits(x).is_finite())
               continue;
             T result = FMod::eval(x, y);
diff --git a/test/src/math/performance_testing/sqrtf128_perf.cpp b/test/src/math/performance_testing/sqrtf128_perf.cpp
new file mode 100644
index 0000000..bc04e69
--- /dev/null
+++ b/test/src/math/performance_testing/sqrtf128_perf.cpp
@@ -0,0 +1,20 @@
+//===-- Differential test for sqrtf128
+//----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SingleInputSingleOutputPerf.h"
+
+#include "src/__support/FPUtil/sqrt.h"
+#include "src/math/sqrtf128.h"
+
+float128 sqrtf128_placeholder(float128 x) {
+  return LIBC_NAMESPACE::fputil::sqrt<float128>(x);
+}
+
+SINGLE_INPUT_SINGLE_OUTPUT_PERF(float128, LIBC_NAMESPACE::sqrtf128,
+                                ::sqrtf128_placeholder, "sqrtf128_perf.log")
diff --git a/test/src/math/sinf16_test.cpp b/test/src/math/sinf16_test.cpp
new file mode 100644
index 0000000..b05501c
--- /dev/null
+++ b/test/src/math/sinf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for sinf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/sinf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcSinf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcSinf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sin, x,
+                                   LIBC_NAMESPACE::sinf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcSinf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sin, x,
+                                   LIBC_NAMESPACE::sinf16(x), 0.5);
+  }
+}
diff --git a/test/src/math/smoke/AddTest.h b/test/src/math/smoke/AddTest.h
index 66b188f..68a4bbe 100644
--- a/test/src/math/smoke/AddTest.h
+++ b/test/src/math/smoke/AddTest.h
@@ -11,7 +11,6 @@
 
 #include "hdr/errno_macros.h"
 #include "hdr/fenv_macros.h"
-#include "src/__support/FPUtil/BasicOperations.h"
 #include "src/__support/macros/properties/os.h"
 #include "test/UnitTest/FEnvSafeTest.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -59,6 +58,10 @@ public:
 #ifndef LIBC_TARGET_OS_IS_WINDOWS
     using namespace LIBC_NAMESPACE::fputil::testing;
 
+    if (LIBC_NAMESPACE::fputil::get_fp_type<OutType>() ==
+        LIBC_NAMESPACE::fputil::get_fp_type<InType>())
+      return;
+
     if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
       EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.max_normal),
                                   FE_OVERFLOW | FE_INEXACT);
@@ -136,6 +139,16 @@ public:
     func(InType(1.0), in.min_denormal);
     EXPECT_FP_EXCEPTION(FE_INEXACT);
   }
+
+  void test_mixed_normality(AddFunc func) {
+    if (LIBC_NAMESPACE::fputil::get_fp_type<OutType>() !=
+        LIBC_NAMESPACE::fputil::get_fp_type<InType>())
+      return;
+
+    EXPECT_FP_EQ(FPBits::create_value(Sign::POS, 2U, 0b1U).get_val(),
+                 func(InFPBits::create_value(Sign::POS, 2U, 0U).get_val(),
+                      InFPBits::create_value(Sign::POS, 0U, 0b10U).get_val()));
+  }
 };
 
 #define LIST_ADD_TESTS(OutType, InType, func)                                  \
@@ -145,6 +158,23 @@ public:
     test_invalid_operations(&func);                                            \
   }                                                                            \
   TEST_F(LlvmLibcAddTest, RangeErrors) { test_range_errors(&func); }           \
-  TEST_F(LlvmLibcAddTest, InexactResults) { test_inexact_results(&func); }
+  TEST_F(LlvmLibcAddTest, InexactResults) { test_inexact_results(&func); }     \
+  TEST_F(LlvmLibcAddTest, MixedNormality) { test_mixed_normality(&func); }
+
+#define LIST_ADD_SAME_TYPE_TESTS(suffix, OutType, InType, func)                \
+  using LlvmLibcAddTest##suffix = AddTest<OutType, InType>;                    \
+  TEST_F(LlvmLibcAddTest##suffix, SpecialNumbers) {                            \
+    test_special_numbers(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcAddTest##suffix, InvalidOperations) {                         \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcAddTest##suffix, RangeErrors) { test_range_errors(&func); }   \
+  TEST_F(LlvmLibcAddTest##suffix, InexactResults) {                            \
+    test_inexact_results(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcAddTest##suffix, MixedNormality) {                            \
+    test_mixed_normality(&func);                                               \
+  }
 
 #endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_ADDTEST_H
diff --git a/test/src/math/smoke/CanonicalizeTest.h b/test/src/math/smoke/CanonicalizeTest.h
index ef75f56..e500bc3 100644
--- a/test/src/math/smoke/CanonicalizeTest.h
+++ b/test/src/math/smoke/CanonicalizeTest.h
@@ -19,6 +19,7 @@
 #include "hdr/math_macros.h"
 
 #define TEST_SPECIAL(x, y, expected, expected_exception)                       \
+  LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT);                         \
   EXPECT_EQ(expected, f(&x, &y));                                              \
   EXPECT_FP_EXCEPTION(expected_exception);                                     \
   LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT)
diff --git a/test/src/math/smoke/FModTest.h b/test/src/math/smoke/FModTest.h
index ad9688f..8fbcc2a 100644
--- a/test/src/math/smoke/FModTest.h
+++ b/test/src/math/smoke/FModTest.h
@@ -18,6 +18,7 @@
 #include "hdr/fenv_macros.h"
 
 #define TEST_SPECIAL(x, y, expected, dom_err, expected_exception)              \
+  LIBC_NAMESPACE::fputil::clear_except(FE_ALL_EXCEPT);                         \
   EXPECT_FP_EQ(expected, f(x, y));                                             \
   EXPECT_MATH_ERRNO((dom_err) ? EDOM : 0);                                     \
   EXPECT_FP_EXCEPTION(expected_exception);                                     \
diff --git a/test/src/math/smoke/NextAfterTest.h b/test/src/math/smoke/NextAfterTest.h
index e62832e..be27c9f 100644
--- a/test/src/math/smoke/NextAfterTest.h
+++ b/test/src/math/smoke/NextAfterTest.h
@@ -115,7 +115,7 @@ public:
     expected_bits = min_subnormal + 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ_WITH_UNDERFLOW(result, expected);
-    ASSERT_FP_EQ_WITH_UNDERFLOW(func(x, 0), 0);
+    ASSERT_FP_EQ_WITH_UNDERFLOW(func(x, 0), zero);
 
     x = -x;
     result = func(x, -1);
diff --git a/test/src/math/smoke/NextTowardTest.h b/test/src/math/smoke/NextTowardTest.h
index a4cd5d0..d2f352c 100644
--- a/test/src/math/smoke/NextTowardTest.h
+++ b/test/src/math/smoke/NextTowardTest.h
@@ -122,7 +122,7 @@ public:
     expected_bits = min_subnormal + 1;
     expected = LIBC_NAMESPACE::cpp::bit_cast<T>(expected_bits);
     ASSERT_FP_EQ_WITH_UNDERFLOW(result, expected);
-    ASSERT_FP_EQ_WITH_UNDERFLOW(func(x, 0), 0);
+    ASSERT_FP_EQ_WITH_UNDERFLOW(func(x, 0), zero);
 
     x = -x;
     result = func(x, -1);
diff --git a/test/src/math/smoke/SqrtTest.h b/test/src/math/smoke/SqrtTest.h
index b5eaee2..29666ad 100644
--- a/test/src/math/smoke/SqrtTest.h
+++ b/test/src/math/smoke/SqrtTest.h
@@ -39,7 +39,8 @@ public:
 
 #define LIST_SQRT_TESTS(T, func)                                               \
   using LlvmLibcSqrtTest = SqrtTest<T, T>;                                     \
-  TEST_F(LlvmLibcSqrtTest, SpecialNumbers) { test_special_numbers(&func); }
+  TEST_F(LlvmLibcSqrtTest, SpecialNumbers) { test_special_numbers(&func); }    \
+  static_assert(true, "Require semicolon.")
 
 #define LIST_NARROWING_SQRT_TESTS(OutType, InType, func)                       \
   using LlvmLibcSqrtTest = SqrtTest<OutType, InType>;                          \
diff --git a/test/src/math/smoke/SubTest.h b/test/src/math/smoke/SubTest.h
index ca95200..c344db2 100644
--- a/test/src/math/smoke/SubTest.h
+++ b/test/src/math/smoke/SubTest.h
@@ -58,6 +58,10 @@ public:
 #ifndef LIBC_TARGET_OS_IS_WINDOWS
     using namespace LIBC_NAMESPACE::fputil::testing;
 
+    if (LIBC_NAMESPACE::fputil::get_fp_type<OutType>() ==
+        LIBC_NAMESPACE::fputil::get_fp_type<InType>())
+      return;
+
     if (ForceRoundingMode r(RoundingMode::Nearest); r.success) {
       EXPECT_FP_EQ_WITH_EXCEPTION(inf, func(in.max_normal, in.neg_max_normal),
                                   FE_OVERFLOW | FE_INEXACT);
@@ -147,4 +151,17 @@ public:
   TEST_F(LlvmLibcSubTest, RangeErrors) { test_range_errors(&func); }           \
   TEST_F(LlvmLibcSubTest, InexactResults) { test_inexact_results(&func); }
 
+#define LIST_SUB_SAME_TYPE_TESTS(suffix, OutType, InType, func)                \
+  using LlvmLibcSubTest##suffix = SubTest<OutType, InType>;                    \
+  TEST_F(LlvmLibcSubTest##suffix, SpecialNumbers) {                            \
+    test_special_numbers(&func);                                               \
+  }                                                                            \
+  TEST_F(LlvmLibcSubTest##suffix, InvalidOperations) {                         \
+    test_invalid_operations(&func);                                            \
+  }                                                                            \
+  TEST_F(LlvmLibcSubTest##suffix, RangeErrors) { test_range_errors(&func); }   \
+  TEST_F(LlvmLibcSubTest##suffix, InexactResults) {                            \
+    test_inexact_results(&func);                                               \
+  }
+
 #endif // LLVM_LIBC_TEST_SRC_MATH_SMOKE_SUBTEST_H
diff --git a/test/src/math/smoke/acosf16_test.cpp b/test/src/math/smoke/acosf16_test.cpp
new file mode 100644
index 0000000..c4274b8
--- /dev/null
+++ b/test/src/math/smoke/acosf16_test.cpp
@@ -0,0 +1,39 @@
+//===-- Unittests for acosf16 ---------------------------------------------===//
+//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/acosf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcAcosf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcAcosf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::acosf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::acosf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::acosf16(1.0f));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::acosf16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::acosf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::acosf16(2.0f));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::acosf16(-2.0f));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/add_same_type_test.cpp b/test/src/math/smoke/add_same_type_test.cpp
new file mode 100644
index 0000000..13e1e3c
--- /dev/null
+++ b/test/src/math/smoke/add_same_type_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for fputil::generic::add --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AddTest.h"
+
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/macros/properties/types.h"
+
+#define ADD_FUNC(T) (LIBC_NAMESPACE::fputil::generic::add<T, T>)
+
+LIST_ADD_SAME_TYPE_TESTS(Double, double, double, ADD_FUNC(double))
+LIST_ADD_SAME_TYPE_TESTS(Float, float, float, ADD_FUNC(float))
+LIST_ADD_SAME_TYPE_TESTS(LongDouble, long double, long double,
+                         ADD_FUNC(long double))
+#ifdef LIBC_TYPES_HAS_FLOAT16
+LIST_ADD_SAME_TYPE_TESTS(Float16, float16, float16, ADD_FUNC(float16))
+#endif
+#ifdef LIBC_TYPES_HAS_FLOAT128
+LIST_ADD_SAME_TYPE_TESTS(Float128, float128, float128, ADD_FUNC(float128))
+#endif
diff --git a/test/src/math/smoke/asinf16_test.cpp b/test/src/math/smoke/asinf16_test.cpp
new file mode 100644
index 0000000..9f675b0
--- /dev/null
+++ b/test/src/math/smoke/asinf16_test.cpp
@@ -0,0 +1,42 @@
+//===-- Unittests for asinf16 ---------------------------------------------===//
+//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/asinf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcAsinf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcAsinf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::asinf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ_WITH_EXCEPTION(aNaN, LIBC_NAMESPACE::asinf16(sNaN), FE_INVALID);
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::asinf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::asinf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::asinf16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::asinf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::asinf16(2.0f));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::asinf16(-2.0f));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/atan_test.cpp b/test/src/math/smoke/atan_test.cpp
new file mode 100644
index 0000000..b83f315
--- /dev/null
+++ b/test/src/math/smoke/atan_test.cpp
@@ -0,0 +1,28 @@
+//===-- Unittests for atan ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/atan.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcAtanTest = LIBC_NAMESPACE::testing::FPTest<double>;
+
+TEST_F(LlvmLibcAtanTest, SpecialNumbers) {
+  EXPECT_FP_EQ_ALL_ROUNDING(aNaN, LIBC_NAMESPACE::atan(aNaN));
+  // atan(sNaN) = aNaN.
+  EXPECT_EQ(FPBits(aNaN).uintval(),
+            FPBits(LIBC_NAMESPACE::atan(sNaN)).uintval());
+  EXPECT_FP_EQ_ALL_ROUNDING(zero, LIBC_NAMESPACE::atan(zero));
+  EXPECT_FP_EQ_ALL_ROUNDING(neg_zero, LIBC_NAMESPACE::atan(neg_zero));
+  // atan(+-Inf) = +- pi/2.
+  EXPECT_FP_EQ(0x1.921fb54442d18p0, LIBC_NAMESPACE::atan(inf));
+  EXPECT_FP_EQ(-0x1.921fb54442d18p0, LIBC_NAMESPACE::atan(neg_inf));
+  // atan(+-1) = +- pi/4.
+  EXPECT_FP_EQ(0x1.921fb54442d18p-1, LIBC_NAMESPACE::atan(1.0));
+  EXPECT_FP_EQ(-0x1.921fb54442d18p-1, LIBC_NAMESPACE::atan(-1.0));
+}
diff --git a/test/src/math/smoke/cosf16_test.cpp b/test/src/math/smoke/cosf16_test.cpp
new file mode 100644
index 0000000..9a51d10
--- /dev/null
+++ b/test/src/math/smoke/cosf16_test.cpp
@@ -0,0 +1,33 @@
+//===-- Unittests for cosf16 ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/cosf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcCosf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcCosf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cosf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cosf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cosf16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cosf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/cospif16_test.cpp b/test/src/math/smoke/cospif16_test.cpp
index f6d7483..135267a 100644
--- a/test/src/math/smoke/cospif16_test.cpp
+++ b/test/src/math/smoke/cospif16_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/FPUtil/cast.h"
 #include "src/errno/libc_errno.h"
 #include "src/math/cospif16.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -19,10 +20,10 @@ TEST_F(LlvmLibcCospif16Test, SpecialNumbers) {
   EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif16(aNaN));
   EXPECT_MATH_ERRNO(0);
 
-  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(zero));
+  EXPECT_FP_EQ(FPBits::one().get_val(), LIBC_NAMESPACE::cospif16(zero));
   EXPECT_MATH_ERRNO(0);
 
-  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(neg_zero));
+  EXPECT_FP_EQ(FPBits::one().get_val(), LIBC_NAMESPACE::cospif16(neg_zero));
   EXPECT_MATH_ERRNO(0);
 
   EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::cospif16(inf));
@@ -33,12 +34,24 @@ TEST_F(LlvmLibcCospif16Test, SpecialNumbers) {
 }
 
 TEST_F(LlvmLibcCospif16Test, Integers) {
-  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(-0x420));
-  EXPECT_FP_EQ(1.0f, LIBC_NAMESPACE::cospif16(-0x1.4p+14));
-  EXPECT_FP_EQ(-1.0f, LIBC_NAMESPACE::cospif16(0x421));
-  EXPECT_FP_EQ(-1.0f, LIBC_NAMESPACE::cospif16(0x333));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(-0x1.28p4));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(-0x1.ffcp9));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(0x1.01p7));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(0x1.f6cp9));
+  EXPECT_FP_EQ(FPBits::one().get_val(),
+               LIBC_NAMESPACE::cospif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(-0x420.0p0)));
+  EXPECT_FP_EQ(FPBits::one().get_val(),
+               LIBC_NAMESPACE::cospif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(-0x1.4p+14)));
+  EXPECT_FP_EQ(FPBits::one(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::cospif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(0x421.0p0)));
+  EXPECT_FP_EQ(FPBits::one(Sign::NEG).get_val(),
+               LIBC_NAMESPACE::cospif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(0x333.0p0)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(-0x1.28p4)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(-0x1.ffcp9)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(0x1.01p7)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::cospif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(0x1.f6cp9)));
 }
diff --git a/test/src/math/smoke/exp2m1f16_test.cpp b/test/src/math/smoke/exp2m1f16_test.cpp
index 8be8697..f423196 100644
--- a/test/src/math/smoke/exp2m1f16_test.cpp
+++ b/test/src/math/smoke/exp2m1f16_test.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "hdr/fenv_macros.h"
+#include "src/__support/FPUtil/cast.h"
 #include "src/errno/libc_errno.h"
 #include "src/math/exp2m1f16.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -44,7 +45,7 @@ TEST_F(LlvmLibcExp2m1f16Test, Overflow) {
                               FE_OVERFLOW | FE_INEXACT);
   EXPECT_MATH_ERRNO(ERANGE);
 
-  float16 x = 16.0;
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(16.0);
 
   EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
       inf, LIBC_NAMESPACE::exp2m1f16(x), FE_OVERFLOW | FE_INEXACT);
@@ -69,9 +70,11 @@ TEST_F(LlvmLibcExp2m1f16Test, ResultNearNegOne) {
   EXPECT_FP_EQ_WITH_EXCEPTION(-1.0, LIBC_NAMESPACE::exp2m1f16(neg_max_normal),
                               FE_INEXACT);
 
-  EXPECT_FP_EQ_ALL_ROUNDING(-0x1.ffcp-1, LIBC_NAMESPACE::exp2m1f16(-11.0));
+  EXPECT_FP_EQ_ALL_ROUNDING(
+      -0x1.ffcp-1,
+      LIBC_NAMESPACE::exp2m1f16(LIBC_NAMESPACE::fputil::cast<float16>(-11.0)));
 
-  float16 x = -12.0;
+  float16 x = LIBC_NAMESPACE::fputil::cast<float16>(-12.0);
 
   EXPECT_FP_EQ_WITH_EXCEPTION_ROUNDING_NEAREST(
       -1.0, LIBC_NAMESPACE::exp2m1f16(x), FE_INEXACT);
diff --git a/test/src/math/smoke/generic_sqrt_test.cpp b/test/src/math/smoke/generic_sqrt_test.cpp
index d0ab31f..4451e5e 100644
--- a/test/src/math/smoke/generic_sqrt_test.cpp
+++ b/test/src/math/smoke/generic_sqrt_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-LIST_SQRT_TESTS(double, LIBC_NAMESPACE::fputil::sqrt<double>)
+LIST_SQRT_TESTS(double, LIBC_NAMESPACE::fputil::sqrt<double>);
diff --git a/test/src/math/smoke/generic_sqrtf128_test.cpp b/test/src/math/smoke/generic_sqrtf128_test.cpp
index edba114..790ff0a 100644
--- a/test/src/math/smoke/generic_sqrtf128_test.cpp
+++ b/test/src/math/smoke/generic_sqrtf128_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-LIST_SQRT_TESTS(float128, LIBC_NAMESPACE::fputil::sqrt<float128>)
+LIST_SQRT_TESTS(float128, LIBC_NAMESPACE::fputil::sqrt<float128>);
diff --git a/test/src/math/smoke/generic_sqrtf_test.cpp b/test/src/math/smoke/generic_sqrtf_test.cpp
index f22ac88..e04d4c4 100644
--- a/test/src/math/smoke/generic_sqrtf_test.cpp
+++ b/test/src/math/smoke/generic_sqrtf_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-LIST_SQRT_TESTS(float, LIBC_NAMESPACE::fputil::sqrt<float>)
+LIST_SQRT_TESTS(float, LIBC_NAMESPACE::fputil::sqrt<float>);
diff --git a/test/src/math/smoke/generic_sqrtl_test.cpp b/test/src/math/smoke/generic_sqrtl_test.cpp
index ddc6a23..ccb5054 100644
--- a/test/src/math/smoke/generic_sqrtl_test.cpp
+++ b/test/src/math/smoke/generic_sqrtl_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/__support/FPUtil/generic/sqrt.h"
 
-LIST_SQRT_TESTS(long double, LIBC_NAMESPACE::fputil::sqrt<long double>)
+LIST_SQRT_TESTS(long double, LIBC_NAMESPACE::fputil::sqrt<long double>);
diff --git a/test/src/math/smoke/nan_test.cpp b/test/src/math/smoke/nan_test.cpp
index 46b9e9a..e45e2e6 100644
--- a/test/src/math/smoke/nan_test.cpp
+++ b/test/src/math/smoke/nan_test.cpp
@@ -23,7 +23,7 @@ public:
     auto actual_fp = LIBC_NAMESPACE::fputil::FPBits<double>(result);
     auto expected_fp = LIBC_NAMESPACE::fputil::FPBits<double>(bits);
     EXPECT_EQ(actual_fp.uintval(), expected_fp.uintval());
-  };
+  }
 };
 
 TEST_F(LlvmLibcNanTest, NCharSeq) {
@@ -44,8 +44,8 @@ TEST_F(LlvmLibcNanTest, RandomString) {
   run_test("123 ", 0x7ff8000000000000);
 }
 
-#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
 TEST_F(LlvmLibcNanTest, InvalidInput) {
-  EXPECT_DEATH([] { LIBC_NAMESPACE::nan(nullptr); }, WITH_SIGNAL(SIGSEGV));
+  EXPECT_DEATH([] { LIBC_NAMESPACE::nan(nullptr); });
 }
 #endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf128_test.cpp b/test/src/math/smoke/nanf128_test.cpp
index 25dd2ef..aa59b79 100644
--- a/test/src/math/smoke/nanf128_test.cpp
+++ b/test/src/math/smoke/nanf128_test.cpp
@@ -28,7 +28,7 @@ public:
     auto actual_fp = FPBits128(result);
     auto expected_fp = FPBits128(bits);
     EXPECT_EQ(actual_fp.uintval(), expected_fp.uintval());
-  };
+  }
 };
 
 TEST_F(LlvmLibcNanf128Test, NCharSeq) {
@@ -55,8 +55,8 @@ TEST_F(LlvmLibcNanf128Test, RandomString) {
            QUIET_NAN);
 }
 
-#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
 TEST_F(LlvmLibcNanf128Test, InvalidInput) {
-  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf128(nullptr); }, WITH_SIGNAL(SIGSEGV));
+  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf128(nullptr); });
 }
 #endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf16_test.cpp b/test/src/math/smoke/nanf16_test.cpp
index ec640a3..04a8c7b 100644
--- a/test/src/math/smoke/nanf16_test.cpp
+++ b/test/src/math/smoke/nanf16_test.cpp
@@ -23,7 +23,7 @@ public:
     auto actual_fp = LIBC_NAMESPACE::fputil::FPBits<float16>(result);
     auto expected_fp = LIBC_NAMESPACE::fputil::FPBits<float16>(bits);
     EXPECT_EQ(actual_fp.uintval(), expected_fp.uintval());
-  };
+  }
 };
 
 TEST_F(LlvmLibcNanf16Test, NCharSeq) {
@@ -43,8 +43,8 @@ TEST_F(LlvmLibcNanf16Test, RandomString) {
   run_test("123 ", 0x7e00);
 }
 
-#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
 TEST_F(LlvmLibcNanf16Test, InvalidInput) {
-  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf16(nullptr); }, WITH_SIGNAL(SIGSEGV));
+  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf16(nullptr); });
 }
 #endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanf_test.cpp b/test/src/math/smoke/nanf_test.cpp
index dd3124e..40e90c4 100644
--- a/test/src/math/smoke/nanf_test.cpp
+++ b/test/src/math/smoke/nanf_test.cpp
@@ -23,7 +23,7 @@ public:
     auto actual_fp = LIBC_NAMESPACE::fputil::FPBits<float>(result);
     auto expected_fp = LIBC_NAMESPACE::fputil::FPBits<float>(bits);
     EXPECT_EQ(actual_fp.uintval(), expected_fp.uintval());
-  };
+  }
 };
 
 TEST_F(LlvmLibcNanfTest, NCharSeq) {
@@ -43,8 +43,8 @@ TEST_F(LlvmLibcNanfTest, RandomString) {
   run_test("123 ", 0x7fc00000);
 }
 
-#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
 TEST_F(LlvmLibcNanfTest, InvalidInput) {
-  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf(nullptr); }, WITH_SIGNAL(SIGSEGV));
+  EXPECT_DEATH([] { LIBC_NAMESPACE::nanf(nullptr); });
 }
 #endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/nanl_test.cpp b/test/src/math/smoke/nanl_test.cpp
index ef3f9c1..dea969f 100644
--- a/test/src/math/smoke/nanl_test.cpp
+++ b/test/src/math/smoke/nanl_test.cpp
@@ -33,7 +33,7 @@ public:
     auto actual_fp = LIBC_NAMESPACE::fputil::FPBits<long double>(result);
     auto expected_fp = LIBC_NAMESPACE::fputil::FPBits<long double>(bits);
     EXPECT_EQ(actual_fp.uintval(), expected_fp.uintval());
-  };
+  }
 };
 
 TEST_F(LlvmLibcNanlTest, NCharSeq) {
@@ -71,8 +71,8 @@ TEST_F(LlvmLibcNanlTest, RandomString) {
   run_test("123 ", expected);
 }
 
-#if !defined(LIBC_HAS_ADDRESS_SANITIZER) && defined(LIBC_TARGET_OS_IS_LINUX)
+#if defined(LIBC_ADD_NULL_CHECKS) && !defined(LIBC_HAS_SANITIZER)
 TEST_F(LlvmLibcNanlTest, InvalidInput) {
-  EXPECT_DEATH([] { LIBC_NAMESPACE::nanl(nullptr); }, WITH_SIGNAL(SIGSEGV));
+  EXPECT_DEATH([] { LIBC_NAMESPACE::nanl(nullptr); });
 }
 #endif // LIBC_HAS_ADDRESS_SANITIZER
diff --git a/test/src/math/smoke/sinf16_test.cpp b/test/src/math/smoke/sinf16_test.cpp
new file mode 100644
index 0000000..2966c3c
--- /dev/null
+++ b/test/src/math/smoke/sinf16_test.cpp
@@ -0,0 +1,33 @@
+//===-- Unittests for sinf16 ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/sinf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcSinf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcSinf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinf16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::sinf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/smoke/sinpif16_test.cpp b/test/src/math/smoke/sinpif16_test.cpp
index 0bcd38a..a79fd52 100644
--- a/test/src/math/smoke/sinpif16_test.cpp
+++ b/test/src/math/smoke/sinpif16_test.cpp
@@ -6,6 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "src/__support/FPUtil/cast.h"
 #include "src/errno/libc_errno.h"
 #include "src/math/sinpif16.h"
 #include "test/UnitTest/FPMatcher.h"
@@ -33,10 +34,18 @@ TEST_F(LlvmLibcSinpif16Test, SpecialNumbers) {
 }
 
 TEST_F(LlvmLibcSinpif16Test, Integers) {
-  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x420));
-  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x1p+10));
-  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(-0x1.4p+14));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x420));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x1.cp+15));
-  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(0x1.cp+7));
+  EXPECT_FP_EQ(neg_zero,
+               LIBC_NAMESPACE::sinpif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(-0x420.0p0)));
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::sinpif16(
+                             LIBC_NAMESPACE::fputil::cast<float16>(-0x1p+10)));
+  EXPECT_FP_EQ(neg_zero,
+               LIBC_NAMESPACE::sinpif16(
+                   LIBC_NAMESPACE::fputil::cast<float16>(-0x1.4p+14)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(0x420.0p0)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(0x1.cp+15)));
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::sinpif16(
+                         LIBC_NAMESPACE::fputil::cast<float16>(0x1.cp+7)));
 }
diff --git a/test/src/math/smoke/sqrt_test.cpp b/test/src/math/smoke/sqrt_test.cpp
index 1551b31..b41e06d 100644
--- a/test/src/math/smoke/sqrt_test.cpp
+++ b/test/src/math/smoke/sqrt_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/math/sqrt.h"
 
-LIST_SQRT_TESTS(double, LIBC_NAMESPACE::sqrt)
+LIST_SQRT_TESTS(double, LIBC_NAMESPACE::sqrt);
diff --git a/test/src/math/smoke/sqrtf128_test.cpp b/test/src/math/smoke/sqrtf128_test.cpp
index 23397b0..2fca748 100644
--- a/test/src/math/smoke/sqrtf128_test.cpp
+++ b/test/src/math/smoke/sqrtf128_test.cpp
@@ -8,6 +8,130 @@
 
 #include "SqrtTest.h"
 
+#include "src/__support/uint128.h"
 #include "src/math/sqrtf128.h"
 
-LIST_SQRT_TESTS(float128, LIBC_NAMESPACE::sqrtf128)
+LIST_SQRT_TESTS(float128, LIBC_NAMESPACE::sqrtf128);
+
+TEST_F(LlvmLibcSqrtTest, HardToRound) {
+  using LIBC_NAMESPACE::fputil::testing::RoundingMode;
+  using FPBits = LIBC_NAMESPACE::fputil::FPBits<float128>;
+
+  // Since there is no exact half cases for square root I encode the
+  // round direction in the sign of the result. E.g. if the number is
+  // negative it means that the exact root is below the rounded value
+  // (the absolute value). Thus I can test not only hard to round
+  // cases for the round to nearest mode but also the directional
+  // modes.
+  float128 HARD_TO_ROUND[][2] = {
+      {0x0.000000dee2f5b6a26c8f07f05442p-16382q,
+       -0x1.ddbd8763a617cff753e2a31083p-8204q},
+      {0x0.000000c86d174c5ad8ae54a548e7p-16382q,
+       0x1.c507bb538940719890851ec1ca88p-8204q},
+      {0x0.000020ab15cfe0b8e488e128f535p-16382q,
+       -0x1.6dccb402560213bc0d62d62e910bp-8201q},
+      {0x0.0000219e97732a9970f2511989bap-16382q,
+       0x1.73163d28be706f4b5052791e28a5p-8201q},
+      {0x0.000026e477546ae99ef57066f9fdp-16382q,
+       -0x1.8f20dd0d0c570a23ea59bc2bf009p-8201q},
+      {0x0.00002d0f88d27a496b3e533f5067p-16382q,
+       0x1.ad9d4abe9f047225a7352bcc52c1p-8201q},
+      {0x1.0000000000000000000000000001p+0q, 0x1p+0q},
+      {0x1.0000000000000000000000000002p+0q,
+       -0x1.0000000000000000000000000001p+0q},
+      {0x1.0000000000000000000000000003p+0q,
+       0x1.0000000000000000000000000001p+0q},
+      {0x1.0000000000000000000000000005p+0q,
+       0x1.0000000000000000000000000002p+0q},
+      {0x1.0000000000000000000000000006p+0q,
+       -0x1.0000000000000000000000000003p+0q},
+      {0x1.1d4c381cbf3a0aa15b9aee344892p+0q,
+       0x1.0e408c3fadc5e64b449c63673f4bp+0q},
+      {0x1.2af17a4ae6f93d11310c49c11b59p+0q,
+       -0x1.14a3bdf0ea5231f12d421a5dbe33p+0q},
+      {0x1.96f893bf29fb91e0fbe19a46d0c8p+0q,
+       0x1.42c6bf6202e66f2295807dee44d9p+0q},
+      {0x1.97fb3839925b66804c429289cce8p+0q,
+       -0x1.432d4049ac1c85a241f333d326e9p+0q},
+      {0x1.be1d900eaeb1533f0f19cc15c7e6p+0q,
+       0x1.51f1715154da44f3bf11f3d96c2dp+0q},
+      {0x1.c4f5074269525063a26051a0ad27p+0q,
+       0x1.54864e9b1daa4d9135ff00663366p+0q},
+      {0x1.035cb5f298a801dc4be9b1f8cd97p+1q,
+       -0x1.6c688775bffcb3f507ba11d0abb9p+0q},
+      {0x1.274be02380427e709beab4dedeb4p+1q,
+       -0x1.84d5763281f2318422392e506b1cp+0q},
+      {0x1.64e797cfdbaa3f7e2f33279dbc6p+1q,
+       0x1.ab79b164e255b26eca00ff99cc99p+0q},
+      {0x1.693a741358c9dac44a570a7e9f6cp+1q,
+       0x1.ae0e8eaeab25bb0c40ee0c2693d3p+0q},
+      {0x1.8275db3fc4d822596047adcb71b9p+1q,
+       -0x1.bcd2bfb653e37a5dbe0ccc2cd917p+0q},
+      {0x1.83280bb98c4a7b88bd6f535899d9p+1q,
+       0x1.bd39409dfd1990dd6a7f8211bb27p+0q},
+      {0x1.d78d8352b48608b510bfd5c75315p+1q,
+       -0x1.eb5c420f15adce0ed2bde5a241cep+0q},
+      {0x1.e3e4774f564b526edff84ce46668p+1q,
+       0x1.f1bf73c0523a19b4bb639c98c0b5p+0q},
+      {0x1.fffffffffffffffffffffffffffap+1q,
+       -0x1.fffffffffffffffffffffffffffdp+0q},
+      {0x1.fffffffffffffffffffffffffffbp+1q,
+       0x1.fffffffffffffffffffffffffffdp+0q},
+      {0x1.fffffffffffffffffffffffffffdp+1q,
+       0x1.fffffffffffffffffffffffffffep+0q},
+      {0x1.fffffffffffffffffffffffffffep+1q,
+       -0x1.ffffffffffffffffffffffffffffp+0q},
+      {0x1.ffffffffffffffffffffffffffffp+1q,
+       0x1.ffffffffffffffffffffffffffffp+0q},
+  };
+
+  auto rnd = [](float128 x, RoundingMode rm) -> float128 {
+    bool is_neg = x < 0;
+    float128 y = is_neg ? -x : x;
+    FPBits ybits(y);
+
+    if (is_neg &&
+        (rm == RoundingMode::Downward || rm == RoundingMode::TowardZero))
+      return FPBits(ybits.uintval() - 1).get_val();
+    if (!is_neg && (rm == RoundingMode::Upward))
+      return FPBits(ybits.uintval() + 1).get_val();
+
+    return y;
+  };
+
+  for (auto &t : HARD_TO_ROUND) {
+    EXPECT_FP_EQ_ALL_ROUNDING(
+        rnd(t[1], RoundingMode::Nearest), rnd(t[1], RoundingMode::Upward),
+        rnd(t[1], RoundingMode::Downward), rnd(t[1], RoundingMode::TowardZero),
+        LIBC_NAMESPACE::sqrtf128(t[0]));
+  }
+
+  // Exact results for subnormal arguments
+  float128 EXACT_SUBNORMAL[][2] = {
+      {0x0.0000000000000000000000000001p-16382q, 0x1p-8247q},
+      {0x0.0000000000000000000000000004p-16382q, 0x1p-8246q},
+      {0x0.0000000000001000000000000000p-16382q, 0x1p-8217q},
+      {0x0.0000000000010000000000000000p-16382q, 0x1p-8215q},
+      {0x0.0000000000100000000000000000p-16382q, 0x1p-8213q},
+  };
+
+  for (auto t : EXACT_SUBNORMAL)
+    EXPECT_FP_EQ_ALL_ROUNDING(t[1], LIBC_NAMESPACE::sqrtf128(t[0]));
+
+  // Check exact cases starting from small numbers
+  for (unsigned k = 1; k < 100 * 100; ++k) {
+    unsigned k2 = k * k;
+    float128 x = static_cast<float128>(k2);
+    float128 y = static_cast<float128>(k);
+    EXPECT_FP_EQ_ALL_ROUNDING(y, LIBC_NAMESPACE::sqrtf128(x));
+  };
+
+  // Then from the largest number.
+  uint64_t k0 = 101904826760412362ULL;
+  for (uint64_t k = k0; k > k0 - 10000; --k) {
+    float128 k_f128 = static_cast<float128>(k);
+    float128 x = k_f128 * k_f128;
+    float128 y = static_cast<float128>(k);
+    EXPECT_FP_EQ_ALL_ROUNDING(y, LIBC_NAMESPACE::sqrtf128(x));
+  }
+}
diff --git a/test/src/math/smoke/sqrtf16_test.cpp b/test/src/math/smoke/sqrtf16_test.cpp
index d620496..950abd2 100644
--- a/test/src/math/smoke/sqrtf16_test.cpp
+++ b/test/src/math/smoke/sqrtf16_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/math/sqrtf16.h"
 
-LIST_SQRT_TESTS(float16, LIBC_NAMESPACE::sqrtf16)
+LIST_SQRT_TESTS(float16, LIBC_NAMESPACE::sqrtf16);
diff --git a/test/src/math/smoke/sqrtf_test.cpp b/test/src/math/smoke/sqrtf_test.cpp
index 3f2e973..888b6cb 100644
--- a/test/src/math/smoke/sqrtf_test.cpp
+++ b/test/src/math/smoke/sqrtf_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/math/sqrtf.h"
 
-LIST_SQRT_TESTS(float, LIBC_NAMESPACE::sqrtf)
+LIST_SQRT_TESTS(float, LIBC_NAMESPACE::sqrtf);
diff --git a/test/src/math/smoke/sqrtl_test.cpp b/test/src/math/smoke/sqrtl_test.cpp
index f80bcfb..4f4a64f 100644
--- a/test/src/math/smoke/sqrtl_test.cpp
+++ b/test/src/math/smoke/sqrtl_test.cpp
@@ -10,4 +10,4 @@
 
 #include "src/math/sqrtl.h"
 
-LIST_SQRT_TESTS(long double, LIBC_NAMESPACE::sqrtl)
+LIST_SQRT_TESTS(long double, LIBC_NAMESPACE::sqrtl);
diff --git a/test/src/math/smoke/sub_same_type_test.cpp b/test/src/math/smoke/sub_same_type_test.cpp
new file mode 100644
index 0000000..016f2b5
--- /dev/null
+++ b/test/src/math/smoke/sub_same_type_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for fputil::generic::sub --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/macros/properties/types.h"
+
+#define SUB_FUNC(T) (LIBC_NAMESPACE::fputil::generic::sub<T, T>)
+
+LIST_SUB_SAME_TYPE_TESTS(Double, double, double, SUB_FUNC(double))
+LIST_SUB_SAME_TYPE_TESTS(Float, float, float, SUB_FUNC(float))
+LIST_SUB_SAME_TYPE_TESTS(LongDouble, long double, long double,
+                         SUB_FUNC(long double))
+#ifdef LIBC_TYPES_HAS_FLOAT16
+LIST_SUB_SAME_TYPE_TESTS(Float16, float16, float16, SUB_FUNC(float16))
+#endif
+#ifdef LIBC_TYPES_HAS_FLOAT128
+LIST_SUB_SAME_TYPE_TESTS(Float128, float128, float128, SUB_FUNC(float128))
+#endif
diff --git a/test/src/math/smoke/tanf16_test.cpp b/test/src/math/smoke/tanf16_test.cpp
new file mode 100644
index 0000000..39d1182
--- /dev/null
+++ b/test/src/math/smoke/tanf16_test.cpp
@@ -0,0 +1,34 @@
+//===-- Unittests for tanf16 ----------------------------------------------===//
+//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/errno/libc_errno.h"
+#include "src/math/tanf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcTanf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+TEST_F(LlvmLibcTanf16Test, SpecialNumbers) {
+  LIBC_NAMESPACE::libc_errno = 0;
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanf16(aNaN));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(zero, LIBC_NAMESPACE::tanf16(zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(neg_zero, LIBC_NAMESPACE::tanf16(neg_zero));
+  EXPECT_MATH_ERRNO(0);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanf16(inf));
+  EXPECT_MATH_ERRNO(EDOM);
+
+  EXPECT_FP_EQ(aNaN, LIBC_NAMESPACE::tanf16(neg_inf));
+  EXPECT_MATH_ERRNO(EDOM);
+}
diff --git a/test/src/math/sqrtf128_test.cpp b/test/src/math/sqrtf128_test.cpp
new file mode 100644
index 0000000..25229f8
--- /dev/null
+++ b/test/src/math/sqrtf128_test.cpp
@@ -0,0 +1,43 @@
+//===-- Unittests for sqrtf128 --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SqrtTest.h"
+
+#include "src/math/sqrtf128.h"
+
+#include "src/__support/integer_literals.h"
+
+LIST_SQRT_TESTS(float128, LIBC_NAMESPACE::sqrtf128)
+
+TEST_F(LlvmLibcSqrtTest, SpecialInputs) {
+  constexpr float128 INPUTS[] = {
+      0x0.000000dee2f5b6a26c8f07f05442p-16382q,
+      0x0.000000c86d174c5ad8ae54a548e7p-16382q,
+      0x0.000020ab15cfe0b8e488e128f535p-16382q,
+      0x0.0000219e97732a9970f2511989bap-16382q,
+      0x0.000026e477546ae99ef57066f9fdp-16382q,
+      0x0.00002d0f88d27a496b3e533f5067p-16382q,
+      0x1.0000000000000000000000000001p+0q,
+      0x1.0000000000000000000000000003p+0q,
+      0x1.0000000000000000000000000005p+0q,
+      0x1.2af17a4ae6f93d11310c49c11b59p+0q,
+      0x1.c4f5074269525063a26051a0ad27p+0q,
+      0x1.035cb5f298a801dc4be9b1f8cd97p+1q,
+      0x1.274be02380427e709beab4dedeb4p+1q,
+      0x1.64e797cfdbaa3f7e2f33279dbc6p+1q,
+      0x1.d78d8352b48608b510bfd5c75315p+1q,
+      0x1.fffffffffffffffffffffffffffbp+1q,
+      0x1.fffffffffffffffffffffffffffdp+1q,
+      0x1.ffffffffffffffffffffffffffffp+1q,
+  };
+
+  for (auto input : INPUTS) {
+    ASSERT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Sqrt, input,
+                                   LIBC_NAMESPACE::sqrtf128(input), 0.5);
+  }
+}
diff --git a/test/src/math/sub_same_type_test.cpp b/test/src/math/sub_same_type_test.cpp
new file mode 100644
index 0000000..016f2b5
--- /dev/null
+++ b/test/src/math/sub_same_type_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for fputil::generic::sub --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "SubTest.h"
+
+#include "src/__support/FPUtil/generic/add_sub.h"
+#include "src/__support/macros/properties/types.h"
+
+#define SUB_FUNC(T) (LIBC_NAMESPACE::fputil::generic::sub<T, T>)
+
+LIST_SUB_SAME_TYPE_TESTS(Double, double, double, SUB_FUNC(double))
+LIST_SUB_SAME_TYPE_TESTS(Float, float, float, SUB_FUNC(float))
+LIST_SUB_SAME_TYPE_TESTS(LongDouble, long double, long double,
+                         SUB_FUNC(long double))
+#ifdef LIBC_TYPES_HAS_FLOAT16
+LIST_SUB_SAME_TYPE_TESTS(Float16, float16, float16, SUB_FUNC(float16))
+#endif
+#ifdef LIBC_TYPES_HAS_FLOAT128
+LIST_SUB_SAME_TYPE_TESTS(Float128, float128, float128, SUB_FUNC(float128))
+#endif
diff --git a/test/src/math/tanf16_test.cpp b/test/src/math/tanf16_test.cpp
new file mode 100644
index 0000000..f2e8741
--- /dev/null
+++ b/test/src/math/tanf16_test.cpp
@@ -0,0 +1,40 @@
+//===-- Exhaustive test for tanf16 ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/math/tanf16.h"
+#include "test/UnitTest/FPMatcher.h"
+#include "test/UnitTest/Test.h"
+#include "utils/MPFRWrapper/MPFRUtils.h"
+
+using LlvmLibcTanf16Test = LIBC_NAMESPACE::testing::FPTest<float16>;
+
+namespace mpfr = LIBC_NAMESPACE::testing::mpfr;
+
+// Range: [0, Inf]
+static constexpr uint16_t POS_START = 0x0000U;
+static constexpr uint16_t POS_STOP = 0x7c00U;
+
+// Range: [-Inf, 0]
+static constexpr uint16_t NEG_START = 0x8000U;
+static constexpr uint16_t NEG_STOP = 0xfc00U;
+
+TEST_F(LlvmLibcTanf16Test, PositiveRange) {
+  for (uint16_t v = POS_START; v <= POS_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tan, x,
+                                   LIBC_NAMESPACE::tanf16(x), 0.5);
+  }
+}
+
+TEST_F(LlvmLibcTanf16Test, NegativeRange) {
+  for (uint16_t v = NEG_START; v <= NEG_STOP; ++v) {
+    float16 x = FPBits(v).get_val();
+    EXPECT_MPFR_MATCH_ALL_ROUNDING(mpfr::Operation::Tan, x,
+                                   LIBC_NAMESPACE::tanf16(x), 0.5);
+  }
+}
diff --git a/test/src/poll/poll_test.cpp b/test/src/poll/poll_test.cpp
new file mode 100644
index 0000000..30f5e41
--- /dev/null
+++ b/test/src/poll/poll_test.cpp
@@ -0,0 +1,25 @@
+//===-- Unittests for poll ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/limits_macros.h" // UINT_MAX
+#include "src/errno/libc_errno.h"
+#include "src/poll/poll.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcPollTest, SmokeTest) {
+  LIBC_NAMESPACE::libc_errno = 0;
+  int ret = LIBC_NAMESPACE::poll(nullptr, 0, 0);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_EQ(0, ret);
+}
+TEST(LlvmLibcPollTest, SmokeFailureTest) {
+  LIBC_NAMESPACE::libc_errno = 0;
+  int ret = LIBC_NAMESPACE::poll(nullptr, UINT_MAX, 0);
+  ASSERT_ERRNO_EQ(EINVAL);
+  ASSERT_EQ(-1, ret);
+}
diff --git a/test/src/search/lsearch_test.cpp b/test/src/search/lsearch_test.cpp
new file mode 100644
index 0000000..9e58b87
--- /dev/null
+++ b/test/src/search/lsearch_test.cpp
@@ -0,0 +1,66 @@
+//===-- Unittests for lsearch ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/search/lsearch.h"
+#include "test/UnitTest/Test.h"
+
+int compar(const void *a, const void *b) {
+  return *reinterpret_cast<const int *>(a) != *reinterpret_cast<const int *>(b);
+}
+
+TEST(LlvmLibcLsearchTest, SearchHead) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 1;
+  void *ret = LIBC_NAMESPACE::lsearch(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[0]);
+}
+
+TEST(LlvmLibcLsearchTest, SearchMiddle) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 2;
+  void *ret = LIBC_NAMESPACE::lsearch(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[1]);
+}
+
+TEST(LlvmLibcLsearchTest, SearchTail) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  int key = 3;
+  void *ret = LIBC_NAMESPACE::lsearch(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[2]);
+}
+
+TEST(LlvmLibcLsearchTest, SearchNonExistent) {
+  int list[4] = {1, 2, 3, 0};
+  size_t len = 3;
+  int key = 4;
+  void *ret = LIBC_NAMESPACE::lsearch(&key, list, &len, sizeof(int), compar);
+  ASSERT_TRUE(ret == &list[3]);
+  ASSERT_EQ(key, list[3]);
+  ASSERT_EQ(len, size_t{4});
+}
+
+TEST(LlvmLibcLsearchTest, SearchExceptional) {
+  int list[3] = {1, 2, 3};
+  size_t len = 3;
+  size_t max_len = ~0;
+  int key = 3;
+
+  ASSERT_EQ(LIBC_NAMESPACE::lsearch(nullptr, list, &len, sizeof(int), compar),
+            nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::lsearch(&key, nullptr, &len, sizeof(int), compar),
+            nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::lsearch(&key, list, nullptr, sizeof(int), compar),
+            nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::lsearch(&key, list, &max_len, sizeof(int), compar),
+            nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::lsearch(&key, list, &len, sizeof(int), nullptr),
+            nullptr);
+}
diff --git a/test/src/setjmp/setjmp_test.cpp b/test/src/setjmp/setjmp_test.cpp
index 9e5f74a..27113cd 100644
--- a/test/src/setjmp/setjmp_test.cpp
+++ b/test/src/setjmp/setjmp_test.cpp
@@ -27,7 +27,7 @@ TEST(LlvmLibcSetJmpTest, SetAndJumpBack) {
   // The first time setjmp is called, it should return 0.
   // Subsequent calls will return the value passed to jump_back below.
   if (LIBC_NAMESPACE::setjmp(buf) <= MAX_LOOP) {
-    ++n;
+    n = n + 1;
     jump_back(buf, n);
   }
   ASSERT_EQ(longjmp_called, n);
diff --git a/test/src/signal/signal_test.cpp b/test/src/signal/signal_test.cpp
index 4b57311..bac9c3b 100644
--- a/test/src/signal/signal_test.cpp
+++ b/test/src/signal/signal_test.cpp
@@ -13,14 +13,12 @@
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-#include "hdr/types/sighandler_t.h"
-
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 
 TEST(LlvmLibcSignal, Invalid) {
   LIBC_NAMESPACE::libc_errno = 0;
-  sighandler_t valid = +[](int) {};
+  auto *valid = +[](int) {};
   EXPECT_THAT((void *)LIBC_NAMESPACE::signal(0, valid),
               Fails(EINVAL, (void *)SIG_ERR));
   EXPECT_THAT((void *)LIBC_NAMESPACE::signal(65, valid),
diff --git a/test/src/stdbit/stdc_bit_ceil_uc_test.cpp b/test/src/stdbit/stdc_bit_ceil_uc_test.cpp
index 1ef87b0..6915859 100644
--- a/test/src/stdbit/stdc_bit_ceil_uc_test.cpp
+++ b/test/src/stdbit/stdc_bit_ceil_uc_test.cpp
@@ -17,18 +17,21 @@ TEST(LlvmLibcStdcBitceilUcTest, Zero) {
 
 TEST(LlvmLibcStdcBitceilUcTest, Ones) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_uc(1U << i),
-              static_cast<unsigned char>(1U << i));
+    EXPECT_EQ(
+        LIBC_NAMESPACE::stdc_bit_ceil_uc(static_cast<unsigned char>(1U << i)),
+        static_cast<unsigned char>(1U << i));
 }
 
 TEST(LlvmLibcStdcBitceilUcTest, OneLessThanPowsTwo) {
   for (unsigned i = 2U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_uc((1U << i) - 1),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_uc(
+                  static_cast<unsigned char>((1U << i) - 1)),
               static_cast<unsigned char>(1U << i));
 }
 
 TEST(LlvmLibcStdcBitceilUcTest, OneMoreThanPowsTwo) {
   for (unsigned i = 1U; i != UCHAR_WIDTH - 1; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_uc((1U << i) + 1),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_uc(
+                  static_cast<unsigned char>((1U << i) + 1)),
               static_cast<unsigned char>(1U << (i + 1)));
 }
diff --git a/test/src/stdbit/stdc_bit_ceil_us_test.cpp b/test/src/stdbit/stdc_bit_ceil_us_test.cpp
index 56873c5..9a8b46f 100644
--- a/test/src/stdbit/stdc_bit_ceil_us_test.cpp
+++ b/test/src/stdbit/stdc_bit_ceil_us_test.cpp
@@ -17,18 +17,21 @@ TEST(LlvmLibcStdcBitceilUsTest, Zero) {
 
 TEST(LlvmLibcStdcBitceilUsTest, Ones) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_us(1U << i),
-              static_cast<unsigned short>(1U << i));
+    EXPECT_EQ(
+        LIBC_NAMESPACE::stdc_bit_ceil_us(static_cast<unsigned short>(1U << i)),
+        static_cast<unsigned short>(1U << i));
 }
 
 TEST(LlvmLibcStdcBitceilUsTest, OneLessThanPowsTwo) {
   for (unsigned i = 2U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_us((1U << i) - 1),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_us(
+                  static_cast<unsigned short>((1U << i) - 1)),
               static_cast<unsigned short>(1U << i));
 }
 
 TEST(LlvmLibcStdcBitceilUsTest, OneMoreThanPowsTwo) {
   for (unsigned i = 1U; i != USHRT_WIDTH - 1; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_us((1U << i) + 1),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_bit_ceil_us(
+                  static_cast<unsigned short>((1U << i) + 1)),
               static_cast<unsigned short>(1U << (i + 1)));
 }
diff --git a/test/src/stdbit/stdc_first_leading_one_uc_test.cpp b/test/src/stdbit/stdc_first_leading_one_uc_test.cpp
index b8c8db5..2ab8397 100644
--- a/test/src/stdbit/stdc_first_leading_one_uc_test.cpp
+++ b/test/src/stdbit/stdc_first_leading_one_uc_test.cpp
@@ -16,6 +16,7 @@ TEST(LlvmLibcStdcFirstLeadingOneUcTest, Zero) {
 
 TEST(LlvmLibcStdcFirstLeadingOneUcTest, OneHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_one_uc(1U << i),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_one_uc(
+                  static_cast<unsigned char>(1U << i)),
               UCHAR_WIDTH - i);
 }
diff --git a/test/src/stdbit/stdc_first_leading_one_us_test.cpp b/test/src/stdbit/stdc_first_leading_one_us_test.cpp
index e948833..de81275 100644
--- a/test/src/stdbit/stdc_first_leading_one_us_test.cpp
+++ b/test/src/stdbit/stdc_first_leading_one_us_test.cpp
@@ -16,6 +16,7 @@ TEST(LlvmLibcStdcFirstLeadingOneUsTest, Zero) {
 
 TEST(LlvmLibcStdcFirstLeadingOneUsTest, OneHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_one_us(1U << i),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_one_us(
+                  static_cast<unsigned short>(1U << i)),
               USHRT_WIDTH - i);
 }
diff --git a/test/src/stdbit/stdc_first_leading_zero_uc_test.cpp b/test/src/stdbit/stdc_first_leading_zero_uc_test.cpp
index ac7e8c7..a19d0ab 100644
--- a/test/src/stdbit/stdc_first_leading_zero_uc_test.cpp
+++ b/test/src/stdbit/stdc_first_leading_zero_uc_test.cpp
@@ -16,6 +16,7 @@ TEST(LlvmLibcStdcFirstLeadingZeroUcTest, ALL) {
 
 TEST(LlvmLibcStdcFirstLeadingZeroUcTest, ZeroHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_zero_uc(~(1U << i)),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_zero_uc(
+                  static_cast<unsigned char>(~(1U << i))),
               UCHAR_WIDTH - i);
 }
diff --git a/test/src/stdbit/stdc_first_leading_zero_us_test.cpp b/test/src/stdbit/stdc_first_leading_zero_us_test.cpp
index 37f8612..2971267 100644
--- a/test/src/stdbit/stdc_first_leading_zero_us_test.cpp
+++ b/test/src/stdbit/stdc_first_leading_zero_us_test.cpp
@@ -16,6 +16,7 @@ TEST(LlvmLibcStdcFirstLeadingZeroUsTest, ALL) {
 
 TEST(LlvmLibcStdcFirstLeadingZeroUsTest, ZeroHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_zero_us(~(1U << i)),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_leading_zero_us(
+                  static_cast<unsigned short>(~(1U << i))),
               USHRT_WIDTH - i);
 }
diff --git a/test/src/stdbit/stdc_first_trailing_one_uc_test.cpp b/test/src/stdbit/stdc_first_trailing_one_uc_test.cpp
index ed2b492..f507e9a 100644
--- a/test/src/stdbit/stdc_first_trailing_one_uc_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_one_uc_test.cpp
@@ -11,10 +11,12 @@
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStdcFirstTrailingOneUcTest, ALL) {
-  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_uc(UCHAR_MAX), 0U);
+  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_uc(UCHAR_MAX), 1U);
 }
 
 TEST(LlvmLibcStdcFirstTrailingOneUcTest, OneHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_uc(1U << i), i + 1);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_uc(
+                  static_cast<unsigned char>(1U << i)),
+              i + 1);
 }
diff --git a/test/src/stdbit/stdc_first_trailing_one_ui_test.cpp b/test/src/stdbit/stdc_first_trailing_one_ui_test.cpp
index 137c8a4..3109d68 100644
--- a/test/src/stdbit/stdc_first_trailing_one_ui_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_one_ui_test.cpp
@@ -11,7 +11,7 @@
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStdcFirstTrailingOneUiTest, ALL) {
-  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ui(UINT_MAX), 0U);
+  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ui(UINT_MAX), 1U);
 }
 
 TEST(LlvmLibcStdcFirstTrailingOneUiTest, OneHot) {
diff --git a/test/src/stdbit/stdc_first_trailing_one_ul_test.cpp b/test/src/stdbit/stdc_first_trailing_one_ul_test.cpp
index 3fc1f3f..8d1f39a 100644
--- a/test/src/stdbit/stdc_first_trailing_one_ul_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_one_ul_test.cpp
@@ -11,7 +11,7 @@
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStdcFirstTrailingOneUlTest, ALL) {
-  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ul(ULONG_MAX), 0U);
+  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ul(ULONG_MAX), 1U);
 }
 
 TEST(LlvmLibcStdcFirstTrailingOneUlTest, OneHot) {
diff --git a/test/src/stdbit/stdc_first_trailing_one_ull_test.cpp b/test/src/stdbit/stdc_first_trailing_one_ull_test.cpp
index 5719e09..12ef053 100644
--- a/test/src/stdbit/stdc_first_trailing_one_ull_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_one_ull_test.cpp
@@ -11,7 +11,7 @@
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStdcFirstTrailingOneUllTest, ALL) {
-  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ull(ULLONG_MAX), 0U);
+  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_ull(ULLONG_MAX), 1U);
 }
 
 TEST(LlvmLibcStdcFirstTrailingOneUllTest, OneHot) {
diff --git a/test/src/stdbit/stdc_first_trailing_one_us_test.cpp b/test/src/stdbit/stdc_first_trailing_one_us_test.cpp
index 6002155..6a506e6 100644
--- a/test/src/stdbit/stdc_first_trailing_one_us_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_one_us_test.cpp
@@ -11,10 +11,12 @@
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStdcFirstTrailingOneUsTest, ALL) {
-  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_us(USHRT_MAX), 0U);
+  EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_us(USHRT_MAX), 1U);
 }
 
 TEST(LlvmLibcStdcFirstTrailingOneUsTest, OneHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_us(1U << i), i + 1);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_one_us(
+                  static_cast<unsigned short>(1U << i)),
+              i + 1);
 }
diff --git a/test/src/stdbit/stdc_first_trailing_zero_uc_test.cpp b/test/src/stdbit/stdc_first_trailing_zero_uc_test.cpp
index 2b17aa6..9535ad9 100644
--- a/test/src/stdbit/stdc_first_trailing_zero_uc_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_zero_uc_test.cpp
@@ -16,5 +16,7 @@ TEST(LlvmLibcStdcFirstTrailingZeroUcTest, ALL) {
 
 TEST(LlvmLibcStdcFirstTrailingZeroUcTest, ZeroHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_zero_uc(~(1U << i)), i + 1);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_zero_uc(
+                  static_cast<unsigned char>(~(1U << i))),
+              i + 1);
 }
diff --git a/test/src/stdbit/stdc_first_trailing_zero_us_test.cpp b/test/src/stdbit/stdc_first_trailing_zero_us_test.cpp
index e370379..e0dc34f 100644
--- a/test/src/stdbit/stdc_first_trailing_zero_us_test.cpp
+++ b/test/src/stdbit/stdc_first_trailing_zero_us_test.cpp
@@ -16,5 +16,7 @@ TEST(LlvmLibcStdcFirstTrailingZeroUsTest, ALL) {
 
 TEST(LlvmLibcStdcFirstTrailingZeroUsTest, ZeroHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_zero_us(~(1U << i)), i + 1);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_first_trailing_zero_us(
+                  static_cast<unsigned short>(~(1U << i))),
+              i + 1);
 }
diff --git a/test/src/stdbit/stdc_has_single_bit_uc_test.cpp b/test/src/stdbit/stdc_has_single_bit_uc_test.cpp
index 1bc189c..9dd2bdc 100644
--- a/test/src/stdbit/stdc_has_single_bit_uc_test.cpp
+++ b/test/src/stdbit/stdc_has_single_bit_uc_test.cpp
@@ -16,5 +16,7 @@ TEST(LlvmLibcStdcHasSingleBitUcTest, Zero) {
 
 TEST(LlvmLibcStdcHasSingleBitUcTest, OneHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_has_single_bit_uc(1U << i), true);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_has_single_bit_uc(
+                  static_cast<unsigned char>(1U << i)),
+              true);
 }
diff --git a/test/src/stdbit/stdc_has_single_bit_us_test.cpp b/test/src/stdbit/stdc_has_single_bit_us_test.cpp
index a038f6f..3ff0b83 100644
--- a/test/src/stdbit/stdc_has_single_bit_us_test.cpp
+++ b/test/src/stdbit/stdc_has_single_bit_us_test.cpp
@@ -16,5 +16,7 @@ TEST(LlvmLibcStdcHasSingleBitUsTest, Zero) {
 
 TEST(LlvmLibcStdcHasSingleBitUsTest, OneHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_has_single_bit_us(1U << i), true);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_has_single_bit_us(
+                  static_cast<unsigned short>(1U << i)),
+              true);
 }
diff --git a/test/src/stdbit/stdc_leading_ones_uc_test.cpp b/test/src/stdbit/stdc_leading_ones_uc_test.cpp
index 5d32d92..4ba240f 100644
--- a/test/src/stdbit/stdc_leading_ones_uc_test.cpp
+++ b/test/src/stdbit/stdc_leading_ones_uc_test.cpp
@@ -17,6 +17,7 @@ TEST(LlvmLibcStdcLeadingOnesUcTest, All) {
 
 TEST(LlvmLibcStdcLeadingOnesUcTest, ZeroHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_ones_uc(~(1U << i)),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_ones_uc(
+                  static_cast<unsigned char>(~(1U << i))),
               UCHAR_WIDTH - i - 1U);
 }
diff --git a/test/src/stdbit/stdc_leading_ones_us_test.cpp b/test/src/stdbit/stdc_leading_ones_us_test.cpp
index 91a1253..0f93eed 100644
--- a/test/src/stdbit/stdc_leading_ones_us_test.cpp
+++ b/test/src/stdbit/stdc_leading_ones_us_test.cpp
@@ -17,6 +17,7 @@ TEST(LlvmLibcStdcLeadingOnesUsTest, All) {
 
 TEST(LlvmLibcStdcLeadingOnesUsTest, ZeroHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_ones_us(~(1U << i)),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_ones_us(
+                  static_cast<unsigned short>(~(1U << i))),
               USHRT_WIDTH - i - 1U);
 }
diff --git a/test/src/stdbit/stdc_leading_zeros_uc_test.cpp b/test/src/stdbit/stdc_leading_zeros_uc_test.cpp
index 3d55507..42f78c2 100644
--- a/test/src/stdbit/stdc_leading_zeros_uc_test.cpp
+++ b/test/src/stdbit/stdc_leading_zeros_uc_test.cpp
@@ -17,6 +17,7 @@ TEST(LlvmLibcStdcLeadingZerosUcTest, Zero) {
 
 TEST(LlvmLibcStdcLeadingZerosUcTest, OneHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_uc(1U << i),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_uc(
+                  static_cast<unsigned char>(1U << i)),
               UCHAR_WIDTH - i - 1U);
 }
diff --git a/test/src/stdbit/stdc_leading_zeros_us_test.cpp b/test/src/stdbit/stdc_leading_zeros_us_test.cpp
index afb418a..967ceb1 100644
--- a/test/src/stdbit/stdc_leading_zeros_us_test.cpp
+++ b/test/src/stdbit/stdc_leading_zeros_us_test.cpp
@@ -17,6 +17,7 @@ TEST(LlvmLibcStdcLeadingZerosUsTest, Zero) {
 
 TEST(LlvmLibcStdcLeadingZerosUsTest, OneHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_us(1U << i),
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_leading_zeros_us(
+                  static_cast<unsigned short>(1U << i)),
               USHRT_WIDTH - i - 1U);
 }
diff --git a/test/src/stdbit/stdc_trailing_ones_uc_test.cpp b/test/src/stdbit/stdc_trailing_ones_uc_test.cpp
index 79d4e5b..0036408 100644
--- a/test/src/stdbit/stdc_trailing_ones_uc_test.cpp
+++ b/test/src/stdbit/stdc_trailing_ones_uc_test.cpp
@@ -17,5 +17,7 @@ TEST(LlvmLibcStdcTrailingOnesUcTest, ALL) {
 
 TEST(LlvmLibcStdcTrailingOnesUcTest, ZeroHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_ones_uc(~(1U << i)), i);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_ones_uc(
+                  static_cast<unsigned char>(~(1U << i))),
+              i);
 }
diff --git a/test/src/stdbit/stdc_trailing_ones_us_test.cpp b/test/src/stdbit/stdc_trailing_ones_us_test.cpp
index 7ab1574..5ebacc8 100644
--- a/test/src/stdbit/stdc_trailing_ones_us_test.cpp
+++ b/test/src/stdbit/stdc_trailing_ones_us_test.cpp
@@ -17,5 +17,7 @@ TEST(LlvmLibcStdcTrailingOnesUsTest, ALL) {
 
 TEST(LlvmLibcStdcTrailingOnesUsTest, ZeroHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_ones_us(~(1U << i)), i);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_ones_us(
+                  static_cast<unsigned short>(~(1U << i))),
+              i);
 }
diff --git a/test/src/stdbit/stdc_trailing_zeros_uc_test.cpp b/test/src/stdbit/stdc_trailing_zeros_uc_test.cpp
index c02b518..129ab38 100644
--- a/test/src/stdbit/stdc_trailing_zeros_uc_test.cpp
+++ b/test/src/stdbit/stdc_trailing_zeros_uc_test.cpp
@@ -17,5 +17,7 @@ TEST(LlvmLibcStdcTrailingZerosUcTest, Zero) {
 
 TEST(LlvmLibcStdcTrailingZerosUcTest, OneHot) {
   for (unsigned i = 0U; i != UCHAR_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_zeros_uc(1U << i), i);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_zeros_uc(
+                  static_cast<unsigned char>(1U << i)),
+              i);
 }
diff --git a/test/src/stdbit/stdc_trailing_zeros_us_test.cpp b/test/src/stdbit/stdc_trailing_zeros_us_test.cpp
index a9f8327..e1171f2 100644
--- a/test/src/stdbit/stdc_trailing_zeros_us_test.cpp
+++ b/test/src/stdbit/stdc_trailing_zeros_us_test.cpp
@@ -17,5 +17,7 @@ TEST(LlvmLibcStdcTrailingZerosUsTest, Zero) {
 
 TEST(LlvmLibcStdcTrailingZerosUsTest, OneHot) {
   for (unsigned i = 0U; i != USHRT_WIDTH; ++i)
-    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_zeros_us(1U << i), i);
+    EXPECT_EQ(LIBC_NAMESPACE::stdc_trailing_zeros_us(
+                  static_cast<unsigned short>(1U << i)),
+              i);
 }
diff --git a/test/src/stdfix/BitsFxTest.h b/test/src/stdfix/BitsFxTest.h
new file mode 100644
index 0000000..eca6ab1
--- /dev/null
+++ b/test/src/stdfix/BitsFxTest.h
@@ -0,0 +1,81 @@
+//===-- Utility class to test bitsfx functions ------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "test/UnitTest/Test.h"
+
+#include "src/__support/fixed_point/fx_rep.h"
+
+template <typename T, typename XType>
+class BitsFxTest : public LIBC_NAMESPACE::testing::Test {
+
+  using FXRep = LIBC_NAMESPACE::fixed_point::FXRep<T>;
+  static constexpr T zero = FXRep::ZERO();
+  static constexpr T max = FXRep::MAX();
+  static constexpr T min = FXRep::MIN();
+  static constexpr T one_half = FXRep::ONE_HALF();
+  static constexpr T one_fourth = FXRep::ONE_FOURTH();
+  static constexpr T eps = FXRep::EPS();
+
+  static constexpr T zero_point_six_eight_seven_five_t = 0.6875;
+
+  static constexpr T negative_zero_point_six_eight_seven_five_t = -0.6875;
+
+  // an arbitrarily chosen special number
+  static constexpr T special_num_t = 10.71875;
+
+  static constexpr T negative_special_num_t = -10.71875;
+
+public:
+  typedef XType (*BitsFxFunc)(T);
+
+  void testSpecialNumbers(BitsFxFunc func) {
+    EXPECT_EQ(static_cast<XType>(0), func(zero));
+    EXPECT_EQ(static_cast<XType>(1ULL << (FXRep::FRACTION_LEN - 1)),
+              func(one_half));
+    EXPECT_EQ(static_cast<XType>(1ULL << (FXRep::FRACTION_LEN - 2)),
+              func(one_fourth));
+    EXPECT_EQ(static_cast<XType>(1), func(eps));
+
+    // (0.6875)_10 = (0.1011)_2
+    EXPECT_EQ(static_cast<XType>(11ULL << (FXRep::FRACTION_LEN - 4)),
+              func(zero_point_six_eight_seven_five_t));
+
+    if constexpr (FXRep::SIGN_LEN > 0)
+      EXPECT_EQ(static_cast<XType>(-(11ULL << (FXRep::FRACTION_LEN - 4))),
+                func(negative_zero_point_six_eight_seven_five_t));
+
+    if constexpr (FXRep::INTEGRAL_LEN > 0) {
+      constexpr size_t kMinFbits = 7;
+
+      if (max >= 11 && FXRep::FRACTION_LEN >= kMinFbits) {
+        // (10.71875)_10 = (1010.1011100)_2
+        constexpr long long kExpected = 1372;
+        EXPECT_EQ(
+            static_cast<XType>(kExpected << (FXRep::FRACTION_LEN - kMinFbits)),
+            func(special_num_t));
+      }
+
+      if constexpr (FXRep::SIGN_LEN > 0) {
+        if (min <= -11 && FXRep::FRACTION_LEN >= kMinFbits) {
+          // (-10.71875)_10 = (-1010.1011100)_2
+          constexpr long long kExpected = -1372;
+          EXPECT_EQ(static_cast<XType>(kExpected
+                                       << (FXRep::FRACTION_LEN - kMinFbits)),
+                    func(negative_special_num_t));
+        }
+      }
+    }
+  }
+};
+
+#define LIST_BITSFX_TESTS(Name, T, XType, func)                                \
+  using LlvmLibcBits##Name##Test = BitsFxTest<T, XType>;                       \
+  TEST_F(LlvmLibcBits##Name##Test, SpecialNumbers) {                           \
+    testSpecialNumbers(&func);                                                 \
+  }                                                                            \
+  static_assert(true, "Require semicolon.")
diff --git a/test/src/stdfix/CountlsTest.h b/test/src/stdfix/CountlsTest.h
new file mode 100644
index 0000000..a8201ac
--- /dev/null
+++ b/test/src/stdfix/CountlsTest.h
@@ -0,0 +1,58 @@
+//===-- Utility class to test countls -------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "test/UnitTest/Test.h"
+
+#include "src/__support/fixed_point/fx_rep.h"
+
+template <typename T> class CountlsTest : public LIBC_NAMESPACE::testing::Test {
+
+  using FXRep = LIBC_NAMESPACE::fixed_point::FXRep<T>;
+  static constexpr T zero = FXRep::ZERO();
+  static constexpr T max = FXRep::MAX();
+  static constexpr T min = FXRep::MIN();
+  static constexpr T one_half = FXRep::ONE_HALF();
+  static constexpr T one_fourth = FXRep::ONE_FOURTH();
+  static constexpr T eps = FXRep::EPS();
+
+public:
+  typedef int (*CountlsFunc)(T);
+
+  void testSpecialNumbers(CountlsFunc func) {
+    constexpr bool is_signed = (FXRep::SIGN_LEN > 0);
+
+    EXPECT_EQ(FXRep::INTEGRAL_LEN, func(one_half));
+    EXPECT_EQ(FXRep::INTEGRAL_LEN + 1, func(one_fourth));
+    EXPECT_EQ(FXRep::VALUE_LEN, func(zero));
+    EXPECT_EQ(FXRep::VALUE_LEN - 1, func(eps));
+    EXPECT_EQ(0, func(max));
+    // If signed, left shifting the minimum value will overflow, so countls = 0.
+    // If unsigned, the minimum value is zero, so countls is the number of value
+    // bits according to ISO/IEC TR 18037.
+    EXPECT_EQ(is_signed ? 0 : FXRep::VALUE_LEN, func(min));
+
+    if (10 <= static_cast<int>(max))
+      EXPECT_EQ(FXRep::INTEGRAL_LEN - 4, func(10));
+
+    if (static_cast<int>(min) <= -10)
+      EXPECT_EQ(FXRep::INTEGRAL_LEN - 4, func(-10));
+
+    if constexpr (is_signed) {
+      EXPECT_EQ(FXRep::VALUE_LEN, func(-zero));
+      EXPECT_EQ(FXRep::VALUE_LEN, func(-eps));
+      EXPECT_EQ(FXRep::INTEGRAL_LEN + 1, func(-one_half));
+      if (FXRep::FRACTION_LEN >= 2)
+        EXPECT_EQ(FXRep::INTEGRAL_LEN + 2, func(-one_fourth));
+    }
+  }
+};
+
+#define LIST_COUNTLS_TESTS(T, func)                                            \
+  using LlvmLibcCountlsTest = CountlsTest<T>;                                  \
+  TEST_F(LlvmLibcCountlsTest, SpecialNumbers) { testSpecialNumbers(&func); }   \
+  static_assert(true, "Require semicolon.")
diff --git a/test/src/stdfix/bitshk_test.cpp b/test/src/stdfix/bitshk_test.cpp
new file mode 100644
index 0000000..ca83162
--- /dev/null
+++ b/test/src/stdfix/bitshk_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitshk ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_hk_t
+#include "src/stdfix/bitshk.h"
+
+LIST_BITSFX_TESTS(hk, short accum, int_hk_t, LIBC_NAMESPACE::bitshk);
diff --git a/test/src/stdfix/bitshr_test.cpp b/test/src/stdfix/bitshr_test.cpp
new file mode 100644
index 0000000..220d7f6
--- /dev/null
+++ b/test/src/stdfix/bitshr_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitshr ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_hr_t
+#include "src/stdfix/bitshr.h"
+
+LIST_BITSFX_TESTS(hr, short fract, int_hr_t, LIBC_NAMESPACE::bitshr);
diff --git a/test/src/stdfix/bitsk_test.cpp b/test/src/stdfix/bitsk_test.cpp
new file mode 100644
index 0000000..7e0057b
--- /dev/null
+++ b/test/src/stdfix/bitsk_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitsk -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_k_t
+#include "src/stdfix/bitsk.h"
+
+LIST_BITSFX_TESTS(k, accum, int_k_t, LIBC_NAMESPACE::bitsk);
diff --git a/test/src/stdfix/bitslk_test.cpp b/test/src/stdfix/bitslk_test.cpp
new file mode 100644
index 0000000..46c04e2
--- /dev/null
+++ b/test/src/stdfix/bitslk_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitslk ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_lk_t
+#include "src/stdfix/bitslk.h"
+
+LIST_BITSFX_TESTS(lk, long accum, int_lk_t, LIBC_NAMESPACE::bitslk);
diff --git a/test/src/stdfix/bitslr_test.cpp b/test/src/stdfix/bitslr_test.cpp
new file mode 100644
index 0000000..ef68d28
--- /dev/null
+++ b/test/src/stdfix/bitslr_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitslr ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_lr_t
+#include "src/stdfix/bitslr.h"
+
+LIST_BITSFX_TESTS(hk, long fract, int_lr_t, LIBC_NAMESPACE::bitslr);
diff --git a/test/src/stdfix/bitsr_test.cpp b/test/src/stdfix/bitsr_test.cpp
new file mode 100644
index 0000000..0aeb980
--- /dev/null
+++ b/test/src/stdfix/bitsr_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitsr -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // int_r_t
+#include "src/stdfix/bitsr.h"
+
+LIST_BITSFX_TESTS(r, fract, int_r_t, LIBC_NAMESPACE::bitsr);
diff --git a/test/src/stdfix/bitsuhk_test.cpp b/test/src/stdfix/bitsuhk_test.cpp
new file mode 100644
index 0000000..5ddb783
--- /dev/null
+++ b/test/src/stdfix/bitsuhk_test.cpp
@@ -0,0 +1,15 @@
+//===-- Unittests for bitsuhk ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_uhk_t
+#include "src/stdfix/bitsuhk.h"
+
+LIST_BITSFX_TESTS(uhk, unsigned short accum, uint_uhk_t,
+                  LIBC_NAMESPACE::bitsuhk);
diff --git a/test/src/stdfix/bitsuhr_test.cpp b/test/src/stdfix/bitsuhr_test.cpp
new file mode 100644
index 0000000..6f5d559
--- /dev/null
+++ b/test/src/stdfix/bitsuhr_test.cpp
@@ -0,0 +1,15 @@
+//===-- Unittests for bitsuhr ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_uhr_t
+#include "src/stdfix/bitsuhr.h"
+
+LIST_BITSFX_TESTS(uhr, unsigned short fract, uint_uhr_t,
+                  LIBC_NAMESPACE::bitsuhr);
diff --git a/test/src/stdfix/bitsuk_test.cpp b/test/src/stdfix/bitsuk_test.cpp
new file mode 100644
index 0000000..309c525
--- /dev/null
+++ b/test/src/stdfix/bitsuk_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitsuk ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_uk_t
+#include "src/stdfix/bitsuk.h"
+
+LIST_BITSFX_TESTS(uk, unsigned accum, uint_uk_t, LIBC_NAMESPACE::bitsuk);
diff --git a/test/src/stdfix/bitsulk_test.cpp b/test/src/stdfix/bitsulk_test.cpp
new file mode 100644
index 0000000..cba011d
--- /dev/null
+++ b/test/src/stdfix/bitsulk_test.cpp
@@ -0,0 +1,15 @@
+//===-- Unittests for bitsulk ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_ulk_t
+#include "src/stdfix/bitsulk.h"
+
+LIST_BITSFX_TESTS(ulk, unsigned long accum, uint_ulk_t,
+                  LIBC_NAMESPACE::bitsulk);
diff --git a/test/src/stdfix/bitsulr_test.cpp b/test/src/stdfix/bitsulr_test.cpp
new file mode 100644
index 0000000..39b21c4
--- /dev/null
+++ b/test/src/stdfix/bitsulr_test.cpp
@@ -0,0 +1,15 @@
+//===-- Unittests for bitsulr ---------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_ulr_t
+#include "src/stdfix/bitsulr.h"
+
+LIST_BITSFX_TESTS(ulr, unsigned long fract, uint_ulr_t,
+                  LIBC_NAMESPACE::bitsulr);
diff --git a/test/src/stdfix/bitsur_test.cpp b/test/src/stdfix/bitsur_test.cpp
new file mode 100644
index 0000000..b7c4b06
--- /dev/null
+++ b/test/src/stdfix/bitsur_test.cpp
@@ -0,0 +1,14 @@
+//===-- Unittests for bitsur ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "BitsFxTest.h"
+
+#include "llvm-libc-types/stdfix-types.h" // uint_ur_t
+#include "src/stdfix/bitsur.h"
+
+LIST_BITSFX_TESTS(ur, unsigned fract, uint_ur_t, LIBC_NAMESPACE::bitsur);
diff --git a/test/src/stdfix/countlshk_test.cpp b/test/src/stdfix/countlshk_test.cpp
new file mode 100644
index 0000000..659f869
--- /dev/null
+++ b/test/src/stdfix/countlshk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlshk -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlshk.h"
+
+LIST_COUNTLS_TESTS(short accum, LIBC_NAMESPACE::countlshk);
diff --git a/test/src/stdfix/countlshr_test.cpp b/test/src/stdfix/countlshr_test.cpp
new file mode 100644
index 0000000..361d4ac
--- /dev/null
+++ b/test/src/stdfix/countlshr_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlshr -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlshr.h"
+
+LIST_COUNTLS_TESTS(short fract, LIBC_NAMESPACE::countlshr);
diff --git a/test/src/stdfix/countlsk_test.cpp b/test/src/stdfix/countlsk_test.cpp
new file mode 100644
index 0000000..74cb519
--- /dev/null
+++ b/test/src/stdfix/countlsk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsk --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsk.h"
+
+LIST_COUNTLS_TESTS(accum, LIBC_NAMESPACE::countlsk);
diff --git a/test/src/stdfix/countlslk_test.cpp b/test/src/stdfix/countlslk_test.cpp
new file mode 100644
index 0000000..006939d
--- /dev/null
+++ b/test/src/stdfix/countlslk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlslk -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlslk.h"
+
+LIST_COUNTLS_TESTS(long accum, LIBC_NAMESPACE::countlslk);
diff --git a/test/src/stdfix/countlslr_test.cpp b/test/src/stdfix/countlslr_test.cpp
new file mode 100644
index 0000000..896cf92
--- /dev/null
+++ b/test/src/stdfix/countlslr_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlslr -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlslr.h"
+
+LIST_COUNTLS_TESTS(long fract, LIBC_NAMESPACE::countlslr);
diff --git a/test/src/stdfix/countlsr_test.cpp b/test/src/stdfix/countlsr_test.cpp
new file mode 100644
index 0000000..d7ae91c
--- /dev/null
+++ b/test/src/stdfix/countlsr_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsr --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsr.h"
+
+LIST_COUNTLS_TESTS(fract, LIBC_NAMESPACE::countlsr);
diff --git a/test/src/stdfix/countlsuhk_test.cpp b/test/src/stdfix/countlsuhk_test.cpp
new file mode 100644
index 0000000..d8e68d6
--- /dev/null
+++ b/test/src/stdfix/countlsuhk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsuhk ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsuhk.h"
+
+LIST_COUNTLS_TESTS(unsigned short accum, LIBC_NAMESPACE::countlsuhk);
diff --git a/test/src/stdfix/countlsuhr_test.cpp b/test/src/stdfix/countlsuhr_test.cpp
new file mode 100644
index 0000000..7dbc590
--- /dev/null
+++ b/test/src/stdfix/countlsuhr_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsuhr ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsuhr.h"
+
+LIST_COUNTLS_TESTS(unsigned short fract, LIBC_NAMESPACE::countlsuhr);
diff --git a/test/src/stdfix/countlsuk_test.cpp b/test/src/stdfix/countlsuk_test.cpp
new file mode 100644
index 0000000..20f78d8
--- /dev/null
+++ b/test/src/stdfix/countlsuk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsuk -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsuk.h"
+
+LIST_COUNTLS_TESTS(unsigned accum, LIBC_NAMESPACE::countlsuk);
diff --git a/test/src/stdfix/countlsulk_test.cpp b/test/src/stdfix/countlsulk_test.cpp
new file mode 100644
index 0000000..81ae208
--- /dev/null
+++ b/test/src/stdfix/countlsulk_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsulk ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsulk.h"
+
+LIST_COUNTLS_TESTS(unsigned long accum, LIBC_NAMESPACE::countlsulk);
diff --git a/test/src/stdfix/countlsulr_test.cpp b/test/src/stdfix/countlsulr_test.cpp
new file mode 100644
index 0000000..5b9b047
--- /dev/null
+++ b/test/src/stdfix/countlsulr_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsulr ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsulr.h"
+
+LIST_COUNTLS_TESTS(unsigned long fract, LIBC_NAMESPACE::countlsulr);
diff --git a/test/src/stdfix/countlsur_test.cpp b/test/src/stdfix/countlsur_test.cpp
new file mode 100644
index 0000000..67e32d7
--- /dev/null
+++ b/test/src/stdfix/countlsur_test.cpp
@@ -0,0 +1,13 @@
+//===-- Unittests for countlsur -------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "CountlsTest.h"
+
+#include "src/stdfix/countlsur.h"
+
+LIST_COUNTLS_TESTS(unsigned fract, LIBC_NAMESPACE::countlsur);
diff --git a/test/src/stdfix/macros_test.cpp b/test/src/stdfix/macros_test.cpp
new file mode 100644
index 0000000..b52abf3
--- /dev/null
+++ b/test/src/stdfix/macros_test.cpp
@@ -0,0 +1,113 @@
+//===-- Unittests for absfx -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "AbsTest.h"
+#include "src/stdfix/abshk.h"
+#include "src/stdfix/abshr.h"
+#include "src/stdfix/absk.h"
+#include "src/stdfix/abslk.h"
+#include "src/stdfix/abslr.h"
+#include "src/stdfix/absr.h"
+
+#include "src/stdfix/countlshk.h"
+#include "src/stdfix/countlshr.h"
+#include "src/stdfix/countlsk.h"
+#include "src/stdfix/countlslk.h"
+#include "src/stdfix/countlslr.h"
+#include "src/stdfix/countlsr.h"
+#include "src/stdfix/countlsuhk.h"
+#include "src/stdfix/countlsuhr.h"
+#include "src/stdfix/countlsuk.h"
+#include "src/stdfix/countlsulk.h"
+#include "src/stdfix/countlsulr.h"
+#include "src/stdfix/countlsur.h"
+
+#include "src/stdfix/roundhk.h"
+#include "src/stdfix/roundhr.h"
+#include "src/stdfix/roundk.h"
+#include "src/stdfix/roundlk.h"
+#include "src/stdfix/roundlr.h"
+#include "src/stdfix/roundr.h"
+#include "src/stdfix/rounduhk.h"
+#include "src/stdfix/rounduhr.h"
+#include "src/stdfix/rounduk.h"
+#include "src/stdfix/roundulk.h"
+#include "src/stdfix/roundulr.h"
+#include "src/stdfix/roundur.h"
+
+using LIBC_NAMESPACE::abshk;
+using LIBC_NAMESPACE::abshr;
+using LIBC_NAMESPACE::absk;
+using LIBC_NAMESPACE::abslk;
+using LIBC_NAMESPACE::abslr;
+using LIBC_NAMESPACE::absr;
+using LIBC_NAMESPACE::countlshk;
+using LIBC_NAMESPACE::countlshr;
+using LIBC_NAMESPACE::countlsk;
+using LIBC_NAMESPACE::countlslk;
+using LIBC_NAMESPACE::countlslr;
+using LIBC_NAMESPACE::countlsr;
+using LIBC_NAMESPACE::countlsuhk;
+using LIBC_NAMESPACE::countlsuhr;
+using LIBC_NAMESPACE::countlsuk;
+using LIBC_NAMESPACE::countlsulk;
+using LIBC_NAMESPACE::countlsulr;
+using LIBC_NAMESPACE::countlsur;
+using LIBC_NAMESPACE::roundhk;
+using LIBC_NAMESPACE::roundhr;
+using LIBC_NAMESPACE::roundk;
+using LIBC_NAMESPACE::roundlk;
+using LIBC_NAMESPACE::roundlr;
+using LIBC_NAMESPACE::roundr;
+using LIBC_NAMESPACE::rounduhk;
+using LIBC_NAMESPACE::rounduhr;
+using LIBC_NAMESPACE::rounduk;
+using LIBC_NAMESPACE::roundulk;
+using LIBC_NAMESPACE::roundulr;
+using LIBC_NAMESPACE::roundur;
+
+TEST(LlvmLibcAbsfxTest, Basic) {
+  ASSERT_EQ(absfx(-0.5r), absr(-0.5r));
+  ASSERT_EQ(absfx(-0.5hr), abshr(-0.5hr));
+  ASSERT_EQ(absfx(-0.5lr), abslr(-0.5lr));
+  ASSERT_EQ(absfx(-0.5k), absk(-0.5k));
+  ASSERT_EQ(absfx(-0.5hk), abshk(-0.5hk));
+  ASSERT_EQ(absfx(-0.5lk), abslk(-0.5lk));
+}
+
+TEST(LlvmLibcRoundfxTest, Basic) {
+  ASSERT_EQ(roundfx(0.75r, 0), roundr(0.75r, 0));
+  ASSERT_EQ(roundfx(0.75hr, 0), roundhr(0.75hr, 0));
+  ASSERT_EQ(roundfx(0.75lr, 0), roundlr(0.75lr, 0));
+  ASSERT_EQ(roundfx(0.75k, 0), roundk(0.75k, 0));
+  ASSERT_EQ(roundfx(0.75hk, 0), roundhk(0.75hk, 0));
+  ASSERT_EQ(roundfx(0.75lk, 0), roundlk(0.75lk, 0));
+
+  ASSERT_EQ(roundfx(0.75ur, 0), roundur(0.75ur, 0));
+  ASSERT_EQ(roundfx(0.75uhr, 0), rounduhr(0.75uhr, 0));
+  ASSERT_EQ(roundfx(0.75ulr, 0), roundulr(0.75ulr, 0));
+  ASSERT_EQ(roundfx(0.75uk, 0), rounduk(0.75uk, 0));
+  ASSERT_EQ(roundfx(0.75uhk, 0), rounduhk(0.75uhk, 0));
+  ASSERT_EQ(roundfx(0.75ulk, 0), roundulk(0.75ulk, 0));
+}
+
+TEST(LlvmLibcCountlsfxTest, Basic) {
+  ASSERT_EQ(countlsfx(0.5r), countlsr(0.5r));
+  ASSERT_EQ(countlsfx(0.5hr), countlshr(0.5hr));
+  ASSERT_EQ(countlsfx(0.5lr), countlslr(0.5lr));
+  ASSERT_EQ(countlsfx(0.5k), countlsk(0.5k));
+  ASSERT_EQ(countlsfx(0.5hk), countlshk(0.5hk));
+  ASSERT_EQ(countlsfx(0.5lk), countlslk(0.5lk));
+
+  ASSERT_EQ(countlsfx(0.5ur), countlsur(0.5ur));
+  ASSERT_EQ(countlsfx(0.5uhr), countlsuhr(0.5uhr));
+  ASSERT_EQ(countlsfx(0.5ulr), countlsulr(0.5ulr));
+  ASSERT_EQ(countlsfx(0.5uk), countlsuk(0.5uk));
+  ASSERT_EQ(countlsfx(0.5uhk), countlsuhk(0.5uhk));
+  ASSERT_EQ(countlsfx(0.5ulk), countlsulk(0.5ulk));
+}
diff --git a/test/src/stdio/fileop_test.cpp b/test/src/stdio/fileop_test.cpp
index 98ead6e..a0368d7 100644
--- a/test/src/stdio/fileop_test.cpp
+++ b/test/src/stdio/fileop_test.cpp
@@ -31,7 +31,7 @@ TEST(LlvmLibcFILETest, SimpleFileOperations) {
   constexpr char FILENAME[] = "testdata/simple_operations.test";
   ::FILE *file = LIBC_NAMESPACE::fopen(FILENAME, "w");
   ASSERT_FALSE(file == nullptr);
-  ASSERT_EQ(LIBC_NAMESPACE::fileno(file), 3);
+  ASSERT_GE(LIBC_NAMESPACE::fileno(file), 0);
   constexpr char CONTENT[] = "1234567890987654321";
   ASSERT_EQ(sizeof(CONTENT) - 1,
             LIBC_NAMESPACE::fwrite(CONTENT, 1, sizeof(CONTENT) - 1, file));
@@ -87,7 +87,7 @@ TEST(LlvmLibcFILETest, SimpleFileOperations) {
 
   LIBC_NAMESPACE::libc_errno = 0;
   ASSERT_THAT(LIBC_NAMESPACE::fwrite("nothing", 1, 1, file),
-              returns(EQ(0)).with_errno(NE(0)));
+              returns(EQ(size_t(0))).with_errno(NE(0)));
   LIBC_NAMESPACE::libc_errno = 0;
 
   ASSERT_EQ(LIBC_NAMESPACE::fclose(file), 0);
diff --git a/test/src/stdio/printf_core/converter_test.cpp b/test/src/stdio/printf_core/converter_test.cpp
index 9da749f..96a00ae 100644
--- a/test/src/stdio/printf_core/converter_test.cpp
+++ b/test/src/stdio/printf_core/converter_test.cpp
@@ -18,10 +18,14 @@ protected:
   // void TearDown() override {}
 
   char str[60];
-  LIBC_NAMESPACE::printf_core::WriteBuffer wb =
-      LIBC_NAMESPACE::printf_core::WriteBuffer(str, sizeof(str) - 1);
-  LIBC_NAMESPACE::printf_core::Writer writer =
-      LIBC_NAMESPACE::printf_core::Writer(&wb);
+  LIBC_NAMESPACE::printf_core::WriteBuffer<
+      LIBC_NAMESPACE::printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>
+      wb = LIBC_NAMESPACE::printf_core::WriteBuffer<
+          LIBC_NAMESPACE::printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>(
+          str, sizeof(str) - 1);
+  LIBC_NAMESPACE::printf_core::Writer<
+      LIBC_NAMESPACE::printf_core::WriteMode::FILL_BUFF_AND_DROP_OVERFLOW>
+      writer = LIBC_NAMESPACE::printf_core::Writer(wb);
 };
 
 TEST_F(LlvmLibcPrintfConverterTest, SimpleRawConversion) {
diff --git a/test/src/stdio/printf_core/parser_test.cpp b/test/src/stdio/printf_core/parser_test.cpp
index c277b30..9d19282 100644
--- a/test/src/stdio/printf_core/parser_test.cpp
+++ b/test/src/stdio/printf_core/parser_test.cpp
@@ -97,7 +97,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArg) {
   expected.has_conv = true;
 
   expected.raw_string = {str, 2};
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -132,7 +133,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithFlags) {
       LIBC_NAMESPACE::printf_core::FormatFlags::LEADING_ZEROES |
       LIBC_NAMESPACE::printf_core::FormatFlags::SPACE_PREFIX |
       LIBC_NAMESPACE::printf_core::FormatFlags::ALTERNATE_FORM);
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -149,7 +151,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithWidth) {
 
   expected.raw_string = {str, 4};
   expected.min_width = 12;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -166,7 +169,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithPrecision) {
 
   expected.raw_string = {str, 5};
   expected.precision = 34;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -183,7 +187,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithTrivialPrecision) {
 
   expected.raw_string = {str, 3};
   expected.precision = 0;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -200,7 +205,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithShortLengthModifier) {
 
   expected.raw_string = {str, 3};
   expected.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::h;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -217,7 +223,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithLongLengthModifier) {
 
   expected.raw_string = {str, 4};
   expected.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::ll;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -235,7 +242,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithBitWidthLengthModifier) {
   expected.raw_string = {str, 5};
   expected.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::w;
   expected.bit_width = 32;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -253,7 +261,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithFastBitWidthLengthModifier) {
   expected.raw_string = {str, 6};
   expected.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::wf;
   expected.bit_width = 32;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -276,7 +285,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithAllOptions) {
   expected.min_width = 56;
   expected.precision = 78;
   expected.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::j;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -294,7 +304,8 @@ TEST(LlvmLibcPrintfParserTest, EvalThreeArgs) {
   expected0.has_conv = true;
 
   expected0.raw_string = {str, 2};
-  expected0.conv_val_raw = arg1;
+  expected0.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected0.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected0, format_arr[0]);
@@ -329,7 +340,8 @@ TEST(LlvmLibcPrintfParserTest, EvalOneArgWithOverflowingWidthAndPrecision) {
   expected.flags = LIBC_NAMESPACE::printf_core::FormatFlags::LEFT_JUSTIFIED;
   expected.min_width = INT_MAX;
   expected.precision = INT_MAX;
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -351,7 +363,8 @@ TEST(LlvmLibcPrintfParserTest,
   expected.flags = LIBC_NAMESPACE::printf_core::FormatFlags::LEFT_JUSTIFIED;
   expected.min_width = INT_MAX;
   expected.precision = arg2;
-  expected.conv_val_raw = arg3;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg3);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -369,7 +382,8 @@ TEST(LlvmLibcPrintfParserTest, IndexModeOneArg) {
   expected.has_conv = true;
 
   expected.raw_string = {str, 4};
-  expected.conv_val_raw = arg1;
+  expected.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected, format_arr[0]);
@@ -387,7 +401,8 @@ TEST(LlvmLibcPrintfParserTest, IndexModeThreeArgsSequential) {
   expected0.has_conv = true;
 
   expected0.raw_string = {str, 4};
-  expected0.conv_val_raw = arg1;
+  expected0.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected0.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected0, format_arr[0]);
@@ -421,7 +436,8 @@ TEST(LlvmLibcPrintfParserTest, IndexModeThreeArgsReverse) {
   expected0.has_conv = true;
 
   expected0.raw_string = {str, 4};
-  expected0.conv_val_raw = arg1;
+  expected0.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected0.conv_name = 'd';
 
   ASSERT_PFORMAT_EQ(expected0, format_arr[0]);
@@ -485,7 +501,8 @@ TEST(LlvmLibcPrintfParserTest, IndexModeComplexParsing) {
 
   expected1.raw_string = {str + 12, 6};
   expected1.length_modifier = LIBC_NAMESPACE::printf_core::LengthModifier::ll;
-  expected1.conv_val_raw = arg3;
+  expected1.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg3);
   expected1.conv_name = 'u';
 
   EXPECT_PFORMAT_EQ(expected1, format_arr[1]);
@@ -546,7 +563,8 @@ TEST(LlvmLibcPrintfParserTest, IndexModeComplexParsing) {
   expected9.raw_string = {str + 41, 7};
   expected9.min_width = 1;
   expected9.precision = 1;
-  expected9.conv_val_raw = arg1;
+  expected9.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected9.conv_name = 'c';
 
   EXPECT_PFORMAT_EQ(expected9, format_arr[9]);
@@ -566,14 +584,16 @@ TEST(LlvmLibcPrintfParserTest, IndexModeGapCheck) {
 
   expected0.has_conv = true;
   expected0.raw_string = {str, 4};
-  expected0.conv_val_raw = arg1;
+  expected0.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg1);
   expected0.conv_name = 'd';
 
   EXPECT_PFORMAT_EQ(expected0, format_arr[0]);
 
   expected1.has_conv = true;
   expected1.raw_string = {str + 4, 4};
-  expected1.conv_val_raw = arg2;
+  expected1.conv_val_raw =
+      static_cast<LIBC_NAMESPACE::fputil::FPBits<double>::StorageType>(arg2);
   expected1.conv_name = 'd';
 
   EXPECT_PFORMAT_EQ(expected1, format_arr[1]);
diff --git a/test/src/stdio/printf_core/writer_test.cpp b/test/src/stdio/printf_core/writer_test.cpp
index 4fe5ffb..8611caa 100644
--- a/test/src/stdio/printf_core/writer_test.cpp
+++ b/test/src/stdio/printf_core/writer_test.cpp
@@ -15,19 +15,20 @@
 
 using LIBC_NAMESPACE::cpp::string_view;
 using LIBC_NAMESPACE::printf_core::WriteBuffer;
+using LIBC_NAMESPACE::printf_core::WriteMode;
 using LIBC_NAMESPACE::printf_core::Writer;
 
 TEST(LlvmLibcPrintfWriterTest, Constructor) {
   char str[10];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   (void)writer;
 }
 
 TEST(LlvmLibcPrintfWriterTest, Write) {
   char str[4] = {'D', 'E', 'F', 'G'};
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write({"abc", 3});
 
   EXPECT_EQ(str[3], 'G');
@@ -42,8 +43,8 @@ TEST(LlvmLibcPrintfWriterTest, Write) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteMultipleTimes) {
   char str[10];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write({"abc", 3});
   writer.write({"DEF", 3});
   writer.write({"1234", 3});
@@ -56,8 +57,8 @@ TEST(LlvmLibcPrintfWriterTest, WriteMultipleTimes) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteChars) {
   char str[4] = {'D', 'E', 'F', 'G'};
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write('a', 3);
 
   EXPECT_EQ(str[3], 'G');
@@ -69,8 +70,8 @@ TEST(LlvmLibcPrintfWriterTest, WriteChars) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteCharsMultipleTimes) {
   char str[10];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write('D', 3);
   writer.write('1', 3);
@@ -83,8 +84,8 @@ TEST(LlvmLibcPrintfWriterTest, WriteCharsMultipleTimes) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteManyChars) {
   char str[100];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write('Z', 99);
 
   wb.buff[wb.buff_cur] = '\0';
@@ -105,8 +106,8 @@ TEST(LlvmLibcPrintfWriterTest, WriteManyChars) {
 
 TEST(LlvmLibcPrintfWriterTest, MixedWrites) {
   char str[13];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -120,8 +121,8 @@ TEST(LlvmLibcPrintfWriterTest, MixedWrites) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteWithMaxLength) {
   char str[11];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write({"abcDEF123456", 12});
 
   wb.buff[wb.buff_cur] = '\0';
@@ -132,8 +133,8 @@ TEST(LlvmLibcPrintfWriterTest, WriteWithMaxLength) {
 
 TEST(LlvmLibcPrintfWriterTest, WriteCharsWithMaxLength) {
   char str[11];
-  WriteBuffer wb(str, sizeof(str) - 1);
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
+  Writer writer(wb);
   writer.write('1', 15);
 
   wb.buff[wb.buff_cur] = '\0';
@@ -144,9 +145,9 @@ TEST(LlvmLibcPrintfWriterTest, WriteCharsWithMaxLength) {
 
 TEST(LlvmLibcPrintfWriterTest, MixedWriteWithMaxLength) {
   char str[11];
-  WriteBuffer wb(str, sizeof(str) - 1);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, sizeof(str) - 1);
 
-  Writer writer(&wb);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -162,9 +163,9 @@ TEST(LlvmLibcPrintfWriterTest, StringWithMaxLengthOne) {
   char str[1];
   // This is because the max length should be at most 1 less than the size of
   // the buffer it's writing to.
-  WriteBuffer wb(str, 0);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(str, 0);
 
-  Writer writer(&wb);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -177,9 +178,9 @@ TEST(LlvmLibcPrintfWriterTest, StringWithMaxLengthOne) {
 }
 
 TEST(LlvmLibcPrintfWriterTest, NullStringWithZeroMaxLength) {
-  WriteBuffer wb(nullptr, 0);
+  WriteBuffer<WriteMode::FILL_BUFF_AND_DROP_OVERFLOW> wb(nullptr, 0);
 
-  Writer writer(&wb);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -213,9 +214,10 @@ TEST(LlvmLibcPrintfWriterTest, WriteWithMaxLengthWithCallback) {
   OutBuff out_buff = {str, 0};
 
   char wb_buff[8];
-  WriteBuffer wb(wb_buff, sizeof(wb_buff), &copy_to_out,
-                 reinterpret_cast<void *>(&out_buff));
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FLUSH_TO_STREAM> wb(
+      wb_buff, sizeof(wb_buff), &copy_to_out,
+      reinterpret_cast<void *>(&out_buff));
+  Writer writer(wb);
   writer.write({"abcDEF123456", 12});
 
   // Flush the buffer
@@ -232,9 +234,10 @@ TEST(LlvmLibcPrintfWriterTest, WriteCharsWithMaxLengthWithCallback) {
   OutBuff out_buff = {str, 0};
 
   char wb_buff[8];
-  WriteBuffer wb(wb_buff, sizeof(wb_buff), &copy_to_out,
-                 reinterpret_cast<void *>(&out_buff));
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FLUSH_TO_STREAM> wb(
+      wb_buff, sizeof(wb_buff), &copy_to_out,
+      reinterpret_cast<void *>(&out_buff));
+  Writer writer(wb);
   writer.write('1', 15);
 
   // Flush the buffer
@@ -251,9 +254,10 @@ TEST(LlvmLibcPrintfWriterTest, MixedWriteWithMaxLengthWithCallback) {
   OutBuff out_buff = {str, 0};
 
   char wb_buff[8];
-  WriteBuffer wb(wb_buff, sizeof(wb_buff), &copy_to_out,
-                 reinterpret_cast<void *>(&out_buff));
-  Writer writer(&wb);
+  WriteBuffer<WriteMode::FLUSH_TO_STREAM> wb(
+      wb_buff, sizeof(wb_buff), &copy_to_out,
+      reinterpret_cast<void *>(&out_buff));
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -273,9 +277,10 @@ TEST(LlvmLibcPrintfWriterTest, ZeroLengthBufferWithCallback) {
   OutBuff out_buff = {str, 0};
 
   char wb_buff[1];
-  WriteBuffer wb(wb_buff, 0, &copy_to_out, reinterpret_cast<void *>(&out_buff));
+  WriteBuffer<WriteMode::FLUSH_TO_STREAM> wb(
+      wb_buff, 0, &copy_to_out, reinterpret_cast<void *>(&out_buff));
 
-  Writer writer(&wb);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
@@ -294,9 +299,10 @@ TEST(LlvmLibcPrintfWriterTest, NullStringWithZeroMaxLengthWithCallback) {
 
   OutBuff out_buff = {str, 0};
 
-  WriteBuffer wb(nullptr, 0, &copy_to_out, reinterpret_cast<void *>(&out_buff));
+  WriteBuffer<WriteMode::FLUSH_TO_STREAM> wb(
+      nullptr, 0, &copy_to_out, reinterpret_cast<void *>(&out_buff));
 
-  Writer writer(&wb);
+  Writer writer(wb);
   writer.write('a', 3);
   writer.write({"DEF", 3});
   writer.write('1', 3);
diff --git a/test/src/stdio/scanf_core/converter_test.cpp b/test/src/stdio/scanf_core/converter_test.cpp
index d1aecd4..ff0ce92 100644
--- a/test/src/stdio/scanf_core/converter_test.cpp
+++ b/test/src/stdio/scanf_core/converter_test.cpp
@@ -9,14 +9,13 @@
 #include "src/__support/CPP/string_view.h"
 #include "src/stdio/scanf_core/converter.h"
 #include "src/stdio/scanf_core/core_structs.h"
-#include "src/stdio/scanf_core/reader.h"
+#include "src/stdio/scanf_core/string_reader.h"
 
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcScanfConverterTest, RawMatchBasic) {
   const char *str = "abcdef";
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   // Reading "abc" should succeed.
   ASSERT_EQ(LIBC_NAMESPACE::scanf_core::raw_match(&reader, "abc"),
@@ -51,8 +50,7 @@ TEST(LlvmLibcScanfConverterTest, RawMatchBasic) {
 
 TEST(LlvmLibcScanfConverterTest, RawMatchSpaces) {
   const char *str = " a \t\n b   cd";
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   // Reading "a" should fail and not advance.
   // Since there's nothing in the format string (the second argument to
@@ -98,8 +96,7 @@ TEST(LlvmLibcScanfConverterTest, RawMatchSpaces) {
 TEST(LlvmLibcScanfConverterTest, StringConvSimple) {
   const char *str = "abcDEF123 654LKJihg";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
   conv.has_conv = true;
@@ -120,8 +117,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvSimple) {
 
 TEST(LlvmLibcScanfConverterTest, StringConvNoWrite) {
   const char *str = "abcDEF123 654LKJihg";
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
   conv.has_conv = true;
@@ -141,8 +137,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvNoWrite) {
 TEST(LlvmLibcScanfConverterTest, StringConvWidth) {
   const char *str = "abcDEF123 654LKJihg";
   char result[6];
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
   conv.has_conv = true;
@@ -175,8 +170,7 @@ TEST(LlvmLibcScanfConverterTest, StringConvWidth) {
 TEST(LlvmLibcScanfConverterTest, CharsConv) {
   const char *str = "abcDEF123 654LKJihg MNOpqr&*(";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
   conv.has_conv = true;
@@ -230,8 +224,7 @@ TEST(LlvmLibcScanfConverterTest, CharsConv) {
 TEST(LlvmLibcScanfConverterTest, ScansetConv) {
   const char *str = "abcDEF[123] 654LKJihg";
   char result[20];
-  LIBC_NAMESPACE::scanf_core::ReadBuffer str_reader{str, sizeof(str)};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&str_reader);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(str, sizeof(str));
 
   LIBC_NAMESPACE::scanf_core::FormatSection conv;
   conv.has_conv = true;
diff --git a/test/src/stdio/scanf_core/reader_test.cpp b/test/src/stdio/scanf_core/reader_test.cpp
index 43a1418..4cafc81 100644
--- a/test/src/stdio/scanf_core/reader_test.cpp
+++ b/test/src/stdio/scanf_core/reader_test.cpp
@@ -7,7 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
-#include "src/stdio/scanf_core/reader.h"
+#include "src/stdio/scanf_core/string_reader.h"
 
 #include "test/UnitTest/Test.h"
 
@@ -15,14 +15,14 @@ TEST(LlvmLibcScanfStringReaderTest, Constructor) {
   char str[10];
   // buff_len justneeds to be a big number. The specific value isn't important
   // in the real world.
-  LIBC_NAMESPACE::scanf_core::ReadBuffer rb{const_cast<char *>(str), 1000000};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&rb);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(const_cast<char *>(str),
+                                                  1000000);
 }
 
 TEST(LlvmLibcScanfStringReaderTest, SimpleRead) {
   const char *str = "abc";
-  LIBC_NAMESPACE::scanf_core::ReadBuffer rb{const_cast<char *>(str), 1000000};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&rb);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(const_cast<char *>(str),
+                                                  1000000);
 
   for (size_t i = 0; i < sizeof("abc"); ++i) {
     ASSERT_EQ(str[i], reader.getc());
@@ -31,8 +31,8 @@ TEST(LlvmLibcScanfStringReaderTest, SimpleRead) {
 
 TEST(LlvmLibcScanfStringReaderTest, ReadAndReverse) {
   const char *str = "abcDEF123";
-  LIBC_NAMESPACE::scanf_core::ReadBuffer rb{const_cast<char *>(str), 1000000};
-  LIBC_NAMESPACE::scanf_core::Reader reader(&rb);
+  LIBC_NAMESPACE::scanf_core::StringReader reader(const_cast<char *>(str),
+                                                  1000000);
 
   for (size_t i = 0; i < 5; ++i) {
     ASSERT_EQ(str[i], reader.getc());
diff --git a/test/src/stdio/sprintf_test.cpp b/test/src/stdio/sprintf_test.cpp
index e8303ff..f6af6ad 100644
--- a/test/src/stdio/sprintf_test.cpp
+++ b/test/src/stdio/sprintf_test.cpp
@@ -1861,6 +1861,113 @@ TEST(LlvmLibcSPrintfTest, FloatDecimalLongDoubleConv) {
       "179817332113");
 #endif
 #endif // LIBC_TYPES_LONG_DOUBLE_IS_X86_FLOAT80
+
+#if defined(LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128)
+  // Some exceptionally difficult cases for 39-digit precision. (That's the
+  // number of digits supported by the float320 algorithm, and should still be
+  // correct under other algorithms. So these are still enabled even under
+  // LIBC_COPT_FLOAT_TO_STR_REDUCED_PRECISION.)
+  //
+  // These were found by number-theoretic search to be the worst cases in terms
+  // of being extremely close to the rounding boundary between two possible
+  // decimal outputs. For example, the first of these cases has a true value
+  // beginning with
+  //
+  // 2.245786964418815522831613614422112838795000000000000000000
+  //                                          0000000000000000010767969...
+  //
+  // so you need to compute a _long_ way past the 39th digit to find out
+  // whether to round the ...8795 up to 880 or not!
+  //
+  // The first half of these cases all rounded up; the second half all rounded
+  // down. You can see that in both sections the final decimal digit is
+  // sometimes odd and sometimes even, ruling out the possibility that we're
+  // getting these right by mistakenly assuming them to be _exactly_ on the
+  // boundary.
+
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.bde5716bba8d70255b4be10e0a0ap-3388L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "2.24578696441881552283161361442211283880e-1020");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.64b78defc8712684490980d80808p-3391L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "2.24578696441881552283161361442211283880e-1021");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.c0eed9d1ea4b6f215accb15cb42cp-4714L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.54362575487963943466308346767014523161e-1419");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.a393eaafc3dbabfcd30442cef525p-12600L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.72435694193924008931441874634575361189e-3793");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.b7a5248baf85133c9b7bf3241f75p+11050L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "4.13346579244549095104252956440178208514e+3326");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.81bf6d977f99ff7bd9debdd52815p+1359L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.89595297593127274811683259716608232064e+409");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.fcb9cfd65f068b758d30ba19a494p-4451L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "2.59258570015527007681686041122929728653e-1340");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.7d8b5be0c744e89829e48b933b6fp-4448L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.55555142009316204609011624673757837192e-1339");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.dbb1f01aef7b93c37ca00217888cp-12205L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.57758077908296078543773740016012372216e-3674");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.fb037d72fdf1a8aa8bdfc2586fe3p+2580L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "8.99846610004600287527755301065037553046e+776");
+
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.9af8fe5febf751a795292e30335dp+2052L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "8.30087814106622071390265113980150545241e+617");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.48c731e6565f748610edbe8cf5e4p+2049L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "8.30087814106622071390265113980150545241e+616");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.8e78bc76e98998b7bbf6c8f80f2ap-5671L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.12473970318904704063044350553302771341e-1707");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.59a832c16a7797aec70196ddf9dbp-16181L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.45896738321434823250358135932839533040e-4871");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.14868f0121f946256c01457e617cp-16184L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.45896738321434823250358135932839533040e-4872");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.0ca8c4b525b1128506cdc668df43p+11017L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "2.94051951004764266903705588743096762647e+3316");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.fcd40bb49b18aa19d66a3c5572dep+5547L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.29335350323078956384272678475060580129e+1670");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.0e5e51510a653e744d6b84efed86p-13613L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "1.26585813611514592337442314391432904094e-4098");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.ff41f8aa97e676e95b1a6a7751fap+16366L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "9.06377119787295161934827646572467920486e+4926");
+  written = LIBC_NAMESPACE::sprintf(buff, "%#.39Lg",
+                                    0x1.4770bf66ccafd7d80ac9bb3dded7p-1843L);
+  ASSERT_STREQ_LEN(written, buff,
+                   "2.03521509642091239545213340619368190283e-555");
+
+#endif // LIBC_TYPES_LONG_DOUBLE_IS_FLOAT128
 }
 
 TEST(LlvmLibcSPrintfTest, FloatExponentConv) {
diff --git a/test/src/stdio/sscanf_test.cpp b/test/src/stdio/sscanf_test.cpp
index 18addb6..cb302df 100644
--- a/test/src/stdio/sscanf_test.cpp
+++ b/test/src/stdio/sscanf_test.cpp
@@ -246,27 +246,27 @@ TEST(LlvmLibcSScanfTest, FloatConvSimple) {
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 123.0);
+  EXPECT_FP_EQ(result, 123.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("456.1", "%a", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 456.1);
+  EXPECT_FP_EQ(result, 456.1f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x789.ap0", "%e", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0x789.ap0);
+  EXPECT_FP_EQ(result, 0x789.ap0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x.8", "%e", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0x0.8p0);
+  EXPECT_FP_EQ(result, 0x0.8p0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x8.", "%e", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0x8.0p0);
+  EXPECT_FP_EQ(result, 0x8.0p0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("+12.0e1", "%g", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 12.0e1);
+  EXPECT_FP_EQ(result, 12.0e1f);
 
   ret_val = LIBC_NAMESPACE::sscanf("inf", "%F", &result);
   EXPECT_EQ(ret_val, 1);
@@ -282,19 +282,19 @@ TEST(LlvmLibcSScanfTest, FloatConvSimple) {
 
   ret_val = LIBC_NAMESPACE::sscanf("1e10", "%G", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 1e10);
+  EXPECT_FP_EQ(result, 1e10f);
 
   ret_val = LIBC_NAMESPACE::sscanf(".1", "%G", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.1);
+  EXPECT_FP_EQ(result, 0.1f);
 
   ret_val = LIBC_NAMESPACE::sscanf("1.", "%G", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 1.0);
+  EXPECT_FP_EQ(result, 1.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0", "%f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("Not a float", "%f", &result);
   EXPECT_EQ(ret_val, 0);
@@ -407,7 +407,7 @@ TEST(LlvmLibcSScanfTest, FloatConvComplexParsing) {
 
   ret_val = LIBC_NAMESPACE::sscanf("0x1.0e3", "%f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0x1.0e3p0);
+  EXPECT_FP_EQ(result, 0x1.0e3p0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("", "%a", &result);
   EXPECT_EQ(ret_val, 0);
@@ -463,11 +463,11 @@ TEST(LlvmLibcSScanfTest, FloatConvComplexParsing) {
 
   ret_val = LIBC_NAMESPACE::sscanf("-.1e1", "%f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, -.1e1);
+  EXPECT_FP_EQ(result, -.1e1f);
 
   ret_val = LIBC_NAMESPACE::sscanf("1.2.e1", "%f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 1.2);
+  EXPECT_FP_EQ(result, 1.2f);
 }
 
 TEST(LlvmLibcSScanfTest, FloatConvMaxWidth) {
@@ -478,22 +478,22 @@ TEST(LlvmLibcSScanfTest, FloatConvMaxWidth) {
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%3f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 123.0);
+  EXPECT_FP_EQ(result, 123.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%5f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 123.0);
+  EXPECT_FP_EQ(result, 123.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("456", "%1f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 4.0);
+  EXPECT_FP_EQ(result, 4.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("-789", "%1f", &result);
   EXPECT_EQ(ret_val, 0);
 
   ret_val = LIBC_NAMESPACE::sscanf("-123", "%2f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, -1.0);
+  EXPECT_FP_EQ(result, -1.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("inf", "%2f", &result);
   EXPECT_EQ(ret_val, 0);
@@ -519,11 +519,11 @@ TEST(LlvmLibcSScanfTest, FloatConvMaxWidth) {
 
   ret_val = LIBC_NAMESPACE::sscanf("01", "%1f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x1", "%2f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("100e", "%4f", &result);
   EXPECT_EQ(ret_val, 0);
@@ -533,7 +533,7 @@ TEST(LlvmLibcSScanfTest, FloatConvMaxWidth) {
 
   ret_val = LIBC_NAMESPACE::sscanf("100e10", "%5f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 100e1);
+  EXPECT_FP_EQ(result, 100e1f);
 }
 
 TEST(LlvmLibcSScanfTest, FloatConvNoWrite) {
@@ -542,51 +542,51 @@ TEST(LlvmLibcSScanfTest, FloatConvNoWrite) {
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%*f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("456.1", "%*a", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("0x789.ap0", "%*e", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("+12.0e1", "%*g", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("inf", "%*F", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("NaN", "%*A", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("-InFiNiTy", "%*E", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("1e10", "%*G", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf(".1", "%*G", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%*3f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("123", "%*5f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("456", "%*1f", &result);
   EXPECT_EQ(ret_val, 1);
-  EXPECT_FP_EQ(result, 0.0);
+  EXPECT_FP_EQ(result, 0.0f);
 
   ret_val = LIBC_NAMESPACE::sscanf("Not a float", "%*f", &result);
   EXPECT_EQ(ret_val, 0);
diff --git a/test/src/stdlib/SortingTest.h b/test/src/stdlib/SortingTest.h
index d34584e..d845280 100644
--- a/test/src/stdlib/SortingTest.h
+++ b/test/src/stdlib/SortingTest.h
@@ -7,19 +7,18 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/macros/config.h"
-#include "src/stdlib/qsort_data.h"
 #include "test/UnitTest/Test.h"
 
 class SortingTest : public LIBC_NAMESPACE::testing::Test {
 
-  using Array = LIBC_NAMESPACE::internal::Array;
-  using Comparator = LIBC_NAMESPACE::internal::Comparator;
-  using SortingRoutine = LIBC_NAMESPACE::internal::SortingRoutine;
+  using SortingRoutine = void (*)(void *array, size_t array_len,
+                                  size_t elem_size,
+                                  int (*compare)(const void *, const void *));
 
-public:
   static int int_compare(const void *l, const void *r) {
     int li = *reinterpret_cast<const int *>(l);
     int ri = *reinterpret_cast<const int *>(r);
+
     if (li == ri)
       return 0;
     else if (li > ri)
@@ -28,16 +27,19 @@ public:
       return -1;
   }
 
+  static void int_sort(SortingRoutine sort_func, int *array, size_t array_len) {
+    sort_func(reinterpret_cast<void *>(array), array_len, sizeof(int),
+              int_compare);
+  }
+
+public:
   void test_sorted_array(SortingRoutine sort_func) {
     int array[25] = {10,   23,   33,   35,   55,   70,    71,   100,  110,
                      123,  133,  135,  155,  170,  171,   1100, 1110, 1123,
                      1133, 1135, 1155, 1170, 1171, 11100, 12310};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_LE(array[0], 10);
     ASSERT_LE(array[1], 23);
@@ -69,14 +71,11 @@ public:
   void test_reversed_sorted_array(SortingRoutine sort_func) {
     int array[] = {25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13,
                    12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    int_sort(sort_func, array, ARRAY_LEN);
 
-    sort_func(arr);
-
-    for (int i = 0; i < int(ARRAY_SIZE - 1); ++i)
+    for (int i = 0; i < int(ARRAY_LEN - 1); ++i)
       ASSERT_EQ(array[i], i + 1);
   }
 
@@ -84,14 +83,11 @@ public:
     int array[] = {100, 100, 100, 100, 100, 100, 100, 100, 100,
                    100, 100, 100, 100, 100, 100, 100, 100, 100,
                    100, 100, 100, 100, 100, 100, 100};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
-    for (size_t i = 0; i < ARRAY_SIZE; ++i)
+    for (size_t i = 0; i < ARRAY_LEN; ++i)
       ASSERT_EQ(array[i], 100);
   }
 
@@ -99,12 +95,9 @@ public:
     int array[25] = {10,  23,  8,    35,   55,   45,  40,  100, 110,
                      123, 90,  80,   70,   60,   171, 11,  1,   -1,
                      -5,  -10, 1155, 1170, 1171, 12,  -100};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], -100);
     ASSERT_EQ(array[1], -10);
@@ -135,12 +128,9 @@ public:
 
   void test_unsorted_array_2(SortingRoutine sort_func) {
     int array[7] = {10, 40, 45, 55, 35, 23, 60};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
-
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 10);
     ASSERT_EQ(array[1], 23);
@@ -153,12 +143,9 @@ public:
 
   void test_unsorted_array_duplicated_1(SortingRoutine sort_func) {
     int array[6] = {10, 10, 20, 20, 5, 5};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 5);
     ASSERT_EQ(array[1], 5);
@@ -170,12 +157,9 @@ public:
 
   void test_unsorted_array_duplicated_2(SortingRoutine sort_func) {
     int array[10] = {20, 10, 10, 10, 10, 20, 21, 21, 21, 21};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 10);
     ASSERT_EQ(array[1], 10);
@@ -191,12 +175,9 @@ public:
 
   void test_unsorted_array_duplicated_3(SortingRoutine sort_func) {
     int array[10] = {20, 30, 30, 30, 30, 20, 21, 21, 21, 21};
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
-
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 20);
     ASSERT_EQ(array[1], 20);
@@ -213,12 +194,9 @@ public:
   void test_unsorted_three_element_1(SortingRoutine sort_func) {
     int array[3] = {14999024, 0, 3};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 0);
     ASSERT_EQ(array[1], 3);
@@ -228,12 +206,9 @@ public:
   void test_unsorted_three_element_2(SortingRoutine sort_func) {
     int array[3] = {3, 14999024, 0};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 0);
     ASSERT_EQ(array[1], 3);
@@ -243,12 +218,9 @@ public:
   void test_unsorted_three_element_3(SortingRoutine sort_func) {
     int array[3] = {3, 0, 14999024};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
-
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 0);
     ASSERT_EQ(array[1], 3);
@@ -258,12 +230,9 @@ public:
   void test_same_three_element(SortingRoutine sort_func) {
     int array[3] = {12345, 12345, 12345};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 12345);
     ASSERT_EQ(array[1], 12345);
@@ -273,12 +242,9 @@ public:
   void test_unsorted_two_element_1(SortingRoutine sort_func) {
     int array[] = {14999024, 0};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 0);
     ASSERT_EQ(array[1], 14999024);
@@ -287,12 +253,9 @@ public:
   void test_unsorted_two_element_2(SortingRoutine sort_func) {
     int array[] = {0, 14999024};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
-
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 0);
     ASSERT_EQ(array[1], 14999024);
@@ -301,12 +264,9 @@ public:
   void test_same_two_element(SortingRoutine sort_func) {
     int array[] = {12345, 12345};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 12345);
     ASSERT_EQ(array[1], 12345);
@@ -315,15 +275,80 @@ public:
   void test_single_element(SortingRoutine sort_func) {
     int array[] = {12345};
 
-    constexpr size_t ARRAY_SIZE = sizeof(array) / sizeof(int);
-
-    auto arr = Array(reinterpret_cast<uint8_t *>(array), ARRAY_SIZE,
-                     sizeof(int), Comparator(int_compare));
+    constexpr size_t ARRAY_LEN = sizeof(array) / sizeof(int);
 
-    sort_func(arr);
+    int_sort(sort_func, array, ARRAY_LEN);
 
     ASSERT_EQ(array[0], 12345);
   }
+
+  void test_different_elem_size(SortingRoutine sort_func) {
+    // Random order of values [0,50) to avoid only testing pre-sorted handling.
+    // Long enough to reach interesting code.
+    constexpr uint8_t ARRAY_INITIAL_VALS[] = {
+        42, 13, 8,  4,  17, 28, 20, 32, 22, 29, 7,  2,  46, 37, 26, 49, 24,
+        38, 10, 18, 40, 36, 47, 15, 11, 48, 44, 33, 1,  5,  16, 35, 39, 41,
+        14, 23, 3,  9,  6,  27, 21, 25, 31, 45, 12, 43, 34, 30, 19, 0};
+
+    constexpr size_t ARRAY_LEN = sizeof(ARRAY_INITIAL_VALS);
+    constexpr size_t MAX_ELEM_SIZE = 150;
+    constexpr size_t BUF_SIZE = ARRAY_LEN * MAX_ELEM_SIZE;
+
+    static_assert(ARRAY_LEN < 256); // so we can encode the values.
+
+    // Minimum alignment to test implementation for bugs related to assuming
+    // incorrect association between alignment and element size. The buffer is
+    // 'static' as otherwise it will exhaust the stack on the GPU targets.
+    alignas(1) static uint8_t buf[BUF_SIZE];
+
+    // GCC still requires capturing the constant ARRAY_INITIAL_VALS in the
+    // lambda hence, let's use & to implicitly capture all needed variables
+    // automatically.
+    const auto fill_buf = [&](size_t elem_size) {
+      for (size_t i = 0; i < BUF_SIZE; ++i) {
+        buf[i] = 0;
+      }
+
+      for (size_t elem_i = 0, buf_i = 0; elem_i < ARRAY_LEN; ++elem_i) {
+        const uint8_t elem_val = ARRAY_INITIAL_VALS[elem_i];
+        for (size_t elem_byte_i = 0; elem_byte_i < elem_size; ++elem_byte_i) {
+          buf[buf_i] = elem_val;
+          buf_i += 1;
+        }
+      }
+    };
+
+    for (size_t elem_size = 0; elem_size <= MAX_ELEM_SIZE; ++elem_size) {
+      // Fill all bytes with data to ensure mistakes in elem swap are noticed.
+      fill_buf(elem_size);
+
+      sort_func(reinterpret_cast<void *>(buf), ARRAY_LEN, elem_size,
+                [](const void *a, const void *b) -> int {
+                  const uint8_t a_val = *reinterpret_cast<const uint8_t *>(a);
+                  const uint8_t b_val = *reinterpret_cast<const uint8_t *>(b);
+
+                  if (a_val < b_val) {
+                    return -1;
+                  } else if (a_val > b_val) {
+                    return 1;
+                  } else {
+                    return 0;
+                  }
+                });
+
+      for (size_t elem_i = 0, buf_i = 0; elem_i < ARRAY_LEN; ++elem_i) {
+        const uint8_t expected_elem_val = static_cast<uint8_t>(elem_i);
+
+        for (size_t elem_byte_i = 0; elem_byte_i < elem_size; ++elem_byte_i) {
+          const uint8_t buf_val = buf[buf_i];
+          // Check that every byte in the element has the expected value.
+          ASSERT_EQ(buf_val, expected_elem_val)
+              << "elem_size: " << elem_size << " buf_i: " << buf_i << '\n';
+          buf_i += 1;
+        }
+      }
+    }
+  }
 };
 
 #define LIST_SORTING_TESTS(Name, Func)                                         \
@@ -374,4 +399,7 @@ public:
   TEST_F(LlvmLibc##Name##Test, SingleElementArray) {                           \
     test_single_element(Func);                                                 \
   }                                                                            \
+  TEST_F(LlvmLibc##Name##Test, DifferentElemSizeArray) {                       \
+    test_different_elem_size(Func);                                            \
+  }                                                                            \
   static_assert(true)
diff --git a/test/src/stdlib/StrfromTest.h b/test/src/stdlib/StrfromTest.h
index 5209472..197165c 100644
--- a/test/src/stdlib/StrfromTest.h
+++ b/test/src/stdlib/StrfromTest.h
@@ -17,45 +17,45 @@
 template <typename InputT>
 class StrfromTest : public LIBC_NAMESPACE::testing::Test {
 
-  static const bool is_single_prec =
+  static constexpr bool is_single_prec =
       LIBC_NAMESPACE::cpp::is_same<InputT, float>::value;
-  static const bool is_double_prec =
+  static constexpr bool is_double_prec =
       LIBC_NAMESPACE::cpp::is_same<InputT, double>::value;
 
   using FunctionT = int (*)(char *, size_t, const char *, InputT fp);
 
 public:
   void floatDecimalFormat(FunctionT func) {
-    if (is_single_prec)
+    if constexpr (is_single_prec)
       floatDecimalSinglePrec(func);
-    else if (is_double_prec)
+    else if constexpr (is_double_prec)
       floatDecimalDoublePrec(func);
     else
       floatDecimalLongDoublePrec(func);
   }
 
   void floatHexExpFormat(FunctionT func) {
-    if (is_single_prec)
+    if constexpr (is_single_prec)
       floatHexExpSinglePrec(func);
-    else if (is_double_prec)
+    else if constexpr (is_double_prec)
       floatHexExpDoublePrec(func);
     else
       floatHexExpLongDoublePrec(func);
   }
 
   void floatDecimalExpFormat(FunctionT func) {
-    if (is_single_prec)
+    if constexpr (is_single_prec)
       floatDecimalExpSinglePrec(func);
-    else if (is_double_prec)
+    else if constexpr (is_double_prec)
       floatDecimalExpDoublePrec(func);
     else
       floatDecimalExpLongDoublePrec(func);
   }
 
   void floatDecimalAutoFormat(FunctionT func) {
-    if (is_single_prec)
+    if constexpr (is_single_prec)
       floatDecimalAutoSinglePrec(func);
-    else if (is_double_prec)
+    else if constexpr (is_double_prec)
       floatDecimalAutoDoublePrec(func);
     else
       floatDecimalAutoLongDoublePrec(func);
@@ -95,7 +95,7 @@ public:
     written = func(buff, 36, "A simple string with one conversion", 1.0);
     ASSERT_STREQ_LEN(written, buff, "A simple string with one conversion");
 
-    written = func(buff, 20, "%1f", 1234567890.0);
+    written = func(buff, 20, "%1f", static_cast<InputT>(1234567890.0));
     ASSERT_STREQ_LEN(written, buff, "%1f");
   }
 
@@ -103,23 +103,23 @@ public:
     char buff[20];
     int written;
 
-    written = func(buff, 5, "%f", 1234567890.0);
+    written = func(buff, 5, "%f", static_cast<InputT>(1234567890.0));
     EXPECT_EQ(written, 17);
     ASSERT_STREQ(buff, "1234");
 
-    written = func(buff, 5, "%.5f", 1.05);
+    written = func(buff, 5, "%.5f", static_cast<InputT>(1.05));
     EXPECT_EQ(written, 7);
     ASSERT_STREQ(buff, "1.05");
 
-    written = func(buff, 0, "%g", 1.0);
+    written = func(buff, 0, "%g", static_cast<InputT>(1.0));
     EXPECT_EQ(written, 1);
     ASSERT_STREQ(buff, "1.05"); // Make sure that buff has not changed
   }
 
   void infNanValues(FunctionT func) {
-    if (is_double_prec)
+    if constexpr (is_double_prec)
       doublePrecInfNan(func);
-    else if (!is_single_prec)
+    else if constexpr (!is_single_prec)
       longDoublePrecInfNan(func);
   }
 
@@ -127,13 +127,13 @@ public:
     char buff[70];
     int written;
 
-    written = func(buff, 16, "%f", 1.0);
+    written = func(buff, 16, "%f", 1.0f);
     ASSERT_STREQ_LEN(written, buff, "1.000000");
 
-    written = func(buff, 20, "%f", 1234567890.0);
+    written = func(buff, 20, "%f", 1234567890.0f);
     ASSERT_STREQ_LEN(written, buff, "1234567936.000000");
 
-    written = func(buff, 67, "%.3f", 1.0);
+    written = func(buff, 67, "%.3f", 1.0f);
     ASSERT_STREQ_LEN(written, buff, "1.000");
   }
 
@@ -222,14 +222,14 @@ public:
     char buff[25];
     int written;
 
-    written = func(buff, 0, "%a", 1234567890.0);
+    written = func(buff, 0, "%a", 1234567890.0f);
     EXPECT_EQ(written, 14);
 
-    written = func(buff, 20, "%a", 1234567890.0);
+    written = func(buff, 20, "%a", 1234567890.0f);
     EXPECT_EQ(written, 14);
     ASSERT_STREQ(buff, "0x1.26580cp+30");
 
-    written = func(buff, 20, "%A", 1234567890.0);
+    written = func(buff, 20, "%A", 1234567890.0f);
     EXPECT_EQ(written, 14);
     ASSERT_STREQ(buff, "0X1.26580CP+30");
   }
@@ -314,10 +314,10 @@ public:
     char buff[25];
     int written;
 
-    written = func(buff, 20, "%.9e", 1234567890.0);
+    written = func(buff, 20, "%.9e", 1234567890.0f);
     ASSERT_STREQ_LEN(written, buff, "1.234567936e+09");
 
-    written = func(buff, 20, "%.9E", 1234567890.0);
+    written = func(buff, 20, "%.9E", 1234567890.0f);
     ASSERT_STREQ_LEN(written, buff, "1.234567936E+09");
   }
 
@@ -379,10 +379,10 @@ public:
     char buff[25];
     int written;
 
-    written = func(buff, 20, "%.9g", 1234567890.0);
+    written = func(buff, 20, "%.9g", 1234567890.0f);
     ASSERT_STREQ_LEN(written, buff, "1.23456794e+09");
 
-    written = func(buff, 20, "%.9G", 1234567890.0);
+    written = func(buff, 20, "%.9G", 1234567890.0f);
     ASSERT_STREQ_LEN(written, buff, "1.23456794E+09");
   }
 
diff --git a/test/src/stdlib/StrtolTest.h b/test/src/stdlib/StrtolTest.h
index 8a67848..ed302f1 100644
--- a/test/src/stdlib/StrtolTest.h
+++ b/test/src/stdlib/StrtolTest.h
@@ -8,6 +8,7 @@
 
 #include "src/__support/CPP/limits.h"
 #include "src/__support/CPP/type_traits.h"
+#include "src/__support/ctype_utils.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/errno/libc_errno.h"
 #include "test/UnitTest/Test.h"
@@ -16,14 +17,6 @@
 
 using LIBC_NAMESPACE::cpp::is_signed_v;
 
-static inline char int_to_b36_char(int input) {
-  if (input < 0 || input > 36)
-    return '0';
-  if (input < 10)
-    return static_cast<char>('0' + input);
-  return static_cast<char>('A' + input - 10);
-}
-
 template <typename ReturnT>
 struct StrtoTest : public LIBC_NAMESPACE::testing::Test {
   using FunctionT = ReturnT (*)(const char *, char **, int);
@@ -207,7 +200,8 @@ struct StrtoTest : public LIBC_NAMESPACE::testing::Test {
     char small_string[4] = {'\0', '\0', '\0', '\0'};
     for (int base = 2; base <= 36; ++base) {
       for (int first_digit = 0; first_digit <= 36; ++first_digit) {
-        small_string[0] = int_to_b36_char(first_digit);
+        small_string[0] = static_cast<char>(
+            LIBC_NAMESPACE::internal::int_to_b36_char(first_digit));
         if (first_digit < base) {
           LIBC_NAMESPACE::libc_errno = 0;
           ASSERT_EQ(func(small_string, nullptr, base),
@@ -223,9 +217,11 @@ struct StrtoTest : public LIBC_NAMESPACE::testing::Test {
 
     for (int base = 2; base <= 36; ++base) {
       for (int first_digit = 0; first_digit <= 36; ++first_digit) {
-        small_string[0] = int_to_b36_char(first_digit);
+        small_string[0] = static_cast<char>(
+            LIBC_NAMESPACE::internal::int_to_b36_char(first_digit));
         for (int second_digit = 0; second_digit <= 36; ++second_digit) {
-          small_string[1] = int_to_b36_char(second_digit);
+          small_string[1] = static_cast<char>(
+              LIBC_NAMESPACE::internal::int_to_b36_char(second_digit));
           if (first_digit < base && second_digit < base) {
             LIBC_NAMESPACE::libc_errno = 0;
             ASSERT_EQ(
@@ -248,11 +244,14 @@ struct StrtoTest : public LIBC_NAMESPACE::testing::Test {
 
     for (int base = 2; base <= 36; ++base) {
       for (int first_digit = 0; first_digit <= 36; ++first_digit) {
-        small_string[0] = int_to_b36_char(first_digit);
+        small_string[0] = static_cast<char>(
+            LIBC_NAMESPACE::internal::int_to_b36_char(first_digit));
         for (int second_digit = 0; second_digit <= 36; ++second_digit) {
-          small_string[1] = int_to_b36_char(second_digit);
+          small_string[1] = static_cast<char>(
+              LIBC_NAMESPACE::internal::int_to_b36_char(second_digit));
           for (int third_digit = 0; third_digit <= limit; ++third_digit) {
-            small_string[2] = int_to_b36_char(third_digit);
+            small_string[2] = static_cast<char>(
+                LIBC_NAMESPACE::internal::int_to_b36_char(third_digit));
 
             if (first_digit < base && second_digit < base &&
                 third_digit < base) {
diff --git a/test/src/stdlib/a64l_test.cpp b/test/src/stdlib/a64l_test.cpp
new file mode 100644
index 0000000..acdef5d
--- /dev/null
+++ b/test/src/stdlib/a64l_test.cpp
@@ -0,0 +1,87 @@
+//===-- Unittests for a64l ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/stdlib/a64l.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcA64lTest, EmptyString) { ASSERT_EQ(LIBC_NAMESPACE::a64l(""), 0l); }
+TEST(LlvmLibcA64lTest, FullString) {
+  ASSERT_EQ(LIBC_NAMESPACE::a64l("AbC12/"), 1141696972l);
+}
+
+constexpr char B64_CHARS[64] = {
+    '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
+    'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a',
+    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
+    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+};
+
+TEST(LlvmLibcA64lTest, OneCharacter) {
+  char example_str[2] = {'\0', '\0'};
+
+  for (size_t i = 0; i < 64; ++i) {
+    example_str[0] = B64_CHARS[i];
+    ASSERT_EQ(LIBC_NAMESPACE::a64l(example_str), static_cast<long>(i));
+  }
+}
+
+TEST(LlvmLibcA64lTest, TwoCharacters) {
+  char example_str[3] = {'\0', '\0', '\0'};
+
+  for (size_t first = 0; first < 64; ++first) {
+    example_str[0] = B64_CHARS[first];
+    for (size_t second = 0; second < 64; ++second) {
+      example_str[1] = B64_CHARS[second];
+
+      ASSERT_EQ(LIBC_NAMESPACE::a64l(example_str),
+                static_cast<long>(first + (second * 64)));
+    }
+  }
+}
+
+TEST(LlvmLibcA64lTest, FiveSameCharacters) {
+  // Technically the last digit can be parsed to give the last two bits. Not
+  // handling that here.
+  char example_str[6] = {
+      '\0', '\0', '\0', '\0', '\0', '\0',
+  };
+
+  // set every 6th bit
+  const long BASE_NUM = 0b1000001000001000001000001;
+
+  for (size_t char_val = 0; char_val < 64; ++char_val) {
+    for (size_t i = 0; i < 5; ++i)
+      example_str[i] = B64_CHARS[char_val];
+
+    const long expected_result = BASE_NUM * char_val;
+
+    ASSERT_EQ(LIBC_NAMESPACE::a64l(example_str), expected_result);
+  }
+}
+
+TEST(LlvmLibcA64lTest, OneOfSixCharacters) {
+  char example_str[7] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0'};
+
+  for (size_t cur_char = 0; cur_char < 6; ++cur_char) {
+    // clear the string, set all the chars to b64(0)
+    for (size_t i = 0; i < 6; ++i)
+      example_str[i] = B64_CHARS[0];
+
+    for (size_t char_val = 0; char_val < 64; ++char_val) {
+      example_str[cur_char] = B64_CHARS[char_val];
+
+      // Need to limit to 32 bits, since that's what the standard says the
+      // function does.
+      const long expected_result =
+          static_cast<int32_t>(char_val << (6 * cur_char));
+
+      ASSERT_EQ(LIBC_NAMESPACE::a64l(example_str), expected_result);
+    }
+  }
+}
diff --git a/test/src/stdlib/heap_sort_test.cpp b/test/src/stdlib/heap_sort_test.cpp
index d70e3dc..18d4244 100644
--- a/test/src/stdlib/heap_sort_test.cpp
+++ b/test/src/stdlib/heap_sort_test.cpp
@@ -7,10 +7,20 @@
 //===----------------------------------------------------------------------===//
 
 #include "SortingTest.h"
-#include "src/stdlib/heap_sort.h"
+#include "src/stdlib/qsort_util.h"
 
-void sort(const LIBC_NAMESPACE::internal::Array &array) {
-  LIBC_NAMESPACE::internal::heap_sort(array);
+void heap_sort(void *array, size_t array_size, size_t elem_size,
+               int (*compare)(const void *, const void *)) {
+
+  constexpr bool USE_QUICKSORT = false;
+
+  const auto is_less = [compare](const void *a,
+                                 const void *b) noexcept -> bool {
+    return compare(a, b) < 0;
+  };
+
+  LIBC_NAMESPACE::internal::unstable_sort_impl<USE_QUICKSORT>(
+      array, array_size, elem_size, is_less);
 }
 
-LIST_SORTING_TESTS(HeapSort, sort);
+LIST_SORTING_TESTS(HeapSort, heap_sort);
diff --git a/test/src/stdlib/l64a_test.cpp b/test/src/stdlib/l64a_test.cpp
new file mode 100644
index 0000000..a58ded1
--- /dev/null
+++ b/test/src/stdlib/l64a_test.cpp
@@ -0,0 +1,94 @@
+//===-- Unittests for l64a ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/__support/CPP/limits.h"
+#include "src/stdlib/l64a.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcL64aTest, Zero) {
+  ASSERT_STREQ(LIBC_NAMESPACE::l64a(0), "......");
+}
+TEST(LlvmLibcL64aTest, Max) {
+  ASSERT_STREQ(LIBC_NAMESPACE::l64a(
+                   LIBC_NAMESPACE::cpp::numeric_limits<uint32_t>::max()),
+               "zzzzz1");
+}
+
+constexpr char B64_CHARS[64] = {
+    '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
+    'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a',
+    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
+    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+};
+
+TEST(LlvmLibcL64aTest, OneCharacter) {
+  // The trailing null is technically unnecessary, but it means it won't look
+  // bad when we print it.
+  char expected_str[7] = {'\0', '.', '.', '.', '.', '.', '\0'};
+
+  for (size_t i = 0; i < 64; ++i) {
+    expected_str[0] = B64_CHARS[i];
+    ASSERT_STREQ(LIBC_NAMESPACE::l64a(i), expected_str);
+  }
+}
+
+TEST(LlvmLibcL64aTest, TwoCharacters) {
+  char expected_str[7] = {'\0', '\0', '.', '.', '.', '.', '\0'};
+
+  for (size_t first = 0; first < 64; ++first) {
+    expected_str[0] = B64_CHARS[first];
+    for (size_t second = 0; second < 64; ++second) {
+      expected_str[1] = B64_CHARS[second];
+
+      ASSERT_STREQ(LIBC_NAMESPACE::l64a(first + (second * 64)), expected_str);
+    }
+  }
+}
+
+TEST(LlvmLibcL64aTest, FiveSameCharacters) {
+  // Only using 5 because those are the only digits that can be any character.
+  char expected_str[7] = {'\0', '\0', '\0', '\0', '\0', '.', '\0'};
+
+  // set every 6th bit
+  const long BASE_NUM = 0b1000001000001000001000001;
+
+  for (size_t char_val = 0; char_val < 64; ++char_val) {
+    for (size_t i = 0; i < 5; ++i)
+      expected_str[i] = B64_CHARS[char_val];
+
+    const long input_num = BASE_NUM * char_val;
+
+    ASSERT_STREQ(LIBC_NAMESPACE::l64a(input_num), expected_str);
+  }
+}
+
+TEST(LlvmLibcL64aTest, OneOfSixCharacters) {
+  char expected_str[7] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0'};
+
+  for (size_t cur_char = 0; cur_char < 6; ++cur_char) {
+    // clear the string, set all the chars to b64(0)
+    for (size_t i = 0; i < 6; ++i)
+      expected_str[i] = B64_CHARS[0];
+
+    for (size_t char_val = 0; char_val < 64; ++char_val) {
+      // Since each base64 character holds 6 bits and we're only using 32 bits
+      // of input, the 6th character only gets 2 bits, so it can never be
+      // greater than 3.
+      if (char_val > 3 && cur_char == 5)
+        break;
+      expected_str[cur_char] = B64_CHARS[char_val];
+
+      // Need to limit to 32 bits, since that's what the standard says the
+      // function does.
+      const long input_num = static_cast<int32_t>(char_val << (6 * cur_char));
+
+      ASSERT_STREQ(LIBC_NAMESPACE::l64a(input_num), expected_str);
+    }
+  }
+}
diff --git a/test/src/stdlib/qsort_r_test.cpp b/test/src/stdlib/qsort_r_test.cpp
index 6893fdc..f189236 100644
--- a/test/src/stdlib/qsort_r_test.cpp
+++ b/test/src/stdlib/qsort_r_test.cpp
@@ -62,9 +62,9 @@ TEST(LlvmLibcQsortRTest, SortedArray) {
   ASSERT_LE(array[23], 11100);
   ASSERT_LE(array[24], 12310);
 
-  // This is a sorted list, but there still have to have been at least N
+  // This is a sorted list, but there still have to have been at least N - 1
   // comparisons made.
-  ASSERT_GE(count, ARRAY_SIZE);
+  ASSERT_GE(count, ARRAY_SIZE - 1);
 }
 
 TEST(LlvmLibcQsortRTest, ReverseSortedArray) {
diff --git a/test/src/stdlib/qsort_test.cpp b/test/src/stdlib/qsort_test.cpp
deleted file mode 100644
index 1e921a8..0000000
--- a/test/src/stdlib/qsort_test.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-//===-- Unittests for qsort -----------------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "SortingTest.h"
-#include "src/stdlib/qsort.h"
-
-void sort(const LIBC_NAMESPACE::internal::Array &array) {
-  LIBC_NAMESPACE::qsort(reinterpret_cast<void *>(array.get(0)), array.size(),
-                        sizeof(int), SortingTest::int_compare);
-}
-
-LIST_SORTING_TESTS(Qsort, sort);
diff --git a/test/src/stdlib/quick_sort_test.cpp b/test/src/stdlib/quick_sort_test.cpp
index d6bf77e..2832c85 100644
--- a/test/src/stdlib/quick_sort_test.cpp
+++ b/test/src/stdlib/quick_sort_test.cpp
@@ -1,4 +1,4 @@
-//===-- Unittests for quick sort ------------------------------------------===//
+//===-- Unittests for qsort -----------------------------------------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -7,10 +7,19 @@
 //===----------------------------------------------------------------------===//
 
 #include "SortingTest.h"
-#include "src/stdlib/quick_sort.h"
+#include "src/stdlib/qsort_util.h"
 
-void sort(const LIBC_NAMESPACE::internal::Array &array) {
-  LIBC_NAMESPACE::internal::quick_sort(array);
+void quick_sort(void *array, size_t array_size, size_t elem_size,
+                int (*compare)(const void *, const void *)) {
+  constexpr bool USE_QUICKSORT = true;
+
+  const auto is_less = [compare](const void *a,
+                                 const void *b) noexcept -> bool {
+    return compare(a, b) < 0;
+  };
+
+  LIBC_NAMESPACE::internal::unstable_sort_impl<USE_QUICKSORT>(
+      array, array_size, elem_size, is_less);
 }
 
-LIST_SORTING_TESTS(QuickSort, sort);
+LIST_SORTING_TESTS(Qsort, quick_sort);
diff --git a/test/src/string/memcpy_test.cpp b/test/src/string/memcpy_test.cpp
index adf6ef7..ce267d1 100644
--- a/test/src/string/memcpy_test.cpp
+++ b/test/src/string/memcpy_test.cpp
@@ -48,7 +48,7 @@ TEST(LlvmLibcMemcpyTest, CheckAccess) {
     auto page = pages.GetPageB().WithAccess(PROT_WRITE);
     // And fill it with random numbers.
     for (size_t i = 0; i < page.page_size; ++i)
-      page.page_ptr[i] = rand();
+      page.page_ptr[i] = static_cast<uint8_t>(rand());
     // Then return it in read mode.
     return page.WithAccess(PROT_READ);
   }();
diff --git a/test/src/string/memmove_test.cpp b/test/src/string/memmove_test.cpp
index e280b5d..1e225e5 100644
--- a/test/src/string/memmove_test.cpp
+++ b/test/src/string/memmove_test.cpp
@@ -93,7 +93,8 @@ TEST(LlvmLibcMemmoveTest, SizeSweep) {
   Randomize(Buffer);
   for (int Size = 0; Size < kMaxSize; ++Size)
     for (int Overlap = -1; Overlap < Size;) {
-      ASSERT_TRUE(CheckMemmove<Adaptor>(Buffer, Size, Overlap));
+      ASSERT_TRUE(
+          CheckMemmove<Adaptor>(Buffer, static_cast<size_t>(Size), Overlap));
       // Prevent quadratic behavior by skipping offset above kDenseOverlap.
       if (Overlap > kDenseOverlap)
         Overlap *= 2;
diff --git a/test/src/string/memory_utils/memory_check_utils.h b/test/src/string/memory_utils/memory_check_utils.h
index 3ddd15b..db9cfda 100644
--- a/test/src/string/memory_utils/memory_check_utils.h
+++ b/test/src/string/memory_utils/memory_check_utils.h
@@ -157,7 +157,7 @@ inline uint16_t Checksum(cpp::span<char> dst) {
   uint16_t sum1 = 0;
   uint16_t sum2 = 0;
   for (char c : dst) {
-    sum1 = (sum1 + c) % 255U;
+    sum1 = (sum1 + static_cast<uint16_t>(c)) % 255U;
     sum2 = (sum2 + sum1) % 255U;
   }
   return static_cast<uint16_t>((sum2 << 8) | sum1);
@@ -185,8 +185,10 @@ template <auto FnImpl>
 inline bool CheckMemmove(cpp::span<char> buffer, size_t size, int overlap) {
   LIBC_ASSERT(buffer.size() > (2 * size + 1));
   const size_t half_size = buffer.size() / 2;
-  LIBC_ASSERT((size_t)(overlap >= 0 ? overlap : -overlap) < half_size);
-  cpp::span<char> head = buffer.first(half_size + overlap).last(size);
+  LIBC_ASSERT(static_cast<size_t>(overlap >= 0 ? overlap : -overlap) <
+              half_size);
+  cpp::span<char> head =
+      buffer.first(half_size + static_cast<size_t>(overlap)).last(size);
   cpp::span<char> tail = buffer.last(half_size).first(size);
   LIBC_ASSERT(head.size() == size);
   LIBC_ASSERT(tail.size() == size);
diff --git a/test/src/string/memory_utils/op_tests.cpp b/test/src/string/memory_utils/op_tests.cpp
index c6197d1..2057ab3 100644
--- a/test/src/string/memory_utils/op_tests.cpp
+++ b/test/src/string/memory_utils/op_tests.cpp
@@ -174,7 +174,7 @@ TYPED_TEST(LlvmLibcOpTest, Memset, MemsetImplementations) {
     static constexpr auto HeadTailImpl = SetAdaptor<Impl::head_tail>;
     Buffer DstBuffer(2 * kSize);
     for (size_t size = kSize; size < 2 * kSize; ++size) {
-      const char value = size % 10;
+      const uint8_t value = size % 10;
       auto dst = DstBuffer.span().subspan(0, size);
       ASSERT_TRUE(CheckMemset<HeadTailImpl>(dst, value, size));
     }
@@ -185,7 +185,7 @@ TYPED_TEST(LlvmLibcOpTest, Memset, MemsetImplementations) {
       static constexpr auto LoopImpl = SetAdaptor<Impl::loop_and_tail>;
       Buffer DstBuffer(3 * kSize);
       for (size_t size = kSize; size < 3 * kSize; ++size) {
-        const char value = size % 10;
+        const uint8_t value = size % 10;
         auto dst = DstBuffer.span().subspan(0, size);
         ASSERT_TRUE((CheckMemset<LoopImpl>(dst, value, size)));
       }
diff --git a/test/src/string/memory_utils/utils_test.cpp b/test/src/string/memory_utils/utils_test.cpp
index 4c1accd..4dff068 100644
--- a/test/src/string/memory_utils/utils_test.cpp
+++ b/test/src/string/memory_utils/utils_test.cpp
@@ -47,11 +47,11 @@ TEST(LlvmLibcUtilsTest, DistanceToAlignDown) {
 TEST(LlvmLibcUtilsTest, Adjust2) {
   char a, b;
   const size_t base_size = 10;
-  for (ptrdiff_t I = -2; I < 2; ++I) {
+  for (uintptr_t I = 0; I < 4; ++I) {
     auto *p1 = &a;
     auto *p2 = &b;
     size_t size = base_size;
-    adjust(I, p1, p2, size);
+    adjust(static_cast<ptrdiff_t>(I), p1, p2, size);
     EXPECT_EQ(intptr_t(p1), intptr_t(&a + I));
     EXPECT_EQ(intptr_t(p2), intptr_t(&b + I));
     EXPECT_EQ(size, base_size - I);
diff --git a/test/src/string/memset_test.cpp b/test/src/string/memset_test.cpp
index 774a321..46d6ce7 100644
--- a/test/src/string/memset_test.cpp
+++ b/test/src/string/memset_test.cpp
@@ -27,7 +27,7 @@ TEST(LlvmLibcMemsetTest, SizeSweep) {
   static constexpr size_t kMaxSize = 400;
   Buffer DstBuffer(kMaxSize);
   for (size_t size = 0; size < kMaxSize; ++size) {
-    const char value = size % 10;
+    const uint8_t value = size % 10;
     auto dst = DstBuffer.span().subspan(0, size);
     ASSERT_TRUE((CheckMemset<Adaptor>(dst, value, size)));
   }
diff --git a/test/src/string/strcmp_test.cpp b/test/src/string/strcmp_test.cpp
index ef58dc6..2344476 100644
--- a/test/src/string/strcmp_test.cpp
+++ b/test/src/string/strcmp_test.cpp
@@ -25,13 +25,13 @@ TEST(LlvmLibcStrCmpTest, EmptyStringShouldNotEqualNonEmptyString) {
   const char *s2 = "abc";
   int result = LIBC_NAMESPACE::strcmp(empty, s2);
   // This should be '\0' - 'a' = -97
-  ASSERT_EQ(result, -97);
+  ASSERT_EQ(result, '\0' - 'a');
 
   // Similar case if empty string is second argument.
   const char *s3 = "123";
   result = LIBC_NAMESPACE::strcmp(s3, empty);
   // This should be '1' - '\0' = 49
-  ASSERT_EQ(result, 49);
+  ASSERT_EQ(result, '1' - '\0');
 }
 
 TEST(LlvmLibcStrCmpTest, EqualStringsShouldReturnZero) {
@@ -50,12 +50,12 @@ TEST(LlvmLibcStrCmpTest, ShouldReturnResultOfFirstDifference) {
   const char *s2 = "___C55__";
   int result = LIBC_NAMESPACE::strcmp(s1, s2);
   // This should return 'B' - 'C' = -1.
-  ASSERT_EQ(result, -1);
+  ASSERT_EQ(result, 'B' - 'C');
 
   // Verify operands reversed.
   result = LIBC_NAMESPACE::strcmp(s2, s1);
   // This should return 'C' - 'B' = 1.
-  ASSERT_EQ(result, 1);
+  ASSERT_EQ(result, 'C' - 'B');
 }
 
 TEST(LlvmLibcStrCmpTest, CapitalizedLetterShouldNotBeEqual) {
@@ -63,12 +63,12 @@ TEST(LlvmLibcStrCmpTest, CapitalizedLetterShouldNotBeEqual) {
   const char *s2 = "abCd";
   int result = LIBC_NAMESPACE::strcmp(s1, s2);
   // 'c' - 'C' = 32.
-  ASSERT_EQ(result, 32);
+  ASSERT_EQ(result, 'c' - 'C');
 
   // Verify operands reversed.
   result = LIBC_NAMESPACE::strcmp(s2, s1);
   // 'C' - 'c' = -32.
-  ASSERT_EQ(result, -32);
+  ASSERT_EQ(result, 'C' - 'c');
 }
 
 TEST(LlvmLibcStrCmpTest, UnequalLengthStringsShouldNotReturnZero) {
@@ -76,12 +76,12 @@ TEST(LlvmLibcStrCmpTest, UnequalLengthStringsShouldNotReturnZero) {
   const char *s2 = "abcd";
   int result = LIBC_NAMESPACE::strcmp(s1, s2);
   // '\0' - 'd' = -100.
-  ASSERT_EQ(result, -100);
+  ASSERT_EQ(result, -'\0' - 'd');
 
   // Verify operands reversed.
   result = LIBC_NAMESPACE::strcmp(s2, s1);
   // 'd' - '\0' = 100.
-  ASSERT_EQ(result, 100);
+  ASSERT_EQ(result, 'd' - '\0');
 }
 
 TEST(LlvmLibcStrCmpTest, StringArgumentSwapChangesSign) {
@@ -89,11 +89,11 @@ TEST(LlvmLibcStrCmpTest, StringArgumentSwapChangesSign) {
   const char *b = "b";
   int result = LIBC_NAMESPACE::strcmp(b, a);
   // 'b' - 'a' = 1.
-  ASSERT_EQ(result, 1);
+  ASSERT_EQ(result, 'b' - 'a');
 
   result = LIBC_NAMESPACE::strcmp(a, b);
   // 'a' - 'b' = -1.
-  ASSERT_EQ(result, -1);
+  ASSERT_EQ(result, 'a' - 'b');
 }
 
 TEST(LlvmLibcStrCmpTest, Case) {
diff --git a/test/src/string/bcmp_test.cpp b/test/src/strings/bcmp_test.cpp
similarity index 95%
rename from test/src/string/bcmp_test.cpp
rename to test/src/strings/bcmp_test.cpp
index c639040..794f9a1 100644
--- a/test/src/string/bcmp_test.cpp
+++ b/test/src/strings/bcmp_test.cpp
@@ -6,11 +6,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "memory_utils/memory_check_utils.h"
 #include "src/__support/macros/config.h"
-#include "src/string/bcmp.h"
+#include "src/strings/bcmp.h"
 #include "test/UnitTest/Test.h"
 #include "test/UnitTest/TestLogger.h"
+#include "test/src/string/memory_utils/memory_check_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/test/src/string/bcopy_test.cpp b/test/src/strings/bcopy_test.cpp
similarity index 94%
rename from test/src/string/bcopy_test.cpp
rename to test/src/strings/bcopy_test.cpp
index 04772bb..6daa634 100644
--- a/test/src/string/bcopy_test.cpp
+++ b/test/src/strings/bcopy_test.cpp
@@ -6,13 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/__support/macros/config.h"
-#include "src/string/bcopy.h"
+#include "src/strings/bcopy.h"
 
-#include "memory_utils/memory_check_utils.h"
 #include "src/__support/CPP/span.h"
+#include "src/__support/macros/config.h"
 #include "test/UnitTest/MemoryMatcher.h"
 #include "test/UnitTest/Test.h"
+#include "test/src/string/memory_utils/memory_check_utils.h"
 
 using LIBC_NAMESPACE::cpp::array;
 using LIBC_NAMESPACE::cpp::span;
@@ -87,7 +87,8 @@ TEST(LlvmLibcBcopyTest, SizeSweep) {
   Randomize(Buffer);
   for (int Size = 0; Size < kMaxSize; ++Size)
     for (int Overlap = -1; Overlap < Size;) {
-      ASSERT_TRUE(CheckMemmove<Adaptor>(Buffer, Size, Overlap));
+      ASSERT_TRUE(
+          CheckMemmove<Adaptor>(Buffer, static_cast<size_t>(Size), Overlap));
       // Prevent quadratic behavior by skipping offset above kDenseOverlap.
       if (Overlap > kDenseOverlap)
         Overlap *= 2;
diff --git a/test/src/string/bzero_test.cpp b/test/src/strings/bzero_test.cpp
similarity index 91%
rename from test/src/string/bzero_test.cpp
rename to test/src/strings/bzero_test.cpp
index a240436..4d4112f 100644
--- a/test/src/string/bzero_test.cpp
+++ b/test/src/strings/bzero_test.cpp
@@ -6,10 +6,10 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "memory_utils/memory_check_utils.h"
 #include "src/__support/macros/config.h"
-#include "src/string/bzero.h"
+#include "src/strings/bzero.h"
 #include "test/UnitTest/Test.h"
+#include "test/src/string/memory_utils/memory_check_utils.h"
 
 namespace LIBC_NAMESPACE_DECL {
 
diff --git a/test/src/strings/ffs_test.cpp b/test/src/strings/ffs_test.cpp
new file mode 100644
index 0000000..17cd412
--- /dev/null
+++ b/test/src/strings/ffs_test.cpp
@@ -0,0 +1,32 @@
+//===-- Unittests for ffs -------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffs.h"
+
+#include "src/__support/macros/config.h"
+#include "test/UnitTest/Test.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+TEST(LlvmLibcFfsTest, SimpleFfs) {
+  ASSERT_EQ(ffs(0x00000000), 0);
+  ASSERT_EQ(ffs(0x00000001), 1);
+  ASSERT_EQ(ffs(0x00000020), 6);
+  ASSERT_EQ(ffs(0x00000400), 11);
+  ASSERT_EQ(ffs(0x00008000), 16);
+  ASSERT_EQ(ffs(0x00010000), 17);
+  ASSERT_EQ(ffs(0x00200000), 22);
+  ASSERT_EQ(ffs(0x04000000), 27);
+  ASSERT_EQ(ffs(0x80000000), 32);
+  ASSERT_EQ(ffs(0xfbe71), 1);
+  ASSERT_EQ(ffs(0xfbe70), 5);
+  ASSERT_EQ(ffs(0x10), 5);
+  ASSERT_EQ(ffs(0x100), 9);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/strings/ffsl_test.cpp b/test/src/strings/ffsl_test.cpp
new file mode 100644
index 0000000..cf5c32f
--- /dev/null
+++ b/test/src/strings/ffsl_test.cpp
@@ -0,0 +1,42 @@
+//===-- Unittests for ffsl ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffsl.h"
+
+#include "src/__support/macros/config.h"
+#include "test/UnitTest/Test.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+TEST(LlvmLibcFfslTest, SimpleFfsl) {
+  ASSERT_EQ(ffsl(0x00000000L), 0);
+  ASSERT_EQ(ffsl(0x00000001L), 1);
+  ASSERT_EQ(ffsl(0x00000020L), 6);
+  ASSERT_EQ(ffsl(0x00000400L), 11);
+  ASSERT_EQ(ffsl(0x00008000L), 16);
+  ASSERT_EQ(ffsl(0x00010000L), 17);
+  ASSERT_EQ(ffsl(0x00200000L), 22);
+  ASSERT_EQ(ffsl(0x04000000L), 27);
+  ASSERT_EQ(ffsl(0x80000000L), 32);
+#ifdef __LP64__
+  ASSERT_EQ(ffsl(0x0000000100000000L), 33);
+  ASSERT_EQ(ffsl(0x0000002000000000L), 38);
+  ASSERT_EQ(ffsl(0x0000040000000000L), 43);
+  ASSERT_EQ(ffsl(0x0000800000000000L), 48);
+  ASSERT_EQ(ffsl(0x0001000000000000L), 49);
+  ASSERT_EQ(ffsl(0x0020000000000000L), 54);
+  ASSERT_EQ(ffsl(0x0400000000000000L), 59);
+  ASSERT_EQ(ffsl(0x8000000000000000L), 64);
+#endif
+  ASSERT_EQ(ffsl(0xfbe71L), 1);
+  ASSERT_EQ(ffsl(0xfbe70L), 5);
+  ASSERT_EQ(ffsl(0x10L), 5);
+  ASSERT_EQ(ffsl(0x100L), 9);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/strings/ffsll_test.cpp b/test/src/strings/ffsll_test.cpp
new file mode 100644
index 0000000..bdd7a2e
--- /dev/null
+++ b/test/src/strings/ffsll_test.cpp
@@ -0,0 +1,40 @@
+//===-- Unittests for ffsll -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/strings/ffsll.h"
+
+#include "src/__support/macros/config.h"
+#include "test/UnitTest/Test.h"
+
+namespace LIBC_NAMESPACE_DECL {
+
+TEST(LlvmLibcFfsllTest, SimpleFfsll) {
+  ASSERT_EQ(ffsll(0x0000000000000000LL), 0);
+  ASSERT_EQ(ffsll(0x0000000000000001LL), 1);
+  ASSERT_EQ(ffsll(0x0000000000000020LL), 6);
+  ASSERT_EQ(ffsll(0x0000000000000400LL), 11);
+  ASSERT_EQ(ffsll(0x0000000000008000LL), 16);
+  ASSERT_EQ(ffsll(0x0000000000010000LL), 17);
+  ASSERT_EQ(ffsll(0x0000000000200000LL), 22);
+  ASSERT_EQ(ffsll(0x0000000004000000LL), 27);
+  ASSERT_EQ(ffsll(0x0000000080000000LL), 32);
+  ASSERT_EQ(ffsll(0x0000000100000000LL), 33);
+  ASSERT_EQ(ffsll(0x0000002000000000LL), 38);
+  ASSERT_EQ(ffsll(0x0000040000000000LL), 43);
+  ASSERT_EQ(ffsll(0x0000800000000000LL), 48);
+  ASSERT_EQ(ffsll(0x0001000000000000LL), 49);
+  ASSERT_EQ(ffsll(0x0020000000000000LL), 54);
+  ASSERT_EQ(ffsll(0x0400000000000000LL), 59);
+  ASSERT_EQ(ffsll(0x8000000000000000LL), 64);
+  ASSERT_EQ(ffsll(0xfbe71LL), 1);
+  ASSERT_EQ(ffsll(0xfbe70LL), 5);
+  ASSERT_EQ(ffsll(0x10LL), 5);
+  ASSERT_EQ(ffsll(0x100LL), 9);
+}
+
+} // namespace LIBC_NAMESPACE_DECL
diff --git a/test/src/string/index_test.cpp b/test/src/strings/index_test.cpp
similarity index 86%
rename from test/src/string/index_test.cpp
rename to test/src/strings/index_test.cpp
index 8895320..fc4cd2b 100644
--- a/test/src/string/index_test.cpp
+++ b/test/src/strings/index_test.cpp
@@ -6,9 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "StrchrTest.h"
+#include "test/src/string/StrchrTest.h"
 
-#include "src/string/index.h"
+#include "src/strings/index.h"
 #include "test/UnitTest/Test.h"
 
 STRCHR_TEST(Index, LIBC_NAMESPACE::index)
diff --git a/test/src/string/rindex_test.cpp b/test/src/strings/rindex_test.cpp
similarity index 86%
rename from test/src/string/rindex_test.cpp
rename to test/src/strings/rindex_test.cpp
index 1051391..d3b756f 100644
--- a/test/src/string/rindex_test.cpp
+++ b/test/src/strings/rindex_test.cpp
@@ -6,9 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "StrchrTest.h"
+#include "test/src/string/StrchrTest.h"
 
-#include "src/string/rindex.h"
+#include "src/strings/rindex.h"
 #include "test/UnitTest/Test.h"
 
 STRRCHR_TEST(Rindex, LIBC_NAMESPACE::rindex)
diff --git a/test/src/strings/strcasecmp_l_test.cpp b/test/src/strings/strcasecmp_l_test.cpp
new file mode 100644
index 0000000..33a47b6
--- /dev/null
+++ b/test/src/strings/strcasecmp_l_test.cpp
@@ -0,0 +1,21 @@
+//===-- Unittests for strcasecmp_l ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/locale_macros.h"
+#include "src/locale/freelocale.h"
+#include "src/locale/newlocale.h"
+#include "src/strings/strcasecmp_l.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcStrCaseCmpLTest, Case) {
+  locale_t locale = LIBC_NAMESPACE::newlocale(LC_ALL, "C", nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::strcasecmp_l("hello", "HELLO", locale), 0);
+  ASSERT_LT(LIBC_NAMESPACE::strcasecmp_l("hello1", "hello2", locale), 0);
+  ASSERT_GT(LIBC_NAMESPACE::strcasecmp_l("hello2", "hello1", locale), 0);
+  LIBC_NAMESPACE::freelocale(locale);
+}
diff --git a/test/src/string/strcasecmp_test.cpp b/test/src/strings/strcasecmp_test.cpp
similarity index 97%
rename from test/src/string/strcasecmp_test.cpp
rename to test/src/strings/strcasecmp_test.cpp
index df78881..cd29c21 100644
--- a/test/src/string/strcasecmp_test.cpp
+++ b/test/src/strings/strcasecmp_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/strcasecmp.h"
+#include "src/strings/strcasecmp.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStrCaseCmpTest, EmptyStringsShouldReturnZero) {
diff --git a/test/src/strings/strncasecmp_l_test.cpp b/test/src/strings/strncasecmp_l_test.cpp
new file mode 100644
index 0000000..271f318
--- /dev/null
+++ b/test/src/strings/strncasecmp_l_test.cpp
@@ -0,0 +1,22 @@
+//===-- Unittests for strncasecmp_l ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/locale_macros.h"
+#include "src/locale/freelocale.h"
+#include "src/locale/newlocale.h"
+#include "src/strings/strncasecmp_l.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcStrNCaseCmpLTest, Case) {
+  locale_t locale = LIBC_NAMESPACE::newlocale(LC_ALL, "C", nullptr);
+  ASSERT_EQ(LIBC_NAMESPACE::strncasecmp_l("hello", "HELLO", 3, locale), 0);
+  ASSERT_EQ(LIBC_NAMESPACE::strncasecmp_l("abcXX", "ABCYY", 3, locale), 0);
+  ASSERT_LT(LIBC_NAMESPACE::strncasecmp_l("hello1", "hello2", 6, locale), 0);
+  ASSERT_GT(LIBC_NAMESPACE::strncasecmp_l("hello2", "hello1", 6, locale), 0);
+  LIBC_NAMESPACE::freelocale(locale);
+}
diff --git a/test/src/string/strncasecmp_test.cpp b/test/src/strings/strncasecmp_test.cpp
similarity index 97%
rename from test/src/string/strncasecmp_test.cpp
rename to test/src/strings/strncasecmp_test.cpp
index b4173c4..870574e 100644
--- a/test/src/string/strncasecmp_test.cpp
+++ b/test/src/strings/strncasecmp_test.cpp
@@ -6,7 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/string/strncasecmp.h"
+#include "src/strings/strncasecmp.h"
 #include "test/UnitTest/Test.h"
 
 TEST(LlvmLibcStrNCaseCmpTest,
diff --git a/test/src/sys/mman/linux/process_mrelease_test.cpp b/test/src/sys/mman/linux/process_mrelease_test.cpp
deleted file mode 100644
index 71cde7a..0000000
--- a/test/src/sys/mman/linux/process_mrelease_test.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-//===-- Unittests for process_mrelease ------------------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "src/__support/OSUtil/syscall.h" // For internal syscall function.
-#include "src/errno/libc_errno.h"
-#include "src/signal/kill.h"
-#include "src/signal/raise.h"
-#include "src/stdlib/exit.h"
-#include "src/sys/mman/process_mrelease.h"
-#include "src/unistd/close.h"
-#include "src/unistd/fork.h"
-#include "test/UnitTest/ErrnoSetterMatcher.h"
-#include "test/UnitTest/LibcTest.h"
-
-#include <sys/syscall.h>
-#if defined(SYS_process_mrelease) && defined(SYS_pidfd_open)
-using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
-
-int pidfd_open(pid_t pid, unsigned int flags) {
-  return LIBC_NAMESPACE::syscall_impl(SYS_pidfd_open, pid, flags);
-}
-
-TEST(LlvmLibcProcessMReleaseTest, NoError) {
-  pid_t child_pid = fork();
-  EXPECT_GE(child_pid, 0);
-
-  if (child_pid == 0) {
-    // pause the child process
-    LIBC_NAMESPACE::raise(SIGSTOP);
-  } else {
-    // Parent process: wait a bit and then kill the child.
-    // Give child process some time to start.
-    int pidfd = pidfd_open(child_pid, 0);
-    EXPECT_GE(pidfd, 0);
-
-    // Send SIGKILL to child process
-    LIBC_NAMESPACE::kill(child_pid, SIGKILL);
-
-    EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(pidfd, 0), Succeeds());
-
-    LIBC_NAMESPACE::close(pidfd);
-  }
-}
-
-TEST(LlvmLibcProcessMReleaseTest, ErrorNotKilled) {
-  pid_t child_pid = fork();
-  EXPECT_GE(child_pid, 0);
-
-  if (child_pid == 0) {
-    // pause the child process
-    LIBC_NAMESPACE::raise(SIGSTOP);
-  } else {
-    int pidfd = pidfd_open(child_pid, 0);
-    EXPECT_GE(pidfd, 0);
-
-    EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(pidfd, 0), Fails(EINVAL));
-
-    LIBC_NAMESPACE::close(pidfd);
-  }
-}
-
-TEST(LlvmLibcProcessMReleaseTest, ErrorNonExistingPidfd) {
-  EXPECT_THAT(LIBC_NAMESPACE::process_mrelease(-1, 0), Fails(EBADF));
-}
-#endif
diff --git a/test/src/sys/mman/linux/remap_file_pages_test.cpp b/test/src/sys/mman/linux/remap_file_pages_test.cpp
index 267f759..ebc5c89 100644
--- a/test/src/sys/mman/linux/remap_file_pages_test.cpp
+++ b/test/src/sys/mman/linux/remap_file_pages_test.cpp
@@ -23,7 +23,7 @@ using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 
 TEST(LlvmLibcRemapFilePagesTest, NoError) {
-  size_t page_size = sysconf(_SC_PAGE_SIZE);
+  size_t page_size = LIBC_NAMESPACE::sysconf(_SC_PAGE_SIZE);
   ASSERT_GT(page_size, size_t(0));
 
   // Create a file-backed mapping
@@ -53,7 +53,7 @@ TEST(LlvmLibcRemapFilePagesTest, NoError) {
 }
 
 TEST(LlvmLibcRemapFilePagesTest, ErrorInvalidFlags) {
-  size_t page_size = sysconf(_SC_PAGE_SIZE);
+  size_t page_size = LIBC_NAMESPACE::sysconf(_SC_PAGE_SIZE);
   ASSERT_GT(page_size, size_t(0));
 
   // Create a file-backed mapping
@@ -81,7 +81,7 @@ TEST(LlvmLibcRemapFilePagesTest, ErrorInvalidFlags) {
 }
 
 TEST(LlvmLibcRemapFilePagesTest, ErrorInvalidAddress) {
-  size_t page_size = sysconf(_SC_PAGESIZE);
+  size_t page_size = LIBC_NAMESPACE::sysconf(_SC_PAGESIZE);
   ASSERT_GT(page_size, size_t(0));
 
   // Use an address that we haven't mapped
diff --git a/test/src/sys/random/linux/getrandom_test.cpp b/test/src/sys/random/linux/getrandom_test.cpp
index e3481b7..eb5b23c 100644
--- a/test/src/sys/random/linux/getrandom_test.cpp
+++ b/test/src/sys/random/linux/getrandom_test.cpp
@@ -16,14 +16,16 @@
 TEST(LlvmLibcGetRandomTest, InvalidFlag) {
   LIBC_NAMESPACE::cpp::array<char, 10> buffer;
   LIBC_NAMESPACE::libc_errno = 0;
-  ASSERT_THAT(LIBC_NAMESPACE::getrandom(buffer.data(), buffer.size(), -1),
-              LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails(EINVAL));
+  ASSERT_THAT(
+      LIBC_NAMESPACE::getrandom(buffer.data(), buffer.size(), -1),
+      LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails<ssize_t>(EINVAL));
 }
 
 TEST(LlvmLibcGetRandomTest, InvalidBuffer) {
   LIBC_NAMESPACE::libc_errno = 0;
-  ASSERT_THAT(LIBC_NAMESPACE::getrandom(nullptr, 65536, 0),
-              LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails(EFAULT));
+  ASSERT_THAT(
+      LIBC_NAMESPACE::getrandom(nullptr, 65536, 0),
+      LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails<ssize_t>(EFAULT));
 }
 
 TEST(LlvmLibcGetRandomTest, ReturnsSize) {
diff --git a/test/src/sys/socket/linux/bind_test.cpp b/test/src/sys/socket/linux/bind_test.cpp
index e70cbd5..60cd7c0 100644
--- a/test/src/sys/socket/linux/bind_test.cpp
+++ b/test/src/sys/socket/linux/bind_test.cpp
@@ -12,12 +12,16 @@
 #include "src/stdio/remove.h"
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSocketTest, BindLocalSocket) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcBindTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcBindTest, BindLocalSocket) {
 
   const char *FILENAME = "bind_file.test";
   auto SOCK_PATH = libc_make_test_file_path(FILENAME);
@@ -41,14 +45,10 @@ TEST(LlvmLibcSocketTest, BindLocalSocket) {
   ASSERT_LT(
       i, static_cast<unsigned int>(sizeof(sockaddr_un) - sizeof(sa_family_t)));
 
-  int result =
+  ASSERT_THAT(
       LIBC_NAMESPACE::bind(sock, reinterpret_cast<struct sockaddr *>(&my_addr),
-                           sizeof(struct sockaddr_un));
-
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
-
-  LIBC_NAMESPACE::close(sock);
-
-  LIBC_NAMESPACE::remove(SOCK_PATH);
+                           sizeof(struct sockaddr_un)),
+      Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::close(sock), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::remove(SOCK_PATH), Succeeds(0));
 }
diff --git a/test/src/sys/socket/linux/send_recv_test.cpp b/test/src/sys/socket/linux/send_recv_test.cpp
index a5d4880..46f73a2 100644
--- a/test/src/sys/socket/linux/send_recv_test.cpp
+++ b/test/src/sys/socket/linux/send_recv_test.cpp
@@ -12,62 +12,51 @@
 
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSendRecvTest, SucceedsWithSocketPair) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSendRecvTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSendRecvTest, SucceedsWithSocketPair) {
   const char TEST_MESSAGE[] = "connection successful";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
   int sockpair[2] = {0, 0};
 
-  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair),
+              Succeeds(0));
 
-  ssize_t send_result =
-      LIBC_NAMESPACE::send(sockpair[0], TEST_MESSAGE, MESSAGE_LEN, 0);
-  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::send(sockpair[0], TEST_MESSAGE, MESSAGE_LEN, 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   char buffer[256];
 
-  ssize_t recv_result =
-      LIBC_NAMESPACE::recv(sockpair[1], buffer, sizeof(buffer), 0);
-  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::recv(sockpair[1], buffer, sizeof(buffer), 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   ASSERT_STREQ(buffer, TEST_MESSAGE);
 
   // close both ends of the socket
-  result = LIBC_NAMESPACE::close(sockpair[0]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
-
-  result = LIBC_NAMESPACE::close(sockpair[1]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[0]), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[1]), Succeeds(0));
 }
 
-TEST(LlvmLibcSendRecvTest, SendFails) {
+TEST_F(LlvmLibcSendRecvTest, SendFails) {
   const char TEST_MESSAGE[] = "connection terminated";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
-  ssize_t send_result = LIBC_NAMESPACE::send(-1, TEST_MESSAGE, MESSAGE_LEN, 0);
-  EXPECT_EQ(send_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(LIBC_NAMESPACE::send(-1, TEST_MESSAGE, MESSAGE_LEN, 0),
+              Fails(EBADF));
 }
 
-TEST(LlvmLibcSendRecvTest, RecvFails) {
+TEST_F(LlvmLibcSendRecvTest, RecvFails) {
   char buffer[256];
 
-  ssize_t recv_result = LIBC_NAMESPACE::recv(-1, buffer, sizeof(buffer), 0);
-  ASSERT_EQ(recv_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(LIBC_NAMESPACE::recv(-1, buffer, sizeof(buffer), 0),
+              Fails(EBADF));
 }
diff --git a/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp b/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp
index abcb0a3..7ed94b2 100644
--- a/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp
+++ b/test/src/sys/socket/linux/sendmsg_recvmsg_test.cpp
@@ -12,20 +12,24 @@
 
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSendMsgRecvMsgTest, SucceedsWithSocketPair) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSendMsgRecvMsgTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSendMsgRecvMsgTest, SucceedsWithSocketPair) {
   const char TEST_MESSAGE[] = "connection successful";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
   int sockpair[2] = {0, 0};
 
-  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair),
+              Succeeds(0));
 
   iovec send_msg_text;
   send_msg_text.iov_base =
@@ -41,9 +45,8 @@ TEST(LlvmLibcSendMsgRecvMsgTest, SucceedsWithSocketPair) {
   send_message.msg_controllen = 0;
   send_message.msg_flags = 0;
 
-  ssize_t send_result = LIBC_NAMESPACE::sendmsg(sockpair[0], &send_message, 0);
-  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::sendmsg(sockpair[0], &send_message, 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   char buffer[256];
 
@@ -60,23 +63,17 @@ TEST(LlvmLibcSendMsgRecvMsgTest, SucceedsWithSocketPair) {
   recv_message.msg_controllen = 0;
   recv_message.msg_flags = 0;
 
-  ssize_t recv_result = LIBC_NAMESPACE::recvmsg(sockpair[1], &recv_message, 0);
-  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::recvmsg(sockpair[1], &recv_message, 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   ASSERT_STREQ(buffer, TEST_MESSAGE);
 
   // close both ends of the socket
-  result = LIBC_NAMESPACE::close(sockpair[0]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
-
-  result = LIBC_NAMESPACE::close(sockpair[1]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[0]), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[1]), Succeeds(0));
 }
 
-TEST(LlvmLibcSendMsgRecvMsgTest, SendFails) {
+TEST_F(LlvmLibcSendMsgRecvMsgTest, SendFails) {
   const char TEST_MESSAGE[] = "connection terminated";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
@@ -94,14 +91,10 @@ TEST(LlvmLibcSendMsgRecvMsgTest, SendFails) {
   send_message.msg_controllen = 0;
   send_message.msg_flags = 0;
 
-  ssize_t send_result = LIBC_NAMESPACE::sendmsg(-1, &send_message, 0);
-  EXPECT_EQ(send_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(LIBC_NAMESPACE::sendmsg(-1, &send_message, 0), Fails(EBADF));
 }
 
-TEST(LlvmLibcSendMsgRecvMsgTest, RecvFails) {
+TEST_F(LlvmLibcSendMsgRecvMsgTest, RecvFails) {
   char buffer[256];
 
   iovec recv_msg_text;
@@ -117,9 +110,5 @@ TEST(LlvmLibcSendMsgRecvMsgTest, RecvFails) {
   recv_message.msg_controllen = 0;
   recv_message.msg_flags = 0;
 
-  ssize_t recv_result = LIBC_NAMESPACE::recvmsg(-1, &recv_message, 0);
-  ASSERT_EQ(recv_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(LIBC_NAMESPACE::recvmsg(-1, &recv_message, 0), Fails(EBADF));
 }
diff --git a/test/src/sys/socket/linux/sendto_recvfrom_test.cpp b/test/src/sys/socket/linux/sendto_recvfrom_test.cpp
index e91b333..8377260 100644
--- a/test/src/sys/socket/linux/sendto_recvfrom_test.cpp
+++ b/test/src/sys/socket/linux/sendto_recvfrom_test.cpp
@@ -12,64 +12,55 @@
 
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSendToRecvFromTest, SucceedsWithSocketPair) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSendToRecvFromTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSendToRecvFromTest, SucceedsWithSocketPair) {
   const char TEST_MESSAGE[] = "connection successful";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
   int sockpair[2] = {0, 0};
 
-  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_STREAM, 0, sockpair),
+              Succeeds(0));
 
-  ssize_t send_result = LIBC_NAMESPACE::sendto(sockpair[0], TEST_MESSAGE,
-                                               MESSAGE_LEN, 0, nullptr, 0);
-  EXPECT_EQ(send_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::sendto(sockpair[0], TEST_MESSAGE, MESSAGE_LEN, 0,
+                                     nullptr, 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   char buffer[256];
 
-  ssize_t recv_result = LIBC_NAMESPACE::recvfrom(sockpair[1], buffer,
-                                                 sizeof(buffer), 0, nullptr, 0);
-  ASSERT_EQ(recv_result, static_cast<ssize_t>(MESSAGE_LEN));
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::recvfrom(sockpair[1], buffer, sizeof(buffer), 0,
+                                       nullptr, 0),
+              Succeeds(static_cast<ssize_t>(MESSAGE_LEN)));
 
   ASSERT_STREQ(buffer, TEST_MESSAGE);
 
   // close both ends of the socket
-  result = LIBC_NAMESPACE::close(sockpair[0]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
-
-  result = LIBC_NAMESPACE::close(sockpair[1]);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[0]), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[1]), Succeeds(0));
 }
 
-TEST(LlvmLibcSendToRecvFromTest, SendToFails) {
+TEST_F(LlvmLibcSendToRecvFromTest, SendToFails) {
   const char TEST_MESSAGE[] = "connection terminated";
   const size_t MESSAGE_LEN = sizeof(TEST_MESSAGE);
 
-  ssize_t send_result =
-      LIBC_NAMESPACE::sendto(-1, TEST_MESSAGE, MESSAGE_LEN, 0, nullptr, 0);
-  EXPECT_EQ(send_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(
+      LIBC_NAMESPACE::sendto(-1, TEST_MESSAGE, MESSAGE_LEN, 0, nullptr, 0),
+      Fails(EBADF));
 }
 
-TEST(LlvmLibcSendToRecvFromTest, RecvFromFails) {
+TEST_F(LlvmLibcSendToRecvFromTest, RecvFromFails) {
   char buffer[256];
 
-  ssize_t recv_result =
-      LIBC_NAMESPACE::recvfrom(-1, buffer, sizeof(buffer), 0, nullptr, 0);
-  ASSERT_EQ(recv_result, ssize_t(-1));
-  ASSERT_ERRNO_FAILURE();
-
-  LIBC_NAMESPACE::libc_errno = 0; // reset errno to avoid test ordering issues.
+  ASSERT_THAT(
+      LIBC_NAMESPACE::recvfrom(-1, buffer, sizeof(buffer), 0, nullptr, 0),
+      Fails(EBADF));
 }
diff --git a/test/src/sys/socket/linux/socket_test.cpp b/test/src/sys/socket/linux/socket_test.cpp
index d1197fa..9f16be9 100644
--- a/test/src/sys/socket/linux/socket_test.cpp
+++ b/test/src/sys/socket/linux/socket_test.cpp
@@ -10,15 +10,19 @@
 
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSocketTest, LocalSocket) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSocketTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSocketTest, LocalSocket) {
   int sock = LIBC_NAMESPACE::socket(AF_UNIX, SOCK_DGRAM, 0);
   ASSERT_GE(sock, 0);
   ASSERT_ERRNO_SUCCESS();
 
-  LIBC_NAMESPACE::close(sock);
+  ASSERT_THAT(LIBC_NAMESPACE::close(sock), Succeeds(0));
 }
diff --git a/test/src/sys/socket/linux/socketpair_test.cpp b/test/src/sys/socket/linux/socketpair_test.cpp
index 9393ddd..94b7412 100644
--- a/test/src/sys/socket/linux/socketpair_test.cpp
+++ b/test/src/sys/socket/linux/socketpair_test.cpp
@@ -10,28 +10,29 @@
 
 #include "src/unistd/close.h"
 
-#include "src/errno/libc_errno.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/socket.h> // For AF_UNIX and SOCK_DGRAM
 
-TEST(LlvmLibcSocketPairTest, LocalSocket) {
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSocketPairTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSocketPairTest, LocalSocket) {
   int sockpair[2] = {-1, -1};
-  int result = LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_DGRAM, 0, sockpair);
-  ASSERT_EQ(result, 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::socketpair(AF_UNIX, SOCK_DGRAM, 0, sockpair),
+              Succeeds(0));
 
   ASSERT_GE(sockpair[0], 0);
   ASSERT_GE(sockpair[1], 0);
 
-  LIBC_NAMESPACE::close(sockpair[0]);
-  LIBC_NAMESPACE::close(sockpair[1]);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[0]), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::close(sockpair[1]), Succeeds(0));
 }
 
-TEST(LlvmLibcSocketPairTest, SocketFails) {
+TEST_F(LlvmLibcSocketPairTest, SocketFails) {
   int sockpair[2] = {-1, -1};
-  int result = LIBC_NAMESPACE::socketpair(-1, -1, -1, sockpair);
-  ASSERT_EQ(result, -1);
-  ASSERT_ERRNO_FAILURE();
+  ASSERT_THAT(LIBC_NAMESPACE::socketpair(-1, -1, -1, sockpair), Fails(EINVAL));
 }
diff --git a/test/src/sys/uio/readv_test.cpp b/test/src/sys/uio/readv_test.cpp
new file mode 100644
index 0000000..7cbaa33
--- /dev/null
+++ b/test/src/sys/uio/readv_test.cpp
@@ -0,0 +1,43 @@
+//===-- Unittests for readv -----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/struct_iovec.h"
+#include "src/fcntl/open.h"
+#include "src/sys/uio/readv.h"
+#include "src/unistd/close.h"
+#include "src/unistd/unlink.h"
+#include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+TEST(LlvmLibcSysUioReadvTest, SmokeTest) {
+  const char *filename = "./LlvmLibcSysUioReadvTest";
+  int fd = LIBC_NAMESPACE::open(filename, O_WRONLY | O_CREAT, 0644);
+  ASSERT_THAT(fd, returns(GT(0)).with_errno(EQ(0)));
+  const char data[] = "Hello, World!\n";
+  ASSERT_THAT(LIBC_NAMESPACE::write(fd, data, sizeof(data)),
+              returns(EQ(sizeof(data))).with_errno(EQ(0)));
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
+
+  fd = LIBC_NAMESPACE::open(filename, O_RDONLY);
+  ASSERT_THAT(fd, returns(GT(0)).with_errno(EQ(0)));
+  char buf0[2];
+  char buf1[3];
+  struct iovec iov[2];
+  iov[0].iov_base = buf0;
+  iov[0].iov_len = 1;
+  iov[1].iov_base = buf1;
+  iov[1].iov_len = 2;
+  ASSERT_THAT(LIBC_NAMESPACE::readv(fd, iov, 2),
+              returns(EQ(ssize_t(3))).with_errno(EQ(0)));
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::unlink(filename),
+              returns(EQ(ssize_t(0))).with_errno(EQ(0)));
+}
diff --git a/test/src/sys/uio/writev_test.cpp b/test/src/sys/uio/writev_test.cpp
new file mode 100644
index 0000000..69db0de
--- /dev/null
+++ b/test/src/sys/uio/writev_test.cpp
@@ -0,0 +1,34 @@
+//===-- Unittests for writev ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/struct_iovec.h"
+#include "src/fcntl/open.h"
+#include "src/sys/uio/writev.h"
+#include "src/unistd/close.h"
+#include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+
+TEST(LlvmLibcSysUioWritevTest, SmokeTest) {
+  const char *filename = "./LlvmLibcSysUioWritevTest";
+  int fd = LIBC_NAMESPACE::open(filename, O_WRONLY | O_CREAT, 0644);
+  ASSERT_THAT(fd, returns(GT(0)).with_errno(EQ(0)));
+  const char *data = "Hello, World!\n";
+  struct iovec iov[2];
+  iov[0].iov_base = const_cast<char *>(data);
+  iov[0].iov_len = 7;
+  iov[1].iov_base = const_cast<char *>(data + 7);
+  iov[1].iov_len = 8;
+  ASSERT_THAT(LIBC_NAMESPACE::writev(fd, iov, 2),
+              returns(EQ(ssize_t(15))).with_errno(EQ(0)));
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds());
+  ASSERT_THAT(LIBC_NAMESPACE::unlink(filename),
+              returns(EQ(ssize_t(0))).with_errno(EQ(0)));
+}
diff --git a/test/src/time/TmHelper.h b/test/src/time/TmHelper.h
index 5ae2584..1582839 100644
--- a/test/src/time/TmHelper.h
+++ b/test/src/time/TmHelper.h
@@ -9,12 +9,9 @@
 #ifndef LLVM_LIBC_TEST_SRC_TIME_TMHELPER_H
 #define LLVM_LIBC_TEST_SRC_TIME_TMHELPER_H
 
-#include <time.h>
-
+#include "hdr/types/struct_tm.h"
 #include "src/__support/macros/config.h"
-#include "src/time/time_utils.h"
-
-using LIBC_NAMESPACE::time_utils::TimeConstants;
+#include "src/time/time_constants.h"
 
 namespace LIBC_NAMESPACE_DECL {
 namespace tmhelper {
@@ -30,7 +27,7 @@ static inline void initialize_tm_data(struct tm *tm_data, int year, int month,
                     .tm_mday = mday,
                     .tm_mon = month - 1, // tm_mon starts with 0 for Jan
                     // years since 1900
-                    .tm_year = year - TimeConstants::TIME_YEAR_BASE,
+                    .tm_year = year - time_constants::TIME_YEAR_BASE,
                     .tm_wday = wday,
                     .tm_yday = yday,
                     .tm_isdst = 0};
diff --git a/test/src/time/TmMatcher.h b/test/src/time/TmMatcher.h
index 630956b..d39ee39 100644
--- a/test/src/time/TmMatcher.h
+++ b/test/src/time/TmMatcher.h
@@ -9,8 +9,7 @@
 #ifndef LLVM_LIBC_TEST_SRC_TIME_TM_MATCHER_H
 #define LLVM_LIBC_TEST_SRC_TIME_TM_MATCHER_H
 
-#include <time.h>
-
+#include "hdr/types/struct_tm.h"
 #include "src/__support/macros/config.h"
 #include "test/UnitTest/Test.h"
 
diff --git a/test/src/time/asctime_r_test.cpp b/test/src/time/asctime_r_test.cpp
index f3aadbb..b595cfe 100644
--- a/test/src/time/asctime_r_test.cpp
+++ b/test/src/time/asctime_r_test.cpp
@@ -8,12 +8,10 @@
 
 #include "src/errno/libc_errno.h"
 #include "src/time/asctime_r.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/Test.h"
 #include "test/src/time/TmHelper.h"
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 static inline char *call_asctime_r(struct tm *tm_data, int year, int month,
                                    int mday, int hour, int min, int sec,
                                    int wday, int yday, char *buffer) {
@@ -30,7 +28,7 @@ TEST(LlvmLibcAsctimeR, Nullptr) {
   ASSERT_ERRNO_EQ(EINVAL);
   ASSERT_STREQ(nullptr, result);
 
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   result = LIBC_NAMESPACE::asctime_r(nullptr, buffer);
   ASSERT_ERRNO_EQ(EINVAL);
   ASSERT_STREQ(nullptr, result);
@@ -42,7 +40,7 @@ TEST(LlvmLibcAsctimeR, Nullptr) {
 }
 
 TEST(LlvmLibcAsctimeR, ValidDate) {
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   struct tm tm_data;
   char *result;
   // 1970-01-01 00:00:00. Test with a valid buffer size.
diff --git a/test/src/time/clock_getres_test.cpp b/test/src/time/clock_getres_test.cpp
new file mode 100644
index 0000000..d8b3f01
--- /dev/null
+++ b/test/src/time/clock_getres_test.cpp
@@ -0,0 +1,55 @@
+//===-- Unittests for clock_getres- ---------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/time_macros.h"
+#include "src/time/clock_getres.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
+using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+
+TEST(LlvmLibcClockGetRes, Invalid) {
+  timespec tp;
+  EXPECT_THAT(LIBC_NAMESPACE::clock_getres(-1, &tp), Fails(EINVAL));
+}
+
+TEST(LlvmLibcClockGetRes, NullSpec) {
+  EXPECT_THAT(LIBC_NAMESPACE::clock_getres(CLOCK_REALTIME, nullptr),
+              Succeeds());
+}
+
+TEST(LlvmLibcClockGetRes, Realtime) {
+  timespec tp;
+  EXPECT_THAT(LIBC_NAMESPACE::clock_getres(CLOCK_REALTIME, &tp), Succeeds());
+  EXPECT_GE(tp.tv_sec, static_cast<decltype(tp.tv_sec)>(0));
+  EXPECT_GE(tp.tv_nsec, static_cast<decltype(tp.tv_nsec)>(0));
+}
+
+TEST(LlvmLibcClockGetRes, Monotonic) {
+  timespec tp;
+  ASSERT_THAT(LIBC_NAMESPACE::clock_getres(CLOCK_MONOTONIC, &tp), Succeeds());
+  EXPECT_GE(tp.tv_sec, static_cast<decltype(tp.tv_sec)>(0));
+  EXPECT_GE(tp.tv_nsec, static_cast<decltype(tp.tv_nsec)>(0));
+}
+
+TEST(LlvmLibcClockGetRes, ProcessCpuTime) {
+  timespec tp;
+  ASSERT_THAT(LIBC_NAMESPACE::clock_getres(CLOCK_PROCESS_CPUTIME_ID, &tp),
+              Succeeds());
+  EXPECT_GE(tp.tv_sec, static_cast<decltype(tp.tv_sec)>(0));
+  EXPECT_GE(tp.tv_nsec, static_cast<decltype(tp.tv_nsec)>(0));
+}
+
+TEST(LlvmLibcClockGetRes, ThreadCpuTime) {
+  timespec tp;
+  ASSERT_THAT(LIBC_NAMESPACE::clock_getres(CLOCK_THREAD_CPUTIME_ID, &tp),
+              Succeeds());
+  EXPECT_GE(tp.tv_sec, static_cast<decltype(tp.tv_sec)>(0));
+  EXPECT_GE(tp.tv_nsec, static_cast<decltype(tp.tv_nsec)>(0));
+}
diff --git a/test/src/time/clock_gettime_test.cpp b/test/src/time/clock_gettime_test.cpp
index 43715c0..d3edcae 100644
--- a/test/src/time/clock_gettime_test.cpp
+++ b/test/src/time/clock_gettime_test.cpp
@@ -6,12 +6,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/time_macros.h"
+#include "hdr/types/struct_timespec.h"
+#include "hdr/types/time_t.h"
 #include "src/__support/macros/properties/architectures.h"
 #include "src/time/clock_gettime.h"
 #include "test/UnitTest/Test.h"
 
-#include <time.h>
-
 TEST(LlvmLibcClockGetTime, RealTime) {
   timespec tp;
   int result;
diff --git a/test/src/time/clock_test.cpp b/test/src/time/clock_test.cpp
index 05082aa..8d8d89d 100644
--- a/test/src/time/clock_test.cpp
+++ b/test/src/time/clock_test.cpp
@@ -6,11 +6,10 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/types/clock_t.h"
 #include "src/time/clock.h"
 #include "test/UnitTest/Test.h"
 
-#include <time.h>
-
 TEST(LlvmLibcClockTest, SmokeTest) {
   clock_t c1 = LIBC_NAMESPACE::clock();
   ASSERT_GT(c1, clock_t(0));
diff --git a/test/src/time/ctime_r_test.cpp b/test/src/time/ctime_r_test.cpp
index 9ce6f75..27011b7 100644
--- a/test/src/time/ctime_r_test.cpp
+++ b/test/src/time/ctime_r_test.cpp
@@ -8,18 +8,16 @@
 
 #include "src/errno/libc_errno.h"
 #include "src/time/ctime_r.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/Test.h"
 #include "test/src/time/TmHelper.h"
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 TEST(LlvmLibcCtimeR, Nullptr) {
   char *result;
   result = LIBC_NAMESPACE::ctime_r(nullptr, nullptr);
   ASSERT_STREQ(nullptr, result);
 
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   result = LIBC_NAMESPACE::ctime_r(nullptr, buffer);
   ASSERT_STREQ(nullptr, result);
 
@@ -29,7 +27,7 @@ TEST(LlvmLibcCtimeR, Nullptr) {
 }
 
 TEST(LlvmLibcCtimeR, ValidUnixTimestamp0) {
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   time_t t;
   char *result;
   // 1970-01-01 00:00:00. Test with a valid buffer size.
@@ -39,7 +37,7 @@ TEST(LlvmLibcCtimeR, ValidUnixTimestamp0) {
 }
 
 TEST(LlvmLibcCtime, ValidUnixTimestamp32Int) {
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   time_t t;
   char *result;
   // 2038-01-19 03:14:07. Test with a valid buffer size.
@@ -49,7 +47,7 @@ TEST(LlvmLibcCtime, ValidUnixTimestamp32Int) {
 }
 
 TEST(LlvmLibcCtimeR, InvalidArgument) {
-  char buffer[TimeConstants::ASCTIME_BUFFER_SIZE];
+  char buffer[LIBC_NAMESPACE::time_constants::ASCTIME_BUFFER_SIZE];
   time_t t;
   char *result;
   t = 2147483648;
diff --git a/test/src/time/difftime_test.cpp b/test/src/time/difftime_test.cpp
index 68ff463..4dab1ac 100644
--- a/test/src/time/difftime_test.cpp
+++ b/test/src/time/difftime_test.cpp
@@ -8,15 +8,12 @@
 
 #include "src/__support/FPUtil/FPBits.h"
 #include "src/time/difftime.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
-using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 TEST(LlvmLibcDifftime, SmokeTest) {
-  time_t t1_seconds = TimeConstants::SECONDS_PER_HOUR;
+  time_t t1_seconds = LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR;
   time_t t2_seconds = 0;
 
   LIBC_NAMESPACE::fputil::FPBits<long double> expected_fp =
diff --git a/test/src/time/gettimeofday_test.cpp b/test/src/time/gettimeofday_test.cpp
index ee934b7..8f9f136 100644
--- a/test/src/time/gettimeofday_test.cpp
+++ b/test/src/time/gettimeofday_test.cpp
@@ -6,8 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <time.h>
-
+#include "hdr/types/struct_timeval.h"
 #include "src/time/gettimeofday.h"
 #include "test/UnitTest/Test.h"
 
diff --git a/test/src/time/gmtime_r_test.cpp b/test/src/time/gmtime_r_test.cpp
index 2276b48..9d466f4 100644
--- a/test/src/time/gmtime_r_test.cpp
+++ b/test/src/time/gmtime_r_test.cpp
@@ -7,12 +7,10 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/time/gmtime_r.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/Test.h"
 #include "test/src/time/TmMatcher.h"
 
-using LIBC_NAMESPACE::time_utils::TimeConstants;
-
 // gmtime and gmtime_r share the same code and thus didn't repeat all the tests
 // from gmtime. Added couple of validation tests.
 TEST(LlvmLibcGmTimeR, EndOf32BitEpochYear) {
@@ -22,16 +20,17 @@ TEST(LlvmLibcGmTimeR, EndOf32BitEpochYear) {
   struct tm tm_data;
   struct tm *tm_data_ptr;
   tm_data_ptr = LIBC_NAMESPACE::gmtime_r(&seconds, &tm_data);
-  EXPECT_TM_EQ((tm{7,  // sec
-                   14, // min
-                   3,  // hr
-                   19, // day
-                   0,  // tm_mon starts with 0 for Jan
-                   2038 - TimeConstants::TIME_YEAR_BASE, // year
-                   2,                                    // wday
-                   7,                                    // yday
-                   0}),
-               *tm_data_ptr);
+  EXPECT_TM_EQ(
+      (tm{7,  // sec
+          14, // min
+          3,  // hr
+          19, // day
+          0,  // tm_mon starts with 0 for Jan
+          2038 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          2,                                                     // wday
+          7,                                                     // yday
+          0}),
+      *tm_data_ptr);
   EXPECT_TM_EQ(*tm_data_ptr, tm_data);
 }
 
@@ -43,15 +42,16 @@ TEST(LlvmLibcGmTimeR, Max64BitYear) {
   struct tm tm_data;
   struct tm *tm_data_ptr;
   tm_data_ptr = LIBC_NAMESPACE::gmtime_r(&seconds, &tm_data);
-  EXPECT_TM_EQ((tm{50, // sec
-                   50, // min
-                   12, // hr
-                   1,  // day
-                   0,  // tm_mon starts with 0 for Jan
-                   2147483647 - TimeConstants::TIME_YEAR_BASE, // year
-                   2,                                          // wday
-                   50,                                         // yday
-                   0}),
-               *tm_data_ptr);
+  EXPECT_TM_EQ(
+      (tm{50, // sec
+          50, // min
+          12, // hr
+          1,  // day
+          0,  // tm_mon starts with 0 for Jan
+          2147483647 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          2,                                                           // wday
+          50,                                                          // yday
+          0}),
+      *tm_data_ptr);
   EXPECT_TM_EQ(*tm_data_ptr, tm_data);
 }
diff --git a/test/src/time/gmtime_test.cpp b/test/src/time/gmtime_test.cpp
index 433fbf6..6af5a18 100644
--- a/test/src/time/gmtime_test.cpp
+++ b/test/src/time/gmtime_test.cpp
@@ -6,32 +6,36 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "hdr/types/struct_tm.h"
 #include "src/__support/CPP/limits.h" // INT_MAX, INT_MIN
 #include "src/errno/libc_errno.h"
 #include "src/time/gmtime.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "test/src/time/TmMatcher.h"
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
-using LIBC_NAMESPACE::time_utils::TimeConstants;
 
 TEST(LlvmLibcGmTime, OutOfRange) {
   if (sizeof(time_t) < sizeof(int64_t))
     return;
   time_t seconds =
-      1 + INT_MAX * static_cast<int64_t>(
-                        TimeConstants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
+      1 +
+      INT_MAX *
+          static_cast<int64_t>(
+              LIBC_NAMESPACE::time_constants::NUMBER_OF_SECONDS_IN_LEAP_YEAR);
   struct tm *tm_data = LIBC_NAMESPACE::gmtime(&seconds);
   EXPECT_TRUE(tm_data == nullptr);
   ASSERT_ERRNO_EQ(EOVERFLOW);
 
   LIBC_NAMESPACE::libc_errno = 0;
-  seconds = INT_MIN * static_cast<int64_t>(
-                          TimeConstants::NUMBER_OF_SECONDS_IN_LEAP_YEAR) -
-            1;
+  seconds =
+      INT_MIN *
+          static_cast<int64_t>(
+              LIBC_NAMESPACE::time_constants::NUMBER_OF_SECONDS_IN_LEAP_YEAR) -
+      1;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
   EXPECT_TRUE(tm_data == nullptr);
   ASSERT_ERRNO_EQ(EOVERFLOW);
@@ -43,201 +47,215 @@ TEST(LlvmLibcGmTime, InvalidSeconds) {
   // -1 second from 1970-01-01 00:00:00 returns 1969-12-31 23:59:59.
   seconds = -1;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{59,     // sec
-                   59,     // min
-                   23,     // hr
-                   31,     // day
-                   12 - 1, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   364,                                  // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{59,     // sec
+          59,     // min
+          23,     // hr
+          31,     // day
+          12 - 1, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          364,                                                   // yday
+          0}),
+      *tm_data);
   // 60 seconds from 1970-01-01 00:00:00 returns 1970-01-01 00:01:00.
   seconds = 60;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   1, // min
-                   0, // hr
-                   1, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1970 - TimeConstants::TIME_YEAR_BASE, // year
-                   4,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          1, // min
+          0, // hr
+          1, // day
+          0, // tm_mon starts with 0 for Jan
+          1970 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          4,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, InvalidMinutes) {
   time_t seconds = 0;
   struct tm *tm_data = nullptr;
   // -1 minute from 1970-01-01 00:00:00 returns 1969-12-31 23:59:00.
-  seconds = -TimeConstants::SECONDS_PER_MIN;
+  seconds = -LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0,  // sec
-                   59, // min
-                   23, // hr
-                   31, // day
-                   11, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0,  // sec
+          59, // min
+          23, // hr
+          31, // day
+          11, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
   // 60 minutes from 1970-01-01 00:00:00 returns 1970-01-01 01:00:00.
-  seconds = 60 * TimeConstants::SECONDS_PER_MIN;
+  seconds = 60 * LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   1, // hr
-                   1, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1970 - TimeConstants::TIME_YEAR_BASE, // year
-                   4,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          1, // hr
+          1, // day
+          0, // tm_mon starts with 0 for Jan
+          1970 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          4,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, InvalidHours) {
   time_t seconds = 0;
   struct tm *tm_data = nullptr;
   // -1 hour from 1970-01-01 00:00:00 returns 1969-12-31 23:00:00.
-  seconds = -TimeConstants::SECONDS_PER_HOUR;
+  seconds = -LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0,  // sec
-                   0,  // min
-                   23, // hr
-                   31, // day
-                   11, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0,  // sec
+          0,  // min
+          23, // hr
+          31, // day
+          11, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
   // 24 hours from 1970-01-01 00:00:00 returns 1970-01-02 00:00:00.
-  seconds = 24 * TimeConstants::SECONDS_PER_HOUR;
+  seconds = 24 * LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   2, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1970 - TimeConstants::TIME_YEAR_BASE, // year
-                   5,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          2, // day
+          0, // tm_mon starts with 0 for Jan
+          1970 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          5,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, InvalidYear) {
   // -1 year from 1970-01-01 00:00:00 returns 1969-01-01 00:00:00.
-  time_t seconds =
-      -TimeConstants::DAYS_PER_NON_LEAP_YEAR * TimeConstants::SECONDS_PER_DAY;
+  time_t seconds = -LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR *
+                   LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   struct tm *tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   1, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          1, // day
+          0, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, InvalidMonths) {
   time_t seconds = 0;
   struct tm *tm_data = nullptr;
   // -1 month from 1970-01-01 00:00:00 returns 1969-12-01 00:00:00.
-  seconds = -31 * TimeConstants::SECONDS_PER_DAY;
+  seconds = -31 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0,      // sec
-                   0,      // min
-                   0,      // hr
-                   1,      // day
-                   12 - 1, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   1,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0,      // sec
+          0,      // min
+          0,      // hr
+          1,      // day
+          12 - 1, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          1,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
   // 1970-13-01 00:00:00 returns 1971-01-01 00:00:00.
-  seconds =
-      TimeConstants::DAYS_PER_NON_LEAP_YEAR * TimeConstants::SECONDS_PER_DAY;
+  seconds = LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR *
+            LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   1, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1971 - TimeConstants::TIME_YEAR_BASE, // year
-                   5,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          1, // day
+          0, // tm_mon starts with 0 for Jan
+          1971 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          5,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, InvalidDays) {
   time_t seconds = 0;
   struct tm *tm_data = nullptr;
   // -1 day from 1970-01-01 00:00:00 returns 1969-12-31 00:00:00.
-  seconds = -1 * TimeConstants::SECONDS_PER_DAY;
+  seconds = -1 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0,  // sec
-                   0,  // min
-                   0,  // hr
-                   31, // day
-                   11, // tm_mon starts with 0 for Jan
-                   1969 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0,  // sec
+          0,  // min
+          0,  // hr
+          31, // day
+          11, // tm_mon starts with 0 for Jan
+          1969 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 
   // 1970-01-32 00:00:00 returns 1970-02-01 00:00:00.
-  seconds = 31 * TimeConstants::SECONDS_PER_DAY;
+  seconds = 31 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   1, // day
-                   0, // tm_mon starts with 0 for Jan
-                   1970 - TimeConstants::TIME_YEAR_BASE, // year
-                   0,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          1, // day
+          0, // tm_mon starts with 0 for Jan
+          1970 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          0,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 
   // 1970-02-29 00:00:00 returns 1970-03-01 00:00:00.
-  seconds = 59 * TimeConstants::SECONDS_PER_DAY;
+  seconds = 59 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   1, // day
-                   2, // tm_mon starts with 0 for Jan
-                   1970 - TimeConstants::TIME_YEAR_BASE, // year
-                   0,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          1, // day
+          2, // tm_mon starts with 0 for Jan
+          1970 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          0,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 
   // 1972-02-30 00:00:00 returns 1972-03-01 00:00:00.
-  seconds = ((2 * TimeConstants::DAYS_PER_NON_LEAP_YEAR) + 60) *
-            TimeConstants::SECONDS_PER_DAY;
+  seconds =
+      ((2 * LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR) + 60) *
+      LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{0, // sec
-                   0, // min
-                   0, // hr
-                   1, // day
-                   2, // tm_mon starts with 0 for Jan
-                   1972 - TimeConstants::TIME_YEAR_BASE, // year
-                   3,                                    // wday
-                   0,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{0, // sec
+          0, // min
+          0, // hr
+          1, // day
+          2, // tm_mon starts with 0 for Jan
+          1972 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          3,                                                     // wday
+          0,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, EndOf32BitEpochYear) {
@@ -245,16 +263,17 @@ TEST(LlvmLibcGmTime, EndOf32BitEpochYear) {
   // Test implementation can encode time for Tue 19 January 2038 03:14:07 UTC.
   time_t seconds = 0x7FFFFFFF;
   struct tm *tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{7,  // sec
-                   14, // min
-                   3,  // hr
-                   19, // day
-                   0,  // tm_mon starts with 0 for Jan
-                   2038 - TimeConstants::TIME_YEAR_BASE, // year
-                   2,                                    // wday
-                   7,                                    // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{7,  // sec
+          14, // min
+          3,  // hr
+          19, // day
+          0,  // tm_mon starts with 0 for Jan
+          2038 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          2,                                                     // wday
+          7,                                                     // yday
+          0}),
+      *tm_data);
 }
 
 TEST(LlvmLibcGmTime, Max64BitYear) {
@@ -263,28 +282,30 @@ TEST(LlvmLibcGmTime, Max64BitYear) {
   // Mon Jan 1 12:50:50 2170 (200 years from 1970),
   time_t seconds = 6311479850;
   struct tm *tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{50, // sec
-                   50, // min
-                   12, // hr
-                   1,  // day
-                   0,  // tm_mon starts with 0 for Jan
-                   2170 - TimeConstants::TIME_YEAR_BASE, // year
-                   1,                                    // wday
-                   50,                                   // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{50, // sec
+          50, // min
+          12, // hr
+          1,  // day
+          0,  // tm_mon starts with 0 for Jan
+          2170 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          1,                                                     // wday
+          50,                                                    // yday
+          0}),
+      *tm_data);
 
   // Test for Tue Jan 1 12:50:50 in 2,147,483,647th year.
   seconds = 67767976202043050;
   tm_data = LIBC_NAMESPACE::gmtime(&seconds);
-  EXPECT_TM_EQ((tm{50, // sec
-                   50, // min
-                   12, // hr
-                   1,  // day
-                   0,  // tm_mon starts with 0 for Jan
-                   2147483647 - TimeConstants::TIME_YEAR_BASE, // year
-                   2,                                          // wday
-                   50,                                         // yday
-                   0}),
-               *tm_data);
+  EXPECT_TM_EQ(
+      (tm{50, // sec
+          50, // min
+          12, // hr
+          1,  // day
+          0,  // tm_mon starts with 0 for Jan
+          2147483647 - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE, // year
+          2,                                                           // wday
+          50,                                                          // yday
+          0}),
+      *tm_data);
 }
diff --git a/test/src/time/mktime_test.cpp b/test/src/time/mktime_test.cpp
index 84e6c7e..fe1116f 100644
--- a/test/src/time/mktime_test.cpp
+++ b/test/src/time/mktime_test.cpp
@@ -8,7 +8,7 @@
 
 #include "src/__support/CPP/limits.h" // INT_MAX
 #include "src/time/mktime.h"
-#include "src/time/time_utils.h"
+#include "src/time/time_constants.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 #include "test/src/time/TmHelper.h"
@@ -16,29 +16,37 @@
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
-using LIBC_NAMESPACE::time_utils::Month;
+using LIBC_NAMESPACE::time_constants::Month;
 
 static inline constexpr int tm_year(int year) {
-  return year - TimeConstants::TIME_YEAR_BASE;
+  return year - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE;
 }
 
 TEST(LlvmLibcMkTime, FailureSetsErrno) {
-  struct tm tm_data {
-    .tm_sec = INT_MAX, .tm_min = INT_MAX, .tm_hour = INT_MAX,
-    .tm_mday = INT_MAX, .tm_mon = INT_MAX - 1, .tm_year = tm_year(INT_MAX),
-    .tm_wday = 0, .tm_yday = 0, .tm_isdst = 0
-  };
+  struct tm tm_data{.tm_sec = INT_MAX,
+                    .tm_min = INT_MAX,
+                    .tm_hour = INT_MAX,
+                    .tm_mday = INT_MAX,
+                    .tm_mon = INT_MAX - 1,
+                    .tm_year = tm_year(INT_MAX),
+                    .tm_wday = 0,
+                    .tm_yday = 0,
+                    .tm_isdst = 0};
   EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
 }
 
 TEST(LlvmLibcMkTime, InvalidSeconds) {
   {
     // -1 second from 1970-01-01 00:00:00 returns 1969-12-31 23:59:59.
-    struct tm tm_data {
-      .tm_sec = -1, .tm_min = 0, .tm_hour = 0, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = -1,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(-1));
     EXPECT_TM_EQ((tm{.tm_sec = 59,
                      .tm_min = 59,
@@ -54,11 +62,15 @@ TEST(LlvmLibcMkTime, InvalidSeconds) {
 
   {
     // 60 seconds from 1970-01-01 00:00:00 returns 1970-01-01 00:01:00.
-    struct tm tm_data {
-      .tm_sec = 60, .tm_min = 0, .tm_hour = 0, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 60,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(60));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 1,
@@ -76,13 +88,17 @@ TEST(LlvmLibcMkTime, InvalidSeconds) {
 TEST(LlvmLibcMkTime, InvalidMinutes) {
   {
     // -1 minute from 1970-01-01 00:00:00 returns 1969-12-31 23:59:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = -1, .tm_hour = 0, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = -1,
+                      .tm_hour = 0,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(-TimeConstants::SECONDS_PER_MIN));
+                Succeeds(-LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 59,
                      .tm_hour = 23,
@@ -97,13 +113,17 @@ TEST(LlvmLibcMkTime, InvalidMinutes) {
 
   {
     // 60 minutes from 1970-01-01 00:00:00 returns 1970-01-01 01:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 60, .tm_hour = 0, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 60,
+                      .tm_hour = 0,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(60 * TimeConstants::SECONDS_PER_MIN));
+                Succeeds(60 * LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 1,
@@ -120,13 +140,17 @@ TEST(LlvmLibcMkTime, InvalidMinutes) {
 TEST(LlvmLibcMkTime, InvalidHours) {
   {
     // -1 hour from 1970-01-01 00:00:00 returns 1969-12-31 23:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = -1, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = -1,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(-TimeConstants::SECONDS_PER_HOUR));
+                Succeeds(-LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 23,
@@ -141,13 +165,18 @@ TEST(LlvmLibcMkTime, InvalidHours) {
 
   {
     // 24 hours from 1970-01-01 00:00:00 returns 1970-01-02 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 24, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
-    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(24 * TimeConstants::SECONDS_PER_HOUR));
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 24,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
+    EXPECT_THAT(
+        LIBC_NAMESPACE::mktime(&tm_data),
+        Succeeds(24 * LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -163,14 +192,18 @@ TEST(LlvmLibcMkTime, InvalidHours) {
 
 TEST(LlvmLibcMkTime, InvalidYear) {
   // -1 year from 1970-01-01 00:00:00 returns 1969-01-01 00:00:00.
-  struct tm tm_data {
-    .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 1,
-    .tm_mon = Month::JANUARY, .tm_year = tm_year(1969), .tm_wday = 0,
-    .tm_yday = 0, .tm_isdst = 0
-  };
+  struct tm tm_data{.tm_sec = 0,
+                    .tm_min = 0,
+                    .tm_hour = 0,
+                    .tm_mday = 1,
+                    .tm_mon = Month::JANUARY,
+                    .tm_year = tm_year(1969),
+                    .tm_wday = 0,
+                    .tm_yday = 0,
+                    .tm_isdst = 0};
   EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-              Succeeds(-TimeConstants::DAYS_PER_NON_LEAP_YEAR *
-                       TimeConstants::SECONDS_PER_DAY));
+              Succeeds(-LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR *
+                       LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
   EXPECT_TM_EQ((tm{.tm_sec = 0,
                    .tm_min = 0,
                    .tm_hour = 0,
@@ -188,61 +221,85 @@ TEST(LlvmLibcMkTime, InvalidEndOf32BitEpochYear) {
     return;
   {
     // 2038-01-19 03:14:08 tests overflow of the second in 2038.
-    struct tm tm_data {
-      .tm_sec = 8, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 8,
+                      .tm_min = 14,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 
   {
     // 2038-01-19 03:15:07 tests overflow of the minute in 2038.
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 15, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 15,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 
   {
     // 2038-01-19 04:14:07 tests overflow of the hour in 2038.
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 14, .tm_hour = 4, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 14,
+                      .tm_hour = 4,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 
   {
     // 2038-01-20 03:14:07 tests overflow of the day in 2038.
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 20,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 14,
+                      .tm_hour = 3,
+                      .tm_mday = 20,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 
   {
     // 2038-02-19 03:14:07 tests overflow of the month in 2038.
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::FEBRUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 14,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::FEBRUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 
   {
     // 2039-01-19 03:14:07 tests overflow of the year.
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2039), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 14,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2039),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Fails(EOVERFLOW));
   }
 }
@@ -250,12 +307,18 @@ TEST(LlvmLibcMkTime, InvalidEndOf32BitEpochYear) {
 TEST(LlvmLibcMkTime, InvalidMonths) {
   {
     // -1 month from 1970-01-01 00:00:00 returns 1969-12-01 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 0, .tm_mon = -1,
-      .tm_year = tm_year(1970), .tm_wday = 0, .tm_yday = 0, .tm_isdst = 0
-    };
-    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(-32 * TimeConstants::SECONDS_PER_DAY));
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 0,
+                      .tm_mon = -1,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
+    EXPECT_THAT(
+        LIBC_NAMESPACE::mktime(&tm_data),
+        Succeeds(-32 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -270,13 +333,19 @@ TEST(LlvmLibcMkTime, InvalidMonths) {
 
   {
     // 1970-13-01 00:00:00 returns 1971-01-01 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 1, .tm_mon = 12,
-      .tm_year = tm_year(1970), .tm_wday = 0, .tm_yday = 0, .tm_isdst = 0
-    };
-    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(TimeConstants::DAYS_PER_NON_LEAP_YEAR *
-                         TimeConstants::SECONDS_PER_DAY));
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 1,
+                      .tm_mon = 12,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
+    EXPECT_THAT(
+        LIBC_NAMESPACE::mktime(&tm_data),
+        Succeeds(LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR *
+                 LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -293,13 +362,17 @@ TEST(LlvmLibcMkTime, InvalidMonths) {
 TEST(LlvmLibcMkTime, InvalidDays) {
   {
     // -1 day from 1970-01-01 00:00:00 returns 1969-12-31 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = (1 - 1),
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = (1 - 1),
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(-1 * TimeConstants::SECONDS_PER_DAY));
+                Succeeds(-1 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -314,13 +387,17 @@ TEST(LlvmLibcMkTime, InvalidDays) {
 
   {
     // 1970-01-32 00:00:00 returns 1970-02-01 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 32,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 32,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(31 * TimeConstants::SECONDS_PER_DAY));
+                Succeeds(31 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -335,13 +412,17 @@ TEST(LlvmLibcMkTime, InvalidDays) {
 
   {
     // 1970-02-29 00:00:00 returns 1970-03-01 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 29,
-      .tm_mon = Month::FEBRUARY, .tm_year = tm_year(1970), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 29,
+                      .tm_mon = Month::FEBRUARY,
+                      .tm_year = tm_year(1970),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(59 * TimeConstants::SECONDS_PER_DAY));
+                Succeeds(59 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -356,14 +437,20 @@ TEST(LlvmLibcMkTime, InvalidDays) {
 
   {
     // 1972-02-30 00:00:00 returns 1972-03-01 00:00:00.
-    struct tm tm_data {
-      .tm_sec = 0, .tm_min = 0, .tm_hour = 0, .tm_mday = 30,
-      .tm_mon = Month::FEBRUARY, .tm_year = tm_year(1972), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
-    EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(((2 * TimeConstants::DAYS_PER_NON_LEAP_YEAR) + 60) *
-                         TimeConstants::SECONDS_PER_DAY));
+    struct tm tm_data{.tm_sec = 0,
+                      .tm_min = 0,
+                      .tm_hour = 0,
+                      .tm_mday = 30,
+                      .tm_mon = Month::FEBRUARY,
+                      .tm_year = tm_year(1972),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
+    EXPECT_THAT(
+        LIBC_NAMESPACE::mktime(&tm_data),
+        Succeeds(((2 * LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR) +
+                  60) *
+                 LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 0,
                      .tm_min = 0,
                      .tm_hour = 0,
@@ -381,11 +468,15 @@ TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   // Test for maximum value of a signed 32-bit integer.
   // Test implementation can encode time for Tue 19 January 2038 03:14:07 UTC.
   {
-    struct tm tm_data {
-      .tm_sec = 7, .tm_min = 14, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 7,
+                      .tm_min = 14,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(0x7FFFFFFF));
     EXPECT_TM_EQ((tm{.tm_sec = 7,
                      .tm_min = 14,
@@ -403,11 +494,15 @@ TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   {
     // 2038-01-19 03:13:59 tests that even a large seconds field is
     // accepted if the minutes field is smaller.
-    struct tm tm_data {
-      .tm_sec = 59, .tm_min = 13, .tm_hour = 3, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 59,
+                      .tm_min = 13,
+                      .tm_hour = 3,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(0x7FFFFFFF - 8));
     EXPECT_TM_EQ((tm{.tm_sec = 59,
                      .tm_min = 13,
@@ -424,13 +519,18 @@ TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   {
     // 2038-01-19 02:59:59 tests that large seconds and minutes are
     // accepted if the hours field is smaller.
-    struct tm tm_data {
-      .tm_sec = 59, .tm_min = 59, .tm_hour = 2, .tm_mday = 19,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 59,
+                      .tm_min = 59,
+                      .tm_hour = 2,
+                      .tm_mday = 19,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN));
+                Succeeds(0x7FFFFFFF - 8 -
+                         14 * LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN));
     EXPECT_TM_EQ((tm{.tm_sec = 59,
                      .tm_min = 59,
                      .tm_hour = 2,
@@ -446,14 +546,19 @@ TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   {
     // 2038-01-18 23:59:59 tests that large seconds, minutes and hours
     // are accepted if the days field is smaller.
-    struct tm tm_data {
-      .tm_sec = 59, .tm_min = 59, .tm_hour = 23, .tm_mday = 18,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2038), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 59,
+                      .tm_min = 59,
+                      .tm_hour = 23,
+                      .tm_mday = 18,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2038),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN -
-                         3 * TimeConstants::SECONDS_PER_HOUR));
+                Succeeds(0x7FFFFFFF - 8 -
+                         14 * LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN -
+                         3 * LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR));
     EXPECT_TM_EQ((tm{.tm_sec = 59,
                      .tm_min = 59,
                      .tm_hour = 23,
@@ -469,15 +574,20 @@ TEST(LlvmLibcMkTime, EndOf32BitEpochYear) {
   {
     // 2038-01-18 23:59:59 tests that the final second of 2037 is
     // accepted.
-    struct tm tm_data {
-      .tm_sec = 59, .tm_min = 59, .tm_hour = 23, .tm_mday = 31,
-      .tm_mon = Month::DECEMBER, .tm_year = tm_year(2037), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 59,
+                      .tm_min = 59,
+                      .tm_hour = 23,
+                      .tm_mday = 31,
+                      .tm_mon = Month::DECEMBER,
+                      .tm_year = tm_year(2037),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data),
-                Succeeds(0x7FFFFFFF - 8 - 14 * TimeConstants::SECONDS_PER_MIN -
-                         3 * TimeConstants::SECONDS_PER_HOUR -
-                         18 * TimeConstants::SECONDS_PER_DAY));
+                Succeeds(0x7FFFFFFF - 8 -
+                         14 * LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN -
+                         3 * LIBC_NAMESPACE::time_constants::SECONDS_PER_HOUR -
+                         18 * LIBC_NAMESPACE::time_constants::SECONDS_PER_DAY));
     EXPECT_TM_EQ((tm{.tm_sec = 59,
                      .tm_min = 59,
                      .tm_hour = 23,
@@ -496,11 +606,15 @@ TEST(LlvmLibcMkTime, Max64BitYear) {
     return;
   {
     // Mon Jan 1 12:50:50 2170 (200 years from 1970),
-    struct tm tm_data {
-      .tm_sec = 50, .tm_min = 50, .tm_hour = 12, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2170), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 50,
+                      .tm_min = 50,
+                      .tm_hour = 12,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2170),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(6311479850));
     EXPECT_TM_EQ((tm{.tm_sec = 50,
                      .tm_min = 50,
@@ -516,11 +630,15 @@ TEST(LlvmLibcMkTime, Max64BitYear) {
 
   {
     // Test for Tue Jan 1 12:50:50 in 2,147,483,647th year.
-    struct tm tm_data {
-      .tm_sec = 50, .tm_min = 50, .tm_hour = 12, .tm_mday = 1,
-      .tm_mon = Month::JANUARY, .tm_year = tm_year(2147483647), .tm_wday = 0,
-      .tm_yday = 0, .tm_isdst = 0
-    };
+    struct tm tm_data{.tm_sec = 50,
+                      .tm_min = 50,
+                      .tm_hour = 12,
+                      .tm_mday = 1,
+                      .tm_mon = Month::JANUARY,
+                      .tm_year = tm_year(2147483647),
+                      .tm_wday = 0,
+                      .tm_yday = 0,
+                      .tm_isdst = 0};
     EXPECT_THAT(LIBC_NAMESPACE::mktime(&tm_data), Succeeds(67767976202043050));
     EXPECT_TM_EQ((tm{.tm_sec = 50,
                      .tm_min = 50,
diff --git a/test/src/time/nanosleep_test.cpp b/test/src/time/nanosleep_test.cpp
index 2a6eea4..d4f98e2 100644
--- a/test/src/time/nanosleep_test.cpp
+++ b/test/src/time/nanosleep_test.cpp
@@ -6,8 +6,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <time.h>
-
+#include "hdr/types/struct_timespec.h"
 #include "src/errno/libc_errno.h"
 #include "src/time/nanosleep.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
diff --git a/test/src/time/strftime_test.cpp b/test/src/time/strftime_test.cpp
new file mode 100644
index 0000000..cac7560
--- /dev/null
+++ b/test/src/time/strftime_test.cpp
@@ -0,0 +1,2328 @@
+//===-- Unittests for strftime --------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/struct_tm.h"
+#include "src/__support/CPP/array.h"
+#include "src/__support/integer_to_string.h"
+#include "src/time/strftime.h"
+#include "src/time/time_constants.h"
+#include "test/UnitTest/Test.h"
+
+// Copied from sprintf_test.cpp.
+// TODO: put this somewhere more reusable, it's handy.
+// Subtract 1 from sizeof(expected_str) to account for the null byte.
+#define EXPECT_STREQ_LEN(actual_written, actual_str, expected_str)             \
+  EXPECT_EQ(actual_written, sizeof(expected_str) - 1);                         \
+  EXPECT_STREQ(actual_str, expected_str);
+
+constexpr int get_adjusted_year(int year) {
+  // tm_year counts years since 1900, so subtract 1900 to get the tm_year for a
+  // given raw year.
+  return year - LIBC_NAMESPACE::time_constants::TIME_YEAR_BASE;
+}
+
+// TODO: Move this somewhere it can be reused. It seems like a useful tool to
+// have.
+// A helper class to generate simple padded numbers. It places the result in its
+// internal buffer, which is cleared on every call.
+class SimplePaddedNum {
+  static constexpr int BUFF_LEN = 16;
+  char buff[BUFF_LEN];
+  size_t cur_len; // length of string currently in buff
+
+  void clear_buff() {
+    // TODO: builtin_memset?
+    for (int i = 0; i < BUFF_LEN; ++i)
+      buff[i] = '\0';
+  }
+
+public:
+  SimplePaddedNum() = default;
+
+  // PRECONDITIONS: 0 < num < 2**31, min_width < 16
+  // Returns: Pointer to the start of the padded number as a string, stored in
+  // the internal buffer.
+  char *get_padded_num(int num, size_t min_width, char padding_char = '0') {
+    clear_buff();
+
+    // we're not handling the negative sign here, so padding on negative numbers
+    // will be incorrect. For this use case I consider that to be a reasonable
+    // tradeoff for simplicity. This is more meant for the cases where we can
+    // loop through all the possibilities, and for time those are all positive.
+    LIBC_NAMESPACE::IntegerToString<int> raw(num);
+    auto str = raw.view();
+    int leading_zeroes = static_cast<int>(min_width - raw.size());
+
+    int i = 0;
+    for (; static_cast<int>(i) < leading_zeroes; ++i)
+      buff[i] = padding_char;
+    for (size_t str_cur = 0, e = str.size(); str_cur < e; ++i, ++str_cur)
+      buff[i] = str[str_cur];
+    cur_len = i;
+    return buff;
+  }
+
+  size_t get_str_len() { return cur_len; }
+};
+
+TEST(LlvmLibcStrftimeTest, ConstantConversions) {
+  // this tests %n, %t, and %%, which read nothing.
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%n", &time);
+  EXPECT_STREQ_LEN(written, buffer, "\n");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%t", &time);
+  EXPECT_STREQ_LEN(written, buffer, "\t");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%%", &time);
+  EXPECT_STREQ_LEN(written, buffer, "%");
+}
+
+TEST(LlvmLibcStrftimeTest, CenturyTests) {
+  // this tests %C, which reads: [tm_year]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // basic tests
+  time.tm_year = get_adjusted_year(2022);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "20");
+
+  time.tm_year = get_adjusted_year(11900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "119");
+
+  time.tm_year = get_adjusted_year(1900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "19");
+
+  time.tm_year = get_adjusted_year(900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "09");
+
+  time.tm_year = get_adjusted_year(0);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00");
+
+  // This case does not match what glibc does.
+  // Both the C standard and Posix say %C is "Replaced by the year divided by
+  // 100 and truncated to an integer, as a decimal number."
+  // What glibc does is it returns the century for the provided year.
+  // The difference is that glibc returns "-1" as the century for year -1, and
+  // "-2" for year -101.
+  // This case demonstrates that LLVM-libc instead just divides by 100, and
+  // returns the result. "00" for year -1, and "-1" for year -101.
+  // Personally, neither of these really feels right. Posix has a table of
+  // examples where it treats "%C%y" as identical to "%Y". Neither of these
+  // behaviors would handle that properly, you'd either get "-199" or "0099"
+  // (since %y always returns a number in the range [00-99]).
+  time.tm_year = get_adjusted_year(-1);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00");
+
+  time.tm_year = get_adjusted_year(-101);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-1");
+
+  time.tm_year = get_adjusted_year(-9001);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-90");
+
+  time.tm_year = get_adjusted_year(-10001);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-100");
+
+  // width tests (with the 0 flag, since the default padding is undefined).
+  time.tm_year = get_adjusted_year(2023);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "20");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "20");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00020");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000000020");
+
+  time.tm_year = get_adjusted_year(900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "9");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00009");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000000009");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000000123");
+
+  time.tm_year = get_adjusted_year(-123);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-1");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-1");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-0001");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-000000001");
+
+  // '+' flag tests
+  time.tm_year = get_adjusted_year(2023);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "20");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+2C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "20");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0020");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000000020");
+
+  time.tm_year = get_adjusted_year(900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "9");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+2C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0009");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000000009");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+2C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000000123");
+
+  time.tm_year = get_adjusted_year(-123);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-1");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+2C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-1");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-0001");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-000000001");
+
+  // Posix specified tests:
+  time.tm_year = get_adjusted_year(17);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00");
+
+  time.tm_year = get_adjusted_year(270);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "02");
+
+  time.tm_year = get_adjusted_year(270);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+3C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+02");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+3C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+123");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%04C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0123");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+123");
+
+  time.tm_year = get_adjusted_year(123456);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%06C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "001234");
+
+  time.tm_year = get_adjusted_year(123456);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+6C", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+01234");
+}
+
+TEST(LlvmLibcStrftimeTest, TwoDigitDayOfMonth) {
+  using LIBC_NAMESPACE::time_constants::MAX_DAYS_PER_MONTH;
+  // this tests %d, which reads: [tm_mday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 1; i <= MAX_DAYS_PER_MONTH; ++i) {
+    time.tm_mday = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%d", &time);
+    char *result = spn.get_padded_num(i, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, size_t(2));
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_mday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_mday = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05d", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00031");
+}
+
+TEST(LlvmLibcStrftimeTest, MinDigitDayOfMonth) {
+  // this tests %e, which reads: [tm_mday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 1; i < 32; ++i) {
+    time.tm_mday = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%e", &time);
+    char *result = spn.get_padded_num(i, 2, ' ');
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_mday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_mday = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05e", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00031");
+}
+
+TEST(LlvmLibcStrftimeTest, ISOYearOfCentury) {
+  // this tests %g, which reads: [tm_year, tm_wday, tm_yday]
+
+  // A brief primer on ISO dates:
+  // 1) ISO weeks start on Monday and end on Sunday
+  // 2) ISO years start on the Monday of the 1st ISO week of the year
+  // 3) The 1st ISO week of the ISO year has the 4th day of the Gregorian year.
+
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // a sunday in the middle of the year. No need to worry about rounding
+  time.tm_wday = 0;
+  time.tm_yday = 100;
+
+  // Test the easy cases
+  for (int i = 0; i < 102; ++i) {
+    time.tm_year = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%g", &time);
+    char *result = spn.get_padded_num(i % 100, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // Test the harder to round cases
+
+  // not a leap year. Not relevant for the start-of-year tests, but it does
+  // matter for the end-of-year tests.
+  time.tm_year = 99;
+
+  /*
+This table has an X for each day that should be in the previous year,
+everywhere else should be in the current year.
+
+       yday
+      0123456
+  i 1         Monday
+  s 2         Tuesday
+  o 3         Wednesday
+  w 4         Thursday
+  d 5 X       Friday
+  a 6 XX      Saturday
+  y 7 XXX     Sunday
+*/
+
+  // check the first days of the year
+  for (int yday = 0; yday < 5; ++yday) {
+    for (int iso_wday = LIBC_NAMESPACE::time_constants::MONDAY; iso_wday < 8;
+         ++iso_wday) {
+      // start with monday, to match the ISO week.
+      time.tm_wday = iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      time.tm_yday = yday;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%g", &time);
+
+      if (iso_wday <= LIBC_NAMESPACE::time_constants::THURSDAY || yday >= 3) {
+        // monday - thursday are never in the previous year, nor are the 4th and
+        // after.
+        EXPECT_STREQ_LEN(written, buffer, "99");
+      } else {
+        // iso_wday is 5, 6, or 7 and yday is 0, 1, or 2.
+        // days_since_thursday is therefor 1, 2, or 3.
+        const int days_since_thursday =
+            iso_wday - LIBC_NAMESPACE::time_constants::THURSDAY;
+
+        if (days_since_thursday > yday) {
+          EXPECT_STREQ_LEN(written, buffer, "98");
+        } else {
+          EXPECT_STREQ_LEN(written, buffer, "99");
+        }
+      }
+    }
+  }
+
+  /*
+  Similar to above, but the Xs represent being in the NEXT year. Also the
+  top counts down until the end of the year.
+
+    year end - yday
+        6543210
+    i 1     XXX Monday
+    s 2      XX Tuesday
+    o 3       X Wednesday
+    w 4         Thursday
+    d 5         Friday
+    a 6         Saturday
+    y 7         Sunday
+
+
+  If we place the charts next to each other, you can more easily see the
+  pattern:
+
+year end - yday yday
+        6543210 0123456
+    i 1     XXX         Monday
+    s 2      XX         Tuesday
+    o 3       X         Wednesday
+    w 4                 Thursday
+    d 5         X       Friday
+    a 6         XX      Saturday
+    y 7         XXX     Sunday
+
+    From this we can see that thursday is always in the same ISO and regular
+    year, because the ISO year starts on the week with the 4th. Since Thursday
+    is at least 3 days from either edge of the ISO week, the first thursday of
+    the year is always in the first ISO week of the year.
+  */
+
+  // set up all the extra stuff to cover leap years.
+  struct tm time_leap_year;
+  char buffer_leap_year[100];
+  size_t written_leap_year = 0;
+  time_leap_year = time;
+  time_leap_year.tm_year = 100; // 2000 is a leap year.
+
+  // check the last days of the year. Checking 5 to make sure all the leap year
+  // cases are covered as well.
+  for (int days_left = 0; days_left < 5; ++days_left) {
+    for (int iso_wday = LIBC_NAMESPACE::time_constants::MONDAY; iso_wday < 8;
+         ++iso_wday) {
+      // start with monday, to match the ISO week.
+      time.tm_wday = iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      // subtract 1 from the max yday to handle yday being 0-indexed.
+      time.tm_yday = LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR -
+                     1 - days_left;
+
+      time_leap_year.tm_wday =
+          iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      time_leap_year.tm_yday =
+          LIBC_NAMESPACE::time_constants::LAST_DAY_OF_LEAP_YEAR - days_left;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%g", &time);
+      written_leap_year = LIBC_NAMESPACE::strftime(
+          buffer_leap_year, sizeof(buffer_leap_year), "%g", &time_leap_year);
+
+      if (iso_wday >= LIBC_NAMESPACE::time_constants::THURSDAY ||
+          days_left >= 3) {
+        // thursday - sunday are never in the next year, nor are days more than
+        // 3 days before the end.
+        EXPECT_STREQ_LEN(written, buffer, "99");
+        EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "00");
+      } else {
+        // iso_wday is 1, 2 or 3 and days_left is 0, 1, or 2
+        if (iso_wday + days_left <= 3) {
+          EXPECT_STREQ_LEN(written, buffer, "00");
+          EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "01");
+        } else {
+          EXPECT_STREQ_LEN(written, buffer, "99");
+          EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "00");
+        }
+      }
+    }
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_year = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_year = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05g", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00031");
+}
+
+TEST(LlvmLibcStrftimeTest, ISOYear) {
+  // this tests %G, which reads: [tm_year, tm_wday, tm_yday]
+
+  // This stuff is all the same as above, but for brevity I'm not going to
+  // duplicate all the comments explaining exactly how ISO years work. The
+  // general comments are still here though.
+
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // a sunday in the middle of the year. No need to worry about rounding
+  time.tm_wday = 0;
+  time.tm_yday = 100;
+
+  // Test the easy cases
+  for (int i = 1; i < 10000; ++i) {
+    time.tm_year = get_adjusted_year(i);
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%G", &time);
+    char *result = spn.get_padded_num(i, 4);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // also check it handles years with extra digits properly
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  // Test the harder to round cases
+
+  // not a leap year. Not relevant for the start-of-year tests, but it does
+  // matter for the end-of-year tests.
+  time.tm_year = get_adjusted_year(1999);
+
+  // check the first days of the year
+  for (int yday = 0; yday < 5; ++yday) {
+    for (int iso_wday = 1; iso_wday < 8; ++iso_wday) {
+      // start with monday, to match the ISO week.
+      time.tm_wday = iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      time.tm_yday = yday;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%G", &time);
+
+      if (iso_wday <= LIBC_NAMESPACE::time_constants::THURSDAY || yday >= 4) {
+        // monday - thursday are never in the previous year, nor are the 4th and
+        // after.
+        EXPECT_STREQ_LEN(written, buffer, "1999");
+      } else {
+        // iso_wday is 5, 6, or 7 and yday is 0, 1, or 2.
+        // days_since_thursday is therefor 1, 2, or 3.
+        const int days_since_thursday =
+            iso_wday - LIBC_NAMESPACE::time_constants::THURSDAY;
+
+        if (days_since_thursday > yday) {
+          EXPECT_STREQ_LEN(written, buffer, "1998");
+        } else {
+          EXPECT_STREQ_LEN(written, buffer, "1999");
+        }
+      }
+    }
+  }
+
+  // set up all the extra stuff to cover leap years.
+  struct tm time_leap_year;
+  char buffer_leap_year[100];
+  size_t written_leap_year = 0;
+  time_leap_year = time;
+  time_leap_year.tm_year = 100; // 2000 is a leap year.
+
+  // check the last days of the year. Checking 5 to make sure all the leap year
+  // cases are covered as well.
+  for (int days_left = 0; days_left < 5; ++days_left) {
+    for (int iso_wday = 1; iso_wday < 8; ++iso_wday) {
+      // start with monday, to match the ISO week.
+      time.tm_wday = iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      // subtract 1 from the max yday to handle yday being 0-indexed.
+      time.tm_yday =
+          LIBC_NAMESPACE::time_constants::LAST_DAY_OF_NON_LEAP_YEAR - days_left;
+
+      time_leap_year.tm_wday =
+          iso_wday % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      time_leap_year.tm_yday =
+          LIBC_NAMESPACE::time_constants::LAST_DAY_OF_LEAP_YEAR - days_left;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%G", &time);
+      written_leap_year = LIBC_NAMESPACE::strftime(
+          buffer_leap_year, sizeof(buffer_leap_year), "%G", &time_leap_year);
+
+      if (iso_wday >= 4 || days_left >= 3) {
+        // thursday - sunday are never in the next year, nor are days more than
+        // 3 days before the end.
+        EXPECT_STREQ_LEN(written, buffer, "1999");
+        EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "2000");
+      } else {
+        // iso_wday is 1, 2 or 3 and days_left is 0, 1, or 2
+        if (iso_wday + days_left <= 3) {
+          EXPECT_STREQ_LEN(written, buffer, "2000");
+          EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "2001");
+        } else {
+          EXPECT_STREQ_LEN(written, buffer, "1999");
+          EXPECT_STREQ_LEN(written_leap_year, buffer_leap_year, "2000");
+        }
+      }
+    }
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_year = get_adjusted_year(5);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_year = get_adjusted_year(31);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00031");
+
+  time.tm_year = get_adjusted_year(2001);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2001");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2001");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05G", &time);
+  EXPECT_STREQ_LEN(written, buffer, "02001");
+}
+
+TEST(LlvmLibcStrftimeTest, TwentyFourHour) {
+  // this tests %H, which reads: [tm_hour]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 0; i < 24; ++i) {
+    time.tm_hour = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%H", &time);
+    char *result = spn.get_padded_num(i, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_hour = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_hour = 23;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "23");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "23");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05H", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00023");
+}
+
+TEST(LlvmLibcStrftimeTest, TwelveHour) {
+  // this tests %I, which reads: [tm_hour]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  time.tm_hour = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  // Tests on all the well defined values, except 0 since it was easier to
+  // special case it.
+  for (int i = 1; i <= 12; ++i) {
+    char *result = spn.get_padded_num(i, 2);
+
+    time.tm_hour = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%I", &time);
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+
+    // hour + 12 should give the same result
+    time.tm_hour = i + 12;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%I", &time);
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_hour = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_hour = 23;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05I", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00011");
+}
+
+TEST(LlvmLibcStrftimeTest, DayOfYear) {
+  // this tests %j, which reads: [tm_yday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 0; i < LIBC_NAMESPACE::time_constants::DAYS_PER_LEAP_YEAR; ++i) {
+    time.tm_yday = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%j", &time);
+    char *result = spn.get_padded_num(i + 1, 3);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_yday = 5 - 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_yday = 123 - 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05j", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00123");
+}
+
+TEST(LlvmLibcStrftimeTest, MonthOfYear) {
+  // this tests %m, which reads: [tm_mon]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 0; i < LIBC_NAMESPACE::time_constants::MONTHS_PER_YEAR; ++i) {
+    time.tm_mon = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%m", &time);
+    // %m is 1 indexed, so add 1 to the number we're comparing to.
+    char *result = spn.get_padded_num(i + 1, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_mon = 5 - 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_mon = 11 - 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05m", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00011");
+}
+
+TEST(LlvmLibcStrftimeTest, MinuteOfHour) {
+  // this tests %M, which reads: [tm_min]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 0; i < LIBC_NAMESPACE::time_constants::MINUTES_PER_HOUR; ++i) {
+    time.tm_min = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%M", &time);
+    char *result = spn.get_padded_num(i, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_min = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_min = 11;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05M", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00011");
+}
+
+TEST(LlvmLibcStrftimeTest, SecondsSinceEpoch) {
+  // this tests %s, which reads: [tm_year, tm_mon, tm_mday, tm_hour, tm_min,
+  // tm_sec, tm_isdst]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  time.tm_year = get_adjusted_year(1970);
+  // yday is not used, the day of the year is calculated from the month and mday
+  time.tm_mon = 0;
+  time.tm_mday = 1; // the only 1-indexed member
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  time.tm_sec = 1;
+  time.tm_isdst = 0;
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "1");
+
+  // The time as of writing this test
+  time.tm_year = get_adjusted_year(2025);
+  time.tm_mon = 1;
+  time.tm_mday = 4;
+  time.tm_hour = 11;
+  time.tm_min = 8;
+  time.tm_sec = 41;
+  time.tm_isdst = 0;
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%s", &time);
+  // if you run your system's strftime to compare you will likely get a slightly
+  // different result because it's supposed to respect timezones.
+  EXPECT_STREQ_LEN(written, buffer, "1738667321");
+
+  // Thorough testing of the mktime mechanism is done in the mktime tests, so
+  // they aren't duplicated here.
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_year = get_adjusted_year(1970);
+  time.tm_mon = 0;
+  time.tm_mday = 1;
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  time.tm_sec = 5;
+  time.tm_isdst = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_min = 11;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "665");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "665");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05s", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00665");
+}
+
+TEST(LlvmLibcStrftimeTest, SecondOfMinute) {
+  // this tests %S, which reads: [tm_sec]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values
+  for (int i = 0; i < LIBC_NAMESPACE::time_constants::SECONDS_PER_MIN; ++i) {
+    time.tm_sec = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%S", &time);
+    char *result = spn.get_padded_num(i, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_sec = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+
+  time.tm_sec = 11;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05S", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00011");
+}
+
+TEST(LlvmLibcStrftimeTest, ISODayOfWeek) {
+  // this tests %u, which reads: [tm_wday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SUNDAY;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%u", &time);
+  EXPECT_STREQ_LEN(written, buffer, "7");
+
+  // Tests on all the well defined values except for sunday, which is 0 in
+  // normal weekdays but 7 here.
+  for (int i = LIBC_NAMESPACE::time_constants::MONDAY;
+       i <= LIBC_NAMESPACE::time_constants::SATURDAY; ++i) {
+    time.tm_wday = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%u", &time);
+    char *result = spn.get_padded_num(i, 1);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01u", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02u", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05u", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+}
+
+TEST(LlvmLibcStrftimeTest, WeekOfYearStartingSunday) {
+  // this tests %U, which reads: [tm_year, tm_wday, tm_yday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // setting the year to a leap year, but it doesn't actually matter. This
+  // conversion doesn't end up checking the year at all.
+  time.tm_year = get_adjusted_year(2000);
+
+  const int WEEK_START = LIBC_NAMESPACE::time_constants::SUNDAY;
+
+  for (int first_weekday = LIBC_NAMESPACE::time_constants::SUNDAY;
+       first_weekday <= LIBC_NAMESPACE::time_constants::SATURDAY;
+       ++first_weekday) {
+    time.tm_wday = first_weekday;
+    int cur_week = 0;
+
+    // iterate through the year, starting on first_weekday.
+    for (int yday = 0;
+         yday < LIBC_NAMESPACE::time_constants::DAYS_PER_LEAP_YEAR; ++yday) {
+      time.tm_yday = yday;
+      // If the week just ended, move to the next week.
+      if (time.tm_wday == WEEK_START)
+        ++cur_week;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%U", &time);
+      char *result = spn.get_padded_num(cur_week, 2);
+
+      ASSERT_STREQ(buffer, result);
+      ASSERT_EQ(written, spn.get_str_len());
+
+      // a day has passed, move to the next weekday, looping as necessary.
+      time.tm_wday =
+          (time.tm_wday + 1) % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+    }
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SUNDAY;
+  time.tm_yday = 22;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00004");
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SUNDAY;
+  time.tm_yday = 78;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00012");
+}
+
+TEST(LlvmLibcStrftimeTest, ISOWeekOfYear) {
+  // this tests %V, which reads: [tm_year, tm_wday, tm_yday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  const int starting_year = get_adjusted_year(1999);
+
+  // we're going to check the days from 1999 to 2001 to cover all the
+  // transitions to and from leap years and non-leap years (the start of 1999
+  // and end of 2001 cover the non-leap years).
+  const int days_to_check = // 1096
+      LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR +
+      LIBC_NAMESPACE::time_constants::DAYS_PER_LEAP_YEAR +
+      LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR;
+
+  const int WEEK_START = LIBC_NAMESPACE::time_constants::MONDAY;
+
+  for (int first_weekday = LIBC_NAMESPACE::time_constants::SUNDAY;
+       first_weekday <= LIBC_NAMESPACE::time_constants::SATURDAY;
+       ++first_weekday) {
+    time.tm_year = starting_year;
+    time.tm_wday = first_weekday;
+    time.tm_yday = 0;
+    int cur_week = 1;
+    if (first_weekday == LIBC_NAMESPACE::time_constants::SUNDAY ||
+        first_weekday == LIBC_NAMESPACE::time_constants::SATURDAY)
+      cur_week = 52;
+    else if (first_weekday == LIBC_NAMESPACE::time_constants::FRIDAY)
+      cur_week = 53;
+
+    // iterate through the year, starting on first_weekday.
+    for (size_t cur_day = 0; cur_day < days_to_check; ++cur_day) {
+      // If the week just ended, move to the next week.
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%V", &time);
+      char *result = spn.get_padded_num(cur_week, 2);
+
+      ASSERT_STREQ(buffer, result);
+      ASSERT_EQ(written, spn.get_str_len());
+
+      // a day has passed, increment the counters.
+      ++time.tm_yday;
+      if (time.tm_yday ==
+          (time.tm_year == get_adjusted_year(2000)
+               ? LIBC_NAMESPACE::time_constants::DAYS_PER_LEAP_YEAR
+               : LIBC_NAMESPACE::time_constants::DAYS_PER_NON_LEAP_YEAR)) {
+        time.tm_yday = 0;
+        ++time.tm_year;
+      }
+
+      time.tm_wday =
+          (time.tm_wday + 1) % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+      if (time.tm_wday == WEEK_START) {
+        ++cur_week;
+        const int days_left_in_year =
+            (time.tm_year == get_adjusted_year(2000)
+                 ? LIBC_NAMESPACE::time_constants::LAST_DAY_OF_LEAP_YEAR
+                 : LIBC_NAMESPACE::time_constants::LAST_DAY_OF_NON_LEAP_YEAR) -
+            time.tm_yday;
+
+        // if the week we're currently in is in the next year, or if the year
+        // has turned over, reset the week.
+        if (days_left_in_year < 3 || (cur_week > 51 && time.tm_yday < 10))
+          cur_week = 1;
+      }
+    }
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SUNDAY;
+  time.tm_yday = 22;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00004");
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SUNDAY;
+  time.tm_yday = 78;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05U", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00012");
+}
+
+TEST(LlvmLibcStrftimeTest, DayOfWeek) {
+  // this tests %w, which reads: [tm_wday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Tests on all the well defined values.
+  for (int i = LIBC_NAMESPACE::time_constants::SUNDAY;
+       i <= LIBC_NAMESPACE::time_constants::SATURDAY; ++i) {
+    time.tm_wday = i;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%w", &time);
+    char *result = spn.get_padded_num(i, 1);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01w", &time);
+  EXPECT_STREQ_LEN(written, buffer, "5");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02w", &time);
+  EXPECT_STREQ_LEN(written, buffer, "05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05w", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00005");
+}
+
+TEST(LlvmLibcStrftimeTest, WeekOfYearStartingMonday) {
+  // this tests %W, which reads: [tm_year, tm_wday, tm_yday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // setting the year to a leap year, but it doesn't actually matter. This
+  // conversion doesn't end up checking the year at all.
+  time.tm_year = get_adjusted_year(2000);
+
+  const int WEEK_START = LIBC_NAMESPACE::time_constants::MONDAY;
+
+  for (int first_weekday = LIBC_NAMESPACE::time_constants::SUNDAY;
+       first_weekday <= LIBC_NAMESPACE::time_constants::SATURDAY;
+       ++first_weekday) {
+    time.tm_wday = first_weekday;
+    int cur_week = 0;
+
+    // iterate through the year, starting on first_weekday.
+    for (int yday = 0;
+         yday < LIBC_NAMESPACE::time_constants::DAYS_PER_LEAP_YEAR; ++yday) {
+      time.tm_yday = yday;
+      // If the week just ended, move to the next week.
+      if (time.tm_wday == WEEK_START)
+        ++cur_week;
+
+      written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%W", &time);
+      char *result = spn.get_padded_num(cur_week, 2);
+
+      ASSERT_STREQ(buffer, result);
+      ASSERT_EQ(written, spn.get_str_len());
+
+      // a day has passed, move to the next weekday, looping as necessary.
+      time.tm_wday =
+          (time.tm_wday + 1) % LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK;
+    }
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = LIBC_NAMESPACE::time_constants::MONDAY;
+  time.tm_yday = 22;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00004");
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::MONDAY;
+  time.tm_yday = 78;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05W", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00012");
+}
+
+TEST(LlvmLibcStrftimeTest, YearOfCentury) {
+  // this tests %y, which reads: [tm_year]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  time.tm_year = get_adjusted_year(2000);
+
+  // iterate through the year, starting on first_weekday.
+  for (int year = 1900; year < 2001; ++year) {
+    time.tm_year = get_adjusted_year(year);
+
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%y", &time);
+    char *result = spn.get_padded_num(year % 100, 2);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_year = get_adjusted_year(2004);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00004");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "45");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%02y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "45");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00045");
+}
+
+TEST(LlvmLibcStrftimeTest, FullYearTests) {
+  // this tests %Y, which reads: [tm_year]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+  SimplePaddedNum spn;
+
+  // Test the easy cases
+  for (int i = 1; i < 10000; ++i) {
+    time.tm_year = get_adjusted_year(i);
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+    char *result = spn.get_padded_num(i, 4);
+
+    ASSERT_STREQ(buffer, result);
+    ASSERT_EQ(written, spn.get_str_len());
+  }
+
+  time.tm_year = get_adjusted_year(11900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "11900");
+
+  time.tm_year = get_adjusted_year(0);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000");
+
+  time.tm_year = get_adjusted_year(-1);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  // TODO: should this be what we standardize? Posix doesn't specify what to do
+  // about negative numbers
+  EXPECT_STREQ_LEN(written, buffer, "-001");
+
+  time.tm_year = get_adjusted_year(-9001);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-9001");
+
+  time.tm_year = get_adjusted_year(-10001);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-10001");
+
+  // width tests (with the 0 flag, since the default padding is undefined).
+  time.tm_year = get_adjusted_year(2023);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%04Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "02023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000002023");
+
+  time.tm_year = get_adjusted_year(900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%04Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000000900");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%04Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0000012345");
+
+  time.tm_year = get_adjusted_year(-123);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%04Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-0123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-000000123");
+
+  // '+' flag tests
+  time.tm_year = get_adjusted_year(2023);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+2023");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000002023");
+
+  time.tm_year = get_adjusted_year(900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0900");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000000900");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+000012345");
+
+  time.tm_year = get_adjusted_year(-123);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-0123");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-000000123");
+
+  // Posix specified tests:
+  time.tm_year = get_adjusted_year(1970);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "1970");
+
+  time.tm_year = get_adjusted_year(1970);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "1970");
+
+  time.tm_year = get_adjusted_year(27);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0027");
+
+  time.tm_year = get_adjusted_year(270);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0270");
+
+  time.tm_year = get_adjusted_year(270);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0270");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+4Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345");
+
+  time.tm_year = get_adjusted_year(270);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0270");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+5Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%06Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "012345");
+
+  time.tm_year = get_adjusted_year(12345);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+6Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345");
+
+  time.tm_year = get_adjusted_year(123456);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%08Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00123456");
+
+  time.tm_year = get_adjusted_year(123456);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+8Y", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+0123456");
+}
+
+// String conversions
+
+struct num_str_pair {
+  int num;
+  LIBC_NAMESPACE::cpp::string_view str;
+};
+
+TEST(LlvmLibcStrftimeTest, ShortWeekdayName) {
+  // this tests %a, which reads: [tm_wday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  constexpr LIBC_NAMESPACE::cpp::array<
+      num_str_pair, LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK>
+      WEEKDAY_PAIRS = {{
+          {LIBC_NAMESPACE::time_constants::SUNDAY, "Sun"},
+          {LIBC_NAMESPACE::time_constants::MONDAY, "Mon"},
+          {LIBC_NAMESPACE::time_constants::TUESDAY, "Tue"},
+          {LIBC_NAMESPACE::time_constants::WEDNESDAY, "Wed"},
+          {LIBC_NAMESPACE::time_constants::THURSDAY, "Thu"},
+          {LIBC_NAMESPACE::time_constants::FRIDAY, "Fri"},
+          {LIBC_NAMESPACE::time_constants::SATURDAY, "Sat"},
+      }};
+
+  for (size_t i = 0; i < WEEKDAY_PAIRS.size(); ++i) {
+    time.tm_wday = WEEKDAY_PAIRS[i].num;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%a", &time);
+    EXPECT_STREQ(buffer, WEEKDAY_PAIRS[i].str.data());
+    EXPECT_EQ(written, WEEKDAY_PAIRS[i].str.size());
+  }
+
+  // check invalid weekdays
+  time.tm_wday = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SATURDAY + 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = LIBC_NAMESPACE::time_constants::THURSDAY;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Thu");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Thu");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "       Thu");
+
+  time.tm_wday = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  ?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10a", &time);
+  EXPECT_STREQ_LEN(written, buffer, "         ?");
+}
+
+TEST(LlvmLibcStrftimeTest, FullWeekdayName) {
+  // this tests %a, which reads: [tm_wday]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  constexpr LIBC_NAMESPACE::cpp::array<
+      num_str_pair, LIBC_NAMESPACE::time_constants::DAYS_PER_WEEK>
+      WEEKDAY_PAIRS = {{
+          {LIBC_NAMESPACE::time_constants::SUNDAY, "Sunday"},
+          {LIBC_NAMESPACE::time_constants::MONDAY, "Monday"},
+          {LIBC_NAMESPACE::time_constants::TUESDAY, "Tuesday"},
+          {LIBC_NAMESPACE::time_constants::WEDNESDAY, "Wednesday"},
+          {LIBC_NAMESPACE::time_constants::THURSDAY, "Thursday"},
+          {LIBC_NAMESPACE::time_constants::FRIDAY, "Friday"},
+          {LIBC_NAMESPACE::time_constants::SATURDAY, "Saturday"},
+      }};
+
+  for (size_t i = 0; i < WEEKDAY_PAIRS.size(); ++i) {
+    time.tm_wday = WEEKDAY_PAIRS[i].num;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%A", &time);
+    EXPECT_STREQ(buffer, WEEKDAY_PAIRS[i].str.data());
+    EXPECT_EQ(written, WEEKDAY_PAIRS[i].str.size());
+  }
+
+  // check invalid weekdays
+  time.tm_wday = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  time.tm_wday = LIBC_NAMESPACE::time_constants::SATURDAY + 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_wday = LIBC_NAMESPACE::time_constants::THURSDAY;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Thursday");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Thursday");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  Thursday");
+
+  time.tm_wday = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  ?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10A", &time);
+  EXPECT_STREQ_LEN(written, buffer, "         ?");
+}
+
+TEST(LlvmLibcStrftimeTest, ShortMonthName) {
+  // this tests %b, which reads: [tm_mon]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  constexpr LIBC_NAMESPACE::cpp::array<
+      num_str_pair, LIBC_NAMESPACE::time_constants::MONTHS_PER_YEAR>
+      MONTH_PAIRS = {{
+          {LIBC_NAMESPACE::time_constants::JANUARY, "Jan"},
+          {LIBC_NAMESPACE::time_constants::FEBRUARY, "Feb"},
+          {LIBC_NAMESPACE::time_constants::MARCH, "Mar"},
+          {LIBC_NAMESPACE::time_constants::APRIL, "Apr"},
+          {LIBC_NAMESPACE::time_constants::MAY, "May"},
+          {LIBC_NAMESPACE::time_constants::JUNE, "Jun"},
+          {LIBC_NAMESPACE::time_constants::JULY, "Jul"},
+          {LIBC_NAMESPACE::time_constants::AUGUST, "Aug"},
+          {LIBC_NAMESPACE::time_constants::SEPTEMBER, "Sep"},
+          {LIBC_NAMESPACE::time_constants::OCTOBER, "Oct"},
+          {LIBC_NAMESPACE::time_constants::NOVEMBER, "Nov"},
+          {LIBC_NAMESPACE::time_constants::DECEMBER, "Dec"},
+      }};
+
+  for (size_t i = 0; i < MONTH_PAIRS.size(); ++i) {
+    time.tm_mon = MONTH_PAIRS[i].num;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%b", &time);
+    EXPECT_STREQ(buffer, MONTH_PAIRS[i].str.data());
+    EXPECT_EQ(written, MONTH_PAIRS[i].str.size());
+  }
+
+  // check invalid weekdays
+  time.tm_mon = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  time.tm_mon = LIBC_NAMESPACE::time_constants::DECEMBER + 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  // Also test %h, which is identical to %b
+  time.tm_mon = LIBC_NAMESPACE::time_constants::OCTOBER;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%h", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Oct");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_mon = LIBC_NAMESPACE::time_constants::OCTOBER;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Oct");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Oct");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "       Oct");
+
+  time.tm_mon = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  ?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10b", &time);
+  EXPECT_STREQ_LEN(written, buffer, "         ?");
+}
+
+TEST(LlvmLibcStrftimeTest, FullMonthName) {
+  // this tests %B, which reads: [tm_mon]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  constexpr LIBC_NAMESPACE::cpp::array<
+      num_str_pair, LIBC_NAMESPACE::time_constants::MONTHS_PER_YEAR>
+      MONTH_PAIRS = {{
+          {LIBC_NAMESPACE::time_constants::JANUARY, "January"},
+          {LIBC_NAMESPACE::time_constants::FEBRUARY, "February"},
+          {LIBC_NAMESPACE::time_constants::MARCH, "March"},
+          {LIBC_NAMESPACE::time_constants::APRIL, "April"},
+          {LIBC_NAMESPACE::time_constants::MAY, "May"},
+          {LIBC_NAMESPACE::time_constants::JUNE, "June"},
+          {LIBC_NAMESPACE::time_constants::JULY, "July"},
+          {LIBC_NAMESPACE::time_constants::AUGUST, "August"},
+          {LIBC_NAMESPACE::time_constants::SEPTEMBER, "September"},
+          {LIBC_NAMESPACE::time_constants::OCTOBER, "October"},
+          {LIBC_NAMESPACE::time_constants::NOVEMBER, "November"},
+          {LIBC_NAMESPACE::time_constants::DECEMBER, "December"},
+      }};
+
+  for (size_t i = 0; i < MONTH_PAIRS.size(); ++i) {
+    time.tm_mon = MONTH_PAIRS[i].num;
+    written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%B", &time);
+    EXPECT_STREQ(buffer, MONTH_PAIRS[i].str.data());
+    EXPECT_EQ(written, MONTH_PAIRS[i].str.size());
+  }
+
+  // check invalid weekdays
+  time.tm_mon = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  time.tm_mon = LIBC_NAMESPACE::time_constants::DECEMBER + 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_mon = LIBC_NAMESPACE::time_constants::OCTOBER;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "October");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "October");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "   October");
+
+  time.tm_mon = -1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%3B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  ?");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10B", &time);
+  EXPECT_STREQ_LEN(written, buffer, "         ?");
+}
+
+TEST(LlvmLibcStrftimeTest, AM_PM) {
+  // this tests %p, which reads: [tm_hour]
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  time.tm_hour = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "AM");
+
+  time.tm_hour = 6;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "AM");
+
+  time.tm_hour = 12;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "PM");
+
+  time.tm_hour = 18;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "PM");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  time.tm_hour = 6;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "AM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%2p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "AM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "        AM");
+
+  time.tm_hour = 18;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "PM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%2p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "PM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%10p", &time);
+  EXPECT_STREQ_LEN(written, buffer, "        PM");
+}
+
+TEST(LlvmLibcStrftimeTest, DateFormatUS) {
+  // this tests %D, which reads: [tm_mon, tm_mday, tm_year]
+  // This is equivalent to "%m/%d/%y"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of %m, %d, and %y have their own tests, so this test won't cover all
+  // values of those. Instead it will do basic tests and focus on the specific
+  // padding behavior.
+
+  time.tm_mon = 0;  // 0 indexed, so 0 is january
+  time.tm_mday = 2; // 1 indexed, so 2 is the 2nd
+  time.tm_year = get_adjusted_year(1903);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "01/02/03");
+
+  time.tm_mon = 11;
+  time.tm_mday = 31;
+  time.tm_year = get_adjusted_year(1999);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12/31/99");
+
+  // The day LLVM-libc started
+  time.tm_mon = 8;
+  time.tm_mday = 16;
+  time.tm_year = get_adjusted_year(2019);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "09/16/19");
+
+  // %x is equivalent to %D in default locale
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%x", &time);
+  EXPECT_STREQ_LEN(written, buffer, "09/16/19");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  // Padding is handled in the same way as POSIX describes for %F
+  time.tm_mon = 1;
+  time.tm_mday = 5;
+  time.tm_year = get_adjusted_year(2025);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2/05/25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%07D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2/05/25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0002/05/25");
+
+  time.tm_mon = 9;
+  time.tm_mday = 2;
+  time.tm_year = get_adjusted_year(2000);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10/02/00");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%07D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10/02/00");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010D", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0010/02/00");
+}
+
+TEST(LlvmLibcStrftimeTest, DateFormatISO) {
+  // this tests %F, which reads: [tm_year, tm_mon, tm_mday]
+  // This is equivalent to "%Y-%m-%d"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of %Y, %m, and %d have their own tests, so this test won't cover all
+  // values of those. Instead it will do basic tests and focus on the specific
+  // padding behavior.
+
+  time.tm_year = get_adjusted_year(1901);
+  time.tm_mon = 1;  // 0 indexed, so 1 is february
+  time.tm_mday = 3; // 1 indexed, so 2 is the 2nd
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "1901-02-03");
+
+  time.tm_year = get_adjusted_year(1999);
+  time.tm_mon = 11;
+  time.tm_mday = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "1999-12-31");
+
+  time.tm_year = get_adjusted_year(2019);
+  time.tm_mon = 8;
+  time.tm_mday = 16;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2019-09-16");
+
+  time.tm_year = get_adjusted_year(123);
+  time.tm_mon = 3;
+  time.tm_mday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0123-04-05");
+
+  time.tm_year = get_adjusted_year(67);
+  time.tm_mon = 7;
+  time.tm_mday = 9;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0067-08-09");
+
+  time.tm_year = get_adjusted_year(2);
+  time.tm_mon = 1;
+  time.tm_mday = 14;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0002-02-14");
+
+  time.tm_year = get_adjusted_year(-543);
+  time.tm_mon = 1;
+  time.tm_mday = 1;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-543-02-01");
+
+  // padding tests
+  time.tm_year = get_adjusted_year(2025);
+  time.tm_mon = 1;
+  time.tm_mday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2025-02-05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2025-02-05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%012F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "002025-02-05");
+
+  time.tm_year = get_adjusted_year(12345);
+  time.tm_mon = 11;
+  time.tm_mday = 25;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345-12-25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12345-12-25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%012F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "012345-12-25");
+
+  time.tm_year = get_adjusted_year(476);
+  time.tm_mon = 8;
+  time.tm_mday = 4;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "476-09-04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0476-09-04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%012F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "000476-09-04");
+
+  time.tm_year = get_adjusted_year(-100);
+  time.tm_mon = 9;
+  time.tm_mday = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-100-10-31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-100-10-31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%012F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-00100-10-31");
+
+  // '+' flag tests
+  time.tm_year = get_adjusted_year(2025);
+  time.tm_mon = 1;
+  time.tm_mday = 5;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2025-02-05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "2025-02-05");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+12F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+02025-02-05");
+
+  time.tm_year = get_adjusted_year(12345);
+  time.tm_mon = 11;
+  time.tm_mday = 25;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345-12-25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345-12-25");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+12F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+12345-12-25");
+
+  time.tm_year = get_adjusted_year(476);
+  time.tm_mon = 8;
+  time.tm_mday = 4;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "476-09-04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0476-09-04");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+12F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "+00476-09-04");
+
+  time.tm_year = get_adjusted_year(-100);
+  time.tm_mon = 9;
+  time.tm_mday = 31;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+1F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-100-10-31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+10F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-100-10-31");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%+12F", &time);
+  EXPECT_STREQ_LEN(written, buffer, "-00100-10-31");
+}
+
+TEST(LlvmLibcStrftimeTest, TimeFormatAMPM) {
+  // this tests %r, which reads: [tm_hour, tm_min, tm_sec]
+  // This is equivalent to "%I:%M:%S %p"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of %I, %M, %S, and %p have their own tests, so this test won't cover
+  // all values of those. Instead it will do basic tests and focus on the
+  // specific padding behavior.
+
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  time.tm_sec = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "12:00:00 AM");
+
+  time.tm_hour = 1;
+  time.tm_min = 23;
+  time.tm_sec = 45;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "01:23:45 AM");
+
+  time.tm_hour = 18;
+  time.tm_min = 6;
+  time.tm_sec = 2;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "06:06:02 PM");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  // Padding is handled in the same way as POSIX describes for %F
+  time.tm_hour = 10;
+  time.tm_min = 9;
+  time.tm_sec = 59;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09:59 AM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%011r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09:59 AM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%013r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0010:09:59 AM");
+
+  time.tm_hour = 16;
+  time.tm_min = 56;
+  time.tm_sec = 9;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4:56:09 PM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%011r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04:56:09 PM");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%013r", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0004:56:09 PM");
+}
+
+TEST(LlvmLibcStrftimeTest, TimeFormatMinute) {
+  // this tests %R, which reads: [tm_hour, tm_min]
+  // This is equivalent to "%H:%M"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of %H and %M have their own tests, so this test won't cover
+  // all values of those. Instead it will do basic tests and focus on the
+  // specific padding behavior.
+
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00:00");
+
+  time.tm_hour = 1;
+  time.tm_min = 23;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "01:23");
+
+  time.tm_hour = 18;
+  time.tm_min = 6;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "18:06");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  // Padding is handled in the same way as POSIX describes for %F
+  time.tm_hour = 10;
+  time.tm_min = 9;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%07R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0010:09");
+
+  time.tm_hour = 4;
+  time.tm_min = 56;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4:56");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%05R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04:56");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%07R", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0004:56");
+}
+
+TEST(LlvmLibcStrftimeTest, TimeFormatSecond) {
+  // this tests %T, which reads: [tm_hour, tm_min, tm_sec]
+  // This is equivalent to "%H:%M:%S"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of %H, %M, and %S have their own tests, so this test won't cover
+  // all values of those. Instead it will do basic tests and focus on the
+  // specific padding behavior.
+
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  time.tm_sec = 0;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "00:00:00");
+
+  time.tm_hour = 1;
+  time.tm_min = 23;
+  time.tm_sec = 45;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "01:23:45");
+
+  time.tm_hour = 18;
+  time.tm_min = 6;
+  time.tm_sec = 2;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "18:06:02");
+
+  // %X is equivalent to %T in default locale
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%X", &time);
+  EXPECT_STREQ_LEN(written, buffer, "18:06:02");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  // Padding is handled in the same way as POSIX describes for %F
+  time.tm_hour = 10;
+  time.tm_min = 9;
+  time.tm_sec = 59;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09:59");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%08T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "10:09:59");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0010:09:59");
+
+  time.tm_hour = 4;
+  time.tm_min = 56;
+  time.tm_sec = 9;
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%01T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "4:56:09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%08T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "04:56:09");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%010T", &time);
+  EXPECT_STREQ_LEN(written, buffer, "0004:56:09");
+}
+
+TEST(LlvmLibcStrftimeTest, TimeFormatFullDateTime) {
+  // this tests %c, which reads:
+  //  [tm_wday, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_year]
+  // This is equivalent to "%a %b %e %T %Y"
+  struct tm time;
+  char buffer[100];
+  size_t written = 0;
+
+  // each of the individual conversions have their own tests, so this test won't
+  // cover all values of those. Instead it will do basic tests and focus on the
+  // specific padding behavior.
+
+  time.tm_wday = 0;
+  time.tm_mon = 0;
+  time.tm_mday = 1;
+  time.tm_hour = 0;
+  time.tm_min = 0;
+  time.tm_sec = 0;
+  time.tm_year = get_adjusted_year(1900);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Sun Jan  1 00:00:00 1900");
+
+  time.tm_wday = 3;
+  time.tm_mon = 5;
+  time.tm_mday = 15;
+  time.tm_hour = 14;
+  time.tm_min = 13;
+  time.tm_sec = 12;
+  time.tm_year = get_adjusted_year(2011);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Wed Jun 15 14:13:12 2011");
+
+  // now, as of the writing of this test
+  time.tm_wday = 4;
+  time.tm_mon = 1;
+  time.tm_mday = 6;
+  time.tm_hour = 12;
+  time.tm_min = 57;
+  time.tm_sec = 50;
+  time.tm_year = get_adjusted_year(2025);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Thu Feb  6 12:57:50 2025");
+
+  time.tm_wday = 5;
+  time.tm_mon = 8;
+  time.tm_mday = 4;
+  time.tm_hour = 16;
+  time.tm_min = 57;
+  time.tm_sec = 18;
+  time.tm_year = get_adjusted_year(476);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Fri Sep  4 16:57:18 0476");
+
+  // padding is technically undefined for this conversion, but we support it, so
+  // we need to test it.
+  // Padding is handled in the same way as POSIX describes for %F.
+  // This includes assuming the trailing conversions are of a fixed width, which
+  // isn't true for years. For simplicity, we format years (%Y) to be padded to
+  // 4 digits when possible, which means padding will work as expected for years
+  // -999 to 9999. If the current year is large enough to trigger this bug,
+  // congrats on making it another ~8000 years!
+  time.tm_wday = 5;
+  time.tm_mon = 8;
+  time.tm_mday = 4;
+  time.tm_hour = 16;
+  time.tm_min = 57;
+  time.tm_sec = 18;
+  time.tm_year = get_adjusted_year(476);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Fri Sep  4 16:57:18 0476");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%24c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Fri Sep  4 16:57:18 0476");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%26c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  Fri Sep  4 16:57:18 0476");
+
+  // '0' flag has no effect on the string part of the conversion, only the
+  // numbers, and the only one of those that defaults to spaces is day of month.
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%026c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  Fri Sep 04 16:57:18 0476");
+
+  time.tm_wday = 3;
+  time.tm_mon = 5;
+  time.tm_mday = 15;
+  time.tm_hour = 14;
+  time.tm_min = 13;
+  time.tm_sec = 12;
+  time.tm_year = get_adjusted_year(2011);
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%1c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Wed Jun 15 14:13:12 2011");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%24c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "Wed Jun 15 14:13:12 2011");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%26c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  Wed Jun 15 14:13:12 2011");
+
+  written = LIBC_NAMESPACE::strftime(buffer, sizeof(buffer), "%026c", &time);
+  EXPECT_STREQ_LEN(written, buffer, "  Wed Jun 15 14:13:12 2011");
+}
+
+// TODO: implement %z and %Z when timezones are implemented.
+//  TEST(LlvmLibcStrftimeTest, TimezoneOffset) {
+//    // this tests %z, which reads: [tm_isdst, tm_zone]
+//    struct tm time;
+//    char buffer[100];
+//    size_t written = 0;
+//    SimplePaddedNum spn;
+//  }
diff --git a/test/src/time/time_test.cpp b/test/src/time/time_test.cpp
index d3d4dc9..7cdb4e8 100644
--- a/test/src/time/time_test.cpp
+++ b/test/src/time/time_test.cpp
@@ -9,8 +9,6 @@
 #include "src/time/time_func.h"
 #include "test/UnitTest/Test.h"
 
-#include <time.h>
-
 TEST(LlvmLibcTimeTest, SmokeTest) {
   time_t t1;
   time_t t2 = LIBC_NAMESPACE::time(&t1);
diff --git a/test/src/time/timespec_get_test.cpp b/test/src/time/timespec_get_test.cpp
new file mode 100644
index 0000000..327bfef
--- /dev/null
+++ b/test/src/time/timespec_get_test.cpp
@@ -0,0 +1,46 @@
+//===-- Unittests for timespec_get ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/time_macros.h"
+#include "hdr/types/struct_timespec.h"
+#include "src/__support/macros/properties/architectures.h"
+#include "src/time/timespec_get.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcTimespecGet, Utc) {
+  timespec ts;
+  int result;
+  result = LIBC_NAMESPACE::timespec_get(&ts, TIME_UTC);
+#ifdef LIBC_TARGET_ARCH_IS_GPU
+  ASSERT_EQ(result, 0);
+#else
+  ASSERT_EQ(result, TIME_UTC);
+  ASSERT_GT(ts.tv_sec, time_t(0));
+#endif
+}
+
+TEST(LlvmLibcTimespecGet, Monotonic) {
+  timespec ts1, ts2;
+  int result;
+  result = LIBC_NAMESPACE::timespec_get(&ts1, TIME_MONOTONIC);
+  ASSERT_EQ(result, TIME_MONOTONIC);
+  ASSERT_GT(ts1.tv_sec, time_t(0));
+  result = LIBC_NAMESPACE::timespec_get(&ts2, TIME_MONOTONIC);
+  ASSERT_EQ(result, TIME_MONOTONIC);
+  ASSERT_GE(ts2.tv_sec, ts1.tv_sec); // The monotonic time should increase.
+  if (ts2.tv_sec == ts1.tv_sec) {
+    ASSERT_GE(ts2.tv_nsec, ts1.tv_nsec);
+  }
+}
+
+TEST(LlvmLibcTimespecGet, Unknown) {
+  timespec ts;
+  int result;
+  result = LIBC_NAMESPACE::timespec_get(&ts, 0);
+  ASSERT_EQ(result, 0);
+}
diff --git a/test/src/unistd/access_test.cpp b/test/src/unistd/access_test.cpp
index 0643b2b..693f15c 100644
--- a/test/src/unistd/access_test.cpp
+++ b/test/src/unistd/access_test.cpp
@@ -6,21 +6,23 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/access.h"
 #include "src/unistd/close.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 #include <unistd.h>
 
-TEST(LlvmLibcAccessTest, CreateAndTest) {
+using LlvmLibcAccessTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcAccessTest, CreateAndTest) {
   // The test strategy is to repeatedly create a file in different modes and
   // test that it is accessable in those modes but not in others.
-  LIBC_NAMESPACE::libc_errno = 0;
+  using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "access.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -29,30 +31,23 @@ TEST(LlvmLibcAccessTest, CreateAndTest) {
   ASSERT_GT(fd, 0);
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, F_OK), 0);
-  ASSERT_ERRNO_SUCCESS();
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, X_OK | W_OK | R_OK), 0);
-  ASSERT_ERRNO_SUCCESS();
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, F_OK), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, X_OK | W_OK | R_OK),
+              Succeeds(0));
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 
   fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IXUSR);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, F_OK), 0);
-  ASSERT_ERRNO_SUCCESS();
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, X_OK), 0);
-  ASSERT_ERRNO_SUCCESS();
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, R_OK), -1);
-  ASSERT_ERRNO_EQ(EACCES);
-  LIBC_NAMESPACE::libc_errno = 0;
-  ASSERT_EQ(LIBC_NAMESPACE::access(TEST_FILE, W_OK), -1);
-  ASSERT_ERRNO_EQ(EACCES);
-  LIBC_NAMESPACE::libc_errno = 0;
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, F_OK), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, X_OK), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, R_OK), Fails(EACCES));
+  ASSERT_THAT(LIBC_NAMESPACE::access(TEST_FILE, W_OK), Fails(EACCES));
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcAccessTest, AccessNonExistentFile) {
+TEST_F(LlvmLibcAccessTest, AccessNonExistentFile) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::access("testdata/non-existent-file", F_OK),
               Fails(ENOENT));
diff --git a/test/src/unistd/chdir_test.cpp b/test/src/unistd/chdir_test.cpp
index e1bdcd7..ac5217b 100644
--- a/test/src/unistd/chdir_test.cpp
+++ b/test/src/unistd/chdir_test.cpp
@@ -6,16 +6,18 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/chdir.h"
 #include "src/unistd/close.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/fcntl_macros.h"
 
-TEST(LlvmLibcChdirTest, ChangeAndOpen) {
+using LlvmLibcChdirTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcChdirTest, ChangeAndOpen) {
   // The idea of this test is that we will first open an existing test file
   // without changing the directory to make sure it exists. Next, we change
   // directory and open the same file to make sure that the "chdir" operation
@@ -27,7 +29,6 @@ TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   auto TEST_FILE = libc_make_test_file_path(FILENAME2);
   constexpr const char *FILENAME3 = "chdir.test";
   auto TEST_FILE_BASE = libc_make_test_file_path(FILENAME3);
-  LIBC_NAMESPACE::libc_errno = 0;
 
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_PATH);
   ASSERT_GT(fd, 0);
@@ -41,9 +42,7 @@ TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
 
-TEST(LlvmLibcChdirTest, ChangeToNonExistentDir) {
-  LIBC_NAMESPACE::libc_errno = 0;
+TEST_F(LlvmLibcChdirTest, ChangeToNonExistentDir) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::chdir("non-existent-dir"), Fails(ENOENT));
-  LIBC_NAMESPACE::libc_errno = 0;
 }
diff --git a/test/src/unistd/dup2_test.cpp b/test/src/unistd/dup2_test.cpp
index 2b2b3f3..f6d546d 100644
--- a/test/src/unistd/dup2_test.cpp
+++ b/test/src/unistd/dup2_test.cpp
@@ -6,21 +6,22 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/dup2.h"
 #include "src/unistd/read.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
+using LlvmLibcdupTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcdupTest, ReadAndWriteViaDup) {
   constexpr int DUPFD = 0xD0;
-  LIBC_NAMESPACE::libc_errno = 0;
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "dup2.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -59,7 +60,7 @@ TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcdupTest, DupBadFD) {
+TEST_F(LlvmLibcdupTest, DupBadFD) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::dup2(-1, 123), Fails(EBADF));
 }
diff --git a/test/src/unistd/dup3_test.cpp b/test/src/unistd/dup3_test.cpp
index 7b1c8e0..598940b 100644
--- a/test/src/unistd/dup3_test.cpp
+++ b/test/src/unistd/dup3_test.cpp
@@ -6,26 +6,27 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/dup3.h"
 #include "src/unistd/read.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
+using LlvmLibcdupTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
 // The tests here are exactly the same as those of dup2. We only test the
 // plumbing of the dup3 syscall and not the dup3 functionality itself as it is
 // a simple syscall wrapper. Testing dup3 functionality is beyond the scope of
 // this test.
 
-TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
+TEST_F(LlvmLibcdupTest, ReadAndWriteViaDup) {
   constexpr int DUPFD = 0xD0;
-  LIBC_NAMESPACE::libc_errno = 0;
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "dup3.test";
@@ -65,7 +66,7 @@ TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcdupTest, DupBadFD) {
+TEST_F(LlvmLibcdupTest, DupBadFD) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::dup3(-1, 123, 0), Fails(EBADF));
 }
diff --git a/test/src/unistd/dup_test.cpp b/test/src/unistd/dup_test.cpp
index c7bf877..8e0b662 100644
--- a/test/src/unistd/dup_test.cpp
+++ b/test/src/unistd/dup_test.cpp
@@ -6,20 +6,21 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/dup.h"
 #include "src/unistd/read.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
-  LIBC_NAMESPACE::libc_errno = 0;
+using LlvmLibcdupTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcdupTest, ReadAndWriteViaDup) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "dup.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -55,7 +56,7 @@ TEST(LlvmLibcdupTest, ReadAndWriteViaDup) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcdupTest, DupBadFD) {
+TEST_F(LlvmLibcdupTest, DupBadFD) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::dup(-1), Fails(EBADF));
 }
diff --git a/test/src/unistd/fchdir_test.cpp b/test/src/unistd/fchdir_test.cpp
index 0e39fde..add5648 100644
--- a/test/src/unistd/fchdir_test.cpp
+++ b/test/src/unistd/fchdir_test.cpp
@@ -6,16 +6,18 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/fchdir.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/fcntl_macros.h"
 
-TEST(LlvmLibcChdirTest, ChangeAndOpen) {
+using LlvmLibcChdirTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcChdirTest, ChangeAndOpen) {
   // The idea of this test is that we will first open an existing test file
   // without changing the directory to make sure it exists. Next, we change
   // directory and open the same file to make sure that the "fchdir" operation
@@ -27,7 +29,6 @@ TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   auto TEST_FILE = libc_make_test_file_path(FILENAME2);
   constexpr const char *FILENAME3 = "fchdir.test";
   auto TEST_FILE_BASE = libc_make_test_file_path(FILENAME3);
-  LIBC_NAMESPACE::libc_errno = 0;
 
   int dir_fd = LIBC_NAMESPACE::open(TEST_DIR, O_DIRECTORY);
   ASSERT_GT(dir_fd, 0);
@@ -45,10 +46,7 @@ TEST(LlvmLibcChdirTest, ChangeAndOpen) {
   ASSERT_THAT(LIBC_NAMESPACE::close(dir_fd), Succeeds(0));
 }
 
-TEST(LlvmLibcChdirTest, ChangeToNonExistentDir) {
-  using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
-  LIBC_NAMESPACE::libc_errno = 0;
+TEST_F(LlvmLibcChdirTest, ChangeToNonExistentDir) {
   ASSERT_EQ(LIBC_NAMESPACE::fchdir(0), -1);
   ASSERT_ERRNO_FAILURE();
-  LIBC_NAMESPACE::libc_errno = 0;
 }
diff --git a/test/src/unistd/fpathconf_test.cpp b/test/src/unistd/fpathconf_test.cpp
index fe63e5e..3cba7ec 100644
--- a/test/src/unistd/fpathconf_test.cpp
+++ b/test/src/unistd/fpathconf_test.cpp
@@ -12,19 +12,24 @@
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/fpathconf.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+using LlvmLibcFpathconfTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcPipeTest, SmokeTest) {
+TEST_F(LlvmLibcFpathconfTest, SmokeTest) {
   constexpr const char *FILENAME = "fpathconf.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(fd, 0);
+
   EXPECT_EQ(LIBC_NAMESPACE::fpathconf(fd, _PC_SYNC_IO), -1l);
   EXPECT_EQ(LIBC_NAMESPACE::fpathconf(fd, _PC_PATH_MAX),
             static_cast<long>(_POSIX_PATH_MAX));
-  LIBC_NAMESPACE::close(fd);
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
 
 // TODO: Functionality tests
diff --git a/test/src/unistd/ftruncate_test.cpp b/test/src/unistd/ftruncate_test.cpp
index 2fe4002..c50a07f 100644
--- a/test/src/unistd/ftruncate_test.cpp
+++ b/test/src/unistd/ftruncate_test.cpp
@@ -7,21 +7,22 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/ftruncate.h"
 #include "src/unistd/read.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
 namespace cpp = LIBC_NAMESPACE::cpp;
+using LlvmLibcFtruncateTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcFtruncateTest, CreateAndTruncate) {
+TEST_F(LlvmLibcFtruncateTest, CreateAndTruncate) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "ftruncate.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -34,7 +35,6 @@ TEST(LlvmLibcFtruncateTest, CreateAndTruncate) {
   //   2. Read it to make sure what was written is actually in the file.
   //   3. Truncate to 1 byte.
   //   4. Try to read more than 1 byte and fail.
-  LIBC_NAMESPACE::libc_errno = 0;
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
@@ -67,7 +67,7 @@ TEST(LlvmLibcFtruncateTest, CreateAndTruncate) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcFtruncateTest, TruncateBadFD) {
+TEST_F(LlvmLibcFtruncateTest, TruncateBadFD) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::ftruncate(0, off_t(1)), Fails(EINVAL));
 }
diff --git a/test/src/unistd/getentropy_test.cpp b/test/src/unistd/getentropy_test.cpp
new file mode 100644
index 0000000..a417756
--- /dev/null
+++ b/test/src/unistd/getentropy_test.cpp
@@ -0,0 +1,30 @@
+//===-- Unittests for getentropy ------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/errno_macros.h"
+#include "src/unistd/getentropy.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/ErrnoSetterMatcher.h"
+#include "test/UnitTest/Test.h"
+
+using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+using LlvmLibcUnistdGetEntropyTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUnistdGetEntropyTest, LengthTooLong) {
+  char buf[1024];
+  ASSERT_THAT(LIBC_NAMESPACE::getentropy(buf, 257), Fails(EIO));
+}
+
+TEST_F(LlvmLibcUnistdGetEntropyTest, SmokeTest) {
+  char buf[256];
+  ASSERT_THAT(LIBC_NAMESPACE::getentropy(buf, 256), Succeeds());
+}
+
+TEST_F(LlvmLibcUnistdGetEntropyTest, OtherError) {
+  ASSERT_THAT(LIBC_NAMESPACE::getentropy(nullptr, 1), Fails(EIO));
+}
diff --git a/test/src/unistd/getopt_test.cpp b/test/src/unistd/getopt_test.cpp
index e6e8772..1a31094 100644
--- a/test/src/unistd/getopt_test.cpp
+++ b/test/src/unistd/getopt_test.cpp
@@ -79,7 +79,7 @@ struct LlvmLibcGetoptTest : public LIBC_NAMESPACE::testing::Test {
 
 // This is safe because getopt doesn't currently permute argv like GNU's getopt
 // does so this just helps silence warnings.
-char *operator"" _c(const char *c, size_t) { return const_cast<char *>(c); }
+char *operator""_c(const char *c, size_t) { return const_cast<char *>(c); }
 
 TEST_F(LlvmLibcGetoptTest, NoMatch) {
   array<char *, 3> argv{"prog"_c, "arg1"_c, nullptr};
@@ -155,7 +155,7 @@ TEST_F(LlvmLibcGetoptTest, ParseArgInNext) {
   EXPECT_EQ(test_globals::optind, 3);
 }
 
-TEST_F(LlvmLibcGetoptTest, ParseMutliInOne) {
+TEST_F(LlvmLibcGetoptTest, ParseMultiInOne) {
   array<char *, 3> argv{"prog"_c, "-abc"_c, nullptr};
 
   EXPECT_EQ(LIBC_NAMESPACE::getopt(2, argv.data(), "abc"), (int)'a');
diff --git a/test/src/unistd/getsid_test.cpp b/test/src/unistd/getsid_test.cpp
new file mode 100644
index 0000000..e997348
--- /dev/null
+++ b/test/src/unistd/getsid_test.cpp
@@ -0,0 +1,23 @@
+//===-- Unittests for getsid ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/getsid.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
+#include "test/UnitTest/Test.h"
+
+using LlvmLibcGetSidTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcGetSidTest, GetCurrSID) {
+  pid_t sid = LIBC_NAMESPACE::getsid(0);
+  ASSERT_NE(sid, -1);
+  ASSERT_ERRNO_SUCCESS();
+
+  pid_t nonexist_sid = LIBC_NAMESPACE::getsid(-1);
+  ASSERT_EQ(nonexist_sid, -1);
+  ASSERT_ERRNO_FAILURE();
+}
diff --git a/test/src/unistd/isatty_test.cpp b/test/src/unistd/isatty_test.cpp
index c20eead..63a0bf7 100644
--- a/test/src/unistd/isatty_test.cpp
+++ b/test/src/unistd/isatty_test.cpp
@@ -6,10 +6,10 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/isatty.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
@@ -17,11 +17,11 @@
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcIsATTYTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcIsATTYTest, StdInOutTests) {
+TEST_F(LlvmLibcIsATTYTest, StdInOutTests) {
   // If stdin is connected to a terminal, assume that all of the standard i/o
   // fds are.
-  LIBC_NAMESPACE::libc_errno = 0;
   if (LIBC_NAMESPACE::isatty(0)) {
     EXPECT_THAT(LIBC_NAMESPACE::isatty(0), Succeeds(1)); // stdin
     EXPECT_THAT(LIBC_NAMESPACE::isatty(1), Succeeds(1)); // stdout
@@ -33,27 +33,26 @@ TEST(LlvmLibcIsATTYTest, StdInOutTests) {
   }
 }
 
-TEST(LlvmLibcIsATTYTest, BadFdTest) {
-  LIBC_NAMESPACE::libc_errno = 0;
+TEST_F(LlvmLibcIsATTYTest, BadFdTest) {
   EXPECT_THAT(LIBC_NAMESPACE::isatty(-1), Fails(EBADF, 0)); // invalid fd
 }
 
-TEST(LlvmLibcIsATTYTest, DevTTYTest) {
+TEST_F(LlvmLibcIsATTYTest, DevTTYTest) {
   constexpr const char *FILENAME = "/dev/tty";
   auto TTY_FILE = libc_make_test_file_path(FILENAME);
-  LIBC_NAMESPACE::libc_errno = 0;
   int fd = LIBC_NAMESPACE::open(TTY_FILE, O_RDONLY);
   if (fd > 0) {
     ASSERT_ERRNO_SUCCESS();
     EXPECT_THAT(LIBC_NAMESPACE::isatty(fd), Succeeds(1));
     ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
+  } else {
+    ASSERT_ERRNO_FAILURE();
   }
 }
 
-TEST(LlvmLibcIsATTYTest, FileTest) {
+TEST_F(LlvmLibcIsATTYTest, FileTest) {
   constexpr const char *FILENAME = "isatty.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
-  LIBC_NAMESPACE::libc_errno = 0;
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
diff --git a/test/src/unistd/link_test.cpp b/test/src/unistd/link_test.cpp
index 3f1af2e..e91edd5 100644
--- a/test/src/unistd/link_test.cpp
+++ b/test/src/unistd/link_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/link.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcLinkTest, CreateAndUnlink) {
+using LlvmLibcLinkTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcLinkTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "link.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -28,7 +30,6 @@ TEST(LlvmLibcLinkTest, CreateAndUnlink) {
   //   2. Create a link to that file.
   //   3. Open the link to check that the link was created.
   //   4. Cleanup the file and its link.
-  LIBC_NAMESPACE::libc_errno = 0;
   int write_fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(write_fd, 0);
@@ -44,7 +45,7 @@ TEST(LlvmLibcLinkTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE_LINK), Succeeds(0));
 }
 
-TEST(LlvmLibcLinkTest, LinkToNonExistentFile) {
+TEST_F(LlvmLibcLinkTest, LinkToNonExistentFile) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::link("non-existent-file", "bad-link"),
               Fails(ENOENT));
diff --git a/test/src/unistd/linkat_test.cpp b/test/src/unistd/linkat_test.cpp
index c6e4575..1d82908 100644
--- a/test/src/unistd/linkat_test.cpp
+++ b/test/src/unistd/linkat_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/linkat.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcLinkatTest, CreateAndUnlink) {
+using LlvmLibcLinkatTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcLinkatTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "testdata";
   auto TEST_DIR = libc_make_test_file_path(FILENAME);
@@ -34,7 +36,6 @@ TEST(LlvmLibcLinkatTest, CreateAndUnlink) {
   //   2. Create a link to that file.
   //   3. Open the link to check that the link was created.
   //   4. Cleanup the file and its link.
-  LIBC_NAMESPACE::libc_errno = 0;
   int write_fd =
       LIBC_NAMESPACE::open(TEST_FILE_PATH, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
@@ -56,7 +57,7 @@ TEST(LlvmLibcLinkatTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::close(dir_fd), Succeeds(0));
 }
 
-TEST(LlvmLibcLinkatTest, LinkToNonExistentFile) {
+TEST_F(LlvmLibcLinkatTest, LinkToNonExistentFile) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::linkat(AT_FDCWD, "testdata/non-existent-file",
                                      AT_FDCWD, "testdata/bad-link", 0),
diff --git a/test/src/unistd/lseek_test.cpp b/test/src/unistd/lseek_test.cpp
index 40c0bf0..66268ca 100644
--- a/test/src/unistd/lseek_test.cpp
+++ b/test/src/unistd/lseek_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/lseek.h"
 #include "src/unistd/read.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <unistd.h>
 
-TEST(LlvmLibcUniStd, LseekTest) {
+using LlvmLibcUniStd = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUniStd, LseekTest) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "testdata/lseek.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -24,7 +26,7 @@ TEST(LlvmLibcUniStd, LseekTest) {
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
   constexpr const char LSEEK_TEST[] = "lseek test";
-  constexpr int LSEEK_TEST_SIZE = sizeof(LSEEK_TEST) - 1;
+  constexpr ssize_t LSEEK_TEST_SIZE = sizeof(LSEEK_TEST) - 1;
 
   char read_buf[20];
   ASSERT_THAT(LIBC_NAMESPACE::read(fd, read_buf, LSEEK_TEST_SIZE),
@@ -33,7 +35,7 @@ TEST(LlvmLibcUniStd, LseekTest) {
   EXPECT_STREQ(read_buf, LSEEK_TEST);
 
   // Seek to the beginning of the file and re-read.
-  ASSERT_THAT(LIBC_NAMESPACE::lseek(fd, 0, SEEK_SET), Succeeds(0));
+  ASSERT_THAT(LIBC_NAMESPACE::lseek(fd, 0, SEEK_SET), Succeeds(off_t(0)));
   ASSERT_THAT(LIBC_NAMESPACE::read(fd, read_buf, LSEEK_TEST_SIZE),
               Succeeds(LSEEK_TEST_SIZE));
   read_buf[LSEEK_TEST_SIZE] = '\0';
@@ -41,7 +43,7 @@ TEST(LlvmLibcUniStd, LseekTest) {
 
   // Seek to the beginning of the file from the end and re-read.
   ASSERT_THAT(LIBC_NAMESPACE::lseek(fd, -LSEEK_TEST_SIZE, SEEK_END),
-              Succeeds(0));
+              Succeeds(off_t(0)));
   ASSERT_THAT(LIBC_NAMESPACE::read(fd, read_buf, LSEEK_TEST_SIZE),
               Succeeds(LSEEK_TEST_SIZE));
   read_buf[LSEEK_TEST_SIZE] = '\0';
@@ -50,7 +52,7 @@ TEST(LlvmLibcUniStd, LseekTest) {
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
 
-TEST(LlvmLibcUniStd, LseekFailsTest) {
+TEST_F(LlvmLibcUniStd, LseekFailsTest) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "testdata/lseek.test";
@@ -58,6 +60,6 @@ TEST(LlvmLibcUniStd, LseekFailsTest) {
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_RDONLY);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
-  EXPECT_THAT(LIBC_NAMESPACE::lseek(fd, -1, SEEK_CUR), Fails(EINVAL));
+  EXPECT_THAT(LIBC_NAMESPACE::lseek(fd, -1, SEEK_CUR), Fails<off_t>(EINVAL));
   ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
diff --git a/test/src/unistd/pathconf_test.cpp b/test/src/unistd/pathconf_test.cpp
index 3dc4b2c..5529774 100644
--- a/test/src/unistd/pathconf_test.cpp
+++ b/test/src/unistd/pathconf_test.cpp
@@ -12,19 +12,24 @@
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/pathconf.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+using LlvmLibcPathconfTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcPipeTest, SmokeTest) {
+TEST_F(LlvmLibcPathconfTest, SmokeTest) {
   constexpr const char *FILENAME = "pathconf.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
+  ASSERT_ERRNO_SUCCESS();
+  ASSERT_GT(fd, 0);
+
   EXPECT_EQ(LIBC_NAMESPACE::pathconf(FILENAME, _PC_SYNC_IO), -1l);
   EXPECT_EQ(LIBC_NAMESPACE::pathconf(FILENAME, _PC_PATH_MAX),
             static_cast<long>(_POSIX_PATH_MAX));
-  LIBC_NAMESPACE::close(fd);
+  ASSERT_THAT(LIBC_NAMESPACE::close(fd), Succeeds(0));
 }
 
 // TODO: Functionality tests
diff --git a/test/src/unistd/pipe2_test.cpp b/test/src/unistd/pipe2_test.cpp
index 795ec78..db35c34 100644
--- a/test/src/unistd/pipe2_test.cpp
+++ b/test/src/unistd/pipe2_test.cpp
@@ -5,23 +5,24 @@
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
-#include "src/errno/libc_errno.h"
 #include "src/unistd/close.h"
 #include "src/unistd/pipe2.h"
 
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+using LlvmLibcPipe2Test = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcPipe2Test, SmokeTest) {
+TEST_F(LlvmLibcPipe2Test, SucceedsSmokeTest) {
   int pipefd[2];
   ASSERT_THAT(LIBC_NAMESPACE::pipe2(pipefd, 0), Succeeds());
   ASSERT_THAT(LIBC_NAMESPACE::close(pipefd[0]), Succeeds());
   ASSERT_THAT(LIBC_NAMESPACE::close(pipefd[1]), Succeeds());
 }
 
-TEST(LlvmLibcPipe2ErrTest, SmokeTest) {
+TEST_F(LlvmLibcPipe2Test, FailsSmokeTest) {
   int pipefd[2];
   ASSERT_THAT(LIBC_NAMESPACE::pipe2(pipefd, -1), Fails(EINVAL));
   ASSERT_THAT(LIBC_NAMESPACE::pipe2(nullptr, 0), Fails(EFAULT));
diff --git a/test/src/unistd/pipe_test.cpp b/test/src/unistd/pipe_test.cpp
index 9c633de..9c6d9f6 100644
--- a/test/src/unistd/pipe_test.cpp
+++ b/test/src/unistd/pipe_test.cpp
@@ -8,12 +8,14 @@
 #include "src/unistd/close.h"
 #include "src/unistd/pipe.h"
 
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 using namespace LIBC_NAMESPACE::testing::ErrnoSetterMatcher;
+using LlvmLibcPipeTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcPipeTest, SmokeTest) {
+TEST_F(LlvmLibcPipeTest, SmokeTest) {
 
   int pipefd[2];
 
diff --git a/test/src/unistd/pread_pwrite_test.cpp b/test/src/unistd/pread_pwrite_test.cpp
index 3c42fcc..7cbac04 100644
--- a/test/src/unistd/pread_pwrite_test.cpp
+++ b/test/src/unistd/pread_pwrite_test.cpp
@@ -6,7 +6,6 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/fsync.h"
@@ -14,21 +13,24 @@
 #include "src/unistd/pwrite.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcUniStd, PWriteAndPReadBackTest) {
+using LlvmLibcUniStd = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUniStd, PWriteAndPReadBackTest) {
   // The strategy here is that we first create a file and write to it. Next,
   // we open that file again and write at an offset. Finally, we open the
   // file again and pread at an offset and make sure that only expected data
   // is being read back. This also confirms that pwrite happened successfully.
   constexpr const char HELLO[] = "hello";
-  constexpr int HELLO_SIZE = sizeof(HELLO);
+  constexpr ssize_t HELLO_SIZE = sizeof(HELLO);
   constexpr off_t OFFSET = 3;
   constexpr const char OFFSET_TEXT[] = "helhello";
-  constexpr int OFFSET_TEXT_SIZE = sizeof(OFFSET_TEXT);
+  constexpr ssize_t OFFSET_TEXT_SIZE = sizeof(OFFSET_TEXT);
 
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 
@@ -65,12 +67,12 @@ TEST(LlvmLibcUniStd, PWriteAndPReadBackTest) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcUniStd, PWriteFails) {
+TEST_F(LlvmLibcUniStd, PWriteFails) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
-  EXPECT_THAT(LIBC_NAMESPACE::pwrite(-1, "", 1, 0), Fails(EBADF));
+  EXPECT_THAT(LIBC_NAMESPACE::pwrite(-1, "", 1, 0), Fails<ssize_t>(EBADF));
 }
 
-TEST(LlvmLibcUniStd, PReadFails) {
+TEST_F(LlvmLibcUniStd, PReadFails) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
-  EXPECT_THAT(LIBC_NAMESPACE::pread(-1, nullptr, 1, 0), Fails(EBADF));
+  EXPECT_THAT(LIBC_NAMESPACE::pread(-1, nullptr, 1, 0), Fails<ssize_t>(EBADF));
 }
diff --git a/test/src/unistd/read_write_test.cpp b/test/src/unistd/read_write_test.cpp
index 8b6ba42..8952e60 100644
--- a/test/src/unistd/read_write_test.cpp
+++ b/test/src/unistd/read_write_test.cpp
@@ -6,19 +6,21 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/stdio/remove.h"
 #include "src/unistd/close.h"
 #include "src/unistd/fsync.h"
 #include "src/unistd/read.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcUniStd, WriteAndReadBackTest) {
+using LlvmLibcUniStd = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUniStd, WriteAndReadBackTest) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "__unistd_read_write.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -27,7 +29,7 @@ TEST(LlvmLibcUniStd, WriteAndReadBackTest) {
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(write_fd, 0);
   constexpr const char HELLO[] = "hello";
-  constexpr int HELLO_SIZE = sizeof(HELLO);
+  constexpr ssize_t HELLO_SIZE = sizeof(HELLO);
   ASSERT_THAT(LIBC_NAMESPACE::write(write_fd, HELLO, HELLO_SIZE),
               Succeeds(HELLO_SIZE));
   ASSERT_THAT(LIBC_NAMESPACE::fsync(write_fd), Succeeds(0));
@@ -45,18 +47,18 @@ TEST(LlvmLibcUniStd, WriteAndReadBackTest) {
   ASSERT_THAT(LIBC_NAMESPACE::remove(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcUniStd, WriteFails) {
+TEST_F(LlvmLibcUniStd, WriteFails) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 
-  EXPECT_THAT(LIBC_NAMESPACE::write(-1, "", 1), Fails(EBADF));
+  EXPECT_THAT(LIBC_NAMESPACE::write(-1, "", 1), Fails<ssize_t>(EBADF));
   EXPECT_THAT(LIBC_NAMESPACE::write(1, reinterpret_cast<const void *>(-1), 1),
-              Fails(EFAULT));
+              Fails<ssize_t>(EFAULT));
 }
 
-TEST(LlvmLibcUniStd, ReadFails) {
+TEST_F(LlvmLibcUniStd, ReadFails) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
 
-  EXPECT_THAT(LIBC_NAMESPACE::read(-1, nullptr, 1), Fails(EBADF));
+  EXPECT_THAT(LIBC_NAMESPACE::read(-1, nullptr, 1), Fails<ssize_t>(EBADF));
   EXPECT_THAT(LIBC_NAMESPACE::read(0, reinterpret_cast<void *>(-1), 1),
-              Fails(EFAULT));
+              Fails<ssize_t>(EFAULT));
 }
diff --git a/test/src/unistd/readlink_test.cpp b/test/src/unistd/readlink_test.cpp
index 6b27294..25c58a5 100644
--- a/test/src/unistd/readlink_test.cpp
+++ b/test/src/unistd/readlink_test.cpp
@@ -7,23 +7,23 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
-#include "src/errno/libc_errno.h"
 #include "src/string/string_utils.h"
 #include "src/unistd/readlink.h"
 #include "src/unistd/symlink.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 namespace cpp = LIBC_NAMESPACE::cpp;
+using LlvmLibcReadlinkTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcReadlinkTest, CreateAndUnlink) {
+TEST_F(LlvmLibcReadlinkTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "readlink_test_file";
   auto LINK_VAL = libc_make_test_file_path(FILENAME);
   constexpr const char *FILENAME2 = "readlink_test_file.link";
   auto LINK = libc_make_test_file_path(FILENAME2);
-  LIBC_NAMESPACE::libc_errno = 0;
 
   // The test strategy is as follows:
   //   1. Create a symlink with value LINK_VAL.
@@ -40,10 +40,10 @@ TEST(LlvmLibcReadlinkTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(LINK), Succeeds(0));
 }
 
-TEST(LlvmLibcReadlinkTest, ReadlinkInNonExistentPath) {
+TEST_F(LlvmLibcReadlinkTest, ReadlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   constexpr auto LEN = 8;
   char buf[LEN];
   ASSERT_THAT(LIBC_NAMESPACE::readlink("non-existent-link", buf, LEN),
-              Fails(ENOENT));
+              Fails<ssize_t>(ENOENT));
 }
diff --git a/test/src/unistd/readlinkat_test.cpp b/test/src/unistd/readlinkat_test.cpp
index 9e4bb9a..e2e7188 100644
--- a/test/src/unistd/readlinkat_test.cpp
+++ b/test/src/unistd/readlinkat_test.cpp
@@ -7,25 +7,25 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
-#include "src/errno/libc_errno.h"
 #include "src/string/string_utils.h"
 #include "src/unistd/readlinkat.h"
 #include "src/unistd/symlink.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/fcntl_macros.h"
 
 namespace cpp = LIBC_NAMESPACE::cpp;
+using LlvmLibcReadlinkatTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
-TEST(LlvmLibcReadlinkatTest, CreateAndUnlink) {
+TEST_F(LlvmLibcReadlinkatTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "readlinkat_test_file";
   auto LINK_VAL = libc_make_test_file_path(FILENAME);
   constexpr const char *FILENAME2 = "readlinkat_test_file.link";
   auto LINK = libc_make_test_file_path(FILENAME2);
-  LIBC_NAMESPACE::libc_errno = 0;
 
   // The test strategy is as follows:
   //   1. Create a symlink with value LINK_VAL.
@@ -42,11 +42,11 @@ TEST(LlvmLibcReadlinkatTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(LINK), Succeeds(0));
 }
 
-TEST(LlvmLibcReadlinkatTest, ReadlinkInNonExistentPath) {
+TEST_F(LlvmLibcReadlinkatTest, ReadlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   constexpr auto LEN = 8;
   char buf[LEN];
   ASSERT_THAT(
       LIBC_NAMESPACE::readlinkat(AT_FDCWD, "non-existent-link", buf, LEN),
-      Fails(ENOENT));
+      Fails<ssize_t>(ENOENT));
 }
diff --git a/test/src/unistd/rmdir_test.cpp b/test/src/unistd/rmdir_test.cpp
index 4f4cd94..860cf1c 100644
--- a/test/src/unistd/rmdir_test.cpp
+++ b/test/src/unistd/rmdir_test.cpp
@@ -6,15 +6,17 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/sys/stat/mkdir.h"
 #include "src/unistd/rmdir.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include "hdr/fcntl_macros.h"
 
-TEST(LlvmLibcRmdirTest, CreateAndRemove) {
+using LlvmLibcRmdirTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcRmdirTest, CreateAndRemove) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "rmdir.testdir";
   auto TEST_DIR = libc_make_test_file_path(FILENAME);
@@ -22,7 +24,7 @@ TEST(LlvmLibcRmdirTest, CreateAndRemove) {
   ASSERT_THAT(LIBC_NAMESPACE::rmdir(TEST_DIR), Succeeds(0));
 }
 
-TEST(LlvmLibcRmdirTest, RemoveNonExistentDir) {
+TEST_F(LlvmLibcRmdirTest, RemoveNonExistentDir) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::rmdir("non-existent-dir"), Fails(ENOENT));
 }
diff --git a/test/src/unistd/setsid_test.cpp b/test/src/unistd/setsid_test.cpp
new file mode 100644
index 0000000..466faa1
--- /dev/null
+++ b/test/src/unistd/setsid_test.cpp
@@ -0,0 +1,15 @@
+//===-- Unittests for setsid ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "src/unistd/setsid.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcGetPidTest, SmokeTest) {
+  // setsid always succeeds. So, we just call it as a smoke test.
+  LIBC_NAMESPACE::setsid();
+}
diff --git a/test/src/unistd/symlink_test.cpp b/test/src/unistd/symlink_test.cpp
index 9e8b81c..1cc90be 100644
--- a/test/src/unistd/symlink_test.cpp
+++ b/test/src/unistd/symlink_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/symlink.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcSymlinkTest, CreateAndUnlink) {
+using LlvmLibcSymlinkTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSymlinkTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "symlink.test";
   auto TEST_FILE_BASE = libc_make_test_file_path(FILENAME);
@@ -30,7 +32,6 @@ TEST(LlvmLibcSymlinkTest, CreateAndUnlink) {
   //   2. Create a symlink to that file.
   //   3. Open the symlink to check that the symlink was created.
   //   4. Cleanup the file and its symlink.
-  LIBC_NAMESPACE::libc_errno = 0;
   int write_fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(write_fd, 0);
@@ -48,7 +49,7 @@ TEST(LlvmLibcSymlinkTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE_LINK), Succeeds(0));
 }
 
-TEST(LlvmLibcSymlinkTest, SymlinkInNonExistentPath) {
+TEST_F(LlvmLibcSymlinkTest, SymlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::symlink("non-existent-dir/non-existent-file",
                                       "non-existent-dir/bad-symlink"),
diff --git a/test/src/unistd/symlinkat_test.cpp b/test/src/unistd/symlinkat_test.cpp
index b6588a9..85970be 100644
--- a/test/src/unistd/symlinkat_test.cpp
+++ b/test/src/unistd/symlinkat_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/symlinkat.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcSymlinkatTest, CreateAndUnlink) {
+using LlvmLibcSymlinkatTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcSymlinkatTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "testdata";
   auto TEST_DIR = libc_make_test_file_path(FILENAME);
@@ -34,7 +36,6 @@ TEST(LlvmLibcSymlinkatTest, CreateAndUnlink) {
   //   2. Create a link to that file.
   //   3. Open the link to check that the link was created.
   //   4. Cleanup the file and its link.
-  LIBC_NAMESPACE::libc_errno = 0;
   int write_fd =
       LIBC_NAMESPACE::open(TEST_FILE_PATH, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
@@ -55,7 +56,7 @@ TEST(LlvmLibcSymlinkatTest, CreateAndUnlink) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE_PATH), Succeeds(0));
 }
 
-TEST(LlvmLibcSymlinkatTest, SymlinkInNonExistentPath) {
+TEST_F(LlvmLibcSymlinkatTest, SymlinkInNonExistentPath) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::symlinkat("non-existent-dir/non-existent-file",
                                         AT_FDCWD, "non-existent-dir/bad-link"),
diff --git a/test/src/unistd/syscall_test.cpp b/test/src/unistd/syscall_test.cpp
index f6cc3ea..85caef2 100644
--- a/test/src/unistd/syscall_test.cpp
+++ b/test/src/unistd/syscall_test.cpp
@@ -6,8 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/unistd/syscall.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
@@ -17,6 +17,7 @@
 #include <unistd.h>
 
 using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
+using LlvmLibcSyscallTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
 
 // We only do a smoke test here. Actual functionality tests are
 // done by the unit tests of the syscall wrappers like mmap.
@@ -26,14 +27,12 @@ using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
 // set up the arguments properly. We still need to specify the namespace though
 // because the macro generates a call to the actual internal function
 // (__llvm_libc_syscall) which is inside the namespace.
-TEST(LlvmLibcSyscallTest, TrivialCall) {
-  LIBC_NAMESPACE::libc_errno = 0;
-
+TEST_F(LlvmLibcSyscallTest, TrivialCall) {
   ASSERT_GE(LIBC_NAMESPACE::syscall(SYS_gettid), 0l);
   ASSERT_ERRNO_SUCCESS();
 }
 
-TEST(LlvmLibcSyscallTest, SymlinkCreateDestroy) {
+TEST_F(LlvmLibcSyscallTest, SymlinkCreateDestroy) {
   constexpr const char LINK_VAL[] = "syscall_readlink_test_value";
   constexpr const char LINK[] = "testdata/syscall_readlink.test.link";
 
@@ -68,22 +67,22 @@ TEST(LlvmLibcSyscallTest, SymlinkCreateDestroy) {
   ASSERT_ERRNO_SUCCESS();
 }
 
-TEST(LlvmLibcSyscallTest, FileReadWrite) {
+TEST_F(LlvmLibcSyscallTest, FileReadWrite) {
   constexpr const char HELLO[] = "hello";
   constexpr int HELLO_SIZE = sizeof(HELLO);
 
   constexpr const char *TEST_FILE = "testdata/syscall_pread_pwrite.test";
 
 #ifdef SYS_open
-  int fd =
+  long fd =
       LIBC_NAMESPACE::syscall(SYS_open, TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
 #elif defined(SYS_openat)
-  int fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD, TEST_FILE,
-                                   O_WRONLY | O_CREAT, S_IRWXU);
+  long fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD, TEST_FILE,
+                                    O_WRONLY | O_CREAT, S_IRWXU);
 #else
 #error "open and openat syscalls not available."
 #endif
-  ASSERT_GT(fd, 0);
+  ASSERT_GT(fd, 0l);
   ASSERT_ERRNO_SUCCESS();
 
   ASSERT_GE(LIBC_NAMESPACE::syscall(SYS_pwrite64, fd, HELLO, HELLO_SIZE, 0),
@@ -97,7 +96,7 @@ TEST(LlvmLibcSyscallTest, FileReadWrite) {
   ASSERT_ERRNO_SUCCESS();
 }
 
-TEST(LlvmLibcSyscallTest, FileLinkCreateDestroy) {
+TEST_F(LlvmLibcSyscallTest, FileLinkCreateDestroy) {
   constexpr const char *TEST_DIR = "testdata";
   constexpr const char *TEST_FILE = "syscall_linkat.test";
   constexpr const char *TEST_FILE_PATH = "testdata/syscall_linkat.test";
@@ -112,29 +111,29 @@ TEST(LlvmLibcSyscallTest, FileLinkCreateDestroy) {
   //   4. Cleanup the file and its link.
 
 #ifdef SYS_open
-  int write_fd = LIBC_NAMESPACE::syscall(SYS_open, TEST_FILE_PATH,
-                                         O_WRONLY | O_CREAT, S_IRWXU);
+  long write_fd = LIBC_NAMESPACE::syscall(SYS_open, TEST_FILE_PATH,
+                                          O_WRONLY | O_CREAT, S_IRWXU);
 #elif defined(SYS_openat)
-  int write_fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD, TEST_FILE_PATH,
-                                         O_WRONLY | O_CREAT, S_IRWXU);
+  long write_fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD, TEST_FILE_PATH,
+                                          O_WRONLY | O_CREAT, S_IRWXU);
 #else
 #error "open and openat syscalls not available."
 #endif
-  ASSERT_GT(write_fd, 0);
+  ASSERT_GT(write_fd, 0l);
   ASSERT_ERRNO_SUCCESS();
 
   ASSERT_GE(LIBC_NAMESPACE::syscall(SYS_close, write_fd), 0l);
   ASSERT_ERRNO_SUCCESS();
 
 #ifdef SYS_open
-  int dir_fd = LIBC_NAMESPACE::syscall(SYS_open, TEST_DIR, O_DIRECTORY, 0);
+  long dir_fd = LIBC_NAMESPACE::syscall(SYS_open, TEST_DIR, O_DIRECTORY, 0);
 #elif defined(SYS_openat)
-  int dir_fd =
+  long dir_fd =
       LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD, TEST_DIR, O_DIRECTORY, 0);
 #else
 #error "open and openat syscalls not available."
 #endif
-  ASSERT_GT(dir_fd, 0);
+  ASSERT_GT(dir_fd, 0l);
   ASSERT_ERRNO_SUCCESS();
 
   ASSERT_GE(LIBC_NAMESPACE::syscall(SYS_linkat, dir_fd, TEST_FILE, dir_fd,
@@ -142,15 +141,15 @@ TEST(LlvmLibcSyscallTest, FileLinkCreateDestroy) {
             0l);
   ASSERT_ERRNO_SUCCESS();
 #ifdef SYS_open
-  int link_fd =
+  long link_fd =
       LIBC_NAMESPACE::syscall(SYS_open, TEST_FILE_LINK_PATH, O_PATH, 0);
 #elif defined(SYS_openat)
-  int link_fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD,
-                                        TEST_FILE_LINK_PATH, O_PATH, 0);
+  long link_fd = LIBC_NAMESPACE::syscall(SYS_openat, AT_FDCWD,
+                                         TEST_FILE_LINK_PATH, O_PATH, 0);
 #else
 #error "open and openat syscalls not available."
 #endif
-  ASSERT_GT(link_fd, 0);
+  ASSERT_GT(link_fd, 0l);
   ASSERT_ERRNO_SUCCESS();
 
 #ifdef SYS_unlink
diff --git a/test/src/unistd/truncate_test.cpp b/test/src/unistd/truncate_test.cpp
index 261dd63..0af3b63 100644
--- a/test/src/unistd/truncate_test.cpp
+++ b/test/src/unistd/truncate_test.cpp
@@ -7,13 +7,13 @@
 //===----------------------------------------------------------------------===//
 
 #include "src/__support/CPP/string_view.h"
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/read.h"
 #include "src/unistd/truncate.h"
 #include "src/unistd/unlink.h"
 #include "src/unistd/write.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
@@ -21,7 +21,9 @@
 
 namespace cpp = LIBC_NAMESPACE::cpp;
 
-TEST(LlvmLibcTruncateTest, CreateAndTruncate) {
+using LlvmLibcTruncateTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcTruncateTest, CreateAndTruncate) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "truncate.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
@@ -34,7 +36,6 @@ TEST(LlvmLibcTruncateTest, CreateAndTruncate) {
   //   2. Read it to make sure what was written is actually in the file.
   //   3. Truncate to 1 byte.
   //   4. Try to read more than 1 byte and fail.
-  LIBC_NAMESPACE::libc_errno = 0;
   int fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(fd, 0);
@@ -61,7 +62,7 @@ TEST(LlvmLibcTruncateTest, CreateAndTruncate) {
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcTruncateTest, TruncateNonExistentFile) {
+TEST_F(LlvmLibcTruncateTest, TruncateNonExistentFile) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(
       LIBC_NAMESPACE::truncate("non-existent-dir/non-existent-file", off_t(1)),
diff --git a/test/src/unistd/unlink_test.cpp b/test/src/unistd/unlink_test.cpp
index e1ffaab..892779b 100644
--- a/test/src/unistd/unlink_test.cpp
+++ b/test/src/unistd/unlink_test.cpp
@@ -6,27 +6,30 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/unistd/close.h"
 #include "src/unistd/unlink.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcUnlinkTest, CreateAndUnlink) {
+using LlvmLibcUnlinkTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUnlinkTest, CreateAndUnlink) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "unlink.test";
   auto TEST_FILE = libc_make_test_file_path(FILENAME);
   int write_fd = LIBC_NAMESPACE::open(TEST_FILE, O_WRONLY | O_CREAT, S_IRWXU);
   ASSERT_ERRNO_SUCCESS();
   ASSERT_GT(write_fd, 0);
+
   ASSERT_THAT(LIBC_NAMESPACE::close(write_fd), Succeeds(0));
   ASSERT_THAT(LIBC_NAMESPACE::unlink(TEST_FILE), Succeeds(0));
 }
 
-TEST(LlvmLibcUnlinkTest, UnlinkNonExistentFile) {
+TEST_F(LlvmLibcUnlinkTest, UnlinkNonExistentFile) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Fails;
   ASSERT_THAT(LIBC_NAMESPACE::unlink("non-existent-file"), Fails(ENOENT));
 }
diff --git a/test/src/unistd/unlinkat_test.cpp b/test/src/unistd/unlinkat_test.cpp
index 2d64a99..e862ad1 100644
--- a/test/src/unistd/unlinkat_test.cpp
+++ b/test/src/unistd/unlinkat_test.cpp
@@ -6,17 +6,19 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "src/errno/libc_errno.h"
 #include "src/fcntl/open.h"
 #include "src/fcntl/openat.h"
 #include "src/unistd/close.h"
 #include "src/unistd/unlinkat.h"
+#include "test/UnitTest/ErrnoCheckingTest.h"
 #include "test/UnitTest/ErrnoSetterMatcher.h"
 #include "test/UnitTest/Test.h"
 
 #include <sys/stat.h>
 
-TEST(LlvmLibcUnlinkatTest, CreateAndDeleteTest) {
+using LlvmLibcUnlinkatTest = LIBC_NAMESPACE::testing::ErrnoCheckingTest;
+
+TEST_F(LlvmLibcUnlinkatTest, CreateAndDeleteTest) {
   using LIBC_NAMESPACE::testing::ErrnoSetterMatcher::Succeeds;
   constexpr const char *FILENAME = "testdata";
   auto TEST_DIR = libc_make_test_file_path(FILENAME);
@@ -34,7 +36,7 @@ TEST(LlvmLibcUnlinkatTest, CreateAndDeleteTest) {
   ASSERT_THAT(LIBC_NAMESPACE::close(dir_fd), Succeeds(0));
 }
 
-TEST(LlvmLibcUnlinkatTest, UnlinkatNonExistentFile) {
+TEST_F(LlvmLibcUnlinkatTest, UnlinkatNonExistentFile) {
   constexpr const char *FILENAME = "testdata";
   auto TEST_DIR = libc_make_test_file_path(FILENAME);
   int dir_fd = LIBC_NAMESPACE::open(TEST_DIR, O_DIRECTORY);
diff --git a/test/src/wchar/wcslen_test.cpp b/test/src/wchar/wcslen_test.cpp
new file mode 100644
index 0000000..9cf4465
--- /dev/null
+++ b/test/src/wchar/wcslen_test.cpp
@@ -0,0 +1,20 @@
+//===-- Unittests for wcslen ----------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "hdr/types/size_t.h"
+#include "hdr/types/wchar_t.h"
+#include "src/wchar/wcslen.h"
+#include "test/UnitTest/Test.h"
+
+TEST(LlvmLibcWCSLenTest, EmptyString) {
+  ASSERT_EQ(size_t{0}, LIBC_NAMESPACE::wcslen(L""));
+}
+
+TEST(LlvmLibcWCSLenTest, AnyString) {
+  ASSERT_EQ(size_t{12}, LIBC_NAMESPACE::wcslen(L"Hello World!"));
+}
```

