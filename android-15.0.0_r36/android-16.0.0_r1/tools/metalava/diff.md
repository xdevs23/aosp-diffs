```diff
diff --git a/.idea/kotlinc.xml b/.idea/kotlinc.xml
index bb2d78993..4e1810b83 100644
--- a/.idea/kotlinc.xml
+++ b/.idea/kotlinc.xml
@@ -4,6 +4,6 @@
     <option name="sourceMapEmbedSources" />
   </component>
   <component name="KotlinJpsPluginSettings">
-    <option name="version" value="2.0.20" />
+    <option name="version" value="2.1.0" />
   </component>
 </project>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 31b97053d..e4e87131b 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -3,6 +3,12 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.11" />
   </component>
+  <component name="EntryPointsManager">
+    <list size="2">
+      <item index="0" class="java.lang.String" itemvalue="com.android.tools.metalava.model.junit4.ParameterFilter" />
+      <item index="1" class="java.lang.String" itemvalue="com.fasterxml.jackson.annotation.JsonValue" />
+    </list>
+  </component>
   <component name="ExternalStorageConfigurationManager" enabled="true" />
   <component name="NullableNotNullManager">
     <option name="myDefaultNullable" value="org.jetbrains.annotations.Nullable" />
@@ -50,7 +56,7 @@
       </value>
     </option>
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" project-jdk-name="21" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/classes" />
   </component>
 </project>
\ No newline at end of file
diff --git a/FORMAT.md b/FORMAT.md
index 6af5b81d7..830aef720 100644
--- a/FORMAT.md
+++ b/FORMAT.md
@@ -304,21 +304,9 @@ Here's an example:
 In v1 files we only list type names, but in v2 we allow an optional parameter
 name to be specified; "commit" in the above.
 
-Note that this isn't just for Kotlin. Just like there are special nullness
-annotations to mark up the null contract for an element, we will also have a
-special annotation to explicitly name a Java parameter:
-@android.annotation.ParameterName (which is hidden). This obviously isn't usable
-from Java, but Kotlin client code can now reference the parameter.
-
-Therefore, the following Java code (not signature code) will also produce
-exactly the same signature as the above:
-
-```
-    public static void edit(SharedPreferences prefs, @ParameterName("commit") boolean ct) {…}
-```
-
-(Note how the implementation parameter doesn't have to match the public, API
-name of the parameter.)
+Note that this is just for Kotlin. There is no support for using this for Java
+as Java does not consider parameter names to be part of the API and so Kotlin
+will not use parameter names when calling Java.
 
 ### Support Default Values
 
@@ -333,15 +321,8 @@ and/or parameter name:
     method public static void edit(SharedPreferences, boolean commit = false);
 ```
 
-For Kotlin code, the default parameter values are extracted automatically, and
-for Java, just as with parameter names, you can specify a special annotation to
-record the default value for usage from languages that support default parameter
-values:
-
-```
-    public static void edit(SharedPreferences prefs, @DefaultValue("false") boolean ct) {…}
-```
-
+For Kotlin code, the default parameter values are extracted automatically.
+However, Java does not provide any way of specifying default values.
 
 ### Include Inherited Methods
 
diff --git a/build.gradle.kts b/build.gradle.kts
index 80e1361cc..8a3170b20 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -17,6 +17,7 @@
 import com.android.tools.metalava.CREATE_ARCHIVE_TASK
 import com.android.tools.metalava.buildinfo.CREATE_BUILD_INFO_TASK
 import com.android.tools.metalava.buildinfo.CreateAggregateLibraryBuildInfoFileTask.Companion.CREATE_AGGREGATE_BUILD_INFO_FILES_TASK
+import com.android.tools.metalava.buildinfo.setUpAggregateBuildInfoFileTask
 
 defaultTasks =
     mutableListOf(
@@ -30,7 +31,4 @@ defaultTasks =
         "ktCheck",
     )
 
-project.tasks.register(
-    CREATE_AGGREGATE_BUILD_INFO_FILES_TASK,
-    com.android.tools.metalava.buildinfo.CreateAggregateLibraryBuildInfoFileTask::class
-)
+setUpAggregateBuildInfoFileTask()
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/MetalavaBuildPlugin.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/MetalavaBuildPlugin.kt
index 6e0128486..6e4595085 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/MetalavaBuildPlugin.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/MetalavaBuildPlugin.kt
@@ -16,18 +16,12 @@
 
 package com.android.tools.metalava
 
+import org.gradle.api.tasks.bundling.Jar
 import com.android.build.api.dsl.Lint
-import com.android.tools.metalava.buildinfo.CreateAggregateLibraryBuildInfoFileTask
-import com.android.tools.metalava.buildinfo.CreateAggregateLibraryBuildInfoFileTask.Companion.CREATE_AGGREGATE_BUILD_INFO_FILES_TASK
-import com.android.tools.metalava.buildinfo.addTaskToAggregateBuildInfoFileTask
 import com.android.tools.metalava.buildinfo.configureBuildInfoTask
-import java.io.File
-import java.io.StringReader
-import java.util.Properties
 import org.gradle.api.JavaVersion
 import org.gradle.api.Plugin
 import org.gradle.api.Project
-import org.gradle.api.artifacts.Configuration
 import org.gradle.api.component.AdhocComponentWithVariants
 import org.gradle.api.internal.tasks.testing.filter.DefaultTestFilter
 import org.gradle.api.plugins.JavaPlugin
@@ -44,10 +38,14 @@ import org.gradle.api.tasks.testing.logging.TestLogEvent
 import org.gradle.kotlin.dsl.create
 import org.gradle.kotlin.dsl.get
 import org.gradle.kotlin.dsl.getByType
+import org.gradle.kotlin.dsl.setEnvironment
 import org.jetbrains.kotlin.gradle.dsl.JvmTarget
 import org.jetbrains.kotlin.gradle.dsl.KotlinVersion
 import org.jetbrains.kotlin.gradle.plugin.KotlinBasePluginWrapper
 import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
+import java.io.File
+import java.io.StringReader
+import java.util.Properties
 
 class MetalavaBuildPlugin : Plugin<Project> {
     override fun apply(project: Project) {
@@ -63,8 +61,8 @@ class MetalavaBuildPlugin : Plugin<Project> {
                     project.tasks.withType(KotlinCompile::class.java).configureEach { task ->
                         task.compilerOptions.apply {
                             jvmTarget.set(JvmTarget.JVM_17)
-                            apiVersion.set(KotlinVersion.KOTLIN_1_7)
-                            languageVersion.set(KotlinVersion.KOTLIN_1_7)
+                            apiVersion.set(KotlinVersion.KOTLIN_2_0)
+                            languageVersion.set(KotlinVersion.KOTLIN_2_0)
                             allWarningsAsErrors.set(true)
                         }
                     }
@@ -82,7 +80,7 @@ class MetalavaBuildPlugin : Plugin<Project> {
         project.group = "com.android.tools.metalava"
     }
 
-    fun configureLint(project: Project) {
+    private fun configureLint(project: Project) {
         project.apply(mapOf("plugin" to "com.android.lint"))
         project.extensions.getByType<Lint>().apply {
             fatal.add("UastImplementation") // go/hide-uast-impl
@@ -94,7 +92,7 @@ class MetalavaBuildPlugin : Plugin<Project> {
         }
     }
 
-    fun configureTestTasks(project: Project) {
+    private fun configureTestTasks(project: Project) {
         val testTask = project.tasks.named("test", Test::class.java)
 
         val zipTask: TaskProvider<Zip> =
@@ -114,6 +112,26 @@ class MetalavaBuildPlugin : Plugin<Project> {
                 "--add-opens=java.base/java.lang.reflect=ALL-UNNAMED",
             )
 
+            // Get the jar from the stub-annotations project.
+            val jarTask = project.findProject(":stub-annotations")!!.tasks.named("jar", Jar::class.java)
+
+            // Add a dependency from this test task to the jar task of stub-annotations to make sure
+            // it is built before this is run.
+            task.dependsOn(jarTask)
+
+            // Clear the environment before adding any custom variables. Avoids problems with
+            // inconsistent behavior when testing code that accesses environment variables, e.g.
+            // command line tools that use environment variables to determine whether to use colors
+            // in command line help.
+            task.setEnvironment()
+
+            // Get the path to the stub-annotations jar and pass it to this in an environment
+            // variable.
+            val stubAnnotationsJar = jarTask.get().outputs.files.singleFile
+            task.environment.put(
+                "METALAVA_STUB_ANNOTATIONS_JAR", stubAnnotationsJar,
+            )
+
             task.doFirst {
                 // Before running the tests update the filter.
                 task.filter { testFilter ->
@@ -181,7 +199,7 @@ class MetalavaBuildPlugin : Plugin<Project> {
         }
     }
 
-    fun configurePublishing(project: Project) {
+    private fun configurePublishing(project: Project) {
         val projectRepo = project.layout.buildDirectory.dir("repo")
         val archiveTaskProvider =
             configurePublishingArchive(
@@ -227,15 +245,13 @@ class MetalavaBuildPlugin : Plugin<Project> {
                         }
                     }
 
-                    val buildInfoTask =
-                        configureBuildInfoTask(
-                            project,
-                            this,
-                            isBuildingOnServer(),
-                            getDistributionDirectory(project),
-                            archiveTaskProvider
-                        )
-                    project.addTaskToAggregateBuildInfoFileTask(buildInfoTask)
+                    configureBuildInfoTask(
+                        project,
+                        this,
+                        isBuildingOnServer(),
+                        getDistributionDirectory(project),
+                        archiveTaskProvider
+                    )
                 }
             }
             repositories { handler ->
@@ -277,7 +293,6 @@ class MetalavaBuildPlugin : Plugin<Project> {
 }
 
 internal fun Project.version(): Provider<String> {
-    @Suppress("UNCHECKED_CAST") // version is a VersionProviderWrapper set in MetalavaBuildPlugin
     return (version as VersionProviderWrapper).versionProvider
 }
 
@@ -291,7 +306,7 @@ private class VersionProviderWrapper(val versionProvider: Provider<String>) {
 private fun Project.getMetalavaVersion(): VersionProviderWrapper {
     val contents =
         providers.fileContents(
-            rootProject.layout.projectDirectory.file("version.properties")
+            isolated.rootProject.projectDirectory.file("version.properties")
         )
     return VersionProviderWrapper(
         contents.asText.map {
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/Publishing.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/Publishing.kt
index a7ed96ec5..69696b1fa 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/Publishing.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/Publishing.kt
@@ -25,7 +25,7 @@ import org.gradle.api.tasks.bundling.Zip
 
 const val CREATE_ARCHIVE_TASK = "createArchive"
 
-fun configurePublishingArchive(
+internal fun configurePublishingArchive(
     project: Project,
     publicationName: String,
     repositoryName: String,
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/CreateAggregateLibraryBuildInfoFileTask.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/CreateAggregateLibraryBuildInfoFileTask.kt
index c28af817f..bef7a94f2 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/CreateAggregateLibraryBuildInfoFileTask.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/CreateAggregateLibraryBuildInfoFileTask.kt
@@ -19,15 +19,17 @@ package com.android.tools.metalava.buildinfo
 import com.android.tools.metalava.buildinfo.CreateAggregateLibraryBuildInfoFileTask.Companion.CREATE_AGGREGATE_BUILD_INFO_FILES_TASK
 import com.android.tools.metalava.getDistributionDirectory
 import com.google.gson.Gson
-import java.io.File
 import org.gradle.api.DefaultTask
 import org.gradle.api.Project
-import org.gradle.api.provider.ListProperty
-import org.gradle.api.provider.Provider
-import org.gradle.api.tasks.Input
+import org.gradle.api.attributes.AttributeContainer
+import org.gradle.api.attributes.Category
+import org.gradle.api.file.ConfigurableFileCollection
+import org.gradle.api.tasks.InputFiles
 import org.gradle.api.tasks.OutputFile
 import org.gradle.api.tasks.TaskAction
+import org.gradle.kotlin.dsl.named
 import org.gradle.work.DisableCachingByDefault
+import java.io.File
 
 /** Task for a json file of all dependencies for each artifactId */
 @DisableCachingByDefault(because = "Not worth caching")
@@ -38,7 +40,8 @@ abstract class CreateAggregateLibraryBuildInfoFileTask : DefaultTask() {
     }
 
     /** List of each build_info.txt file for each project. */
-    @get:Input abstract val libraryBuildInfoFiles: ListProperty<File>
+    @get:InputFiles
+    abstract val libraryBuildInfoFiles: ConfigurableFileCollection
 
     @OutputFile
     val outputFile =
@@ -80,7 +83,7 @@ abstract class CreateAggregateLibraryBuildInfoFileTask : DefaultTask() {
         val output = StringBuilder()
         output.append("{ \"artifacts\": [\n")
         val artifactList = mutableListOf<String>()
-        for (infoFile in libraryBuildInfoFiles.get()) {
+        for (infoFile in libraryBuildInfoFiles.files) {
             if (
                 (infoFile.isFile and (infoFile.name != outputFile.name)) and
                     (infoFile.name.contains("_build_info.txt"))
@@ -104,11 +107,29 @@ abstract class CreateAggregateLibraryBuildInfoFileTask : DefaultTask() {
     }
 }
 
-fun Project.addTaskToAggregateBuildInfoFileTask(task: Provider<CreateLibraryBuildInfoTask>) {
-    rootProject.tasks.named(CREATE_AGGREGATE_BUILD_INFO_FILES_TASK).configure {
-        val aggregateLibraryBuildInfoFileTask = it as CreateAggregateLibraryBuildInfoFileTask
-        aggregateLibraryBuildInfoFileTask.libraryBuildInfoFiles.add(
-            task.flatMap { task -> task.outputFile }
-        )
+internal fun AttributeContainer.setBuildInfoAttributes(project: Project) {
+    attribute(Category.CATEGORY_ATTRIBUTE, project.objects.named("build-info"))
+
+}
+
+fun Project.setUpAggregateBuildInfoFileTask() {
+    val buildInfoConsumer = configurations.register("buildInfoConsumer") { configuration ->
+        configuration.isCanBeConsumed = false
+        configuration.isCanBeResolved = true
+        configuration.attributes.setBuildInfoAttributes(project)
+    }
+    subprojects { subproject ->
+        buildInfoConsumer.configure {
+            it.dependencies.add(dependencies.create(subproject))
+        }
+    }
+    val buildInfoCollection = buildInfoConsumer.map {
+        it.incoming.artifactView { it.lenient(true) }.files
+    }
+    tasks.create(
+        CREATE_AGGREGATE_BUILD_INFO_FILES_TASK,
+        CreateAggregateLibraryBuildInfoFileTask::class.java
+    ) {
+        it.libraryBuildInfoFiles.from(buildInfoCollection)
     }
 }
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
index 088120362..7612bb25a 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
@@ -19,12 +19,7 @@ package com.android.tools.metalava.buildinfo
 import com.android.tools.metalava.buildinfo.LibraryBuildInfoFile.Check
 import com.android.tools.metalava.version
 import com.google.gson.GsonBuilder
-import java.io.File
-import java.io.Serializable
-import java.util.Objects
-import java.util.concurrent.TimeUnit
 import org.gradle.api.DefaultTask
-import org.gradle.api.GradleException
 import org.gradle.api.Project
 import org.gradle.api.artifacts.Dependency
 import org.gradle.api.artifacts.ProjectDependency
@@ -37,6 +32,9 @@ import org.gradle.api.tasks.OutputFile
 import org.gradle.api.tasks.TaskAction
 import org.gradle.api.tasks.TaskProvider
 import org.gradle.api.tasks.bundling.Zip
+import java.io.File
+import java.io.Serializable
+import java.util.Objects
 
 const val CREATE_BUILD_INFO_TASK = "createBuildInfo"
 
@@ -77,7 +75,7 @@ internal fun configureBuildInfoTask(
     inCI: Boolean,
     distributionDirectory: File,
     archiveTaskProvider: TaskProvider<Zip>
-): TaskProvider<CreateLibraryBuildInfoTask> {
+) {
     // Unfortunately, dependency information is only available through internal API
     // (See https://github.com/gradle/gradle/issues/21345).
     val dependencies =
@@ -85,7 +83,7 @@ internal fun configureBuildInfoTask(
             it.usages.orEmpty().flatMap { it.dependencies }
         }
 
-    return project.tasks.register(CREATE_BUILD_INFO_TASK, CreateLibraryBuildInfoTask::class.java) {
+    val buildInfoTask = project.tasks.register(CREATE_BUILD_INFO_TASK, CreateLibraryBuildInfoTask::class.java) {
         it.artifactId.set(project.provider { project.name })
         it.groupId.set(project.provider { project.group as String })
         it.version.set(project.version())
@@ -112,7 +110,12 @@ internal fun configureBuildInfoTask(
         // This should always be "metalava" unless the target changes
         it.target.set("metalava")
     }
+    project.configurations.consumable(BUILD_INFO_PROVIDER_CONFIGURATION) { configuration ->
+        configuration.attributes.setBuildInfoAttributes(project)
+    }
+    project.artifacts.add(BUILD_INFO_PROVIDER_CONFIGURATION, buildInfoTask)
 }
+private const val BUILD_INFO_PROVIDER_CONFIGURATION = "buildInfoProvider"
 
 fun List<Dependency>.asBuildInfoDependencies() =
     filter { it.group?.startsWith("com.android.tools.metalava") ?: false }
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 646fd2de9..dfe205508 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,9 +1,9 @@
 [versions]
-kotlin = "2.0.20"
-androidLint = "31.8.0-alpha08"
+kotlin = "2.1.0"
+androidLint = "31.10.0-alpha06"
 
 [libraries]
-androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.7.0-alpha09" }
+androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.10.0-alpha06" }
 androidLint = { module = "com.android.tools.lint:lint", version.ref = "androidLint" }
 androidLintApi = { module = "com.android.tools.lint:lint-api", version.ref = "androidLint" }
 androidLintChecks = { module = "com.android.tools.lint:lint-checks", version.ref = "androidLint" }
@@ -19,6 +19,8 @@ asm = { module = "org.ow2.asm:asm", version = "8.0" }
 asmTree = { module = "org.ow2.asm:asm-tree", version = "8.0" }
 clikt = { module = "com.github.ajalt.clikt:clikt-jvm", version = "3.5.3" }
 gson = { module = "com.google.code.gson:gson", version = "2.8.9" }
+jacksonDataformatXml = { module = "com.fasterxml.jackson.dataformat:jackson-dataformat-xml", version = "2.15.0" }
+jacksonModuleKotlin = { module = "com.fasterxml.jackson.module:jackson-module-kotlin", version = "2.15.0" }
 junit4 = { module = "junit:junit", version = "4.13.2" }
 kotlinGradlePlugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
 kotlinStdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlin" }
diff --git a/gradle/verification-keyring.keys b/gradle/verification-keyring.keys
index 52dd92f49..1b7538fdd 100644
--- a/gradle/verification-keyring.keys
+++ b/gradle/verification-keyring.keys
@@ -1,7 +1,6 @@
 pub    80C08B1C29100955
 sub    CF771F914C2A4A73
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBE2fCWARBAC3v9wYo5kmynmVP+43ccamidflSLQjjpsXpSDLPFokGxeuw0OC
 QJy46m8b5ACoCqRlfwnRRcEHxiSlaBATJA6hi7NRO41R39C62JXsIxNJR16JNQ5k
@@ -32,7 +31,6 @@ pub    84E913A8E3A748C0
 uid    The Legion of the Bouncy Castle Inc. (Maven Repository Artifact Signer) <bcmavensync@bouncycastle.org>
 
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGR/8HUBDADJ+V5VgTXFG4xVI/1r07a/pTXoAQhHyJMkVdFScGARsps07VXI
 IsYgPsifOFU55E7uRMZPTLAx5F1uxoZAWGtXIz0d4ISKhobFquH8jZe7TnsJBJNV
@@ -53,7 +51,6 @@ uid    J. Daniel Kulp <dan@kulp.com>
 
 sub    594E23256A36A392
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBEqQOcwBEACdPSfBAkHm1b2GdOjB3gGerx/JDn3zYNnNpcQrM8Do0bxDwlfT
 qwLA0P9ju4mzTfHU5kEvm2lrXz8QCZPLe9eY6GxzzSbeXtt+4fP84/YGmsK6DQTy
@@ -98,7 +95,6 @@ uid    Open Source Development <mail@marcphilipp.de>
 
 sub    8B2A34A7D4A9B8B3
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFrKW9IBEACkqUvM7hU1WqOOeb1gZ7pUsRliHuoUvYIrd+hdp+qhPmJ0NG0W
 YhZK5UtJBmqvtHKRkbwYxUuya9zlBmCfQFf0GpFKJ65JSrPSkZADI3aZ4aUkxIUw
@@ -141,7 +137,6 @@ tRGH8AOkjAfNdZiOwFcvFj1wnvC2u9rpJmsRBm6SfJnc0tjyZKO5pg==
 pub    8671A8DF71296252
 sub    51F5B36C761AA122
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFoQh54BEADOuivAfgGKc4/zDwx+AwJdctjTT0znL9knRTYG6ediv2Eq+CXm
 gBM9m5twl+qhUB1NtrdHb4BH49VY9/gHr3JDyo5ewu96qkbeQl4pxW0zmHg/yJx7
@@ -185,7 +180,6 @@ uid    Gary David Gregory (Code signing key) <ggregory@apache.org>
 
 sub    59BA7BFEAD3D7F94
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE2kzuwBCACYV+G9yxNkSjAKSji0B5ipMGM74JAL1Ogtcu+993pLHHYsdXri
 WWXi37x9PLjeHxw63mN26SFyrbMJ4A8erLB03PDjw0DEzAwiu9P2vSvL/RFxGBbk
@@ -212,7 +206,6 @@ IsGn88kjyyYqOy8WJEjoOXFh++dpWiM7nZkgQcNi5A==
 pub    873A8E86B4372146
 sub    1AFEC329B615D06C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEdddbQRBADRgstdUZq7ceq3NYcR5kpoU2tN2Zvg1vptE9FxpDbL73gdLWnI
 C7IAx+NNjdG7Ncdg+u10UZv6OSmhWAd8ubWcD9JxKtS4UXkNPHxhHFHqVPHuCwsQ
@@ -244,7 +237,6 @@ uid    Gradle Inc. <info@gradle.com>
 
 sub    5E9AEEBA28836032
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBGUVRogBEAChVh0t3YAJIdreb6SP/lf4x097IRpOiJ7Ww+DDtXFUhKJBwgfC
 4T10TBGP835tV6TfkEeCPGWABoxaD88zUlSHs7k7v/SfedwfOKbOE3c+oR43JL7P
@@ -289,7 +281,6 @@ uid    Emily Johnston <epmjohnston@google.com>
 
 sub    37AE8263DA3084E5
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBFu8+5UBDAC74QfHuMgQVUqSmwgE+zWX1YKY4w9a0vKrj7E4tRY8JXaX6GtH
 TWnOkAndsxK3kpUyRx8S7f4HL4Sxf05Tar22nrNkuiQddKjLsdlH7VIolGW1eFm2
@@ -326,7 +317,6 @@ uid    Antoine Mottier <antoine.mottier@ow2.org>
 
 sub    C327DD2B96A50E1C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBF6WyHgBEADOrbvGGDYVckFcUofqKiYrBneClFJH1ANheF+KIekmnFV2SH1Z
 RS2rw12IbpCjwqjhFTMWH2UTLF6pAsSGIufTrSVUAF2WxHw84Y60KmwuYayJCVd3
@@ -371,7 +361,6 @@ uid    Ktlint (ktlint signing key) <ktlint-admin@pinterest.com>
 
 sub    B89991D171A02F5C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBF9amNkBEADKyJj5snYd8bZpONpu1QHf7c/TK9HxcMzGZaIv9QzViX6CtEHb
 2Q2x6ejXQ2frECMrvns5JAJd21B6215EhlOqrHSMkTrQ6fvOIfWd0huZ0QHr4FME
@@ -416,7 +405,6 @@ pub    99CE9D9F22DC5C99
 sub    6C907406A9482E08
 sub    B2581403B6FA2318
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEJDQwIRBAD8GFadoCUDLBvFZaR/xu2KS+k8dgfqtYKXpEQ2CH05lpFWrTXo
 C6h9koiHcsMKtgLFE0LG6nHTUbLs2W7gBCaCk9HzMmsFI5D7RDbyga0wvvg96y4d
@@ -461,7 +449,6 @@ WjXlAJ0Tp3W/Ij5GUere1wynm2Ol+6Tv4Q==
 pub    9A259C7EE636C5ED
 sub    D66472CF54179CC4
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFKD+PgBEAC8IkWujQlmU0/7+QPZFsc/z/rXgg7BQyo330QK4HeMzeCK6WHa
 SWzVDM9h6nFDs6Xln6YexbZUjLsxS/a/Ox2i26Qg8B+NghgiratbdJsByRrU/3la
@@ -505,7 +492,6 @@ uid    Benson Margulies <bimargulies@apache.org>
 
 sub    32E3DF6FC5E91334
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBEzDDl0BEADHvJW2uff8vfxbfy0IvNOK4aytU+HVEvKEmuSqYEzC8i3BF6RT
 LOxTeRFlu92rYz5ypD0mdNCzQaH0xbkcjialP6FpPCByrM9fFv6hmxZFSY71rvqz
@@ -550,7 +536,6 @@ uid    Slawomir Jaranowski <s.jaranowski@gmail.com>
 
 sub    E3F6790A5A167F5A
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBGHDIagBEADpzdCwVjVlHuo8qpu9HtmqNpEW4TB7y6+NX7Q39mj8w+iVskE1
 sL0+BOCdP6ZMiQziWbOQ2FxCd3mD0ixZ7v1i7+0jowySPacJbVNaPPECP38gDte4
@@ -593,7 +578,6 @@ mMc1ojZ9QHu9WXM+cEND6KY3m407KYw2ItiMcY3Y5fNTRdEMvu7S
 pub    A1B4460D8BA7B9AF
 sub    BA6D22590B3F9BEA
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE4waOEBCADHDHNTq1NRR5TSooIrKY0BTQnaLfjKZfcJOwp+btBJrOUO7+e/
 V3M4DZQclj/e8SBiVmRPK8Oyrv6i5B5+Ee/qNlLjWiO10AJ/PLRjYdoW1V6PlTm7
@@ -621,7 +605,6 @@ uid    Stefan Bodewig <bodewig@apache.org>
 
 sub    6366592024774157
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBDsSIk4RBADSCj6rUjV64tYCGT1DYKYR7GthyWpNdGHSYLbETBcDatAe1dzQ
 5NsCgfrlybfyeY+y1lxr3T9bqf6zJWDw/718wff96qmmv1qzexSYtmIrj+h53V82
@@ -650,7 +633,6 @@ uid    Thomas Neidhart <thomas.neidhart@gmail.com>
 
 sub    8183E80D264EE073
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBE8YNGIBEADEgcfvs8TL3X2Ql62HJ6SrXWAOoHw5CquJxUQkvBGesIT1Hk24
 exiPwrlNE1qUjbVlef1Cwk9ZfwMOpJdfP2MQQbx0nxxqv+JtsoeXUy9bTSvZYBUL
@@ -695,7 +677,6 @@ uid    Tom Denley (scarytom) <t.denley@cantab.net>
 
 sub    9C4C23E6FFE405BD
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE+xZxIBCACzKctn4ez8xOC0pGThhAwjYWGkzcwK4HNaC1usHThBFz3/t8JN
 OqUXRixLyi5wELN6GHlsGVUQS3IfB4JtuhScsieSB8PTree68/knMq6JI08mJqZr
@@ -723,7 +704,6 @@ pub    A6EA2E2BF22E0543
 uid    Tobias Warneke (for development purposes) <t.warneke@gmx.net>
 
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBFJQhigBDADpuhND/VUQwJT0nnJxfjAIur59hyaZZ3Ph/KIgmCneyq7lzYO6
 xa1ucH8mqNBVNLLBhs4CjihBddU/ZKTX3WnZyhQKQMZr3Tg+TCNFmAR4/hnZ3NjZ
@@ -738,12 +718,48 @@ dCBwdXJwb3NlcykgPHQud2FybmVrZUBnbXgubmV0Pg==
 =q1C6
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    A9321EDAA5CB3202
+uid    Werner Randelshofer <werner.randelshofer@bluewin.ch>
+
+sub    D36DB5C489BAAC5B
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+
+mQGNBGBoC2ABDACyCWLqqAo9NeThE90hBoYomtgLci5I8+7PxSYeQfzUYjXzZcnh
+6d/zHaeC0zxGhT2LNe5i3p2e36xSeFDobjG2Il/nv+4jFCgbn3TZ2hEingPuPsg5
+isodOXHBSY9iHPTKInpiu+J79MWP9GVZ6GeOOgQaNSrNN3uDE1w3rukB2SrXGdfT
+/6YZIOtwWZVzc2m9lalPmOAyI4KLI/s37C8Ozfv3c+Bx11WRVzWVpBTo94fU4DPu
+Yzkx2Wxuc4TT5k6bQJI/GHi36M7xkUauXhkRCNvBz+LFVcFjtsv6S37L6RZib6mz
+jZTW+iyD4h66gqzg3hSRxv4YzHgR/Os26Br2ioZNzH6hJFtNktR4oN/2kydmj5Od
+WYjvdMmd/dMbZheZE3f8sziUKCyvWMIddnHAM81uDTXgWcMgYSa3npOGZhfk41z+
+w9o2f1kXIfdurqlA1n8np07PLw5Rfpjvbs7EZxPTJwcc1enaNyL64fb+YIUtFrcW
+Dt1zUMEDkbcZL1UAEQEAAbQ0V2VybmVyIFJhbmRlbHNob2ZlciA8d2VybmVyLnJh
+bmRlbHNob2ZlckBibHVld2luLmNoPrkBjQRgaAtgAQwA9dZFGqc0/6pUKDUsT+2h
+Mh0z5mISLc+x6v4wbAqiEcBE9uoKf0LniRfVeehmuJpiUPgOf3TyxNbxeWiFuJEL
+ZbnrYztAeRE66Zxk6i2Mv+207fdlj3mhphdEWh4f/0AJa2PAmiwlcxq1O3VJ/Wfn
+3huCqIU5cmqnmGKH9LPaW1aJBxWl9+x6mmPVySxpTaQRrnNnumZf9K5lwGEsccvp
+kLP7J1Nlv7HLO8oliPCInEMcsrVqfiKU/bybxNW1wzPJxp8LNLaCNxuLNl4RCp7t
+PQuZgjcoCnz+JwcxnmNGI+FKqSsFXBZyNTWiQJuaFUQa0QON/+Qj3p+OyW15f+Ff
+LjHI/BkNAi4ncNeeazAwuLCMJGMS+dLarHMbbAKLaH0UI062ch3Aq2Sa3io1gU6v
+YHvoKNMNfYdNwoGX85EkzX6A9fm9jBviios1RLkpfO70MoxpWjl/rwHG57GOItWZ
+7O53ebs6HrFPdUYQs0Gz/lj+BaQPwDcMxADfYtGnYMepABEBAAGJAbwEGAEIACYW
+IQRurXUrPis46OIjbXupMh7apcsyAgUCYGgLYAIbDAUJA8JnAAAKCRCpMh7apcsy
+Aj39DACMEaGsskfZBBbF9BHklmN9OHbGKK4qfwY6f3Pl+QEC4m2y5Uaxgx4n0SJZ
+/p4YdVopRj07cdVYEkqJC31co0XPvfbjyBfhcH1BXkKQiYAZMUTqc+ILGHrY/vzP
+27Je+vck6M+ntQ/2rBBiPtD6Bj2RcuXupr6MiGavF5U5vzLUkYm49Oq2Wi5gIuBF
+8+6ipjnzrVl4HqGUlFEt8RK3W4I/ZWTJBlwxaIWoAIfkE54FtSqN4dY+LoNllMKb
+zjFBemXfZXHAFEH9cjNh5EvFKm53ff8X+WNgodiVaH+qv2VMZZngEtmj2Y94v5x5
+z+Q3vcoGH6FUdLjefYm5uwEhhBsTyz8gyBmoj8cBBnw3DZexyOPLGDj/3FSimww0
+HXf8RIR7Msc5GGMLXqSZ4WVZM59pFsqjmqfgl+C8WYWMLAt7sXJGuyl2LQoAtR5g
+pkPZqA0wQiIXe7/RgIs6TpqdS4uLh52KzW7VUXqywr+qH53RFujkS0KijW96Lbbl
+ENk54Kk=
+=7ZAG
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    AC5EC74981F9CDA6
 uid    Cedric Beust <cedric@beust.com>
 
 sub    5D9FFE7B8E3DEA8B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBF0YzcYBCADmNIEEzvSsnJnxH0u89Hb5vCCkl+45dWHyCMsCLNty8yL214LV
 B35gnU+6BvRXN3DmTpreCV8/wgI2h1eq83dTO2AsnJTxTjvYpiwAtWhONxWxCU1Y
@@ -770,7 +786,6 @@ Aif+nc/xcspUmhRdTbLgyImt5TGFAjwKVUGwOH9D2ms=
 pub    B0F3710FA64900E7
 sub    7892707E9657EBD4
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFdbSfIBCACrFI0ai/abnV2U2Wa9QQZwGk3Fegc8laiuTKc0GoYdyptd83/H
 hD5S61ppdkOugBjVTHdgda3xJ7zBZdnwjZvV/TyayQltbh6hU+BMlEolzXLgyvY7
@@ -798,7 +813,6 @@ uid    Checker Framework (Official Release) <checker-framework-dev@googlegroups.
 
 sub    32784D4F004B405B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFM1v9ABCADD0KoXq2ZKlUHeIVovQy3gFmW9oFAaraV48ouv8cYvqdf+s91H
 NyqeyNPT/ihFeNqZJUAMyPdwN5xrWD6gxMrOCR7BFhA5kLmAKz4HfFCQ05ViyQdI
@@ -828,7 +842,6 @@ uid    The Legion of the Bouncy Castle (Maven Repository Artifact Signer) <bcmav
 
 sub    315693699F8D102F
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEowbDsRBAD2jx/Q2jNuCkgiS3fzIj6EzDP+2kipIKH2LEnpnTiBlds2PFYM
 xYibVab/grgQODxTdDnAKifbJA/4h1/T7ba+OV+xIUoSI5MbgaF3USidiDHPX0pY
@@ -862,7 +875,6 @@ uid    Karl Heinz Marbaise (SoftwareEntwicklung Beratung Schulung) <kama@soebes.
 
 sub    02A4A6FB70018AD9
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQQNBFT3aMQBIACl/07e2aAdqLGTocp3J694BSGxjH1M4T8BevXH0UTRTXbge0l2
 3IONp63KF1tmHg0skzUu/1Ybau6Zw7k+jRFN+9VmslRprk4fjHjgxmT5U8p1ualk
@@ -940,7 +952,6 @@ uid    Chris Povirk <cpovirk@google.com>
 
 sub    FC9BDC25FB378008
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFlMExYBCACmdTDSXPwSJeYbfYvHoDl5C7vx/0+LOTunDGJN38pNQHYQAZnv
 Gyoc9ZmChrhLoim7z4ILqmNo8eegknepQ3dGdUij4NVIhR+m+8irayTbsNHvo3UG
@@ -967,7 +978,6 @@ QzLSAVn44AHSomlgzecMR6RZk/fwbzSSiOc3rW1mNFOG70iLz9v4/BJb6dbcSlBl
 pub    BCF4173966770193
 sub    C9F04E6E2DC4F7F8
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFKneXIBCACtnX3ZQmPujf6ocvdnhsBheze71DSl34TfebyW2Qt+g9NhMxo4
 DaJy+iFNnsaMwLZRr6k/qf+ISE3A4opWAQlbk+Wb5s6DPPA2cHH6W4GdkxtuJzqt
@@ -995,7 +1005,6 @@ uid    Valentin Fondaratov <fondarat@gmail.com>
 
 sub    606CC6C4533E81A2
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGAic/4BDACtIv4a32pL+84jJNhJ1yb6GFgoWknJSJ6IELIL0Z7m+FYsymRs
 lTJ/QwBgjZlgS3HS7IBhEl5o+kEt2/U5lPkz/krP8By8EvRv18PpfBzmXNT8rGqc
@@ -1032,7 +1041,6 @@ uid    Jerome Dochez <jedo@google.com>
 
 sub    EA2A558279B36E6B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFSwGboBEADoHgtdw+OVEAIF1SiRju8QDuhePZbpSgRLrt25AmowHJhOQUI1
 EP7+RWoCWW9gWAGas5mGDBxhPw8NgFv1nMUWFAsj0rkViuRD4qpJbChvlqw7YkOq
@@ -1077,7 +1085,6 @@ uid    Ron Shapiro <ronshapiro@google.com>
 
 sub    4006CBA6D352F1FC
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFbgSbABCADGGENSy3oWLjW7zfYMSsR0pm3l3eMA7ptyU5C0U/MoIYjbXwyX
 XtlGwKnNgngATh1SMpX4WDbD8tn6vdeP4uHQsDb40t0XN7/HISFcLhV5pCgz2wNR
@@ -1106,7 +1113,6 @@ uid    TFLite Support <tflite-support-github-robot@google.com>
 
 sub    29E792953D515FC5
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF8pVB0BDADcwRGpJUDe8eVSlJ0yPQl/CyeYc0RWq2f1seUMQO0xFW1xPIeL
 IE68D9VdgarA88qDLYesfBqzn57/r/ztj2aLEKt8IRunJzd0w0G2rrgSCZQ8RmzL
@@ -1144,7 +1150,6 @@ uid    Marc Philipp (JUnit Maven Deployment) <mail@marcphilipp.de>
 
 sub    BF07AD5B93D4BEBE
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE+VqAwBCADvIJMQYWtHnfpfI9IB9WPd+Fd5xlFT7R9trJEfQGA6TDH0IsqH
 0CXVLJ4fa+PiWfkDELK6b1qsGg52+mbzZzkbH+XAsX81sMEF6j5H4pjE9KPB8xAv
@@ -1173,7 +1178,6 @@ uid    Herve Boutemy <hboutemy@apache.org>
 
 sub    64863FF4D1BF1809
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEdUhrIRBADCU9cuKc92CWQlZxwtRuSIV/36Qmj264YD+Lix+r1Qe1PqRr1I
 /MObOo83ulorWigSkx1k81Mnr56NwmIeo2bMhjmgRgf7EG6XEbKdRKfJcJRR1lDV
@@ -1206,7 +1210,6 @@ uid    Tatu Saloranta (cowtowncoder) <tatu.saloranta@iki.fi>
 
 sub    AFF3E378166B1F0F
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFeWvEwBCAC7oSQ7XqcGDc6YL4KAGvDVZYigcJmv0y5hWT4wv9ABP4Jhzr1H
 NDmmGyWzhzTeMxwuZnc9vhxCQRwyxj3gGI5lYPEARswbi2fWk//78/3Wk+YMHJw3
@@ -1230,12 +1233,55 @@ Ett6PX9Hrvc1MTy/UUdb3s08C0wD0x+ZzFzqUXKTZg==
 =Yytq
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    CA80D1F0EB6CA4BA
+uid    Sylwester Lachiewicz <slachiewicz@apache.org>
+
+sub    5EAB8AD72016DF52
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+
+mQINBF62njsBEADakbaGRfpiftmwO/KncA+vG8cNJzPNEU1HD+o0ReMPO6H5G45b
+7gxhZut1Ag1jT/vPbSsTtCloCCy8WF7GtWbjCvvRd8SMP0dlH3vG3rnprXxUCnN4
+jxBCy5Gd/5uPy1G/pMgOwZ03Aam4QP6fQWQ1P+pKT36ZwYcl7jrriYT3jixDIpl3
+kTB9zEwdfN7YBqBczxk+xSlrPMYuYV9i1/+bMgWcRB7w2d+7dwrnxzx3RuUcCxKS
+bPQO4nrq9BalYbaJiGmc/M8sqlLnEsXZjGpFWH06OGSAvW+umyWZ8+nAueSJ3+2d
+6GrGf7lok7UL8zBN8h6TcwTboHY4VUiYk9Fx6Ep6gGxujD9B2hbsL1PWXAX/BqYx
+XE1PGNSB2AoZR4376qxVJnp/SphH7OiNsFOHpiQrrNKu/HOcZZlPLO01Fbkzgx0O
+T5nHRHaWhUvmqGRphogmUVEkNwXMO92FILLkcvBGlNmyGDesw5300QEijdcXLZzi
+LZBuyANzn7Ve0Bk8b6nNVaNln3yCkwLfrsROPItcj/rlEhS3bjvM5E+VmqBD6pvS
+kldJPDKJJGfJZFu7jx5x7kygrVZyFayJsSslnBGsyMvmORNhA1zzWR7tn1BNhCB1
+8JSiXAZEIrh6YOkK9mDlCYppoPZCUshCZVPD8l18eK7A2MQ8luQvgqC6dQARAQAB
+tC1TeWx3ZXN0ZXIgTGFjaGlld2ljeiA8c2xhY2hpZXdpY3pAYXBhY2hlLm9yZz65
+Ag0EXraeOwEQALpzPkRBKxYJAcw+2qkykssP4HaJXV+dCM3v+Ltf9xzfLnRLBDs9
+gnBtgVDTM62tMwiEvjYHgkKA7tQZGVsZLRxXVTbxcB5nxAkxaBFxIyfJ7lcnM1WI
+7xeyH1n7x4UDTKFBYysYvnwOComsBbFbQlLKg22qs4dx6pqbDrcExAagDrR43f7h
+AtGEvQtOk51LEIOptr6ddaK8PGiKBOGv98eqYvl8gkyE50atWEYf2XVgMskHAsES
+Rl/C/i1zBJonIZMFtK+6RGpX8bQ7p3cRD3y5LnNwxT3piszG9LkJigj/4bbPDMyK
+cLni/rxtZBMDY+gD3j62lKvdAmbt0Dxom/j+yJrS/uWbHiE5psbrZooq4gMdsgVV
+DlrCFG3WYnVh56sgjROKAXq4jN1uqrKi3Fxn0Bu73bpjo/8A0xJX4EqE03OqJGRV
+yq+uxOvCndZkeVkK1K4Cvz52kHHRYRUsiGKKWleTI6bWgvDjmJ2xh1lE92Fxwtcn
+t6PJcM9nrDrSpE2zzQt0IT7NWMYg9vrNm3RmKqkQx4w5QNOkl8cGVZ03eKuAaIYB
+gopiT5GzHGE/fmfLs+z3zogwllw9FjsSWZQWM7DJJg/KSYNqGJZddmbXM9ZMQgBn
+rMEYc9qpzmmHaGJcNbyIzAuWAQXpglv1yPiNJHhfCCO1v+wrLTPbx5w9ABEBAAGJ
+AjYEGAEKACAWIQQyEYz3bJ7F2RjlSWfKgNHw62ykugUCXraeOwIbDAAKCRDKgNHw
+62ykuhvfEACaVeVfbaRI7Lq5XzoxEedFfACs9g76xlha2verAcmOjw74de93T/7l
+vz0z6tJQMQigGS+UsABWenn1J0U/gKZq7sqUhT5qsov/LHv9gLR8iqu7Yfz6lFne
+zsfPqWr8Qe/XfLaO1psID5/hAx6KJ6/52RVTE4OQtyvIxl7hpkV8DsfbkqB3uHZf
+/7vH7nt41pkPqX0wYPG3FIzROjxw11f2K9Mg66l1N1PCJD+AfpV7OcL/2eFcIETC
+I4p1xlyb7a2wYgj2xgpH8SJ6Fc5dOwq4Pec3yjWkV7CqWE3OirNo/tCHCk9XXDoB
+gKXFlhxEouADxjB7FbuDb1HR2qG/G6TBKwTSHZ+0mXrUV19kjfMOz4DtRhq34H6X
+xJG2V4XNE31/xbw9QPV96/avlB8wMQyxok3RR6P47cE1XIwL3npo3eH0HbIoElhb
+zGmLon9yIHdLfZQQNo5V6OvF2T/IKzJk5SjXXJWl8T7o6GK4FYKe4J0lGU9utF2X
+aLeuCeaeqXTlxRR2izI0by6bH9TSFVaK4DdU+85xvXLqvyCNWQ7kbpYiagpXzrg0
+elDkvkksr0hPI4t0HQzw4O8JkJoI228SQt9Kxz+NS7p4zLdwywc2iaBOss3+aaF2
+jruIBFa+COdqCBtqC0Rvh2GhfthHtIpNFr3Lvu7y6cjP7YggzXQ3Dg==
+=AKpr
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    CE8B1D1D2530EDC5
 uid    Eclipse Implementation of JAXB Project <jaxb-impl-dev@eclipse.org>
 
 sub    7ECBD740FF06AEB5
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFuX5CkBEADkTgn4nzuq0lWR+7kFGYLKvmPLjes4j2nmygIafUjVbNmD70gY
 DPpbSP02HxgicM6xSSqzZuBVxpbcffqjMPXf8LkVX4iWKZtyzLpf34yaojigU3qF
@@ -1292,7 +1338,6 @@ uid    Deanna <deannagarcia@google.com>
 
 sub    5199F3DAE89C332D
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGCtdhoBDADdopjDt4eUNEqLJSw1ZICSR0oq09SOVtJSaSYdF8UiXjBfL1Ds
 fhTDqSv5pT2a2gLj0OU3tFhWHvINLaKKCjQnHVcFXi2LTxt+XBOjRYkFjHVisbaZ
@@ -1329,7 +1374,6 @@ uid    Liam Miller-Cushon (Error Prone releases) <cushon@google.com>
 
 sub    3F606403DCA455C8
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBGH0NlsBEACnLJ3vl/aV+4ytkJ6QSfDFHrwzSo1eEXyuFZ85mLijvgGuaKRr
 c9/lKed0MuyhLJ7YD752kcFCEIyPbjeqEFsBcgU/RWa1AEfaay4eMLBzLSOwCvhD
@@ -1375,7 +1419,6 @@ uid    Andrea Lin <andrealin@google.com>
 
 sub    63F72A7A8658D653
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFj2NXwBCADPJcGfWz4Zsfa/UEUF6a4aAIjqCy+rNmLf9Vs3HD6B5p1r7VkC
 e0HhxrfbkDkQu6aEmAwV6GwYiwWBf/LQYNdKm1FYZFhKLhyuTPiirFqIouEFqiK2
@@ -1408,7 +1451,6 @@ VcLnowGJ7hvsaYMNYyMbaI/2xg==
 pub    D9C565AA72BA2FDD
 sub    9121AD263441EEDD
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBFrjUQUBDADTMQL/4d9EyVhsO4XBH9wbGWxcEJvsu/HvppN5fY8hpMV0+Cr9
 wjAeJ7d9zdFJVB8vPLN7bb5dm6SNyK3KiOugqVgZrQ+ZPTvCCgFbFyEXuZwDiOa1
@@ -1444,7 +1486,6 @@ uid    Cedric Beust <cedric@beust.com>
 
 sub    50C6CC55C6F24FB1
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBF8tnmMBCADROe7j1ZvgiMgfsQKqCSuSqgMkfMT2DEXwZKdHqkj0gfx8MPQg
 OP1pmMgpIwIXKr5kZ9KMGiGULNnS+WU2SNqjyKeq3MlnSYW5Di52MoAD7W4cHmry
@@ -1471,7 +1512,6 @@ W5SOf8mTnm2l1QQfyZbXZbpSSO30XFVvxlc=
 pub    E0130A3ED5A2079E
 sub    0AE7BBD7FEE66E0C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFlMSXMBCADcgN0/57D/gU5cDobPiRuDT6qAxb/NWhQiqwAocKd274r4gPJm
 RbffUEZEgKhjH6l0CQfilC4R4x2QtU9sNC9kB/D6zumoS1uI0Hmx1pC4UseUy55r
@@ -1497,7 +1537,6 @@ mCQvt2FuiaLL3d/uH0z6EzWs+XZNbjRBTGI9VmO7siIy6rjatdult3Sx1quBCixC
 pub    E16AB52D79FD224F
 sub    5A34A5E06B936F93
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFF/4bYBCADTeOLZiVGNbjlPrwG7UcMl+yXmEqpf9dB1A9cuicH3PWXj0WOb
 LSzHjzoRvRekEqSUmgoveey1lPuA2qjOUkXY6Kiyx+oLiG0/ObJHUQW2O+tjSQ0R
@@ -1527,7 +1566,6 @@ sub    9351716690874F25
 sub    3D5839A2262CBBFB
 sub    60EB70DDAAC2EC21
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF/RX/MBDADSqelDQKobURExWUKALq86yTPMxMasxmDlccKFpk5xjWrryL7z
 qg4Fnb7IK5fKDtcnTANtOv2hlIli1h131+SmjJdD3qhfly7QoszOpr5izDS+FOCj
@@ -1608,7 +1646,6 @@ pub    E93671C7272B7B3F
 uid    Rolf Lear (JDOM) (Used to sign JDOM Packages) <jdom@tuis.net>
 
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFCPD00BCAC4tY8wMQTsCKyII/mMkUDAkXA2cLM47fY1Wn+iohtgtalUdA0v
 AhGvTdFU6/St35rOKNoyLC7Sy30FBYpAEfMB/x9j/CaQtdtGhaQU0hCvtWGhhS3J
@@ -1620,12 +1657,44 @@ TSkgKFVzZWQgdG8gc2lnbiBKRE9NIFBhY2thZ2VzKSA8amRvbUB0dWlzLm5ldD4=
 =Q+9k
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    EB095DA7D2F6AC0E
+sub    603D72C90616CD6B
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+
+mQGNBGBm/LQBDADMr/VPcTvE6k3wEYxq5kZusnDCDTsI6RK51d4oMwaRc3Z0jtZ0
+CfyWocZBok4rMbZAVnE3Q8pMyikGGUnc8ZsWoPEmJyCpw/2Orj0QqZhIgYMQ31Uq
+tiGZF/G4w9phLIkFgU9BLGYjRNM69R0oE/Tj8mjguvnKzYM3GjkY6nDsgWCM5TJX
+01k4sdLs0dVg86m4keq+SeS9uEwnINZTh6kQUKsW6aHvvPXze/UPoaZqxgXDjF+F
+JrPwW8yDllkbzpbo53ulz1TL5RsIH3daUwxXG3ciovUXG/b2ZRuWjtH7Gn/AvCNL
+0RXdHK3A2I23zCooOE+we2D45QUHm/vcmvsnbxOU7Tslm2DsnYxBjf5dAl2yZn+J
+FSrV91Bbd5ZXi1UkkGjBzAgbHDwdMvL9K6fTO9NwjXyBpiHy6ukIOObn9uIgDSSa
+xPnqgeykSv+RZEea8ML4BSif5RJYlmILEzJhH4rtX9X+t8BZv+ZoaN6p/qYg4/2+
+XfSUPmCJjlUaIUUAEQEAAbkBjQRgZvy0AQwAtuysL4l1wLjDIgva/+mD76cekxRu
+54s7zYOkh/87NIZ6tPkPlw/w+m7CEohurx2sQSPrClJoaMqxlPgRCmmj5JQVEC79
+9pkvJZb+QwslD57P84LYntiqpr+nmmR6vgDlZxaiRa6OVUllUTYwDpHcQ8MocXan
+e4iAea99acxL60zOimPeaPVK9tXZQ1nKPVIWs6RSYna54FFZn0uXfG4Qx8xEAXYd
+cUj5oEh4JFtEcP+55YVWopfi+zIQwwJ7JaO6ZZhHco4OpCwTauB/hX2SVdSijV32
+O9IhHXO3xPIi+5RC/iwHrhF3kexNLlfVWMnb/RWC7ROQXdUEK4YQGLy7+dFd7lKQ
+5gbUoAhuqWOnHyaSAyNlFGum3FR5oroad0eKS5jzk2n4UMPNDAoo7yEi1cdCrykD
+Jeb1GQD6ucQx+oqLkc1OGwqVjJU3FDQj/yvSCPKmst9lSGS3JH9l6ac033Db2qAP
+kUxnhw2xN4LHk2Ioovn5SZu1IUzH8/i+HhpfABEBAAGJAbYEGAEKACAWIQR0QPH3
+0nusEV+VPVXrCV2n0vasDgUCYGb8tAIbDAAKCRDrCV2n0vasDkSBC/91fDW0V6U8
+pRwW6HFruAnq/0uQ2gISrmDlpJzsgSO6HQQfho1T/7uuYhnBGyU4dxIF4G9A+Ehh
+2iwhB90JzCNLstTW6ueSWMK+4hvBpfx3kCbs2oxu0z8ZHroxE9I7e5XqDQOazANn
+eLRZJ5SArg1dFGYveBRlyjE55CmDQyj58aJkMbLAAJrdrMkFZHwbeBKOs3ph0zn5
+NvSBDUP8A3wlUXuSySeXYCUIj2k4Q6zJodnhP76ivfpu0eZn4UnD0sI8YdoJOsNK
+gDRO6fR9kEEh/XGY082B1Ad6tO2nea1MIVF0GIgfh3ezd3YcG4Rip0uqIPr7yxpT
+mVEA8wVvpWg8+wY2/xvLuHtZD59bK4KlQ9m+4W5WhursrdUfSI2EuXNp7xYwNRVf
+elApmsOOWqONqWg4leirxkWUMz7XDArDPuei4Qk8VF4/0yfGOVSh8VHQrIauzqrN
+p4LbYC9sii1fqxQTFVGPPhv6Wujd/eUuUeURZbKgpHIfniDXLiaTUyc=
+=aMmv
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    ECDFEA3CB4493B94
 uid    Guillaume Nodet <gnodet@apache.org>
 
 sub    3BD211F725778C36
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBERFeVERBACjfASThn15ynIICr0Gu8quGCl2rSSRar8TsjrbiwYB2MTW35Rg
 NjLU6MN5Nq4d5G8D5aMeoyGODstIHH8zA52sDGeHOMKfDaAraL+lGzElbpmaqP2s
@@ -1657,7 +1726,6 @@ tyujlQjxGTiKBQCgoBIwI2lsUanDnZbPcPilG0OOhiM=
 pub    EE92349AD86DE446
 sub    E68665C8F91BDE69
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBGO91akBCADDDpIrW/IohUSJNDu9VOUlnfEOm5VS49uqM0uucLi0BeAhy1Fo
 P6Yg1cJkcK66DtnUoTM/JJLyDzJRlKnniLrYCkw8ScvtPdA5cQKJTY5ecn+9ouR2
@@ -1683,7 +1751,6 @@ DqhGe5NO7GoCns3XxqjpggME9eCEQooeKHlLCAkX2/XttwVSRlrNsdVb82iKy7E=
 pub    EE9E7DC9D92FC896
 sub    3B7272A25F20140F
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE/oyDcBCACgYsHtmWmtUzqyr/JN+orfJaTl2363qiS+NJ1lt2CNxUWOqldc
 VcIGyjmzokxTRpGdCFmT1Lh/hzZhcDPLjrtxf+f6njIibt80OiEbX39gjwZRIikd
@@ -1711,7 +1778,6 @@ uid    Netty Project Bot <netty-project-bot@users.noreply.github.com>
 
 sub    1C9F436B883DCCF6
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBGAhOxEBEADdB5Jy2sSOndOMCTyk8IFIJYPogjXtN7CnyIlqr4jEB5G87TJf
 m7OxB95aIVS1vSA5ghCm88N1mKtW6jyYjgLFQbbyD9/X3ShVZjh8B2R4atL93SSK
@@ -1757,7 +1823,6 @@ uid    Jonathan Hedley <jonathan@hedley.net>
 
 sub    6064B04A9DC688E0
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEtsF2oRBACcai1CJgjBfgteTh61OuTg4dxFwvLSxXy8uM1ouJw5sMx+OKR9
 Uq6pAZ1+NAUckUrha9J6qhQ+WQtaO5PI1Cz2f9rY+FBRx3O+jeTaCgGxM8mGUM5e
@@ -1788,7 +1853,6 @@ EPQuh/lmUBXJfs8An3O2/IQ/ThzLrM/2Ue3Spd2u5wN+AKCHU4hSTSkXM1gG3c9e
 pub    F6D4A1D411E9D1AE
 sub    B5CB27F94F97173B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE89LqsBCAC/C7QToaRF8eZgGOxcvp9aG+mFFCMjaRAb4Mh59OYdmUb6ZjfO
 9388HPebGbPNR8SHYs0dBIuWY4ZJ7oUTYPswasL8vB0iPFdyHhvkCca+yk0b8ZBM
@@ -1816,7 +1880,6 @@ uid    Baptiste Mathus <baptiste@codehaus.org>
 
 sub    5F68B9B2F1725F16
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFFCLwoBCADxtcGi0nfolr1kGWe3jQ7n18roJFwBs4Q52nx0h4+a8ZGr7/1E
 1brakrz3t/cTSZIrhfru8kirP8cJtXBxpd/nCeRrB/4ZtXPUJiGwKx6sVGr0ix6U
@@ -1843,7 +1906,6 @@ B7NlACz0MCH3fYo=
 pub    012579464D01C06A
 sub    CB6D56B72FDDF8AA
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFgnlA8BCACVtx3oLXcanfvwtMRwal6pLQ8IVMG9+fr4xGdbSHXCRNbosDa5
 agU7WeQMPhusSxJGaA3w7NOdjAwD/LeHADhDPeI6llJg1Fb3EyqH0NZaODKU/Or/
@@ -1871,7 +1933,6 @@ uid    Chao Zhang <zhangchao6865@gmail.com>
 
 sub    8C40458A5F28CF7B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGADx6IBDADoHin1LGQ8dhnlhfNCBZ3IyXS2NpR1VjmYtHSlh1hGsPcmHuwo
 1mLA6JzXF7NuK3Y52pbTr6vz9bAap8Ysjq/3UJeiDbf7FvmO5xAEVUhrpc7AEY7G
@@ -1908,7 +1969,6 @@ uid    Sonatype, Inc. (Sonatype release key) <dev@sonatype.com>
 
 sub    F2E4DE8FA750E060
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEmoKU8RBADEN0Q6AuEWEeddjARAzNXcjEx1WfTbLxW5abiiy7zLEht63mhF
 kBlbyxEIRnHCSrPLUqY5ROWdyey8MJw+bsQn005RZmSvq2rniXz3MpcyAcYPVPWx
@@ -1939,7 +1999,6 @@ SQQYEQIACQUCSagpTwIbDAAKCRADdM8ujdG9/auQAKCCtFUmslioIPSjZkWVLJpo
 pub    056ACA74D46000BF
 sub    DECB4AA7ECD68C0E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEoo3BYRBACXE2oGRA58Ml6s+kvfk6n/AJ+5OFeRT/Xelco/cpdxOVF5LkRk
 yd+vR2+F9ldBlH7CSTCmrdZIN3M3zrcWndrk/OQkCxNWVnE/a1li7L3G9nYr011k
@@ -1967,7 +2026,6 @@ sub    3FF44D37464BBB7E
 sub    6A0975F8B1127B83
 sub    6005789E24E5AD1E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBFzy4ngBDAC4mz6ELMWjfJ8GZtolq3E96T7qjfp4J9FxGVxdbJxkEDnn6MTg
 V8zhD7yeSZcUSvwzPiDlB/b4RYnh+5LjzKHTsrtr9ja0SupuCkVGkMGWeHhpIGV9
@@ -2123,7 +2181,6 @@ uid    Eclipse Project for JAXB <jaxb-dev@eclipse.org>
 
 sub    8118B3BCDB1A5000
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFu1EwUBEADAXapH49L1Lwt28iK737X/+4bRDE+lkMxehnUZ7QJs5zkFz5Sh
 9K2rQO0PpvoMSdadGplFyhKdDP/iEUpzxTTbqMs5UjbJr0MoFfE957Vz59mNf9WY
@@ -2180,7 +2237,6 @@ uid    Paul Holser <pholser@alumni.rice.edu>
 
 sub    71499A87DC1FF84B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBE3LMfMRBAD90h69D8yyPWaSoAyh2mOOOZ/XH0isuBpDZCWptemlMHgImqdQ
 2sXLXYT1bJKmSaMw+yKjp8J/NYk69EbmSK1C2nypLQtWhUmXXd3XVYw6hrG/dGvi
@@ -2213,7 +2269,6 @@ uid    Peter Palaga <peter@palaga.org>
 
 sub    83552A552A0D431C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFBIm/wBCACgqvegptBhfKbyBXZiW+7XchIJCOpwq0/9QgSehKMwELbUKqNM
 sIVrywANqYn32S9hNRvBiKGm/KY7VwN9p1Cr6Ey3XuGSbRo/xN6tqfV/rV5YClL5
@@ -2242,7 +2297,6 @@ uid    Rafi Kamal <rafikamal93@gmail.com>
 
 sub    0190A8A50D88C2C9
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF1wCjUBDADAQDQrGd1ul3QLVj5zbl72zNWVNsRVF98JLSXYMmxsY/A0YNzT
 B8LR58QCNF/xcjDyFt6+9jDEVjkKnJTHduzxddF/cQ9pw+0BOOwyfIkC2ryHzGUH
@@ -2277,7 +2331,6 @@ TaOGLo2nZ/FesPa3uBnylgYyUnzuNZB3kLz3zAM04/jc8Vk=
 pub    15C71C0A4E0B8EDD
 sub    891E4C2D471515FE
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFcyNOoBEACj0zTN3GkRNAY3jihHZdGvi70i4R8mUfcQUwWGRsGGlzSwyJfe
 20qNOHqwHaxVCAIp4e5paNf9cEKepOv5IqMkmaRdiC2W+BHDxcJgBot/IrC81ube
@@ -2321,7 +2374,6 @@ uid    Marc Philipp (JUnit Development, 2014) <mail@marcphilipp.de>
 
 sub    EFE8086F9E93774E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFPU8TIBCADGNvExYTJpVuNGCF9NuWw+IkitjAD7WzF7QkvFCSw9VftzgTUZ
 3PYrThRiaDdmHQAke4Sp+nYyAJ7iUcQqg/5/ONiMdzXEv5Kwy5WJN8+o2aXSunIT
@@ -2356,7 +2408,6 @@ uid    Emily Johnston <epmjohnston@google.com>
 
 sub    5F6BA89D4B0869B9
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF3TQCcBDAD177B+Btl8XBEkBQ5jFSezFrpEl4arwCEa7htCp6T3h55HvYwz
 P7Y9zWYXfhAC8XJlPQJYpqaQiiYtdlmOrOS4wbp5Lr+z/0XpFlJFzdKglxKYcdfP
@@ -2393,7 +2444,6 @@ uid    Robert Scholte <rfscholte@codehaus.org>
 
 sub    A182F48D9C2C0825
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQMuBE4CPoURCACWBMGV/j1pioJPWkD9K9NdeRvld8sBorFBZo99DF3mcJvrXo/t
 We7gmvcx2n/8P5lL27sYPuj6WSRgtVBlSMXllJm3NL3Hu/7XRILfJEKVeLLTdxc/
@@ -2437,7 +2487,6 @@ uid    Rafael Winterhalter <rafael.wth@gmail.com>
 sub    7999BEFBA1039E8B
 sub    A7E989B0634097AC
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBF3Ep5QBEADZfs6o1IpZbZ1qlBkoJ7oWL0vFCcdPUgF/PRFXWKlsuFHVVV/N
 oZF9SDiCJxfvsVXmI+IHTVMR2SszU2xDF2SlScRfZQwrLhBsDP9nv9N1eGIoA5Ny
@@ -2518,7 +2567,6 @@ sub    7D1BE4480B61E2A7
 sub    C2148900BCD3C2AF
 sub    CFF46EE3C17E53E9
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGBP58sBDADYRZmxLOkqrz0QZ/yESRpv7IeHGLqDE1a8QfFtFb14MJCLSAAS
 3nMD6Szi9mEjEqYdJURRcMjbUBhePgbhzGa3FYkjAB8lj6IKbu+ogCwVm1S8+caZ
@@ -2637,7 +2685,6 @@ uid    Brian E Fox (CODE SIGNING KEY) <brianf@apache.org>
 
 sub    AD9CEBA0521B1945
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBEry8yoBEADnhvT3m/zzzuiUKyAeIfnN9CeN0ilQx4P0kFMhyZchRR4Ekb41
 iKw7tDL9q+g7xSo3yUT9dKjDWJ3yhDpdAhp6d4y8GAuWqlOu8CQdEHJOKK0yxTzX
@@ -2680,7 +2727,6 @@ gMqQQpNoy+5xrNg+uv6po4Jjtidfww==
 pub    22E44AC0622B91C3
 sub    BFE9E301CD277BAF
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFpqN94BCACaAb8Afmng1QPu5k5uzLoA1FJnF6Wf31ZU1FzDxHFHLNUYSWN2
 Bg6k95QH5ruZ+Z/QOJSoIB+b3htDklyxd8m+G2KsMIqnQs0BaTN18hb3PFyMIknM
@@ -2707,7 +2753,6 @@ pub    280D66A55F5316C5
 uid    Brian Campbell (key for signing maven artifacts) <brian.d.campbell@gmail.com>
 
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFOOGVgBCACiDwUZOc6943aBGUrxikkfUnsyZfHtF9jihYmA1pSgfsye+JxR
 oG9QWW9+3qx4L/d4ZEqBftTWpsjyrY7NyMaeXtJEjE0vhiWNehgXB1z4XTJ66zCX
@@ -2723,7 +2768,6 @@ YmVsbEBnbWFpbC5jb20+
 pub    29579F18FA8FD93B
 sub    9DF7F2349731D55B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFYFiMABCADYpblWssqGxbjTwsyroPh48BwdSKl59zbFKoEHDw87NeWq7fik
 h95RkbdeWsQSvduXWgQZsUDq9cLOkuS/ChAMkAAd3MPp1NMdFmAqS7BX5wU5s5I7
@@ -2751,7 +2795,6 @@ uid    Charles Lee <ckl@google.com>
 
 sub    D95ECEC170500D9F
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBFsHC7gBDADlkoJglNVbX9MShcAm6jvS5atCZwWT63gSasObXFxswsJQd1NK
 qryHNcj9tKBfLbSpMOoHeyyIKDdwdxN+6+N9Hi4hf0j1Ub6deJyI8ace8VERWaxF
@@ -2788,7 +2831,6 @@ uid    Ceki Gulcu <ceki@qos.ch>
 
 sub    10DA72CD7FBFA159
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE+ZO+EBCAC3fZOOuYKthr0GcUge0PH2bh18sbM9XUmPKQz/W15l1NA/2ARS
 2gUXM0R+SunMlun9KsqjnojJ2ObVPvbm1Hg/66JSRgR3JWfIpSlJxLicpfu8rCfN
@@ -2816,7 +2858,6 @@ uid    Brad Corso <bcorso@google.com>
 
 sub    5CE9BCD2ED28F793
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF0vfHYBDADEDPY9ub98c7jQe4yMbPke3A/sxNHnn0WuA9JN880DPs3L7lrv
 9VHTOlFXslDNBPYSbgFXH5YlMGg8ZY8bhngjc+Z3dtrCX1cAjUXOnibi7fBFomLB
@@ -2851,7 +2892,6 @@ K0rLXbIe/0Q1MkLjnJ9MqcnGGPSNV5d2f/Q9Y8U9EA==
 pub    36D4E9618F3ADAB5
 sub    C4935FA8AC763C70
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGGiftwBDAC94Yhhh/5yO8jYFkg01MPnooXKZEPwxAbAg9wn5iM0tHxhEpkU
 zJVYZ+JYq013+Ldp8Of7A/d6hKTtZ0xwSeY7S/WFykIk6tc0P5j0sfFS3pGPDk+W
@@ -2887,7 +2927,6 @@ uid    Bintray (by JFrog) <bintray@bintray.com>
 
 sub    0CFE993CDBE1D0A2
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFTi8JIBEACcN1ucQ1uCOZ1owTELQV/6i4q7NbYdJ5wf7yPYfEugSo3yfbo3
 Pw/XEvlnpDZmT155sGNOkteZtZMdcm5XhFbdtquLlrkjAcUGatq5rAt3eLAlvU7u
@@ -2932,7 +2971,6 @@ uid    Eclipse Project for JAF <jaf-dev@eclipse.org>
 
 sub    D908A43FB7EC07AC
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFu07rsBEADYizNlY0FYNZ6q2wx7AmWLw6PHje55uFhYM8Saqtwg/rm1tl78
 j28E/coP2zMFf/ec+zqKsfYi4DMmLZ9ESIngMUOIE7mY0Pp4WN7oYFRtvU0ARWyp
@@ -2989,7 +3027,6 @@ uid    Carl Mastrangelo <carl@carlmastrangelo.com>
 
 sub    9B2A1B698A113AAD
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFzwo60BEACg1rgL5jUtKkFE5DiwqJwxzJyJDH00TBSN6ZT+nXh1UxgC9q2h
 olF9V+2+LV1Jcmnc946xzIMiWLG33QB0NKVCdU5jNuLahOcViQQjNfGXwNzYoNCR
@@ -3029,10 +3066,54 @@ nEq4tzixXZee6daOaBArXoaC1pEN8grIppEyMBaqmVP1GT1+pvY=
 =qc4l
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    3D12CA2AC19F3181
+uid    Tatu Saloranta (cowtowncoder) <tatu.saloranta@iki.fi>
+
+sub    575D6C921D84AC76
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+
+mQINBGL4BxIBEAC+lX44fd/zrVQPzdKygarBd/X0bBpGakT++Kfk4UBGl3q+wd2G
+R9puB9R377ds8hU7U3To8sHguUZo6DbD9Gb/is/WajSb9g92z+rMow3KbqfCYqWr
+kaIj27OJgbziFcnMAtvGoFRfaPI/7TOwEw3jT7B87RXeiATX4iL8fzMUmkfZm0Hk
+qjnepMQeaz3KzMY4DfBcI45kwzl3EIBFIlk428mhBU5iAAANoyPsimfqEPRCUDjx
+vT8g7PvpkBdNZgRS6R9vLxyzKi/f5KswZIMvop/pRXIhAKDhCCyr2GD+T3JoIKp9
+kvS1MQucWeX8+TFWh5qEA3e06Xu0JSdPCEej0BH06EiTMsAOU5bWqgLAO9DVpS32
+I092KAuMJlEPCnz7IGXVkeNY5KYrlsmoKrBO3GF/zsCyiZDvSULkVJcrtBCYOrgq
+HRIzvJWQaTJ5V15MD8CZIELyjCGZ8Jy8hdZpaTjYalw0bUq+yRAqMD5slp6A1tnv
+jyqVTgU+yRGq2HB90vJ0D3P1w4xRDuNF8c02futO415Yc/qkyh3/5AjGSoocrlfX
+cMreJXpQWVsvXn3NsitjsA6XOJpMOgipCDxfvn8SSLl9fWNJf55j7fCkBokF/lIi
+81RVQbyjVCOV0OEqHJLP9asPHyAFvUppNWtcvViPxVmb52djnw/x/61WVQARAQAB
+tDVUYXR1IFNhbG9yYW50YSAoY293dG93bmNvZGVyKSA8dGF0dS5zYWxvcmFudGFA
+aWtpLmZpPrkCDQRi+AcSARAAsKXGqznhDeU87UA073pnPg12bloq5h79U8iZozoV
+NIRhjMxJyilOlWZVCIOWEDWJJ1Dnzn/9OaYEJrBIY4yPDQQ9wsrOklUOsDpZAPiq
+QyrP3V8MibbWBPhBvyDM48GVtg2xedB5Jk9lSv6BYUUn9D2q/nG1UP5jSwFQu7nm
+VgVV5XXs6lb5N7Q2GGXn/U/EJX/ffS1VxYIjM0Ra8yy3HdihBwF+LHuuRU8SHxWG
+Aq7IRSCg0YuCFjc0KrT1e5m/eMF2NFcLHuZjBII5onhj4wRmJ3tiVNMWDQcbZctc
+t2ng13MTZTa3EvwJHvQKlgGFOGoLaHAnn29abeUN5YtKoNz7FSgyealg3Hm/pIHF
+Lh4LcBxQlSAqEFDLL/aeRf5Fi9/PzlnE0dpUOLRnqxNnZpcqhVru5qRC3JAH10qS
+aG2ZbVG6fAjuu/YNJZPjiVkpsXXZVcm3VwhWgHjikG9MKEDpEdb6NrSR8hphq9tB
+HmvlF/pHS6I1UMGAqiAnb5yuGKR7oaU+XK85OpaIX2aQTzB3aUexUEGXkBFuRG3B
+TX6FBMLIG9qpBvoUCC+UO8EWox5Bmht1roWNsRMqB7i0m9tIT+YSNrobcbMFJf/i
+Do42bQwo8y8+fUPgA5A2WDPjzd3kdFCQ6mCpcuPSk7s9t8y5bjYzcKqPCtMtOVxg
+kDMAEQEAAYkCPAQYAQgAJhYhBCgRjAcMsioBdaLo1D0SyirBnzGBBQJi+AcSAhsM
+BQkJZgGAAAoJED0SyirBnzGBkG0P/28WaiFCKz2vOqFxC6tfRPjhU7wilUM4KIYm
+ij0uh8dq4Lbz0tmybzvq15QL0QBciPLF+w6tHXnmT9KV3n4nY6X4ys9W4VvFn+0V
+OkDinNBMpfP2KglWYoJ9Q8yZRda9pq5GWtFUTS44fOj/2NU+2YawIkdDzb/vixID
+bD2y/E7ta8lpfL1hXZaLONFvMZXj9ZwVNfTloXjj1PVWDfNHgQ+Yo9gp9CwsSUHc
+jTqVQ9Nz92HGrpPThzlQnflFV9gO1cHpl2+MEQy+fYAH0hsmCx2KgBdVyWzl5IXk
+z0bLbcV0SJM7wP4I6ZkJoqDVN1IYjGdRCZGyeNpaBT7+2KZW5gV6DACiRdeNNvrD
+lbrAtRVCzEELaWbwv24KG6hKnU84WWvx6ygOOQRaXGkzvNIybaPJImUe4p38F9YA
+Rq2IMF4rMYomDyOclcAL2E3DZ1NZw/VZOYsk4MdATQRtYSz2mQbZGGqw5lKNCsmH
+9GPJkGZne1NJzh6bXZEfucjQ+cjtvf8Bn7HtSnmXETRoHGEBShsO9hw4mLDhC4os
+LBaslDFjyxMECWr3v7TuEmEmNcD+KwNyACFNuBjEBWeuJZYwCkAkVy8AyitrTMh8
+/CPhk/tPm26c+KI5BJsQg8V34FMtd+trRhXRG2mfPB2cU2t9Il7Tlzi71iGEafIb
+96Um/Inf
+=ec6I
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    3E3D777C909A447C
 sub    7ECD484BE871E4BC
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFhV2aoBCACyHcEuTUn5nVo1ODvWvgBgV8b6Aju4cVAhMNIvAdcOYf+N9Rgo
 Y/669/P371uN2hc4SxJeORBjHyzkAX2sJZQj+FwdvGl60YX9Zv/NQaTzC1WFMRp2
@@ -3060,7 +3141,6 @@ uid    Rob Tompkins <chtompki@apache.org>
 
 sub    3260CB2DEF74135B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFhqdSMBEACmveOOsQrTky8b5M+Cq6lbhqRB4+INnfigxr7+EMpswo4AxYuA
 Op/YG+G7NU5h6EK6Tj2dVfXga90GYFkehtFRZgOUJUGKPU/53upsbnsWS8qjJD8g
@@ -3105,7 +3185,6 @@ uid    Michael Schierl (Maven Project Release Key) <schierlm@users.sourceforge.n
 
 sub    C0B9C2CC3DD97C16
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE5zrtcBCADFfU0ugIGUCM44fqPJKrsB3TaDu5EpauvFfYqUfyookzMHSKtB
 4YqBSKzBEiZ1rFB/KCn7XJTh5epoCau4DsG4U0XZjsx+esDR4ZtL42LEzeMTuluV
@@ -3134,7 +3213,6 @@ uid    Groovy Operator (Groovy Language Continuous Integration Server) <ci@groov
 
 sub    01F3A913FB698736
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFLmWO0BCADfxkkFnwj5uOALP07g8yArQpu6zbNr+5dtDvJe8Y51V1leb74U
 Eh4U1IeosCRdKUCg0XlAjDmjrUkG6W/5AMUZM676JVHL5tVG1F+dsKhCrFOZoMHj
@@ -3165,7 +3243,6 @@ uid    Stanley Shyiko <stanley.shyiko@gmail.com>
 sub    8067ECAA8D58321C
 sub    750F9A735EECF640
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFkgff4BEADQW10I1gEirYflEkNU9ukvBD/UFzsNxtKKxiDB58O1j9/o8bJN
 uM56B/skfFg1V4Gkpmnf9sJyakI8jHIvZ720dPHB8nVRBKV+sUD7hoI2QYVJMJMV
@@ -3233,7 +3310,6 @@ uid    Simon Mittermueller (none) <simon.mittermueller@gmail.com>
 
 sub    4CE6E05D128BCFAD
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFE0soEBCADAy/iIRT/lpb+vfDjWs/k1XQNU3mzXoMm1mmS/Z8VOc0jF7sVB
 A5z2pC6u2OmEr1oJkhWefX+mU//7kXs6VvUCReE4uheGBlisg/ELEXkTm342TcwS
@@ -3262,7 +3338,6 @@ uid    AJ Alt <ajalt@users.noreply.github.com>
 
 sub    868FF6CCEF26A83C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBF5CDMYBCADC1/aWU6ZbGZEphRbmjUPNfqh3N5goSnDCou97mmQ9Uq8iBuKS
 UXJnGSOHudXK56f+Drx5lGZdLAzveZdqaqb1o3yLFO3PJxwj3Ulhab3O3uTG2eR0
@@ -3291,7 +3366,6 @@ uid    Adam Cozzette <acozzette@google.com>
 
 sub    726F4E5C34CFD750
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF8QwXwBDADKNLAHhjWUqnLYiO+ws3Hy1du6tMvkR3nfsnIDqpCvSjb+3/rI
 OHSyq8TbaGLLuHOM4K/KvrKgjhTbXQxvx1WR5IpoylcINzI959yAbaywBj6gVQB3
@@ -3326,7 +3400,6 @@ AGg2/CyrKszDpsR8R04jHL/ZAxrodA4Awc3BTpNxQDPfdRPc8w==
 pub    4DB7BC57DFDBCEA4
 sub    25EB2A6CB1459233
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFBm+zUBCACsrBpO6mOsZ/B6PdPPV/Hj87m2GHeEYEHt2o2l8X2BdbZKbVW1
 FIKnpYe3+TsFCe/qNxlR6vk0Jpy3ChD3nW/J0rmU0ju1SZnS7rdSMj3AI5M5xxpy
@@ -3354,7 +3427,6 @@ uid    Gradle Inc. <info@gradle.com>
 
 sub    33AEBC1F01C98081
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFxaxWYBCADI4/gRCJYfXwZYdUoEGlAlCfRgABy90rvebzcs8MKtolAbPVkG
 iqnjftXd28sZhEDx9YJrUfmzspdrYmU7hy1kgV1/WGIcWyTExTH3bqlnaIWnnTxA
@@ -3385,7 +3457,6 @@ sub    7EC19439E4D4C2A0
 sub    D89D05374952262B
 sub    B5681E477AD61C38
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBF+7lwIBDACcXIXAwFDoWvCCWn+OImyyJQvSnnte93Mc1ZJtlArkrjeGU7Mu
 5giUH+FOyiXlj7CU4G9RTnAzDgM8XPncWOERgRG2dXtO03Li7iUEX4Z8PCUGsTxP
@@ -3464,7 +3535,6 @@ apJdEkbmMXU=
 
 pub    571A5291E827E1C7
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBE9iFawRBACJb4OMk3zqMDNvSJKYZ8fGYrPq7yCcf/ykKDkGb2dtPnAZGkSp
 3mmNlTsU6s9ARn7BtkhIuM5TdbLs+z+okX62h3F0WW3h+CpfIXyKSgl7uWbhZ5G8
@@ -3483,7 +3553,6 @@ uid    Eclipse EE4J Project <ee4j-dev@eclipse.org>
 
 sub    153E7A3C2B4E5118
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFri3Q8BEAC90D8TTu6C05m/eq6HbU8gOHFc+2VJriVmnoyODTlEk/LAsT6h
 BRok7nzY0LpNUzUREjJy/w80YTOjLs25IFhnqA6mq8BGLjFwjhBPA4piCyhW/Elh
@@ -3537,7 +3606,6 @@ DmlBBHiPyQWUgkZrTrJGzpzKLFowpWUoy49YiGUZw983YoHw
 pub    586654072EAD6677
 sub    2E74CACB6918A897
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBE1VSkkRBACkCgvt26sMi+0X+EOJDMqdK0Sziy06k47LJf1jOg4tTZ2T9QtP
 OZ8fD+va/O5+q8Kna993jzcO5n0Nv+R/K3+MvUqSmdITshCIjBt3cC0n6FWndGyl
@@ -3567,7 +3635,6 @@ CDJEYrz4EqbscOdx6H3uwA==
 pub    59A252FB1199D873
 sub    92BD2D0B5B21ABA2
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFUBG7QBCADRWXf0Fw05qRhM4cRnGKlOW1ecue1DCxHAtFwoqmAXyTCO+tI0
 MEW5SyXUkX6FsWLl6A2y+KgOs669ogzfQ0rnZMEt4HisRp8wpgk3GWR1/9aKYz/c
@@ -3593,7 +3660,6 @@ V3u1xg+t7/QlghTMoJAA0H5G
 pub    5E1F79A7C298661E
 sub    A7CC6488427379A4
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFgRFtYBCADud9fmvTI8Dbs+9GcZUIVzxkL84QYHSDxI9fF+sxfAviq1U+YJ
 a+ZLIW7HsXx8vpn3hqIqAbDxHjrb6MEJ3OWD5Ks7O9Lq7HOhtqAT/mpV3fZmf6pF
@@ -3618,7 +3684,6 @@ iDYuP3RTuHnFenYROA/YcDvA
 
 pub    5E2F2B3D474EFE6B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFijpzMBCACxAT3jijwXbI6b7LIF/k8oSGyM8ZNJpb6AQvPqKIqCzxNFXzow
 EBCasKMhIWgGy+293Tpt/DY4btJie4u+igMBS86iXrF8CUnOLPgTlAIyil/oREGJ
@@ -3634,7 +3699,6 @@ uid    Eric Bruneton <ebruneton@free.fr>
 
 sub    0440006D577EAE4B
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE7JURcBCADO+9Dc4/JnB+wX+fq+Fr2zUGSPOT6/qjE5kXL4FEbJKsqDSAKG
 VnbtRrsIUdmNIFQmz71bBDFhRBbrSrkz927k8eUPhYtxE2NmmWSuKgrjF4qviPQv
@@ -3661,7 +3725,6 @@ v813ZcA=
 pub    62C82E50836EB3EE
 sub    2AC7BF2F3349DE80
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFeOGY0BEADIr99yL4ahwgM3KB7zMVzDk/PEkzUWpm1BSxqUxuQtzWArFj13
 Y3Zi6g1tw5jKESfxtmpXx7j7xR3qVdJbsYJMU0zQi+FehwnKox3Go3UnIKt7kydz
@@ -3703,7 +3766,6 @@ egz57oSj4I+NT33hA64x6jicEKyBNxNI
 pub    6425559C47CC79C4
 sub    D547B4A01F74AC1E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBE3XFIUBCADcj1zw8m1evCgEMqxgOfl6L8y1tsYWsX7tVPvHEkYlXHrdcpkB
 fGuWPrauvhBmB9sBkFfxzU98Ilz3Xk9pfISYiaMUk9Mk1ZxsCoYPVhxvOSvk5LgS
@@ -3732,7 +3794,6 @@ uid    Michel Kraemer <michel@undercouch.de>
 sub    D3DBC823BE4819ED
 sub    0162FE0CF6E18BD4
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBE7sdQQBEACsLaqrIiSlsJIWpalL9i+i6x8Yg6l+bw8qaH/i7kjZKFLf6Xrq
 PFHo9dpF3LPOguvPLP5fs04KIShl0IhJuArSxvwfH8GnqPAaM0TZpfJQ9uqAcvxk
@@ -3812,7 +3873,6 @@ uid    Popma Remko <remkop@yahoo.com>
 
 sub    0AC07D0BBD11498C
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGBVUWMBDACXALXWXSrB2V95lR1L+i+sQsTQt8tCIgX0iX9UZ7Vw2K/lLnLw
 WYtM3oTxYox4OdgkK9tK6771EdCH5wQtRdUQJjlsBfZDPMiGqmh1jrAxAugEkFyC
@@ -3849,7 +3909,6 @@ uid    Ceki Gulcu <ceki@qos.ch>
 
 sub    A1766BE5F812AC2E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mJMEYvEGpBMFK4EEACMEIwQA6knc/2gtbqDhPh5EzrymR4Hwi1Xf2S0aqMopA1zg
 IeZzBgSfL+4fEfpXL4eAzvrk29jIXSizDEOgFpw3PW3Om1gASxub4Jo6EQrRgOdd
@@ -3870,7 +3929,6 @@ uid    Szczepan Faber <szczepiq@gmail.com>
 
 sub    C0058C509A81C102
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGNBGAofm8BDADhvXfCdHebhi2I1nd+n+1cTk0Kfv8bq4BQ1T2O85XlFpp1jaIR
 70GAm2MOt8+eEXt/TuPkVBWnJovDpBbkUfYWxSIpPxJzcxWV+4WJi/25fBOq2EuP
@@ -3908,7 +3966,6 @@ uid    Paul King <paulk@apache.org>
 sub    EA8543C570FAF804
 sub    CA890A5FA09CFD80
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFgMcBMBEAC/xcIVVOOh+F7S0OTzBlFH34s5fDbi6Zto469tZyW1peyWtXAZ
 m+2jzFfeTCHaUQO3YjoTy2fPygS4tVD+ew4EAzMG5Uti4kwWZw0PYKz2JO/gl1JY
@@ -3976,7 +4033,6 @@ uid    Colin Decker <cgdecker@google.com>
 
 sub    ABE9F3126BB741C1
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFIXyRQBCADe285y3Pu7KzoKyP6wqeNXtvvuwMatAmPm5x/i+S8MlryqzsYa
 x6twUmXV1yKjjtGrO+9fHvTOWBfSSP+fP9KTaTQYSasoJq2Mw4cQDy1i0zrxNZUw
@@ -4014,7 +4070,6 @@ sub    6494C6D6997C215E
 sub    32EE5355A6BC6E42
 sub    E88979FB9B30ACF2
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBFcMjNMBEAC6Wr5QuLIFgz1V1EFPlg8ty2TsjQEl4VWftUAqWlMevJFWvYEx
 BOsOZ6kNFfBfjAxgJNWTkxZrHzDl74R7KW/nUx6X57bpFjUyRaB8F3/NpWKSeIGS
@@ -4333,7 +4388,6 @@ nOdlNV/zT9VvBk/RkV+Tl/Lk4g==
 pub    78178478013521D0
 sub    FA84183FDD6A6B98
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBF6RvwcBCADIVU7oxOiljoWxNTkZ00PKVwyqhahYpN/4lamULtECCS+HAF+J
 DsNy/6QCl7lKAGrSyn9dvsI56KEkGvUJfpQrpRlg+uIQDMxS8JF7p9n49DNc8Q88
@@ -4356,12 +4410,47 @@ rsfg6TqN6ykXvdbXTHO2cD0DFFZNzO5quWpqxTLMSgNswFB4mjvd0mS3bUK4DhM=
 =T0w5
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    7905DE25C78AD456
+uid    Protobuf Release <protobuf@googlegroups.com>
+
+sub    DBC5123E2E98FEFE
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+
+mQGNBGSsZCsBDADJZoPoHGJNAB3sn/kFQ3zlj+vZ7OY5aWoH2nL3tHQYZvN/pJRs
+8wu4Cw1ApatqLIaur6S6LR+s4xB7HxnMvpiF3NMwr6ZeZBUUTGEJbRgFhY9TqZam
+CZJ/xPz/FevPhZn3/McqDGbjEx+G7hciUl0EwIOhanAQQvVYaWxDL+Pesqqh23U7
+Cex2NcotieICt7dWJ7SAM3TOSLP9OQd4scRvYLWqv6/vu/nQ68RwqaonR2QzxhUY
+Uul7vR3iNRXtbnS31qIgCYWAoX6w0xHf6KUeIPWV21ZIUu5cg6kQr/sPt/OQuGS2
+nKk+InYtopDi6d7AUh8WI2TP7qAMIoRkhAeDEQ99DiopwFNPA/7M4g99AQfFSmp3
+acPCdeXXAZeDAqoFGFKTlqzg3FLWpGkubI/iXyHkpQfOXv4MtYuPGVNheBXGcWbf
+XPjbkFYjkGIN2Wx4i7yf43hMCk6ArhswfgCcgoORI+DCVdm7ORID1PjIU2Z71EA2
+qDdFwdoOdEV42YUAEQEAAbQsUHJvdG9idWYgUmVsZWFzZSA8cHJvdG9idWZAZ29v
+Z2xlZ3JvdXBzLmNvbT65AY0EZKxkKwEMAK4LeTj1dr8F9E98Up6y4AKHY0Zbeb5v
+c/TzsJX6UCudzygYTbQnEcrPIcJ5TJV5leniAlxnqUz/qJxmpBtGCNH63c9+iJNh
+VqJEZh9dbupqQn+mqtBvsPABbHU+C46TLebmOK4R99zgtxVlSYabJubuG2Mqnq96
+mutBUWKI3iY5j0JAMLY1DJesAGwAWP8gvUZHhd4LJN3iikNSTWyUE0Hnwm2VKFq4
+cxI/6qaCpztfuSD1y0JplSfmKRd+ecLSqhDvlMZkwigUpjCvF7iSaPvpxWdkFabS
+frMeIjwbGU/fLV8ilwtPPb57X6Nrk9NIUdVa6ZbxiuIErIcp3JfgfUfy7wxcI/Uj
+Mq1I50NOwizLVprZbmKv1P88bACmdon612pnDhhs84phJmA7fzQ/jAqF1JQ4Crdz
+L+6g56Kkx1VlN3dSmPjuycjTzykuNwZ/Fi0Lj9Czg4LVp6peSsPWS+lp9h9tOSzt
+lQev+GXiQKZTYt8JxvBPOkm0hd5M30BDbwARAQABiQG8BBgBCgAmFiEEGlXwka0o
+wH+DH6RNeQXeJceK1FYFAmSsZCsCGwwFCQPCZwAACgkQeQXeJceK1FbX9wwAmLBK
+Q8JljEwk0KqYxawrusWXwaH+1I83urf/WsOJYEkKoiQObsFGTuaolyln6ZHyF+gt
+uKeWtlbvG6aXqv9XXcsVQG7NMGdEAy6DTNj77uBAXMWTxVpD09iVeepvWSiz7r7M
+gzJfluNgGDOGKpkxxIjS8NnOAsK9uquyvBQa97I+YniarTkpnVWpgSR/7V3HHf6Q
+2aCKL3ihdK2uIS4dIrFi+mVCt2zDad8U8N7S2Gv2VO/vBF+hIFCV788hLH9HeX3f
+70E99X57hrVCh0MeColOIV1zwK8GLeV7bpr6x11x5cjiv27xky95WteyH5w9w/Xq
+Tu0NQ5YyKX/0PUYVX3mLs59H7Wys6ANygWJs59JT4KSwb3pIEV7gWSwp3mWkstlF
+m4Tq/d+gVF64ItrHylZg0WpHPv1s+dH6/tWcsBnkgR/OS33PkijQgvMW4imQNRxg
+ymOZIduHXX1X+KzlRZTXvv4tSFnIQ0mWY1ySiOJQJS2WABVwFpFc8rECm6eN
+=z4dc
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    79752DB6C966F0B8
 uid    Rob Manning <robert.m.manning@gmail.com>
 
 sub    AC9F6F1991913E30
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEqXMWkRBACnsxVroe9ojc2AnRn/85KJi/Ntsbku5iJ5z72B6I+VGn/b1Xln
 kuvRJ41RLG13lKVmHtSTq2pajjmAr9jY5gS8nJ3JUES9bG3yKNN1IDswXExfAUJp
@@ -4404,7 +4493,6 @@ uid    Inderjeet Singh <inder@alumni.stanford.edu>
 
 sub    C3E640F38D845FA2
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFZUsiQBCADGmoidvh3VvXWGdwbAtHPtDPKEebE/MfFVO+QTRbjJxphzKwAt
 mxHruikafaSTnC9FWizj99e/Yc45YZHcnt5Htmy0a7DSOQXL37rrnieZxg86tYmC
@@ -4431,7 +4519,6 @@ domz6nBt2DF400YubAZR
 pub    7A8860944FAD5F62
 sub    C189C86B813330C4
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQINBEvxja8BEADAzZOup1X0B12zJsNsDvXVIwmM6bB+uhEsUHoFTvmsEVwRoZtn
 i7Q0WSFoY+LDxbvC4Bg1+urCrUrstRJYRyF/pMqPYq/HokRlPjtrli/i3mUSd0zN
@@ -4473,7 +4560,6 @@ WxZ/desi/+eJ8DKd5ff/SE7/
 pub    7C25280EAE63EBE5
 sub    926DFB2EDB329089
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEPonucRBACtbhYckAoyz1tuSXYX4XiqGa5390gIMcxe2hJ+Ncx9o3zX09Im
 f8PW27BnMrz7EIydgB2wphhjfK4vkNNtm5ZDWH/zJStsk1Fe7lNuuxs8XorX1+8D
@@ -4503,7 +4589,6 @@ JCh/PZsbHv+eJN32qA==
 pub    7C7D8456294423BA
 sub    9842FE565AA0601E
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQGiBEvsZw4RBADH20nX+H1xvMBYmXRj1Aae4dRr6Y6qI7QRWHO6Z7/dxr9bk/NN
 Yjq5KsVOQxZzloVdtqx75rznT7fZq98g7Nq9IeEtB6k4tnh6XQLhljJMk0a3mzdt
@@ -4533,7 +4618,6 @@ On/eScLdx27sje7q3sBENw==
 pub    7FE9900F412D622E
 sub    AE6B5325E74ED034
 -----BEGIN PGP PUBLIC KEY BLOCK-----
-Version: BCPG v1.68
 
 mQENBFnyVlkBCACe8zGkIlDV0dUKmk9PWe2Hw8qM9DdPbtpUOpmUOidGY5svQDL3
 eqvHk85TbxqFEe3Qbjjt+R+iApFuXy5kmueXTvwCm7nAU+k/pZtPuzHyhDs3iFFH
diff --git a/gradle/verification-metadata.xml b/gradle/verification-metadata.xml
index 62f4431f2..87e494f0a 100644
--- a/gradle/verification-metadata.xml
+++ b/gradle/verification-metadata.xml
@@ -32,6 +32,23 @@
          <trusted-key id="08F0AAB4D0C1A4BDDE340765B341DDB020FCB6AB" group="org.bouncycastle"/>
          <trusted-key id="0CC641C3A62453AB390066C4A41F13C999945293" group="commons-logging"/>
          <trusted-key id="0D35D3F60078655126908E8AF3D1600878E85A3D" group="io.netty"/>
+         <trusted-key id="0F06FF86BEEAF4E71866EE5232EE5355A6BC6E42">
+            <trusting group="com.android"/>
+            <trusting group="com.android.databinding"/>
+            <trusting group="com.android.kotlin.multiplatform.library"/>
+            <trusting group="com.android.settings"/>
+            <trusting group="com.android.tools"/>
+            <trusting group="com.android.tools.analytics-library"/>
+            <trusting group="com.android.tools.build"/>
+            <trusting group="com.android.tools.build.jetifier"/>
+            <trusting group="com.android.tools.ddms"/>
+            <trusting group="com.android.tools.emulator"/>
+            <trusting group="com.android.tools.external.com-intellij"/>
+            <trusting group="com.android.tools.external.org-jetbrains"/>
+            <trusting group="com.android.tools.layoutlib"/>
+            <trusting group="com.android.tools.lint"/>
+            <trusting group="com.android.tools.utp"/>
+         </trusted-key>
          <trusted-key id="0F07D1201BDDAB67CFB84EB479752DB6C966F0B8" group="com.google.android"/>
          <trusted-key id="10F3C7A02ECA55E502BADCF3991EFB94DB91127D" group="org.ow2"/>
          <trusted-key id="11B581967F079A30A3E93140D57506CD188FD842" group="com.google.api.grpc"/>
@@ -39,7 +56,17 @@
          <trusted-key id="160A7A9CF46221A56B06AD64461A804F2609FD89" group="com.github.shyiko.klob"/>
          <trusted-key id="190D5A957FF22273E601F7A7C92C5FEC70161C62" group="org.apache"/>
          <trusted-key id="19BEAB2D799C020F17C69126B16698A4ADF4D638" group="org.checkerframework"/>
+         <trusted-key id="1A55F091AD28C07F831FA44D7905DE25C78AD456" group="com.google.protobuf"/>
          <trusted-key id="1FA37FBE4453C1073E7EF61D6449005F96BC97A3" group="de.undercouch"/>
+         <trusted-key id="28118C070CB22A0175A2E8D43D12CA2AC19F3181">
+            <trusting group="com.fasterxml"/>
+            <trusting group="com.fasterxml.jackson"/>
+            <trusting group="com.fasterxml.jackson.core"/>
+            <trusting group="com.fasterxml.jackson.dataformat"/>
+            <trusting group="com.fasterxml.jackson.module"/>
+            <trusting group="com.fasterxml.woodstox"/>
+            <trusting group="org.codehaus.woodstox"/>
+         </trusted-key>
          <trusted-key id="2BCBDD0F23EA1CAFCC11D4860374CF2E8DD1BDFD">
             <trusting group="net.java"/>
             <trusting group="org.codehaus"/>
@@ -56,6 +83,7 @@
          <trusted-key id="314FE82E5A4C5377BCA2EDEC5208812E1E4A6DB0" group="com.gradle"/>
          <trusted-key id="31BAE2E51D95E0F8AD9B7BCC40A3C4432BD7308C" group="com.googlecode.juniversalchardet"/>
          <trusted-key id="31FAE244A81D64507B47182E1B2718089CE964B8" group="com.thoughtworks.qdox"/>
+         <trusted-key id="32118CF76C9EC5D918E54967CA80D1F0EB6CA4BA" group="org.codehaus.mojo"/>
          <trusted-key id="3288B8BE8512D6C0CA185268C51E6CBC7FF46F0B" group="com.google.auto"/>
          <trusted-key id="33FD4BFD33554634053D73C0C2148900BCD3C2AF" group="org.jetbrains"/>
          <trusted-key id="34441E504A937F43EB0DAEF96A65176A0FB1CD0B" group="org.codehaus.groovy"/>
@@ -84,13 +112,8 @@
             <trusting group="org.slf4j"/>
          </trusted-key>
          <trusted-key id="6214760097DC5CFAD0175AC2C9FBAA83A8753994">
-            <trusting group="com.fasterxml"/>
-            <trusting group="com.fasterxml.jackson"/>
-            <trusting group="com.fasterxml.jackson.core"/>
-            <trusting group="com.fasterxml.jackson.dataformat"/>
-            <trusting group="com.fasterxml.jackson.module"/>
-            <trusting group="com.fasterxml.woodstox"/>
-            <trusting group="org.codehaus.woodstox"/>
+            <trusting group="com.fasterxml" name="oss-parent"/>
+            <trusting group="org.codehaus.woodstox" name="stax2-api"/>
          </trusted-key>
          <trusted-key id="648190996EC0930A6D7D49A978178478013521D0" group="com.facebook"/>
          <trusted-key id="694621A7227D8D5289699830ABE9F3126BB741C1">
@@ -103,12 +126,14 @@
             <trusting group="com.sun.activation"/>
             <trusting group="jakarta.activation"/>
          </trusted-key>
+         <trusted-key id="6EAD752B3E2B38E8E2236D7BA9321EDAA5CB3202" group="ch.randelshofer" name="fastdoubleparser"/>
          <trusted-key id="6F538074CCEBF35F28AF9B066A0975F8B1127B83">
             <trusting group="org.jetbrains.kotlin"/>
             <trusting group="org.jetbrains.kotlin.jvm"/>
          </trusted-key>
          <trusted-key id="6F7E5ACBCD02DB60DFD232E45E1F79A7C298661E" group="com.google.auto"/>
          <trusted-key id="720746177725A89207A7075BFD5DEA07FCB690A8" group="org.codehaus.mojo"/>
+         <trusted-key id="7440F1F7D27BAC115F953D55EB095DA7D2F6AC0E" group="org.tensorflow"/>
          <trusted-key id="7615AD56144DF2376F49D98B1669C4BB543E0445" group="com.google.errorprone"/>
          <trusted-key id="7616EB882DAF57A11477AAF559A252FB1199D873" group="com.google.code.findbugs"/>
          <trusted-key id="78DA3333F653B1C54A938BE24DB7BC57DFDBCEA4" group="net.java.dev.jna"/>
@@ -134,6 +159,22 @@
          <trusted-key id="98465301A4939C0279F2E847D89D05374952262B" group="org.jetbrains.dokka"/>
          <trusted-key id="A0E7010544C02BD4C072B1803E3D777C909A447C" group="io.opencensus"/>
          <trusted-key id="A5BD02B93E7A40482EB1D66A5F69AD087600B22C" group="org.ow2.asm"/>
+         <trusted-key id="A5F483CD733A4EBAEA378B2AE88979FB9B30ACF2">
+            <trusting group="com.android"/>
+            <trusting group="com.android.databinding"/>
+            <trusting group="com.android.kotlin.multiplatform.library"/>
+            <trusting group="com.android.tools"/>
+            <trusting group="com.android.tools.analytics-library"/>
+            <trusting group="com.android.tools.build"/>
+            <trusting group="com.android.tools.build.jetifier"/>
+            <trusting group="com.android.tools.ddms"/>
+            <trusting group="com.android.tools.emulator"/>
+            <trusting group="com.android.tools.external.com-intellij"/>
+            <trusting group="com.android.tools.external.org-jetbrains"/>
+            <trusting group="com.android.tools.layoutlib"/>
+            <trusting group="com.android.tools.lint"/>
+            <trusting group="com.android.tools.utp"/>
+         </trusted-key>
          <trusted-key id="A6D6C97108B8585F91B158748671A8DF71296252" group="com.squareup"/>
          <trusted-key id="A7892505CF1A58076453E52D7999BEFBA1039E8B" group="net.bytebuddy"/>
          <trusted-key id="AA417737BD805456DB3CBDDE6601E5C08DCCBB96" group="info.picocli"/>
@@ -144,7 +185,12 @@
          <trusted-key id="B6E73D84EA4FCC47166087253FAAD2CD5ECBB314" group="org.apache.commons"/>
          <trusted-key id="B801E2F8EF035068EC1139CC29579F18FA8FD93B" group="com.google.j2objc"/>
          <trusted-key id="BCC135FC7ED8214F823D73E97FE9900F412D622E" group="com.google.flatbuffers"/>
-         <trusted-key id="BDB5FA4FE719D787FB3D3197F6D4A1D411E9D1AE" group="com.google.guava"/>
+         <trusted-key id="BDB5FA4FE719D787FB3D3197F6D4A1D411E9D1AE">
+            <trusting group="com.google.guava"/>
+            <trusting group="com.google.j2objc" name="j2objc-annotations" version="3.0.0"/>
+            <trusting group="com.google.truth"/>
+            <trusting group="com.google.truth.extensions"/>
+         </trusted-key>
          <trusted-key id="C6F7D1C804C821F49AF3BFC13AD93C3C677A106E" group="io.perfmark"/>
          <trusted-key id="C70B844F002F21F6D2B9C87522E44AC0622B91C3" group="com.beust"/>
          <trusted-key id="C7BE5BCC9FEC15518CFDA882B0F3710FA64900E7">
@@ -176,22 +222,6 @@
          <trusted-key id="E85AED155021AF8A6C6B7A4A7C7D8456294423BA" group="org.objenesis"/>
          <trusted-key id="EA23DB1360D9029481E7F2EFECDFEA3CB4493B94" group="jline"/>
          <trusted-key id="EB1B3DE71713C9EC2E87CC26EE92349AD86DE446" group="com.google.j2objc"/>
-         <trusted-key id="A5F483CD733A4EBAEA378B2AE88979FB9B30ACF2">
-            <trusting group="com.android"/>
-            <trusting group="com.android.databinding"/>
-            <trusting group="com.android.kotlin.multiplatform.library"/>
-            <trusting group="com.android.tools"/>
-            <trusting group="com.android.tools.analytics-library"/>
-            <trusting group="com.android.tools.build"/>
-            <trusting group="com.android.tools.build.jetifier"/>
-            <trusting group="com.android.tools.ddms"/>
-            <trusting group="com.android.tools.emulator"/>
-            <trusting group="com.android.tools.external.com-intellij"/>
-            <trusting group="com.android.tools.external.org-jetbrains"/>
-            <trusting group="com.android.tools.layoutlib"/>
-            <trusting group="com.android.tools.lint"/>
-            <trusting group="com.android.tools.utp"/>
-         </trusted-key>
          <trusted-key id="EE0CA873074092F806F59B65D364ABAA39A47320">
             <trusting group="com.google.errorprone"/>
             <trusting group="com.google.turbine"/>
@@ -216,30 +246,2070 @@
       </trusted-keys>
    </configuration>
    <components>
-      <component group="javax.inject" name="javax.inject" version="1">
-         <artifact name="javax.inject-1.jar">
-            <sha256 value="91c77044a50c481636c32d916fd89c9118a72195390452c81065080f957de7ff" origin="Generated by Gradle" reason="Artifact is not signed"/>
+      <component group="ch.randelshofer" name="fastdoubleparser" version="0.8.0">
+         <artifact name="fastdoubleparser-0.8.0.jar">
+            <sha256 value="10fe288fd7a2cdaf5175332b73529f9abf8fd54dcfff317d6967c0c35ffb133b" origin="Generated by Gradle"/>
          </artifact>
-         <artifact name="javax.inject-1.pom">
-            <sha256 value="943e12b100627804638fa285805a0ab788a680266531e650921ebfe4621a8bfa" origin="Generated by Gradle" reason="Artifact is not signed"/>
+         <artifact name="fastdoubleparser-0.8.0.pom">
+            <sha256 value="5563e5dd4bb054759f0f83851606d99d2426d75c27372814027005e92d1c2aaa" origin="Generated by Gradle"/>
          </artifact>
       </component>
-      <component group="net.sf.kxml" name="kxml2" version="2.3.0">
-         <artifact name="kxml2-2.3.0.jar">
-            <sha256 value="f264dd9f79a1fde10ce5ecc53221eff24be4c9331c830b7d52f2f08a7b633de2" origin="Generated by Gradle" reason="Artifact is not signed. b/294916131"/>
+      <component group="com.android" name="signflinger" version="8.9.0-alpha04">
+         <artifact name="signflinger-8.9.0-alpha04.jar">
+            <sha256 value="c1dca2c683634ee1a294298f9c7179578af6a86e080bdc40f961915bc5c8142f" origin="Generated by Gradle"/>
          </artifact>
-         <artifact name="kxml2-2.3.0.pom">
-            <sha256 value="31ce606f4e9518936299bb0d27c978fa61e185fd1de7c9874fe959a53e34a685" origin="Generated by Gradle" reason="Artifact is not signed. b/294916131"/>
+         <artifact name="signflinger-8.9.0-alpha04.pom">
+            <sha256 value="9d7a7ff8acf2484cf76ba6496d9257df527475ccda7641353e17628a471300c2" origin="Generated by Gradle"/>
          </artifact>
       </component>
-      <component group="org.ow2" name="ow2" version="1.5">
-         <artifact name="ow2-1.5.pom">
-            <sha256 value="0f8a1b116e760b8fe6389c51b84e4b07a70fc11082d4f936e453b583dd50b43b" origin="Generated by Gradle" reason="Artifact is not signed"/>
+      <component group="com.android" name="zipflinger" version="8.9.0-alpha04">
+         <artifact name="zipflinger-8.9.0-alpha04.jar">
+            <sha256 value="81dd485618a509a3235929b9eb13091d884452661de6ce5a45cc38b1c555421c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="zipflinger-8.9.0-alpha04.pom">
+            <sha256 value="1fd4be5d6495d18e8e2ec794f959c744f2531ad5b95e05a803b3aa4b7d1af143" origin="Generated by Gradle"/>
          </artifact>
       </component>
-      <component group="org.sonatype.oss" name="oss-parent" version="7">
-         <artifact name="oss-parent-7.pom">
-            <sha256 value="b51f8867c92b6a722499557fc3a1fdea77bdf9ef574722fe90ce436a29559454" origin="Generated by Gradle" reason="Artifact is not signed"/>
+      <component group="com.android.databinding" name="baseLibrary" version="8.9.0-alpha04">
+         <artifact name="baseLibrary-8.9.0-alpha04.jar">
+            <sha256 value="794113709dab21b06c262b3795e73cb708fbacae61715f34361e1af6237a1870" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="baseLibrary-8.9.0-alpha04.pom">
+            <sha256 value="c90337f5ad439688be8c82af3bfdab28e686f76f84ef222735998bbe447fb73c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="annotations" version="31.9.0-alpha04">
+         <artifact name="annotations-31.9.0-alpha04.jar">
+            <sha256 value="b25995fa7b220d35fbb8e325df071f8291691bfbaff9734c98e38f45ec2a73ee" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="annotations-31.9.0-alpha04.pom">
+            <sha256 value="a003aa2773cc8d424338800f7f6a21a33334d7c36020aa8a4f0427da83362139" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="common" version="31.9.0-alpha04">
+         <artifact name="common-31.9.0-alpha04.jar">
+            <sha256 value="523be1904b41c1be5cdaa68598bfda298b8f3d461c333384c80d77f1952e9c07" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="common-31.9.0-alpha04.pom">
+            <sha256 value="d4a94cfdf1aff00a0838c81477ccf03aa5601e74d69d6b1737b93af3c3a24a28" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="dvlib" version="31.9.0-alpha04">
+         <artifact name="dvlib-31.9.0-alpha04.jar">
+            <sha256 value="e3cf3fdc947788dee8d5baa76cb72a66571174bc4741edf0e3bab97a7ca90e1b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="dvlib-31.9.0-alpha04.pom">
+            <sha256 value="bb30af8c31950f29bda3aa9c1ed93c26c677ddf55850e8c0a28bc2b133918bcb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="play-sdk-proto" version="31.9.0-alpha04">
+         <artifact name="play-sdk-proto-31.9.0-alpha04.jar">
+            <sha256 value="c6fc15a5c203064cfd2c8a176fdeac72ae0a2d743ec47a2e66a0238d8d870b6b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="play-sdk-proto-31.9.0-alpha04.pom">
+            <sha256 value="32f081928779e363d11c2af5976ffbc0552a53bb976e7caa311761a691ff997f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="repository" version="31.9.0-alpha04">
+         <artifact name="repository-31.9.0-alpha04.jar">
+            <sha256 value="20b98fd690a544a12e2cfa4e4c64207dff22238d17b031f344233709b23924a1" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="repository-31.9.0-alpha04.pom">
+            <sha256 value="ffcceaca1ea91cccabf376eb52acdb6b914eba08e44545e78bd62873f4f1edbb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="sdk-common" version="31.9.0-alpha04">
+         <artifact name="sdk-common-31.9.0-alpha04.jar">
+            <sha256 value="00fc74b4f75c2325051521f5de882bd22fa2073f9836d49216a6b86afef5fe61" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="sdk-common-31.9.0-alpha04.pom">
+            <sha256 value="1129d293c7f4288559bb0d6cf058ad01ade77b0ac625b34f415f59714e92f75a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools" name="sdklib" version="31.9.0-alpha04">
+         <artifact name="sdklib-31.9.0-alpha04.jar">
+            <sha256 value="92e20c5f1927bf64d9e84d45b9b4d089f61a0fd335a38415673cb6121f285171" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="sdklib-31.9.0-alpha04.pom">
+            <sha256 value="8a5b1ead07b385f8518e4ea9b545156b11261c6f06110fcbd745ea0abe63171b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.analytics-library" name="crash" version="31.9.0-alpha04">
+         <artifact name="crash-31.9.0-alpha04.jar">
+            <sha256 value="cca97ac29a1329bd310a3e832b6e57f46227e501aa529c00a63df217c5d7df41" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="crash-31.9.0-alpha04.pom">
+            <sha256 value="10fa35e7911ff58c862b3e1cf78df4be8dd9cb6f62cff5a29080f041db1106c6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.analytics-library" name="protos" version="31.9.0-alpha04">
+         <artifact name="protos-31.9.0-alpha04.jar">
+            <sha256 value="0a0b7f2908332dca56ab13637e00c1294e9d1427ecdbb9d723096e45197f9307" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="protos-31.9.0-alpha04.pom">
+            <sha256 value="db132e3dccded4fa86dd1db8c5d187fb59cc1fe1d2bf0a3045df90faea8c14fb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.analytics-library" name="shared" version="31.9.0-alpha04">
+         <artifact name="shared-31.9.0-alpha04.jar">
+            <sha256 value="2aa3a3c24eb46c7f3ee3075b0d81a827519637a4e3a05ce74d4ac358cda4f2bb" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="shared-31.9.0-alpha04.pom">
+            <sha256 value="73de3a5aa048ed17cf1fc8c077f36599612bf8ea90c47ebe28a755922ba4a9da" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.analytics-library" name="tracker" version="31.9.0-alpha04">
+         <artifact name="tracker-31.9.0-alpha04.jar">
+            <sha256 value="eed50afc37c1f62db74ab89bc9ef123449da67a02c42fb17a570373e10880518" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="tracker-31.9.0-alpha04.pom">
+            <sha256 value="11d914a581cfa33e1bd813a9cbd59d38a6fccac681039c0abbd38ab82987ff20" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="aapt2-proto" version="8.9.0-alpha04-12634980">
+         <artifact name="aapt2-proto-8.9.0-alpha04-12634980.jar">
+            <sha256 value="5d1b413f3c283c19e329c9a14ba4ec806b6fdebe2700b605f089239f1f837467" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="aapt2-proto-8.9.0-alpha04-12634980.module">
+            <sha256 value="a5b0ef7e20b5bb4606d27e3b9eafa94049d1af8c017b296110098d99f2ed03fe" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="aaptcompiler" version="8.9.0-alpha04">
+         <artifact name="aaptcompiler-8.9.0-alpha04.jar">
+            <sha256 value="10485353fefe7d7536df268068e3c64671ec703fdd20e8b04ae3fb5edab64632" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="aaptcompiler-8.9.0-alpha04.module">
+            <sha256 value="eaadc27394545ae6b1edf4d937b0f58cf12abbbf2feba5b2f8ed6be89e25d2db" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="apksig" version="8.9.0-alpha04">
+         <artifact name="apksig-8.9.0-alpha04.jar">
+            <sha256 value="c070ed1394629d74641aa0906f60b2ffa1ee77e6366a1f93437f59717b1aeb89" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="apksig-8.9.0-alpha04.pom">
+            <sha256 value="1a1f3256c26ec6d606dbcaeed202441dd42baeb6b0fec809d24635db6d554303" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="apkzlib" version="8.9.0-alpha04">
+         <artifact name="apkzlib-8.9.0-alpha04.jar">
+            <sha256 value="1c1a67d6f4f186427ac166ebaa0dd867f595d5144fc925252b05ffb9d1a156b7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="apkzlib-8.9.0-alpha04.pom">
+            <sha256 value="7cda6f0954c2f7bd4b8a5312c19681999b4a427c727f414140abb95e6fa6faf5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="builder" version="8.9.0-alpha04">
+         <artifact name="builder-8.9.0-alpha04.jar">
+            <sha256 value="2ef288576c9c0c30923d0f3477f7ab12dcbe5c333d7c1cc81d27f4164a0d7e2b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="builder-8.9.0-alpha04.module">
+            <sha256 value="3798b57ab13e3d35c252cff030f094343cb08e1c8ef723bb50afa9a5a4f29437" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="builder-model" version="8.9.0-alpha04">
+         <artifact name="builder-model-8.9.0-alpha04.jar">
+            <sha256 value="3060e0f76331a6fe71d9d301cd189466896f4496b8c7484b79f589abc931b13a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="builder-model-8.9.0-alpha04.module">
+            <sha256 value="4bbb3b6582b03ef4edc7f23b9905f76ee3b7df105fe6be864a635fa07a2cb5fd" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="builder-test-api" version="8.9.0-alpha04">
+         <artifact name="builder-test-api-8.9.0-alpha04.jar">
+            <sha256 value="1a39dadc0c79be9e32460e43340d5e4f5ce7fb0b775bf0531dff0854e540af69" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="builder-test-api-8.9.0-alpha04.module">
+            <sha256 value="b9dfa2d495f32611cef7754021ac1a77c348ffde90e6ca67b9f9948d22d752d1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="gradle" version="8.9.0-alpha04">
+         <artifact name="gradle-8.9.0-alpha04.jar">
+            <sha256 value="7595c9a27fb58f6b31f472cb27e9dc27286faa01cab7116fd8e090f052424bf4" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="gradle-8.9.0-alpha04.module">
+            <sha256 value="156ae68a76cb5473973eba8f363976e1f4a8e26d7db6ba020758e988df1a9fd7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="gradle-api" version="8.9.0-alpha04">
+         <artifact name="gradle-api-8.9.0-alpha04.jar">
+            <sha256 value="b169ac6a47a3f04c61cf9bdb771de96c5422389efaa9756cd247a39e0a34fb4f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="gradle-api-8.9.0-alpha04.module">
+            <sha256 value="6eb02025c9b5bc2d305be16f2e2c262856cc6db643f19f94931f8b39dd13b07d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="gradle-settings-api" version="8.9.0-alpha04">
+         <artifact name="gradle-settings-api-8.9.0-alpha04.jar">
+            <sha256 value="a04adbbb71c5cdd9f94a74a9eda36fb7571a01d2f920f0418acaa4202f748d4a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="gradle-settings-api-8.9.0-alpha04.module">
+            <sha256 value="87c26ee1996a44ee71ce68f8b62293943a051451686dd32b4b077b53100ad6b2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="manifest-merger" version="31.9.0-alpha04">
+         <artifact name="manifest-merger-31.9.0-alpha04.jar">
+            <sha256 value="ef29c941e4f356a0a5e7acd0cf842a6deeb438a1f41410b1e23677fec649b9b7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="manifest-merger-31.9.0-alpha04.module">
+            <sha256 value="335de14be3a24a221a67d31031e374dc489a71a9b79fb3f7d39c1e42e959a8fa" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.build" name="transform-api" version="2.0.0-deprecated-use-gradle-api">
+         <artifact name="transform-api-2.0.0-deprecated-use-gradle-api.jar">
+            <sha256 value="e8b4151ae1679f1abe7a14ee371ac9b3c651ae7b63290d1f586bdd0f78face9a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="transform-api-2.0.0-deprecated-use-gradle-api.pom">
+            <sha256 value="d49d179f707d3f3a00b2a7d36136b54aa8d44fa22770703cd82fe52fb39e22eb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.ddms" name="ddmlib" version="31.9.0-alpha04">
+         <artifact name="ddmlib-31.9.0-alpha04.jar">
+            <sha256 value="ab1288e6ec107a377cbaa3d0c558160fffa5813f5f263c24de3270a5eb73aa98" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="ddmlib-31.9.0-alpha04.pom">
+            <sha256 value="7d25313d5641687593ce0fec1ad8af7fa95e27e87bd1de5832cafcb4079a2376" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.external.com-intellij" name="intellij-core" version="31.9.0-alpha04">
+         <artifact name="intellij-core-31.9.0-alpha04.jar">
+            <sha256 value="8ab8cadf840efa205abef22913f33892e644234ca7064180bdf7b6f559d85e7a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="intellij-core-31.9.0-alpha04.pom">
+            <sha256 value="a84f9b9363f19deab45ea9dd06fb507256dd31ed955c6301a878d7bc2da61f39" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.external.com-intellij" name="kotlin-compiler" version="31.9.0-alpha04">
+         <artifact name="kotlin-compiler-31.9.0-alpha04.jar">
+            <sha256 value="798b73b17b221465e5d7490ebe5fdabbcbdbe499e96022f663c97144f1bceb4e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-compiler-31.9.0-alpha04.pom">
+            <sha256 value="0e8d520722ee3c7b0eeab33b41642f9658f55098be4dc18791475779e0ce43a9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.external.org-jetbrains" name="uast" version="31.9.0-alpha04">
+         <artifact name="uast-31.9.0-alpha04.jar">
+            <sha256 value="97e5dc2b0e09eccd34c127f2177d68305ddc1ffb4005576efde8e84ab591ac6c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="uast-31.9.0-alpha04.pom">
+            <sha256 value="b0359b9b546aa1f301103818431fabd7e8f92740118a49c1e88937ee2ab17671" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.layoutlib" name="layoutlib-api" version="31.9.0-alpha04">
+         <artifact name="layoutlib-api-31.9.0-alpha04.jar">
+            <sha256 value="fb1bf9ea60b59f61ea1b0e327ce82a4196b461e977add0a14443d922fd24d2c6" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="layoutlib-api-31.9.0-alpha04.pom">
+            <sha256 value="1e40a8f48b9da0bad771e0b29ac2e082c9ad7755e5981bf70a513707abbb2af4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint" version="31.9.0-alpha04">
+         <artifact name="lint-31.9.0-alpha04.jar">
+            <sha256 value="bdd03de9d7ec2e4acd3d2df2dd8c965609db647c98209f3bb6126229f8b9a14d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-31.9.0-alpha04.pom">
+            <sha256 value="5b1921584d42b79c0f11afd7cca201ca7ff7bd8a1a26f1302d81c4cd3dd6af11" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-api" version="31.9.0-alpha04">
+         <artifact name="lint-api-31.9.0-alpha04.jar">
+            <sha256 value="957e527b9303d669427edf780eac87c54a5e589c90677b18ed066a0d7f661a0e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-api-31.9.0-alpha04.pom">
+            <sha256 value="b3a33ed1f76c6e2dc1880f19dfb3dad175138cea42c521049c712e3cb3e81d31" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-checks" version="31.9.0-alpha04">
+         <artifact name="lint-checks-31.9.0-alpha04.jar">
+            <sha256 value="f942874b1798ad2b10e1a44299a975f1b329137e625cd4364f4b84638105ba5b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-checks-31.9.0-alpha04.pom">
+            <sha256 value="3dcc6d11164dedf57a1189890e1102fd9a1960da3f3c5855e7ba2e835df9876e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-gradle" version="31.9.0-alpha04">
+         <artifact name="lint-gradle-31.9.0-alpha04.jar">
+            <sha256 value="b884bda63c54af4236240bb55b480dc9f4541469c9442ada7b7690f6d208fe66" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-gradle-31.9.0-alpha04.pom">
+            <sha256 value="b16958a1a0d18d25b3b1bc7da49b9e0d56c6dd84d9433a917a48841f4c5a12f2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-model" version="31.9.0-alpha04">
+         <artifact name="lint-model-31.9.0-alpha04.jar">
+            <sha256 value="f640209179047eba7d0365df6cd1ed7b939a10f072b0e04ce895e69b3565869a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-model-31.9.0-alpha04.pom">
+            <sha256 value="86d319c6107ef569b237565cec01b4e8757499b338aad66da4da142684d6b1db" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-tests" version="31.9.0-alpha04">
+         <artifact name="lint-tests-31.9.0-alpha04.jar">
+            <sha256 value="352f272f04de73518f132cb3dfe3e1014dee8ce776363a18ca212e6a70252de7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-tests-31.9.0-alpha04.pom">
+            <sha256 value="2791ba273e1470ace39d3bd239d6a273e512a0ed385b3bf5cae8f2147baffd8b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.lint" name="lint-typedef-remover" version="31.9.0-alpha04">
+         <artifact name="lint-typedef-remover-31.9.0-alpha04.jar">
+            <sha256 value="4a3ba3babfd79e6fc67bcef647fb4ecfeaf59b481b108f7c2eba4d1c5c6dea8e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="lint-typedef-remover-31.9.0-alpha04.pom">
+            <sha256 value="31502f7347038e3da7b4b40d96b6660e2c7ea9c32ee509740435e30b48e44e5f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-device-provider-ddmlib-proto" version="31.9.0-alpha04">
+         <artifact name="android-device-provider-ddmlib-proto-31.9.0-alpha04.jar">
+            <sha256 value="da9f3f3dae26544c90668549584765d5854a87c425d2cfe577cd34d3600ea097" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-device-provider-ddmlib-proto-31.9.0-alpha04.pom">
+            <sha256 value="8fc355b714dd8c0547478f294d17ed5bb6c88d61239ce8220d79b29f02d9a131" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-device-provider-gradle-proto" version="31.9.0-alpha04">
+         <artifact name="android-device-provider-gradle-proto-31.9.0-alpha04.jar">
+            <sha256 value="ad2342bb1d6f95563400a322493ea1c229cb93df3944f1261b7399f718494049" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-device-provider-gradle-proto-31.9.0-alpha04.pom">
+            <sha256 value="4e651ff529ca7978d0db48a6f7741759df09f0a3ed7c073893c9f0ae185156e3" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-device-provider-profile-proto" version="31.9.0-alpha04">
+         <artifact name="android-device-provider-profile-proto-31.9.0-alpha04.jar">
+            <sha256 value="10d100ced5d083714c1c68bbbb10bb375e8546f92ab0e4219c0e4a5ff298115e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-device-provider-profile-proto-31.9.0-alpha04.pom">
+            <sha256 value="9b3fd191851f0dcbedbd8029c9fc9d5a1979f402eded37b06791b1435599f949" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-additional-test-output-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-additional-test-output-proto-31.9.0-alpha04.jar">
+            <sha256 value="38450694de6328c2c4cba696f9c04ecdd5ce6952355f68c3a22f9541d1d6546f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-additional-test-output-proto-31.9.0-alpha04.pom">
+            <sha256 value="ff7cd1227e98287181079ea40036ae45b9e234e52fbb7624c34aaa952babf877" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-apk-installer-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-apk-installer-proto-31.9.0-alpha04.jar">
+            <sha256 value="543eb6c8d72b2ed7451f8e939d5d80890566f14bc26b7df9c8347506b258d7ae" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-apk-installer-proto-31.9.0-alpha04.pom">
+            <sha256 value="05c779e6e95ac672a358c55a105ee72bee018265128045460ac9171329686550" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-coverage-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-coverage-proto-31.9.0-alpha04.jar">
+            <sha256 value="efb4d7014aaa7355246a07c2e437a2231fb252540ff1bce6872c88dc8da89d12" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-coverage-proto-31.9.0-alpha04.pom">
+            <sha256 value="e82f1a03609efc63f8832ca46d95e7f92a3dba437c727ed5da0a178f7144c9f9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-emulator-control-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-emulator-control-proto-31.9.0-alpha04.jar">
+            <sha256 value="aedec5ec4627d898cccdf42d8038db20eba4495753c53d1b0b378734491caf5f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-emulator-control-proto-31.9.0-alpha04.pom">
+            <sha256 value="cdddb3a3ec465c101adad23ed865108fa277b02d4f66fb25f7377386148b5cf8" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-logcat-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-logcat-proto-31.9.0-alpha04.jar">
+            <sha256 value="9129024bd8e38353bca3eb26dfd8e3628e058d57d6e9d8451ffc35f016751e63" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-logcat-proto-31.9.0-alpha04.pom">
+            <sha256 value="0ae267a17497590e1cb63b450632559d4fb20e1713e7211a4cd7c4b44b6d60da" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-host-retention-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-host-retention-proto-31.9.0-alpha04.jar">
+            <sha256 value="3db8ed38ef49b694caea466ae22e3b36cedc9557b3589d0e07c0cdd83294591c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-host-retention-proto-31.9.0-alpha04.pom">
+            <sha256 value="f78febcd9b4170aa883216250ddf5e612921bcd410b199533c39aa988820c0b5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.android.tools.utp" name="android-test-plugin-result-listener-gradle-proto" version="31.9.0-alpha04">
+         <artifact name="android-test-plugin-result-listener-gradle-proto-31.9.0-alpha04.jar">
+            <sha256 value="cbdf71bca60e14c30e7b2cf4b90f0f0a3e8c138f7cadd874b0d9c0ae082e0274" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="android-test-plugin-result-listener-gradle-proto-31.9.0-alpha04.pom">
+            <sha256 value="77a4a8328d54b322d4d5df2660aba71dcb5e3cab7e1e3df45a498f4a737e306d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.facebook" name="ktfmt" version="0.44">
+         <artifact name="ktfmt-0.44.jar">
+            <sha256 value="0045f5c74d79d43c13a017a8475b92c1dde4fd43e04871a4ab47bc953edcfefa" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="ktfmt-0.44.pom">
+            <sha256 value="97f6a16706f09cd86fef91d7197658ce47720c7d73e6147590cd48df8b10122d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.facebook" name="ktfmt-parent" version="0.44">
+         <artifact name="ktfmt-parent-0.44.pom">
+            <sha256 value="8ea5f062165bf84d9dc7d73c1b9b0e860a82d6f9c8e6f7a6c2e8cebe1235050d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml" name="oss-parent" version="38">
+         <artifact name="oss-parent-38.pom">
+            <sha256 value="c83f8f45dfdca8d0b6b3661c60b3f84780f671b12e06f91ad5d1c1a1d1f966e8" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml" name="oss-parent" version="50">
+         <artifact name="oss-parent-50.pom">
+            <sha256 value="f5da55dd7b88fb170c46801d17774a652fb2f4581fb5b1d0a5fc86aa182b8577" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml" name="oss-parent" version="55">
+         <artifact name="oss-parent-55.pom">
+            <sha256 value="0f5e18f2b35ebf6d839f7fd549972883f696c210f9ae3230afd2c20ba886c04d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml" name="oss-parent" version="59">
+         <artifact name="oss-parent-59.pom">
+            <sha256 value="8e54db60e1080e03b6ddb96b14db3e3e6dbde244a713040204106c167f135233" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml" name="oss-parent" version="61">
+         <artifact name="oss-parent-61.pom">
+            <sha256 value="3649513cf597e9186da0855986a8c543e12bdbd805edeef9c124db56dd036544" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson" name="jackson-bom" version="2.15.0">
+         <artifact name="jackson-bom-2.15.0.pom">
+            <sha256 value="e00c2e86229cd968794691ae90eee15b08c4d4f5748c9b34bb422d713446dd95" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson" name="jackson-bom" version="2.18.2">
+         <artifact name="jackson-bom-2.18.2.pom">
+            <sha256 value="5247cdc301725d3f67f7ef049037289d5af709d6972bcf4b17096e4548d2956b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson" name="jackson-parent" version="2.15">
+         <artifact name="jackson-parent-2.15.pom">
+            <sha256 value="6cdf97bc66f389f63e36850d2f552d1216688f8e5a58727d3f6a98edf8675cde" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson" name="jackson-parent" version="2.18.1">
+         <artifact name="jackson-parent-2.18.1.pom">
+            <sha256 value="d0822fac1a0226844b8ad445c920c49a4f619169d09b1010a7dfeed19910998c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-annotations" version="2.15.0">
+         <artifact name="jackson-annotations-2.15.0.jar">
+            <sha256 value="91adcd3dcf5fd9a16499934e7536a23d456692a0093e3d4fd52f138c3936348c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-annotations-2.15.0.module">
+            <sha256 value="bf1555a2e4bb3f23db391fc4c8dfc6157ec64e8c376588144a260f541b2de1ae" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-annotations" version="2.18.2">
+         <artifact name="jackson-annotations-2.18.2.jar">
+            <sha256 value="581bd61000ef7648943f781ca05689e56d03f6052748365a8e2b3a9b5d3fa32f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-annotations-2.18.2.module">
+            <sha256 value="e11baf9b536e6df94daa635a1013ec3e069b866b8e112ddc2aa0446a155050dc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-core" version="2.15.0">
+         <artifact name="jackson-core-2.15.0.jar">
+            <sha256 value="5b483f68fa9dd6aa37da37d1f79dd5c4b9464238f4f0660a242cb6b5c724950c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-core-2.15.0.module">
+            <sha256 value="ee1d06a38e8d44d81a2e6a6f54b7d864ae4b2ff710ddf58a2bdfb891f2717381" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-core" version="2.18.2">
+         <artifact name="jackson-core-2.18.2.jar">
+            <sha256 value="d8054ae7c0d1c2d2f55d28e46026ebe5892881f3fab5f439233184381c3b4a1f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-core-2.18.2.module">
+            <sha256 value="ca78c60436767fcc36ce146b774e4f50a9cb9f632d13172c44bae88e0c03cfa2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-databind" version="2.15.0">
+         <artifact name="jackson-databind-2.15.0.jar">
+            <sha256 value="00c5a5d5ae71ac8e8d5b8da606841e2251c806355939cb5d51c4cdc6b644a0dc" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-databind-2.15.0.module">
+            <sha256 value="a1a842346fde9efc48ddb938b44f1eeebd446868f5cd7031326653a132c06f83" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.core" name="jackson-databind" version="2.18.2">
+         <artifact name="jackson-databind-2.18.2.jar">
+            <sha256 value="4b364e6850dc89172fcf1d4dd26b8ff5488eda44ff4657e22dd265203dd5ab3c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-databind-2.18.2.module">
+            <sha256 value="8c7dac2f727818d8847a82aa4eac6b0174d79cf04df90de2246072e6dd34e700" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.dataformat" name="jackson-dataformat-xml" version="2.15.0">
+         <artifact name="jackson-dataformat-xml-2.15.0.jar">
+            <sha256 value="e3137c89b08d0c3d9f7dfeae11d5b941b310f5f7bfdea90063f29c0b3b1f6807" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-dataformat-xml-2.15.0.module">
+            <sha256 value="499f0f934f74c93b2045db5a5a00a091d27d1026a0cb5cbe5739e5f5abe0693d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.dataformat" name="jackson-dataformat-xml" version="2.18.2">
+         <artifact name="jackson-dataformat-xml-2.18.2.jar">
+            <sha256 value="3a5c26f070b9974617f4b103b9561d4f5e3f4f8cc60162d4e0cd3e172c776af5" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-dataformat-xml-2.18.2.module">
+            <sha256 value="a4b0a6fff89daec6c383b014fda4db97427c4556641ca0df542e1084a9c388e2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.jackson.module" name="jackson-module-kotlin" version="2.15.0">
+         <artifact name="jackson-module-kotlin-2.15.0.jar">
+            <sha256 value="a8f728e2b8da5cd679ed940138a684891a165c7fdd95aede85e95aa0a004cb1e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jackson-module-kotlin-2.15.0.module">
+            <sha256 value="b2625fccbaf57edb69c5d2edc16a768550dbf0e13cfa6ea9eee900e0c1aa09a6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.woodstox" name="woodstox-core" version="6.5.1">
+         <artifact name="woodstox-core-6.5.1.jar">
+            <sha256 value="c928d60665c6415fb1c39775cf95cfc44f7f4580cf5ab01b1c380ebffd76887f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="woodstox-core-6.5.1.pom">
+            <sha256 value="4839654e16b1714e74f51abcb378d8356814ab8f4d5273d1dd2f1ce8a390addc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.fasterxml.woodstox" name="woodstox-core" version="7.0.0">
+         <artifact name="woodstox-core-7.0.0.jar">
+            <sha256 value="eeb3853282c24964a93a6eb4c1bbcb60c8d09fd8e0ffc75ab64ad21045a1fa78" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="woodstox-core-7.0.0.pom">
+            <sha256 value="184c25e1bc38428af2bbeb67d77632ec9fe30a82cf20b10f513bed3f92c4e6e4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.github.ajalt.clikt" name="clikt-jvm" version="3.5.3">
+         <artifact name="clikt-jvm-3.5.3.module">
+            <sha256 value="c3c6314213e5b2d6193bf78287a4ad1cb76ab417a2049a922255c74230f00693" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="clikt-jvm.jar">
+            <sha256 value="e003327a491671d612d787a5269188a7fb84c2f419f08f590a35a18e87c30817" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.android" name="annotations" version="4.1.1.4">
+         <artifact name="annotations-4.1.1.4.jar">
+            <sha256 value="ba734e1e84c09d615af6a09d33034b4f0442f8772dec120efb376d86a565ae15" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="annotations-4.1.1.4.pom">
+            <sha256 value="e4bb54753c36a27a0e5d70154a5034fedd8feac4282295034bfd483d6c7aae78" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.api.grpc" name="proto-google-common-protos" version="2.17.0">
+         <artifact name="proto-google-common-protos-2.17.0.jar">
+            <sha256 value="4ef1fe0c327fc1521d1d753b0b1c4a875a54bd14ebded3afff0ca395320b6ea9" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="proto-google-common-protos-2.17.0.pom">
+            <sha256 value="3f028153a585c59f558b3e43a7c9809a601a8bb5e91061d6c658fffa24cb8e26" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.auto" name="auto-parent" version="6">
+         <artifact name="auto-parent-6.pom">
+            <sha256 value="05f740c6648165db00cf618dd56c200c4725e358e6d54f5853e0bec15734ea0a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.auto.value" name="auto-value-annotations" version="1.6.2">
+         <artifact name="auto-value-annotations-1.6.2.jar">
+            <sha256 value="b48b04ddba40e8ac33bf036f06fc43995fc5084bd94bdaace807ce27d3bea3fb" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="auto-value-annotations-1.6.2.pom">
+            <sha256 value="1c76cd462fc96e7aa96dc70ce82f0d54063d6df16db35c9c7d9cc0d1a99d3fff" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.auto.value" name="auto-value-annotations" version="1.8.1">
+         <artifact name="auto-value-annotations-1.8.1.jar">
+            <sha256 value="37ec09b47d7ed35a99d13927db5c86fc9071f620f943ead5d757144698310852" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="auto-value-annotations-1.8.1.pom">
+            <sha256 value="aef37993198860b47398b370c5752cccef66ff85bf0c9bbf060a5cd4534c5f6a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.auto.value" name="auto-value-parent" version="1.6.2">
+         <artifact name="auto-value-parent-1.6.2.pom">
+            <sha256 value="27b640c82179f5cff62009c0b72033d9bc60f60e9902a66802274b7fe37fc81c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.auto.value" name="auto-value-parent" version="1.8.1">
+         <artifact name="auto-value-parent-1.8.1.pom">
+            <sha256 value="3d989bdae9cef7ede12aa69ad71f4bb253bd3a49634aa9bbd81b172a87feafd2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.code.findbugs" name="jsr305" version="3.0.2">
+         <artifact name="jsr305-3.0.2.jar">
+            <sha256 value="766ad2a0783f2687962c8ad74ceecc38a28b9f72a2d085ee438b7813e928d0c7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jsr305-3.0.2.pom">
+            <sha256 value="19889dbdf1b254b2601a5ee645b8147a974644882297684c798afe5d63d78dfe" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.code.gson" name="gson" version="2.10.1">
+         <artifact name="gson-2.10.1.jar">
+            <sha256 value="4241c14a7727c34feea6507ec801318a3d4a90f070e4525681079fb94ee4c593" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="gson-2.10.1.pom">
+            <sha256 value="d2b115634f5c085db4b9c9ffc2658e89e231fdbfbe2242121a1cd95d4d948dd7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.code.gson" name="gson" version="2.8.9">
+         <artifact name="gson-2.8.9.jar">
+            <sha256 value="d3999291855de495c94c743761b8ab5176cfeabe281a5ab0d8e8d45326fd703e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="gson-2.8.9.pom">
+            <sha256 value="afded6e6a690fbf3ad4ae65ada397f0a90a5f630b303d1b741b9c97926fdd4de" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.code.gson" name="gson-parent" version="2.10.1">
+         <artifact name="gson-parent-2.10.1.pom">
+            <sha256 value="4248e0882426c615182385d6086c3ef3262e769957189e29306280b85482b833" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.code.gson" name="gson-parent" version="2.8.9">
+         <artifact name="gson-parent-2.8.9.pom">
+            <sha256 value="b16e026e63427c1972ad0fc68703ec379b1576e411ba49c32fa9a31ab0bbcffb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.crypto.tink" name="tink" version="1.7.0">
+         <artifact name="tink-1.7.0.jar">
+            <sha256 value="88970a456a08ba4c66b01b23e5846ca1095cc14e54cb48363e5d2e15a1307308" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="tink-1.7.0.pom">
+            <sha256 value="2aee3523715f8f2cd10b2603c8d19e561ac758310b7e2c9853946d2c5e7b4bf7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.dagger" name="dagger" version="2.28.3">
+         <artifact name="dagger-2.28.3.jar">
+            <sha256 value="f1dd23f8ae34a8e91366723991ead0d6499d1a3e9163ce550c200b02d76a872b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="dagger-2.28.3.pom">
+            <sha256 value="265ba959a8e13c3a06133f04b539169c1018daffd4d33f53c453ab4cb386f570" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.11.0">
+         <artifact name="error_prone_annotations-2.11.0.pom">
+            <sha256 value="0261ca01f2d2e9ac2ae2ece75d42c56323b385fb294b6bc943f62ef4e92ddf08" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.16">
+         <artifact name="error_prone_annotations-2.16.pom">
+            <sha256 value="606e66083c9367b231103e851b8c19271fa35b8c61b30b9ba368250fb316ae09" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.18.0">
+         <artifact name="error_prone_annotations-2.18.0.jar">
+            <sha256 value="9e6814cb71816988a4fd1b07a993a8f21bb7058d522c162b1de849e19bea54ae" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="error_prone_annotations-2.18.0.pom">
+            <sha256 value="920135797dcca5917b5a5c017642a58d340a4cd1bcd12f56f892a5663bd7bddc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.3.1">
+         <artifact name="error_prone_annotations-2.3.1.pom">
+            <sha256 value="3edce6b711ba368efe16b9b7aacb0214fbd648414cb9b965953a2e7ed89a819a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.3.4">
+         <artifact name="error_prone_annotations-2.3.4.jar">
+            <sha256 value="baf7d6ea97ce606c53e11b6854ba5f2ce7ef5c24dddf0afa18d1260bd25b002c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="error_prone_annotations-2.3.4.pom">
+            <sha256 value="1326738a4b4f7ccacf607b866a11fb85193ef60f6a59461187ce7265f9be5bed" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_annotations" version="2.7.1">
+         <artifact name="error_prone_annotations-2.7.1.jar">
+            <sha256 value="cd5257c08a246cf8628817ae71cb822be192ef91f6881ca4a3fcff4f1de1cff3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="error_prone_annotations-2.7.1.pom">
+            <sha256 value="31a872e1149c5f3a8bc05fb4de455e5ea608ecfad1af222cb7637ca6c762ee25" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.11.0">
+         <artifact name="error_prone_parent-2.11.0.pom">
+            <sha256 value="8283f0cb44c624a79d330b6fd80b8b8a715a68b3685c9a951c3de837d4540551" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.16">
+         <artifact name="error_prone_parent-2.16.pom">
+            <sha256 value="0f4428f7ed6eeeb0b9f63496413f9cde7bc76c90d6bf13bd3a8de7b3740eb8be" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.18.0">
+         <artifact name="error_prone_parent-2.18.0.pom">
+            <sha256 value="47f22e99c7bf466391def16f8377985e5d3ba6f5bbcf65853644805513e15fad" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.3.1">
+         <artifact name="error_prone_parent-2.3.1.pom">
+            <sha256 value="767525d9a81129cd081968382980336327be4162b1e2251a182911daa733c123" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.3.4">
+         <artifact name="error_prone_parent-2.3.4.pom">
+            <sha256 value="40495b437a60d2398f0fdfc054b89d9c394a82347a274a0721c2e950a4302186" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.errorprone" name="error_prone_parent" version="2.7.1">
+         <artifact name="error_prone_parent-2.7.1.pom">
+            <sha256 value="0a6e242e28104e8093405ae37969660a438b71c4c1b73fc4ff716db89da88de6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.flatbuffers" name="flatbuffers-java" version="1.12.0">
+         <artifact name="flatbuffers-java-1.12.0.jar">
+            <sha256 value="3f8c088b4dd04a9858721f2e162508c94db0dd86f961e306ee63ef2eda871bf7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="flatbuffers-java-1.12.0.pom">
+            <sha256 value="cb226baf546260770f21e8152a6aa88ba15230d739f750df480f2a668d43e0eb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.googlejavaformat" name="google-java-format" version="1.8">
+         <artifact name="google-java-format-1.8.jar">
+            <sha256 value="4e12b232d7f65cb1dcfffe0b44f97f20977288162dcdec9df09255f298003b98" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="google-java-format-1.8.pom">
+            <sha256 value="066fcdb7abb9736f51602b73b26c75184bf501a03c8a66a42dc0526886c44967" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.googlejavaformat" name="google-java-format-parent" version="1.8">
+         <artifact name="google-java-format-parent-1.8.pom">
+            <sha256 value="2ec55c1fbdf9aadcf38a725c09cee4e5be8c78af3d85e83fb98c62e7d00e033b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="failureaccess" version="1.0.1">
+         <artifact name="failureaccess-1.0.1.jar">
+            <sha256 value="a171ee4c734dd2da837e4b16be9df4661afab72a41adaf31eb84dfdaf936ca26" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="failureaccess-1.0.1.pom">
+            <sha256 value="e96042ce78fecba0da2be964522947c87b40a291b5fd3cd672a434924103c4b9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava" version="29.0-jre">
+         <artifact name="guava-29.0-jre.jar">
+            <sha256 value="b22c5fb66d61e7b9522531d04b2f915b5158e80aa0b40ee7282c8bfb07b0da25" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="guava-29.0-jre.pom">
+            <sha256 value="9027e934098903d287f1ba61c8b65f01d1d1e1da7a6fbcc04bf3de0544014426" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava" version="30.1.1-android">
+         <artifact name="guava-30.1.1-android.jar">
+            <sha256 value="355f79352f8c252f2bdaa06c687c4836a38016caccfc4c28d16ae77ecfdffa2f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="guava-30.1.1-android.pom">
+            <sha256 value="b218de6e345a7983fefce49a04baf19f6ace359cad1c84973190cd6c4da05846" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava" version="32.0.1-jre">
+         <artifact name="guava-32.0.1-jre.jar">
+            <sha256 value="bd7fa227591fb8509677d0d1122cf95158f3b8a9f45653f58281d879f6dc48c5" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="guava-32.0.1-jre.pom">
+            <sha256 value="42c257f7f736d377b31afeeee978ab26d730cd70af60dde7662e182352e2482a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava" version="32.1.1-jre">
+         <artifact name="guava-32.1.1-jre.jar">
+            <sha256 value="91fbba37f1c8b251cf9ea9e7d3a369eb79eb1e6a5df1d4bbf483dd0380740281" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="guava-32.1.1-jre.module">
+            <sha256 value="a58f938d239e698b59b3c39cad580efd1a3fd4ca13ab92b30426d42452c4ef3e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava-parent" version="26.0-android">
+         <artifact name="guava-parent-26.0-android.pom">
+            <sha256 value="f8698ab46ca996ce889c1afc8ca4f25eb8ac6b034dc898d4583742360016cc04" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava-parent" version="29.0-jre">
+         <artifact name="guava-parent-29.0-jre.pom">
+            <sha256 value="6a57f9e02f78dfa2f4bda3416065a64426ae1b66de228cf6e196e2e1912553bf" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava-parent" version="30.1.1-android">
+         <artifact name="guava-parent-30.1.1-android.pom">
+            <sha256 value="d8e6b0f0fa4bf6be21734dc530f74d8696e9d0ac3ad27fbc7928ba3d8f64d761" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava-parent" version="32.0.1-jre">
+         <artifact name="guava-parent-32.0.1-jre.pom">
+            <sha256 value="43ed0e36b353f41e5eb75cd756667c9e2df97cef06eb16066967158a1d034d2a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="guava-parent" version="32.1.1-jre">
+         <artifact name="guava-parent-32.1.1-jre.pom">
+            <sha256 value="06aa5d1ac068f2f809530f3ff53fb5c8c940152a253623d0b53c4f53f5a13a3d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.guava" name="listenablefuture" version="9999.0-empty-to-avoid-conflict-with-guava">
+         <artifact name="listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar">
+            <sha256 value="b372a037d4230aa57fbeffdef30fd6123f9c0c2db85d0aced00c91b974f33f99" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.pom">
+            <sha256 value="18d4b1db26153d4e55079ce1f76bb1fe05cdb862ef9954a88cbcc4ff38b8679b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.j2objc" name="j2objc-annotations" version="1.3">
+         <artifact name="j2objc-annotations-1.3.jar">
+            <sha256 value="21af30c92267bd6122c0e0b4d20cccb6641a37eaf956c6540ec471d584e64a7b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="j2objc-annotations-1.3.pom">
+            <sha256 value="5faca824ba115bee458730337dfdb2fcea46ba2fd774d4304edbf30fa6a3f055" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.j2objc" name="j2objc-annotations" version="2.8">
+         <artifact name="j2objc-annotations-2.8.jar">
+            <sha256 value="f02a95fa1a5e95edb3ed859fd0fb7df709d121a35290eff8b74dce2ab7f4d6ed" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="j2objc-annotations-2.8.pom">
+            <sha256 value="37f87798b18385113c918bfa9e1276fe50735ef8fa849b5800c519d54dbf11f8" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.jimfs" name="jimfs" version="1.1">
+         <artifact name="jimfs-1.1.jar">
+            <sha256 value="c4828e28d7c0a930af9387510b3bada7daa5c04d7c25a75c7b8b081f1c257ddd" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jimfs-1.1.pom">
+            <sha256 value="efa86e5cd922f17b472fdfcae57234d8d4ac3e148b6250737dfce454af7a7a44" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.jimfs" name="jimfs" version="1.2">
+         <artifact name="jimfs-1.2.jar">
+            <sha256 value="de16d5c8489729a8512f1a02fbd81f58f89249b72066987da4cc5c87ecb9f72d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jimfs-1.2.pom">
+            <sha256 value="c4a23fb6320252ff397dafa70ce30479f1da8e6158f3b63052c49fac4669916f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.jimfs" name="jimfs-parent" version="1.1">
+         <artifact name="jimfs-parent-1.1.pom">
+            <sha256 value="c71555751e57e0ef912870e8ac9625ae782502a6a5b9c19ccf83b2a97d8b26bd" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.jimfs" name="jimfs-parent" version="1.2">
+         <artifact name="jimfs-parent-1.2.pom">
+            <sha256 value="e47b362a84b65daf3196b5a205634af5608ba9e56086ff4af183daa29258571b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.protobuf" name="protobuf-bom" version="3.22.3">
+         <artifact name="protobuf-bom-3.22.3.pom">
+            <sha256 value="13a32dfb9de6fc1c3c3f7af53e4d5c77fd77d2b476bae38b74b7581cdee2e655" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.protobuf" name="protobuf-java" version="3.22.3">
+         <artifact name="protobuf-java-3.22.3.jar">
+            <sha256 value="59d388ea6a2d2d76ae8efff7fd4d0c60c6f0f464c3d3ab9be8e5add092975708" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="protobuf-java-3.22.3.pom">
+            <sha256 value="186ea794150f5b42aea7ec6041df373d1d8a8a831624f58a55debb6043ec7312" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.protobuf" name="protobuf-java-util" version="3.22.3">
+         <artifact name="protobuf-java-util-3.22.3.jar">
+            <sha256 value="c615f76879dc5c303e4df5b94a6afa39534058c7545db2d483fd95d9f63c8bfe" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="protobuf-java-util-3.22.3.pom">
+            <sha256 value="b44701b06a064865ec9b5614a93e9e28fadd7d4dfc4b460f21c819ef53dbe2d6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.protobuf" name="protobuf-parent" version="3.22.3">
+         <artifact name="protobuf-parent-3.22.3.pom">
+            <sha256 value="399133d7f6f57934dd76c4b18e86348f424532108daf4a01c8f820b8665f0929" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.truth" name="truth" version="1.1.3">
+         <artifact name="truth-1.1.3.jar">
+            <sha256 value="fc0b67782289a2aabfddfdf99eff1dcd5edc890d49143fcd489214b107b8f4f3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="truth-1.1.3.pom">
+            <sha256 value="3788951d82568b9a1ff7ab145274b8e6062b156e003704bcf6b9a6cc5c5f660b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.truth" name="truth-parent" version="1.1.3">
+         <artifact name="truth-parent-1.1.3.pom">
+            <sha256 value="9ac211b0ae371355dc70d5a6a528654fe72c95b6f328052fb5dced45f9afe7f5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.google.turbine" name="turbine" version="0.2.1">
+         <artifact name="turbine-0.2.1.jar">
+            <sha256 value="d0777f485ed32bda0aadcb173eabc5c5325086c1fc2d1a881c3784d26f010da0" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="turbine-0.2.1.pom">
+            <sha256 value="2f2b294cea0d0598b5de36f94e45f2dd4065424d32d233a28c2645803b3d7bbb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.googlecode.juniversalchardet" name="juniversalchardet" version="1.0.3">
+         <artifact name="juniversalchardet-1.0.3.jar">
+            <sha256 value="757bfe906193b8b651e79dc26cd67d6b55d0770a2cdfb0381591504f779d4a76" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="juniversalchardet-1.0.3.pom">
+            <sha256 value="7846399b35c7cd642a9b3a000c3e2d62d04eb37a4547b6933cc8b18bcc2f086b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.squareup" name="javapoet" version="1.10.0">
+         <artifact name="javapoet-1.10.0.jar">
+            <sha256 value="20ef4b82e43ff7c652281a21313cf3b941092467add3fa73509c26f6969efdab" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="javapoet-1.10.0.pom">
+            <sha256 value="1690340a222279f2cbadf373e88826fa20f7f3cc3ec0252f36818fed32701ab1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.squareup" name="javawriter" version="2.5.0">
+         <artifact name="javawriter-2.5.0.jar">
+            <sha256 value="fcfb09fb0ea0aa97d3cfe7ea792398081348e468f126b3603cb3803f240197f0" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="javawriter-2.5.0.pom">
+            <sha256 value="e1abd7f1116cf5e0c59947693e2189208ec94296b2a3394c959e3511d399a7b0" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.activation" name="all" version="1.2.0">
+         <artifact name="all-1.2.0.pom">
+            <sha256 value="1d8518e3ac7532a104e4f7be77def37c982e530723c6bdb3d67708cce2b0c2c4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.activation" name="all" version="1.2.1">
+         <artifact name="all-1.2.1.pom">
+            <sha256 value="360883bf64486ecef161b8f282f6503536dd1a670d53a0a871c8fb20170e6795" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.activation" name="javax.activation" version="1.2.0">
+         <artifact name="javax.activation-1.2.0.jar">
+            <sha256 value="993302b16cd7056f21e779cc577d175a810bb4900ef73cd8fbf2b50f928ba9ce" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="javax.activation-1.2.0.pom">
+            <sha256 value="f879b6e945854c6900b0dbee1c8384d7ab3de7e157fd7ac84937405c416d2a5e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.istack" name="istack-commons" version="3.0.8">
+         <artifact name="istack-commons-3.0.8.pom">
+            <sha256 value="a0f0517e8512f0fbcc7b8295c12f6566a3d0c2d86d655639dc662ef8c0c7ebe5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.istack" name="istack-commons-runtime" version="3.0.8">
+         <artifact name="istack-commons-runtime-3.0.8.jar">
+            <sha256 value="4ffabb06be454a05e4398e20c77fa2b6308d4b88dfbef7ca30a76b5b7d5505ef" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="istack-commons-runtime-3.0.8.pom">
+            <sha256 value="c2e014d34cb84ed287d064986c45c305a4124228a7337eccf6c421d14d708f1c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.bind" name="jaxb-bom-ext" version="2.3.2">
+         <artifact name="jaxb-bom-ext-2.3.2.pom">
+            <sha256 value="1a7dec2b27e7e055744cdb8cf1b90def4fd473acd1b804eff098139358959bd7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.bind.mvn" name="jaxb-parent" version="2.3.2">
+         <artifact name="jaxb-parent-2.3.2.pom">
+            <sha256 value="20dd6dc34ab7549ac40da1d82e92222ec4347ad0ec0cb118ef6c5703bed53a18" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.bind.mvn" name="jaxb-runtime-parent" version="2.3.2">
+         <artifact name="jaxb-runtime-parent-2.3.2.pom">
+            <sha256 value="b24f8d51f184a68bc1b86d48c0e3cfefeb21a44ede1c5f7303c58ae0488533ec" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.bind.mvn" name="jaxb-txw-parent" version="2.3.2">
+         <artifact name="jaxb-txw-parent-2.3.2.pom">
+            <sha256 value="b55d3efa9b158f483a30e92c78ccb600f93314733d089eba9b74436f01b314a4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.fastinfoset" name="FastInfoset" version="1.2.16">
+         <artifact name="FastInfoset-1.2.16.jar">
+            <sha256 value="056f3a1e144409f21ed16afc26805f58e9a21f3fce1543c42d400719d250c511" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="FastInfoset-1.2.16.pom">
+            <sha256 value="e147d258ab6e6691f70599a952400e6e6c7558f8c9c028dbe1be23178308e830" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="com.sun.xml.fastinfoset" name="fastinfoset-project" version="1.2.16">
+         <artifact name="fastinfoset-project-1.2.16.pom">
+            <sha256 value="90582425adc1f40b41362dafb95173931225acaa5e79620d5e6bd52f646292ba" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="commons-codec" name="commons-codec" version="1.10">
+         <artifact name="commons-codec-1.10.jar">
+            <sha256 value="4241dfa94e711d435f29a4604a3e2de5c4aa3c165e23bd066be6fc1fc4309569" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="commons-codec-1.10.pom">
+            <sha256 value="bdb8db7012d112a6e3ea8fdb7c510b300d99eff0819d27dddba9c43397ea4cfb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="commons-codec" name="commons-codec" version="1.11">
+         <artifact name="commons-codec-1.11.jar">
+            <sha256 value="e599d5318e97aa48f42136a2927e6dfa4e8881dff0e6c8e3109ddbbff51d7b7d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="commons-codec-1.11.pom">
+            <sha256 value="c1e7140d1dea8fdf3528bc1e3c5444ac0b541297311f45f9806c213ec3ee9a10" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="commons-io" name="commons-io" version="2.16.1">
+         <artifact name="commons-io-2.16.1.jar">
+            <sha256 value="f41f7baacd716896447ace9758621f62c1c6b0a91d89acee488da26fc477c84f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="commons-io-2.16.1.pom">
+            <sha256 value="5777d292251c7895c04a4c57015683ec3b353a12486c9b3e7178e9b0b3c38fff" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="commons-logging" name="commons-logging" version="1.2">
+         <artifact name="commons-logging-1.2.jar">
+            <sha256 value="daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="commons-logging-1.2.pom">
+            <sha256 value="c91ab5aa570d86f6fd07cc158ec6bc2c50080402972ee9179fe24100739fbb20" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-api" version="1.57.0">
+         <artifact name="grpc-api-1.57.0.jar">
+            <sha256 value="8d2c384299f84ee8aa7f670f00e7cb26b87e231cf3091474307b32b76910f71c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-api-1.57.0.pom">
+            <sha256 value="c3f054a7c8861647d0a55825b0a949f44fcfc9c64f479083d96813814c502612" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-context" version="1.57.0">
+         <artifact name="grpc-context-1.57.0.jar">
+            <sha256 value="953fcacd82f531e69b76e3834f5830bad4c22ae84144e058d71dc80a7430275d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-context-1.57.0.pom">
+            <sha256 value="ab264e82bfb6ab895f6016af8b3cc44495abc81e769c30fa5a9ae0ad16be6cc6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-core" version="1.57.0">
+         <artifact name="grpc-core-1.57.0.jar">
+            <sha256 value="3bee48c73bc4c5b55bed79be0e484adf26ba56bebbe5798ddbf34714ef1e1cea" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-core-1.57.0.pom">
+            <sha256 value="8184045f5791e00cf2cdbcf5e8846afd48f5cf7e5a4f38fb5b8303c7b2efe55b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-netty" version="1.57.0">
+         <artifact name="grpc-netty-1.57.0.jar">
+            <sha256 value="81d43f2d4ed18fa341bd840a3735f1403a70074a046e157e27f679b721b4c9ad" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-netty-1.57.0.pom">
+            <sha256 value="ed9dfdd7b1ed4356afb3c5d1407dedb634c8602fb410479b480ad8c1139ee17b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-protobuf" version="1.57.0">
+         <artifact name="grpc-protobuf-1.57.0.jar">
+            <sha256 value="49f986d4eab12610fdba4a6890fca52d5eb653598916fdb863a366d5e28eecf7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-protobuf-1.57.0.pom">
+            <sha256 value="c0dcb8c67fd01daa63256f0f8b68d3707ceb7ca85cdaab7a3c6c3ff460e13dd1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-protobuf-lite" version="1.57.0">
+         <artifact name="grpc-protobuf-lite-1.57.0.jar">
+            <sha256 value="2c507c02d981b84a21763d44e09af4f279881dd3e25be3080f6361258607f198" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-protobuf-lite-1.57.0.pom">
+            <sha256 value="b023be7008849489f652eeff75fd0fe1aa9c905f671d344e16daafddf921819d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.grpc" name="grpc-stub" version="1.57.0">
+         <artifact name="grpc-stub-1.57.0.jar">
+            <sha256 value="6e6ee141539fa14d9fa479f7f511605544443c7e011e78e273cf9468aa183060" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="grpc-stub-1.57.0.pom">
+            <sha256 value="6d4459487c621dff31510a88829063631e915d2dcc774d71928418116e59a88d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-buffer" version="4.1.93.Final">
+         <artifact name="netty-buffer-4.1.93.Final.jar">
+            <sha256 value="007c7d9c378df02d390567d0d7ddf542ffddb021b7313dbf502392113ffabb08" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-buffer-4.1.93.Final.pom">
+            <sha256 value="83fbc54e2b73b86d55b208f618d1a2a156910ec146f7ece57565007b750add78" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-codec" version="4.1.93.Final">
+         <artifact name="netty-codec-4.1.93.Final.jar">
+            <sha256 value="990c378168dc6364c6ff569701f4f2f122fffe8998b3e189eba4c4d868ed1084" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-codec-4.1.93.Final.pom">
+            <sha256 value="19cded267a070dff1abc9d029b552fad262acc1aba5c6c67b2278fca113a26ab" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-codec-http" version="4.1.93.Final">
+         <artifact name="netty-codec-http-4.1.93.Final.jar">
+            <sha256 value="dacf78ce78ab2d29570325db4cd2451ea589639807de95881a0fa7155a9e6b55" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-codec-http-4.1.93.Final.pom">
+            <sha256 value="a3dafff071b6d284e8063d96843de2bb83cf3b889eae0cc9e0adb64a57a31b82" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-codec-http2" version="4.1.93.Final">
+         <artifact name="netty-codec-http2-4.1.93.Final.jar">
+            <sha256 value="d96cc09045a1341c6d47494352aa263b87b72fb1d2ea9eca161aa73820bfe8bb" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-codec-http2-4.1.93.Final.pom">
+            <sha256 value="084433b42d541f7ac4b59287dd253285cfda3a3d65de72e7368bb7ec3d367271" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-codec-socks" version="4.1.93.Final">
+         <artifact name="netty-codec-socks-4.1.93.Final.jar">
+            <sha256 value="0ea47b5ba23ca1da8eb9146c8fc755c1271414633b1e2be2ce1df764ba0fff2a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-codec-socks-4.1.93.Final.pom">
+            <sha256 value="8cd816ed991a946041bab4cb24bd9c8e41ee0692512511f2d83cef538eb605d7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-common" version="4.1.93.Final">
+         <artifact name="netty-common-4.1.93.Final.jar">
+            <sha256 value="443bb316599fb16e3baeba2fb58881814d7ff0b7af176fe76e38071a6e86f8c0" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-common-4.1.93.Final.pom">
+            <sha256 value="42d883b13eb38cabf549616462c5f331f5333bf0c8fc9215744f83c0180a4f6b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-handler" version="4.1.93.Final">
+         <artifact name="netty-handler-4.1.93.Final.jar">
+            <sha256 value="4e5f563ae14ed713381816d582f5fcfd0615aefb29203486cdfb782d8a00a02b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-handler-4.1.93.Final.pom">
+            <sha256 value="84a1525cac0b4759efaef2997a47fe19b9b5642f9273fa0fd58a2e76c7a059fe" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-handler-proxy" version="4.1.93.Final">
+         <artifact name="netty-handler-proxy-4.1.93.Final.jar">
+            <sha256 value="2ac5f7fbefa0b73ef783889069344d5515505a14b2303be693c5002c486df2b4" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-handler-proxy-4.1.93.Final.pom">
+            <sha256 value="6dc50da0e67f597812874f81eaa45404f7d076b8199ea9088932a85c1b610245" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-parent" version="4.1.93.Final">
+         <artifact name="netty-parent-4.1.93.Final.pom">
+            <sha256 value="b109cb76f375fedb8a9ef75ac58063170deb7ea2ddd024f466fef6dc65cdfcee" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-resolver" version="4.1.93.Final">
+         <artifact name="netty-resolver-4.1.93.Final.jar">
+            <sha256 value="e59770b66e81822e5d111ac4e544d7eb0c543e0a285f52628e53941acd8ed759" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-resolver-4.1.93.Final.pom">
+            <sha256 value="5b350c3c91e9e55d29cbe68cfe4ef2116cc1f0328677ebf9f615bab7082c79f4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-transport" version="4.1.93.Final">
+         <artifact name="netty-transport-4.1.93.Final.jar">
+            <sha256 value="a5a78019bc1cd43dbc3c7b7cdd3801912ca26d1f498fb560514fee497864ba96" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-transport-4.1.93.Final.pom">
+            <sha256 value="0dd62a0eb3cb1ea001a4d0426e4f5c08df1c70d9265675bffa5c583613422d43" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.netty" name="netty-transport-native-unix-common" version="4.1.93.Final">
+         <artifact name="netty-transport-native-unix-common-4.1.93.Final.jar">
+            <sha256 value="774165a1c4dbaacb17f9c1ad666b3569a6a59715ae828e7c3d47703f479a53e7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="netty-transport-native-unix-common-4.1.93.Final.pom">
+            <sha256 value="15bc25b67ff0a49272b270ef2b8cffd620057ca16cb29dff7ad5661adca2ae12" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="io.perfmark" name="perfmark-api" version="0.26.0">
+         <artifact name="perfmark-api-0.26.0.jar">
+            <sha256 value="b7d23e93a34537ce332708269a0d1404788a5b5e1949e82f5535fce51b3ea95b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="perfmark-api-0.26.0.module">
+            <sha256 value="31d832332474ce48150f5bae003343319136f336afd1076a289029319e3ea97a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="jakarta.activation" name="jakarta.activation-api" version="1.2.1">
+         <artifact name="jakarta.activation-api-1.2.1.jar">
+            <sha256 value="8b0a0f52fa8b05c5431921a063ed866efaa41dadf2e3a7ee3e1961f2b0d9645b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jakarta.activation-api-1.2.1.pom">
+            <sha256 value="42585cb07dda7f23aa04eb5e0940061944a246a67ad3d16942fbe569ff03cd31" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="jakarta.xml.bind" name="jakarta.xml.bind-api" version="2.3.2">
+         <artifact name="jakarta.xml.bind-api-2.3.2.jar">
+            <sha256 value="69156304079bdeed9fc0ae3b39389f19b3cc4ba4443bc80508995394ead742ea" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jakarta.xml.bind-api-2.3.2.pom">
+            <sha256 value="b537b388dbab4cc0690b9d2fb0c74124d672531734567acf6e53130eab131ad6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="jakarta.xml.bind" name="jakarta.xml.bind-api-parent" version="2.3.2">
+         <artifact name="jakarta.xml.bind-api-parent-2.3.2.pom">
+            <sha256 value="15a55b7d537c9f9970aead28d2af97c059f65ff6102f76bbd29f1247dd8a6dfb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="javax.annotation" name="javax.annotation-api" version="1.3.2">
+         <artifact name="javax.annotation-api-1.3.2.jar">
+            <sha256 value="e04ba5195bcd555dc95650f7cc614d151e4bcd52d29a10b8aa2197f3ab89ab9b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="javax.annotation-api-1.3.2.pom">
+            <sha256 value="46a4a251ca406e78e4853d7a2bae83282844a4992851439ee9a1f23716f06b97" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="javax.inject" name="javax.inject" version="1">
+         <artifact name="javax.inject-1.jar">
+            <sha256 value="91c77044a50c481636c32d916fd89c9118a72195390452c81065080f957de7ff" origin="Generated by Gradle" reason="Artifact is not signed"/>
+         </artifact>
+         <artifact name="javax.inject-1.pom">
+            <sha256 value="943e12b100627804638fa285805a0ab788a680266531e650921ebfe4621a8bfa" origin="Generated by Gradle" reason="Artifact is not signed"/>
+         </artifact>
+      </component>
+      <component group="junit" name="junit" version="4.13.2">
+         <artifact name="junit-4.13.2.jar">
+            <sha256 value="8e495b634469d64fb8acfa3495a065cbacc8a0fff55ce1e31007be4c16dc57d3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="junit-4.13.2.pom">
+            <sha256 value="569b6977ee4603c965c1c46c3058fa6e969291b0160eb6964dd092cd89eadd94" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.java" name="jvnet-parent" version="1">
+         <artifact name="jvnet-parent-1.pom">
+            <sha256 value="281440811268e65d9e266b3cc898297e214e04f09740d0386ceeb4a8923d63bf" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.java" name="jvnet-parent" version="3">
+         <artifact name="jvnet-parent-3.pom">
+            <sha256 value="30f5789efa39ddbf96095aada3fc1260c4561faf2f714686717cb2dc5049475a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.java.dev.jna" name="jna" version="4.2.2">
+         <artifact name="jna-4.2.2.pom">
+            <sha256 value="abd66d98c9b3ddd82f9d79cafa4d661f41bbc595d2c81da7af3fc019109af7b7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.java.dev.jna" name="jna" version="5.6.0">
+         <artifact name="jna-5.6.0.jar">
+            <sha256 value="5557e235a8aa2f9766d5dc609d67948f2a8832c2d796cea9ef1d6cbe0b3b7eaf" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jna-5.6.0.pom">
+            <sha256 value="5fe81b0255978f24616d37b10608b79498a5f3073e1d9b2038d8736a831f2608" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.java.dev.jna" name="jna-platform" version="5.6.0">
+         <artifact name="jna-platform-5.6.0.jar">
+            <sha256 value="9ecea8bf2b1b39963939d18b70464eef60c508fed8820f9dcaba0c35518eabf7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jna-platform-5.6.0.pom">
+            <sha256 value="1beb35cb4184e6c906a7e32eaebd852dd3da0a263962e99134ab945832394e28" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.sf.jopt-simple" name="jopt-simple" version="4.9">
+         <artifact name="jopt-simple-4.9.jar">
+            <sha256 value="26c5856e954b5f864db76f13b86919b59c6eecf9fd930b96baa8884626baf2f5" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jopt-simple-4.9.pom">
+            <sha256 value="7af7e2d8b24b4798f04c2b7da24c9fbd1b7557b4e017c2054481565916079092" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="net.sf.kxml" name="kxml2" version="2.3.0">
+         <artifact name="kxml2-2.3.0.jar">
+            <sha256 value="f264dd9f79a1fde10ce5ecc53221eff24be4c9331c830b7d52f2f08a7b633de2" origin="Generated by Gradle" reason="Artifact is not signed. b/294916131"/>
+         </artifact>
+         <artifact name="kxml2-2.3.0.pom">
+            <sha256 value="31ce606f4e9518936299bb0d27c978fa61e185fd1de7c9874fe959a53e34a685" origin="Generated by Gradle" reason="Artifact is not signed. b/294916131"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="13">
+         <artifact name="apache-13.pom">
+            <sha256 value="ff513db0361fd41237bef4784968bc15aae478d4ec0a9496f811072ccaf3841d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="15">
+         <artifact name="apache-15.pom">
+            <sha256 value="36c2f2f979ac67b450c0cb480e4e9baf6b40f3a681f22ba9692287d1139ad494" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="18">
+         <artifact name="apache-18.pom">
+            <sha256 value="7831307285fd475bbc36b20ae38e7882f11c3153b1d5930f852d44eda8f33c17" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="21">
+         <artifact name="apache-21.pom">
+            <sha256 value="af10c108da014f17cafac7b52b2b4b5a3a1c18265fa2af97a325d9143537b380" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="23">
+         <artifact name="apache-23.pom">
+            <sha256 value="bc10624e0623f36577fac5639ca2936d3240ed152fb6d8d533ab4d270543491c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache" name="apache" version="31">
+         <artifact name="apache-31.pom">
+            <sha256 value="555d0c9eaa69c042aff924927b9381e8f8174136d355eead445224452e6291cc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-compress" version="1.21">
+         <artifact name="commons-compress-1.21.jar">
+            <sha256 value="6aecfd5459728a595601cfa07258d131972ffc39b492eb48bdd596577a2f244a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="commons-compress-1.21.pom">
+            <sha256 value="675bb023c9beedde3232949979b9742a5fea946280a55a1b462d4ca7801088cd" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-parent" version="34">
+         <artifact name="commons-parent-34.pom">
+            <sha256 value="3a2e69d06d641d1f3b293126dc9e2e4ea6563bf8c36c87e0ab6fa4292d04b79c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-parent" version="35">
+         <artifact name="commons-parent-35.pom">
+            <sha256 value="7098a1ab8336ecd4c9dc21cbbcac869f82c66f64b8ac4f7988d41b4fcb44e49a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-parent" version="42">
+         <artifact name="commons-parent-42.pom">
+            <sha256 value="cd313494c670b483ec256972af1698b330e598f807002354eb765479f604b09c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-parent" version="52">
+         <artifact name="commons-parent-52.pom">
+            <sha256 value="75dbe8f34e98e4c3ff42daae4a2f9eb4cbcd3b5f1047d54460ace906dbb4502e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.commons" name="commons-parent" version="69">
+         <artifact name="commons-parent-69.pom">
+            <sha256 value="d50da9c39bdca823d618d1b4a03b73f196497fcb8616fd0da727c8623592a9bb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpclient" version="4.5.14">
+         <artifact name="httpclient-4.5.14.jar">
+            <sha256 value="c8bc7e1c51a6d4ce72f40d2ebbabf1c4b68bfe76e732104b04381b493478e9d6" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="httpclient-4.5.14.pom">
+            <sha256 value="f18355af4cf80a8a4ef04ebd742a47e90a7eaf080c725b2095dbc4fc5dbdefb7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpclient" version="4.5.6">
+         <artifact name="httpclient-4.5.6.jar">
+            <sha256 value="c03f813195e7a80e3608d0ddd8da80b21696a4c92a6a2298865bf149071551c7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="httpclient-4.5.6.pom">
+            <sha256 value="7efc1241e73e7fbb268bfd33242d11ebd3ca07061d7d85f2962dc32a0f0b8855" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcomponents-client" version="4.5.14">
+         <artifact name="httpcomponents-client-4.5.14.pom">
+            <sha256 value="5bad1de4f101447659f89d089868ccbad64a68cc503d2d65410b51f6904aa061" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcomponents-client" version="4.5.6">
+         <artifact name="httpcomponents-client-4.5.6.pom">
+            <sha256 value="b042b41f2391edb00d35f7f4e509aed2123648c1d246ce58d0f7b905c9fe1f73" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcomponents-core" version="4.4.16">
+         <artifact name="httpcomponents-core-4.4.16.pom">
+            <sha256 value="f2d75a2c2d423ad18539bf21656d56f88a4091944a662fcaf159d5ae283db7f7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcomponents-parent" version="10">
+         <artifact name="httpcomponents-parent-10.pom">
+            <sha256 value="caaf967d94afb21753f36082c6086206bd1f48825ff596932cceba72b65d39fa" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcomponents-parent" version="11">
+         <artifact name="httpcomponents-parent-11.pom">
+            <sha256 value="a901f87b115c55070c7ee43efff63e20e7b02d30af2443ae292bf1f4e532d3aa" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpcore" version="4.4.16">
+         <artifact name="httpcore-4.4.16.jar">
+            <sha256 value="6c9b3dd142a09dc468e23ad39aad6f75a0f2b85125104469f026e52a474e464f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="httpcore-4.4.16.pom">
+            <sha256 value="3cbad849b35dacfe6cec31adada2c623c026c3261141b0d26eec7e399c6cd7fa" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.apache.httpcomponents" name="httpmime" version="4.5.6">
+         <artifact name="httpmime-4.5.6.jar">
+            <sha256 value="0b2b1102c18d3c7e05a77214b9b7501a6f6056174ae5604e0e256776eda7553e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="httpmime-4.5.6.pom">
+            <sha256 value="dfbfd6ffe2a784ca9817c46365aa7f8a578320b805bde39d6f55a0b09d8aa8ca" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.bitbucket.b_c" name="jose4j" version="0.9.5">
+         <artifact name="jose4j-0.9.5.jar">
+            <sha256 value="808fb3166f3e67dad9811c331029ab1681242fd52b735bc3f33f281167fcc72e" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jose4j-0.9.5.pom">
+            <sha256 value="bad024180a1b469cbd94e5f2db12841bcac5443d9545607f673cfde677c1d872" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.bouncycastle" name="bcpkix-jdk18on" version="1.79">
+         <artifact name="bcpkix-jdk18on-1.79.jar">
+            <sha256 value="3639a24ddf9ba4b7eba0659b44770e91eba816421888e571f285aadefe532cd6" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="bcpkix-jdk18on-1.79.pom">
+            <sha256 value="35e49f4134de2ac326c3a50a25762cbb4db56f3802fa3f730cc85b653ad0987b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.bouncycastle" name="bcprov-jdk18on" version="1.79">
+         <artifact name="bcprov-jdk18on-1.79.jar">
+            <sha256 value="0d81ecc3124536b539bce9aa3fe9621b7f84c9cee371b635a5b31c78b79ab1da" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="bcprov-jdk18on-1.79.pom">
+            <sha256 value="d8f1a06b149d746e9d98de54e2f7aa9b2eb613fb35ca67d8ae396ceaac661ee4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.bouncycastle" name="bcutil-jdk18on" version="1.79">
+         <artifact name="bcutil-jdk18on-1.79.jar">
+            <sha256 value="c70b88ada58938cbc2f005d40329054078bcfa1149e6ffc03e9242eb6ab21836" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="bcutil-jdk18on-1.79.pom">
+            <sha256 value="e24c1fb4cf1605405a6988e9e4d6e4b2e1f4393fc73a89a9452ae625ee311d02" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.checkerframework" name="checker-compat-qual" version="2.5.5">
+         <artifact name="checker-compat-qual-2.5.5.jar">
+            <sha256 value="11d134b245e9cacc474514d2d66b5b8618f8039a1465cdc55bbc0b34e0008b7a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="checker-compat-qual-2.5.5.pom">
+            <sha256 value="42f21ebd9183be049ee5afc822b345403a5da764037875734a039b0d6e0353be" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.checkerframework" name="checker-qual" version="2.11.1">
+         <artifact name="checker-qual-2.11.1.jar">
+            <sha256 value="015224a4b1dc6de6da053273d4da7d39cfea20e63038169fc45ac0d1dc9c5938" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="checker-qual-2.11.1.pom">
+            <sha256 value="cf2e0c90d8f757455f4a258ea609739053663bd5da6a79d9bd53f935a47de79c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.checkerframework" name="checker-qual" version="2.5.8">
+         <artifact name="checker-qual-2.5.8.pom">
+            <sha256 value="33ac6a0f1341ae96647c7d4465f4aa3d24fe97d2697bcee2ceae6fc8b5ef2c3c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.checkerframework" name="checker-qual" version="3.13.0">
+         <artifact name="checker-qual-3.13.0.jar">
+            <sha256 value="3ea0dcd73b4d6cb2fb34bd7ed4dad6db327a01ebad7db05eb7894076b3d64491" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="checker-qual-3.13.0.module">
+            <sha256 value="19c5c98bf51711bcdbbd6f34d58fe552bfc60f5ca7888baa74eca1b1f7c4c6dc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.checkerframework" name="checker-qual" version="3.33.0">
+         <artifact name="checker-qual-3.33.0.jar">
+            <sha256 value="e316255bbfcd9fe50d165314b85abb2b33cb2a66a93c491db648e498a82c2de1" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="checker-qual-3.33.0.module">
+            <sha256 value="e8521d75625d41272c767d262a153ac163cc505b66644a2ef705fa8949ffb4e5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.groovy" name="groovy" version="3.0.22">
+         <artifact name="groovy-3.0.22.jar">
+            <sha256 value="c92c92c4b9b183f9981ba7399f36592e5e3ad6f4cdac7101b5a22cc17998d13f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="groovy-3.0.22.pom">
+            <sha256 value="51b731e5cff121efd6d320f4a801cd616869c5bed4e9c0e353b29060b1d2355f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.mojo" name="animal-sniffer-annotations" version="1.23">
+         <artifact name="animal-sniffer-annotations-1.23.jar">
+            <sha256 value="9ffe526bf43a6348e9d8b33b9cd6f580a7f5eed0cf055913007eda263de974d0" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="animal-sniffer-annotations-1.23.pom">
+            <sha256 value="5610db06b733641acbc7a0c48a80c40069db627bad043f8c7c8d7afb4f6a3d27" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.mojo" name="animal-sniffer-parent" version="1.23">
+         <artifact name="animal-sniffer-parent-1.23.pom">
+            <sha256 value="6b7f054ab86a87f8e2599f35808b0989922e86b6cab13988021cd12640a4b404" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.mojo" name="mojo-parent" version="74">
+         <artifact name="mojo-parent-74.pom">
+            <sha256 value="1472325a16f0b1bdabed21fa4839372964944610294ce2681b2059edc654f2b3" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.woodstox" name="stax2-api" version="4.2.1">
+         <artifact name="stax2-api-4.2.1.jar">
+            <sha256 value="678567e48b51a42c65c699f266539ad3d676d4b1a5b0ad7d89ece8b9d5772579" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="stax2-api-4.2.1.pom">
+            <sha256 value="79da410c8c0f46a3f8e8adb30d6c24ccd6065b6ef6bfde87bd97e9881ea0a2e7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.codehaus.woodstox" name="stax2-api" version="4.2.2">
+         <artifact name="stax2-api-4.2.2.jar">
+            <sha256 value="a61c48d553efad78bc01fffc4ac528bebbae64cbaec170b2a5e39cf61eb51abe" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="stax2-api-4.2.2.pom">
+            <sha256 value="4e902ec556fc6598b41c2952ec1573edc815037e7330ec4922eab619422686e2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.eclipse.ee4j" name="project" version="1.0.2">
+         <artifact name="project-1.0.2.pom">
+            <sha256 value="7495a07a797e88e43c3bc1a87421bd8b1fc55e32291fa18e4e32d8031ddc873f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.eclipse.ee4j" name="project" version="1.0.5">
+         <artifact name="project-1.0.5.pom">
+            <sha256 value="916b4794d8d8220a59a3fdf6a64dbe794aeb23395e888b81ae36a9b5a2c591a6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.glassfish.jaxb" name="jaxb-bom" version="2.3.2">
+         <artifact name="jaxb-bom-2.3.2.pom">
+            <sha256 value="a1018bb54678ed9f5acb2f7a4084e385ff510201f4e9dbf5f75dc6a675f66be7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.glassfish.jaxb" name="jaxb-runtime" version="2.3.2">
+         <artifact name="jaxb-runtime-2.3.2.jar">
+            <sha256 value="e6e0a1e89fb6ff786279e6a0082d5cef52dc2ebe67053d041800737652b4fd1b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jaxb-runtime-2.3.2.pom">
+            <sha256 value="9448a5ad7fa68a6083dfbe4f42c8c83e082b9202a105401fc68e944c26548b34" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.glassfish.jaxb" name="txw2" version="2.3.2">
+         <artifact name="txw2-2.3.2.jar">
+            <sha256 value="4a6a9f483388d461b81aa9a28c685b8b74c0597993bf1884b04eddbca95f48fe" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="txw2-2.3.2.pom">
+            <sha256 value="a79dd002fb038183ff286a2635be2e68c103b87e0e64717d8d44bfd017fd33ea" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.hamcrest" name="hamcrest-core" version="1.3">
+         <artifact name="hamcrest-core-1.3.jar">
+            <sha256 value="66fdef91e9739348df7a096aa384a5685f4e875584cce89386a7a47251c4d8e9" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="hamcrest-core-1.3.pom">
+            <sha256 value="fde386a7905173a1b103de6ab820727584b50d0e32282e2797787c20a64ffa93" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.hamcrest" name="hamcrest-parent" version="1.3">
+         <artifact name="hamcrest-parent-1.3.pom">
+            <sha256 value="6d535f94efb663bdb682c9f27a50335394688009642ba7a9677504bc1be4129b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jdom" name="jdom2" version="2.0.6">
+         <artifact name="jdom2-2.0.6.jar">
+            <sha256 value="1345f11ba606d15603d6740551a8c21947c0215640770ec67271fe78bea97cf5" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="jdom2-2.0.6.pom">
+            <sha256 value="47b23a79fe336b741b82434c6e049d68165256e405e75c10921fd72fa8a65d8d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains" name="annotations" version="13.0">
+         <artifact name="annotations-13.0.jar">
+            <sha256 value="ace2a10dc8e2d5fd34925ecac03e4988b2c0f851650c94b8cef49ba1bd111478" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="annotations-13.0.pom">
+            <sha256 value="965aeb2bedff369819bdde1bf7a0b3b89b8247dd69c88b86375d76163bb8c397" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains" name="annotations" version="23.0.0">
+         <artifact name="annotations-23.0.0.jar">
+            <sha256 value="7b0f19724082cbfcbc66e5abea2b9bc92cf08a1ea11e191933ed43801eb3cd05" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="annotations-23.0.0.pom">
+            <sha256 value="c9490f655132328df2cfbcfdf743f53fc3916d6c1d10437175a6ca6e3a67771c" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.intellij.deps" name="trove4j" version="1.0.20181211">
+         <artifact name="trove4j-1.0.20181211.jar">
+            <sha256 value="affb7c85a3c87bdcf69ff1dbb84de11f63dc931293934bc08cd7ab18de083601" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="trove4j-1.0.20181211.pom">
+            <sha256 value="310a6aa2d90534c32b8f46f1fc98cd0edae95dcdfca23e2847e5efa9ae0c019a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.intellij.deps" name="trove4j" version="1.0.20200330">
+         <artifact name="trove4j-1.0.20200330.jar">
+            <sha256 value="c5fd725bffab51846bf3c77db1383c60aaaebfe1b7fe2f00d23fe1b7df0a439d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="trove4j-1.0.20200330.pom">
+            <sha256 value="87721cbaa65a3c97d8b1ba9d207840f164c9fe38759fc9ea10ffe26565f8d3e9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-build-common" version="2.1.0">
+         <artifact name="kotlin-build-common-2.1.0.jar">
+            <sha256 value="3a5d34e8b1ed8b80ee22d54488c2a425cf7b685481916d726ffb9994088d2cb9" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-build-common-2.1.0.pom">
+            <sha256 value="0e35c2444d46014dfade076016b787c9d533f9858109df1e4ce67ced4d1a96c3" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-build-statistics" version="2.1.0">
+         <artifact name="kotlin-build-statistics-2.1.0.jar">
+            <sha256 value="32bc03764535ddbc2db1f98836579af6b631c8bea62071864ab02145f2769fbb" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-build-statistics-2.1.0.pom">
+            <sha256 value="2c8c6ac4cf534eacaba9ff5ed3fa45d8029d3a31b211e9e002dfce79fc7a21ca" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-build-tools-api" version="2.1.0">
+         <artifact name="kotlin-build-tools-api-2.1.0.jar">
+            <sha256 value="f145b814f9c01328c2c369a6b8fc77434cac02a7d68f0e05d0dd4cada78bbac7" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-build-tools-api-2.1.0.pom">
+            <sha256 value="e3cfc8da8ddf3bbd3f0ca07183a51feb4893e8bcb8fee801f4b8ce05ef9443a9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-build-tools-impl" version="2.1.0">
+         <artifact name="kotlin-build-tools-impl-2.1.0.jar">
+            <sha256 value="958827bc3711fc3c3491fc77f367a999ad558352b1a2b32d18f5916cce15ed39" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-build-tools-impl-2.1.0.pom">
+            <sha256 value="58ee953420c53e1ea3ab896aaef9964960b444ca8e0a07f76e951e05c62102f9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-compiler-embeddable" version="1.6.10">
+         <artifact name="kotlin-compiler-embeddable-1.6.10.jar">
+            <sha256 value="a4a3096b6159659245be113960a6883863c43f3a53926f38c16b8c5c5993b49d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-compiler-embeddable-1.6.10.pom">
+            <sha256 value="9b76dcc343bbfb22b4146803f128e79428ed565c00710cd9f526654f485b6c6b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-compiler-embeddable" version="2.1.0">
+         <artifact name="kotlin-compiler-embeddable-2.1.0.jar">
+            <sha256 value="c1b139a6f251c3b99e92befa326cb75d93a001d74c3ac601155a8cdb0d253783" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-compiler-embeddable-2.1.0.pom">
+            <sha256 value="0044fa45046fba7ca808d98f9895f25b16510edb53c1e282107db006d126d67f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-compiler-runner" version="2.1.0">
+         <artifact name="kotlin-compiler-runner-2.1.0.jar">
+            <sha256 value="915872c85112df5bc08ec25a1af5d86a2d3f82b1d845310eee62be5508c13497" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-compiler-runner-2.1.0.pom">
+            <sha256 value="13ad1bfcea4778db8336d30bd8edf02239354475f2c4d3289ddffb5a183205d5" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-daemon-client" version="2.1.0">
+         <artifact name="kotlin-daemon-client-2.1.0.jar">
+            <sha256 value="1751dabfcd76b58f878b90df6a602241ec4e4cd6fed60e2d5c2201c5068451e3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-daemon-client-2.1.0.pom">
+            <sha256 value="43aebe513576d51f48129cd85c860d0813de6a1cc7591aca7c28e5432cf8df1b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-daemon-embeddable" version="1.6.10">
+         <artifact name="kotlin-daemon-embeddable-1.6.10.jar">
+            <sha256 value="d727708eefddfde89b1a4f7416eaf65287d123cfee6b6ed37ec8526cc6f3b548" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-daemon-embeddable-1.6.10.pom">
+            <sha256 value="f09a1d2b53c0853c5c2ad3298e7956810833b3776045d5d5e5707e9ff57d90d7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-daemon-embeddable" version="2.1.0">
+         <artifact name="kotlin-daemon-embeddable-2.1.0.jar">
+            <sha256 value="6aa581bd53c3500e380e4bb6b2407f6d233910012f425349c2ed5a8ddbe29eac" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-daemon-embeddable-2.1.0.pom">
+            <sha256 value="c85b7aec38f0a3e53cd221265d08233d9ab1f0600902b7d3d74754def84abf18" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-2.1.0-gradle85.jar">
+            <sha256 value="caafc71157634bf7864f44026f5a63d256881c1cd9711456325266a53bafe728" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-2.1.0.module">
+            <sha256 value="0a846b51225d2a0443f005316cbb1318591f5855ae6e955f7860c25bee9d2b17" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin-annotations" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-annotations-2.1.0.jar">
+            <sha256 value="d53e97f0e13a37d8fa98fb44cd67e45d3bcf8b4278fdbe1acd1ddbccc740f74b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-annotations-2.1.0.pom">
+            <sha256 value="6c1ca8596963f1cd12951aee50e34c47b3c0a58893d20f138240f5786c68e4bf" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin-api" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-api-2.1.0.jar">
+            <sha256 value="bf03d64ecffcb66d73fea0991768dd75cbeb1192d47c7a48b61ba7f7ca258858" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-api-2.1.0.module">
+            <sha256 value="9ad196cf9a5c7d8840ad974d697a3af94990ecf16df681e755a90bf42a3ea410" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin-idea" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-idea-2.1.0.jar">
+            <sha256 value="1a7e8d40f5498649e7b1995e87bd73504875254ad9cad093b86b81347e80151c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-idea-2.1.0.module">
+            <sha256 value="cb206888b337cc56acba00bded11942b03b463333fedf25cccd741ef73a8c3e9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin-idea-proto" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-idea-proto-2.1.0.jar">
+            <sha256 value="96d0c169ae7e8191935f748146b9f64a1f6f25d121941e29714faaab089da910" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-idea-proto-2.1.0.pom">
+            <sha256 value="0ec74e3cc7c7a20ca4d8860f9d2cd965670ec419b389ead09d712c81d1bc6047" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugin-model" version="2.1.0">
+         <artifact name="kotlin-gradle-plugin-model-2.1.0.jar">
+            <sha256 value="306832bc994a061f3bf3f1be592b23945057080499e7dc33c52cb69e33d19164" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugin-model-2.1.0.module">
+            <sha256 value="fdb78fa159a111bf9cd0c08023b728c77aebddcb95cfdc505f926a9218adc6a1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-gradle-plugins-bom" version="2.1.0">
+         <artifact name="kotlin-gradle-plugins-bom-2.1.0.module">
+            <sha256 value="a81bd9adbd3ba75a05a6c3a3ed846e0c92a5a7ac4ce8363cf604b4f2c8a7b75c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-gradle-plugins-bom-2.1.0.pom">
+            <sha256 value="9216b199d987cab680450aac715caa57571f8a67800e36e37026f8f453c1feb1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-klib-commonizer-api" version="2.1.0">
+         <artifact name="kotlin-klib-commonizer-api-2.1.0.jar">
+            <sha256 value="05fcb427938d6e2379a8430bb6613ab2fe2089d057e064530e7225b864cf9e37" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-klib-commonizer-api-2.1.0.pom">
+            <sha256 value="6ee261b9393ccd649ef39efea73bef2e98e46caed5622008dedd769e4cd877eb" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-klib-commonizer-embeddable" version="2.1.0">
+         <artifact name="kotlin-klib-commonizer-embeddable-2.1.0.jar">
+            <sha256 value="d937f731886937ba369a46b2263294cf1170989d3321d07153c91d9cb86a99d9" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-klib-commonizer-embeddable-2.1.0.pom">
+            <sha256 value="67ec3e97100b876dd2b805c9d30fd96d000e56661979a976c483d20a900f29bd" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-native-utils" version="2.1.0">
+         <artifact name="kotlin-native-utils-2.1.0.jar">
+            <sha256 value="c4396feba6d0a24ab717426b36418e945b7cd0f50d77c866524f26676f968439" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-native-utils-2.1.0.pom">
+            <sha256 value="e8d410f736cfaca2fb277b98e4a2796f0e544e1e096a004385c7befce531ee01" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-reflect" version="1.6.10">
+         <artifact name="kotlin-reflect-1.6.10.jar">
+            <sha256 value="3277ac102ae17aad10a55abec75ff5696c8d109790396434b496e75087854203" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-reflect-1.6.10.pom">
+            <sha256 value="57905524274a00ae028aaccc27283f6bc5925a934a046c1cc5d06c8ee4d6d5a9" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-reflect" version="2.1.0-RC">
+         <artifact name="kotlin-reflect-2.1.0-RC.jar">
+            <sha256 value="cc6f27ba154a2e0e7fa9edf4ef9bba141560120a6b4213560dbd87f849b1ab23" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-reflect-2.1.0-RC.pom">
+            <sha256 value="aec0726be9a6732767939ba888d3d3d3f70dcb9eba1b4703c977577385cd15ea" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-script-runtime" version="1.6.10">
+         <artifact name="kotlin-script-runtime-1.6.10.jar">
+            <sha256 value="c123e7bc733e4a08b772704690540c9fd28aed8d85a446477f25c57d4be2a25b" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-script-runtime-1.6.10.pom">
+            <sha256 value="294c59902a88ed10286ca1371894e571c296d0eb4eafddbad08e3083929b8f4e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-script-runtime" version="2.1.0">
+         <artifact name="kotlin-script-runtime-2.1.0.jar">
+            <sha256 value="15a2b82119e9f145ea028029bd31166584648a419157c20948c124fa33d40e50" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-script-runtime-2.1.0.pom">
+            <sha256 value="f3332fc0f5e962f6aefe0a2c08d3c4d7ab35b13a05dac84c4bc6914e26ed27cd" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-scripting-common" version="2.1.0">
+         <artifact name="kotlin-scripting-common-2.1.0.jar">
+            <sha256 value="d3ebe15699ec1a7fb6c3b5fa939eb6b888b3273e6c0597d2c2e3aaa0e46afa45" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-scripting-common-2.1.0.pom">
+            <sha256 value="ab2b23f0cb72ec042c2b808fb18985a7ebe75a65aaa00527969e94325c6c006b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-scripting-compiler-embeddable" version="2.1.0">
+         <artifact name="kotlin-scripting-compiler-embeddable-2.1.0.jar">
+            <sha256 value="b2abc6d959c915af92a289aed14a530eaf09e48613f283da0a4e8d3444340fc3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-scripting-compiler-embeddable-2.1.0.pom">
+            <sha256 value="cbfaecdb0693983ab5b6aeab5e70813969f99a239c731c46f8f7404c055d7227" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-scripting-compiler-impl-embeddable" version="2.1.0">
+         <artifact name="kotlin-scripting-compiler-impl-embeddable-2.1.0.jar">
+            <sha256 value="8a900406012ba5eda8925856253f72235451db387f0ce50ed31d655c9e5c66d6" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-scripting-compiler-impl-embeddable-2.1.0.pom">
+            <sha256 value="8b549ab2aadab49d369bfe8f1806f71ff98ffafa1570672ad8f7a8b01b236c7b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-scripting-jvm" version="2.1.0">
+         <artifact name="kotlin-scripting-jvm-2.1.0.jar">
+            <sha256 value="c5a21b6d07ef677970b328f9ebff115282285e62c85fa1866e84e4d7be3a44a3" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-scripting-jvm-2.1.0.pom">
+            <sha256 value="f0dd3c1c8a8b1dc258b566668a2dbd777ed9ad48ccafa60ec1752480b54d347a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib" version="1.6.10">
+         <artifact name="kotlin-stdlib-1.6.10.jar">
+            <sha256 value="5305f7a4dee7a6cb79a29c258aca93de47b49588a6dfc6da01bd8772589ea66c" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-1.6.10.pom">
+            <sha256 value="3b08709ea4bae3669d9a29b9e007a8550b10c1516c10a8f6dbe9f94ab81dc46d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib" version="2.1.0">
+         <artifact name="kotlin-stdlib-2.1.0-all.jar">
+            <sha256 value="a7412f66d71bcd2721c398307972fbb5f9409f945643eee05d1080b289a339cb" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-2.1.0.jar">
+            <sha256 value="d6f91b7b0f306cca299fec74fb7c34e4874d6f5ec5b925a0b4de21901e119c3f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-2.1.0.module">
+            <sha256 value="dcfbc8e8bf32cd67a7efadd91d31152bce9870911d6ec50878f4fdb6e03e70e2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib" version="2.1.0-RC">
+         <artifact name="kotlin-stdlib-2.1.0-RC.jar">
+            <sha256 value="6df179971554288feac56f590e06902e4c78c91dd688aecd28dbc09493ebdc01" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-2.1.0-RC.module">
+            <sha256 value="b641932ae09e3b760d35d5f4f7ff4dd40ab183b31ac249a284022bd33ffde780" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-common" version="1.6.10">
+         <artifact name="kotlin-stdlib-common-1.6.10.jar">
+            <sha256 value="280ddd0994e4560c9a49ee81c1b047ddc2b8f2176159475066025b474b37effd" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-common-1.6.10.pom">
+            <sha256 value="f75af217cdd8dd9e07b1e0e018084a32092a091a390b73feaa657ec44e5cf094" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-common" version="1.8.22">
+         <artifact name="kotlin-stdlib-common-1.8.22.pom">
+            <sha256 value="a72b11df08b5322d7a5e8e620789ee3e4cfef38e86c430e7d113bfa9e54c581e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-common" version="2.1.0">
+         <artifact name="kotlin-stdlib-common-2.1.0.module">
+            <sha256 value="2b9a5ae785f8513a93f8cec3f6e5e07f8b1766f8497b3a487f3441a251d67563" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-jdk7" version="1.6.10">
+         <artifact name="kotlin-stdlib-jdk7-1.6.10.jar">
+            <sha256 value="2aedcdc6b69b33bdf5cc235bcea88e7cf6601146bb6bcdffdb312bbacd7be261" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-jdk7-1.6.10.pom">
+            <sha256 value="612211ff930f5b52c724ff763417d5aa281dd7e0325c3b35c8d18120a6a8df4d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-jdk7" version="2.1.0-RC">
+         <artifact name="kotlin-stdlib-jdk7-2.1.0-RC.jar">
+            <sha256 value="a16b473e6c1064b28b92192cc5ff0ced7bb7f853cb0b35e56681284cb5618cde" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-jdk7-2.1.0-RC.pom">
+            <sha256 value="fe42afa20000e793b49dd12522134e82658671c040c025c873303fd458dad779" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-jdk8" version="1.8.22">
+         <artifact name="kotlin-stdlib-jdk8-1.8.22.pom">
+            <sha256 value="928f2187217476313cb816d48070bc7654aa3b9a5ae81d3fc5f8c279cc8f8d9e" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-stdlib-jdk8" version="2.1.0-RC">
+         <artifact name="kotlin-stdlib-jdk8-2.1.0-RC.jar">
+            <sha256 value="acf8d8303c1138a0fc69e36f8a75d164aaecf7e881aeeadca25e7e9a33c5f2ff" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-stdlib-jdk8-2.1.0-RC.pom">
+            <sha256 value="03ff0a0fb13de2586d1365b5f34c9d4605deed3e0edca5dfe35c9974ec969d6a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-test" version="1.6.10">
+         <artifact name="kotlin-test-1.6.10.jar">
+            <sha256 value="b891453cafbf961532d2ba0fb8969e40b0f7c168c9a2fc6a8cdf7c1b0577a36a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-test-1.6.10.module">
+            <sha256 value="0408c2443d253dc0836517a84d81e788adc8dbcb6024af3f4629ce70a2ff632b" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-test" version="2.1.0">
+         <artifact name="kotlin-test-2.1.0-all.jar">
+            <sha256 value="ba813d25e9ebe67d750b98920694ad42bf9a80c12e6d25066d1c8e974ad89656" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-test-2.1.0.jar">
+            <sha256 value="6f9818fa182de3c68d19418997a7d5d9f4d7dc10be7ff203dec80e3a3d6238e6" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-test-2.1.0.module">
+            <sha256 value="f6e3ef22058e1bfa7d6fe42a352ec7449e8c6bb885812f571495b095a0b72176" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-test-junit" version="2.1.0">
+         <artifact name="kotlin-test-junit-2.1.0.jar">
+            <sha256 value="4fed5ed01c6ff2fad07a517b986938db5eeb8891a363609077a5257662fbcca5" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-test-junit-2.1.0.module">
+            <sha256 value="b44c2639a826c721026cf89b8a5082f535457d81f389949829681847a8cf793f" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-tooling-core" version="2.1.0">
+         <artifact name="kotlin-tooling-core-2.1.0.jar">
+            <sha256 value="4176c612098cb92df38a485ff8b10aaa24abb400f610d48f5088aeb07c8002c8" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-tooling-core-2.1.0.pom">
+            <sha256 value="a5a4e9f54a413cdb2c1d140c349b559f684b0da8b0216a0a5645206f3fc581af" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-util-io" version="2.1.0">
+         <artifact name="kotlin-util-io-2.1.0.jar">
+            <sha256 value="001a50db3da0a89a954db615fcb0e3f4a81a5341d407060ea88c9356f10f23e1" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-util-io-2.1.0.pom">
+            <sha256 value="ec557203d9248a3701e1665a256cf1e91691733d95fdf2f18f39e8a8ec93c7a1" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-util-klib" version="2.1.0">
+         <artifact name="kotlin-util-klib-2.1.0.jar">
+            <sha256 value="6260a30e876a162d8268faaff6aa2d451e7bba008a03522075792a4e71a61c29" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-util-klib-2.1.0.pom">
+            <sha256 value="9ebfbbc73137f4d19883df909255adbfc6d13d8fa7ec9ef47066a3b688c96cdc" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin" name="kotlin-util-klib-metadata" version="2.1.0">
+         <artifact name="kotlin-util-klib-metadata-2.1.0.jar">
+            <sha256 value="1a8a58974132dbf08193336a45c9350749a1af489667a199da3ebb3a8849907d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlin-util-klib-metadata-2.1.0.pom">
+            <sha256 value="e329322576dc1ca8cbe20a3afe4fd1f5724da3b95349b5538cd03b184ff971c2" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlin.jvm" name="org.jetbrains.kotlin.jvm.gradle.plugin" version="2.1.0">
+         <artifact name="org.jetbrains.kotlin.jvm.gradle.plugin-2.1.0.pom">
+            <sha256 value="1a6305413e11172f2471cffdad970758b798eb173185c324ce1702b4e645f927" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jetbrains.kotlinx" name="kotlinx-coroutines-core-jvm" version="1.6.4">
+         <artifact name="kotlinx-coroutines-core-jvm-1.6.4.jar">
+            <sha256 value="c24c8bb27bb320c4a93871501a7e5e0c61607638907b197aef675513d4c820be" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="kotlinx-coroutines-core-jvm-1.6.4.module">
+            <sha256 value="0d94c8a41483e7c2707ebd693e1b1357a84152998ce85550ebbc54ca4321a3a7" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.junit" name="junit-bom" version="5.10.2">
+         <artifact name="junit-bom-5.10.2.pom">
+            <sha256 value="169dd904a4b0f6520cffe658cc62292bfe9f3c14a989fa92120724cde43a9968" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.junit" name="junit-bom" version="5.9.2">
+         <artifact name="junit-bom-5.9.2.pom">
+            <sha256 value="2ed07d65845131f5336a86476c9a4056b59d0b58b9815ab3679bb0f36f35f705" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.jvnet.staxex" name="stax-ex" version="1.8.1">
+         <artifact name="stax-ex-1.8.1.jar">
+            <sha256 value="20522549056e9e50aa35ef0b445a2e47a53d06be0b0a9467d704e2483ffb049a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="stax-ex-1.8.1.pom">
+            <sha256 value="8fc84f36ce6da6ce8c893b6538199a7f69a69a0706d9b17a3ee6a3a09452eed6" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2" name="ow2" version="1.5">
+         <artifact name="ow2-1.5.pom">
+            <sha256 value="0f8a1b116e760b8fe6389c51b84e4b07a70fc11082d4f936e453b583dd50b43b" origin="Generated by Gradle" reason="Artifact is not signed"/>
+         </artifact>
+      </component>
+      <component group="org.ow2" name="ow2" version="1.5.1">
+         <artifact name="ow2-1.5.1.pom">
+            <sha256 value="321ddbb7ee6fe4f53dea6b4cd6db74154d6bfa42391c1f763b361b9f485acf05" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm" version="8.0">
+         <artifact name="asm-8.0.pom">
+            <sha256 value="a37609f34acb2e01de591b33e3cd2725e4bb8e1cdfd7968c956efdab362643c0" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm" version="9.1">
+         <artifact name="asm-9.1.jar">
+            <sha256 value="cda4de455fab48ff0bcb7c48b4639447d4de859a7afc30a094a986f0936beba2" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-9.1.pom">
+            <sha256 value="c683a90dd68f2b1788cbdfc4647ea9405ef5925b371c199f8fd39d44d3cede8d" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm" version="9.7">
+         <artifact name="asm-9.7.jar">
+            <sha256 value="adf46d5e34940bdf148ecdd26a9ee8eea94496a72034ff7141066b3eea5c4e9d" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-9.7.pom">
+            <sha256 value="de00115f1d84f3a0b2ee3a4b6f6192d066f86d185d67b9d1522f2c80feac5f00" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm-analysis" version="9.7">
+         <artifact name="asm-analysis-9.7.jar">
+            <sha256 value="7bc6bcbc21379948a0c8c467fb0f864206e5b818f6bc0b546872f5c9f941556f" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-analysis-9.7.pom">
+            <sha256 value="9c33080ebcb631ae4f77eb62ed67bfc40cb872e8cfd058ac863e445c1dd973df" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm-commons" version="9.7">
+         <artifact name="asm-commons-9.7.jar">
+            <sha256 value="389bc247958e049fc9a0408d398c92c6d370c18035120395d4cba1d9d9304b7a" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-commons-9.7.pom">
+            <sha256 value="5acee3ee7252ed90b8074c755d022787499a95fafff98ac4a685107c4da409b4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm-tree" version="8.0">
+         <artifact name="asm-tree-8.0.pom">
+            <sha256 value="54b0fb2b4bff0e01a45aa6d293205a688d9b123582f84d657492ee18b21f31a4" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm-tree" version="9.7">
+         <artifact name="asm-tree-9.7.jar">
+            <sha256 value="62f4b3bc436045c1acb5c3ba2d8ec556ec3369093d7f5d06c747eb04b56d52b1" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-tree-9.7.pom">
+            <sha256 value="a34ea1e3e4128c01038db43c6976e88c779cf5af84b0505da266dfe6965668ec" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.ow2.asm" name="asm-util" version="9.7">
+         <artifact name="asm-util-9.7.jar">
+            <sha256 value="37a6414d36641973f1af104937c95d6d921b2ddb4d612c66c5a9f2b13fc14211" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="asm-util-9.7.pom">
+            <sha256 value="5d014d8c870d4871825bd2ddb5567b21ef6dac8ec48bbb8dbb465b0b3a2bf452" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.slf4j" name="slf4j-api" version="1.7.30">
+         <artifact name="slf4j-api-1.7.30.jar">
+            <sha256 value="cdba07964d1bb40a0761485c6b1e8c2f8fd9eb1d19c53928ac0d7f9510105c57" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="slf4j-api-1.7.30.pom">
+            <sha256 value="7e0747751e9b67e19dcb5206f04ea22cc03d250c422426402eadd03513f2c314" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.slf4j" name="slf4j-parent" version="1.7.30">
+         <artifact name="slf4j-parent-1.7.30.pom">
+            <sha256 value="11647956e48a0c5bfb3ac33f6da7e83f341002b6857efd335a505b687be34b75" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.sonatype.oss" name="oss-parent" version="7">
+         <artifact name="oss-parent-7.pom">
+            <sha256 value="b51f8867c92b6a722499557fc3a1fdea77bdf9ef574722fe90ce436a29559454" origin="Generated by Gradle" reason="Artifact is not signed"/>
+         </artifact>
+      </component>
+      <component group="org.sonatype.oss" name="oss-parent" version="9">
+         <artifact name="oss-parent-9.pom">
+            <sha256 value="fb40265f982548212ff82e362e59732b2187ec6f0d80182885c14ef1f982827a" origin="Generated by Gradle"/>
+         </artifact>
+      </component>
+      <component group="org.tensorflow" name="tensorflow-lite-metadata" version="0.1.0-rc2">
+         <artifact name="tensorflow-lite-metadata-0.1.0-rc2.jar">
+            <sha256 value="2c2a264f842498c36d34d2a7b91342490d9a962862c85baac1acd54ec2fca6d9" origin="Generated by Gradle"/>
+         </artifact>
+         <artifact name="tensorflow-lite-metadata-0.1.0-rc2.pom">
+            <sha256 value="9a4f5e5674366c156c90391662f03ed7c5971d6aa63832df74a271da6ff82e96" origin="Generated by Gradle"/>
          </artifact>
       </component>
    </components>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index b8d661d2f..0af0eb668 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,7 +1,7 @@
 #Tue May 30 13:39:24 PDT 2023
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
-distributionSha256Sum=5b9c5eb3f9fc2c94abaea57d90bd78747ca117ddbbf96c859d3741181a12bf2a
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-bin.zip
+distributionSha256Sum=7a00d51fb93147819aab76024feece20b6b84e420694101f276be952e08bef03
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/metalava-model-psi/Android.bp b/metalava-model-psi/Android.bp
index df60703e2..d8aaa6a3e 100644
--- a/metalava-model-psi/Android.bp
+++ b/metalava-model-psi/Android.bp
@@ -23,6 +23,7 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     java_resource_dirs: ["src/main/resources/"],
     libs: [
         "metalava-model",
diff --git a/metalava-model-psi/lint-baseline.xml b/metalava-model-psi/lint-baseline.xml
index b15e4556f..2f7e37a4b 100644
--- a/metalava-model-psi/lint-baseline.xml
+++ b/metalava-model-psi/lint-baseline.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<issues format="6" by="lint 8.4.0-alpha07" type="baseline" client="gradle" dependencies="false" name="AGP (8.4.0-alpha07)" variant="all" version="8.4.0-alpha07">
+<issues format="6" by="lint 8.9.0-alpha04" type="baseline" client="gradle" dependencies="false" name="AGP (8.9.0-alpha04)" variant="all" version="8.9.0-alpha04">
 
     <issue
         id="UastImplementation"
@@ -8,7 +8,7 @@
         errorLine2="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
         <location
             file="src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt"
-            line="43"
+            line="45"
             column="1"/>
     </issue>
 
@@ -19,7 +19,7 @@
         errorLine2="                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
         <location
             file="src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt"
-            line="300"
+            line="181"
             column="34"/>
     </issue>
 
@@ -30,10 +30,21 @@
         errorLine2="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
         <location
             file="src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt"
-            line="93"
+            line="98"
             column="1"/>
     </issue>
 
+    <issue
+        id="UastImplementation"
+        message="org.jetbrains.uast.kotlin.KotlinUMethodWithFakeLightDelegateBase is UAST implementation. Consider using one of its corresponding UAST interfaces: `UMethod`, `UDeclaration`, `UAnnotated`, `UAnchorOwner`"
+        errorLine1="                element is KotlinUMethodWithFakeLightDelegateBase&lt;*> &amp;&amp; sourcePsi is KtDeclaration"
+        errorLine2="                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
+        <location
+            file="src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt"
+            line="264"
+            column="28"/>
+    </issue>
+
     <issue
         id="UastImplementation"
         message="org.jetbrains.uast.kotlin.KotlinUMethodWithFakeLightDelegateBase is UAST implementation. Consider using one of its corresponding UAST interfaces: `UMethod`, `UDeclaration`, `UAnnotated`, `UAnchorOwner`"
@@ -41,7 +52,7 @@
         errorLine2="                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
         <location
             file="src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt"
-            line="253"
+            line="309"
             column="28"/>
     </issue>
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
index c84ed3982..41c9c9d09 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
@@ -32,6 +32,7 @@ import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
+import org.jetbrains.kotlin.psi.KtTypeAlias
 import org.jetbrains.kotlin.psi.KtTypeReference
 import org.jetbrains.kotlin.psi.psiUtil.hasSuspendModifier
 import org.jetbrains.uast.UElement
@@ -97,6 +98,11 @@ private constructor(
         }
     }
 
+    /** Checks whether the [kaType] is a value class type. */
+    fun isValueClassType(): Boolean {
+        return kaType?.let { analysisSession?.typeForValueClass(it) } ?: false
+    }
+
     /**
      * Creates [KotlinTypeInfo] for the component type of this [kaType], assuming it is an array.
      */
@@ -233,6 +239,11 @@ private constructor(
                         }
                     }
                 }
+                is KtTypeAlias -> {
+                    analyze(ktElement) {
+                        KotlinTypeInfo(this, ktElement.getTypeReference()?.type, ktElement)
+                    }
+                }
                 else -> null
             }
 
@@ -355,5 +366,12 @@ private constructor(
                 // non-null upper bound, e.g., T : Any
                 ktType.canBeNull
         }
+
+        // Mimic `typeForValueClass` in
+        // `org.jetbrains.kotlin.light.classes.symbol.classes.symbolLightClassUtils.kt`
+        private fun KaSession.typeForValueClass(type: KaType): Boolean {
+            val symbol = type.expandedSymbol as? KaNamedClassSymbol ?: return false
+            return symbol.isInline
+        }
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
index c929a59d7..f01554e85 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
@@ -40,29 +40,35 @@ import com.intellij.psi.PsiClassObjectAccessExpression
 import com.intellij.psi.PsiExpression
 import com.intellij.psi.PsiField
 import com.intellij.psi.PsiLiteral
-import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiReference
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
 import org.jetbrains.kotlin.asJava.elements.KtLightNullabilityAnnotation
 
 internal class PsiAnnotationItem
 private constructor(
-    override val codebase: PsiBasedCodebase,
+    override val annotationContext: PsiBasedCodebase,
     val psiAnnotation: PsiAnnotation,
     originalName: String,
     qualifiedName: String,
 ) :
     DefaultAnnotationItem(
-        codebase = codebase,
+        annotationContext = annotationContext,
         fileLocation = PsiFileLocation.fromPsiElement(psiAnnotation),
         originalName = originalName,
         qualifiedName = qualifiedName,
-        attributesGetter = { getAnnotationAttributes(codebase, psiAnnotation) },
+        attributesGetter = { getAnnotationAttributes(annotationContext, psiAnnotation) },
     ) {
 
     override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
         val sb = StringBuilder(60)
-        appendAnnotation(codebase, sb, psiAnnotation, qualifiedName, target, showDefaultAttrs)
+        appendAnnotation(
+            annotationContext,
+            sb,
+            psiAnnotation,
+            qualifiedName,
+            target,
+            showDefaultAttrs
+        )
         return sb.toString()
     }
 
@@ -96,11 +102,18 @@ private constructor(
             codebase: PsiBasedCodebase,
             psiAnnotation: PsiAnnotation,
         ): AnnotationItem? {
-            val originalName = psiAnnotation.qualifiedName ?: return null
+            // If the qualified name is a typealias, convert it to the aliased type because that is
+            // the version that will be present as a class in the codebase.
+            val originalName =
+                psiAnnotation.qualifiedName?.let {
+                    (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName
+                        ?: it
+                }
+                    ?: return null
             val qualifiedName =
                 codebase.annotationManager.normalizeInputName(originalName) ?: return null
             return PsiAnnotationItem(
-                codebase = codebase,
+                annotationContext = codebase,
                 psiAnnotation = psiAnnotation,
                 originalName = originalName,
                 qualifiedName = qualifiedName,
@@ -356,7 +369,6 @@ internal class PsiAnnotationSingleAttributeValue(
             when (val resolved = psiValue.resolve()) {
                 is PsiField -> return codebase.findField(resolved)
                 is PsiClass -> return codebase.findOrCreateClass(resolved)
-                is PsiMethod -> return codebase.findCallableByPsiMethod(resolved)
             }
         }
         return null
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
index d62964487..2cbdcb97e 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
@@ -49,6 +49,7 @@ internal class PsiBasedClassResolver(
                     fromClasspath = true,
                     allowReadingComments = allowReadingComments,
                     assembler = assembler,
+                    isMultiplatform = uastEnvironment.isKMP,
                 )
             }
         assembler.initializeFromSources(SourceSet.empty(), apiPackages = null)
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
index ff7b501e0..c673dfde2 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
@@ -51,6 +51,7 @@ internal class PsiBasedCodebase(
     val allowReadingComments: Boolean,
     val fromClasspath: Boolean = false,
     assembler: PsiCodebaseAssembler,
+    val isMultiplatform: Boolean,
 ) :
     DefaultCodebase(
         location = location,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
index 765a3320b..948e578a3 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
@@ -27,7 +27,6 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
 import com.android.tools.metalava.model.MutableModifierList
@@ -89,9 +88,9 @@ import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
+import org.jetbrains.kotlin.psi.KtTypeAlias
 import org.jetbrains.kotlin.psi.KtTypeReference
 import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter
-import org.jetbrains.kotlin.util.collectionUtils.filterIsInstanceAnd
 import org.jetbrains.uast.UClass
 import org.jetbrains.uast.UFile
 import org.jetbrains.uast.UMethod
@@ -315,7 +314,7 @@ internal class PsiCodebaseAssembler(
                         psiMethod,
                         classTypeItemFactory,
                     )
-                addOverloadedKotlinConstructorsIfNecessary(
+                addOverloadedKotlinCallablesIfNecessary(
                     classItem,
                     classTypeItemFactory,
                     constructor
@@ -334,6 +333,7 @@ internal class PsiCodebaseAssembler(
                 val method =
                     PsiMethodItem.create(codebase, classItem, psiMethod, classTypeItemFactory)
                 if (!method.isEnumSyntheticMethod()) {
+                    addOverloadedKotlinCallablesIfNecessary(classItem, classTypeItemFactory, method)
                     classItem.addMethod(method)
                 }
             }
@@ -384,60 +384,66 @@ internal class PsiCodebaseAssembler(
             // Collect all accessor methods, backing fields, and constructor parameters that could
             // be associated with the class properties.
             val accessors =
-                classItem.methods().filterIsInstanceAnd<PsiMethodItem> { it.isKotlinProperty() }
-            // Don't include data class component methods
-            val getters =
-                accessors
-                    .filter { it.parameters().isEmpty() && !it.name().startsWith("component") }
-                    .associateByNotNull { it.psiMethod.propertyForAccessor() }
-            val setters =
-                accessors
-                    .filter { it.parameters().size == 1 }
-                    .associateByNotNull { it.psiMethod.propertyForAccessor() }
+                classItem.methods().filterIsInstance<PsiMethodItem>().groupBy {
+                    it.psiMethod.propertyForAccessor()
+                }
             val backingFields =
                 classItem
                     .fields()
                     .map { it as PsiFieldItem }
                     .associateByNotNull { it.psi().sourceElement as? KtDeclaration }
-            val constructorParameters =
-                classItem.primaryConstructor
-                    ?.parameters()
-                    ?.map { it as PsiParameterItem }
-                    ?.filter { (it.sourcePsi as? KtParameter)?.isPropertyParameter() ?: false }
-                    ?.associateBy { it.name() }
-                    .orEmpty()
 
             // Properties can either be declared directly as properties or as constructor params.
+            // First find all property declarations.
             // For a file facade class containing top-level property definitions, the KtClass won't
-            // exist, so fall back to the properties underlying the getters and fields.
-            val allProperties =
-                if (ktClass != null) {
-                    ktClass.declarations.filterIsInstance<KtProperty>() +
-                        ktClass.primaryConstructor
-                            ?.valueParameters
-                            ?.filter { it.isPropertyParameter() }
-                            .orEmpty()
-                } else {
-                    (getters.keys + backingFields.keys).toSet()
-                }
-
-            for (propertyDeclaration in allProperties) {
-                val name = propertyDeclaration.name ?: continue
+            // exist, so get top level definitions from the file(s).
+            val declarations = ktClass?.declarations ?: topLevelDeclarations(psiClass)
+            val ktProperties = declarations.filterIsInstance<KtProperty>()
+            for (ktProperty in ktProperties) {
                 val property =
                     PsiPropertyItem.create(
                         codebase = codebase,
-                        ktDeclaration = propertyDeclaration,
+                        ktDeclaration = ktProperty,
                         containingClass = classItem,
-                        typeItemFactory = enclosingClassTypeItemFactory,
-                        name = name,
-                        getter = getters[propertyDeclaration],
-                        setter = setters[propertyDeclaration],
-                        constructorParameter = constructorParameters[name],
-                        backingField = backingFields[propertyDeclaration],
+                        containingTypeItemFactory = classTypeItemFactory,
+                        accessors = accessors[ktProperty] ?: emptyList(),
+                        constructorParameter = null,
+                        backingField = backingFields[ktProperty],
                     )
                         ?: continue
                 classItem.addProperty(property)
             }
+
+            // Find all properties declared as constructor params
+            if (ktClass != null) {
+                val constructorParameters =
+                    classItem.primaryConstructor
+                        ?.parameters()
+                        ?.map { it as PsiParameterItem }
+                        ?.filter { (it.sourcePsi as? KtParameter)?.isPropertyParameter() ?: false }
+                        ?.associateBy { it.name() }
+                        .orEmpty()
+
+                val ktParameters =
+                    ktClass.primaryConstructor
+                        ?.valueParameters
+                        ?.filter { it.isPropertyParameter() }
+                        .orEmpty()
+                for (ktParameter in ktParameters) {
+                    val property =
+                        PsiPropertyItem.create(
+                            codebase = codebase,
+                            ktDeclaration = ktParameter,
+                            containingClass = classItem,
+                            containingTypeItemFactory = classTypeItemFactory,
+                            accessors = accessors[ktParameter] ?: emptyList(),
+                            constructorParameter = constructorParameters[ktParameter.name],
+                            backingField = backingFields[ktParameter],
+                        )
+                            ?: continue
+                    classItem.addProperty(property)
+                }
+            }
         }
         // This actually gets all nested classes not just inner, i.e. non-static nested,
         // classes.
@@ -580,14 +586,13 @@ internal class PsiCodebaseAssembler(
     }
 
     /**
-     * Returns true if overloads of this constructor should be checked separately when checking the
-     * signature of this constructor.
+     * Returns true if overloads of this callable should be created separately.
      *
      * This works around the issue of actual callable not generating overloads for @JvmOverloads
      * annotation when the default is specified on expect side
      * (https://youtrack.jetbrains.com/issue/KT-57537).
      */
-    private fun PsiConstructorItem.shouldExpandOverloads(): Boolean {
+    private fun PsiCallableItem.shouldExpandOverloads(): Boolean {
         val ktFunction = (psiMethod as? UMethod)?.sourcePsi as? KtFunction ?: return false
         return modifiers.isActual() &&
             psiMethod.hasAnnotation(JvmStandardClassIds.JVM_OVERLOADS_FQ_NAME.asString()) &&
@@ -598,23 +603,23 @@ internal class PsiCodebaseAssembler(
     }
 
     /**
-     * Add overloads of [constructor] if necessary.
+     * Add overloads of [callable] if necessary.
      *
      * Workaround for https://youtrack.jetbrains.com/issue/KT-57537.
      *
-     * For each parameter with a default value in [constructor] this adds a [ConstructorItem] that
+     * For each parameter with a default value in [callable] this adds a [PsiCallableItem] that
      * excludes that parameter and all following parameters with default values.
      */
-    private fun addOverloadedKotlinConstructorsIfNecessary(
+    private fun addOverloadedKotlinCallablesIfNecessary(
         classItem: PsiClassItem,
         enclosingClassTypeItemFactory: PsiTypeItemFactory,
-        constructor: PsiConstructorItem,
+        callable: PsiCallableItem,
     ) {
-        if (!constructor.shouldExpandOverloads()) {
+        if (!callable.shouldExpandOverloads()) {
             return
         }
 
-        val parameters = constructor.parameters()
+        val parameters = callable.parameters()
 
         // Create an overload of the constructor for each parameter that has a default value. The
         // constructor will exclude that parameter and all following parameters that have default
@@ -624,25 +629,40 @@ internal class PsiCodebaseAssembler(
             // There is no need to create an overload if the parameter does not have default value.
             if (!currentParameter.hasDefaultValue()) continue
 
-            // Create an overloaded constructor.
-            val overloadConstructor =
-                PsiConstructorItem.create(
-                    codebase,
-                    classItem,
-                    constructor.psiMethod,
-                    enclosingClassTypeItemFactory,
-                    psiParametersGetter = {
-                        parameters.mapIndexedNotNull { index, parameterItem ->
-                            // Ignore the current parameter as well as any following parameters
-                            // with default values.
-                            if (index >= currentParameterIndex && parameterItem.hasDefaultValue())
-                                null
-                            else (parameterItem as PsiParameterItem).psiParameter
-                        }
-                    },
-                )
-
-            classItem.addConstructor(overloadConstructor)
+            val psiParameters =
+                parameters.mapIndexedNotNull { index, parameterItem ->
+                    // Ignore the current parameter as well as any following parameters
+                    // with default values.
+                    if (index >= currentParameterIndex && parameterItem.hasDefaultValue()) null
+                    else (parameterItem as PsiParameterItem).psiParameter
+                }
+            // Create an overloaded callable.
+            when (callable) {
+                is PsiConstructorItem -> {
+                    val overloadConstructor =
+                        PsiConstructorItem.create(
+                            codebase,
+                            classItem,
+                            callable.psiMethod,
+                            enclosingClassTypeItemFactory,
+                            psiParameters,
+                        )
+
+                    classItem.addConstructor(overloadConstructor)
+                }
+                is PsiMethodItem -> {
+                    val overloadMethod =
+                        PsiMethodItem.create(
+                            codebase,
+                            classItem,
+                            callable.psiMethod,
+                            enclosingClassTypeItemFactory,
+                            psiParameters,
+                        )
+
+                    classItem.addMethod(overloadMethod)
+                }
+            }
         }
     }
 
@@ -920,6 +940,8 @@ internal class PsiCodebaseAssembler(
         // Create the initial set of packages that were found in the source files.
         codebase.packageTracker.createInitialPackages(packageDocs)
 
+        findTypeAliases(psiClasses, codebase)
+
         // Process the `PsiClass`es.
         for (psiClass in psiClasses) {
             // If a package filter is supplied then ignore any classes that do not match it.
@@ -939,6 +961,29 @@ internal class PsiCodebaseAssembler(
         }
     }
 
+    /**
+     * Finds all type aliases declared in the [KtFile]s underlying any file facade classes in
+     * [psiClasses] and adds them to the codebase.
+     */
+    private fun findTypeAliases(psiClasses: List<PsiClass>, codebase: PsiBasedCodebase) {
+        val typeAliases =
+            psiClasses.flatMap { topLevelDeclarations(it) }.filterIsInstance<KtTypeAlias>()
+        for (typeAlias in typeAliases) {
+            PsiTypeAliasItem.create(typeAlias, codebase)
+        }
+    }
+
+    /**
+     * Returns a list of declarations from the [fileFacadeClass]. If [fileFacadeClass] is not
+     * actually a file facade class, returns an empty list.
+     */
+    private fun topLevelDeclarations(fileFacadeClass: PsiClass): List<KtDeclaration> {
+        return ((fileFacadeClass as? UClass)?.javaPsi as? KtLightClassForFacade)?.files?.flatMap {
+            it.declarations
+        }
+            ?: emptyList()
+    }
+
     /**
      * Split the [psiFiles] into separate `package-info.java` [PsiJavaFile]s and [PsiClass]es.
      *
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
index 1ffe9dd5b..7e74d7194 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
@@ -35,7 +35,9 @@ import com.intellij.psi.JavaPsiFacade
 import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiParameter
+import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtClassOrObject
+import org.jetbrains.kotlin.psi.KtConstructor
 import org.jetbrains.kotlin.psi.KtPrimaryConstructor
 import org.jetbrains.uast.UMethod
 
@@ -80,7 +82,7 @@ private constructor(
             containingClass: ClassItem,
             psiMethod: PsiMethod,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
-            psiParametersGetter: (PsiMethod) -> List<PsiParameter> = { it.psiParameters },
+            psiParameters: List<PsiParameter> = psiMethod.psiParameters,
         ): PsiConstructorItem {
             assert(psiMethod.isConstructor)
             val name = psiMethod.name
@@ -122,7 +124,7 @@ private constructor(
                             psiMethod,
                             containingCallable as PsiCallableItem,
                             constructorTypeItemFactory,
-                            psiParametersGetter(psiMethod),
+                            psiParameters,
                         )
                     },
                     returnType = containingClass.type(),
@@ -131,6 +133,31 @@ private constructor(
                     implicitConstructor = false,
                     isPrimary = (psiMethod as? UMethod)?.isPrimaryConstructor ?: false,
                 )
+
+            // Undo setting of constructors with value class types to private (b/395472914).
+            // Constructors that use value class types are effectively private to java callers, but
+            // they can be public in source to kotlin callers, so we want to track them.
+            if (
+                constructor.modifiers.isPrivate() &&
+                    constructor.parameters().any { (it.type() as PsiTypeItem).isValueClassType() }
+            ) {
+                (psiMethod.sourceElement as? KtConstructor<*>)?.let { sourcePsi ->
+                    if (!sourcePsi.hasModifier(KtTokens.PRIVATE_KEYWORD)) {
+                        constructor.mutateModifiers {
+                            val correctedVisibility =
+                                when {
+                                    sourcePsi.hasModifier(KtTokens.PROTECTED_KEYWORD) ->
+                                        VisibilityLevel.PROTECTED
+                                    sourcePsi.hasModifier(KtTokens.INTERNAL_KEYWORD) ->
+                                        VisibilityLevel.INTERNAL
+                                    else -> VisibilityLevel.PUBLIC
+                                }
+                            setVisibilityLevel(correctedVisibility)
+                        }
+                    }
+                }
+            }
+
             return constructor
         }
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
index b6f8645c9..b4140d166 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
@@ -132,7 +132,6 @@ class PsiEnvironmentManager(
         modelOptions: ModelOptions,
         allowReadingComments: Boolean,
         jdkHome: File?,
-        projectDescription: File?,
     ): SourceParser {
         return PsiSourceParser(
             psiEnvironmentManager = this,
@@ -142,7 +141,6 @@ class PsiEnvironmentManager(
             useK2Uast = modelOptions[PsiModelOptions.useK2Uast],
             allowReadingComments = allowReadingComments,
             jdkHome = jdkHome,
-            projectDescription = projectDescription,
         )
     }
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
index 023a89224..c6e1b988a 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
@@ -29,7 +29,6 @@ import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.isNonNullAnnotation
 import com.android.tools.metalava.model.item.DefaultFieldItem
 import com.android.tools.metalava.model.item.FieldValue
-import com.android.tools.metalava.reporter.Issues
 import com.intellij.psi.PsiCallExpression
 import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiEnumConstant
@@ -38,12 +37,6 @@ import com.intellij.psi.PsiModifierListOwner
 import com.intellij.psi.PsiPrimitiveType
 import com.intellij.psi.PsiReference
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
-import org.jetbrains.kotlin.lexer.KtTokens
-import org.jetbrains.kotlin.psi.KtObjectDeclaration
-import org.jetbrains.kotlin.psi.KtProperty
-import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
-import org.jetbrains.kotlin.psi.psiUtil.isPublic
-import org.jetbrains.uast.UField
 
 internal class PsiFieldItem(
     override val codebase: PsiBasedCodebase,
@@ -54,7 +47,7 @@ internal class PsiFieldItem(
     containingClass: ClassItem,
     type: TypeItem,
     private val isEnumConstant: Boolean,
-    override val fieldValue: FieldValue?,
+    override val legacyFieldValue: FieldValue?,
 ) :
     DefaultFieldItem(
         codebase = codebase,
@@ -67,7 +60,7 @@ internal class PsiFieldItem(
         containingClass = containingClass,
         type = type,
         isEnumConstant = isEnumConstant,
-        fieldValue = fieldValue,
+        legacyFieldValue = legacyFieldValue,
     ),
     FieldItem,
     PsiItem {
@@ -85,75 +78,6 @@ internal class PsiFieldItem(
             )
             .also { duplicated -> duplicated.inheritedFrom = containingClass() }
 
-    override fun ensureCompanionFieldJvmField() {
-        if (modifiers.isPublic() && modifiers.isFinal()) {
-            // UAST will inline const fields into the surrounding class, so we have to
-            // dip into Kotlin PSI to figure out if this field was really declared in
-            // a companion object
-            val psi = psi()
-            if (psi is UField) {
-                val sourcePsi = psi.sourcePsi
-                if (sourcePsi is KtProperty) {
-                    val companionClassName = sourcePsi.containingClassOrObject?.name
-                    if (companionClassName == "Companion") {
-                        // JvmField cannot be applied to const property
-                        // (https://github.com/JetBrains/kotlin/blob/dc7b1fbff946d1476cc9652710df85f65664baee/compiler/frontend.java/src/org/jetbrains/kotlin/resolve/jvm/checkers/JvmFieldApplicabilityChecker.kt#L46)
-                        if (!modifiers.isConst()) {
-                            if (modifiers.findAnnotation("kotlin.jvm.JvmField") == null) {
-                                codebase.reporter.report(
-                                    Issues.MISSING_JVMSTATIC,
-                                    this,
-                                    "Companion object constants like ${name()} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
-                                )
-                            } else if (modifiers.findAnnotation("kotlin.jvm.JvmStatic") != null) {
-                                codebase.reporter.report(
-                                    Issues.MISSING_JVMSTATIC,
-                                    this,
-                                    "Companion object constants like ${name()} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
-                                )
-                            }
-                        }
-                    }
-                } else if (sourcePsi is KtObjectDeclaration && sourcePsi.isCompanion()) {
-                    // We are checking if we have public properties that we can expect to be
-                    // constant
-                    // (that is, declared via `val`) but that aren't declared 'const' in a companion
-                    // object that are not annotated with @JvmField or annotated with @JvmStatic
-                    // https://developer.android.com/kotlin/interop#companion_constants
-                    val ktProperties =
-                        sourcePsi.declarations.filter { declaration ->
-                            declaration is KtProperty &&
-                                declaration.isPublic &&
-                                !declaration.isVar &&
-                                !declaration.hasModifier(KtTokens.CONST_KEYWORD) &&
-                                declaration.annotationEntries.none { annotationEntry ->
-                                    annotationEntry.shortName?.asString() == "JvmField"
-                                }
-                        }
-                    for (ktProperty in ktProperties) {
-                        if (
-                            ktProperty.annotationEntries.none { annotationEntry ->
-                                annotationEntry.shortName?.asString() == "JvmStatic"
-                            }
-                        ) {
-                            codebase.reporter.report(
-                                Issues.MISSING_JVMSTATIC,
-                                ktProperty,
-                                "Companion object constants like ${ktProperty.name} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        } else {
-                            codebase.reporter.report(
-                                Issues.MISSING_JVMSTATIC,
-                                ktProperty,
-                                "Companion object constants like ${ktProperty.name} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        }
-                    }
-                }
-            }
-        }
-    }
-
     companion object {
         internal fun create(
             codebase: PsiBasedCodebase,
@@ -201,7 +125,7 @@ internal class PsiFieldItem(
                 containingClass = containingClass,
                 type = fieldType,
                 isEnumConstant = isEnumConstant,
-                fieldValue = fieldValue
+                legacyFieldValue = fieldValue
             )
         }
     }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
index f7012b85f..023456dcf 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
@@ -26,6 +26,7 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.reporter.Issues
 import com.intellij.psi.JavaPsiFacade
 import com.intellij.psi.PsiClass
+import com.intellij.psi.PsiComment
 import com.intellij.psi.PsiCompiledElement
 import com.intellij.psi.PsiDocCommentOwner
 import com.intellij.psi.PsiElement
@@ -38,6 +39,7 @@ import com.intellij.psi.impl.source.SourceTreeToPsiMap
 import com.intellij.psi.impl.source.javadoc.PsiDocMethodOrFieldRef
 import com.intellij.psi.impl.source.tree.CompositePsiElement
 import com.intellij.psi.impl.source.tree.JavaDocElementType
+import com.intellij.psi.javadoc.PsiDocComment
 import com.intellij.psi.javadoc.PsiDocTag
 import com.intellij.psi.javadoc.PsiDocToken
 import com.intellij.psi.javadoc.PsiInlineDocTag
@@ -636,8 +638,46 @@ internal class PsiItemDocumentation(
                 }
             }
 
-            if (element is PsiDocCommentOwner && element.docComment !is PsiCompiledElement) {
-                return element.docComment?.text ?: ""
+            if (element is PsiDocCommentOwner) {
+                val docComment = element.docComment
+                if (docComment != null && docComment !is PsiCompiledElement) {
+                    val text = docComment.text
+                    // Make sure that the text is a doc comment, i.e. starts with /**.
+                    if (text != null) {
+                        if (text.startsWith("/**")) {
+                            return text
+                        } else {
+                            // Workaround for b/391104222.
+                            //
+                            // Scan through the previous nodes for the first real doc comment up to
+                            // the first non-white space node. The latter ensures it does not find a
+                            // doc comment that belongs to another item.
+                            var node = element.node
+                            while (true) {
+                                node = node.treePrev ?: break
+
+                                // Ignore white space or empty marker nodes, e.g. ImportListElement,
+                                // that are inserted to mark semantically significant locations but
+                                // do not actually have any content. They may be added between an
+                                // item like a class and its corresponding doc comment.
+                                if (node is PsiWhiteSpace || node.textLength == 0) continue
+
+                                // Stop searching as soon as the first non PsiComment is found.
+                                val psiComment = node as? PsiComment ?: break
+
+                                // If the comment is not a doc comment (with the correct type AND
+                                // content) then ignore it.
+                                if (
+                                    psiComment !is PsiDocComment ||
+                                        !psiComment.text.startsWith("/**")
+                                )
+                                    continue
+
+                                return psiComment.text
+                            }
+                        }
+                    }
+                }
             }
 
             return ""
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
index 6cbe2e7a6..2c7c9fe1e 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
@@ -34,6 +34,7 @@ import com.android.tools.metalava.model.type.MethodFingerprint
 import com.android.tools.metalava.reporter.FileLocation
 import com.intellij.psi.PsiAnnotationMethod
 import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiParameter
 import org.jetbrains.kotlin.psi.KtNamedFunction
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.kotlin.psi.KtProperty
@@ -97,16 +98,16 @@ internal class PsiMethodItem(
                     (psiMethod.sourcePsi as KtParameter).hasValOrVar())
     }
 
-    override fun defaultValue(): String {
+    override fun legacyDefaultValue(): String {
         return when (psiMethod) {
             is UAnnotationMethod -> {
                 psiMethod.uastDefaultValue?.let { codebase.printer.toSourceString(it) } ?: ""
             }
             is PsiAnnotationMethod -> {
                 psiMethod.defaultValue?.let { codebase.printer.toSourceExpression(it, this) }
-                    ?: super.defaultValue()
+                    ?: super.legacyDefaultValue()
             }
-            else -> super.defaultValue()
+            else -> super.legacyDefaultValue()
         }
     }
 
@@ -171,6 +172,7 @@ internal class PsiMethodItem(
             containingClass: ClassItem,
             psiMethod: PsiMethod,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
+            psiParameters: List<PsiParameter> = psiMethod.psiParameters,
         ): PsiMethodItem {
             assert(!psiMethod.isConstructor)
             // UAST workaround: @JvmName for UMethod with fake LC PSI
@@ -249,6 +251,7 @@ internal class PsiMethodItem(
                             psiMethod,
                             containingCallable as PsiCallableItem,
                             methodTypeItemFactory,
+                            psiParameters,
                         )
                     },
                     typeParameterList = typeParameterList,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
index 948b461d5..a68eebc9c 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.JAVA_LANG_ANNOTATION_TARGET
 import com.android.tools.metalava.model.JAVA_LANG_TYPE_USE_TARGET
+import com.android.tools.metalava.model.JVM_STATIC
 import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
 import com.android.tools.metalava.model.ModifierFlags.Companion.ACTUAL
 import com.android.tools.metalava.model.ModifierFlags.Companion.COMPANION
@@ -47,7 +48,6 @@ import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
 import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
 import com.android.tools.metalava.model.ModifierFlags.Companion.VALUE
 import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
-import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_MASK
 import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
 import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.VisibilityLevel
@@ -76,13 +76,18 @@ import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
 import org.jetbrains.kotlin.lexer.KtModifierKeywordToken
 import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtAnnotated
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.KtConstructor
 import org.jetbrains.kotlin.psi.KtDeclaration
 import org.jetbrains.kotlin.psi.KtElement
+import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtModifierList
 import org.jetbrains.kotlin.psi.KtModifierListOwner
 import org.jetbrains.kotlin.psi.KtNamedFunction
+import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
-import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
+import org.jetbrains.kotlin.psi.psiUtil.isTopLevelKtOrJavaMember
 import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
 import org.jetbrains.uast.UAnnotated
 import org.jetbrains.uast.UAnnotation
@@ -122,34 +127,55 @@ internal object PsiModifierItem {
     }
 
     /**
-     * Creates modifiers for the property represented by [ktDeclaration]. If the [getter] exists, it
-     * is used to create the modifiers (along with annotations appearing directly on the property).
-     * If there is no getter, the kt modifiers are used.
+     * Creates modifiers for the property represented by [ktDeclaration] using the [KtModifierList]
+     * and from the property. Uses annotations from the [getter] if it exists in addition to
+     * property annotations because property modifiers used to be created just from the getter and
+     * some places rely on the old behavior for annotations (@RestrictTo in AndroidX is only
+     * applicable to accessors, not properties themselves).
      */
     fun createForProperty(
         codebase: PsiBasedCodebase,
         ktDeclaration: KtDeclaration,
         getter: PsiMethodItem?,
+        setter: PsiMethodItem?,
     ): MutableModifierList {
+        val ktModifierList = ktDeclaration.modifierList
+        val visibilityFlags =
+            visibilityFlags(
+                psiModifierList = null,
+                ktModifierList = ktModifierList,
+                element = ktDeclaration,
+                sourcePsi = ktDeclaration
+            )
+        val kotlinFlags = kotlinFlags { token ->
+            ktModifierList?.hasModifier(token) ?: ktDeclaration.hasModifier(token)
+        }
+        val javaFlags = javaFlagsForKotlinElement(ktDeclaration)
+        val flags = visibilityFlags or kotlinFlags or javaFlags
+
+        // Use the flags computed from the property, and the getter annotations, if they exist.
         val modifiers =
-            if (getter != null) {
-                create(codebase, getter.psi())
-            } else {
-                val ktModifierList = ktDeclaration.modifierList
-                val visibilityFlags =
-                    visibilityFlags(
-                        psiModifierList = null,
-                        ktModifierList = ktModifierList,
-                        element = ktDeclaration,
-                        sourcePsi = ktDeclaration
-                    )
-                val kotlinFlags = kotlinFlags { token ->
-                    ktModifierList?.hasModifier(token) ?: ktDeclaration.hasModifier(token)
-                }
-                val javaFlags = javaFlagsForKotlinElement(ktDeclaration)
-                val flags = visibilityFlags or kotlinFlags or javaFlags
-                createMutableModifiers(flags, emptyList())
-            }
+            createMutableModifiers(
+                flags,
+                // Filter deprecated annotations: the property will pull effectivelyDeprecated
+                // status from its getter, but the originallyDeprecated value should reflect
+                // the property itself, to avoid propagating deprecation from getter to property to
+                // setter. The setter should only inherit deprecation from the property itself.
+                getter?.modifiers?.annotations()?.filter { !isDeprecatedAnnotation(it) }
+                    ?: emptyList()
+            )
+
+        // Correct visibility of accessors (work around K2 bugs with value class type properties)
+        // https://youtrack.jetbrains.com/issue/KT-74205
+        // The getter must have the same visibility as the property
+        val propertyVisibility = modifiers.getVisibilityLevel()
+        if (getter != null && getter.modifiers.getVisibilityLevel() != propertyVisibility) {
+            getter.mutateModifiers { setVisibilityLevel(modifiers.getVisibilityLevel()) }
+        }
+        // The setter cannot be more visible than the property
+        if (setter != null && setter.modifiers.getVisibilityLevel() > propertyVisibility) {
+            setter.mutateModifiers { setVisibilityLevel(modifiers.getVisibilityLevel()) }
+        }
 
         // Annotations whose target is property won't be bound to anywhere in LC/UAST, if the
         // property doesn't need a backing field. Same for unspecified use-site target.
@@ -158,10 +184,14 @@ internal object PsiModifierItem {
             val useSiteTarget = ktAnnotationEntry.useSiteTarget?.getAnnotationUseSiteTarget()
             if (useSiteTarget == null || useSiteTarget == AnnotationUseSiteTarget.PROPERTY) {
                 val uAnnotation = ktAnnotationEntry.toUElement() as? UAnnotation ?: continue
-                val annotationItem = UAnnotationItem.create(codebase, uAnnotation)
+                val annotationItem = UAnnotationItem.create(codebase, uAnnotation) ?: continue
                 if (annotationItem !in modifiers.annotations()) {
                     modifiers.addAnnotation(annotationItem)
                 }
+                // Make sure static definitions are marked
+                if (annotationItem.qualifiedName == JVM_STATIC) {
+                    modifiers.setStatic(true)
+                }
             }
         }
 
@@ -172,6 +202,48 @@ internal object PsiModifierItem {
         return modifiers
     }
 
+    /**
+     * Creates modifiers for a [ktDeclaration] that does not have an equivalent psi element which
+     * can be used with [create]. If the [ktDeclaration] is a property, [createForProperty] should
+     * be used instead.
+     */
+    fun createForKtDeclaration(
+        codebase: PsiBasedCodebase,
+        ktDeclaration: KtDeclaration
+    ): MutableModifierList {
+        val ktModifierList = ktDeclaration.modifierList
+        val visibilityFlags =
+            visibilityFlags(
+                psiModifierList = null,
+                ktModifierList = ktModifierList,
+                element = ktDeclaration,
+                sourcePsi = ktDeclaration
+            )
+        val kotlinFlags = kotlinFlags { token ->
+            ktModifierList?.hasModifier(token) ?: ktDeclaration.hasModifier(token)
+        }
+        val flags = visibilityFlags or kotlinFlags
+
+        val annotations =
+            ktDeclaration.annotationEntries.mapNotNull { ktAnnotationEntry ->
+                (ktAnnotationEntry.toUElement() as? UAnnotation)?.let { uAnnotation ->
+                    UAnnotationItem.create(codebase, uAnnotation)
+                }
+            }
+
+        val modifiers =
+            createMutableModifiers(
+                flags,
+                annotations,
+            )
+
+        if (hasDeprecatedAnnotation(modifiers)) {
+            modifiers.setDeprecated(true)
+        }
+
+        return modifiers
+    }
+
     /** Determine whether nullness annotations need removing from [modifiers]. */
     private fun shouldRemoveNullnessAnnotations(
         modifiers: BaseModifierList,
@@ -187,14 +259,15 @@ internal object PsiModifierItem {
     }
 
     private fun hasDeprecatedAnnotation(modifiers: BaseModifierList) =
-        modifiers.hasAnnotation {
-            it.qualifiedName.let { qualifiedName ->
-                qualifiedName == "Deprecated" ||
-                    qualifiedName.endsWith(".Deprecated") ||
-                    // DeprecatedForSdk that do not apply to this API surface have been filtered
-                    // out so if any are left then treat it as a standard Deprecated annotation.
-                    qualifiedName == ANDROID_DEPRECATED_FOR_SDK
-            }
+        modifiers.hasAnnotation(::isDeprecatedAnnotation)
+
+    private fun isDeprecatedAnnotation(annotationItem: AnnotationItem): Boolean =
+        annotationItem.qualifiedName.let { qualifiedName ->
+            qualifiedName == "Deprecated" ||
+                qualifiedName.endsWith(".Deprecated") ||
+                // DeprecatedForSdk that do not apply to this API surface have been filtered
+                // out so if any are left then treat it as a standard Deprecated annotation.
+                qualifiedName == ANDROID_DEPRECATED_FOR_SDK
         }
 
     private fun isDeprecatedFromSourcePsi(element: PsiModifierListOwner): Boolean {
@@ -212,36 +285,7 @@ internal object PsiModifierItem {
     }
 
     private fun computeFlag(element: PsiModifierListOwner, modifierList: PsiModifierList): Int {
-        var flags = 0
-        if (modifierList.hasModifierProperty(PsiModifier.STATIC)) {
-            flags = flags or STATIC
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.ABSTRACT)) {
-            flags = flags or ABSTRACT
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.FINAL)) {
-            flags = flags or FINAL
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.NATIVE)) {
-            flags = flags or NATIVE
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
-            flags = flags or SYNCHRONIZED
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.STRICTFP)) {
-            flags = flags or STRICT_FP
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.TRANSIENT)) {
-            flags = flags or TRANSIENT
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.VOLATILE)) {
-            flags = flags or VOLATILE
-        }
-        if (modifierList.hasModifierProperty(PsiModifier.DEFAULT)) {
-            flags = flags or DEFAULT
-        }
-
-        // Look for special Kotlin keywords
+        // Look for a KtModifierList to compute visibility and Kotlin-specific modifiers.
         var ktModifierList: KtModifierList? = null
         val sourcePsi = (element as? UElement)?.sourcePsi
         when (modifierList) {
@@ -255,6 +299,21 @@ internal object PsiModifierItem {
             }
         }
 
+        // Compute flags that exist in java.
+        var flags =
+            if (
+                element is KotlinUMethodWithFakeLightDelegateBase<*> && sourcePsi is KtDeclaration
+            ) {
+                // Fake elements from kotlin (e.g. methods that use value class types) may not have
+                // the correct modifiers (https://youtrack.jetbrains.com/issue/KTIJ-33047). Compute
+                // them directly from the source instead.
+                // Use the property element directly for accessors because some values aren't
+                // defined for accessors (e.g. containingClassOrObject is null).
+                javaFlagsForKotlinElement((sourcePsi as? KtPropertyAccessor)?.property ?: sourcePsi)
+            } else {
+                javaFlags(modifierList)
+            }
+
         // Merge in the visibility flags.
         val visibilityFlags = visibilityFlags(modifierList, ktModifierList, element, sourcePsi)
         flags = flags or visibilityFlags
@@ -357,6 +416,42 @@ internal object PsiModifierItem {
         return visibilityFlags
     }
 
+    /**
+     * Computes flags that exist in Java, excluding visibility flags. These are for both Java and
+     * Kotlin source elements.
+     */
+    private fun javaFlags(modifierList: PsiModifierList): Int {
+        var flags = 0
+        if (modifierList.hasModifierProperty(PsiModifier.STATIC)) {
+            flags = flags or STATIC
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.ABSTRACT)) {
+            flags = flags or ABSTRACT
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.FINAL)) {
+            flags = flags or FINAL
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.NATIVE)) {
+            flags = flags or NATIVE
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
+            flags = flags or SYNCHRONIZED
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.STRICTFP)) {
+            flags = flags or STRICT_FP
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.TRANSIENT)) {
+            flags = flags or TRANSIENT
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.VOLATILE)) {
+            flags = flags or VOLATILE
+        }
+        if (modifierList.hasModifierProperty(PsiModifier.DEFAULT)) {
+            flags = flags or DEFAULT
+        }
+        return flags
+    }
+
     /** Computes Kotlin-specific flags. */
     private fun kotlinFlags(hasModifier: (KtModifierKeywordToken) -> Boolean): Int {
         var flags = 0
@@ -404,29 +499,69 @@ internal object PsiModifierItem {
 
     /** Creates Java-equivalent flags for the Kotlin element. */
     private fun javaFlagsForKotlinElement(ktDeclaration: KtDeclaration): Int {
-        return if (ktDeclaration.hasModifier(KtTokens.CONST_KEYWORD)) {
-            FINAL or STATIC
-        } else if (ktDeclaration.hasModifier(KtTokens.FINAL_KEYWORD)) {
-            FINAL
-        } else if (
-            ktDeclaration.hasModifier(KtTokens.ABSTRACT_KEYWORD) ||
-                ktDeclaration.containingClass()?.isAnnotation() == true
+        return if (
+            // const values are static, and anything in a file-facade class (which top level
+            // [KtDeclaration]s are) is also static
+            ktDeclaration.hasModifier(KtTokens.CONST_KEYWORD) ||
+                ktDeclaration.isTopLevelKtOrJavaMember()
         ) {
-            // Declarations with the abstract keyword are abstract, and so are annotation class
-            // properties.
+            FINAL or STATIC
+        } else if (ktDeclaration.isAbstract()) {
             ABSTRACT
-        } else if (
-            !ktDeclaration.hasModifier(KtTokens.OPEN_KEYWORD) &&
-                !ktDeclaration.hasModifier(KtTokens.OVERRIDE_KEYWORD) &&
-                ktDeclaration.containingClass()?.isInterface() != true
-        ) {
-            // Kotlin elements are final unless declared otherwise.
+        } else if (ktDeclaration.isDefault()) {
+            DEFAULT
+        } else if (ktDeclaration.isFinal()) {
             FINAL
         } else {
             0
         }
     }
 
+    private fun KtDeclaration.isFromInterface(): Boolean {
+        // Can't use containingClass() here -- don't count definitions in interface companions
+        return (containingClassOrObject as? KtClass)?.isInterface() == true
+    }
+
+    /**
+     * Checks if the [KtDeclaration] needs the abstract modifier:
+     * - if the definition used the abstract modifier
+     * - if the definition is an annotation property
+     * - if the definition is an interface property without a defined getter
+     * - if the definition is an interface function without a body
+     */
+    private fun KtDeclaration.isAbstract(): Boolean {
+        return hasModifier(KtTokens.ABSTRACT_KEYWORD) ||
+            (containingClassOrObject as? KtClass)?.isAnnotation() == true ||
+            (this is KtProperty && isFromInterface() && getter?.hasBody() != true) ||
+            (this is KtFunction && isFromInterface() && !hasBody())
+    }
+
+    /**
+     * Checks if the [KtDeclaration] needs the default modifier:
+     * - if the definition is an interface property with a defined getter (interface properties
+     *   cannot have backing fields, so this is the only way they can have a default implementation)
+     * - if the definition is an interface function with a body
+     */
+    private fun KtDeclaration.isDefault(): Boolean {
+        return isFromInterface() &&
+            ((this is KtProperty && getter?.hasBody() == true) || (this is KtFunction && hasBody()))
+    }
+
+    /**
+     * Checks if the [KtDeclaration] needs the final modifier. This should only be called if the
+     * definition does not need the abstract or default modifiers.
+     * - if the definition uses the final keyword
+     * - if the definition does not use the open keyword and does not use the override keyword
+     * - the definition is not a constructor -- the final modifier isn't needed for constructors as
+     *   constructors can never be overridden
+     */
+    private fun KtDeclaration.isFinal(): Boolean {
+        return hasModifier(KtTokens.FINAL_KEYWORD) ||
+            (!hasModifier(KtTokens.OPEN_KEYWORD) &&
+                !hasModifier(KtTokens.OVERRIDE_KEYWORD) &&
+                this !is KtConstructor<*>)
+    }
+
     /**
      * Returns a list of the targets this annotation is defined to apply to, as qualified names
      * (e.g. "java.lang.annotation.ElementType.TYPE_USE").
@@ -507,24 +642,7 @@ internal object PsiModifierItem {
                     .distinct()
                     // Remove any type-use annotations that psi incorrectly applied to the item.
                     .filterIncorrectTypeUseAnnotations(element)
-                    .mapNotNull {
-                        val qualifiedName = it.qualifiedName
-                        // Consider also supporting
-                        // com.android.internal.annotations.VisibleForTesting?
-                        if (qualifiedName == ANDROIDX_VISIBLE_FOR_TESTING) {
-                            val otherwise = it.findAttributeValue(ATTR_OTHERWISE)
-                            val ref =
-                                when {
-                                    otherwise is PsiReferenceExpression -> otherwise.referenceName
-                                            ?: ""
-                                    otherwise != null -> otherwise.text
-                                    else -> ""
-                                }
-                            flags = getVisibilityFlag(ref, flags)
-                        }
-
-                        PsiAnnotationItem.create(codebase, it)
-                    }
+                    .mapNotNull { PsiAnnotationItem.create(codebase, it) }
                     .filter { !it.isDeprecatedForSdk() }
             createMutableModifiers(flags, annotations)
         }
@@ -564,22 +682,7 @@ internal object PsiModifierItem {
                             it.qualifiedName == null ||
                             !it.isKotlinNullabilityAnnotation
                     }
-                    .mapNotNull {
-                        val qualifiedName = it.qualifiedName
-                        if (qualifiedName == ANDROIDX_VISIBLE_FOR_TESTING) {
-                            val otherwise = it.findAttributeValue(ATTR_OTHERWISE)
-                            val ref =
-                                when {
-                                    otherwise is PsiReferenceExpression -> otherwise.referenceName
-                                            ?: ""
-                                    otherwise != null -> otherwise.asSourceString()
-                                    else -> ""
-                                }
-                            flags = getVisibilityFlag(ref, flags)
-                        }
-
-                        UAnnotationItem.create(codebase, it)
-                    }
+                    .mapNotNull { UAnnotationItem.create(codebase, it) }
                     .filter { !it.isDeprecatedForSdk() }
 
             if (!isPrimitiveVariable) {
@@ -614,7 +717,7 @@ internal object PsiModifierItem {
 
         for (api in allowIn.leafValues()) {
             val annotationName = api.value() as? String ?: continue
-            if (codebase.annotationManager.isShowAnnotationName(annotationName)) {
+            if (annotationContext.annotationManager.isShowAnnotationName(annotationName)) {
                 return true
             }
         }
@@ -627,24 +730,6 @@ internal object PsiModifierItem {
 
     private val UAnnotation.isKotlinNullabilityAnnotation: Boolean
         get() = qualifiedName == NOT_NULL || qualifiedName == NULLABLE
-
-    /** Modifies the modifier flags based on the VisibleForTesting otherwise constants */
-    private fun getVisibilityFlag(ref: String, flags: Int): Int {
-        val visibilityFlags =
-            if (ref.endsWith("PROTECTED")) {
-                PROTECTED
-            } else if (ref.endsWith("PACKAGE_PRIVATE")) {
-                PACKAGE_PRIVATE
-            } else if (ref.endsWith("PRIVATE") || ref.endsWith("NONE")) {
-                PRIVATE
-            } else {
-                flags and VISIBILITY_MASK
-            }
-
-        return (flags and VISIBILITY_MASK.inv()) or visibilityFlags
-    }
 }
 
-private const val ANDROIDX_VISIBLE_FOR_TESTING = "androidx.annotation.VisibleForTesting"
-private const val ATTR_OTHERWISE = "otherwise"
 private const val ATTR_ALLOW_IN = "allowIn"
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
similarity index 57%
rename from metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
rename to metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
index d3ef319ac..2f68f4a38 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
@@ -16,11 +16,8 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.item.DefaultValue
+import com.android.tools.metalava.model.item.ParameterDefaultValue
 import org.jetbrains.kotlin.analysis.api.KaExperimentalApi
 import org.jetbrains.kotlin.analysis.api.analyze
 import org.jetbrains.kotlin.analysis.api.symbols.KaFunctionSymbol
@@ -35,41 +32,27 @@ import org.jetbrains.uast.UExpression
 import org.jetbrains.uast.UMethod
 import org.jetbrains.uast.UastFacade
 
-internal class PsiDefaultValue(private val item: PsiParameterItem) : DefaultValue {
+internal class PsiParameterDefaultValue(private val item: PsiParameterItem) :
+    ParameterDefaultValue {
 
     override fun duplicate(parameter: ParameterItem) =
-        PsiDefaultValue(parameter as PsiParameterItem)
+        PsiParameterDefaultValue(parameter as PsiParameterItem)
 
-    private var defaultValueAsString: String? = null
+    private var hasDefaultValue: Boolean? = null
 
-    private fun defaultValueAsString(): String? {
-        if (defaultValueAsString == null) {
-            defaultValueAsString = item.computeDefaultValue()
+    override fun hasDefaultValue(): Boolean {
+        if (hasDefaultValue == null) {
+            hasDefaultValue = item.computeHasDefaultValue()
         }
-        return defaultValueAsString
+        return hasDefaultValue!!
     }
 
-    override fun hasDefaultValue() = isDefaultValueKnown()
-
-    override fun isDefaultValueKnown(): Boolean {
-        val psiParameter = item.psiParameter
-        return if (psiParameter.isKotlin()) {
-            defaultValueAsString() != INVALID_VALUE
-        } else {
-            // Java: Look for @ParameterName annotation
-            item.modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
-        }
-    }
-
-    override fun value() = defaultValueAsString()
-
     @OptIn(KaExperimentalApi::class)
-    private fun PsiParameterItem.computeDefaultValue(): String? {
+    private fun PsiParameterItem.computeHasDefaultValue(): Boolean {
         if (psiParameter.isKotlin()) {
             val psiCallableItem = item.containingCallable() as PsiCallableItem
             val ktFunction =
-                ((psiCallableItem.psi() as? UMethod)?.sourcePsi as? KtFunction)
-                    ?: return INVALID_VALUE
+                ((psiCallableItem.psi() as? UMethod)?.sourcePsi as? KtFunction) ?: return false
 
             analyze(ktFunction) {
                 val function =
@@ -78,42 +61,21 @@ internal class PsiDefaultValue(private val item: PsiParameterItem) : DefaultValu
                     } else {
                         ktFunction.symbol
                     }
-                if (function !is KaFunctionSymbol) return INVALID_VALUE
-                val symbol = getKtParameterSymbol(function) ?: return INVALID_VALUE
+                if (function !is KaFunctionSymbol) return false
+                val symbol = getKtParameterSymbol(function) ?: return false
                 if (symbol is KaValueParameterSymbol && symbol.hasDefaultValue) {
-                    val defaultValue =
-                        (symbol.psi as? KtParameter)?.defaultValue ?: return INVALID_VALUE
+                    val defaultValue = (symbol.psi as? KtParameter)?.defaultValue ?: return false
                     if (defaultValue is KtConstantExpression) {
-                        return defaultValue.text
+                        return true
                     }
 
-                    val defaultExpression =
-                        UastFacade.convertElement(defaultValue, null, UExpression::class.java)
-                            as? UExpression
-                            ?: return INVALID_VALUE
-                    val constant = defaultExpression.evaluate()
-                    return if (
-                        constant != null && (constant is String || constant.javaClass.isPrimitive)
-                    ) {
-                        CodePrinter.constantToSource(constant)
-                    } else {
-                        // Expression: Compute from UAST rather than just using the source text
-                        // such that we can ensure references are fully qualified etc.
-                        codebase.printer.toSourceString(defaultExpression)
-                    }
+                    return UastFacade.convertElement(defaultValue, null, UExpression::class.java) is
+                        UExpression
                 }
             }
-
-            return INVALID_VALUE
-        } else {
-            // Java: Look for @ParameterName annotation
-            val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
-            if (annotation != null) {
-                return annotation.attributes.firstOrNull()?.value?.value()?.toString()
-            }
         }
 
-        return null
+        return false
     }
 
     private fun PsiParameterItem.getKtParameterSymbol(
@@ -161,14 +123,4 @@ internal class PsiDefaultValue(private val item: PsiParameterItem) : DefaultValu
 
         return null
     }
-
-    companion object {
-
-        /**
-         * Private marker return value from [#computeDefaultValue] signifying that the parameter has
-         * a default value but we were unable to compute a suitable static string representation for
-         * it
-         */
-        const val INVALID_VALUE = "__invalid_value__"
-    }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
index 3c1a3707f..026424c5d 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
@@ -16,23 +16,20 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.CallableItem
-import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterBindings
 import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.findAnnotation
 import com.android.tools.metalava.model.item.DefaultParameterItem
-import com.android.tools.metalava.model.item.DefaultValueFactory
+import com.android.tools.metalava.model.item.ParameterDefaultValue
+import com.android.tools.metalava.model.item.ParameterDefaultValueFactory
 import com.android.tools.metalava.model.item.PublicNameProvider
 import com.android.tools.metalava.model.type.MethodFingerprint
 import com.intellij.psi.PsiEllipsisType
 import com.intellij.psi.PsiParameter
-import com.intellij.psi.impl.compiled.ClsParameterImpl
 import org.jetbrains.kotlin.analysis.api.analyze
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.uast.UParameter
@@ -47,7 +44,7 @@ internal constructor(
     containingCallable: PsiCallableItem,
     parameterIndex: Int,
     type: TypeItem,
-    defaultValueFactory: DefaultValueFactory,
+    defaultValueFactory: ParameterDefaultValueFactory,
 ) :
     DefaultParameterItem(
         codebase = codebase,
@@ -157,7 +154,10 @@ internal constructor(
                     // Need to down cast as [isSamCompatibleOrKotlinLambda] needs access to the
                     // underlying PsiType.
                     type = type as PsiTypeItem,
-                    defaultValueFactory = { PsiDefaultValue(it as PsiParameterItem) }
+                    defaultValueFactory = {
+                        if (it.isKotlin()) PsiParameterDefaultValue(it as PsiParameterItem)
+                        else ParameterDefaultValue.NONE
+                    },
                 )
             return parameter
         }
@@ -206,21 +206,6 @@ internal fun PsiParameterItem.getPublicName(): String? {
             return null
         }
         return name()
-    } else {
-        // Java: Look for @ParameterName annotation
-        val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
-        if (annotation != null) {
-            return annotation.attributes.firstOrNull()?.value?.value()?.toString()
-        }
-
-        // Parameter names from classpath jars are not present as annotations
-        if (
-            origin == ClassOrigin.CLASS_PATH &&
-                (psiParameter is ClsParameterImpl) &&
-                !psiParameter.isAutoGeneratedName
-        ) {
-            return name()
-        }
     }
 
     return null
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
index 292c6a589..048b1187c 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
@@ -25,8 +25,13 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.item.DefaultPropertyItem
 import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtParameter
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.KtPropertyAccessor
+import org.jetbrains.kotlin.psi.KtTypeParameterListOwner
 
 internal class PsiPropertyItem
 private constructor(
@@ -42,7 +47,9 @@ private constructor(
     getter: MethodItem?,
     setter: MethodItem?,
     constructorParameter: ParameterItem?,
-    backingField: FieldItem?
+    backingField: FieldItem?,
+    receiver: TypeItem?,
+    typeParameterList: TypeParameterList,
 ) :
     DefaultPropertyItem(
         codebase = codebase,
@@ -58,6 +65,8 @@ private constructor(
         setter = setter,
         constructorParameter = constructorParameter,
         backingField = backingField,
+        receiver = receiver,
+        typeParameterList = typeParameterList,
     ),
     PropertyItem,
     PsiItem {
@@ -66,20 +75,22 @@ private constructor(
 
     companion object {
         /**
-         * Creates a new property item for the [ktDeclaration], given a [name] and relationships to
-         * other items.
+         * Creates a new property item for the [ktDeclaration], given relationships to other items.
          *
          * Kotlin's properties consist of up to four other declarations: Their accessor functions,
          * primary constructor parameter, and a backing field. These relationships are useful for
          * resolving documentation and exposing the model correctly in Kotlin stubs.
          *
-         * Most properties have a [getter], but those that are available through field access in
-         * Java (e.g. `const val` and [JvmField] properties) or are not accessible from Java (e.g.
+         * Most properties have a getter, but those that are available through field access in Java
+         * (e.g. `const val` and [JvmField] properties) or are not accessible from Java (e.g.
          * private properties and non-constructor value class properties) do not.
          *
-         * Mutable `var` properties usually have a [setter], but properties with a private default
+         * Mutable `var` properties usually have a setter, but properties with a private default
          * setter may use direct field access instead.
          *
+         * The [accessors] should contain the getter and setter, if they exist. It may also contain
+         * other accessors, like data class component methods.
+         *
          * Properties declared in the primary constructor of a class have an associated
          * [constructorParameter]. This relationship is important for resolving docs which may exist
          * on the constructor parameter.
@@ -91,17 +102,42 @@ private constructor(
             codebase: PsiBasedCodebase,
             ktDeclaration: KtDeclaration,
             containingClass: ClassItem,
-            typeItemFactory: PsiTypeItemFactory,
-            name: String,
-            getter: PsiMethodItem?,
-            setter: PsiMethodItem? = null,
+            containingTypeItemFactory: PsiTypeItemFactory,
+            accessors: List<PsiMethodItem>,
             constructorParameter: PsiParameterItem? = null,
             backingField: PsiFieldItem? = null,
         ): PsiPropertyItem? {
+            val name = ktDeclaration.name ?: return null
+
+            val (typeParameterList, typeItemFactory) =
+                PsiTypeParameterList.create(
+                    codebase,
+                    containingTypeItemFactory,
+                    "property $name",
+                    ktDeclaration as? KtTypeParameterListOwner
+                )
+
+            // Compute the type of the receiver, if there is one. This will be used to find the
+            // right accessors for the property.
+            val receiverType =
+                (ktDeclaration as? KtProperty)?.receiverTypeReference?.let {
+                    typeItemFactory.getTypeForKtElement(it)
+                }
+
+            // Determine which accessors are the getter and setter.
+            val getter = findGetter(accessors, receiverType)
+            val setter = findSetter(accessors, receiverType)
+
             val type =
                 getter?.returnType()
-                    ?: typeItemFactory.getTypeForProperty(ktDeclaration) ?: return null
-            val modifiers = PsiModifierItem.createForProperty(codebase, ktDeclaration, getter)
+                    ?: typeItemFactory.getTypeForKtElement(ktDeclaration) ?: return null
+            val modifiers =
+                PsiModifierItem.createForProperty(codebase, ktDeclaration, getter, setter)
+            if (modifiers.isFinal() && containingClass.modifiers.isFinal()) {
+                // The containing class is final, so it is implied that every property is final as
+                // well. No need to apply 'final' to each property. (This is done for methods too.)
+                modifiers.setFinal(false)
+            }
 
             val property =
                 PsiPropertyItem(
@@ -115,7 +151,9 @@ private constructor(
                     getter = getter,
                     setter = setter,
                     constructorParameter = constructorParameter,
-                    backingField = backingField
+                    backingField = backingField,
+                    receiver = receiverType,
+                    typeParameterList = typeParameterList,
                 )
             getter?.property = property
             setter?.property = property
@@ -123,5 +161,56 @@ private constructor(
             backingField?.property = property
             return property
         }
+
+        /**
+         * Given [allAccessors] for a property ([PsiMethodItem]s] for which the source element is
+         * the same [KtProperty]/[KtParameter]), finds the getter.
+         */
+        private fun findGetter(
+            allAccessors: List<PsiMethodItem>,
+            propertyReceiverType: PsiTypeItem?
+        ): PsiMethodItem? {
+            return if (propertyReceiverType == null) {
+                // No receiver, so the getter has no parameter. Make sure not to find a data class
+                // component method.
+                allAccessors.singleOrNull {
+                    it.parameters().isEmpty() && !it.name().startsWith("component")
+                }
+            } else {
+                // If there's a receiver, the getter should have the receiver type as its parameter.
+                allAccessors.singleOrNull {
+                    it.parameters().singleOrNull()?.type() == propertyReceiverType
+                }
+                // Work around a psi bug where value class extension property accessors don't
+                // include the receiver (b/385148821). This strategy does not always work, which is
+                // why the one above is used in most cases: the getter for a property parameter's
+                // source element will be a KtParameter, and the getter for a simple property
+                // declaration with no custom getter declaration will be a KtProperty, not a
+                // KtPropertyAccessor.
+                ?: allAccessors.singleOrNull {
+                        (it.psiMethod.sourceElement as? KtPropertyAccessor)?.isGetter == true
+                    }
+            }
+        }
+
+        /** Like [findGetter], but finds the property setter instead. */
+        private fun findSetter(
+            allAccessors: List<PsiMethodItem>,
+            propertyReceiverType: PsiTypeItem?
+        ): PsiMethodItem? {
+            return if (propertyReceiverType == null) {
+                // No receiver, the setter has one parameter.
+                allAccessors.singleOrNull { it.parameters().size == 1 }
+            } else {
+                // The setter has a receiver parameter in addition to the normal setter parameter.
+                allAccessors.singleOrNull {
+                    it.parameters().size == 2 && it.parameters()[0].type() == propertyReceiverType
+                }
+                // Work around a psi bug, see the equivalent [findGetter] case for details.
+                ?: allAccessors.singleOrNull {
+                        (it.psiMethod.sourceElement as? KtPropertyAccessor)?.isSetter == true
+                    }
+            }
+        }
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
index 551dfce17..1416c5c4f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
@@ -62,7 +62,6 @@ internal class PsiSourceParser(
     private val useK2Uast: Boolean,
     private val allowReadingComments: Boolean,
     private val jdkHome: File?,
-    private val projectDescription: File?,
 ) : SourceParser {
 
     private val reporter = codebaseConfig.reporter
@@ -84,27 +83,27 @@ internal class PsiSourceParser(
      */
     override fun parseSources(
         sourceSet: SourceSet,
-        commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
         apiPackages: PackageFilter?,
+        projectDescription: File?,
     ): Codebase {
         return parseAbsoluteSources(
             sourceSet.absoluteCopy().extractRoots(reporter),
-            commonSourceSet.absoluteCopy().extractRoots(reporter),
             description,
             classPath.map { it.absoluteFile },
             apiPackages,
+            projectDescription,
         )
     }
 
     /** Returns a codebase initialized from the given set of absolute files. */
     private fun parseAbsoluteSources(
         sourceSet: SourceSet,
-        commonSourceSet: SourceSet,
         description: String,
         classpath: List<File>,
         apiPackages: PackageFilter?,
+        projectDescription: File?,
     ): PsiBasedCodebase {
         val config = UastEnvironment.Configuration.create(useFirUast = useK2Uast)
         config.javaLanguageLevel = javaLanguageLevel
@@ -115,15 +114,6 @@ internal class PsiSourceParser(
             projectDescription != null -> {
                 configureUastEnvironmentFromProjectDescription(config, projectDescription)
             }
-            commonSourceSet.sources.isNotEmpty() -> {
-                configureUastEnvironmentForKMP(
-                    config,
-                    sourceSet.sources,
-                    commonSourceSet.sources,
-                    classpath,
-                    rootDir
-                )
-            }
             else -> {
                 configureUastEnvironment(config, sourceSet.sourcePath, classpath, rootDir)
             }
@@ -148,6 +138,7 @@ internal class PsiSourceParser(
                     config = codebaseConfig,
                     allowReadingComments = allowReadingComments,
                     assembler = it,
+                    isMultiplatform = environment.isKMP,
                 )
             }
 
@@ -159,8 +150,12 @@ internal class PsiSourceParser(
         return File(homePath, "jmods").isDirectory
     }
 
-    override fun loadFromJar(apiJar: File): Codebase {
-        val environment = loadUastFromJars(listOf(apiJar))
+    override fun loadFromJar(apiJar: File, classPath: List<File>): Codebase {
+        val jars = buildList {
+            add(apiJar)
+            addAll(classPath)
+        }
+        val environment = loadUastFromJars(jars)
         val assembler =
             PsiCodebaseAssembler(environment) { assembler ->
                 PsiBasedCodebase(
@@ -169,6 +164,7 @@ internal class PsiSourceParser(
                     config = codebaseConfig,
                     allowReadingComments = allowReadingComments,
                     assembler = assembler,
+                    isMultiplatform = environment.isKMP,
                 )
             }
         val codebase = assembler.codebase
@@ -217,96 +213,42 @@ internal class PsiSourceParser(
         )
     }
 
-    private fun configureUastEnvironmentForKMP(
-        config: UastEnvironment.Configuration,
-        sourceFiles: List<File>,
-        commonSourceFiles: List<File>,
-        classpath: List<File>,
-        rootDir: File,
-    ) {
-        // TODO(b/322111050): consider providing a nice DSL at Lint level
-        val projectXml = File.createTempFile("project", ".xml")
-        projectXml.deleteOnExit()
-
-        fun describeSources(sources: List<File>) = buildString {
-            for (source in sources) {
-                if (!source.isFile) continue
-                appendLine("    <src file=\"${source.absolutePath}\" />")
-            }
-        }
-
-        fun describeClasspath() = buildString {
-            for (dep in classpath) {
-                // TODO: what other kinds of dependencies?
-                if (dep.extension !in SUPPORTED_CLASSPATH_EXT) continue
-                if (dep.extension == "klib") {
-                    appendLine("    <klib file=\"${dep.absolutePath}\" />")
-                } else {
-                    appendLine("    <classpath ${dep.extension}=\"${dep.absolutePath}\" />")
-                }
-            }
-        }
-
-        // We're about to build the description of Lint's project model.
-        // Alas, no proper documentation is available. Please refer to examples at upstream Lint:
-        // https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/ProjectInitializerTest.kt
-        //
-        // An ideal project structure would look like:
-        //
-        // <project>
-        //   <root dir="frameworks/support/compose/ui/ui"/>
-        //   <module name="commonMain" android="false">
-        //     <src file="src/commonMain/.../file1.kt" /> <!-- and so on -->
-        //     <klib file="lib/if/any.klib" />
-        //     <classpath jar="/path/to/kotlin/coroutinesCore.jar" />
-        //     ...
-        //   </module>
-        //   <module name="jvmMain" android="false">
-        //     <dep module="commonMain" kind="dependsOn" />
-        //     <src file="src/jvmMain/.../file1.kt" /> <!-- and so on -->
-        //     ...
-        //   </module>
-        //   <module name="androidMain" android="true">
-        //     <dep module="jvmMain" kind="dependsOn" />
-        //     <src file="src/androidMain/.../file1.kt" /> <!-- and so on -->
-        //     ...
-        //   </module>
-        //   ...
-        // </project>
-        //
-        // That is, there are common modules where `expect` declarations and common business logic
-        // reside, along with binary dependencies of several formats, including klib and jar.
-        // Then, platform-specific modules "depend" on common modules, and have their own source set
-        // and binary dependencies.
-        //
-        // For now, with --common-source-path, common source files are isolated, but the project
-        // structure is not fully conveyed. Therefore, we will reuse the same binary dependencies
-        // for all modules (which only(?) cause performance degradation on binary resolution).
-        val description = buildString {
-            appendLine("""<?xml version="1.0" encoding="utf-8"?>""")
-            appendLine("<project>")
-            appendLine("  <root dir=\"${rootDir.absolutePath}\" />")
-            appendLine("  <module name=\"commonMain\" android=\"false\" >")
-            append(describeSources(commonSourceFiles))
-            append(describeClasspath())
-            appendLine("  </module>")
-            appendLine("  <module name=\"app\" >")
-            appendLine("    <dep module=\"commonMain\" kind=\"dependsOn\" />")
-            // NB: While K2 requires separate common / platform-specific source roots, K1 still
-            // needs to receive all source roots at once. Thus, existing usages (e.g., androidx)
-            // often pass all source files, according to compiler configuration.
-            // To make a correct module structure, we need to filter out common source files here.
-            // TODO: once fully switching to K2 and androidx usage is adjusted, we won't need this.
-            append(describeSources(sourceFiles - commonSourceFiles))
-            append(describeClasspath())
-            appendLine("  </module>")
-            appendLine("</project>")
-        }
-        projectXml.writeText(description)
-
-        configureUastEnvironmentFromProjectDescription(config, projectXml)
-    }
-
+    /**
+     * Configures the environment based on an XML description of Lint's project model.
+     *
+     * Alas, no proper documentation is available. Please refer to examples at upstream Lint:
+     * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/ProjectInitializerTest.kt
+     *
+     * An ideal project structure would look like:
+     * ```
+     * <project>
+     *     <root dir="frameworks/support/compose/ui/ui"/>
+     *     <module name="commonMain" android="false">
+     *         <src file="src/commonMain/.../file1.kt" /> <!-- and so on -->
+     *         <klib file="lib/if/any.klib" />
+     *         <classpath jar="/path/to/kotlin/coroutinesCore.jar" />
+     *         ...
+     *     </module>
+     *     <module name="jvmMain" android="false">
+     *         <dep module="commonMain" kind="dependsOn" />
+     *         <src file="src/jvmMain/.../file1.kt" /> <!-- and so on -->
+     *         ...
+     *     </module>
+     *     <module name="androidMain" android="true">
+     *         <dep module="jvmMain" kind="dependsOn" />
+     *         <src file="src/androidMain/.../file1.kt" /> <!-- and so on -->
+     *         ...
+     *     </module>
+     *     ...
+     * </project>
+     * ```
+     *
+     * That is, there are common modules where `expect` declarations and common business logic
+     * reside, along with binary dependencies of several formats, including klib and jar.
+     *
+     * Then, platform-specific modules "depend" on common modules, and have their own source set and
+     * binary dependencies.
+     */
     private fun configureUastEnvironmentFromProjectDescription(
         config: UastEnvironment.Configuration,
         projectDescription: File,
@@ -322,7 +264,20 @@ internal class PsiSourceParser(
         //  * UastEnvironment Module simply reuses existing Lint Project model.
         computeMetadata(lintClient, projectDescription)
         config.addModules(
-            lintClient.knownProjects.map { lintProject ->
+            lintClient.knownProjects.mapNotNull { lintProject ->
+                // TODO(b/383457595): For the given root dir,
+                //   Lint creates a bogus, uninitialized [Project]
+                if (
+                    // The default project name, if not given, is directory name
+                    // not something we provided, like `androidMain`.
+                    lintProject.name == lintProject.dir.name &&
+                        // source folder might be still the root dir
+                        // but libraries would be empty / not computed.
+                        (lintProject.javaSourceFolders.isEmpty() ||
+                            lintProject.javaLibraries.isEmpty())
+                ) {
+                    return@mapNotNull null
+                }
                 lintProject.kotlinLanguageLevel = kotlinLanguageLevel
                 UastEnvironment.Module(
                     lintProject,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeAliasItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeAliasItem.kt
new file mode 100644
index 000000000..88a4aae07
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeAliasItem.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.DefaultTypeAliasItem
+import com.android.tools.metalava.reporter.FileLocation
+import com.intellij.psi.PsiElement
+import org.jetbrains.kotlin.psi.KtTypeAlias
+
+internal class PsiTypeAliasItem
+private constructor(
+    override val codebase: PsiBasedCodebase,
+    private val ktTypeAlias: KtTypeAlias,
+    fileLocation: FileLocation,
+    modifiers: BaseModifierList,
+    aliasedType: TypeItem,
+    qualifiedName: String,
+    typeParameterList: TypeParameterList,
+    containingPackage: DefaultPackageItem,
+) :
+    DefaultTypeAliasItem(
+        codebase,
+        fileLocation,
+        modifiers,
+        PsiItemDocumentation.factory(ktTypeAlias, codebase),
+        ApiVariantSelectors.MUTABLE_FACTORY,
+        aliasedType,
+        qualifiedName,
+        typeParameterList,
+        containingPackage,
+    ),
+    PsiItem {
+
+    override fun psi(): PsiElement {
+        return ktTypeAlias
+    }
+
+    companion object {
+        /**
+         * Tries to create a [PsiTypeAliasItem] from the [ktTypeAlias]. May return null if the
+         * qualified name or type of the type alias can't be resolved.
+         */
+        fun create(ktTypeAlias: KtTypeAlias, codebase: PsiBasedCodebase): PsiTypeAliasItem? {
+            val qualifiedName = ktTypeAlias.getClassId()?.asFqNameString() ?: return null
+
+            val (typeParameterList, typeItemFactory) =
+                PsiTypeParameterList.create(
+                    codebase,
+                    codebase.globalTypeItemFactory,
+                    "typealias $qualifiedName",
+                    ktTypeAlias
+                )
+            val aliasedType = typeItemFactory.getTypeForKtElement(ktTypeAlias) ?: return null
+
+            val packageName = qualifiedName.substringBeforeLast(".")
+            val containingPackage = codebase.findOrCreatePackage(packageName)
+
+            val modifiers = PsiModifierItem.createForKtDeclaration(codebase, ktTypeAlias)
+
+            return PsiTypeAliasItem(
+                codebase = codebase,
+                ktTypeAlias = ktTypeAlias,
+                fileLocation = PsiFileLocation.fromPsiElement(ktTypeAlias),
+                modifiers = modifiers,
+                aliasedType = aliasedType,
+                qualifiedName = qualifiedName,
+                typeParameterList = typeParameterList,
+                containingPackage = containingPackage,
+            )
+        }
+    }
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
index 8030332eb..6d51f8862 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
@@ -41,7 +41,10 @@ import com.intellij.psi.util.TypeConversionUtil
 internal sealed class PsiTypeItem(
     val psiType: PsiType,
     modifiers: TypeModifiers,
+    val kotlinTypeInfo: KotlinTypeInfo?,
 ) : DefaultTypeItem(modifiers) {
+    /** Whether the [psiType] is originally a value class type. */
+    override fun isValueClassType(): Boolean = kotlinTypeInfo?.isValueClassType() ?: false
 
     /** Returns `true` if `this` type can be assigned from `other` without unboxing the other. */
     override fun isAssignableFromWithoutUnboxing(other: TypeItem): Boolean {
@@ -58,13 +61,19 @@ internal class PsiPrimitiveTypeItem(
     psiType: PsiType,
     override val kind: PrimitiveTypeItem.Primitive,
     modifiers: TypeModifiers,
-) : PrimitiveTypeItem, PsiTypeItem(psiType, modifiers) {
+    kotlinTypeInfo: KotlinTypeInfo?,
+) : PrimitiveTypeItem, PsiTypeItem(psiType, modifiers, kotlinTypeInfo) {
     @Deprecated(
         "implementation detail of this class",
         replaceWith = ReplaceWith("substitute(modifiers)"),
     )
     override fun duplicate(modifiers: TypeModifiers): PsiPrimitiveTypeItem =
-        PsiPrimitiveTypeItem(psiType = psiType, kind = kind, modifiers = modifiers)
+        PsiPrimitiveTypeItem(
+            psiType = psiType,
+            kind = kind,
+            modifiers = modifiers,
+            kotlinTypeInfo = kotlinTypeInfo,
+        )
 }
 
 /** A [PsiTypeItem] backed by a [PsiArrayType]. */
@@ -73,7 +82,8 @@ internal class PsiArrayTypeItem(
     override val componentType: TypeItem,
     override val isVarargs: Boolean,
     modifiers: TypeModifiers,
-) : ArrayTypeItem, PsiTypeItem(psiType, modifiers) {
+    kotlinTypeInfo: KotlinTypeInfo?,
+) : ArrayTypeItem, PsiTypeItem(psiType, modifiers, kotlinTypeInfo) {
     @Deprecated(
         "implementation detail of this class",
         replaceWith = ReplaceWith("substitute(modifiers, componentType)"),
@@ -84,6 +94,7 @@ internal class PsiArrayTypeItem(
             componentType = componentType,
             isVarargs = isVarargs,
             modifiers = modifiers,
+            kotlinTypeInfo = kotlinTypeInfo,
         )
 }
 
@@ -95,7 +106,8 @@ internal open class PsiClassTypeItem(
     final override val arguments: List<TypeArgumentTypeItem>,
     final override val outerClassType: ClassTypeItem?,
     modifiers: TypeModifiers,
-) : ClassTypeItem, PsiTypeItem(psiType, modifiers) {
+    kotlinTypeInfo: KotlinTypeInfo?,
+) : ClassTypeItem, PsiTypeItem(psiType, modifiers, kotlinTypeInfo) {
     override val className: String = ClassTypeItem.computeClassName(qualifiedName)
 
     private val asClassCache by
@@ -123,6 +135,7 @@ internal open class PsiClassTypeItem(
             arguments = arguments,
             outerClassType = outerClassType,
             modifiers = modifiers,
+            kotlinTypeInfo = kotlinTypeInfo,
         )
 }
 
@@ -137,6 +150,7 @@ internal class PsiLambdaTypeItem(
     override val receiverType: TypeItem?,
     override val parameterTypes: List<TypeItem>,
     override val returnType: TypeItem,
+    kotlinTypeInfo: KotlinTypeInfo?,
 ) :
     PsiClassTypeItem(
         codebase = codebase,
@@ -145,6 +159,7 @@ internal class PsiLambdaTypeItem(
         arguments = arguments,
         outerClassType = outerClassType,
         modifiers = modifiers,
+        kotlinTypeInfo = kotlinTypeInfo,
     ),
     LambdaTypeItem {
 
@@ -168,6 +183,7 @@ internal class PsiLambdaTypeItem(
             receiverType = receiverType,
             parameterTypes = parameterTypes,
             returnType = returnType,
+            kotlinTypeInfo = kotlinTypeInfo,
         )
     }
 }
@@ -177,7 +193,8 @@ internal class PsiVariableTypeItem(
     psiType: PsiType,
     modifiers: TypeModifiers,
     override val asTypeParameter: TypeParameterItem,
-) : VariableTypeItem, PsiTypeItem(psiType, modifiers) {
+    kotlinTypeInfo: KotlinTypeInfo?,
+) : VariableTypeItem, PsiTypeItem(psiType, modifiers, kotlinTypeInfo) {
 
     override val name: String = asTypeParameter.name()
 
@@ -190,6 +207,7 @@ internal class PsiVariableTypeItem(
             psiType = psiType,
             modifiers = modifiers,
             asTypeParameter = asTypeParameter,
+            kotlinTypeInfo = kotlinTypeInfo,
         )
 }
 
@@ -199,7 +217,8 @@ internal class PsiWildcardTypeItem(
     override val extendsBound: ReferenceTypeItem?,
     override val superBound: ReferenceTypeItem?,
     modifiers: TypeModifiers,
-) : WildcardTypeItem, PsiTypeItem(psiType, modifiers) {
+    kotlinTypeInfo: KotlinTypeInfo?,
+) : WildcardTypeItem, PsiTypeItem(psiType, modifiers, kotlinTypeInfo) {
     @Deprecated(
         "implementation detail of this class",
         replaceWith = ReplaceWith("substitute(modifiers, extendsBound, superBound)")
@@ -214,5 +233,6 @@ internal class PsiWildcardTypeItem(
             extendsBound = extendsBound,
             superBound = superBound,
             modifiers = modifiers,
+            kotlinTypeInfo = kotlinTypeInfo,
         )
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
index 8bb148731..a30118b69 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
@@ -32,6 +33,7 @@ import com.android.tools.metalava.model.WildcardTypeItem
 import com.android.tools.metalava.model.type.ContextNullability
 import com.android.tools.metalava.model.type.DefaultTypeItemFactory
 import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.android.tools.metalava.model.type.MethodFingerprint
 import com.intellij.psi.PsiAnnotation
 import com.intellij.psi.PsiArrayType
 import com.intellij.psi.PsiClassType
@@ -94,6 +96,38 @@ internal class PsiTypeItemFactory(
         return getType(underlyingType.psiType, underlyingType.context, contextNullability)
     }
 
+    override fun getMethodParameterType(
+        underlyingParameterType: PsiTypeInfo,
+        itemAnnotations: List<AnnotationItem>,
+        fingerprint: MethodFingerprint,
+        parameterIndex: Int,
+        isVarArg: Boolean
+    ): TypeItem {
+        // Workaround for b/388030457, b/388508139: when a vararg is used in kotlin for a parameter
+        // that isn't final, it should be a regular PsiArrayType, not a PsiEllipsisType, but psi
+        // gets it wrong in some cases.
+        val fixedUnderlyingParameterType =
+            if (
+                underlyingParameterType.context?.isKotlin() == true &&
+                    underlyingParameterType.psiType is PsiEllipsisType &&
+                    parameterIndex + 1 != fingerprint.parameterCount
+            ) {
+                underlyingParameterType.copy(
+                    psiType = underlyingParameterType.psiType.toArrayType()
+                )
+            } else {
+                underlyingParameterType
+            }
+
+        return super.getMethodParameterType(
+            fixedUnderlyingParameterType,
+            itemAnnotations,
+            fingerprint,
+            parameterIndex,
+            isVarArg
+        )
+    }
+
     /**
      * Returns a [PsiTypeItem] representing the [psiType]. The [context] is used to get nullability
      * information for Kotlin types.
@@ -154,7 +188,7 @@ internal class PsiTypeItemFactory(
      * no [PsiElement] with a defined [PsiType].
      */
     @OptIn(KaExperimentalApi::class)
-    internal fun getTypeForProperty(
+    internal fun getTypeForKtElement(
         ktElement: KtElement,
     ): PsiTypeItem? {
         val kotlinTypeInfo = KotlinTypeInfo.fromContext(ktElement)
@@ -265,12 +299,14 @@ internal class PsiTypeItemFactory(
                             contextNullability = contextNullability,
                         )
                     } else {
-                        createClassTypeItem(
-                            psiType = psiType,
-                            kotlinType = kotlinType,
-                            contextNullability = contextNullability,
-                            creatingClassTypeForClass = creatingClassTypeForClass,
-                        )
+                        val classType =
+                            createClassTypeItem(
+                                psiType = psiType,
+                                kotlinType = kotlinType,
+                                contextNullability = contextNullability,
+                                creatingClassTypeForClass = creatingClassTypeForClass,
+                            )
+                        checkForTypeAliasSubstitution(classType, contextNullability) ?: classType
                     }
                 }
             }
@@ -293,6 +329,51 @@ internal class PsiTypeItemFactory(
         }
     }
 
+    /**
+     * Checks if there are is a type alias matching the name of the [classTypeItem]. If there is,
+     * converts the aliased type for this usage (mapping type parameters and adjusting nullability).
+     *
+     * If there is no matching type alias, returns null.
+     */
+    private fun checkForTypeAliasSubstitution(
+        classTypeItem: PsiClassTypeItem,
+        contextNullability: ContextNullability
+    ): PsiTypeItem? {
+        // Don't bother checking for type aliases in non-KMP codebases because the substitution will
+        // already have happened in the UAST representation. Substitution won't have happened for
+        // expect/actual type aliases used from a common source set because the type is platform
+        // dependent. Metalava is just modeling the android/jvm platform, so the substitution needs
+        // to happen here.
+        if (!codebase.isMultiplatform) return null
+
+        val typeAlias = codebase.findTypeAlias(classTypeItem.qualifiedName) ?: return null
+
+        // Map type parameters of the type alias, if applicable.
+        val convertedType =
+            if (typeAlias.typeParameterList.isEmpty()) {
+                typeAlias.aliasedType
+            } else {
+                val typeParameterBindings =
+                    typeAlias.typeParameterList
+                        .zip(classTypeItem.arguments.map { it as ReferenceTypeItem })
+                        .toMap()
+                typeAlias.aliasedType.convertType(typeParameterBindings)
+            }
+
+        // Update type nullability: if the context requires a specific nullability, use that.
+        // If the aliased type is nullable, that propagates to the usage. Otherwise, use the
+        // nullability set by the usage site.
+        val nullability =
+            contextNullability.forcedNullability
+                ?: if (typeAlias.aliasedType.modifiers.isNullable) {
+                    TypeNullability.NULLABLE
+                } else {
+                    classTypeItem.modifiers.nullability
+                }
+
+        return convertedType.substitute(nullability) as PsiTypeItem
+    }
+
     /** Create a [PsiPrimitiveTypeItem]. */
     private fun createPrimitiveTypeItem(
         psiType: PsiPrimitiveType,
@@ -302,6 +383,7 @@ internal class PsiTypeItemFactory(
             psiType = psiType,
             kind = getKind(psiType),
             modifiers = createTypeModifiers(psiType, kotlinType, ContextNullability.forceNonNull),
+            kotlinTypeInfo = kotlinType,
         )
 
     /** Get the [PrimitiveTypeItem.Primitive] enum from the [PsiPrimitiveType]. */
@@ -342,6 +424,7 @@ internal class PsiTypeItemFactory(
                 ),
             isVarargs = psiType is PsiEllipsisType,
             modifiers = createTypeModifiers(psiType, kotlinType, contextNullability),
+            kotlinTypeInfo = kotlinType,
         )
 
     /** Create a [PsiClassTypeItem]. */
@@ -369,6 +452,7 @@ internal class PsiTypeItemFactory(
                     creatingClassTypeForClass = true,
                 ),
             modifiers = createTypeModifiers(psiType, kotlinType, contextNullability),
+            kotlinTypeInfo = kotlinType,
         )
     }
 
@@ -663,6 +747,7 @@ internal class PsiTypeItemFactory(
             receiverType = receiverType,
             parameterTypes = parameterTypes,
             returnType = returnType,
+            kotlinTypeInfo = kotlinType,
         )
     }
 
@@ -677,6 +762,7 @@ internal class PsiTypeItemFactory(
             psiType = psiType,
             modifiers = createTypeModifiers(psiType, kotlinType, contextNullability),
             asTypeParameter = typeParameterItem,
+            kotlinTypeInfo = kotlinType,
         )
 
     /** Create a [PsiWildcardTypeItem]. */
@@ -709,6 +795,7 @@ internal class PsiTypeItemFactory(
                     kotlinType.takeIf { psiType.isSuper },
                 ),
             modifiers = createTypeModifiers(psiType, kotlinType, ContextNullability.forceUndefined),
+            kotlinTypeInfo = kotlinType,
         )
 
     /**
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
index da561c1b2..38d578ea5 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
@@ -76,5 +76,25 @@ internal class PsiTypeParameterItem(
             }
             return false
         }
+
+        /**
+         * Creates a [DefaultTypeParameterItem] using the [ktTypeParameter]. Should be used only
+         * when there is no [PsiTypeParameter] available.
+         *
+         * The returned type parameter uses the default type implementation, which does not create a
+         * [PsiVariableTypeItem], as the analysis API doesn't have a direct way to create a psi type
+         * from the [KtTypeParameter].
+         */
+        fun create(
+            codebase: PsiBasedCodebase,
+            ktTypeParameter: KtTypeParameter
+        ): DefaultTypeParameterItem {
+            return DefaultTypeParameterItem(
+                codebase = codebase,
+                modifiers = PsiModifierItem.createForKtDeclaration(codebase, ktTypeParameter),
+                name = ktTypeParameter.name!!,
+                isReified = ktTypeParameter.text.startsWith(KtTokens.REIFIED_KEYWORD.value)
+            )
+        }
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
index 4f68c65a1..9240747c1 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
@@ -19,7 +19,10 @@ package com.android.tools.metalava.model.psi
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeParameterListAndFactory
+import com.intellij.psi.PsiTypeParameter
 import com.intellij.psi.PsiTypeParameterListOwner
+import org.jetbrains.kotlin.asJava.toPsiTypeParameters
+import org.jetbrains.kotlin.psi.KtTypeParameterListOwner
 
 internal object PsiTypeParameterList {
 
@@ -29,17 +32,70 @@ internal object PsiTypeParameterList {
         scopeDescription: String,
         psiOwner: PsiTypeParameterListOwner
     ): TypeParameterListAndFactory<PsiTypeItemFactory> {
-        val psiTypeParameterList =
-            psiOwner.typeParameterList
-                ?: return TypeParameterListAndFactory(
-                    TypeParameterList.NONE,
-                    enclosingTypeItemFactory
-                )
+        return create(
+            codebase,
+            enclosingTypeItemFactory,
+            scopeDescription,
+            psiOwner.typeParameterList?.typeParameters?.asList()
+        )
+    }
+
+    /**
+     * Generates a [PsiTypeParameterList] from the type parameters of the [ktOwner].
+     *
+     * Tries to converts each [KtTypeParameter] to a [PsiTypeParameter] using [toPsiTypeParameters],
+     * which gets a psi version of the type parameter for each psi element that uses the type
+     * parameter. For properties, this is the getter and optionally setter. Properties only can have
+     * type parameters if they have a receiver, and properties without receivers can't have backing
+     * fields, so they must have getters.
+     *
+     * If no psi version of the type parameters can be created (which is the case for type aliases,
+     * that only exist as kt elements), then the [KtTypeParameter]s are used directly.
+     */
+    fun create(
+        codebase: PsiBasedCodebase,
+        enclosingTypeItemFactory: PsiTypeItemFactory,
+        scopeDescription: String,
+        ktOwner: KtTypeParameterListOwner?
+    ): TypeParameterListAndFactory<PsiTypeItemFactory> {
+        val ktTypeParameters = ktOwner?.typeParameters
+        if (ktTypeParameters.isNullOrEmpty()) {
+            return TypeParameterListAndFactory(TypeParameterList.NONE, enclosingTypeItemFactory)
+        }
+
+        // Try to create the type parameter list with psi type parameters
+        val asPsiTypeParameters =
+            ktTypeParameters.mapNotNull { it.toPsiTypeParameters().singleOrNull() }
+        if (asPsiTypeParameters.isNotEmpty()) {
+            return create(codebase, enclosingTypeItemFactory, scopeDescription, asPsiTypeParameters)
+        }
+
+        // No psi type parameters could be created, use the kt type parameters directly.
+        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+            enclosingTypeItemFactory,
+            scopeDescription,
+            ktTypeParameters,
+            { PsiTypeParameterItem.create(codebase, it) },
+            // Bounds are not directly accessible from the analysis API. Type parameters of type
+            // aliases can't have bounds, so this is not a problem.
+            { _, _ -> emptyList() },
+        )
+    }
+
+    private fun create(
+        codebase: PsiBasedCodebase,
+        enclosingTypeItemFactory: PsiTypeItemFactory,
+        scopeDescription: String,
+        psiTypeParameters: List<PsiTypeParameter>?
+    ): TypeParameterListAndFactory<PsiTypeItemFactory> {
+        if (psiTypeParameters.isNullOrEmpty()) {
+            return TypeParameterListAndFactory(TypeParameterList.NONE, enclosingTypeItemFactory)
+        }
 
         return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
             enclosingTypeItemFactory,
             scopeDescription,
-            psiTypeParameterList.typeParameters.toList(),
+            psiTypeParameters,
             { PsiTypeParameterItem.create(codebase, it) },
             // Create bounds and store it in the [PsiTypeParameterItem.bounds] property.
             { typeItemFactory, psiTypeParameter ->
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
index 3ad3fe1e9..029feddcb 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
@@ -33,7 +33,6 @@ import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiExpression
 import com.intellij.psi.PsiField
 import com.intellij.psi.PsiLiteral
-import com.intellij.psi.PsiMethod
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
 import org.jetbrains.kotlin.asJava.elements.KtLightNullabilityAnnotation
 import org.jetbrains.uast.UAnnotation
@@ -49,22 +48,29 @@ import org.jetbrains.uast.util.isArrayInitializer
 
 internal class UAnnotationItem
 private constructor(
-    override val codebase: PsiBasedCodebase,
+    override val annotationContext: PsiBasedCodebase,
     val uAnnotation: UAnnotation,
     originalName: String,
     qualifiedName: String,
 ) :
     DefaultAnnotationItem(
-        codebase = codebase,
+        annotationContext = annotationContext,
         fileLocation = PsiFileLocation.fromPsiElement(uAnnotation.sourcePsi),
         originalName = originalName,
         qualifiedName = qualifiedName,
-        attributesGetter = { getAnnotationAttributes(codebase, uAnnotation) },
+        attributesGetter = { getAnnotationAttributes(annotationContext, uAnnotation) },
     ) {
 
     override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
         val sb = StringBuilder(60)
-        appendAnnotation(codebase, sb, uAnnotation, qualifiedName, target, showDefaultAttrs)
+        appendAnnotation(
+            annotationContext,
+            sb,
+            uAnnotation,
+            qualifiedName,
+            target,
+            showDefaultAttrs
+        )
         return sb.toString()
     }
 
@@ -96,11 +102,18 @@ private constructor(
             codebase: PsiBasedCodebase,
             uAnnotation: UAnnotation,
         ): AnnotationItem? {
-            val originalName = uAnnotation.qualifiedName ?: return null
+            // If the qualified name is a typealias, convert it to the aliased type because that is
+            // the version that will be present as a class in the codebase.
+            val originalName =
+                uAnnotation.qualifiedName?.let {
+                    (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName
+                        ?: it
+                }
+                    ?: return null
             val qualifiedName =
                 codebase.annotationManager.normalizeInputName(originalName) ?: return null
             return UAnnotationItem(
-                codebase = codebase,
+                annotationContext = codebase,
                 uAnnotation = uAnnotation,
                 originalName = originalName,
                 qualifiedName = qualifiedName,
@@ -344,7 +357,6 @@ internal class UAnnotationSingleAttributeValue(
             when (val resolved = psiValue.resolve()) {
                 is PsiField -> return codebase.findField(resolved)
                 is PsiClass -> return codebase.findOrCreateClass(resolved)
-                is PsiMethod -> return codebase.findCallableByPsiMethod(resolved)
             }
         }
         return null
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt
new file mode 100644
index 000000000..79d235922
--- /dev/null
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
+import com.android.tools.metalava.testing.kotlin
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+class PsiCodebasePropertyTest : BaseModelTest() {
+    @Test
+    fun `Test non-KMP codebase without project description`() {
+        runCodebaseTest(
+            kotlin(
+                "main/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    class Foo
+                """
+            )
+        ) {
+            assertThat((codebase as PsiBasedCodebase).isMultiplatform).isFalse()
+        }
+    }
+
+    @Test
+    fun `Test non-KMP codebase with project description`() {
+        val source =
+            kotlin(
+                "main/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    class Foo
+                """
+            )
+        runCodebaseTest(
+            inputSet(source),
+            projectDescription =
+                createProjectDescription(
+                    createModuleDescription(
+                        moduleName = "main",
+                        android = true,
+                        sourceFiles = arrayOf(source),
+                        dependsOn = emptyList()
+                    )
+                )
+        ) {
+            assertThat((codebase as PsiBasedCodebase).isMultiplatform).isFalse()
+        }
+    }
+
+    @Test
+    fun `Test KMP codebase`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    expect class Foo
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.android.kt",
+                """
+                    package test.pkg
+                    actual class Foo
+                """
+            )
+        runCodebaseTest(
+            inputSet(commonSource, androidSource),
+            projectDescription =
+                createProjectDescription(
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                )
+        ) {
+            assertThat((codebase as PsiBasedCodebase).isMultiplatform).isTrue()
+        }
+    }
+}
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
index a732d649d..df61c6037 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
@@ -51,26 +51,28 @@ class PsiFieldItemTest : BaseModelTest() {
         ) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val x = fooClass.fields().single()
-            assertNull(x.initialValue(false))
+            assertNull(x.legacyInitialValue(false))
         }
     }
 
     @Test
     fun `Duplicated field has correct nullability`() {
         runCodebaseTest(
-            java(
-                """
-                    package test.pkg;
-                    public class Foo {
-                        public final String foo = "string";
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-                    public class Bar extends Foo {}
-                """
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+                        public class Foo {
+                            public final String foo = "string";
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public class Bar extends Foo {}
+                    """
+                )
             )
         ) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt
index 2960a2feb..c897e0444 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt
@@ -27,8 +27,8 @@ class PsiFileLocationTest : BaseModelTest() {
      * Casts [item] to a [PsiItem] and gets the source psi of its underlying PsiElement. Generates a
      * baseline key, checking that the element ID of that key matches [expectedKey].
      */
-    private fun checkBaselineKeyFromSourcePsi(item: Item, expectedKey: String) {
-        val psi = (item as PsiItem).sourcePsi
+    private fun checkBaselineKeyFromPsi(item: Item, expectedKey: String) {
+        val psi = (item as PsiItem).psi()
         val baselineKey = PsiFileLocation.getBaselineKey(psi)
         assertEquals(expectedKey, baselineKey.elementId())
     }
@@ -36,24 +36,28 @@ class PsiFileLocationTest : BaseModelTest() {
     @Test
     fun `Baseline key for top level KtProperty`() {
         runCodebaseTest(
-            kotlin(
-                """
-                    package test.pkg
-                    val propertyInTestKt = 0
-                """
-            ),
-            kotlin(
-                """
-                    @file:JvmName("Foo")
-                    package test.pkg
-                    val propertyInFoo = 0
-                """
+            inputSet(
+                kotlin(
+                    "src/test/pkg/Test.kt",
+                    """
+                        package test.pkg
+                        val propertyInTestKt = 0
+                    """
+                ),
+                kotlin(
+                    "src/test/pkg/Foo.kt",
+                    """
+                        @file:JvmName("Foo")
+                        package test.pkg
+                        val propertyInFoo = 0
+                    """
+                )
             )
         ) {
             val testKtPropertyItem = codebase.assertClass("test.pkg.TestKt").properties().single()
-            checkBaselineKeyFromSourcePsi(testKtPropertyItem, "test.pkg.TestKt#propertyInTestKt")
+            checkBaselineKeyFromPsi(testKtPropertyItem, "test.pkg.TestKt#propertyInTestKt")
             val fooPropertyItem = codebase.assertClass("test.pkg.Foo").properties().single()
-            checkBaselineKeyFromSourcePsi(fooPropertyItem, "test.pkg.Foo#propertyInFoo")
+            checkBaselineKeyFromPsi(fooPropertyItem, "test.pkg.Foo#propertyInFoo")
         }
     }
 
@@ -70,7 +74,7 @@ class PsiFileLocationTest : BaseModelTest() {
             )
         ) {
             val foo = codebase.assertClass("test.pkg.Foo").methods().single()
-            checkBaselineKeyFromSourcePsi(
+            checkBaselineKeyFromPsi(
                 foo,
                 "test.pkg.Foo#foo(java.lang.String, java.util.List<? extends T>)"
             )
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
index 01fbba02a..1242966f6 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
@@ -17,6 +17,9 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.kotlin
 import kotlin.test.Test
 import kotlin.test.assertEquals
@@ -56,11 +59,10 @@ class PsiParameterItemTest : BaseModelTest() {
                     }
                 """
             )
-        runCodebaseTest(
-            inputSet(
-                kotlin(
-                    "jvmMain/src/Actual.kt",
-                    """
+        val androidSource =
+            kotlin(
+                "androidMain/src/Actual.kt",
+                """
                     actual suspend fun String.testFun(param: String) {}
                     actual class Test actual constructor(param: String) {
                         actual fun something(
@@ -70,10 +72,17 @@ class PsiParameterItemTest : BaseModelTest() {
                         ) {}
                     }
                     """
-                ),
+            )
+        runCodebaseTest(
+            inputSet(
+                androidSource,
                 commonSource,
             ),
-            commonSources = arrayOf(inputSet(commonSource)),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                )
         ) {
             // Expect classes are ignored by UAST/Kotlin light classes, verify we test actual
             // classes.
@@ -89,7 +98,6 @@ class PsiParameterItemTest : BaseModelTest() {
 
                 val parameter = parameters[1]
                 assertTrue(parameter.hasDefaultValue())
-                assertEquals("\"\"", parameter.defaultValueAsString())
 
                 // continuation
                 assertFalse(parameters[2].hasDefaultValue())
@@ -102,7 +110,6 @@ class PsiParameterItemTest : BaseModelTest() {
             with(constructorItem) {
                 val parameter = parameters().single()
                 assertTrue(parameter.hasDefaultValue())
-                assertEquals("\"\"", parameter.defaultValueAsString())
             }
 
             val methodItem = classItem.methods().single()
@@ -111,10 +118,8 @@ class PsiParameterItemTest : BaseModelTest() {
                 assertEquals(3, parameters.size)
 
                 assertTrue(parameters[0].hasDefaultValue())
-                assertEquals("\"\"", parameters[0].defaultValueAsString())
 
                 assertTrue(parameters[1].hasDefaultValue())
-                assertEquals("param + \"\"", parameters[1].defaultValueAsString())
 
                 assertFalse(parameters[2].hasDefaultValue())
             }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
index 18bd5255b..d0da46555 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
@@ -88,10 +88,10 @@ class PsiSourceParserTest : TemporaryFolderOwner, Assertions {
             )
             .parseSources(
                 createSourceSet(sources, directory),
-                SourceSet.empty(),
                 description = "Test Codebase",
                 classPath = emptyList(),
                 apiPackages = null,
+                projectDescription = null,
             )
     }
 
diff --git a/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt b/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
index c3f02d4c6..c4f1a1f3a 100644
--- a/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
@@ -10,6 +10,19 @@ com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTe
   annotation with enum values[java,k1]
   annotation with enum values[java,k2]
 
+com.android.tools.metalava.model.testsuite.typealiasitem.CommonTypeAliasItemTest
+  accessing type alias from codebase[kotlin,k1]
+  accessing type alias from package[kotlin,k1]
+  annotations on type alias[kotlin,k1]
+  basic type alias types[kotlin,k1]
+  expect actual typealias[kotlin,k1]
+  functional type alias type[kotlin,k1]
+  private type alias visibility[kotlin,k1]
+  type alias name[kotlin,k1]
+  type alias referencing other type alias[kotlin,k1]
+  type alias visibility[kotlin,k1]
+  type parameter lists on type aliases[kotlin,k1]
+
 com.android.tools.metalava.model.testsuite.typeitem.CommonTypeModifiersTest
   Test inner parameterized types with annotations[java,k1]
   Test inner parameterized types with annotations[java,k2]
@@ -26,3 +39,27 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeStringTest
   Type string[java,k1,null annotated parameterized inner type - kotlin nulls]
   Type string[java,k2,null annotated parameterized inner type - annotated]
   Type string[java,k2,null annotated parameterized inner type - kotlin nulls]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
+  testLegacySource[kotlin,k1,source,class array literal]
+  testLegacySource[kotlin,k1,source,class int array literal]
+  testLegacySource[kotlin,k1,source,class void primitive class]
+  testLegacySource[kotlin,k1,source,class void wrapper class]
+  testLegacySource[kotlin,k1,source,class]
+  testLegacySource[kotlin,k2,source,class array literal]
+  testLegacySource[kotlin,k2,source,class int array literal]
+  testLegacySource[kotlin,k2,source,class void primitive class]
+  testLegacySource[kotlin,k2,source,class void wrapper class]
+  testLegacySource[kotlin,k2,source,class]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
+  testLegacySource[kotlin,k1,source,class array literal]
+  testLegacySource[kotlin,k1,source,class int array literal]
+  testLegacySource[kotlin,k1,source,class void primitive class]
+  testLegacySource[kotlin,k1,source,class void wrapper class]
+  testLegacySource[kotlin,k1,source,class]
+  testLegacySource[kotlin,k2,source,class array literal]
+  testLegacySource[kotlin,k2,source,class int array literal]
+  testLegacySource[kotlin,k2,source,class void primitive class]
+  testLegacySource[kotlin,k2,source,class void wrapper class]
+  testLegacySource[kotlin,k2,source,class]
diff --git a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
index a5ae52c2c..c26fcb4a4 100644
--- a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
@@ -68,11 +68,6 @@ com.android.tools.metalava.model.testsuite.fielditem.SourceFieldItemTest
   test non final field with default value as constant expression[turbine]
 
 com.android.tools.metalava.model.testsuite.methoditem.CommonParameterItemTest
-  Test no default value[psi,java,k1]
-  Test no default value[psi,java,k2]
-  Test no default value[psi,kotlin,k1]
-  Test no default value[psi,kotlin,k2]
-  Test no default value[turbine]
   Test publicName reports correct name when called on binary class - Object#equals[turbine]
   Test publicName reports correct name when called on binary class - ViewGroup#onLayout[turbine]
 
@@ -87,6 +82,19 @@ com.android.tools.metalava.model.testsuite.packageitem.CommonPackageItemTest
   Test @hide in package info processed last[psi,java,k2]
   Test @hide in package info processed last[turbine]
 
+com.android.tools.metalava.model.testsuite.typealiasitem.CommonTypeAliasItemTest
+  accessing type alias from codebase[psi,kotlin,k1]
+  accessing type alias from package[psi,kotlin,k1]
+  annotations on type alias[psi,kotlin,k1]
+  basic type alias types[psi,kotlin,k1]
+  expect actual typealias[psi,kotlin,k1]
+  functional type alias type[psi,kotlin,k1]
+  private type alias visibility[psi,kotlin,k1]
+  type alias name[psi,kotlin,k1]
+  type alias referencing other type alias[psi,kotlin,k1]
+  type alias visibility[psi,kotlin,k1]
+  type parameter lists on type aliases[psi,kotlin,k1]
+
 com.android.tools.metalava.model.testsuite.typeitem.CommonIsAssignableFromTest
   Test assignability without unboxing[psi,java,k1,boxedInt to primitiveInt]
   Test assignability without unboxing[psi,java,k1,number to boxedInt]
@@ -133,3 +141,168 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeStringTest
   Type string[psi,java,k1,null annotated parameterized inner type - kotlin nulls]
   Type string[psi,java,k2,null annotated parameterized inner type - annotated]
   Type string[psi,java,k2,null annotated parameterized inner type - kotlin nulls]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
+  testLegacySource[psi,kotlin,k1,source,class array literal]
+  testLegacySource[psi,kotlin,k1,source,class int array literal]
+  testLegacySource[psi,kotlin,k1,source,class void primitive class]
+  testLegacySource[psi,kotlin,k1,source,class void wrapper class]
+  testLegacySource[psi,kotlin,k1,source,class]
+  testLegacySource[psi,kotlin,k2,source,class array literal]
+  testLegacySource[psi,kotlin,k2,source,class int array literal]
+  testLegacySource[psi,kotlin,k2,source,class void primitive class]
+  testLegacySource[psi,kotlin,k2,source,class void wrapper class]
+  testLegacySource[psi,kotlin,k2,source,class]
+  testLegacySource[text,source,String using constant]
+  testLegacySource[text,source,annotation]
+  testLegacySource[text,source,char escaped]
+  testLegacySource[text,source,char unicode]
+  testLegacySource[text,source,char]
+  testLegacySource[text,source,double NaN]
+  testLegacySource[text,source,double negative infinity]
+  testLegacySource[text,source,double positive infinity]
+  testLegacySource[text,source,double with exponent]
+  testLegacySource[text,source,float NaN]
+  testLegacySource[text,source,float negative infinity]
+  testLegacySource[text,source,float positive infinity]
+  testLegacySource[text,source,float with exponent]
+  testLegacySource[text,source,float with upper F]
+  testLegacySource[text,source,int negative]
+  testLegacySource[text,source,int positive]
+  testLegacySource[text,source,long with lower l]
+  testLegacySource[turbine,jar,annotation]
+  testLegacySource[turbine,jar,double NaN]
+  testLegacySource[turbine,jar,double negative infinity]
+  testLegacySource[turbine,jar,double positive infinity]
+  testLegacySource[turbine,jar,float NaN]
+  testLegacySource[turbine,jar,float negative infinity]
+  testLegacySource[turbine,jar,float positive infinity]
+  testLegacySource[turbine,source,String using constant]
+  testLegacySource[turbine,source,annotation]
+  testLegacySource[turbine,source,double NaN]
+  testLegacySource[turbine,source,double with int]
+  testLegacySource[turbine,source,float NaN]
+  testLegacySource[turbine,source,float with int]
+  testLegacySource[turbine,source,int positive]
+  testLegacySource[turbine,source,long with int]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
+  testLegacySource[text,source,String array]
+  testLegacySource[text,source,String using constant]
+  testLegacySource[text,source,annotation]
+  testLegacySource[text,source,char escaped]
+  testLegacySource[text,source,char unicode]
+  testLegacySource[text,source,char]
+  testLegacySource[text,source,class array literal]
+  testLegacySource[text,source,class void wrapper class]
+  testLegacySource[text,source,class]
+  testLegacySource[text,source,double NaN]
+  testLegacySource[text,source,double negative infinity]
+  testLegacySource[text,source,double positive infinity]
+  testLegacySource[text,source,double with exponent]
+  testLegacySource[text,source,float NaN]
+  testLegacySource[text,source,float negative infinity]
+  testLegacySource[text,source,float positive infinity]
+  testLegacySource[text,source,float with exponent]
+  testLegacySource[text,source,float with upper F]
+  testLegacySource[text,source,int positive]
+  testLegacySource[text,source,long with lower l]
+  testLegacySource[turbine,jar,annotation]
+  testLegacySource[turbine,jar,double NaN]
+  testLegacySource[turbine,jar,double negative infinity]
+  testLegacySource[turbine,jar,double positive infinity]
+  testLegacySource[turbine,jar,float NaN]
+  testLegacySource[turbine,jar,float negative infinity]
+  testLegacySource[turbine,jar,float positive infinity]
+  testLegacySource[turbine,source,annotation]
+  testLegacySource[turbine,source,double with int]
+  testLegacySource[turbine,source,float with int]
+  testLegacySource[turbine,source,long with int]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
+  testLegacySource[psi,kotlin,k1,source,class array literal]
+  testLegacySource[psi,kotlin,k1,source,class int array literal]
+  testLegacySource[psi,kotlin,k1,source,class void primitive class]
+  testLegacySource[psi,kotlin,k1,source,class void wrapper class]
+  testLegacySource[psi,kotlin,k1,source,class]
+  testLegacySource[psi,kotlin,k2,source,class array literal]
+  testLegacySource[psi,kotlin,k2,source,class int array literal]
+  testLegacySource[psi,kotlin,k2,source,class void primitive class]
+  testLegacySource[psi,kotlin,k2,source,class void wrapper class]
+  testLegacySource[psi,kotlin,k2,source,class]
+  testLegacySource[text,source,annotation]
+  testLegacySource[text,source,char escaped]
+  testLegacySource[text,source,char unicode]
+  testLegacySource[text,source,char]
+  testLegacySource[text,source,enum]
+  testLegacySource[turbine,jar,annotation]
+  testLegacySource[turbine,jar,char unicode]
+  testLegacySource[turbine,jar,double NaN]
+  testLegacySource[turbine,jar,double negative infinity]
+  testLegacySource[turbine,jar,double positive infinity]
+  testLegacySource[turbine,jar,float NaN]
+  testLegacySource[turbine,jar,float negative infinity]
+  testLegacySource[turbine,jar,float positive infinity]
+  testLegacySource[turbine,jar,int negative]
+  testLegacySource[turbine,source,String using constant]
+  testLegacySource[turbine,source,annotation]
+  testLegacySource[turbine,source,double NaN]
+  testLegacySource[turbine,source,double negative infinity]
+  testLegacySource[turbine,source,double positive infinity]
+  testLegacySource[turbine,source,double with exponent]
+  testLegacySource[turbine,source,double with int]
+  testLegacySource[turbine,source,enum]
+  testLegacySource[turbine,source,float NaN]
+  testLegacySource[turbine,source,float negative infinity]
+  testLegacySource[turbine,source,float positive infinity]
+  testLegacySource[turbine,source,float with exponent]
+  testLegacySource[turbine,source,float with int]
+  testLegacySource[turbine,source,float with upper F]
+  testLegacySource[turbine,source,int negative]
+  testLegacySource[turbine,source,int positive]
+  testLegacySource[turbine,source,long with int]
+  testLegacySource[turbine,source,long with lower l]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
+  testLegacySource[text,source,String using constant]
+  testLegacySource[text,source,class array literal]
+  testLegacySource[text,source,class int array literal]
+  testLegacySource[text,source,class void primitive class]
+  testLegacySource[text,source,class void wrapper class]
+  testLegacySource[text,source,class]
+  testLegacySource[text,source,double NaN]
+  testLegacySource[text,source,double negative infinity]
+  testLegacySource[text,source,double positive infinity]
+  testLegacySource[text,source,enum]
+  testLegacySource[text,source,float NaN]
+  testLegacySource[text,source,float negative infinity]
+  testLegacySource[text,source,float positive infinity]
+  testLegacySource[text,source,long with int]
+  testLegacySource[turbine,jar,double NaN]
+  testLegacySource[turbine,jar,double negative infinity]
+  testLegacySource[turbine,jar,double positive infinity]
+  testLegacySource[turbine,jar,float NaN]
+  testLegacySource[turbine,jar,float negative infinity]
+  testLegacySource[turbine,jar,float positive infinity]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
+  testLegacySource[text,source,String using constant]
+  testLegacySource[text,source,class array literal]
+  testLegacySource[text,source,class int array literal]
+  testLegacySource[text,source,class void primitive class]
+  testLegacySource[text,source,class void wrapper class]
+  testLegacySource[text,source,class]
+  testLegacySource[text,source,double NaN]
+  testLegacySource[text,source,double negative infinity]
+  testLegacySource[text,source,double positive infinity]
+  testLegacySource[text,source,enum]
+  testLegacySource[text,source,float NaN]
+  testLegacySource[text,source,float negative infinity]
+  testLegacySource[text,source,float positive infinity]
+  testLegacySource[text,source,long with int]
+  testLegacySource[turbine,jar,double NaN]
+  testLegacySource[turbine,jar,double negative infinity]
+  testLegacySource[turbine,jar,double positive infinity]
+  testLegacySource[turbine,jar,float NaN]
+  testLegacySource[turbine,jar,float negative infinity]
+  testLegacySource[turbine,jar,float positive infinity]
diff --git a/metalava-model-source/Android.bp b/metalava-model-source/Android.bp
index dc6ed0900..466801aec 100644
--- a/metalava-model-source/Android.bp
+++ b/metalava-model-source/Android.bp
@@ -23,6 +23,7 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     libs: [
         "metalava-model",
         "metalava-reporter",
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
index 05cc7f765..35028e696 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
@@ -37,7 +37,6 @@ interface EnvironmentManager : Closeable {
      * @param kotlinLanguageLevel the kotlin language level as a string, e.g. 1.8, etc.
      * @param modelOptions a set of model specific options provided by the caller.
      * @param jdkHome the optional path to the jdk home directory.
-     * @param projectDescription Lint project model that can describe project structures in detail.
      */
     fun createSourceParser(
         codebaseConfig: Codebase.Config,
@@ -46,7 +45,6 @@ interface EnvironmentManager : Closeable {
         modelOptions: ModelOptions = ModelOptions.empty,
         allowReadingComments: Boolean = true,
         jdkHome: File? = null,
-        projectDescription: File? = null,
     ): SourceParser
 }
 
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
index 7a8a053b3..564a0379e 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
@@ -35,33 +35,29 @@ interface SourceParser {
      * Parse a set of sources into a [Codebase].
      *
      * @param sourceSet the list of source files and root directories.
-     * @param commonSourceSet the list of source files and root directories in the common module.
      * @param description the description to use for [Codebase.description].
      * @param classPath the possibly empty list of jar files which may provide additional classes
      *   referenced by the sources.
      * @param apiPackages an optional [PackageFilter] that if specified will result in only
      *   including the source classes that match the filter in the
      *   [Codebase.getTopLevelClassesFromSource] list.
-     *
-     * "Common module" is the term used in Kotlin multi-platform projects where platform-agnostic
-     * business logic and `expect` declarations are declared. (Counterparts, like platform-specific
-     * logic and `actual` declarations are declared at platform-specific modules, of course.) To
-     * that end, [commonSourceSet] will be used for Kotlin multi-platform projects only. All others,
-     * such as Java only or non-KMP Kotlin projects, won't need to set it, i.e., should pass source
-     * files and root directories via [sourceSet], not [commonSourceSet].
+     * @param projectDescription Lint project model that can describe project structures in detail.
+     *   Only supported by the PSI model.
      */
     fun parseSources(
         sourceSet: SourceSet,
-        commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
         apiPackages: PackageFilter?,
+        projectDescription: File?,
     ): Codebase
 
     /**
      * Load a [Codebase] from a single jar.
      *
      * @param apiJar the jar file from which the [Codebase] will be loaded.
+     * @param classPath the possibly empty list of jar files which may provide additional classes
+     *   referenced by [apiJar].
      */
-    fun loadFromJar(apiJar: File): Codebase
+    fun loadFromJar(apiJar: File, classPath: List<File>): Codebase
 }
diff --git a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
index 6110ad6c3..4808548c2 100644
--- a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
+++ b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
@@ -54,6 +54,7 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
                 if (inputs.inputFormat == InputFormat.KOTLIN) {
                     addAll(getKotlinStdlibPaths())
                 }
+                addAll(inputs.testFixture.additionalClassPath)
             }
             val codebase =
                 createTestCodebase(
@@ -82,10 +83,10 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
             )
         return sourceParser.parseSources(
             sourceSet(inputs.mainSourceDir, inputs.additionalMainSourceDir),
-            sourceSet(inputs.commonSourceDir),
             description = "Test Codebase",
             classPath = classPath,
             apiPackages = testFixture.apiPackages,
+            projectDescription = inputs.projectDescription,
         )
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
index db7a8cf1d..b9e615f65 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
@@ -27,6 +27,8 @@ import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfigAware
+import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.ThrowingReporter
 import com.android.tools.metalava.testing.TemporaryFolderOwner
 import java.io.File
 import org.junit.Rule
@@ -81,9 +83,14 @@ abstract class BaseModelTest() :
     /**
      * The [InputFormat] of the test files that should be processed by this test. It must ignore all
      * other [InputFormat]s.
+     *
+     * The [CodebaseCreatorConfig.inputFormat] is nullable for running tests in `metalava` project
+     * as there is no single [InputFormat] that its runner uses as it mixes [InputFormat.JAVA] and
+     * [InputFormat.KOTLIN] side by side. However, it is always provided by the
+     * [ModelTestSuiteRunner].
      */
     protected val inputFormat
-        get() = codebaseCreatorConfig.inputFormat
+        get() = codebaseCreatorConfig.inputFormat!!
 
     @get:Rule override val temporaryFolder = TemporaryFolder()
 
@@ -118,11 +125,21 @@ abstract class BaseModelTest() :
             throw IllegalStateException("Must provide at least one source file")
         }
 
+        // Get the paths for the TestFiles.
+        val paths = testFiles.map { it.targetRelativePath }
+
+        // Fail if there are any name collisions.
+        val uniquePaths = paths.groupBy { it }
+        if (uniquePaths.size != testFiles.size) {
+            val colliding = uniquePaths.mapNotNull { if (it.value.size == 1) null else it.key }
+            error(
+                "The following test files in the input set have the same name as another test file:\n${colliding.joinToString("\n") { "    $it" }}"
+            )
+        }
+
         val inputFormat =
-            testFiles
+            paths
                 .asSequence()
-                // Map to path.
-                .map { it.targetRelativePath }
                 // Ignore HTML files.
                 .filter { !it.endsWith(".html") }
                 // Map to InputFormat.
@@ -141,16 +158,20 @@ abstract class BaseModelTest() :
         /** The newly created [Codebase]. */
         val codebase: Codebase
 
+        /** The [InputFormat] from which [codebase] was created. */
+        val inputFormat: InputFormat
+
         /** Replace any test run specific directories in [string] with a placeholder string. */
         fun removeTestSpecificDirectories(string: String): String
     }
 
     inner class DefaultCodebaseContext(
         override val codebase: Codebase,
-        private val mainSourceDir: File,
+        override val inputFormat: InputFormat,
+        private val fileToSymbol: Map<File, String>,
     ) : CodebaseContext {
         override fun removeTestSpecificDirectories(string: String): String {
-            return cleanupString(string, mainSourceDir)
+            return replaceFileWithSymbol(string, fileToSymbol)
         }
     }
 
@@ -166,56 +187,62 @@ abstract class BaseModelTest() :
         val apiPackages: PackageFilter? = null,
 
         /** The set of [ApiSurfaces] used in the test. */
-        val apiSurfaces: ApiSurfaces = ApiSurfaces.DEFAULT
+        val apiSurfaces: ApiSurfaces = ApiSurfaces.DEFAULT,
+
+        /** The [Reporter] to use for issues found creating the [Codebase]. */
+        val reporter: Reporter = ThrowingReporter.INSTANCE,
+
+        /** Additional jar files to add to the class path. */
+        val additionalClassPath: List<File> = emptyList(),
     ) {
         /** The [Codebase.Config] to use when creating a [Codebase] to test. */
         val codebaseConfig =
             Codebase.Config(
                 annotationManager = annotationManager,
                 apiSurfaces = apiSurfaces,
+                reporter = reporter,
             )
     }
 
     /**
-     * Create a [Codebase] from one of the supplied [inputSets] and then run a test on that
-     * [Codebase].
-     *
-     * The [InputSet] that is selected is the one whose [InputSet.inputFormat] is the same as the
-     * current [inputFormat]. There can be at most one of those.
+     * Create a [Codebase] from any supplied [inputSets] whose [InputSet.inputFormat] is the same as
+     * the current [inputFormat], and then runs a test on each [Codebase].
      */
     private fun createCodebaseFromInputSetAndRun(
         inputSets: Array<out InputSet>,
-        commonSourcesByInputFormat: Map<InputFormat, InputSet>,
+        projectDescription: TestFile?,
         testFixture: TestFixture,
         test: CodebaseContext.() -> Unit,
     ) {
-        // Run the input set that matches the current inputFormat, if there is one.
-        inputSets
-            .singleOrNull { it.inputFormat == inputFormat }
-            ?.let { inputSet ->
-                val mainSourceDir = sourceDir(inputSet)
-
-                val additionalSourceDir = inputSet.additionalTestFiles?.let { sourceDir(it) }
-
-                val commonSourceDir =
-                    commonSourcesByInputFormat[inputFormat]?.let { commonInputSet ->
-                        sourceDir(commonInputSet)
-                    }
-
-                val inputs =
-                    ModelSuiteRunner.TestInputs(
-                        inputFormat = inputSet.inputFormat,
-                        modelOptions = codebaseCreatorConfig.modelOptions,
-                        mainSourceDir = mainSourceDir,
-                        additionalMainSourceDir = additionalSourceDir,
-                        commonSourceDir = commonSourceDir,
-                        testFixture = testFixture,
+        // Run the input sets that match the current inputFormat.
+        for (inputSet in inputSets.filter { it.inputFormat == inputFormat }) {
+            val mainSourceDir = sourceDir(inputSet)
+            val projectDescriptionFile = projectDescription?.createFile(mainSourceDir.dir)
+
+            val additionalSourceDir = inputSet.additionalTestFiles?.let { sourceDir(it) }
+
+            val inputs =
+                ModelSuiteRunner.TestInputs(
+                    inputFormat = inputSet.inputFormat,
+                    modelOptions = codebaseCreatorConfig.modelOptions,
+                    mainSourceDir = mainSourceDir,
+                    additionalMainSourceDir = additionalSourceDir,
+                    testFixture = testFixture,
+                    projectDescription = projectDescriptionFile,
+                )
+            runner.createCodebaseAndRun(inputs) { codebase ->
+                val context =
+                    DefaultCodebaseContext(
+                        codebase,
+                        inputFormat,
+                        buildMap {
+                            this[mainSourceDir.dir] = "MAIN_SRC"
+                            additionalSourceDir?.dir?.let { dir -> this[dir] = "ADDITIONAL_SRC" }
+                        }
                     )
-                runner.createCodebaseAndRun(inputs) { codebase ->
-                    val context = DefaultCodebaseContext(codebase, mainSourceDir.dir)
-                    context.test()
-                }
+                context.test()
             }
+        }
     }
 
     private fun sourceDir(inputSet: InputSet): ModelSuiteRunner.SourceDir {
@@ -240,13 +267,11 @@ abstract class BaseModelTest() :
      */
     fun runCodebaseTest(
         vararg sources: TestFile,
-        commonSources: Array<TestFile> = emptyArray(),
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runCodebaseTest(
             sources = testFilesToInputSets(sources),
-            commonSources = testFilesToInputSets(commonSources),
             testFixture = testFixture,
             test = test,
         )
@@ -260,33 +285,13 @@ abstract class BaseModelTest() :
      */
     fun runCodebaseTest(
         vararg sources: InputSet,
-        commonSources: Array<InputSet> = emptyArray(),
+        projectDescription: TestFile? = null,
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
-    ) {
-        runCodebaseTest(
-            sources = sources,
-            commonSourcesByInputFormat = commonSources.associateBy { it.inputFormat },
-            testFixture = testFixture,
-            test = test,
-        )
-    }
-
-    /**
-     * Create a [Codebase] from one of the supplied [sources] [InputSet] and then run the [test] on
-     * that [Codebase].
-     *
-     * The [sources] array should have at most one [InputSet] of each [InputFormat].
-     */
-    private fun runCodebaseTest(
-        vararg sources: InputSet,
-        commonSourcesByInputFormat: Map<InputFormat, InputSet> = emptyMap(),
-        testFixture: TestFixture,
-        test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
-            commonSourcesByInputFormat = commonSourcesByInputFormat,
+            projectDescription = projectDescription,
             testFixture = testFixture,
             test = test,
         )
@@ -301,14 +306,13 @@ abstract class BaseModelTest() :
      */
     fun runSourceCodebaseTest(
         vararg sources: TestFile,
-        commonSources: Array<TestFile> = emptyArray(),
+        projectDescription: TestFile? = null,
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runSourceCodebaseTest(
             sources = testFilesToInputSets(sources),
-            commonSourcesByInputFormat =
-                testFilesToInputSets(commonSources).associateBy { it.inputFormat },
+            projectDescription = projectDescription,
             testFixture = testFixture,
             test = test,
         )
@@ -322,33 +326,13 @@ abstract class BaseModelTest() :
      */
     fun runSourceCodebaseTest(
         vararg sources: InputSet,
-        commonSources: Array<InputSet> = emptyArray(),
+        projectDescription: TestFile? = null,
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
-    ) {
-        runSourceCodebaseTest(
-            sources = sources,
-            commonSourcesByInputFormat = commonSources.associateBy { it.inputFormat },
-            testFixture = testFixture,
-            test = test,
-        )
-    }
-
-    /**
-     * Create a [Codebase] from one of the supplied [sources] [InputSet]s and then run the [test] on
-     * that [Codebase].
-     *
-     * The [sources] array should have at most one [InputSet] of each [InputFormat].
-     */
-    private fun runSourceCodebaseTest(
-        vararg sources: InputSet,
-        commonSourcesByInputFormat: Map<InputFormat, InputSet>,
-        testFixture: TestFixture,
-        test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
-            commonSourcesByInputFormat = commonSourcesByInputFormat,
+            projectDescription = projectDescription,
             testFixture = testFixture,
             test = test,
         )
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
index 13afa8732..6e42c0786 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
@@ -451,17 +451,17 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             val nullAnno = fieldItem.assertAnnotation("test.Nullable")
 
             val customAnno1 = fieldItem.assertAnnotation("test.anno.FieldInfo")
-            val custAnno1Attr1 = customAnno1.findAttribute("children")
-            val custAnno1Attr2 = customAnno1.findAttribute("val")
-            val custAnno1Attr3 = customAnno1.findAttribute("cls")
+            val custAnno1Attr1 = customAnno1.assertAttribute("children")
+            val custAnno1Attr2 = customAnno1.assertAttribute("val")
+            val custAnno1Attr3 = customAnno1.assertAttribute("cls")
             val annoClassItem1 = codebase.assertClass("test.anno.FieldInfo")
             val retAnno = annoClassItem1.assertAnnotation("java.lang.annotation.Retention")
             val tarAnno = annoClassItem1.assertAnnotation("java.lang.annotation.Target")
-            val tarAnnoAtrr1 = tarAnno.findAttribute("value")
+            val tarAnnoAttr1 = tarAnno.assertAttribute("value")
 
             val customAnno2 = fieldItem.assertAnnotation("anno.FieldValue")
             val annoClassItem2 = codebase.assertClass("anno.FieldValue")
-            val custAnno2Attr1 = customAnno2.findAttribute("value")
+            val custAnno2Attr1 = customAnno2.assertAttribute("value")
 
             assertEquals(3, fieldItem.modifiers.annotations().count())
 
@@ -469,23 +469,19 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
 
             assertEquals(3, customAnno1.attributes.count())
             assertEquals(false, customAnno1.isRetention())
-            assertNotNull(custAnno1Attr1)
-            assertNotNull(custAnno1Attr2)
-            assertNotNull(custAnno1Attr3)
             assertEquals(
                 true,
                 listOf("child1", "child2").toTypedArray() contentEquals
-                    custAnno1Attr1.value.value() as Array<*>
+                    custAnno1Attr1.legacyValue.value() as Array<*>
             )
-            assertEquals(5, custAnno1Attr2.value.value())
-            assertEquals("test.SimpleClass", custAnno1Attr3.value.value())
+            assertEquals(5, custAnno1Attr2.legacyValue.value())
+            assertEquals("test.SimpleClass", custAnno1Attr3.legacyValue.value())
             assertEquals(annoClassItem1, customAnno1.resolve())
             assertEquals(true, retAnno.isRetention())
             assertEquals(AnnotationRetention.RUNTIME, annoClassItem1.getRetention())
 
             assertEquals(annoClassItem2, customAnno2.resolve())
-            assertNotNull(custAnno2Attr1)
-            assertEquals(12, custAnno2Attr1.value.value())
+            assertEquals(12, custAnno2Attr1.legacyValue.value())
 
             assertEquals("@test.Nullable", nullAnno.toSource())
 
@@ -497,7 +493,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 "@java.lang.annotation.Target(java.lang.annotation.ElementType.FIELD)",
                 tarAnno.toSource()
             )
-            assertEquals(true, tarAnnoAtrr1!!.value is DefaultAnnotationSingleAttributeValue)
+            assertEquals(true, tarAnnoAttr1.legacyValue is DefaultAnnotationSingleAttributeValue)
         }
     }
 
@@ -871,45 +867,6 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
         }
     }
 
-    @Test
-    fun `230 test public name and default value of parameters`() {
-        runSourceCodebaseTest(
-            java(
-                """
-                    package test.pkg;
-
-                    import java.lang.annotation.ElementType;
-                    import java.lang.annotation.Target;
-
-                    public class Test {
-                        public void foo(@ParameterName("TestParam") @DefaultValue(5) int parameter) {
-                        }
-                    }
-
-                    @Target(ElementType.PARAMETER)
-                    @interface DefaultValue {
-                        int value();
-                    }
-
-                    @Target(ElementType.PARAMETER)
-                    @interface ParameterName {
-                        String value();
-                    }
-                """
-            ),
-        ) {
-            val methodItem = codebase.assertClass("test.pkg.Test").methods().single()
-            val paramItem = methodItem.parameters().single()
-
-            assertEquals("parameter", paramItem.name())
-            assertEquals(methodItem, paramItem.containingCallable())
-            assertEquals("TestParam", paramItem.publicName())
-            assertEquals(true, paramItem.hasDefaultValue())
-            assertEquals(true, paramItem.isDefaultValueKnown())
-            assertEquals("5", paramItem.defaultValueAsString())
-        }
-    }
-
     @Test
     fun `240 test documentations`() {
         runSourceCodebaseTest(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt
index 539367d0f..c2e645f04 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt
@@ -21,6 +21,8 @@ import com.android.tools.metalava.model.api.surface.ApiVariantType
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
 import kotlin.test.assertNull
+import kotlin.test.assertSame
+import kotlin.test.assertTrue
 import org.junit.Test
 
 @Suppress("JavadocDeclaration")
@@ -51,6 +53,7 @@ class CommonApiSurfacesTest : BaseModelTest() {
         ) {
             val apiSurfaces = codebase.apiSurfaces
             assertEquals("main", apiSurfaces.main.name, "main name")
+            assertTrue(apiSurfaces.main.isMain, "main is main")
             assertNull(apiSurfaces.base, "base not expected")
         }
     }
@@ -84,8 +87,9 @@ class CommonApiSurfacesTest : BaseModelTest() {
                 ),
         ) {
             val apiSurfaces = codebase.apiSurfaces
-            assertEquals("main", apiSurfaces.main.name, "main name")
-            assertEquals("base", apiSurfaces.base?.name, "base name")
+            // No need to check the state of the ApiSurfaces, just that it is passed through to the
+            // codebase untouched.
+            assertSame(fixtureApiSurfaces, apiSurfaces, "api surfaces gets passed through")
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListWriterTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListWriterTest.kt
index 10e531e71..20e5e6a8e 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListWriterTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListWriterTest.kt
@@ -26,10 +26,10 @@ import org.junit.Test
 /** Common tests for implementations of [ModifierListWriter]. */
 class CommonModifierListWriterTest : BaseModelTest() {
 
-    private fun Item.writeKeywords(normalize: Boolean = false): String {
+    private fun Item.writeKeywords(normalizeFinal: Boolean = false): String {
         val stringWriter = StringWriter()
         val writer = ModifierListWriter.forSignature(stringWriter, skipNullnessAnnotations = true)
-        writer.writeKeywords(this, normalize = normalize)
+        writer.writeKeywords(this, normalizeFinal = normalizeFinal)
         return stringWriter.toString().trimEnd()
     }
 
@@ -161,7 +161,7 @@ class CommonModifierListWriterTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val methodItem = testClass.methods().single()
 
-            assertEquals("public", methodItem.writeKeywords(normalize = true))
+            assertEquals("public", methodItem.writeKeywords(normalizeFinal = true))
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
index a083db1b2..7f516ce47 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
@@ -78,11 +78,11 @@ interface ModelSuiteRunner : FilterableCodebaseCreator {
          */
         val additionalMainSourceDir: SourceDir?,
 
-        /** The optional common sources. */
-        val commonSourceDir: SourceDir?,
-
         /** Additional information to provide to the test runner. */
         val testFixture: BaseModelTest.TestFixture,
+
+        /** An XML file describing the structure of the project (mainly used for KMP projects). */
+        val projectDescription: File?,
     )
 
     /**
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
index c27cfa577..56431da53 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
@@ -204,8 +204,8 @@ class CommonAnnotationItemTest : BaseModelTest() {
                       }
 
                       public @interface Test.Anno {
-                          method public Other annotationValue();
-                          method public Other[] annotationArrayValue();
+                          method public test.pkg.Other annotationValue();
+                          method public test.pkg.Other[] annotationArrayValue();
                       }
                     }
                 """
@@ -786,8 +786,8 @@ class CommonAnnotationItemTest : BaseModelTest() {
                       }
 
                       public @interface Test.Anno {
-                          method public Other annotationValue();
-                          method public Other[] annotationArrayValue();
+                          method public test.pkg.Other annotationValue();
+                          method public test.pkg.Other[] annotationArrayValue();
                       }
                     }
                 """
@@ -1288,7 +1288,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                       }
 
                       public @interface Test.Anno {
-                         method public Int value();
+                         method public int value();
                       }
                     }
                 """
@@ -1409,7 +1409,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                       floatValue = -0.5F,
                       intValue = -1,
                       longValue = -2L,
-                      shortValue = -3,
+                      shortValue = -3
                     )
                     public class Test {
                         public Test() {}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt
index efd9f749d..4fcac107f 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.model.testsuite.callableitem
 
-import com.android.tools.metalava.model.Assertions
+import com.android.tools.metalava.model.Assertions.Companion.assertClass
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.getCallableParameterDescriptorUsingDots
@@ -46,7 +46,7 @@ class CallableParameterDescriptorUsingDotsTest : BaseModelTest() {
         }
     }
 
-    companion object : Assertions {
+    companion object {
         private val params =
             listOf(
                 TestParams(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonAnnotationClassTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonAnnotationClassTest.kt
new file mode 100644
index 000000000..62da59f0a
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonAnnotationClassTest.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.classitem
+
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import junit.framework.TestCase.assertNull
+import kotlin.test.assertEquals
+import org.junit.Test
+
+/** Common tests for implementations of [ClassItem] that are `enum` classes. */
+class CommonAnnotationClassTest : BaseModelTest() {
+    @Test
+    fun `Test annotation class super class`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public @interface Foo {}
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    annotation class Foo { }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public @interface Foo {
+                      }
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val annotationClass = codebase.assertResolvedClass("java.lang.annotation.Annotation")
+
+            assertNull(fooClass.superClassType()?.asClass())
+            assertNull(fooClass.superClass())
+
+            val interfaceList = fooClass.interfaceTypes().map { it.asClass() }
+            assertEquals(listOf(annotationClass), interfaceList)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
index 8470936ac..f2caddfc7 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
@@ -25,6 +25,8 @@ import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.KnownSourceFiles.notTypeUseNonNullSource
+import com.android.tools.metalava.testing.KnownSourceFiles.notTypeUseNullableSource
 import com.android.tools.metalava.testing.KnownSourceFiles.typeUseOnlyNonNullSource
 import com.android.tools.metalava.testing.KnownSourceFiles.typeUseOnlyNullableSource
 import com.android.tools.metalava.testing.java
@@ -602,7 +604,7 @@ class CommonClassItemTest : BaseModelTest() {
             inputSet(
                 signature(
                     """
-                        // Signature format: 3.0
+                        // Signature format: 4.0
                         package test.pkg {
                           public class Generic<T, U> {
                           }
@@ -665,7 +667,7 @@ class CommonClassItemTest : BaseModelTest() {
             inputSet(
                 signature(
                     """
-                        // Signature format: 3.0
+                        // Signature format: 4.0
                         package test.pkg {
                           public interface Generic<T, U> {
                           }
@@ -1453,8 +1455,8 @@ class CommonClassItemTest : BaseModelTest() {
         // nullability annotation.
         runSourceCodebaseTest(
             inputSet(
-                typeUseOnlyNonNullSource,
-                typeUseOnlyNullableSource,
+                notTypeUseNonNullSource,
+                notTypeUseNullableSource,
                 java(
                     """
                         package test.pkg;
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt
index ceafaf609..fdb2e49d5 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.model.testsuite.classitem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.reporter.RecordingReporter
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
 import org.junit.Test
@@ -27,6 +28,7 @@ import org.junit.Test
 class CommonDuplicateClassItemTest : BaseModelTest() {
 
     private fun runDuplicateTest(test: CodebaseContext.() -> Unit) {
+        val recordingReporter = RecordingReporter()
         runCodebaseTest(
             inputSet(
                 java(
@@ -45,14 +47,22 @@ class CommonDuplicateClassItemTest : BaseModelTest() {
                     """
                 )
             ),
-            test = test,
-        )
+            testFixture = TestFixture(reporter = recordingReporter),
+        ) {
+            test()
+
+            val issues = removeTestSpecificDirectories(recordingReporter.issues)
+            assertEquals(
+                "MAIN_SRC/src2/test/pkg/Foo.java:3: warning: Attempted to register test.pkg.Foo twice; once from MAIN_SRC/src/test/pkg/Foo.java and this one from MAIN_SRC/src2/test/pkg/Foo.java [DuplicateSourceClass]",
+                issues
+            )
+        }
     }
 
     private fun CodebaseContext.checkCodebase(codebase: Codebase) {
         val fooClass = codebase.assertClass("test.pkg.Foo")
         assertEquals(
-            "TESTROOT/src/test/pkg/Foo.java",
+            "MAIN_SRC/src/test/pkg/Foo.java",
             removeTestSpecificDirectories(fooClass.fileLocation.path.toString())
         )
 
@@ -66,7 +76,7 @@ class CommonDuplicateClassItemTest : BaseModelTest() {
                 }
         assertEquals(
             """
-                TESTROOT/src/test/pkg/Foo.java
+                MAIN_SRC/src/test/pkg/Foo.java
             """
                 .trimIndent(),
             fooLocations
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonEnumTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonEnumTest.kt
index 56eed09ee..c057aceda 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonEnumTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonEnumTest.kt
@@ -23,10 +23,53 @@ import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
+import kotlin.test.assertEquals
+import kotlin.test.assertSame
 import org.junit.Test
 
 /** Common tests for implementations of [ClassItem] that are `enum` classes. */
 class CommonEnumTest : BaseModelTest() {
+    @Test
+    fun `Test enum class super class`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public enum Foo {
+                        FOO
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    enum class Foo {
+                        FOO
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public enum Foo {
+                        enum_constant public test.pkg.Foo FOO;
+                      }
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val enumClass = codebase.assertResolvedClass("java.lang.Enum")
+
+            assertSame(enumClass, fooClass.superClassType()?.asClass())
+            assertSame(enumClass, fooClass.superClass())
+
+            val interfaceList = fooClass.interfaceTypes()
+            assertEquals(emptyList(), interfaceList)
+        }
+    }
+
     @Test
     fun `Test enum synthetic methods are not included in the enum class`() {
         runCodebaseTest(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt
index e7953cbdc..c0301c7b9 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt
@@ -108,7 +108,6 @@ class CommonValueClassTest : BaseModelTest() {
             assertTrue(primaryConstructor.isPrimary, "Expected a primary constructor")
             val param = primaryConstructor.parameters().single()
             assertTrue(param.hasDefaultValue(), "Expected a default value")
-            assertEquals(param.defaultValue.value(), "0", "Expected a default value of 0")
         }
     }
 
@@ -142,4 +141,63 @@ class CommonValueClassTest : BaseModelTest() {
             assertNull(noAccessorsProperty.backingField)
         }
     }
+
+    @Test
+    fun `Modifiers on APIs using value classes in an interface`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    @JvmInline
+                    value class IntValue(private val value: Int)
+                    interface Interface {
+                        val abstractVal: IntValue
+                        fun abstractFun(): IntValue
+                        val defaultVal: IntValue
+                            get() = IntValue(0)
+                        fun defaultFun(): IntValue = IntValue(0)
+                    }
+                """
+            )
+        ) {
+            val interfaceClass = codebase.assertClass("test.pkg.Interface")
+            // Abstract APIs on interface
+            assertTrue(interfaceClass.assertProperty("abstractVal").modifiers.isAbstract())
+            assertTrue(interfaceClass.assertMethod("getAbstractVal", "").modifiers.isAbstract())
+            assertTrue(interfaceClass.assertMethod("abstractFun", "").modifiers.isAbstract())
+            // Default APIs on interface
+            assertTrue(interfaceClass.assertProperty("defaultVal").modifiers.isDefault())
+            assertTrue(interfaceClass.assertMethod("getDefaultVal", "").modifiers.isDefault())
+            assertTrue(interfaceClass.assertMethod("defaultFun", "").modifiers.isDefault())
+        }
+    }
+
+    @Test
+    fun `Modifiers on APIs using value classes in an abstract class`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    @JvmInline
+                    value class IntValue(private val value: Int)
+                    abstract class AbstractClass {
+                        abstract val abstractVal: IntValue
+                        abstract fun abstractFun(): IntValue
+                        val finalVal: IntValue = IntValue(0)
+                        fun finalFun(): IntValue = IntValue(0)
+                    }
+                """
+            )
+        ) {
+            val abstractClass = codebase.assertClass("test.pkg.AbstractClass")
+            // Abstract APIs on abstract class
+            assertTrue(abstractClass.assertProperty("abstractVal").modifiers.isAbstract())
+            assertTrue(abstractClass.assertMethod("getAbstractVal", "").modifiers.isAbstract())
+            assertTrue(abstractClass.assertMethod("abstractFun", "").modifiers.isAbstract())
+            // Final APIs on abstract class
+            assertTrue(abstractClass.assertProperty("finalVal").modifiers.isFinal())
+            assertTrue(abstractClass.assertMethod("getFinalVal", "").modifiers.isFinal())
+            assertTrue(abstractClass.assertMethod("finalFun", "").modifiers.isFinal())
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonItemDocumentationTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonItemDocumentationTest.kt
new file mode 100644
index 000000000..91ec36c22
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonItemDocumentationTest.kt
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.documentation
+
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertEquals
+import org.junit.Test
+
+class CommonItemDocumentationTest : BaseModelTest() {
+    @Test
+    fun `Test accessing documentation comment`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /**
+                     * Doc
+                     */
+                    public class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        public void otherMethod() {}
+
+                        /**
+                         * Method Doc
+                         */
+                        public void method() {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    /**
+                     * Doc
+                     */
+                    class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        fun otherMethod() {}
+
+                        /**
+                         * Method Doc
+                         */
+                        fun method() {}
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+            assertEquals(
+                """
+                    /**
+                     * Doc
+                     */
+                """
+                    .trimIndent(),
+                documentation.text.trim()
+            )
+
+            val methodDocumentation = testClass.methods().last().documentation
+            assertEquals(
+                """
+                    /**
+                         * Method Doc
+                         */
+                """
+                    .trimIndent(),
+                methodDocumentation.text.trim()
+            )
+        }
+    }
+
+    @Test
+    fun `Test accessing documentation comment after inline comment - bug 391104222`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /// Inline comment
+                    /**
+                     * Doc
+                     */
+                    public class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        public void otherMethod() {}
+
+                        /// Inline method comment
+                        /**
+                         * Method Doc
+                         */
+                        public void method() {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    /// Inline comment
+                    /**
+                     * Doc
+                     */
+                    class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        fun otherMethod() {}
+
+                        /// Inline method comment
+                        /**
+                         * Method Doc
+                         */
+                        fun method() {}
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+            assertEquals(
+                """
+                    /**
+                     * Doc
+                     */
+                """
+                    .trimIndent(),
+                documentation.text.trim()
+            )
+
+            val methodDocumentation = testClass.methods().last().documentation
+            assertEquals(
+                """
+                    /**
+                         * Method Doc
+                         */
+                """
+                    .trimIndent(),
+                methodDocumentation.text.trim()
+            )
+        }
+    }
+
+    @Test
+    fun `Test accessing documentation comment before inline comment - bug 391104222`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /**
+                     * Doc
+                     */
+                    /// Inline comment
+                    public class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        public void otherMethod() {}
+
+                        /**
+                         * Method Doc
+                         */
+                        /// Inline method comment
+                        public void method() {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    /**
+                     * Doc
+                     */
+                    /// Inline comment
+                    class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        fun otherMethod() {}
+
+                        /**
+                         * Method Doc
+                         */
+                        /// Inline method comment
+                        fun method() {}
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+            assertEquals(
+                """
+                    /**
+                     * Doc
+                     */
+                """
+                    .trimIndent(),
+                documentation.text.trim()
+            )
+
+            val methodDocumentation = testClass.methods().last().documentation
+            assertEquals(
+                """
+                    /**
+                         * Method Doc
+                         */
+                """
+                    .trimIndent(),
+                methodDocumentation.text.trim()
+            )
+        }
+    }
+
+    @Test
+    fun `Test does not treat standalone inline comment as documentation comment - bug 391104222`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /// Inline comment
+                    public class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        public void otherMethod() {}
+
+                        /// Inline method comment
+                        public void method() {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    /// Inline comment
+                    class Test {
+                        /**
+                         * Other Method Doc
+                         */
+                        fun otherMethod() {}
+
+                        /// Inline method comment
+                        fun method() {}
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+            assertEquals("", documentation.text)
+
+            val methodDocumentation = testClass.methods().last().documentation
+            assertEquals("", methodDocumentation.text.trim())
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
index 1ae44b717..e3b2ff3dd 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
@@ -44,7 +44,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
                           public interface Source {
                             field public int field;
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -88,7 +88,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
                           public interface Source {
                             field public static int field;
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -162,7 +162,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
                           public class Source {
                             field public int field;
                           }
-                          @Deprecated public class Target implements Source {
+                          @Deprecated public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -214,7 +214,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
                           @Deprecated public class Source {
                             field public int field;
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -266,7 +266,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
                           public class Source {
                             field @Deprecated public int field;
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
index 0782e9f79..53cbf6773 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
@@ -499,7 +499,7 @@ class CommonFieldItemTest : BaseModelTest() {
             val fields = testClass.fields()
             assertEquals(3, fields.size, message = "field count")
             for (field in fields) {
-                val value = field.initialValue(true) as Float
+                val value = field.legacyInitialValue(true) as Float
                 val valueBits = value.toBits()
                 assertEquals(
                     minNormalBits,
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
index cf6ea6347..af8e5cf9b 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
@@ -55,8 +55,8 @@ class SourceFieldItemTest : BaseModelTest() {
                     Double.POSITIVE_INFINITY,
                     61184.toChar(),
                 )
-            assertEquals(fieldValues, classItem.fields().map { it.initialValue(false) })
-            assertEquals(fieldValues, classItem.fields().map { it.initialValue(true) })
+            assertEquals(fieldValues, classItem.fields().map { it.legacyInitialValue(false) })
+            assertEquals(fieldValues, classItem.fields().map { it.legacyInitialValue(true) })
         }
     }
 
@@ -79,10 +79,10 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
-            assertEquals(38, fieldItem1.initialValue(true))
-            assertEquals(38, fieldItem1.initialValue(false))
-            assertEquals(91, fieldItem2.initialValue(true))
-            assertEquals(91, fieldItem2.initialValue(false))
+            assertEquals(38, fieldItem1.legacyInitialValue(true))
+            assertEquals(38, fieldItem1.legacyInitialValue(false))
+            assertEquals(91, fieldItem2.legacyInitialValue(true))
+            assertEquals(91, fieldItem2.legacyInitialValue(false))
         }
     }
 
@@ -112,10 +112,10 @@ class SourceFieldItemTest : BaseModelTest() {
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
 
-            assertEquals(null, fieldItem1.initialValue(false))
-            assertEquals(null, fieldItem1.initialValue(true))
-            assertEquals(null, fieldItem2.initialValue(true))
-            assertEquals(null, fieldItem2.initialValue(false))
+            assertEquals(null, fieldItem1.legacyInitialValue(false))
+            assertEquals(null, fieldItem1.legacyInitialValue(true))
+            assertEquals(null, fieldItem2.legacyInitialValue(true))
+            assertEquals(null, fieldItem2.legacyInitialValue(false))
         }
     }
 
@@ -136,8 +136,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("ENUM1")
 
-            assertNotNull(fieldItem.initialValue(true))
-            assertNotNull(fieldItem.initialValue(false))
+            assertNotNull(fieldItem.legacyInitialValue(true))
+            assertNotNull(fieldItem.legacyInitialValue(false))
         }
     }
 
@@ -156,8 +156,8 @@ class SourceFieldItemTest : BaseModelTest() {
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
-            assertEquals(null, fieldItem.initialValue(true))
-            assertNotNull(fieldItem.initialValue(false))
+            assertEquals(null, fieldItem.legacyInitialValue(true))
+            assertNotNull(fieldItem.legacyInitialValue(false))
         }
     }
 
@@ -177,8 +177,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
 
-            assertEquals(null, fieldItem.initialValue(true))
-            assertEquals(7, fieldItem.initialValue(false))
+            assertEquals(null, fieldItem.legacyInitialValue(true))
+            assertEquals(7, fieldItem.legacyInitialValue(false))
         }
     }
 
@@ -202,10 +202,10 @@ class SourceFieldItemTest : BaseModelTest() {
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
 
-            assertEquals(null, fieldItem1.initialValue(true))
-            assertEquals(27, fieldItem1.initialValue(false))
-            assertEquals(null, fieldItem2.initialValue(true))
-            assertEquals(91, fieldItem2.initialValue(false))
+            assertEquals(null, fieldItem1.legacyInitialValue(true))
+            assertEquals(27, fieldItem1.legacyInitialValue(false))
+            assertEquals(null, fieldItem2.legacyInitialValue(true))
+            assertEquals(91, fieldItem2.legacyInitialValue(false))
         }
     }
 
@@ -224,8 +224,8 @@ class SourceFieldItemTest : BaseModelTest() {
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
-            assertEquals(null, fieldItem.initialValue(true))
-            assertNotNull(fieldItem.initialValue(false))
+            assertEquals(null, fieldItem.legacyInitialValue(true))
+            assertNotNull(fieldItem.legacyInitialValue(false))
         }
     }
 
@@ -264,8 +264,8 @@ class SourceFieldItemTest : BaseModelTest() {
             )
             assertEquals(fieldItem.type(), duplicateField.type(), message = "duplicated types")
             assertEquals(
-                fieldItem.initialValue(),
-                duplicateField.initialValue(),
+                fieldItem.legacyInitialValue(),
+                duplicateField.legacyInitialValue(),
                 message = "duplicated initial value"
             )
             assertEquals(classItem, duplicateField.inheritedFrom, message = "inheritedFrom")
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/flags/CommonFlagTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/flags/CommonFlagTest.kt
new file mode 100644
index 000000000..c2bf710ff
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/flags/CommonFlagTest.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.flags
+
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
+import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
+import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.api.flags.ApiFlags
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.KnownJarFiles
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import kotlin.test.assertSame
+import org.junit.Test
+
+class CommonFlagTest : BaseModelTest() {
+
+    private fun runFlagsTest(
+        apiFlags: ApiFlags?,
+        test: CodebaseContext.() -> Unit,
+    ) {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    import android.annotation.FlaggedApi;
+                    @FlaggedApi("test.pkg.flags.flag_name")
+                    public class Foo {
+                        private Foo() {}
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      @FlaggedApi("test.pkg.flags.flag_name") public class Foo {
+                      }
+                    }
+                """
+            ),
+            testFixture =
+                TestFixture(
+                    annotationManager =
+                        DefaultAnnotationManager(
+                            DefaultAnnotationManager.Config(
+                                apiFlags = apiFlags,
+                            )
+                        ),
+                    additionalClassPath = listOf(KnownJarFiles.stubAnnotationsJar),
+                ),
+            test = test,
+        )
+    }
+
+    @Test
+    fun `Test no flags`() {
+        runFlagsTest(
+            apiFlags = null,
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val annotation = fooClass.assertAnnotation(ANDROID_FLAGGED_API)
+
+            val apiFlag = annotation.apiFlag
+            assertNull(apiFlag, "apiFlag")
+            assertEquals(Showability.NO_EFFECT, annotation.showability, "showability")
+            assertEquals(ANNOTATION_IN_ALL_STUBS, annotation.targets, "targets")
+        }
+    }
+
+    @Test
+    fun `Test empty flags`() {
+        runFlagsTest(
+            apiFlags = ApiFlags(byQualifiedName = emptyMap()),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val annotation = fooClass.assertAnnotation(ANDROID_FLAGGED_API)
+
+            val apiFlag = annotation.apiFlag
+            assertSame(ApiFlag.REVERT_FLAGGED_API, apiFlag, "apiFlag")
+            assertEquals(Showability.REVERT_UNSTABLE_API, annotation.showability, "showability")
+            assertEquals(NO_ANNOTATION_TARGETS, annotation.targets, "targets")
+        }
+    }
+
+    @Test
+    fun `Test with flags finalized`() {
+        runFlagsTest(
+            apiFlags =
+                ApiFlags(
+                    byQualifiedName =
+                        mapOf("test.pkg.flags.flag_name" to ApiFlag.FINALIZE_FLAGGED_API)
+                ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val annotation = fooClass.assertAnnotation(ANDROID_FLAGGED_API)
+
+            val apiFlag = annotation.apiFlag
+            assertSame(ApiFlag.FINALIZE_FLAGGED_API, apiFlag, "apiFlag")
+            assertEquals(Showability.NO_EFFECT, annotation.showability, "showability")
+            assertEquals(NO_ANNOTATION_TARGETS, annotation.targets, "targets")
+        }
+    }
+
+    @Test
+    fun `Test with flags keep`() {
+        runFlagsTest(
+            apiFlags =
+                ApiFlags(
+                    byQualifiedName = mapOf("test.pkg.flags.flag_name" to ApiFlag.KEEP_FLAGGED_API)
+                ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val annotation = fooClass.assertAnnotation(ANDROID_FLAGGED_API)
+
+            val apiFlag = annotation.apiFlag
+            assertSame(ApiFlag.KEEP_FLAGGED_API, apiFlag, "apiFlag")
+            assertEquals(Showability.NO_EFFECT, annotation.showability, "showability")
+            assertEquals(ANNOTATION_IN_ALL_STUBS, annotation.targets, "targets")
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
index f00b52e0d..939a95bfa 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
@@ -52,7 +52,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
     }
 
     companion object {
-        @JvmStatic @Parameterized.Parameters fun comparisons() = CopyMethod.values()
+        @JvmStatic @Parameterized.Parameters fun comparisons() = CopyMethod.entries
     }
 
     /**
@@ -85,7 +85,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public interface Source {
                             method public void method();
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -129,7 +129,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public interface Source {
                             method public default void method();
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -174,7 +174,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public interface Source {
                             method public static void method();
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -218,7 +218,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public class Source {
                             method public void method();
                           }
-                          public final class Target implements Source {
+                          public final class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -265,7 +265,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public class Source {
                             method public void method();
                           }
-                          @Deprecated public class Target implements Source {
+                          @Deprecated public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -317,7 +317,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           @Deprecated public class Source {
                             method public void method();
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
@@ -369,7 +369,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
                           public class Source {
                             method @Deprecated public void method();
                           }
-                          public class Target implements Source {
+                          public class Target implements test.pkg.Source {
                           }
                         }
                     """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonInlineMethodTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonInlineMethodTest.kt
new file mode 100644
index 000000000..33bd4a0cd
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonInlineMethodTest.kt
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.methoditem
+
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertTrue
+import org.junit.Test
+
+class CommonInlineMethodTest : BaseModelTest() {
+    @Test
+    fun `Test modifiers on inline reified fun`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    open class Foo {
+                        inline fun <reified V> reifiedInlineFun() {}
+                    }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val reifiedInlineFun = fooClass.assertMethod("reifiedInlineFun", "")
+            assertTrue(reifiedInlineFun.modifiers.isFinal())
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
index 1d6934fdb..0239b6ad8 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
@@ -19,6 +19,9 @@ package com.android.tools.metalava.model.testsuite.methoditem
 import com.android.tools.metalava.model.JAVA_LANG_THROWABLE
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import kotlin.test.assertEquals
@@ -391,7 +394,66 @@ class CommonMethodItemTest : BaseModelTest() {
                     "java.lang.Integer.class",
                     "test.pkg.TestAnnotation.InnerEnum.ENUM1"
                 )
-            assertEquals(values, classItem.methods().map { it.defaultValue() })
+            assertEquals(values, classItem.methods().map { it.legacyDefaultValue() })
+        }
+    }
+
+    @Test
+    fun `JvmOverloads methods`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    import kotlin.jvm.JvmOverloads
+                    expect class Foo {
+                        @JvmOverloads
+                        fun allOptionalJvmOverloads(p1: Int = 0, p2: Int = 0, p3: Int = 0)
+
+                        @JvmOverloads
+                        fun someOptionalJvmOverloads(p1: Int, p2: Long = 0L, p3: Int, p4: Float = 0F, p5: Int)
+                    }
+                """
+            )
+        // @JvmOverloads needs to be annotated on the actual fun too, but the default values can't
+        // be present on actuals
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    actual class Foo {
+                        @JvmOverloads
+                        actual fun allOptionalJvmOverloads(p1: Int, p2: Int, p3: Int) = Unit
+
+                        @JvmOverloads
+                        actual fun someOptionalJvmOverloads(p1: Int, p2: Long, p3: Int, p4: Float, p5: Int) = Unit
+                    }
+                """
+            )
+        runCodebaseTest(
+            inputSet(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            // check all overloads for `allOptionalJvmOverloads` are present
+            fooClass.assertMethod("allOptionalJvmOverloads", "")
+            fooClass.assertMethod("allOptionalJvmOverloads", "int")
+            fooClass.assertMethod("allOptionalJvmOverloads", "int,int")
+            fooClass.assertMethod("allOptionalJvmOverloads", "int,int,int")
+
+            // check all overloads for `someOptionalJvmOverloads` are present
+            fooClass.assertMethod("someOptionalJvmOverloads", "int,int,int")
+            fooClass.assertMethod("someOptionalJvmOverloads", "int,long,int,int")
+            fooClass.assertMethod("someOptionalJvmOverloads", "int,long,int,float,int")
+
+            // check that there aren't any other methods present
+            assertEquals(fooClass.methods().size, 7)
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
index a7905a7f5..9148421b7 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.model.testsuite.methoditem
 
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
@@ -26,7 +25,6 @@ import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertWithMessage
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNull
-import org.junit.Assert.assertThrows
 import org.junit.Test
 
 /** Common tests for implementations of [ParameterItem]. */
@@ -131,20 +129,6 @@ class CommonParameterItemTest : BaseModelTest() {
                     """
                 ),
             ),
-            inputSet(
-                KnownSourceFiles.supportParameterName,
-                java(
-                    """
-                        package test.pkg;
-
-                        import androidx.annotation.ParameterName;
-
-                        public class Bar {
-                            public void foo(@ParameterName("baz") int baz) {}
-                        }
-                    """
-                ),
-            ),
             inputSet(
                 kotlin(
                     """
@@ -214,11 +198,11 @@ class CommonParameterItemTest : BaseModelTest() {
                     .assertMethod("equals", "java.lang.Object")
                     .parameters()
                     .single()
-            // For some reason Object.equals(Object obj) provides the actual parameter name.
-            // Probably, because it was compiled with a late enough version of javac, and/or with
-            // the appropriate options to record the parameter name.
+            // The parameter name of the Object.equals(Object obj) method is stored in the Object
+            // class but `publicName()` should still return null because the parameter name is not
+            // part of the API of java classes.
             assertEquals("name()", "obj", parameterItem.name())
-            assertEquals("publicName()", "obj", parameterItem.publicName())
+            assertNull("publicName()", parameterItem.publicName())
         }
     }
 
@@ -623,7 +607,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 """
                     // Signature format: 5.0
                     // - language=kotlin
-                    // - concise-default-values=no
+                    // - include-default-parameter-values=no
                     // - kotlin-name-type-order=yes
                     package test.pkg {
                       public final class Foo {
@@ -655,75 +639,6 @@ class CommonParameterItemTest : BaseModelTest() {
             val parameter =
                 codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
             assertEquals("hasDefaultValue", false, parameter.hasDefaultValue())
-            assertEquals("isDefaultValueKnown", false, parameter.isDefaultValueKnown())
-            // TODO: Improve consistency of the following.
-            when (parameter.itemLanguage) {
-                ItemLanguage.KOTLIN -> {
-                    assertEquals(
-                        "defaultValue",
-                        "__invalid_value__",
-                        parameter.defaultValueAsString()
-                    )
-                }
-                ItemLanguage.JAVA -> {
-                    assertEquals("defaultValue", null, parameter.defaultValueAsString())
-                }
-                ItemLanguage.UNKNOWN -> {
-                    val exception =
-                        assertThrows(IllegalStateException::class.java) {
-                            parameter.defaultValueAsString()
-                        }
-                    assertEquals(
-                        "defaultValue",
-                        "cannot call on NONE DefaultValue",
-                        exception.message
-                    )
-                }
-            }
-        }
-    }
-
-    @Test
-    fun `Test null default value`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 5.0
-                    // - language=kotlin
-                    // - concise-default-values=no
-                    // - kotlin-name-type-order=yes
-                    package test.pkg {
-                      public final class Foo {
-                        ctor public Foo();
-                        method public method(s: String? = null): void;
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    public class Foo {
-                        public void method(@other.DefaultValue("null") String s) {}
-                    }
-                """
-            ),
-            kotlin(
-                """
-                    package test.pkg
-
-                    class Foo {
-                        fun method(s: String? = null) {}
-                    }
-                """
-            ),
-        ) {
-            val parameter =
-                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
-            assertEquals("hasDefaultValue", true, parameter.hasDefaultValue())
-            assertEquals("isDefaultValueKnown", true, parameter.isDefaultValueKnown())
-            assertEquals("defaultValue", "null", parameter.defaultValueAsString())
         }
     }
 
@@ -738,7 +653,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 """
                     // Signature format: 5.0
                     // - language=kotlin
-                    // - concise-default-values=yes
+                    // - include-default-parameter-values=yes
                     // - kotlin-name-type-order=yes
                     package test.pkg {
                       public final class Foo {
@@ -752,11 +667,6 @@ class CommonParameterItemTest : BaseModelTest() {
             val parameter =
                 codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
             assertEquals("hasDefaultValue", true, parameter.hasDefaultValue())
-
-            assertEquals("isDefaultValueKnown", false, parameter.isDefaultValueKnown())
-            val exception =
-                assertThrows(IllegalStateException::class.java) { parameter.defaultValueAsString() }
-            assertEquals("defaultValue", "cannot call on UNKNOWN DefaultValue", exception.message)
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
index b0444ec53..36525e0eb 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
@@ -19,9 +19,11 @@ package com.android.tools.metalava.model.testsuite.packageitem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.reporter.RecordingReporter
 import com.android.tools.metalava.testing.KnownSourceFiles.nonNullSource
 import com.android.tools.metalava.testing.html
 import com.android.tools.metalava.testing.java
+import kotlin.test.assertContains
 import kotlin.test.assertEquals
 import kotlin.test.assertNull
 import org.junit.Test
@@ -215,7 +217,7 @@ class CommonPackageItemTest : BaseModelTest() {
             val packageItem = codebase.assertPackage("test.pkg")
             val packageLocation = packageItem.fileLocation.path.toString()
 
-            assertEquals("TESTROOT/api.txt", removeTestSpecificDirectories(packageLocation))
+            assertEquals("MAIN_SRC/api.txt", removeTestSpecificDirectories(packageLocation))
         }
     }
 
@@ -243,7 +245,7 @@ class CommonPackageItemTest : BaseModelTest() {
             val packageLocation = packageItem.fileLocation.path.toString()
 
             assertEquals(
-                "TESTROOT/src/test/pkg/package-info.java",
+                "MAIN_SRC/src/test/pkg/package-info.java",
                 removeTestSpecificDirectories(packageLocation)
             )
         }
@@ -306,7 +308,7 @@ class CommonPackageItemTest : BaseModelTest() {
             val packageLocation = packageItem.fileLocation.path.toString()
 
             assertEquals(
-                "TESTROOT/src/test/pkg/package.html",
+                "MAIN_SRC/src/test/pkg/package.html",
                 removeTestSpecificDirectories(packageLocation)
             )
         }
@@ -421,6 +423,7 @@ class CommonPackageItemTest : BaseModelTest() {
 
     @Test
     fun `Test mismatching between package and directory`() {
+        val recordingReporter = RecordingReporter()
         runCodebaseTest(
             java(
                 "src/test/other/Foo.java",
@@ -431,8 +434,20 @@ class CommonPackageItemTest : BaseModelTest() {
                     }
                 """
             ),
+            testFixture = TestFixture(reporter = recordingReporter),
         ) {
             codebase.assertClass("test.pkg.Foo")
+            // Make sure that if any errors are reported that they are included in this list of
+            // known errors. This is needed because K1 produces both errors, but K2 only produces
+            // the first error. This test is currently broken for Turbine.
+            assertContains(
+                """
+                    MAIN_SRC/src/test/other/Foo.java: error: Unable to determine the package name. This usually means that a source file was where the directory does not seem to match the package declaration; we expected the path MAIN_SRC/src/test/other/Foo.java to end with /test/pkg/Foo.java [IoError]
+                    MAIN_SRC/src/test/other/Foo.java:3: error: Could not find package test.pkg for class test.pkg.Foo. This is most likely due to a mismatch between the package statement and the directory MAIN_SRC/src/test/other [InvalidPackage]
+                """
+                    .trimIndent(),
+                removeTestSpecificDirectories(recordingReporter.issues)
+            )
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
index 8a1be415d..57ed6d6c9 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
@@ -16,11 +16,14 @@
 
 package com.android.tools.metalava.model.testsuite.propertyitem
 
+import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
+import kotlin.test.assertNull
+import kotlin.test.assertTrue
 import org.junit.Assert.assertEquals
 import org.junit.Test
 
@@ -576,4 +579,532 @@ class CommonPropertyItemTest : BaseModelTest() {
             assertThat(valuePropertyOnCompanion.getter).isEqualTo(valueGetterOnCompanion)
         }
     }
+
+    @Test
+    fun `Test top level properties`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+
+                    var variable = 0
+
+                    val valWithNoBackingField
+                        get() = 0
+
+                    const val CONST = 0
+
+                    @JvmField
+                    val jvmField = 0
+                """
+            )
+        ) {
+            val fileFacadeClass = codebase.assertClass("test.pkg.Foo")
+            assertThat(fileFacadeClass.properties()).hasSize(4)
+
+            // var property with getter, setter, and backing field
+            val variable = fileFacadeClass.assertProperty("variable")
+            assertThat(variable.getter).isNotNull()
+            assertThat(variable.setter).isNotNull()
+            assertThat(variable.backingField).isNotNull()
+            assertThat(variable.constructorParameter).isNull()
+
+            // val property with getter, no setter or backing field
+            val valWithNoBackingField = fileFacadeClass.assertProperty("valWithNoBackingField")
+            assertThat(valWithNoBackingField.getter).isNotNull()
+            assertThat(valWithNoBackingField.setter).isNull()
+            assertThat(valWithNoBackingField.backingField).isNull()
+            assertThat(valWithNoBackingField.constructorParameter).isNull()
+
+            // const val doesn't have accessors, but does have backing field
+            val constVal = fileFacadeClass.assertProperty("CONST")
+            assertThat(constVal.getter).isNull()
+            assertThat(constVal.setter).isNull()
+            assertThat(constVal.backingField).isNotNull()
+            assertThat(constVal.constructorParameter).isNull()
+
+            // jvmfield val doesn't have accessors, but does have backing field
+            val jvmField = fileFacadeClass.assertProperty("jvmField")
+            assertThat(jvmField.getter).isNull()
+            assertThat(jvmField.setter).isNull()
+            assertThat(jvmField.backingField).isNotNull()
+            assertThat(jvmField.constructorParameter).isNull()
+        }
+    }
+
+    @Test
+    fun `Test top level extension properties`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+
+                    var String.stringExtension
+                        get() = 0
+                        set(value) {}
+                """
+            )
+        ) {
+            val fileFacadeClass = codebase.assertClass("test.pkg.Foo")
+            assertThat(fileFacadeClass.properties()).hasSize(1)
+
+            // extension property has getter and setter, but no backing field
+            val stringExtension = fileFacadeClass.assertProperty("stringExtension")
+            assertThat(stringExtension.getter).isNotNull()
+            assertThat(stringExtension.setter).isNotNull()
+            assertThat(stringExtension.backingField).isNull()
+            assertThat(stringExtension.constructorParameter).isNull()
+        }
+    }
+
+    @Test
+    fun `Value class extension properties`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+
+                    value class IntValue(val value: Int)
+
+                    var IntValue.valueClassExtension
+                        get() = 0
+                        set(value) {}
+                """
+            )
+        ) {
+            val fileFacadeClass = codebase.assertClass("test.pkg.Foo")
+            assertThat(fileFacadeClass.properties()).hasSize(1)
+
+            // extension property has getter and setter, but no backing field
+            val valueClassExtension = fileFacadeClass.assertProperty("valueClassExtension")
+            assertThat(valueClassExtension.getter).isNotNull()
+            assertThat(valueClassExtension.setter).isNotNull()
+            assertThat(valueClassExtension.backingField).isNull()
+            assertThat(valueClassExtension.constructorParameter).isNull()
+
+            // the extension property receiver is a value class type, which gets mapped to its
+            // value type
+            valueClassExtension.receiver.assertPrimitiveTypeItem {
+                assertEquals(kind, PrimitiveTypeItem.Primitive.INT)
+            }
+        }
+    }
+
+    fun `Test final modifier for properties`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    class FinalClass {
+                        val propertyInFinalClass = 0
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    open class OpenClass {
+                        val finalPropertyInOpenClass = 0
+                        open val openPropertyInOpenClass = 0
+                    }
+                """
+            )
+        ) {
+            val finalClass = codebase.assertClass("test.pkg.FinalClass")
+            assertThat(finalClass.modifiers.isFinal()).isTrue()
+            // Properties in final classes are final, so using the modifier would be redundant.
+            assertThat(finalClass.assertProperty("propertyInFinalClass").modifiers.isFinal())
+                .isFalse()
+
+            val openClass = codebase.assertClass("test.pkg.OpenClass")
+            assertThat(openClass.modifiers.isFinal()).isFalse()
+            assertThat(openClass.assertProperty("finalPropertyInOpenClass").modifiers.isFinal())
+                .isTrue()
+            assertThat(openClass.assertProperty("openPropertyInOpenClass").modifiers.isFinal())
+                .isFalse()
+        }
+    }
+
+    @Test
+    fun `JvmStatic property in object is static`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    import kotlin.jvm.JvmStatic
+                    object Foo {
+                        @JvmStatic
+                        val jvmStaticProperty = 0
+                        val notStaticProperty = 0
+                    }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val jvmStaticProperty = fooClass.assertProperty("jvmStaticProperty")
+            assertThat(jvmStaticProperty.modifiers.isStatic()).isTrue()
+            val notStaticProperty = fooClass.assertProperty("notStaticProperty")
+            assertThat(notStaticProperty.modifiers.isStatic()).isFalse()
+        }
+    }
+
+    @Test
+    fun `Test abstract and default modifier on properties`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+
+                    interface Interface {
+                        // interface properties cannot have initializers
+                        // if no getter is defined, the property is abstract
+                        val abstractVal: Int
+                        // getter is defined, the property is default
+                        val defaultVal: Int
+                            get() = 0
+
+                        companion object {
+                            // this shouldn't be default because the immediate container is an
+                            // object, not an interface
+                            val interfaceCompanionValWithGetter: Int
+                                get() = 0
+                        }
+                    }
+
+                    abstract class AbstractClass {
+                        abstract val abstractVal: Int
+
+                        val nonAbstractValWithInitializer: Int = 0
+                        val nonAbstractValWithGetter: Int
+                            get() = 0
+
+                        // lateinit cannot be paired with abstract
+                        lateinit var nonAbstractLateinitVar: String
+
+                        val notAbstractValInInitBlock: Int
+                        init {
+                            notAbstractValInInitBlock = 0
+                        }
+                    }
+                """
+            )
+        ) {
+            val interfaceClass = codebase.assertClass("test.pkg.Interface")
+            val abstractInterfaceProperty = interfaceClass.assertProperty("abstractVal")
+            assertThat(abstractInterfaceProperty.modifiers.isAbstract()).isTrue()
+            assertThat(abstractInterfaceProperty.modifiers.isDefault()).isFalse()
+            val defaultInterfaceProperty = interfaceClass.assertProperty("defaultVal")
+            assertThat(defaultInterfaceProperty.modifiers.isAbstract()).isFalse()
+            assertThat(defaultInterfaceProperty.modifiers.isDefault()).isTrue()
+
+            val interfaceCompanion = interfaceClass.nestedClasses().single()
+            val interfaceCompanionProperty =
+                interfaceCompanion.assertProperty("interfaceCompanionValWithGetter")
+            assertThat(interfaceCompanionProperty.modifiers.isAbstract()).isFalse()
+            assertThat(interfaceCompanionProperty.modifiers.isDefault()).isFalse()
+
+            val abstractClass = codebase.assertClass("test.pkg.AbstractClass")
+            val abstractClassProperty = abstractClass.assertProperty("abstractVal")
+            assertThat(abstractClassProperty.modifiers.isAbstract()).isTrue()
+            assertThat(abstractClassProperty.modifiers.isDefault()).isFalse()
+
+            val nonAbstractPropertiesFromAbstractClass =
+                listOf(
+                    abstractClass.assertProperty("nonAbstractValWithInitializer"),
+                    abstractClass.assertProperty("nonAbstractValWithGetter"),
+                    abstractClass.assertProperty("nonAbstractLateinitVar"),
+                    abstractClass.assertProperty("notAbstractValInInitBlock"),
+                )
+
+            for (property in nonAbstractPropertiesFromAbstractClass) {
+                assertThat(property.modifiers.isAbstract()).isFalse()
+                assertThat(property.modifiers.isDefault()).isFalse()
+            }
+        }
+    }
+
+    @Test
+    fun `Test property receivers`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+                    val noReceiverProperty = 0
+                    // Extension properties can't have backing fields, so they need defined getters
+                    val Int.intProperty
+                        get() = 0
+                    val String.stringProperty
+                        get() = 0
+                    val Array<String>.stringArrayProperty
+                        get() = 0
+                    val List<String>.stringListProperty
+                        get() = 0
+                """
+            ),
+            // Skip getters in the signature file since they aren't important to the test
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        property public static int noReceiverProperty;
+                        property public static int int.intProperty;
+                        property public static int String.stringProperty;
+                        property public static int String[].stringArrayProperty;
+                        property public static int java.util.List<? extends String>.stringListProperty;
+                      }
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        property public static noReceiverProperty: int;
+                        property public static int.intProperty: int;
+                        property public static String.stringProperty: int;
+                        property public static String[].stringArrayProperty: int;
+                        property public static java.util.List<? extends String>.stringListProperty: int;
+                      }
+                    }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            assertNull(fooClass.assertProperty("noReceiverProperty").receiver)
+
+            fooClass.assertProperty("intProperty").receiver.assertPrimitiveTypeItem {
+                assertEquals(kind, PrimitiveTypeItem.Primitive.INT)
+            }
+
+            fooClass.assertProperty("stringProperty").receiver.assertClassTypeItem {
+                assertTrue(isString())
+            }
+
+            fooClass.assertProperty("stringArrayProperty").receiver.assertArrayTypeItem {
+                componentType.assertClassTypeItem { assertTrue(isString()) }
+            }
+
+            fooClass.assertProperty("stringListProperty").receiver.assertClassTypeItem {
+                assertEquals(qualifiedName, "java.util.List")
+                arguments.single().assertWildcardItem {
+                    extendsBound.assertClassTypeItem { assertTrue(isString()) }
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `Test property type parameters, receiver types`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+                    val String.noTypeParameterProperty = 0
+                    // Property type parameters must be used in the receiver type
+                    // Extension properties can't have backing fields, so they need defined getters
+                    val <T> T.oneTypeParameterReceiver
+                        get() = 0
+                    val <T> List<T>.oneTypeParameterListReceiver
+                        get() = 0
+                    val <T : String> T.oneTypeParameterWithBoundsReceiver
+                        get() = 0
+                    val <T1, T2> Map<T1, T2>.twoTypeParameterMapReceiver
+                        get() = 0
+                    val <T1 : String, T2 : List<T1>> Map<T1, T2>.twoTypeParameterWithBoundsMapReceiver
+                        get() = 0
+                """
+            ),
+            // Skip getters in the signature file since they aren't important to the test
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        property public static int String.noTypeParameterProperty;
+                        property public static <T> int T.oneTypeParameterReceiver;
+                        property public static <T> int java.util.List<? extends T>.oneTypeParameterListReceiver;
+                        property public static <T extends String> int T.oneTypeParameterWithBoundsReceiver;
+                        property public static <T1, T2> int java.util.Map<T1,? extends T2>.twoTypeParameterMapReceiver;
+                        property public static <T1 extends String, T2 extends java.util.List<? extends T1>> int java.util.Map<T1,? extends T2>.twoTypeParameterWithBoundsMapReceiver;
+                      }
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        property public static String.noTypeParameterProperty: int;
+                        property public static <T> T.oneTypeParameterReceiver: int;
+                        property public static <T> java.util.List<? extends T>.oneTypeParameterListReceiver: int;
+                        property public static <T extends String> T.oneTypeParameterWithBoundsReceiver: int;
+                        property public static <T1, T2> java.util.Map<T1,? extends T2>.twoTypeParameterMapReceiver: int;
+                        property public static <T1 extends String, T2 extends java.util.List<? extends T1>> java.util.Map<T1,? extends T2>.twoTypeParameterWithBoundsMapReceiver: int;
+                      }
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val noTypeParameterProperty = fooClass.assertProperty("noTypeParameterProperty")
+            assertThat(noTypeParameterProperty.typeParameterList).isEmpty()
+
+            // val <T> T.oneTypeParameterReceiver
+            val oneTypeParameterReceiver = fooClass.assertProperty("oneTypeParameterReceiver")
+            val oneTypeParameterReceiverT = oneTypeParameterReceiver.typeParameterList.single()
+            assertThat(oneTypeParameterReceiverT.name()).isEqualTo("T")
+            assertThat(oneTypeParameterReceiverT.typeBounds()).isEmpty()
+            assertThat(oneTypeParameterReceiverT.isReified()).isFalse()
+            oneTypeParameterReceiver.receiver.assertVariableTypeItem {
+                assertEquals(asTypeParameter, oneTypeParameterReceiverT)
+            }
+
+            // val <T> List<T>.oneTypeParameterListReceiver
+            val oneTypeParameterListReceiver =
+                fooClass.assertProperty("oneTypeParameterListReceiver")
+            val oneTypeParameterListReceiverT =
+                oneTypeParameterListReceiver.typeParameterList.single()
+            assertThat(oneTypeParameterListReceiverT.name()).isEqualTo("T")
+            assertThat(oneTypeParameterListReceiverT.typeBounds()).isEmpty()
+            assertThat(oneTypeParameterListReceiverT.isReified()).isFalse()
+            oneTypeParameterListReceiver.receiver.assertClassTypeItem {
+                assertEquals(qualifiedName, "java.util.List")
+                arguments.single().assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertEquals(asTypeParameter, oneTypeParameterListReceiverT)
+                    }
+                }
+            }
+
+            // val <T : String> T.oneTypeParameterWithBoundsReceiver
+            val oneTypeParameterWithBoundsReceiver =
+                fooClass.assertProperty("oneTypeParameterWithBoundsReceiver")
+            val oneTypeParameterWithBoundsReceiverT =
+                oneTypeParameterWithBoundsReceiver.typeParameterList.single()
+            assertThat(oneTypeParameterWithBoundsReceiverT.name()).isEqualTo("T")
+            assertThat(oneTypeParameterWithBoundsReceiverT.typeBounds().single().isString())
+                .isTrue()
+            assertThat(oneTypeParameterWithBoundsReceiverT.isReified()).isFalse()
+            oneTypeParameterWithBoundsReceiver.receiver.assertVariableTypeItem {
+                assertEquals(asTypeParameter, oneTypeParameterReceiverT)
+            }
+
+            // val <T1, T2> Map<T1, T2>.twoTypeParameterMapReceiver
+            val twoTypeParameterMapReceiver = fooClass.assertProperty("twoTypeParameterMapReceiver")
+            val twoTypeParameterMapReceiverT1 = twoTypeParameterMapReceiver.typeParameterList[0]
+            assertThat(twoTypeParameterMapReceiverT1.name()).isEqualTo("T1")
+            assertThat(twoTypeParameterMapReceiverT1.typeBounds()).isEmpty()
+            assertThat(twoTypeParameterMapReceiverT1.isReified()).isFalse()
+            val twoTypeParameterMapReceiverT2 = twoTypeParameterMapReceiver.typeParameterList[1]
+            assertThat(twoTypeParameterMapReceiverT2.name()).isEqualTo("T2")
+            assertThat(twoTypeParameterMapReceiverT2.typeBounds()).isEmpty()
+            assertThat(twoTypeParameterMapReceiverT2.isReified()).isFalse()
+            twoTypeParameterMapReceiver.receiver.assertClassTypeItem {
+                assertEquals(qualifiedName, "java.util.Map")
+                assertEquals(arguments.size, 2)
+                arguments[0].assertVariableTypeItem {
+                    assertEquals(asTypeParameter, twoTypeParameterMapReceiverT1)
+                }
+                arguments[1].assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertEquals(asTypeParameter, twoTypeParameterMapReceiverT2)
+                    }
+                }
+            }
+
+            // val <T1 : String, T2 : List<T1>> Map<T1, T2>.twoTypeParameterWithBoundsMapReceiver
+            val twoTypeParameterWithBoundsMapReceiver =
+                fooClass.assertProperty("twoTypeParameterWithBoundsMapReceiver")
+            val twoTypeParameterWithBoundsMapReceiverT1 =
+                twoTypeParameterWithBoundsMapReceiver.typeParameterList[0]
+            assertThat(twoTypeParameterWithBoundsMapReceiverT1.name()).isEqualTo("T1")
+            assertThat(twoTypeParameterWithBoundsMapReceiverT1.typeBounds().single().isString())
+                .isTrue()
+            assertThat(twoTypeParameterWithBoundsMapReceiverT1.isReified()).isFalse()
+            val twoTypeParameterWithBoundsMapReceiverT2 =
+                twoTypeParameterWithBoundsMapReceiver.typeParameterList[1]
+            assertThat(twoTypeParameterWithBoundsMapReceiverT2.name()).isEqualTo("T2")
+            twoTypeParameterWithBoundsMapReceiverT2.typeBounds().single().assertClassTypeItem {
+                assertEquals(qualifiedName, "java.util.List")
+                arguments.single().assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertEquals(asTypeParameter, twoTypeParameterWithBoundsMapReceiverT1)
+                    }
+                }
+            }
+            assertThat(twoTypeParameterWithBoundsMapReceiverT2.isReified()).isFalse()
+            twoTypeParameterWithBoundsMapReceiver.receiver.assertClassTypeItem {
+                assertEquals(qualifiedName, "java.util.Map")
+                assertEquals(arguments.size, 2)
+                arguments[0].assertVariableTypeItem {
+                    assertEquals(asTypeParameter, twoTypeParameterWithBoundsMapReceiverT1)
+                }
+                arguments[1].assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertEquals(asTypeParameter, twoTypeParameterWithBoundsMapReceiverT2)
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `Test property type parameters, property type`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+                    val <T> T.typeParameterExtension
+                        get() = this
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method public static <T> T getTypeParameterExtension(T);
+                        property public static <T> T T.typeParameterExtension;
+                      }
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        method public static <T> getTypeParameterExtension(receiver: T): T;
+                        property public static <T> T.typeParameterExtension: T;
+                      }
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            // Verify that the type parameter list is also used for the property type
+            val typeParameterExtension = fooClass.assertProperty("typeParameterExtension")
+            val typeParameterExtensionT = typeParameterExtension.typeParameterList.single()
+            assertThat(typeParameterExtensionT.name()).isEqualTo("T")
+            assertThat(typeParameterExtensionT.typeBounds()).isEmpty()
+            assertThat(typeParameterExtensionT.isReified()).isFalse()
+            typeParameterExtension.type().assertVariableTypeItem {
+                assertEquals(asTypeParameter, typeParameterExtensionT)
+            }
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/snapshot/CommonEmittableDelegatingVisitorTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/snapshot/CommonEmittableDelegatingVisitorTest.kt
new file mode 100644
index 000000000..bc4d58c44
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/snapshot/CommonEmittableDelegatingVisitorTest.kt
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.snapshot
+
+import com.android.tools.metalava.model.Assertions.Companion.assertClass
+import com.android.tools.metalava.model.Assertions.Companion.assertPackage
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.snapshot.EmittableDelegatingVisitor
+import com.android.tools.metalava.model.snapshot.NonFilteringDelegatingVisitor
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.google.common.truth.Truth.assertWithMessage
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/** Common tests for [EmittableDelegatingVisitor]. */
+class CommonEmittableDelegatingVisitorTest : BaseModelTest() {
+    @Parameterized.Parameter(0) lateinit var testData: TestParams
+
+    data class TestParams(
+        val name: String,
+        val getter: CodebaseContext.() -> SelectableItem,
+    ) {
+        override fun toString(): String {
+            return name
+        }
+    }
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters
+        fun params() =
+            listOf(
+                TestParams(
+                    name = "package",
+                    getter = { codebase.assertPackage("test.pkg") },
+                ),
+                TestParams(
+                    name = "class",
+                    getter = { codebase.assertClass("test.pkg.Foo") },
+                ),
+                TestParams(
+                    name = "constructor",
+                    getter = { codebase.assertClass("test.pkg.Foo").constructors().single() },
+                ),
+                TestParams(
+                    name = "method",
+                    getter = { codebase.assertClass("test.pkg.Foo").methods().single() },
+                ),
+                TestParams(
+                    name = "field",
+                    getter = { codebase.assertClass("test.pkg.Foo").fields().single() },
+                ),
+                TestParams(
+                    name = "property",
+                    getter = { codebase.assertClass("test.pkg.Foo").properties().single() },
+                ),
+                TestParams(
+                    name = "nested class",
+                    getter = { codebase.assertClass("test.pkg.Foo.Nested") },
+                ),
+            )
+    }
+
+    @Test
+    fun `Test filters correctly`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Foo {
+                          ctor public Foo();
+                          method public void method();
+                          field public int field;
+                          property public int property;
+                      }
+                      public class Foo.Nested {
+                      }
+                    }
+                """
+            ),
+        ) {
+            // Visit all the items, unfiltered.
+            val unfilteredItems = buildSet {
+                codebase.accept(NonFilteringDelegatingVisitor(CollateItems(this)))
+            }
+
+            // Get the test item.
+            val testItem = testData.getter(this)
+
+            // Make sure the test item is in the unfiltered list.
+            assertWithMessage("when emit=true").that(unfilteredItems).contains(testItem)
+
+            // Mark the item as not being emittable.
+            testItem.emit = false
+
+            // Visit all the emittable items which should not include the test item.
+            val filteredItems = buildSet {
+                codebase.accept(EmittableDelegatingVisitor(CollateItems(this)))
+            }
+
+            // Make sure the test item is NOT in the filtered list.
+            assertWithMessage("when emit=false").that(filteredItems).doesNotContain(testItem)
+        }
+    }
+
+    private class CollateItems(private val collection: MutableCollection<SelectableItem>) :
+        DelegatedVisitor {
+        override fun visitPackage(pkg: PackageItem) {
+            collection.add(pkg)
+        }
+
+        override fun visitClass(cls: ClassItem) {
+            collection.add(cls)
+        }
+
+        override fun visitConstructor(constructor: ConstructorItem) {
+            collection.add(constructor)
+        }
+
+        override fun visitMethod(method: MethodItem) {
+            collection.add(method)
+        }
+
+        override fun visitField(field: FieldItem) {
+            collection.add(field)
+        }
+
+        override fun visitProperty(property: PropertyItem) {
+            collection.add(property)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
index f75594e16..f0c89885c 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
@@ -38,8 +38,8 @@ class CommonSourceFileTest : BaseModelTest() {
                     """
                         package test.pkg;
 
-                        import test.pkg2.Test1.FIELD;
-                        import test.pkg2.Test1.method;
+                        import static test.pkg2.Test1.FIELD;
+                        import static test.pkg2.Test1.method;
                         import test.pkg1.*;
                         import test.Test.Inner;
                         import test.Test;
@@ -75,6 +75,11 @@ class CommonSourceFileTest : BaseModelTest() {
                         package test.pkg1;
 
                         public class Test1 {}
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg1;
 
                         public class Test2 {}
                     """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typealiasitem/CommonTypeAliasItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typealiasitem/CommonTypeAliasItemTest.kt
new file mode 100644
index 000000000..a7e5f67a9
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typealiasitem/CommonTypeAliasItemTest.kt
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.typealiasitem
+
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
+import com.android.tools.metalava.testing.kotlin
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+class CommonTypeAliasItemTest : BaseModelTest() {
+    @Test
+    fun `accessing type alias from codebase`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias Foo = String;
+                    }
+                """
+            ),
+        ) {
+            codebase.assertTypeAlias("test.pkg.Foo")
+        }
+    }
+
+    @Test
+    fun `accessing type alias from package`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias Foo = String;
+                    }
+                """
+            ),
+        ) {
+            val pkg = codebase.assertPackage("test.pkg")
+            assertThat(pkg.typeAliases()).hasSize(1)
+        }
+    }
+
+    @Test
+    fun `type alias name`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias Foo = String;
+                    }
+                """
+            ),
+        ) {
+            val typeAlias = codebase.assertTypeAlias("test.pkg.Foo")
+            assertThat(typeAlias.qualifiedName).isEqualTo("test.pkg.Foo")
+            assertThat(typeAlias.simpleName).isEqualTo("Foo")
+        }
+    }
+
+    @Test
+    fun `type alias visibility`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias PublicTypeAlias = String
+                    @PublishedApi
+                    internal typealias InternalTypeAlias = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias PublicTypeAlias = String;
+                      @kotlin.PublishedApi internal typealias InternalTypeAlias = String;
+                    }
+                """
+            ),
+        ) {
+            val publicTypeAlias = codebase.assertTypeAlias("test.pkg.PublicTypeAlias")
+            assertThat(publicTypeAlias.modifiers.getVisibilityString()).isEqualTo("public")
+
+            val internalTypeAlias = codebase.assertTypeAlias("test.pkg.InternalTypeAlias")
+            assertThat(internalTypeAlias.modifiers.getVisibilityString()).isEqualTo("internal")
+            assertThat(internalTypeAlias.modifiers.annotations().single().qualifiedName)
+                .isEqualTo("kotlin.PublishedApi")
+        }
+    }
+
+    @Test
+    fun `private type alias visibility`() {
+        // No signature case: private APIs aren't written to signature files
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    private typealias PrivateTypeAlias = String
+                """
+            ),
+        ) {
+            val privateTypeAlias = codebase.assertTypeAlias("test.pkg.PrivateTypeAlias")
+            assertThat(privateTypeAlias.modifiers.getVisibilityString()).isEqualTo("private")
+        }
+    }
+
+    @Test
+    fun `annotations on type alias`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        typealias Unannotated = String
+                        @AnnoA @AnnoB typealias Annotated = String
+                    """
+                ),
+                kotlin(
+                    """
+                        package test.pkg
+                        @Target(AnnotationTarget.TYPEALIAS)
+                        annotation class AnnoA
+                        @Target(AnnotationTarget.TYPEALIAS)
+                        annotation class AnnoB
+                    """
+                )
+            ),
+            inputSet(
+                signature(
+                    """
+                        // Signature format: 5.0
+                        package test.pkg {
+                          @test.pkg.AnnoA @test.pkg.AnnoB public typealias Annotated = String;
+                          public typealias Unannotated = String;
+                        }
+                    """
+                )
+            ),
+        ) {
+            val unannotated = codebase.assertTypeAlias("test.pkg.Unannotated")
+            assertThat(unannotated.modifiers.annotations()).isEmpty()
+            val annotated = codebase.assertTypeAlias("test.pkg.Annotated")
+            val annotations = annotated.modifiers.annotations()
+            assertThat(annotations).hasSize(2)
+            assertThat(annotations.map { it.qualifiedName })
+                .containsExactly("test.pkg.AnnoA", "test.pkg.AnnoB")
+        }
+    }
+
+    @Test
+    fun `basic type alias types`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias PrimitiveType = Int
+                    typealias ArrayType = IntArray
+                    typealias ClassType = String
+                """
+            ),
+            // This type aliases are sorted to match the kotlin code instead of alphabetically.
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias PrimitiveType = int;
+                      public typealias ArrayType = int[];
+                      public typealias ClassType = String;
+                    }
+                """
+            ),
+        ) {
+            val primitiveType = codebase.assertTypeAlias("test.pkg.PrimitiveType").aliasedType
+            primitiveType.assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            val arrayType = codebase.assertTypeAlias("test.pkg.ArrayType").aliasedType
+            arrayType.assertArrayTypeItem {
+                componentType.assertPrimitiveTypeItem {
+                    assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+                }
+            }
+            val classType = codebase.assertTypeAlias("test.pkg.ClassType").aliasedType
+            classType.assertClassTypeItem { assertThat(isString()).isTrue() }
+        }
+    }
+
+    @Test
+    fun `functional type alias type`() {
+        // No signature case: functional types are just parsed as class types (b/169798041).
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias FunctionType = (String) -> Int
+                """
+            ),
+        ) {
+            val functionType = codebase.assertTypeAlias("test.pkg.FunctionType").aliasedType
+            functionType.assertLambdaTypeItem {
+                assertThat(parameterTypes).hasSize(1)
+                assertThat(parameterTypes.single().isString()).isTrue()
+                returnType.assertPrimitiveTypeItem {
+                    assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `type alias referencing other type alias`() {
+        // type aliases should be expanded to the underlying type
+        // No signature case: the type aliases should be output as their underlying type, so having
+        // a type alias as a type in a signature file wouldn't make sense.
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                    typealias Bar = List<Foo>
+                """
+            )
+        ) {
+            val foo = codebase.assertTypeAlias("test.pkg.Foo")
+            assertThat(foo.aliasedType.isString()).isTrue()
+            val bar = codebase.assertTypeAlias("test.pkg.Bar")
+            bar.aliasedType.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.List")
+                assertThat(arguments).hasSize(1)
+                arguments.single().assertWildcardItem {
+                    assertThat(extendsBound!!.isString()).isTrue()
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `type parameter lists on type aliases`() {
+        // Note: bounds are not allowed on type alias parameters. The aliased type is not allowed to
+        // be a type parameter itself.
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias NoTypeParameter = String
+                    typealias OneTypeParameter<T> = List<T>
+                    typealias TwoTypeParameter<K, V> = Map.Entry<K, V>
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias NoTypeParameter = String;
+                      public typealias OneTypeParameter<T> = java.util.List<? extends T>;
+                      public typealias TwoTypeParameter<K, V> = java.util.Map.Entry<? extends K,? extends V>;
+                    }
+                """
+            ),
+        ) {
+            val noTypeParameter = codebase.assertTypeAlias("test.pkg.NoTypeParameter")
+            assertThat(noTypeParameter.typeParameterList).isEmpty()
+
+            val oneTypeParameter = codebase.assertTypeAlias("test.pkg.OneTypeParameter")
+            assertThat(oneTypeParameter.typeParameterList).hasSize(1)
+            val t = oneTypeParameter.typeParameterList.single()
+            assertThat(t.name()).isEqualTo("T")
+            val listT = oneTypeParameter.aliasedType
+            listT.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.List")
+                assertThat(arguments).hasSize(1)
+                arguments.single().assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertThat(asTypeParameter).isEqualTo(t)
+                        assertThat(t.type()).isEqualTo(this)
+                    }
+                }
+            }
+
+            val twoTypeParameter = codebase.assertTypeAlias("test.pkg.TwoTypeParameter")
+            assertThat(twoTypeParameter.typeParameterList).hasSize(2)
+            val k = twoTypeParameter.typeParameterList[0]
+            assertThat(k.name()).isEqualTo("K")
+            val v = twoTypeParameter.typeParameterList[1]
+            assertThat(v.name()).isEqualTo("V")
+            val mapEntryKV = twoTypeParameter.aliasedType
+            mapEntryKV.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.Map.Entry")
+                assertThat(arguments).hasSize(2)
+                arguments[0].assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertThat(asTypeParameter).isEqualTo(k)
+                        assertThat(k.type()).isEqualTo(this)
+                    }
+                }
+                arguments[1].assertWildcardItem {
+                    extendsBound.assertVariableTypeItem {
+                        assertThat(asTypeParameter).isEqualTo(v)
+                        assertThat(v.type()).isEqualTo(this)
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `expect actual typealias`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    expect class Foo
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.android.kt",
+                """
+                    package test.pkg
+                    actual typealias Foo = String
+                """
+            )
+        runCodebaseTest(
+            inputSet(
+                androidSource,
+                commonSource,
+            ),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val fooAlias = codebase.assertTypeAlias("test.pkg.Foo")
+            assertThat(fooAlias.aliasedType.isString()).isTrue()
+        }
+    }
+
+    @Test
+    fun `type alias package emit`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias Foo = String;
+                    }
+                """
+            ),
+        ) {
+            val pkg = codebase.assertPackage("test.pkg")
+            assertThat(pkg.emit).isTrue()
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonErasedTypeStringTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonErasedTypeStringTest.kt
index 969490f1b..7be3580f6 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonErasedTypeStringTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonErasedTypeStringTest.kt
@@ -177,7 +177,7 @@ class CommonErasedTypeStringTest : BaseModelTest() {
     private fun signatureTestFile() =
         signature(
             """
-                        // Signature format: 3.0
+                        // Signature format: 4.0
                         package test.pkg {
                           public class Foo {
                             ctor public Foo();
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonIsAssignableFromTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonIsAssignableFromTest.kt
index 013314664..475a3b0e5 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonIsAssignableFromTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonIsAssignableFromTest.kt
@@ -116,7 +116,7 @@ class CommonIsAssignableFromTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.foo {
                       public class Subject {
                         field public Object obj;
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
index ef9438bcc..410cc025c 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
@@ -16,7 +16,13 @@
 
 package com.android.tools.metalava.model.testsuite.typeitem
 
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.WildcardTypeItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
 import org.junit.Test
@@ -48,4 +54,275 @@ class CommonTypeAliasTest : BaseModelTest() {
                 )
         }
     }
+
+    /**
+     * Sets up a test with an expect/actual type alias. The type alias is defined as an expect class
+     * in commonMain, and an actual type alias in androidMain. It is used as a method return type
+     * from both source sets.
+     *
+     * @param typeAlias The name and type parameters of the type alias, e.g. "Foo" or "Foo<T>".
+     * @param aliasedType The value of the type alias actual in androidMain.
+     * @param typeAliasUsage The usage of the type alias as a method return type in both commonMain
+     *   and androidMain, e.g. "Foo?" or "Foo<String>".
+     * @param assertion Test that will run on the usages of the type alias, for both the commonMain
+     *   and androidMain usage.
+     */
+    private fun checkExpectActualTypealias(
+        typeAlias: String,
+        aliasedType: String,
+        typeAliasUsage: String,
+        assertion: (TypeItem) -> Unit,
+    ) {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    expect class $typeAlias
+                    fun common(): $typeAliasUsage = error("unimplemented")
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.android.kt",
+                """
+                    package test.pkg
+                    actual typealias $typeAlias = $aliasedType
+                    fun android(): $typeAliasUsage = error("unimplemented")
+                """
+            )
+        runCodebaseTest(
+            inputSet(
+                androidSource,
+                commonSource,
+            ),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val commonMethod = codebase.assertClass("test.pkg.FooKt").assertMethod("common", "")
+            assertion(commonMethod.returnType())
+
+            val androidMethod =
+                codebase.assertClass("test.pkg.Foo_androidKt").assertMethod("android", "")
+            assertion(androidMethod.returnType())
+        }
+    }
+
+    /**
+     * Asserts that [typeItem] is either a [ClassTypeItem] or a [WildcardTypeItem]. Returns the
+     * [ClassTypeItem] or the extends bound of the [WildcardTypeItem].
+     *
+     * This is to be used when there are K1/K2 differences between when type arguments end up as
+     * wildcards or plain usages of a type.
+     */
+    private fun getClassOrWildcardExtendsBound(typeItem: TypeItem): TypeItem {
+        return typeItem as? ClassTypeItem
+            ?: (typeItem as? WildcardTypeItem)?.extendsBound
+                ?: error("expected class type or wildcard type with extends bound, was $typeItem")
+    }
+
+    @Test
+    fun `Test usage of simple typealias expect actual`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo",
+            aliasedType = "String",
+            typeAliasUsage = "Foo",
+        ) {
+            assertThat(it.isString()).isTrue()
+            assertThat(it.modifiers.isNullable).isFalse()
+        }
+    }
+
+    @Test
+    fun `Test usage of nullable typealias expect actual`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo",
+            aliasedType = "String?",
+            typeAliasUsage = "Foo",
+        ) {
+            assertThat(it.isString()).isTrue()
+            assertThat(it.modifiers.isNullable).isTrue()
+        }
+    }
+
+    @Test
+    fun `Test usage of typealias expect actual used as nullable`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo",
+            aliasedType = "String",
+            typeAliasUsage = "Foo?",
+        ) {
+            assertThat(it.isString()).isTrue()
+            assertThat(it.modifiers.isNullable).isTrue()
+        }
+    }
+
+    @Test
+    fun `Test usage of generic typealias expect actual`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo<T>",
+            aliasedType = "List<T>",
+            typeAliasUsage = "Foo<String>",
+        ) {
+            it.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.List")
+                assertThat(modifiers.isNullable).isFalse()
+                val stringType = getClassOrWildcardExtendsBound(arguments.single())
+                assertThat(stringType.isString()).isTrue()
+                assertThat(stringType.modifiers.isNullable).isFalse()
+            }
+        }
+    }
+
+    @Test
+    fun `Test usage of nullable generic typealias expect actual`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo<T>",
+            aliasedType = "List<T?>",
+            typeAliasUsage = "Foo<String>",
+        ) {
+            it.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.List")
+                assertThat(modifiers.isNullable).isFalse()
+                val stringType = getClassOrWildcardExtendsBound(arguments.single())
+                assertThat(stringType.isString()).isTrue()
+                assertThat(stringType.modifiers.isNullable).isTrue()
+            }
+        }
+    }
+
+    @Test
+    fun `Test usage of generic typealias expect actual used as nullable`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo<T>",
+            aliasedType = "List<T>",
+            typeAliasUsage = "Foo<String?>",
+        ) {
+            it.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.List")
+                assertThat(modifiers.isNullable).isFalse()
+                val stringType = getClassOrWildcardExtendsBound(arguments.single())
+                assertThat(stringType.isString()).isTrue()
+                assertThat(stringType.modifiers.isNullable).isTrue()
+            }
+        }
+    }
+
+    @Test
+    fun `Test usage of generic typealias expect actual non class type`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo<T>",
+            aliasedType = "Array<T>",
+            typeAliasUsage = "Foo<String>",
+        ) {
+            it.assertArrayTypeItem {
+                assertThat(modifiers.isNullable).isFalse()
+                assertThat(componentType.isString()).isTrue()
+                assertThat(componentType.modifiers.isNullable).isFalse()
+            }
+        }
+    }
+
+    @Test
+    fun `Test usage of generic typealias expect actual reversed generics`() {
+        checkExpectActualTypealias(
+            typeAlias = "Foo<V, K>",
+            aliasedType = "Map<K, V>",
+            typeAliasUsage = "Foo<String, Number>",
+        ) {
+            it.assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("java.util.Map")
+                assertThat(modifiers.isNullable).isFalse()
+                assertThat(arguments).hasSize(2)
+                getClassOrWildcardExtendsBound(arguments[0]).assertClassTypeItem {
+                    assertThat(qualifiedName).isEqualTo("java.lang.Number")
+                    assertThat(modifiers.isNullable).isFalse()
+                }
+                getClassOrWildcardExtendsBound(arguments[1]).assertClassTypeItem {
+                    assertThat(qualifiedName).isEqualTo("java.lang.String")
+                    assertThat(modifiers.isNullable).isFalse()
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `Test usage of actual typealias as parent class`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/ExpectActualParentClass.kt",
+                """
+                    package test.pkg
+                    class CommonChildClass : ExpectActualParentClass()
+                    expect open class ExpectActualParentClass()
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/ExpectActualParentClass.android.kt",
+                """
+                    package test.pkg
+                    open class ActualParentClass
+                    actual typealias ExpectActualParentClass = ActualParentClass
+                """
+            )
+        runCodebaseTest(
+            inputSet(
+                androidSource,
+                commonSource,
+            ),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val actualParentClass = codebase.assertClass("test.pkg.ActualParentClass")
+            val actualParentClassType = actualParentClass.type()
+            val commonChildClass = codebase.assertClass("test.pkg.CommonChildClass")
+            assertThat(commonChildClass.superClassType()).isEqualTo(actualParentClassType)
+        }
+    }
+
+    @Test
+    fun `Test usage of nullable actual typealias as parent class`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/ExpectActualParentClass.kt",
+                """
+                    package test.pkg
+                    class CommonChildClass : ExpectActualParentClass()
+                    expect open class ExpectActualParentClass()
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/ExpectActualParentClass.android.kt",
+                """
+                    package test.pkg
+                    open class ActualParentClass
+                    actual typealias ExpectActualParentClass = ActualParentClass?
+                """
+            )
+        runCodebaseTest(
+            inputSet(
+                androidSource,
+                commonSource,
+            ),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val actualParentClass = codebase.assertClass("test.pkg.ActualParentClass")
+            val actualParentClassType = actualParentClass.type()
+            val commonChildClass = codebase.assertClass("test.pkg.CommonChildClass")
+            assertThat(commonChildClass.superClassType()).isEqualTo(actualParentClassType)
+            assertThat(commonChildClass.superClassType()!!.modifiers.isNullable).isFalse()
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
index 2e99c6541..98fe39e7b 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
@@ -20,6 +20,7 @@ import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.BaseTypeTransformer
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.ReferenceTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
@@ -78,7 +79,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -134,7 +135,7 @@ class CommonTypeItemTest : BaseModelTest() {
             // The Kotlin equivalent can be interpreted with java.lang types instead of primitives
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -190,7 +191,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -233,7 +234,7 @@ class CommonTypeItemTest : BaseModelTest() {
             // The Kotlin equivalent can be interpreted with java.lang types instead of primitives
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -306,7 +307,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -376,7 +377,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         ctor public Foo();
@@ -457,7 +458,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<C> {
                         ctor public Foo();
@@ -512,7 +513,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         method public T bar1();
@@ -575,7 +576,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         method public void bar1(T p);
@@ -633,7 +634,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         field public T foo;
@@ -666,7 +667,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         property public T foo;
@@ -715,7 +716,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo {
                         ctor public Foo();
@@ -799,7 +800,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Outer {
                         ctor public Outer();
@@ -872,7 +873,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Test {
                         ctor public Outer();
@@ -930,7 +931,7 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Outer<O> {
                         ctor public Outer();
@@ -1003,8 +1004,9 @@ class CommonTypeItemTest : BaseModelTest() {
             ),
             inputSet(
                 signature(
+                    "api1.txt",
                     """
-                        // Signature format: 3.0
+                        // Signature format: 4.0
                         package test.pkg1 {
                           public class Outer<O> {
                             ctor public Outer();
@@ -1019,8 +1021,9 @@ class CommonTypeItemTest : BaseModelTest() {
                     """
                 ),
                 signature(
+                    "api2.txt",
                     """
-                        // Signature format: 3.0
+                        // Signature format: 4.0
                         package test.pkg {
                           public class Test {
                             ctor public Test();
@@ -1965,4 +1968,38 @@ class CommonTypeItemTest : BaseModelTest() {
                 .isEqualTo("java.lang.Thread.UncaughtExceptionHandler")
         }
     }
+
+    @Test
+    fun `Non-last varargs param in deprecated method`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    class Foo {
+                        fun notDeprecated(vararg str: String, i: Int) = Unit
+                        @Deprecated(message = "message", level = DeprecationLevel.WARNING)
+                        fun deprecatedWarning(vararg str: String, i: Int) = Unit
+                        @Deprecated(message = "message", level = DeprecationLevel.ERROR)
+                        fun deprecatedError(vararg str: String, i: Int) = Unit
+                        @Deprecated(message = "message", level = DeprecationLevel.HIDDEN)
+                        fun deprecatedHidden(vararg str: String, i: Int) = Unit
+                    }
+                """
+            )
+        ) {
+            val foo = codebase.assertClass("test.pkg.Foo")
+            val notDeprecated = foo.methods().single { it.name() == "notDeprecated" }
+            val deprecatedWarning = foo.methods().single { it.name() == "deprecatedWarning" }
+            val deprecatedError = foo.methods().single { it.name() == "deprecatedError" }
+            val deprecatedHidden = foo.methods().single { it.name() == "deprecatedHidden" }
+
+            fun MethodItem.firstParameterIsVarargs() =
+                (parameters().first().type() as ArrayTypeItem).isVarargs
+
+            assertThat(notDeprecated.firstParameterIsVarargs()).isFalse()
+            assertThat(deprecatedWarning.firstParameterIsVarargs()).isFalse()
+            assertThat(deprecatedError.firstParameterIsVarargs()).isFalse()
+            assertThat(deprecatedHidden.firstParameterIsVarargs()).isFalse()
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
index a731431fd..c980e7f20 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
@@ -551,7 +551,7 @@ class CommonTypeModifiersTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Outer<O> {
                         ctor public Outer();
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeParameterItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeParameterItemTest.kt
index 85f829eec..88ef55e85 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeParameterItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeParameterItemTest.kt
@@ -17,6 +17,8 @@
 package com.android.tools.metalava.model.testsuite.typeitem
 
 import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.StripJavaLangPrefix
+import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
@@ -41,7 +43,7 @@ class CommonTypeParameterItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T> {
                         ctor public Foo();
@@ -76,7 +78,7 @@ class CommonTypeParameterItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T extends Comparable<T>> {
                         ctor public Foo();
@@ -113,7 +115,7 @@ class CommonTypeParameterItemTest : BaseModelTest() {
             ),
             signature(
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class Foo<T extends Object & Comparable<T>> {
                         ctor public Foo();
@@ -304,6 +306,12 @@ class CommonTypeParameterItemTest : BaseModelTest() {
             // There's an expected space between "java.lang.Integer" and "java.lang.String"
             assertThat(typeParameter.toSource())
                 .isEqualTo("T extends java.util.Map<java.lang.Integer, java.lang.String>")
+
+            // There's no expected space between "Integer" and "String"
+            val configuration =
+                TypeStringConfiguration(stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS)
+            assertThat(typeParameter.toSource(configuration))
+                .isEqualTo("T extends java.util.Map<Integer,String>")
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
index 0a702dfae..40d22c347 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
@@ -249,7 +249,7 @@ class CommonTypeStringTest : BaseModelTest() {
         private val testCases =
             // Test primitives besides void (the test setup puts the type in parameter position, and
             // void can't be a parameter type).
-            PrimitiveTypeItem.Primitive.values()
+            PrimitiveTypeItem.Primitive.entries
                 .filter { it != PrimitiveTypeItem.Primitive.VOID }
                 .map { TypeStringParameters(name = it.primitiveName) } +
                 // Test additional types
@@ -369,7 +369,7 @@ class CommonTypeStringTest : BaseModelTest() {
                             ConfigurationTestCase(
                                 name = "spaced params",
                                 configuration =
-                                    TypeStringConfiguration(spaceBetweenParameters = true),
+                                    TypeStringConfiguration(spaceBetweenTypeArguments = true),
                                 expectedTypeString = "java.util.List<java.lang.String>"
                             ),
                         ),
@@ -396,7 +396,7 @@ class CommonTypeStringTest : BaseModelTest() {
                             ConfigurationTestCase(
                                 name = "spaced params",
                                 configuration =
-                                    TypeStringConfiguration(spaceBetweenParameters = true),
+                                    TypeStringConfiguration(spaceBetweenTypeArguments = true),
                                 expectedTypeString =
                                     "java.util.Map<java.lang.String, java.lang.Number>"
                             )
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt
new file mode 100644
index 000000000..c6f399457
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt
@@ -0,0 +1,929 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.Assertions
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.junit4.ParameterFilter
+import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+import com.android.tools.metalava.model.testsuite.value.BaseCommonParameterizedValueTest.Companion.testCases
+import com.android.tools.metalava.model.testsuite.value.BaseCommonParameterizedValueTest.TestClass
+import com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest.Companion.testParameters
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
+import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.valueExamples
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.cacheIn
+import com.android.tools.metalava.testing.jarFromSources
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import com.android.tools.metalava.testing.signature
+import kotlin.test.assertEquals
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/**
+ * Base class of parameterized tests that will run test cases against both jars and sources to check
+ * the behavior of values.
+ *
+ * This only has a single test method which runs a list of [TestCase]s against a list of
+ * [CodebaseProducer]s. A [TestCase] defines the test to run and the [CodebaseProducer] defines the
+ * [Codebase] it will be run on, either jar or source based.
+ *
+ * [TestCase] provides the details of the test to run but the actual test logic is provided by
+ * subclasses of this class. Each subclass selects the [TestCase]s that apply to it and then runs
+ * the test to check different [ValueUseSite]s, e.g. annotation value, method default value, field
+ * value. This approach was taken instead of having methods for each use of a value because the
+ * values should be being handled consistently irrespective of where they are being used, but
+ * currently they are not. Having all the tests for them being run on the same [TestCase]s
+ * highlights the inconsistencies and makes it easier to migrate to consistent handling of the
+ * values.
+ *
+ * Each [TestCase] runs against a [TestClass] which specifies the class name to use and the set of
+ * [TestFile]s to use. The jar tests run against a jar constructed from all the distinct [TestFile]
+ * used by all the [testCases]. The source tests run against just the set of sources needed by the
+ * [TestClass].
+ *
+ * The set of files needed by a [TestClass] are encapsulated in a [TestClass.testFileSet] which
+ * tracks dependencies.
+ *
+ * The set of tests to run is defined by a list of [ValueExample]s which provide the necessary
+ * information to construct [TestClass]es and the [TestCase]s that run against them. Each
+ * [ValueExample] is tested in all possible [ValueUseSite] (although some examples do not work on
+ * some sites). The aim is to create an exhaustive set of tests that first map out the existing
+ * inconsistencies and eventually ensure consistent behavior.
+ *
+ * @param testFileCache the [TestFileCache] in which all the [TestFile]s used by this test class
+ *   will be cached.
+ * @param testJarFile the [TestFile] for the jar file built from all the java source files used by
+ *   this test class.
+ * @param valueUseSite the [ValueUseSite] being tested by this class.
+ * @param legacySourceGetter gets the legacy source representation as expected by
+ *   [ValueExample.expectedLegacySourceFor].
+ */
+abstract class BaseCommonParameterizedValueTest(
+    private val testFileCache: TestFileCache,
+    private val testJarFile: TestFile,
+    private val valueUseSite: ValueUseSite,
+    private val legacySourceGetter: TestCaseContext.() -> String,
+) : BaseModelTest() {
+
+    @Parameterized.Parameter(0) lateinit var codebaseProducer: CodebaseProducer
+
+    @Parameterized.Parameter(1) lateinit var testCase: TestCase
+
+    /** Produces a [Codebase] to test and runs the test on it. */
+    sealed class CodebaseProducer(val kind: ProducerKind) {
+        /**
+         * Produce a [Codebase] and run [test] on it.
+         *
+         * Run with [BaseCommonParameterizedValueTest] as the receiver so it can access
+         * [runSourceCodebaseTest].
+         */
+        abstract fun BaseCommonParameterizedValueTest.runCodebaseProducerTest(
+            testFileCache: TestFileCache,
+            testCase: TestCase,
+            test: TestCaseContext.() -> Unit,
+        )
+
+        protected fun CodebaseContext.runTestCase(
+            testCase: TestCase,
+            valueUseSite: ValueUseSite,
+            test: TestCaseContext.() -> Unit
+        ) {
+            val testCaseContext = TestCaseContext(this, testCase, kind, valueUseSite)
+            testCaseContext.test()
+        }
+
+        final override fun toString() = kind.toString().lowercase()
+    }
+
+    /**
+     * Base of classes that perform a specific test on a [Codebase] produced by [CodebaseProducer].
+     */
+    class TestCase(
+        /** The [ValueExample] on which this test case is based. */
+        val valueExample: ValueExample,
+    ) : Assertions {
+        private val testClassesByInputFormat = mutableMapOf<InputFormat, TestClasses>()
+
+        /** Get the [TestClass] appropriate for [valueUseSite]. */
+        fun testClassFor(inputFormat: InputFormat, valueUseSite: ValueUseSite) =
+            testClassesByInputFormat
+                .computeIfAbsent(inputFormat) {
+                    val creator =
+                        when (it) {
+                            InputFormat.JAVA -> JavaTestClassCreator
+                            InputFormat.KOTLIN -> KotlinTestClassCreator
+                            InputFormat.SIGNATURE -> SignatureTestClassCreator
+                            else -> error("Unknown input format: $inputFormat")
+                        }
+
+                    TestClasses(creator, valueExample)
+                }
+                .testClassFor(valueUseSite)
+
+        override fun toString() = valueExample.name
+    }
+
+    /**
+     * Creates and caches the [TestClass]es needed for [valueExample].
+     *
+     * When first requested for a [TestClass] for [ValueUseSite] in [testClassFor] it will invoke
+     * [testClassCreator] to create one, cache it and return it. On subsequent calls it will return
+     * the cached version. This ensures a single [TestClass] for each [ValueUseSite]/[ValueExample]
+     * combination.
+     *
+     * @param testClassCreator responsible for creating instances of the [TestClass] that this
+     *   caches.
+     * @param valueExample the [ValueExample] for which the [TestClass]es are created.
+     */
+    class TestClasses(
+        private val testClassCreator: TestClassCreator,
+        private val valueExample: ValueExample
+    ) {
+        /** Get the [TestClass] appropriate for [valueUseSite]. */
+        fun testClassFor(valueUseSite: ValueUseSite) =
+            when (valueUseSite) {
+                ValueUseSite.ATTRIBUTE_VALUE,
+                ValueUseSite.ANNOTATION_TO_SOURCE -> annotatedWithAnnotationWithoutDefaults
+                ValueUseSite.ATTRIBUTE_DEFAULT_VALUE -> annotationWithDefaults
+                ValueUseSite.FIELD_VALUE,
+                ValueUseSite.FIELD_WRITE_WITH_SEMICOLON -> field
+            }
+
+        /**
+         * A class called `AnnotationWithDefault_...` for [valueExample] using
+         * [ValueExample.javaExpression] as the default value of the [ATTRIBUTE_NAME] attribute.
+         */
+        private val annotationWithDefaults by
+            lazy(LazyThreadSafetyMode.NONE) {
+                testClassCreator.generateAnnotationClass(
+                    valueExample,
+                    "AnnotationWithDefaults",
+                    withDefaults = true,
+                )
+            }
+
+        /**
+         * A class called `AnnotationTestClass_...` for [valueExample] which is annotated with an
+         * annotation called `AnnotationWithoutDefaults_...` whose [ATTRIBUTE_NAME] attribute has a
+         * value of [ValueExample.javaExpression].
+         */
+        private val annotatedWithAnnotationWithoutDefaults by
+            lazy(LazyThreadSafetyMode.NONE) {
+                val annotationWithoutDefaults =
+                    testClassCreator.generateAnnotationClass(
+                        valueExample,
+                        "AnnotationWithoutDefaults",
+                        withDefaults = false,
+                    )
+
+                testClassCreator.generateAnnotatedTestClass(
+                    valueExample,
+                    "AnnotationTestClass",
+                    annotationWithoutDefaults
+                )
+            }
+
+        /**
+         * A class called `FieldTestClass_...` for [valueExample] whose [FIELD_NAME] has a value of
+         * [ValueExample.javaExpression].
+         */
+        private val field by
+            lazy(LazyThreadSafetyMode.NONE) {
+                testClassCreator.generateFieldTestClass(
+                    valueExample,
+                    "FieldTestClass",
+                )
+            }
+    }
+
+    /**
+     * A test class to run against.
+     *
+     * @param className the name of the test class (in the `test.pkg` package).
+     * @param testFileSet the complete set of [TestFile]s needed to compile the test class.
+     */
+    data class TestClass(val className: String, val testFileSet: Set<TestFile>) {
+        /** Return a new instance of this adding [dependency] to [testFileSet]. */
+        fun dependsOn(dependency: TestFile) = copy(testFileSet = testFileSet + dependency)
+
+        /** Return a new instance of this adding [dependency] to [testFileSet]. */
+        fun dependsOn(dependency: TestClass) =
+            copy(testFileSet = testFileSet + dependency.testFileSet)
+    }
+
+    companion object {
+        /** Filter the parameters. */
+        @JvmStatic
+        @ParameterFilter
+        fun parameterFilter(
+            config: CodebaseCreatorConfig<ModelSuiteRunner>,
+            producer: CodebaseProducer,
+            testCase: TestCase,
+        ): Boolean {
+            val inputFormat = config.inputFormat
+
+            // Ignore any tests that are not valid for the InputFormat.
+            return inputFormat in testCase.valueExample.validForInputFormats &&
+                // Supports all input formats but only Java can produce jars.
+                (inputFormat == InputFormat.JAVA || producer.kind != ProducerKind.JAR)
+        }
+
+        /** The set of [TestCase]s to run in each [CodebaseProducer] in [codebaseProducers]. */
+        private val testCases = run {
+            // Verify that all the ValueExamples have distinct names.
+            val duplicates =
+                valueExamples
+                    .groupingBy { it.name }
+                    .eachCount()
+                    .filter { it.value > 1 }
+                    .map { it.key }
+            if (duplicates.isNotEmpty()) {
+                error("Duplicate value examples: $duplicates")
+            }
+
+            // Construct [TestCase]s from [ValueExample].
+            valueExamples.map { TestCase(it) }
+        }
+
+        /** The list of [CodebaseProducer]s for which all the [testCases] will be run. */
+        private val codebaseProducers =
+            listOf(
+                JarCodebaseProducer(),
+                SourceCodebaseProducer,
+            )
+
+        internal fun testCasesForValueUseSite(valueUseSite: ValueUseSite) =
+            testCases.filter {
+                // Only select TestCase's whose ValueExample is suitable for the specified
+                // ValueUseSite.
+                valueUseSite in it.valueExample.suitableFor
+            }
+
+        /** Create cross product of [codebaseProducers] and [testCases]. */
+        internal fun testCasesForCodebaseProducers(
+            testCases: List<TestCase>,
+        ) =
+            codebaseProducers.flatMap { codebaseProducer ->
+                testCases.map { testCase -> arrayOf(codebaseProducer, testCase) }
+            }
+    }
+
+    /**
+     * Produce a [Codebase] from [TestCase.testClassFor]'s [TestClass.testFileSet] and then run
+     * [TestCase] against it.
+     */
+    private object SourceCodebaseProducer : CodebaseProducer(ProducerKind.SOURCE) {
+        override fun BaseCommonParameterizedValueTest.runCodebaseProducerTest(
+            testFileCache: TestFileCache,
+            testCase: TestCase,
+            test: TestCaseContext.() -> Unit
+        ) {
+            // Cache the sources so that they can be reused.
+            val sources =
+                testCase.testClassFor(inputFormat, valueUseSite).testFileSet.map {
+                    it.cacheIn(testFileCache)
+                }
+
+            // Run the test on the sources.
+            runSourceCodebaseTest(inputSet(sources.toList())) {
+                runTestCase(testCase, valueUseSite, test)
+            }
+        }
+    }
+
+    /** Produce a [Codebase] from [testJarFile]. */
+    private class JarCodebaseProducer : CodebaseProducer(ProducerKind.JAR) {
+        override fun BaseCommonParameterizedValueTest.runCodebaseProducerTest(
+            testFileCache: TestFileCache,
+            testCase: TestCase,
+            test: TestCaseContext.() -> Unit
+        ) {
+            // Cache the jar file so that it will be reused.
+            val cachedJarFile = testJarFile.cacheIn(testFileCache)
+
+            runSourceCodebaseTest(
+                // Unused class, present simply to force the test to be run against models that
+                // support Java.
+                java(
+                    """
+                        package test.pkg;
+                        public class Foo {}
+                    """
+                ),
+                testFixture =
+                    TestFixture(
+                        additionalClassPath = listOf(cachedJarFile.createFile(temporaryFolder.root))
+                    ),
+            ) {
+                runTestCase(testCase, valueUseSite, test)
+            }
+        }
+    }
+
+    /**
+     * Base class for the subclass companion objects.
+     *
+     * Makes it easy to share behavior between them.
+     */
+    open class BaseCompanion(private val valueUseSite: ValueUseSite) {
+        /** The list of all [valueUseSite] test cases. */
+        private val valueUseTestCases = testCasesForValueUseSite(valueUseSite)
+
+        /** The list of parameters for this test class. */
+        val testParameters = testCasesForCodebaseProducers(valueUseTestCases)
+
+        /** Jar file built from all java source files in [testParameters]. */
+        val testJarFile = produceJarTestFile(valueUseTestCases)
+
+        /** Produce a jar from all the distinct [TestFile]s used by [testCases]. */
+        private fun produceJarTestFile(testCases: List<TestCase>): TestFile {
+            // The jar includes all the distinct [TestFile]s used by [testCases].
+            val sourcesForJar = buildSet {
+                for (testCase in testCases) {
+                    addAll(testCase.testClassFor(InputFormat.JAVA, valueUseSite).testFileSet)
+                }
+            }
+
+            // Jar file containing compiled versions of [sourcesForJar].
+            return jarFromSources(
+                "binary-class.jar",
+                *sourcesForJar.toTypedArray(),
+            )
+        }
+    }
+
+    /** Context within which test cases will be run. */
+    class TestCaseContext(
+        delegate: CodebaseContext,
+        private val testCase: TestCase,
+        val producerKind: ProducerKind,
+        private val valueUseSite: ValueUseSite,
+    ) : CodebaseContext by delegate {
+        /** Get the [ClassItem] to be tested from this [Codebase]. */
+        val testClassItem
+            get(): ClassItem {
+                val qualifiedName =
+                    "test.pkg.${testCase.testClassFor(inputFormat, valueUseSite).className}"
+                return codebase.resolveClass(qualifiedName)
+                    ?: error("Expected $qualifiedName to be defined")
+            }
+    }
+
+    /** Run a test on the [Codebase] produced by [codebaseProducer]. */
+    private fun runTestOnCodebase(function: TestCaseContext.() -> Unit) {
+        val thisClass = this
+        with(codebaseProducer) {
+            thisClass.runCodebaseProducerTest(testFileCache, testCase, function)
+        }
+    }
+
+    /**
+     * Run an expectation test.
+     *
+     * Invokes [actualGetter] to get the actual value to compare and compares it against the
+     * expected value retrieved from [expectation].
+     *
+     * @param expectation the [Expectation] that will provide the expected value.
+     * @param actualGetter lambda to get the actual value to test.
+     */
+    private fun <T> runExpectationTest(
+        expectation: Expectation<T>,
+        actualGetter: TestCaseContext.() -> T,
+    ) {
+        runTestOnCodebase {
+            // Get the actual value.
+            val actual = actualGetter()
+
+            // Get the expected value.
+            val expected = expectation.expectationFor(producerKind, valueUseSite, codebase)
+
+            // Compare the two.
+            assertEquals(expected, actual)
+        }
+    }
+
+    @Test
+    fun testLegacySource() {
+        val expectedLegacySource = testCase.valueExample.expectedLegacySourceFor(inputFormat)
+        runExpectationTest(expectedLegacySource, legacySourceGetter)
+    }
+}
+
+/** Interface for objects that create [TestClass] instances. */
+interface TestClassCreator {
+    companion object {
+        const val ATTRIBUTE_NAME = "attr"
+        const val FIELD_NAME = "FIELD"
+    }
+
+    /**
+     * Create an annotation [TestClass] for [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param withDefaults true if defaults should be added, false otherwise.
+     */
+    fun generateAnnotationClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        withDefaults: Boolean
+    ): TestClass
+
+    /**
+     * Create a normal [TestClass] annotated with [annotationTestClass].
+     *
+     * The annotation uses the appropriate values from this [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param annotationTestClass the annotation [TestClass] to annotate the class with.
+     */
+    fun generateAnnotatedTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        annotationTestClass: TestClass,
+    ): TestClass
+
+    /**
+     * Create a [TestClass] containing a "constant" field for this [[valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     */
+    fun generateFieldTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+    ): TestClass
+
+    /** Create a [TestClass] for [className] containing this [TestFile]. */
+    fun TestFile.asTestClass(className: String): TestClass {
+        return TestClass(className, setOf(this))
+    }
+}
+
+/** Create java [TestClass]es for use by [BaseCommonParameterizedValueTest]. */
+object JavaTestClassCreator : TestClassCreator {
+    private val testConstantsClass =
+        java(
+            """
+                package test.pkg;
+                public interface Constants {
+                    String STRING_CONSTANT = "constant";
+                }
+            """
+        )
+
+    private val testEnumClass =
+        java(
+            """
+                package test.pkg;
+                public enum TestEnum {
+                    DEFAULT,
+                    VALUE1,
+                }
+            """
+        )
+
+    private val otherAnnotationClass =
+        java(
+                """
+                    package test.pkg;
+
+                    public @interface OtherAnnotation {
+                        Class<?> classType() default void.class;
+                        TestEnum enumType() default TestEnum.DEFAULT;
+                        int intType() default -1;
+                        String stringType() default "default";
+                        String[] stringArrayType() default {};
+                    }
+                """
+            )
+            .asTestClass("OtherAnnotation")
+            .dependsOn(testEnumClass)
+
+    /** Append all the imports provided by this list to [buffer]. */
+    private fun appendImportsTo(valueExample: ValueExample, buffer: StringBuilder) {
+        for (javaImport in valueExample.javaImports) {
+            buffer.append("import ")
+            buffer.append(javaImport)
+            buffer.append(";\n")
+        }
+    }
+
+    /**
+     * Create an annotation [TestClass] for [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param withDefaults true if defaults should be added, false otherwise.
+     */
+    override fun generateAnnotationClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        withDefaults: Boolean
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return java(
+                buildString {
+                    append("package test.pkg;\n")
+                    appendImportsTo(valueExample, this)
+                    append("public @interface $className {\n")
+                    append("    ")
+                    append(valueExample.javaType)
+                    append(" ")
+                    append(ATTRIBUTE_NAME)
+                    append("()")
+                    if (withDefaults) {
+                        append(" default ")
+                        append(valueExample.javaExpression)
+                    }
+                    append(";\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+
+    /**
+     * Create a normal [TestClass] annotated with [annotationTestClass].
+     *
+     * The annotation uses the appropriate values from this [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param annotationTestClass the annotation [TestClass] to annotate the class with.
+     */
+    override fun generateAnnotatedTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        annotationTestClass: TestClass,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return java(
+                buildString {
+                    append("package test.pkg;\n")
+                    appendImportsTo(valueExample, this)
+                    append("@")
+                    append(annotationTestClass.className)
+                    append("(")
+                    append(ATTRIBUTE_NAME)
+                    append(" = ")
+                    append(valueExample.javaExpression)
+                    append(")\n")
+                    append("public class $className {}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(annotationTestClass)
+    }
+
+    /**
+     * Create a [TestClass] containing a "constant" field for this [[valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     */
+    override fun generateFieldTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return java(
+                buildString {
+                    append("package test.pkg;\n")
+                    appendImportsTo(valueExample, this)
+                    append("public class $className {\n")
+                    append("    public static final ")
+                    append(valueExample.javaType)
+                    append(" ")
+                    append(FIELD_NAME)
+                    append(" = ")
+                    append(valueExample.javaExpression)
+                    append(";\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+}
+
+/** Create kotlin [TestClass]es for use by [BaseCommonParameterizedValueTest]. */
+object KotlinTestClassCreator : TestClassCreator {
+    private val testConstantsClass =
+        kotlin(
+            """
+                package test.pkg
+                object Constants {
+                    const val STRING_CONSTANT = "constant"
+                }
+            """
+        )
+
+    private val testEnumClass =
+        kotlin(
+            """
+                package test.pkg
+                enum class TestEnum {
+                    DEFAULT,
+                    VALUE1,
+                }
+            """
+        )
+
+    private val otherAnnotationClass =
+        kotlin(
+                """
+                    package test.pkg
+
+                    annotation class OtherAnnotation(
+                        val classType: Class<*> = void.javaClass,
+                        val enumType: TestEnum = TestEnum.DEFAULT,
+                        val intType: Int = -1,
+                        val stringType: String = "default",
+                        val stringArrayType: Array<String> = emptyArray(),
+                    )
+                """
+            )
+            .asTestClass("OtherAnnotation")
+            .dependsOn(testEnumClass)
+
+    /**
+     * Create an annotation [TestClass] for [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param withDefaults true if defaults should be added, false otherwise.
+     */
+    override fun generateAnnotationClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        withDefaults: Boolean
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return kotlin(
+                buildString {
+                    append("package test.pkg\n")
+                    append("annotation class $className(\n")
+                    append("    val ")
+                    append(ATTRIBUTE_NAME)
+                    append(": ")
+                    append(valueExample.kotlinType)
+                    if (withDefaults) {
+                        append(" = ")
+                        append(valueExample.kotlinExpression)
+                    }
+                    append("\n")
+                    append(")\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+
+    /**
+     * Create a normal [TestClass] annotated with [annotationTestClass].
+     *
+     * The annotation uses the appropriate values from this [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param annotationTestClass the annotation [TestClass] to annotate the class with.
+     */
+    override fun generateAnnotatedTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        annotationTestClass: TestClass,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return kotlin(
+                buildString {
+                    append("package test.pkg\n")
+                    append("@")
+                    append(annotationTestClass.className)
+                    append("(")
+                    append(ATTRIBUTE_NAME)
+                    append(" = ")
+                    append(valueExample.kotlinExpression)
+                    append(")\n")
+                    append("class $className {}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(annotationTestClass)
+    }
+
+    /**
+     * Create a [TestClass] containing a "constant" field for this [[valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     */
+    override fun generateFieldTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return kotlin(
+                buildString {
+                    append("package test.pkg\n")
+                    append("class $className {\n")
+                    append("    companion object {\n")
+                    append("        const val ")
+                    append(FIELD_NAME)
+                    append(": ")
+                    append(valueExample.kotlinType)
+                    append(" = ")
+                    append(valueExample.kotlinExpression)
+                    append("\n")
+                    append("    }\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+}
+
+/** Creates signature [TestClass]es for use by [BaseCommonParameterizedValueTest]. */
+object SignatureTestClassCreator : TestClassCreator {
+    private val testConstantsClass =
+        signature(
+            "constants.txt",
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Constants {
+                    field public static final String STRING_CONSTANT = "constant";
+                  }
+                }
+            """
+        )
+
+    private val testEnumClass =
+        signature(
+            "test-enum.txt",
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public enum TestEnum {
+                    enum_constant public static final test.pkg.TestEnum DEFAULT;
+                    enum_constant public static final test.pkg.TestEnum VALUE1;
+                  }
+                }
+            """
+        )
+
+    private val otherAnnotationClass =
+        signature(
+                "other-annotation.txt",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public @interface OtherAnnotation {
+                        method public Class<?> classType() default void.class;
+                        method public test.pkg.TestEnum enumType() default test.pkg.TestEnum.DEFAULT;
+                        method public int intType() default -1;
+                        method public String stringType() default "default";
+                        method public String[] stringArrayType() default {};
+                      }
+                    }
+                """
+            )
+            .asTestClass("OtherAnnotation")
+            .dependsOn(testEnumClass)
+
+    /**
+     * Create an annotation [TestClass] for [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param withDefaults true if defaults should be added, false otherwise.
+     */
+    override fun generateAnnotationClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        withDefaults: Boolean
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return signature(
+                "$className.txt",
+                buildString {
+                    append("// Signature format: 2.0\n")
+                    append("package test.pkg {\n")
+                    append("  public @interface $className {\n")
+                    append("    method public abstract ")
+                    append(valueExample.signatureType)
+                    append(" ")
+                    append(ATTRIBUTE_NAME)
+                    append("()")
+                    if (withDefaults) {
+                        append(" default ")
+                        append(valueExample.signatureExpression)
+                    }
+                    append(";\n")
+                    append("  }\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+
+    /**
+     * Create a normal [TestClass] annotated with [annotationTestClass].
+     *
+     * The annotation uses the appropriate values from this [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     * @param annotationTestClass the annotation [TestClass] to annotate the class with.
+     */
+    override fun generateAnnotatedTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+        annotationTestClass: TestClass,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return signature(
+                "$className.txt",
+                buildString {
+                    append("// Signature format: 2.0\n")
+                    append("package test.pkg {\n")
+                    append("  @")
+                    append(annotationTestClass.className)
+                    append("(")
+                    append(ATTRIBUTE_NAME)
+                    append(" = ")
+                    append(valueExample.signatureExpression)
+                    append(") ")
+                    append("public class $className {\n")
+                    append("  }\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(annotationTestClass)
+    }
+
+    /**
+     * Create a [TestClass] containing a "constant" field for this [valueExample].
+     *
+     * @param valueExample the [ValueExample] for which this is being created.
+     * @param classNamePrefix the prefix of the class.
+     */
+    override fun generateFieldTestClass(
+        valueExample: ValueExample,
+        classNamePrefix: String,
+    ): TestClass {
+        val className = "${classNamePrefix}_${valueExample.classSuffix}"
+        return signature(
+                "$className.txt",
+                buildString {
+                    append("// Signature format: 2.0\n")
+                    append("package test.pkg {\n")
+                    append("  public class $className {\n")
+                    append("    field public static final ")
+                    append(valueExample.signatureType)
+                    append(" ")
+                    append(FIELD_NAME)
+                    append(" = ")
+                    append(valueExample.signatureExpression)
+                    append(";\n")
+                    append("  }\n")
+                    append("}\n")
+                }
+            )
+            .asTestClass(className)
+            .dependsOn(otherAnnotationClass)
+            .dependsOn(testConstantsClass)
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt
new file mode 100644
index 000000000..58e6d5833
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ANNOTATION_TO_SOURCE
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import org.junit.ClassRule
+import org.junit.runners.Parameterized
+
+/** Run parameterized tests for [ANNOTATION_TO_SOURCE]. */
+class CommonParameterizedAnnotationToSourceValueTest :
+    BaseCommonParameterizedValueTest(
+        testFileCacheRule.cache,
+        testJarFile,
+        ANNOTATION_TO_SOURCE,
+        legacySourceGetter = {
+            // Get the annotation to test.
+            val annotation = testClassItem.modifiers.annotations().first()
+
+            // Generate the whole annotation representation.
+            val wholeAnnotation = annotation.toSource()
+
+            // Extract the value from the whole annotation.
+            wholeAnnotation.substringAfter("=").substringBeforeLast(")")
+        },
+    ) {
+    companion object : BaseCompanion(ANNOTATION_TO_SOURCE) {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testParameters
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt
new file mode 100644
index 000000000..f35947bad
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Assertions.Companion.assertMethod
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
+import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ATTRIBUTE_DEFAULT_VALUE
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import org.junit.ClassRule
+import org.junit.runners.Parameterized
+
+/** Run parameterized tests for [ATTRIBUTE_DEFAULT_VALUE]. */
+class CommonParameterizedAttributeDefaultValueTest :
+    BaseCommonParameterizedValueTest(
+        testFileCacheRule.cache,
+        testJarFile,
+        ATTRIBUTE_DEFAULT_VALUE,
+        legacySourceGetter = {
+            val annotationMethod = testClassItem.assertMethod(ATTRIBUTE_NAME, "")
+
+            annotationMethod.legacyDefaultValue()
+        },
+    ) {
+    companion object : BaseCompanion(ATTRIBUTE_DEFAULT_VALUE) {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testParameters
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt
new file mode 100644
index 000000000..1e3884137
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Assertions.Companion.assertAttribute
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
+import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ATTRIBUTE_VALUE
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import org.junit.ClassRule
+import org.junit.runners.Parameterized
+
+/** Run parameterized tests for [ATTRIBUTE_VALUE]. */
+class CommonParameterizedAttributeValueTest :
+    BaseCommonParameterizedValueTest(
+        testFileCacheRule.cache,
+        testJarFile,
+        ATTRIBUTE_VALUE,
+        legacySourceGetter = {
+            val annotation = testClassItem.modifiers.annotations().first()
+            val annotationAttribute = annotation.assertAttribute(ATTRIBUTE_NAME)
+
+            annotationAttribute.legacyValue.toSource()
+        }
+    ) {
+    companion object : BaseCompanion(ATTRIBUTE_VALUE) {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testParameters
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt
new file mode 100644
index 000000000..352f3ce9e
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Assertions.Companion.assertField
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
+import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
+import com.android.tools.metalava.model.testsuite.value.ValueUseSite.FIELD_VALUE
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import kotlin.test.assertNotNull
+import org.junit.ClassRule
+import org.junit.runners.Parameterized
+
+/** Run parameterized tests for [FIELD_VALUE]. */
+class CommonParameterizedFieldValueTest :
+    BaseCommonParameterizedValueTest(
+        testFileCacheRule.cache,
+        testJarFile,
+        FIELD_VALUE,
+        legacySourceGetter = {
+            val field = testClassItem.assertField(FIELD_NAME)
+            val fieldValue = assertNotNull(field.legacyFieldValue, "No field value")
+            fieldValue.initialValue(true)?.toString() ?: NO_INITIAL_FIELD_VALUE
+        },
+    ) {
+    companion object : BaseCompanion(FIELD_VALUE) {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testParameters
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt
new file mode 100644
index 000000000..85fe97032
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Assertions.Companion.assertField
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
+import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
+import com.android.tools.metalava.model.testsuite.value.ValueUseSite.FIELD_WRITE_WITH_SEMICOLON
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import java.io.PrintWriter
+import java.io.StringWriter
+import org.junit.ClassRule
+import org.junit.runners.Parameterized
+
+/** Run parameterized tests for [FIELD_WRITE_WITH_SEMICOLON]. */
+class CommonParameterizedFieldWriteWithSemicolonValueTest :
+    BaseCommonParameterizedValueTest(
+        testFileCacheRule.cache,
+        testJarFile,
+        FIELD_WRITE_WITH_SEMICOLON,
+        legacySourceGetter = {
+            val field = testClassItem.assertField(FIELD_NAME)
+
+            // Print the field with semicolon.
+            val stringWriter = StringWriter()
+            PrintWriter(stringWriter).use { writer -> field.writeValueWithSemicolon(writer) }
+            val withSemicolon = stringWriter.toString()
+
+            // Extract the value from the " = ...; // ...." string.
+            if (withSemicolon == ";") NO_INITIAL_FIELD_VALUE
+            else withSemicolon.substringAfter(" = ").substringBefore(";")
+        },
+    ) {
+    companion object : BaseCompanion(FIELD_WRITE_WITH_SEMICOLON) {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testParameters
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt
new file mode 100644
index 000000000..6d7983e8d
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Codebase
+import kotlin.properties.ReadWriteProperty
+import kotlin.reflect.KProperty
+
+/** Encapsulates a set of expectations about values. */
+interface Expectation<out T> {
+    /**
+     * Get the expectations of type [T] for [producerKind] at [valueUseSite] for testing within
+     * [codebase].
+     */
+    fun expectationFor(
+        producerKind: ProducerKind,
+        valueUseSite: ValueUseSite,
+        codebase: Codebase
+    ): T
+}
+
+/**
+ * Builder for expectations.
+ *
+ * This makes it easy to create a set of expectations for all possible combinations of
+ * [ProducerKind] and [ValueUseSite] without duplicating effort.
+ */
+internal fun <T : Any> expectations(body: ExpectationsBuilder<T>.() -> Unit) =
+    nullableExpectations(body = body)
+
+/**
+ * Builder for expectations that allows null.
+ *
+ * This allows the creation of full sets that throw an exception if it is not complete and partial
+ * sets that return `null`.
+ *
+ * @param optionalDefaultValueProvider lambda that provides the default expected value when no
+ *   specific one has been set. Defaults to throwing an exception.
+ */
+private fun <T> nullableExpectations(
+    optionalDefaultValueProvider: ((ExpectationKey) -> T)? = null,
+    body: ExpectationsBuilder<T>.() -> Unit
+): Expectation<T> {
+    val builder = ExpectationsBuilder<T>()
+    builder.body()
+    return builder.expectations(optionalDefaultValueProvider)
+}
+
+/**
+ * Builder for partial expectations.
+ *
+ * Allows `null` values and is expected to be a partial set of expectations that falls back to
+ * another set of expectations. See [fallBackTo].
+ */
+internal fun <T> partialExpectations(body: ExpectationsBuilder<T?>.() -> Unit) =
+    nullableExpectations(optionalDefaultValueProvider = { null }, body = body)
+
+/**
+ * Create an [Expectation] from an [Expectation] that returns `null`, i.e. a partial set, by falling
+ * back to another [Expectation] that does not contain `null`, i.e. a full set.
+ *
+ * If `this` and [other] are the same then just return [other] as there is no point in chaining
+ * them. [other] was chosen to be returned as it has the correct type.
+ */
+fun <T> Expectation<T?>.fallBackTo(other: Expectation<T>) =
+    if (this === other) other else ChainedExpectation(this, other)
+
+/** Produces an expectation of type `T` from a [Codebase]. */
+typealias CodebaseExpectationProducer<T> = (Codebase) -> T
+
+/**
+ * Create an [Expectation] that instead of storing the expectations or type [T] will store
+ * [CodebaseExpectationProducer] that when passed a [Codebase] will produce the expectation.
+ *
+ * Needed for creating expectations that require a [Codebase].
+ */
+internal fun <T> codebaseExpectations(
+    body: ExpectationsBuilder<CodebaseExpectationProducer<T>>.() -> Unit
+): Expectation<T> {
+    // Create an intermediate [Expectation] that takes `CodebaseExpectationProducer<T>`s instead of
+    // `T`s.
+    val intermediate = expectations(body)
+
+    // Wrap that intermediate object in another that will delegate to it to obtain a
+    // `CodebaseExpectationProducer<T>` and then return the expectation it produces.
+    return object : Expectation<T> {
+        override fun expectationFor(
+            producerKind: ProducerKind,
+            valueUseSite: ValueUseSite,
+            codebase: Codebase
+        ): T {
+            val producer = intermediate.expectationFor(producerKind, valueUseSite, codebase)
+            return producer(codebase)
+        }
+    }
+}
+
+/**
+ * A [ReadWriteProperty] which will store the value that is set on the property in [map] for all
+ * [keys].
+ */
+internal class MutableMapDelegate<K, T>(
+    internal val map: MutableMap<K, T>,
+    private val keys: List<K>
+) : ReadWriteProperty<Any?, T> {
+    override fun getValue(thisRef: Any?, property: KProperty<*>) = error("Cannot read value")
+
+    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
+        for (key in keys) {
+            map[key] = value
+        }
+    }
+}
+
+/** The key into the map of expected values in [ExpectationsBuilder.ExpectationMap]. */
+private typealias ExpectationKey = Pair<ProducerKind, ValueUseSite>
+
+/**
+ * Populates [expectationMap] with values for all [producerKinds].
+ *
+ * @param producerKinds the list of [ProducerKind]s whose expectations will be set.
+ */
+internal open class PerProducerKindBuilder<T>(
+    private val producerKinds: List<ProducerKind>,
+    val expectationMap: MutableMap<ExpectationKey, T>
+) {
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.entries].
+     *
+     * This must be set before any of the other properties as this will overwrite them.
+     */
+    var common: T by
+        MutableMapDelegate(
+            expectationMap,
+            producerKinds.flatMap { producerKind ->
+                ValueUseSite.entries.map { producerKind to it }
+            }
+        )
+
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.ATTRIBUTE_VALUE].
+     */
+    var attributeValue: T by
+        MutableMapDelegate(expectationMap, producerKinds.map { it to ValueUseSite.ATTRIBUTE_VALUE })
+
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.ATTRIBUTE_VALUE].
+     */
+    var annotationToSource: T by
+        MutableMapDelegate(
+            expectationMap,
+            producerKinds.map { it to ValueUseSite.ANNOTATION_TO_SOURCE }
+        )
+
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.ATTRIBUTE_DEFAULT_VALUE].
+     */
+    var attributeDefaultValue: T by
+        MutableMapDelegate(
+            expectationMap,
+            producerKinds.map { it to ValueUseSite.ATTRIBUTE_DEFAULT_VALUE }
+        )
+
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.FIELD_VALUE].
+     */
+    var fieldValue: T by
+        MutableMapDelegate(expectationMap, producerKinds.map { it to ValueUseSite.FIELD_VALUE })
+
+    /**
+     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
+     * [ValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
+     */
+    var fieldWriteWithSemicolon: T by
+        MutableMapDelegate(
+            expectationMap,
+            producerKinds.map { it to ValueUseSite.FIELD_WRITE_WITH_SEMICOLON }
+        )
+}
+
+/**
+ * The top level [ExpectationsBuilder].
+ *
+ * Setting [common] on this will set the same expectation across all tests. Setting one of the other
+ * [PerProducerKindBuilder] properties will set the value across all [ProducerKind]s.
+ */
+internal class ExpectationsBuilder<T> :
+    PerProducerKindBuilder<T>(ProducerKind.entries, mutableMapOf()) {
+
+    /** Set expectations just for [ProducerKind.SOURCE]s. */
+    fun source(body: PerProducerKindBuilder<T>.() -> Unit) {
+        val builder = PerProducerKindBuilder(listOf(ProducerKind.SOURCE), expectationMap)
+        builder.body()
+    }
+
+    /** Set expectations just for [ProducerKind.JAR]s. */
+    fun jar(body: PerProducerKindBuilder<T>.() -> Unit) {
+        val builder = PerProducerKindBuilder(listOf(ProducerKind.JAR), expectationMap)
+        builder.body()
+    }
+
+    /** Get the set of expectations that have been built. */
+    fun expectations(
+        optionalDefaultValueProvider: ((ExpectationKey) -> T)? = null
+    ): Expectation<T> {
+        val defaultValueProvider =
+            optionalDefaultValueProvider ?: { error("Could not find expectation for $it") }
+        return ExpectationMap(expectationMap, defaultValueProvider)
+    }
+
+    /**
+     * [Expectation] implementation that just delegates to [Map], throwing an exception if no value
+     * could be found.
+     */
+    internal class ExpectationMap<T>(
+        val map: MutableMap<ExpectationKey, T>,
+        private val defaultValueProvider: (ExpectationKey) -> T,
+    ) : Expectation<T> {
+        override fun expectationFor(
+            producerKind: ProducerKind,
+            valueUseSite: ValueUseSite,
+            codebase: Codebase
+        ): T {
+            val key = producerKind to valueUseSite
+            return map[key] ?: defaultValueProvider(key)
+        }
+    }
+}
+
+/**
+ * An [Expectation] that will check in [first] and if no expected value is found (i.e.
+ * [expectationFor] returns `null`) then delegate to the [second].
+ */
+private class ChainedExpectation<T>(
+    private val first: Expectation<T?>,
+    private val second: Expectation<T>,
+) : Expectation<T> {
+    override fun expectationFor(
+        producerKind: ProducerKind,
+        valueUseSite: ValueUseSite,
+        codebase: Codebase
+    ) =
+        first.expectationFor(producerKind, valueUseSite, codebase)
+            ?: second.expectationFor(producerKind, valueUseSite, codebase)
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ProducerKind.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ProducerKind.kt
new file mode 100644
index 000000000..5061e8062
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ProducerKind.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Codebase
+
+/**
+ * The kinds of [Codebase] producers.
+ *
+ * They are enumerated here because they can affect how values are represented. e.g. an annotation
+ * attribute that is specified by a constant field in the source will be represented by the value of
+ * the constant field in a jar.
+ */
+enum class ProducerKind {
+    JAR,
+    SOURCE,
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt
new file mode 100644
index 000000000..fa0682a17
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt
@@ -0,0 +1,948 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
+import java.util.EnumSet
+
+/**
+ * Encapsulates information about a value example.
+ *
+ * This will be useful for a number of different tests around values.
+ */
+class ValueExample(
+    /**
+     * The name of the example.
+     *
+     * This is used both in the type name and as the attribute name in an annotation class so it
+     * must be unique across all [ValueExample]s.
+     */
+    val name: String,
+
+    /** The java type. */
+    val javaType: String,
+
+    /** The java expression for the value. */
+    val javaExpression: String,
+
+    /**
+     * The Kotlin type.
+     *
+     * Primitive types are different between Java and Kotlin, as are some other types, but most
+     * custom types are the same so default to [javaType].
+     */
+    val kotlinType: String = javaType,
+
+    /**
+     * The Kotlin expression.
+     *
+     * Some Kotlin expressions are different to Java but many are the same so default to
+     * [javaExpression].
+     */
+    val kotlinExpression: String = javaExpression,
+
+    /** The optional java imports. */
+    val javaImports: List<String> = emptyList(),
+
+    /**
+     * The signature type, defaults to [javaType] as signature files generally use Java types and
+     * values but needs to be overridden in some cases, e.g. to use qualified types in place of
+     * unqualified types as signature files requires most types to be qualified.
+     */
+    val signatureType: String = javaType,
+
+    /**
+     * The signature expression, defaults to [javaExpression] as signature files generally use Java
+     * types and values but needs to be overridden in some cases, e.g. to use qualified types in
+     * place of unqualified types as signature files requires most types to be qualified.
+     */
+    val signatureExpression: String = javaExpression,
+
+    /** The set of [ValueUseSite]s in which this example will be tested; defaults to all of them. */
+    val suitableFor: Set<ValueUseSite> = allValueUseSites,
+
+    /** The set of [InputFormat]s for which this example is valid. */
+    val validForInputFormats: Set<InputFormat> = allInputFormats,
+
+    /**
+     * The legacy string representation of [javaExpression].
+     *
+     * This may differ by [ProducerKind] and [ValueUseSite].
+     */
+    private val expectedLegacySource: Expectation<String>,
+
+    /**
+     * Kotlin source expressions can have a different representation than the same source expression
+     * in Java.
+     *
+     * Rather than make [Expectation] support another dimension on top of [ValueUseSite] and
+     * [ProducerKind] for the few cases where there are differences, it is handled by having this
+     * Kotlin specific expectation sit alongside and default to [expectedLegacySource].
+     */
+    private val expectedKotlinLegacySource: Expectation<String?> = expectedLegacySource,
+
+    /**
+     * Controls which [ValueExample]s in [allValueExamples] are run.
+     *
+     * When all the [ValueExample]s have this set to `false` (the default) then they are all tests.
+     * If any [ValueExample] has this set to `true` then only the ones with this set to `true` are
+     * tested. Care must be taken to ensure that this is not set to `true` in uploaded changes.
+     *
+     * This is added to simplify adding a new [ValueExample] or working on an existing
+     * [ValueExample] by limiting the ones which will be tested to save time and reduce the noise of
+     * failing tests.
+     */
+    val testThis: Boolean = false,
+) {
+    /**
+     * If the field is not a constant then wrap it in an Expectation that will enforce that fields
+     * only have constant values.
+     */
+    private fun wrapLegacySource(expectation: Expectation<String>) =
+        if (isConstant) expectation
+        else constantFieldLegacySourceExpectation.fallBackTo(expectation)
+
+    /** Get the expected legacy source for [inputFormat]. */
+    fun expectedLegacySourceFor(inputFormat: InputFormat) =
+        wrapLegacySource(
+            when (inputFormat) {
+                InputFormat.KOTLIN ->
+                    // Kotlin overrides the standard expectations.
+                    expectedKotlinLegacySource.fallBackTo(expectedLegacySource)
+                else -> expectedLegacySource
+            }
+        )
+
+    /** The suffix to add to class names to make them specific to this example. */
+    val classSuffix = name.replace(" ", "_")
+
+    /** True if this is supported to be a field constant. */
+    private val isConstant
+        get() = javaType in constantTypeNames
+
+    companion object {
+        /**
+         * A special value used for fields for whom [FieldItem.legacyInitialValue] returns `null`.
+         */
+        internal const val NO_INITIAL_FIELD_VALUE = "NO INITIAL FIELD VALUE"
+
+        /** Names of constant types used in [ValueExample.javaType]. */
+        private val constantTypeNames = buildSet {
+            for (kind in PrimitiveTypeItem.Primitive.entries) {
+                add(kind.primitiveName)
+            }
+            add("String")
+        }
+
+        /** All the [InputFormat]s. */
+        private val allInputFormats = EnumSet.allOf(InputFormat::class.java)
+
+        /**
+         * The list of all [ValueExample]s that could be tested across [ProducerKind] and
+         * [ValueUseSite]s.
+         */
+        private val allValueExamples =
+            listOf(
+                // Check an annotation literal.
+                ValueExample(
+                    name = "annotation",
+                    javaType = "OtherAnnotation",
+                    javaExpression = "@OtherAnnotation(intType = 1)",
+                    // Must fully qualify most classes in signature files.
+                    signatureType = "test.pkg.OtherAnnotation",
+                    signatureExpression = "@test.pkg.OtherAnnotation(intType = 1)",
+                    expectedLegacySource =
+                        expectations {
+                            common = "@test.pkg.OtherAnnotation(intType = 1)"
+                            source { common = "@OtherAnnotation(intType = 1)" }
+                            // TODO(b/354633349): Missing attributes.
+                            attributeDefaultValue = "@test.pkg.OtherAnnotation"
+
+                            annotationToSource =
+                                "@test.pkg.OtherAnnotation(" +
+                                    "classType=void.class," +
+                                    " enumType=test.pkg.TestEnum.DEFAULT," +
+                                    " intType=1," +
+                                    " stringType=\"default\"," +
+                                    " stringArrayType={}" +
+                                    ")"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue = "@OtherAnnotation(intType = 1)"
+                            annotationToSource = "@OtherAnnotation(intType = 1)"
+                        },
+                    // Annotation literals cannot be used in fields.
+                    suitableFor = allValueUseSitesExceptFields,
+                ),
+                // Check a simple boolean true value.
+                ValueExample(
+                    name = "boolean true",
+                    javaType = "boolean",
+                    javaExpression = "true",
+                    kotlinType = "Boolean",
+                    expectedLegacySource = expectations { common = "true" },
+                ),
+                // Check a simple boolean false value.
+                ValueExample(
+                    name = "boolean false",
+                    javaType = "boolean",
+                    javaExpression = "false",
+                    kotlinType = "Boolean",
+                    expectedLegacySource = expectations { common = "false" },
+                ),
+                // Check a simple byte.
+                ValueExample(
+                    name = "byte",
+                    javaType = "byte",
+                    javaExpression = "116",
+                    kotlinType = "Byte",
+                    expectedLegacySource = expectations { common = "116" },
+                ),
+                // Check a simple char.
+                ValueExample(
+                    name = "char",
+                    javaType = "char",
+                    javaExpression = "'x'",
+                    kotlinType = "Char",
+                    signatureExpression = "120",
+                    expectedLegacySource =
+                        expectations {
+                            common = "'x'"
+                            // TODO(b/354633349): Should have surrounding quotes.
+                            fieldValue = "x"
+                            fieldWriteWithSemicolon = "120"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "\"x\"" },
+                ),
+                // Check a unicode char.
+                ValueExample(
+                    name = "char unicode",
+                    javaType = "char",
+                    javaExpression = "'\\u2912'",
+                    kotlinType = "Char",
+                    signatureExpression = "10514",
+                    expectedLegacySource =
+                        expectations {
+                            common = "'\\u2912'"
+                            // TODO(b/354633349): Should have surrounding quotes and use the
+                            //   `\uABCD` form.
+                            fieldValue = "⤒"
+                            jar { attributeValue = "'⤒'" }
+                            fieldWriteWithSemicolon = "10514"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "\"\\u2912\"" },
+                ),
+                // Check char escaped.
+                ValueExample(
+                    name = "char escaped",
+                    javaType = "char",
+                    javaExpression = "'\\t'",
+                    kotlinType = "Char",
+                    signatureExpression = "9",
+                    expectedLegacySource =
+                        expectations {
+                            // This seems like the best representation. Quoted and escaped.
+                            common = "'\\t'"
+                            // TODO(b/354633349): Should have surrounding quotes and use the
+                            //   `\uABCD` form.
+                            fieldValue = "\t"
+                            fieldWriteWithSemicolon = "9"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "\"\\t\"" },
+                ),
+                // Check a class literal.
+                ValueExample(
+                    name = "class",
+                    javaType = "Class<?>",
+                    javaExpression = "List.class",
+                    javaImports = listOf("java.util.List"),
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "List::class.java",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.util.List.class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better.
+                                common = "List.class"
+                                attributeDefaultValue = "java.util.List.class"
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            // Some value use sites throw a class cast exception.
+                            attributeDefaultValue = "List::class.java"
+                        },
+                ),
+                // Check an array class literal.
+                ValueExample(
+                    name = "class array literal",
+                    javaType = "Class<?>",
+                    javaExpression = "List[].class",
+                    javaImports = listOf("java.util.List"),
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "Array<List>::class.java",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.util.List[].class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better.
+                                common = "List[].class"
+                                attributeDefaultValue = "java.util.List[].class"
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            // Some value use sites throw a class cast exception.
+                            attributeDefaultValue = "Array<List>::class.java"
+                        },
+                ),
+                // Check a primitive class literal.
+                ValueExample(
+                    name = "class void primitive class",
+                    javaType = "Class<?>",
+                    javaExpression = "void.class",
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "Unit::class.java",
+                    expectedLegacySource = expectations { common = "void.class" },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            // Some value use sites throw a class cast exception.
+                            attributeDefaultValue = "Unit::class.java"
+                        },
+                ),
+                // Check a primitive wrapper class literal.
+                ValueExample(
+                    name = "class void wrapper class",
+                    javaType = "Class<?>",
+                    javaExpression = "Void.class",
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "java.lang.Void::class.java",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.lang.Void.class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better unless java.lang
+                                //   prefix is removed.
+                                attributeValue = "Void.class"
+                                annotationToSource = "Void.class"
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            // Some value use sites throw a class cast exception.
+                            attributeDefaultValue = "java.lang.Void::class.java"
+                        },
+                ),
+                // Check a primitive array class literal.
+                ValueExample(
+                    name = "class int array literal",
+                    javaType = "Class<?>",
+                    javaExpression = "int[].class",
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "IntArray::class.java",
+                    expectedLegacySource = expectations { common = "int[].class" },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            // Some value use sites throw a class cast exception.
+                            attributeDefaultValue = "IntArray::class.java"
+                        },
+                ),
+                // Check a simple double.
+                ValueExample(
+                    name = "double",
+                    javaType = "double",
+                    javaExpression = "3.141",
+                    kotlinType = "Double",
+                    expectedLegacySource = expectations { common = "3.141" },
+                ),
+                // Check a simple double with int
+                ValueExample(
+                    name = "double with int",
+                    javaType = "double",
+                    javaExpression = "3",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing F to make it clear it is a
+                            //  double when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "3.0"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeDefaultValue = "3"
+                                attributeValue = "3"
+                                annotationToSource = "3"
+                            }
+                        },
+                    expectedKotlinLegacySource = partialExpectations { source { common = "3" } },
+                ),
+                // Check a simple double with exponent
+                ValueExample(
+                    name = "double with exponent",
+                    javaType = "double",
+                    javaExpression = "7e10",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            common = "7.0E10"
+
+                            source { attributeValue = "7e10" }
+                        },
+                ),
+                // Check a special double - Nan.
+                ValueExample(
+                    name = "double NaN",
+                    javaType = "double",
+                    javaExpression = "Double.NaN",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Double.NaN` when that is how
+                            //   it is referenced in the source and some expression like `(0.0/0.0)`
+                            //   when it is defined like that, e.g. on `java.lang.Double.NaN`
+                            //   itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Double.NaN"
+                                attributeValue = "Double.NaN"
+                                annotationToSource = "java.lang.Double.NaN"
+                                fieldValue = "NaN"
+                                fieldWriteWithSemicolon = "(0.0/0.0)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(0.0/0.0)"
+                                attributeValue = "0.0d / 0.0"
+                                annotationToSource = "0.0 / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue = "kotlin.jvm.internal.DoubleCompanionObject.NaN"
+                            annotationToSource = "kotlin.jvm.internal.DoubleCompanionObject.NaN"
+                        },
+                ),
+                // Check a special double - +infinity.
+                ValueExample(
+                    name = "double positive infinity",
+                    javaType = "double",
+                    javaExpression = "Double.POSITIVE_INFINITY",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Double.NaN` when that is how
+                            //   it is referenced in the source and some expression like `(1.0/0.0)`
+                            //   when it is defined like that, e.g. on
+                            //   `java.lang.Double.POSITIVE_INFINITY` itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Double.POSITIVE_INFINITY"
+                                attributeValue = "Double.POSITIVE_INFINITY"
+                                annotationToSource = "java.lang.Double.POSITIVE_INFINITY"
+                                fieldValue = "Infinity"
+                                fieldWriteWithSemicolon = "(1.0/0.0)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(1.0/0.0)"
+                                attributeValue = "1.0 / 0.0"
+                                annotationToSource = "1.0 / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue =
+                                "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY"
+                            annotationToSource =
+                                "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY"
+                        },
+                ),
+                ValueExample(
+                    name = "double negative infinity",
+                    javaType = "double",
+                    javaExpression = "Double.NEGATIVE_INFINITY",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Double.NaN` when that is how
+                            //   it is referenced in the source and some expression like `(1.0/0.0)`
+                            //   when it is defined like that, e.g. on
+                            //   `java.lang.Double.NEGATIVE_INFINITY` itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Double.NEGATIVE_INFINITY"
+                                attributeValue = "Double.NEGATIVE_INFINITY"
+                                annotationToSource = "java.lang.Double.NEGATIVE_INFINITY"
+                                fieldValue = "-Infinity"
+                                fieldWriteWithSemicolon = "(-1.0/0.0)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(-1.0/0.0)"
+                                attributeValue = "-1.0 / 0.0"
+                                annotationToSource = "-1.0 / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue =
+                                "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY"
+                            annotationToSource =
+                                "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY"
+                        },
+                ),
+                // Check an enum literal.
+                ValueExample(
+                    name = "enum",
+                    javaType = "TestEnum",
+                    javaExpression = "TestEnum.VALUE1",
+                    // Must fully qualify most classes in signature files.
+                    signatureType = "test.pkg.TestEnum",
+                    signatureExpression = "test.pkg.TestEnum.VALUE1",
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.TestEnum.VALUE1"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better.
+                                attributeValue = "TestEnum.VALUE1"
+                            }
+                        },
+                ),
+                // Check a simple float with int
+                ValueExample(
+                    name = "float with int",
+                    javaType = "float",
+                    javaExpression = "3",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing F to make it clear it is a
+                            //  float when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "3.0F"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeDefaultValue = "3"
+                                attributeValue = "3"
+                                annotationToSource = "3"
+                            }
+
+                            jar {
+                                // TODO(b/354633349): Consistency is good.
+                                common = "3.0f"
+                            }
+
+                            // TODO(b/354633349): Consistency is good.
+                            fieldValue = "3.0"
+                            fieldWriteWithSemicolon = "3.0f"
+                        },
+                    expectedKotlinLegacySource = partialExpectations { source { common = "3" } },
+                ),
+                // Check a simple float with exponent
+                ValueExample(
+                    name = "float with exponent",
+                    javaType = "float",
+                    javaExpression = "7e10f",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            common = "7.0E10f"
+
+                            source { attributeValue = "7e10f" }
+
+                            fieldValue = "7.0E10"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "7.0E10" },
+                ),
+                // Check a simple float with upper F.
+                ValueExample(
+                    name = "float with upper F",
+                    javaType = "float",
+                    javaExpression = "3.141F",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            common = "3.141F"
+
+                            // TODO(b/354633349): Consistency is good.
+                            attributeDefaultValue = "3.141f"
+                            annotationToSource = "3.141f"
+
+                            jar {
+                                // TODO(b/354633349): Consistency is good.
+                                common = "3.141f"
+                            }
+
+                            // TODO(b/354633349): Consistency is good.
+                            fieldValue = "3.141"
+                            fieldWriteWithSemicolon = "3.141f"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "3.141" },
+                ),
+                // Check a simple float with lower F.
+                ValueExample(
+                    name = "float with lower f",
+                    javaType = "float",
+                    javaExpression = "3.141f",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            common = "3.141f"
+
+                            // TODO(b/354633349): Consistency is good.
+                            fieldValue = "3.141"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "3.141" },
+                ),
+                // Check a special float - Nan.
+                ValueExample(
+                    name = "float NaN",
+                    javaType = "float",
+                    javaExpression = "Float.NaN",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Float.NaN` when that is how it
+                            //   is referenced in the source and some expression like `(0.0f/0.0f)`
+                            //   when it is defined like that, e.g. on `java.lang.Float.NaN` itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Float.NaN"
+                                attributeValue = "Float.NaN"
+                                annotationToSource = "java.lang.Float.NaN"
+                                fieldValue = "NaN"
+                                fieldWriteWithSemicolon = "(0.0f/0.0f)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(0.0/0.0)"
+                                attributeValue = "0.0f / 0.0"
+                                annotationToSource = "0.0f / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue = "kotlin.jvm.internal.FloatCompanionObject.NaN"
+                            annotationToSource = "kotlin.jvm.internal.FloatCompanionObject.NaN"
+                        },
+                ),
+                // Check a special float - +infinity.
+                ValueExample(
+                    name = "float positive infinity",
+                    javaType = "float",
+                    javaExpression = "Float.POSITIVE_INFINITY",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Float.NaN` when that is how it
+                            //   is referenced in the source and some expression like `(1.0f/0.0f)`
+                            //   when it is defined like that, e.g. on
+                            //   `java.lang.Float.POSITIVE_INFINITY` itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Float.POSITIVE_INFINITY"
+                                attributeValue = "Float.POSITIVE_INFINITY"
+                                annotationToSource = "java.lang.Float.POSITIVE_INFINITY"
+                                fieldValue = "Infinity"
+                                fieldWriteWithSemicolon = "(1.0f/0.0f)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(1.0/0.0)"
+                                attributeValue = "1.0f / 0.0"
+                                annotationToSource = "1.0f / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue =
+                                "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY"
+                            annotationToSource =
+                                "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY"
+                        },
+                ),
+                ValueExample(
+                    name = "float negative infinity",
+                    javaType = "float",
+                    javaExpression = "Float.NEGATIVE_INFINITY",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Every single use has a different representation!?
+                            //   Ideally, this should just `java.lang.Float.NaN` when that is how it
+                            //   is referenced in the source and some expression like `(1.0f/0.0f)`
+                            //   when it is defined like that, e.g. on
+                            //   `java.lang.Float.NEGATIVE_INFINITY` itself.
+                            source {
+                                attributeDefaultValue = "java.lang.Float.NEGATIVE_INFINITY"
+                                attributeValue = "Float.NEGATIVE_INFINITY"
+                                annotationToSource = "java.lang.Float.NEGATIVE_INFINITY"
+                                fieldValue = "-Infinity"
+                                fieldWriteWithSemicolon = "(-1.0f/0.0f)"
+                            }
+
+                            jar {
+                                attributeDefaultValue = "(-1.0/0.0)"
+                                attributeValue = "-1.0f / 0.0"
+                                annotationToSource = "-1.0F / 0.0"
+                                fieldValue = NO_INITIAL_FIELD_VALUE
+                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations {
+                            attributeDefaultValue =
+                                "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY"
+                            annotationToSource =
+                                "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY"
+                        },
+                ),
+                // Check a simple int.
+                ValueExample(
+                    name = "int",
+                    javaType = "int",
+                    javaExpression = "17",
+                    kotlinType = "Int",
+                    expectedLegacySource = expectations { common = "17" },
+                ),
+                // Check an int with a unary plus.
+                ValueExample(
+                    name = "int positive",
+                    javaType = "int",
+                    javaExpression = "+17",
+                    kotlinType = "Int",
+                    expectedLegacySource =
+                        expectations {
+                            common = "17"
+                            source {
+                                // TODO(b/354633349): The leading + is unnecessary.
+                                attributeValue = "+17"
+
+                                annotationToSource = "0x11"
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "+17" },
+                ),
+                // Check an int with a unary minus.
+                ValueExample(
+                    name = "int negative",
+                    javaType = "int",
+                    javaExpression = "-17",
+                    kotlinType = "Int",
+                    expectedLegacySource =
+                        expectations {
+                            common = "-17"
+
+                            annotationToSource = "0xffffffef"
+                        },
+                ),
+                // Check a simple long with an integer value.
+                ValueExample(
+                    name = "long with int",
+                    javaType = "long",
+                    javaExpression = "1000",
+                    kotlinType = "Long",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing L to make it clear it is a
+                            //  long when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "1000L"
+                            fieldValue = "1000"
+                            source {
+                                attributeDefaultValue = "1000"
+                                attributeValue = "1000"
+                                annotationToSource = "1000"
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { annotationToSource = "1000L" },
+                ),
+                // Check a simple long with an upper case suffix.
+                ValueExample(
+                    name = "long with upper L",
+                    javaType = "long",
+                    javaExpression = "10000000000L",
+                    kotlinType = "Long",
+                    expectedLegacySource =
+                        expectations {
+                            common = "10000000000L"
+                            // TODO(b/354633349): Consistency is good.
+                            fieldValue = "10000000000"
+                        },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeDefaultValue = "10000000000" },
+                ),
+                // Check a simple long with a lower case suffix.
+                ValueExample(
+                    name = "long with lower l",
+                    javaType = "long",
+                    javaExpression = "10000000000l",
+                    kotlinType = "Long",
+                    // Kotlin does not support using a lower case l as a suffix for long, presumably
+                    // because it looks too similar to a number 1.
+                    validForInputFormats = EnumSet.complementOf(EnumSet.of(InputFormat.KOTLIN)),
+                    expectedLegacySource =
+                        expectations {
+                            common = "10000000000L"
+                            // TODO(b/354633349): Consistency is good.
+                            fieldValue = "10000000000"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeValue = "10000000000l"
+                            }
+                        },
+                ),
+                // Check a simple short with a lower case suffix.
+                ValueExample(
+                    name = "short",
+                    javaType = "short",
+                    javaExpression = "32000",
+                    kotlinType = "Short",
+                    expectedLegacySource = expectations { common = "32000" },
+                ),
+                // Check a simple string.
+                ValueExample(
+                    name = "String",
+                    javaType = "String",
+                    javaExpression = "\"string\"",
+                    expectedLegacySource =
+                        expectations {
+                            common = "\"string\""
+                            // TODO(b/354633349): Should have surrounding quotes.
+                            fieldValue = "string"
+                        },
+                ),
+                ValueExample(
+                    name = "String escaped",
+                    javaType = "String",
+                    javaExpression = "\"str\\ning\"",
+                    expectedLegacySource =
+                        expectations {
+                            common = "\"str\\ning\""
+                            // TODO(b/354633349): Should have surrounding quotes and newline should
+                            //   be escaped.
+                            fieldValue = "str\ning"
+                        },
+                ),
+                // Check a simple string array.
+                ValueExample(
+                    name = "String array",
+                    javaType = "String[]",
+                    javaExpression = "{\"string1\", \"string2\"}",
+                    kotlinType = "Array<String>",
+                    kotlinExpression = "[\"string1\", \"string2\"]",
+                    // Literal arrays are only allowed in annotations not fields.
+                    suitableFor = allValueUseSitesExceptFields,
+                    expectedLegacySource = expectations { common = "{\"string1\", \"string2\"}" },
+                    expectedKotlinLegacySource =
+                        partialExpectations { attributeValue = "[\"string1\", \"string2\"]" },
+                ),
+                // Check passing a single value to an array type.
+                ValueExample(
+                    name = "String array with single string",
+                    javaType = "String[]",
+                    javaExpression = "\"string\"",
+                    kotlinType = "Array<String>",
+                    // Fields that are of type String[] cannot be given a solitary string like an
+                    // annotation attribute can.
+                    suitableFor = allValueUseSitesExceptFields,
+                    expectedLegacySource =
+                        expectations {
+                            common = "\"string\""
+
+                            jar { common = "{\"string\"}" }
+                        },
+                ),
+                ValueExample(
+                    name = "String using constant",
+                    javaType = "String",
+                    javaExpression = "Constants.STRING_CONSTANT",
+                    expectedLegacySource =
+                        expectations {
+                            common = "\"constant\""
+
+                            jar {
+                                // TODO(b/354633349): Should have surrounding quotes.
+                                fieldValue = "constant"
+                            }
+
+                            source {
+                                common = "test.pkg.Constants.STRING_CONSTANT"
+                                // TODO(b/354633349): Fully qualified is better.
+                                attributeValue = "Constants.STRING_CONSTANT"
+                                // TODO(b/354633349): Should have surrounding quotes, if not
+                                //   a field reference.
+                                fieldValue = "constant"
+                                // TODO(b/354633349): Should probably be a field reference, at least
+                                //   in some cases.
+                                fieldWriteWithSemicolon = "\"constant\""
+                            }
+                        },
+                )
+            )
+
+        /**
+         * The list of [ValueExample]s that will be tested across [ProducerKind] and
+         * [ValueUseSite]s.
+         */
+        internal val valueExamples =
+            allValueExamples
+                .filter { it.testThis }
+                .let { filtered -> filtered.ifEmpty { allValueExamples } }
+    }
+}
+
+/**
+ * A partial [Expectation] that returns [NO_INITIAL_FIELD_VALUE] for fields.
+ *
+ * This is used when a [ValueExample] is not a constant and so a field that uses it will not have a
+ * value. It is checked first and then [falls back to](fallBackTo)
+ * [ValueExample.expectedLegacySource],
+ */
+private val constantFieldLegacySourceExpectation =
+    partialExpectations<String> {
+        fieldValue = NO_INITIAL_FIELD_VALUE
+        fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
+    }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt
new file mode 100644
index 000000000..af27d3682
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.FieldItem
+import java.util.EnumSet
+
+/** The possible places where values can be provided. */
+enum class ValueUseSite {
+    /** The default value specified on an annotation class's method. */
+    ATTRIBUTE_DEFAULT_VALUE,
+
+    /** An annotation attribute value specified in an annotation instance. */
+    ATTRIBUTE_VALUE,
+
+    /**
+     * An annotation attribute value produced by [AnnotationItem.toSource] called on an annotation
+     * instance.
+     */
+    ANNOTATION_TO_SOURCE,
+
+    /** The value of a field. */
+    FIELD_VALUE,
+
+    /** The value of a field written out by [FieldItem.writeValueWithSemicolon]. */
+    FIELD_WRITE_WITH_SEMICOLON,
+}
+
+/**
+ * The set of all [ValueUseSite]s.
+ *
+ * Default for [ValueExample.suitableFor].
+ */
+internal val allValueUseSites = EnumSet.allOf(ValueUseSite::class.java)
+
+/**
+ * The set of all [ValueUseSite]s except [ValueUseSite.FIELD_VALUE] and
+ * [ValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
+ *
+ * Stored in [ValueExample.suitableFor] for any [ValueExample] that does not work on fields.
+ */
+internal val allValueUseSitesExceptFields =
+    allValueUseSites - ValueUseSite.FIELD_VALUE - ValueUseSite.FIELD_WRITE_WITH_SEMICOLON
diff --git a/metalava-model-text/Android.bp b/metalava-model-text/Android.bp
index 185d5aa49..7799ecdf6 100644
--- a/metalava-model-text/Android.bp
+++ b/metalava-model-text/Android.bp
@@ -23,6 +23,7 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     libs: [
         "metalava-model",
     ],
diff --git a/metalava-model-text/build.gradle.kts b/metalava-model-text/build.gradle.kts
index cafbbbf53..07ccc12b4 100644
--- a/metalava-model-text/build.gradle.kts
+++ b/metalava-model-text/build.gradle.kts
@@ -27,6 +27,7 @@ plugins {
 
 dependencies {
     testFixturesImplementation(libs.junit4)
+    testFixturesImplementation(libs.kotlinTest)
     testFixturesImplementation(testFixtures(project(":metalava-model")))
     testFixturesImplementation(project(":metalava-model-testsuite"))
     testFixturesImplementation(project(":metalava-testing"))
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
index 8b689032d..fef714099 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
@@ -58,12 +58,13 @@ import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
-import com.android.tools.metalava.model.item.DefaultValue
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.item.ParameterDefaultValue
 import com.android.tools.metalava.model.javaUnescapeString
 import com.android.tools.metalava.model.type.MethodFingerprint
 import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.Issues
 import java.io.File
 import java.io.IOException
 import java.io.InputStream
@@ -201,6 +202,26 @@ private constructor(
 
     private val codebase = assembler.codebase
 
+    /**
+     * The [FileLocationTracker] for the current file being parsed.
+     *
+     * Set by [parseApiSingleFile].
+     */
+    private lateinit var fileLocationTracker: FileLocationTracker
+
+    /**
+     * Report recoverable errors encountered while parsing.
+     *
+     * Retrieves the location of the error from [fileLocationTracker].
+     */
+    private val errorReporter =
+        object : SignatureErrorReporter {
+            override fun report(issue: Issues.Issue, message: String) {
+                val location = fileLocationTracker.fileLocation()
+                codebase.reporter.report(issue, null, message, location)
+            }
+        }
+
     /**
      * Provides support for parsing and caching [TypeItem]s.
      *
@@ -208,7 +229,9 @@ private constructor(
      * to a non-null value to ensure that it picks up the correct setting of [kotlinStyleNulls].
      */
     private val typeParser by
-        lazy(LazyThreadSafetyMode.NONE) { TextTypeParser(codebase, kotlinStyleNulls!!) }
+        lazy(LazyThreadSafetyMode.NONE) {
+            TextTypeParser(codebase, kotlinStyleNulls!!, errorReporter)
+        }
 
     /**
      * Provides support for creating [TypeItem]s for specific uses.
@@ -239,6 +262,12 @@ private constructor(
      */
     private lateinit var apiVariant: ApiVariant
 
+    /**
+     * True if this is appending information from one signature file to a [Codebase] created from
+     * another signature file.
+     */
+    private var appending: Boolean = false
+
     /** Map from [ClassItem] to [TextTypeItemFactory]. */
     private val classToTypeItemFactory = IdentityHashMap<ClassItem, TextTypeItemFactory>()
 
@@ -423,21 +452,6 @@ private constructor(
         apiText: String,
         apiVariant: ApiVariant,
     ) {
-        // Parse the header of the signature file to determine the format. If the signature file is
-        // empty then `parseHeader` will return null, so it will default to `FileFormat.V2`.
-        format =
-            FileFormat.parseHeader(path, StringReader(apiText), formatForLegacyFiles)
-                ?: FileFormat.V2
-
-        // Disallow a mixture of kotlinStyleNulls settings.
-        if (kotlinStyleNulls == null) {
-            kotlinStyleNulls = format.kotlinStyleNulls
-        } else if (kotlinStyleNulls != format.kotlinStyleNulls) {
-            throw ApiParseException(
-                "Cannot mix signature files with different settings of kotlinStyleNulls"
-            )
-        }
-
         if (appending) {
             // When we're appending, and the content is empty, nothing to do.
             if (apiText.isBlank()) {
@@ -445,10 +459,40 @@ private constructor(
             }
         }
 
+        // The behavior is slightly different when appending to an existing Codebase.
+        this.appending = appending
+
+        // Parse the header of the signature file to determine the format. If the signature file is
+        // empty then `parseHeader` will return null, so it will default to `FileFormat.V2`.
+        format =
+            FileFormat.parseHeader(path, StringReader(apiText), formatForLegacyFiles)
+                ?: FileFormat.V2
+
         // Remember the API variant of the file being parsed.
         this.apiVariant = apiVariant
 
         val tokenizer = Tokenizer(path, apiText.toCharArray())
+
+        // Get the preceding tracker, if any.
+        val precedingTracker =
+            if (::fileLocationTracker.isInitialized) {
+                fileLocationTracker
+            } else {
+                null
+            }
+
+        // Set the file location tracker to provide location information about the current file.
+        fileLocationTracker = tokenizer
+
+        // Disallow a mixture of kotlinStyleNulls settings.
+        if (kotlinStyleNulls != null && kotlinStyleNulls != format.kotlinStyleNulls) {
+            val precedingFile = precedingTracker!!.fileLocation().path
+            errorReporter.report(
+                "Preceding file $precedingFile has different setting of kotlin-style-nulls which may cause issues"
+            )
+        }
+        kotlinStyleNulls = format.kotlinStyleNulls
+
         while (true) {
             val token = tokenizer.getToken() ?: break
             // TODO: Accept annotations on packages.
@@ -504,6 +548,66 @@ private constructor(
         }
     }
 
+    /**
+     * Creates a type alias in the [pkg] with the [modifiers].
+     *
+     * It is expected that the starting position of the [tokenizer] is the "typealias" keyword, and
+     * the next token will be the name and option type parameter list.
+     *
+     * When the method returns, the current [tokenizer] position will be the ";" at the end of the
+     * typealias line.
+     */
+    private fun parseTypeAlias(
+        pkg: DefaultPackageItem,
+        tokenizer: Tokenizer,
+        modifiers: MutableModifierList,
+        location: FileLocation
+    ) {
+        var token = tokenizer.requireToken()
+        tokenizer.assertIdent(token)
+
+        val typeParameterListIndex = token.indexOf("<")
+
+        val (name, typeParameterList, typeItemFactory) =
+            if (typeParameterListIndex == -1) {
+                Triple(token, TypeParameterList.NONE, globalTypeItemFactory)
+            } else {
+                val name = token.substring(0, typeParameterListIndex)
+                val typeParameterListAndFactory =
+                    createTypeParameterList(
+                        globalTypeItemFactory,
+                        "typealias $name",
+                        token.substring(typeParameterListIndex)
+                    )
+                Triple(
+                    name,
+                    typeParameterListAndFactory.typeParameterList,
+                    typeParameterListAndFactory.factory
+                )
+            }
+
+        token = tokenizer.requireToken()
+        if ("=" != token) {
+            throw ApiParseException("expected = found $token", tokenizer)
+        }
+
+        val typeString = scanForTypeString(tokenizer, tokenizer.requireToken())
+        token = tokenizer.current
+        if (";" != token) {
+            throw ApiParseException("expected ; found $token", tokenizer)
+        }
+
+        val type = typeItemFactory.getGeneralType(typeString)
+        itemFactory.createTypeAliasItem(
+            fileLocation = location,
+            modifiers = modifiers,
+            qualifiedName = pkg.qualifiedName() + "." + name,
+            containingPackage = pkg,
+            aliasedType = type,
+            typeParameterList = typeParameterList,
+        )
+    }
+
     private fun parseClass(pkg: DefaultPackageItem, tokenizer: Tokenizer, startingToken: String) {
         var token = startingToken
         var classKind = ClassKind.CLASS
@@ -540,8 +644,17 @@ private constructor(
                 superClassType = globalTypeItemFactory.superEnumType
                 token = tokenizer.requireToken()
             }
+            "typealias" -> {
+                // Type aliases aren't classes, but they are defined at the same level as classes
+                parseTypeAlias(pkg, tokenizer, modifiers, classPosition)
+                // Don't continue creating a class item
+                return
+            }
             else -> {
-                throw ApiParseException("missing class or interface. got: $token", tokenizer)
+                throw ApiParseException(
+                    "expected one of class, interface, @interface, enum, or typealias; found: $token",
+                    tokenizer
+                )
             }
         }
         tokenizer.assertIdent(token)
@@ -1011,17 +1124,11 @@ private constructor(
         val annotations = getAnnotations(tokenizer, token)
         token = tokenizer.current
         val modifiers = parseModifiers(tokenizer, token, annotations)
-        token = tokenizer.current
 
         // Get a TypeParameterList and accompanying TypeItemFactory
         val (typeParameterList, typeItemFactory) =
-            if ("<" == token) {
-                parseTypeParameterList(tokenizer, classTypeItemFactory).also {
-                    token = tokenizer.requireToken()
-                }
-            } else {
-                TypeParameterListAndFactory(TypeParameterList.NONE, classTypeItemFactory)
-            }
+            parseTypeParameterList(tokenizer, classTypeItemFactory)
+        token = tokenizer.current
 
         tokenizer.assertIdent(token)
         val name: String =
@@ -1077,18 +1184,11 @@ private constructor(
         val annotations = getAnnotations(tokenizer, token)
         token = tokenizer.current
         val modifiers = parseModifiers(tokenizer, token, annotations)
-        token = tokenizer.current
 
         // Get a TypeParameterList and accompanying TypeParameterScope
         val (typeParameterList, typeItemFactory) =
-            if ("<" == token) {
-                parseTypeParameterList(tokenizer, classTypeItemFactory).also {
-                    token = tokenizer.requireToken()
-                }
-            } else {
-                TypeParameterListAndFactory(TypeParameterList.NONE, classTypeItemFactory)
-            }
-
+            parseTypeParameterList(tokenizer, classTypeItemFactory)
+        token = tokenizer.current
         tokenizer.assertIdent(token)
 
         val returnTypeString: String
@@ -1172,9 +1272,14 @@ private constructor(
 
         method.markForMainApiSurface()
 
-        // If the method already exists in the class item because it was defined in a previous
-        // signature file then replace it with this one, otherwise just add this method.
-        cl.replaceOrAddMethod(method)
+        if (appending) {
+            // If the method already exists in the class item because it was defined in a previous
+            // signature file then replace it with this one, otherwise just add this method.
+            cl.replaceOrAddMethod(method)
+        } else {
+            // Just add the method to the class.
+            cl.addMethod(method)
+        }
     }
 
     private fun parseField(
@@ -1444,27 +1549,27 @@ private constructor(
         val annotations = getAnnotations(tokenizer, token)
         token = tokenizer.current
         val modifiers = parseModifiers(tokenizer, token, annotations)
+
+        // Get a TypeParameterList and accompanying TypeParameterScope
+        val (typeParameterList, typeItemFactory) =
+            parseTypeParameterList(tokenizer, classTypeItemFactory)
         token = tokenizer.current
-        tokenizer.assertIdent(token)
 
         val typeString: String
-        val name: String
+        val receiverNamePair: Pair<TypeItem?, String>
         if (format.kotlinNameTypeOrder) {
             // Kotlin style: parse the name, then the type.
-            name = parseNameWithColon(token, tokenizer)
-            token = tokenizer.requireToken()
-            tokenizer.assertIdent(token)
+            receiverNamePair = parsePropertyReceiverAndName(tokenizer, typeItemFactory)
+            token = tokenizer.current
             typeString = scanForTypeString(tokenizer, token)
             token = tokenizer.current
         } else {
             // Java style: parse the type, then the name.
             typeString = scanForTypeString(tokenizer, token)
+            receiverNamePair = parsePropertyReceiverAndName(tokenizer, typeItemFactory)
             token = tokenizer.current
-            tokenizer.assertIdent(token)
-            name = token
-            token = tokenizer.requireToken()
         }
-        val type = classTypeItemFactory.getGeneralType(typeString)
+        val type = typeItemFactory.getGeneralType(typeString)
         synchronizeNullability(type, modifiers)
 
         if (";" != token) {
@@ -1474,19 +1579,73 @@ private constructor(
             itemFactory.createPropertyItem(
                 fileLocation = tokenizer.fileLocation(),
                 modifiers = modifiers,
-                name = name,
+                name = receiverNamePair.second,
                 containingClass = cl,
                 type = type,
+                receiver = receiverNamePair.first,
+                typeParameterList = typeParameterList,
             )
         property.markForMainApiSurface()
         cl.addProperty(property)
     }
 
+    /**
+     * Starting from the current token of [tokenizer], parses the optional receiver type and then
+     * the name of a property.
+     *
+     * After the method returns, the caller should continue processing at the new current token of
+     * [tokenizer], which will be the token after
+     */
+    private fun parsePropertyReceiverAndName(
+        tokenizer: Tokenizer,
+        typeItemFactory: TextTypeItemFactory
+    ): Pair<TypeItem?, String> {
+        // If there's no receiver, scanning for the type string should just return the name.
+        // If there is a receiver, because of how the tokens are broken up, it should return
+        // "receiver.name", which can then be split on the last "." to the receiver and name.
+        val receiverAndName = scanForTypeString(tokenizer, tokenizer.current)
+        val namePossiblyWithColon: String
+        val receiverTypeString: String?
+        if (receiverAndName.contains(".")) {
+            namePossiblyWithColon = receiverAndName.substringAfterLast(".")
+            receiverTypeString = receiverAndName.substringBeforeLast(".")
+        } else {
+            namePossiblyWithColon = receiverAndName
+            receiverTypeString = null
+        }
+
+        val name =
+            if (format.kotlinNameTypeOrder) {
+                parseNameWithColon(namePossiblyWithColon, tokenizer)
+            } else {
+                tokenizer.assertIdent(namePossiblyWithColon)
+                namePossiblyWithColon
+            }
+        val receiverType = receiverTypeString?.let { typeItemFactory.getGeneralType(it) }
+
+        return receiverType to name
+    }
+
+    /**
+     * Parses a type parameter list enclosed in "<>", if one exists.
+     *
+     * Starts processing from the current token of [tokenizer]. If that token is not "<", returns an
+     * empty type parameter list.
+     *
+     * After the method returns, the caller should continue processing at the new current token of
+     * [tokenizer], which will be the token after the type parameter list, if it exists, or the same
+     * as the original current token, if there was no type parameter list.
+     */
     private fun parseTypeParameterList(
         tokenizer: Tokenizer,
         enclosingTypeItemFactory: TextTypeItemFactory,
     ): TypeParameterListAndFactory<TextTypeItemFactory> {
-        var token: String
+        var token: String = tokenizer.current
+        // No type parameters to parse. The current token is unchanged
+        if ("<" != token) {
+            return TypeParameterListAndFactory(TypeParameterList.NONE, enclosingTypeItemFactory)
+        }
+
         val start = tokenizer.offset() - 1
         var balance = 1
         while (balance > 0) {
@@ -1498,6 +1657,9 @@ private constructor(
             }
         }
         val typeParameterListString = tokenizer.getStringFromOffset(start)
+        // Set the tokenizer to the next token, so that the caller should continue processing at
+        // tokenizer.current (in alignment with the no type parameter case).
+        tokenizer.requireToken()
         return if (typeParameterListString.isEmpty()) {
             TypeParameterListAndFactory(TypeParameterList.NONE, enclosingTypeItemFactory)
         } else {
@@ -1608,9 +1770,9 @@ private constructor(
                 return parameters
             }
 
-            // Each item can be
-            // optional annotations optional-modifiers type-with-use-annotations-and-generics
-            // optional-name optional-equals-default-value
+            // Each item can be:
+            //   optional-"optional" annotations optional-modifiers
+            //   type-with-use-annotations-and-generics optional-name
 
             // Used to represent the presence of a default value, instead of showing the entire
             // default value
@@ -1656,52 +1818,6 @@ private constructor(
                 }
             }
 
-            var defaultValueString: String? = null
-            if ("=" == token) {
-                if (hasOptionalKeyword) {
-                    throw ApiParseException(
-                        "cannot have both optional keyword and default value",
-                        tokenizer
-                    )
-                }
-                defaultValueString = tokenizer.requireToken(true)
-                val sb = StringBuilder(defaultValueString)
-                if (defaultValueString == "{") {
-                    var balance = 1
-                    while (balance > 0) {
-                        token = tokenizer.requireToken(parenIsSep = false, eatWhitespace = false)
-                        sb.append(token)
-                        if (token == "{") {
-                            balance++
-                        } else if (token == "}") {
-                            balance--
-                            if (balance == 0) {
-                                break
-                            }
-                        }
-                    }
-                    token = tokenizer.requireToken()
-                } else {
-                    var balance = if (defaultValueString == "(") 1 else 0
-                    while (true) {
-                        token = tokenizer.requireToken(parenIsSep = true, eatWhitespace = false)
-                        if ((token.endsWith(",") || token.endsWith(")")) && balance <= 0) {
-                            if (token.length > 1) {
-                                sb.append(token, 0, token.length - 1)
-                                token = token[token.length - 1].toString()
-                            }
-                            break
-                        }
-                        sb.append(token)
-                        if (token == "(") {
-                            balance++
-                        } else if (token == ")") {
-                            balance--
-                        }
-                    }
-                }
-                defaultValueString = sb.toString()
-            }
             when (token) {
                 "," -> {
                     token = tokenizer.requireToken()
@@ -1716,17 +1832,13 @@ private constructor(
 
             // Select the DefaultValue for the parameter.
             val defaultValue =
-                when {
-                    hasOptionalKeyword ->
-                        // It has an optional keyword, so it has a default value but the actual
-                        // value is not known.
-                        DefaultValue.UNKNOWN
-                    defaultValueString == null ->
-                        // It has neither an optional keyword nor an actual default value.
-                        DefaultValue.NONE
-                    else ->
-                        // It has an actual default value.
-                        DefaultValue.fixedDefaultValue(defaultValueString)
+                if (hasOptionalKeyword) {
+                    // It has an optional keyword, so it has a default value but the actual value is
+                    // not known.
+                    ParameterDefaultValue.UNKNOWN
+                } else {
+                    // It does not have an optional keyword so it has no default value.
+                    ParameterDefaultValue.NONE
                 }
             parameters.add(
                 ParameterInfo(
@@ -1752,7 +1864,7 @@ private constructor(
     private inner class ParameterInfo(
         val name: String,
         val publicName: String?,
-        val defaultValue: DefaultValue,
+        val defaultValue: ParameterDefaultValue,
         val typeString: String,
         val modifiers: MutableModifierList,
         val location: FileLocation,
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
index 8c69c27f4..70414f30e 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
@@ -118,9 +118,12 @@ data class FileFormat(
      * `\n` (because it is the terminator of the signature format line).
      */
     val migrating: String? = null,
-    val conciseDefaultValues: Boolean,
+    val includeDefaultParameterValues: Boolean,
     val specifiedAddAdditionalOverrides: Boolean? = null,
 
+    /** See [CustomizableProperty.NORMALIZE_FINAL_MODIFIER]. */
+    val specifiedNormalizeFinalModifier: Boolean? = null,
+
     /**
      * Indicates whether the whole extends list for an interface is sorted.
      *
@@ -139,7 +142,12 @@ data class FileFormat(
      * Indicates which of the possible approaches to `java.lang.` prefix stripping available in
      * [StripJavaLangPrefix] is used when outputting types to signature files.
      */
-    val specifiedStripJavaLangPrefix: StripJavaLangPrefix? = null
+    val specifiedStripJavaLangPrefix: StripJavaLangPrefix? = null,
+
+    /**
+     * Indicates how type arguments should be formatted when outputting types to signature files.
+     */
+    val specifiedTypeArgumentSpacing: TypeArgumentSpacing? = null,
 ) {
     init {
         if (migrating != null && "[,\n]".toRegex().find(migrating) != null) {
@@ -191,6 +199,10 @@ data class FileFormat(
     val addAdditionalOverrides
         get() = effectiveValue({ specifiedAddAdditionalOverrides }, false)
 
+    // This defaults to false but can be overridden on the command line.
+    val normalizeFinalModifier
+        get() = effectiveValue({ specifiedNormalizeFinalModifier }, false)
+
     // This defaults to false but can be overridden on the command line.
     val sortWholeExtendsList
         get() = effectiveValue({ specifiedSortWholeExtendsList }, default = false)
@@ -199,10 +211,16 @@ data class FileFormat(
     val stripJavaLangPrefix
         get() = effectiveValue({ specifiedStripJavaLangPrefix }, StripJavaLangPrefix.LEGACY)
 
+    // This defaults to LEGACY but can be overridden on the command line.
+    val typeArgumentSpacing
+        get() = effectiveValue({ specifiedTypeArgumentSpacing }, TypeArgumentSpacing.LEGACY)
+
     /** The base version of the file format. */
     enum class Version(
         /** The version number of this as a string, e.g. "3.0". */
-        internal val versionNumber: String,
+        val versionNumber: String,
+        /** The optional legacy alias used on the command line, for the `--format` option. */
+        val legacyCommandLineAlias: String? = null,
 
         /** Indicates whether the version supports properties fully or just for migrating. */
         internal val propertySupport: PropertySupport = PropertySupport.FOR_MIGRATING_ONLY,
@@ -212,36 +230,50 @@ data class FileFormat(
          * version.
          */
         factory: (Version) -> FileFormat,
+        /** Help text to use on the command line. */
+        val help: String,
     ) {
         V2(
             versionNumber = "2.0",
+            legacyCommandLineAlias = "v2",
             factory = { version ->
                 FileFormat(
                     version = version,
                     kotlinStyleNulls = false,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                 )
-            }
+            },
+            help =
+                """
+                    This is the base version (more details in `FORMAT.md`) on which all the others
+                    are based. It sets the properties as follows:
+                    ```
+                    + kotlin-style-nulls = no
+                    + include-default-parameter-values = no
+                    ```
+                """,
         ),
-        V3(
-            versionNumber = "3.0",
+        V4(
+            versionNumber = "4.0",
+            legacyCommandLineAlias = "v4",
             factory = { version ->
                 V2.defaults.copy(
                     version = version,
                     // This adds kotlinStyleNulls = true
                     kotlinStyleNulls = true,
-                )
-            }
-        ),
-        V4(
-            versionNumber = "4.0",
-            factory = { version ->
-                V3.defaults.copy(
-                    version = version,
                     // This adds conciseDefaultValues = true
-                    conciseDefaultValues = true,
+                    includeDefaultParameterValues = true,
                 )
-            }
+            },
+            help =
+                """
+                    This is `2.0` plus `kotlin-style-nulls = yes` and `include-default-parameter-values = yes`
+                    giving the following properties:
+                    ```
+                    + kotlin-style-nulls = yes
+                    + include-default-parameter-values = yes
+                    ```
+                """,
         ),
         V5(
             versionNumber = "5.0",
@@ -252,7 +284,14 @@ data class FileFormat(
                     version = version,
                     // This does not add any property defaults, just full property support.
                 )
-            }
+            },
+            help =
+                """
+                    This is the first version that has full support for properties in the signature
+                    header. As such it does not add any new defaults to `4.0`. The intent is that
+                    properties will be explicitly defined in the signature file avoiding reliance on
+                    version specific defaults.
+                """,
         );
 
         /**
@@ -261,7 +300,7 @@ data class FileFormat(
          * It is initialized via a factory to break the cycle where the [Version] constructor
          * depends on the [FileFormat] constructor and vice versa.
          */
-        internal val defaults = factory(this)
+        val defaults = factory(this)
 
         /**
          * Get the version defaults plus any language defaults, if available.
@@ -299,15 +338,15 @@ data class FileFormat(
      * This is independent of the [Version].
      */
     enum class Language(
-        private val conciseDefaultValues: Boolean,
+        private val includeDefaultParameterValues: Boolean,
         private val kotlinStyleNulls: Boolean,
     ) {
-        JAVA(conciseDefaultValues = false, kotlinStyleNulls = false),
-        KOTLIN(conciseDefaultValues = true, kotlinStyleNulls = true);
+        JAVA(includeDefaultParameterValues = false, kotlinStyleNulls = false),
+        KOTLIN(includeDefaultParameterValues = true, kotlinStyleNulls = true);
 
         internal fun applyLanguageDefaults(builder: Builder) {
-            if (builder.conciseDefaultValues == null) {
-                builder.conciseDefaultValues = conciseDefaultValues
+            if (builder.includeDefaultParameterValues == null) {
+                builder.includeDefaultParameterValues = includeDefaultParameterValues
             }
             if (builder.kotlinStyleNulls == null) {
                 builder.kotlinStyleNulls = kotlinStyleNulls
@@ -323,6 +362,21 @@ data class FileFormat(
         SIGNATURE(CallableItem.comparator)
     }
 
+    /** Different ways of spacing out type arguments in [TypeItem.toTypeString]. */
+    enum class TypeArgumentSpacing {
+        /** No spacing added between type arguments. */
+        NONE,
+
+        /**
+         * No spacing added between type arguments unless they are in the bounds of a type
+         * parameter.
+         */
+        LEGACY,
+
+        /** A single space added after the comma that separates type arguments. */
+        SPACE,
+    }
+
     /**
      * Get the header for the signature file that corresponds to this format.
      *
@@ -377,7 +431,7 @@ data class FileFormat(
     private fun iterateOverCustomizableProperties(consumer: (String, String) -> Unit) {
         val defaults = version.defaultsIncludingLanguage(language)
         if (this@FileFormat != defaults) {
-            CustomizableProperty.values().forEach { prop ->
+            CustomizableProperty.entries.forEach { prop ->
                 // Get the string value of this property, if null then it was not specified so skip
                 // the property.
                 val thisValue = prop.stringFromFormat(this@FileFormat) ?: return@forEach
@@ -420,16 +474,13 @@ data class FileFormat(
     }
 
     companion object {
-        private val allDefaults = Version.values().map { it.defaults }.toList()
+        private val allDefaults = Version.entries.map { it.defaults }.toList()
 
-        private val versionByNumber = Version.values().associateBy { it.versionNumber }
+        private val versionByNumber = Version.entries.associateBy { it.versionNumber }
 
         // The defaults associated with version 2.0.
         val V2 = Version.V2.defaults
 
-        // The defaults associated with version 3.0.
-        val V3 = Version.V3.defaults
-
         // The defaults associated with version 4.0.
         val V4 = Version.V4.defaults
 
@@ -702,7 +753,7 @@ data class FileFormat(
          * Get the names of the [CustomizableProperty] that are [CustomizableProperty.defaultable].
          */
         fun defaultableProperties(): List<String> {
-            return CustomizableProperty.values()
+            return CustomizableProperty.entries
                 .filter { it.defaultable }
                 .map { it.propertyName }
                 .sorted()
@@ -713,23 +764,26 @@ data class FileFormat(
     /** A builder for [FileFormat] that applies some optional values to a base [FileFormat]. */
     internal class Builder(private val base: FileFormat) {
         var addAdditionalOverrides: Boolean? = null
-        var conciseDefaultValues: Boolean? = null
+        var includeDefaultParameterValues: Boolean? = null
         var includeTypeUseAnnotations: Boolean? = null
         var kotlinNameTypeOrder: Boolean? = null
         var kotlinStyleNulls: Boolean? = null
         var language: Language? = null
         var migrating: String? = null
         var name: String? = null
+        var normalizeFinalModifier: Boolean? = null
         var overloadedMethodOrder: OverloadedMethodOrder? = null
         var sortWholeExtendsList: Boolean? = null
         var stripJavaLangPrefix: StripJavaLangPrefix? = null
+        var typeArgumentSpacing: TypeArgumentSpacing? = null
         var surface: String? = null
 
         fun build(): FileFormat {
             // Apply any language defaults first as they take priority over version defaults.
             language?.applyLanguageDefaults(this)
             return base.copy(
-                conciseDefaultValues = conciseDefaultValues ?: base.conciseDefaultValues,
+                includeDefaultParameterValues = includeDefaultParameterValues
+                        ?: base.includeDefaultParameterValues,
                 includeTypeUseAnnotations = includeTypeUseAnnotations
                         ?: base.includeTypeUseAnnotations,
                 kotlinNameTypeOrder = kotlinNameTypeOrder ?: base.kotlinNameTypeOrder,
@@ -739,19 +793,29 @@ data class FileFormat(
                 name = name ?: base.name,
                 specifiedAddAdditionalOverrides = addAdditionalOverrides
                         ?: base.specifiedAddAdditionalOverrides,
+                specifiedNormalizeFinalModifier = normalizeFinalModifier
+                        ?: base.specifiedNormalizeFinalModifier,
                 specifiedOverloadedMethodOrder = overloadedMethodOrder
                         ?: base.specifiedOverloadedMethodOrder,
                 specifiedSortWholeExtendsList = sortWholeExtendsList
                         ?: base.specifiedSortWholeExtendsList,
                 specifiedStripJavaLangPrefix = stripJavaLangPrefix
                         ?: base.specifiedStripJavaLangPrefix,
+                specifiedTypeArgumentSpacing = typeArgumentSpacing
+                        ?: base.specifiedTypeArgumentSpacing,
                 surface = surface ?: base.surface,
             )
         }
     }
 
     /** Information about the different customizable properties in [FileFormat]. */
-    private enum class CustomizableProperty(val defaultable: Boolean = false) {
+    enum class CustomizableProperty(
+        val defaultable: Boolean = false,
+        /** Syntax of command line values. */
+        val valueSyntax: String = "",
+        /** Help text to use on the command line. */
+        val help: String = "",
+    ) {
         // The order of values in this is significant as it determines the order of the properties
         // in signature headers. The values in this block are not in alphabetical order because it
         // is important that they are at the start of the signature header.
@@ -792,14 +856,22 @@ data class FileFormat(
             override fun stringFromFormat(format: FileFormat): String? =
                 format.specifiedAddAdditionalOverrides?.let { yesNo(it) }
         },
-        /** concise-default-values=[yes|no] */
-        CONCISE_DEFAULT_VALUES {
+        /** include-default-parameter-values=[yes|no] */
+        INCLUDE_DEFAULT_PARAMETER_VALUES(
+            valueSyntax = "yes|no",
+            help =
+                """
+                    If `no` then the signature file will not include any information about default
+                    parameter values. If `yes` then it will use the pseudo modifier `optional` to
+                    indicate a parameter that has a default value.
+                """,
+        ) {
             override fun setFromString(builder: Builder, value: String) {
-                builder.conciseDefaultValues = yesNo(value)
+                builder.includeDefaultParameterValues = yesNo(value)
             }
 
             override fun stringFromFormat(format: FileFormat): String =
-                yesNo(format.conciseDefaultValues)
+                yesNo(format.includeDefaultParameterValues)
         },
         /** include-type-use-annotations=[yes|no] */
         INCLUDE_TYPE_USE_ANNOTATIONS {
@@ -820,7 +892,19 @@ data class FileFormat(
                 yesNo(format.kotlinNameTypeOrder)
         },
         /** kotlin-style-nulls=[yes|no] */
-        KOTLIN_STYLE_NULLS {
+        KOTLIN_STYLE_NULLS(
+            valueSyntax = "yes|no",
+            help =
+                """
+                    If `no` then the signature file will use `@Nullable` and `@NonNull` annotations
+                    to indicate that the annotated item accepts `null` and does not accept `null`
+                    respectively and neither indicates that it's not defined.
+
+                    If `yes` then the signature file will use a type suffix of `?`, no type suffix
+                    and a type suffix of `!` to indicate the that the type accepts `null`, does not
+                    accept `null` or it's not defined respectively.
+                """,
+        ) {
             override fun setFromString(builder: Builder, value: String) {
                 builder.kotlinStyleNulls = yesNo(value)
             }
@@ -835,8 +919,41 @@ data class FileFormat(
 
             override fun stringFromFormat(format: FileFormat): String? = format.migrating
         },
+        NORMALIZE_FINAL_MODIFIER(
+            defaultable = true,
+            valueSyntax = "yes|no",
+            help =
+                """
+                    Specifies how the `final` modifier is handled on `final` methods. If this is
+                    `yes` and the method's containing class is `final` then the `final` modifier is
+                    not written out, otherwise it is.
+                """,
+        ) {
+            override fun setFromString(builder: Builder, value: String) {
+                builder.normalizeFinalModifier = yesNo(value)
+            }
+
+            override fun stringFromFormat(format: FileFormat): String? =
+                format.specifiedNormalizeFinalModifier?.let { yesNo(it) }
+        },
         /** overloaded-method-other=[source|signature] */
-        OVERLOADED_METHOD_ORDER(defaultable = true) {
+        OVERLOADED_METHOD_ORDER(
+            defaultable = true,
+            valueSyntax = "source|signature",
+            help =
+                """
+                    Specifies the order of overloaded methods in signature files. Applies to the
+                    contents of the files specified on `--api` and `--removed-api`.
+
+                    `source` - preserves the order in which overloaded methods appear in the source
+                    files. This means that refactorings of the source files which change the order
+                    but not the API can cause unnecessary changes in the API signature files.
+
+                    `signature` (default) - sorts overloaded methods by their signature. This means
+                    that refactorings of the source files which change the order but not the API
+                    will have no effect on the API signature files.
+                """,
+        ) {
             override fun setFromString(builder: Builder, value: String) {
                 builder.overloadedMethodOrder = enumFromString<OverloadedMethodOrder>(value)
             }
@@ -859,7 +976,35 @@ data class FileFormat(
 
             override fun stringFromFormat(format: FileFormat): String? =
                 format.specifiedStripJavaLangPrefix?.stringFromEnum()
-        };
+        },
+        TYPE_ARGUMENT_SPACING(
+            defaultable = true,
+            valueSyntax = "legacy|none|space",
+            help =
+                """
+                    Specifies the spacing between the type arguments of a generic type. e.g.
+                    `Map<String, Integer>`. The default is `legacy`.
+
+                    `legacy` - adds no spaces between type arguments except those used in the bounds
+                    of a type parameter. e.g. `Map<String,Integer>` will have no space except in
+                    `class Foo<M extends Map<String, Integer>`.
+
+                    `none` - adds no spaces between any type arguments.
+
+                    `space` - adds a single space between every type argument.
+
+                    Note: This does not affect the spacing of type parameters in a type parameter
+                    list, e.g. `interface Map<K, V>`. They always have a space separator.
+                """,
+        ) {
+            override fun setFromString(builder: Builder, value: String) {
+                builder.typeArgumentSpacing = enumFromString<TypeArgumentSpacing>(value)
+            }
+
+            override fun stringFromFormat(format: FileFormat): String? =
+                format.specifiedTypeArgumentSpacing?.stringFromEnum()
+        },
+        ;
 
         /** The property name in the [parseSpecifier] input. */
         val propertyName: String = name.lowercase(Locale.US).replace("_", "-")
@@ -868,13 +1013,13 @@ data class FileFormat(
          * Set the corresponding property in the supplied [Builder] to the value corresponding to
          * the string representation [value].
          */
-        abstract fun setFromString(builder: Builder, value: String)
+        internal abstract fun setFromString(builder: Builder, value: String)
 
         /**
          * Get the string representation of the corresponding property from the supplied
          * [FileFormat].
          */
-        abstract fun stringFromFormat(format: FileFormat): String?
+        internal abstract fun stringFromFormat(format: FileFormat): String?
 
         /** Inline function to map from a string value to an enum value of the required type. */
         inline fun <reified T : Enum<T>> enumFromString(value: String): T {
@@ -924,7 +1069,7 @@ data class FileFormat(
         fun yesNo(value: Boolean): String = if (value) "yes" else "no"
 
         companion object {
-            val byPropertyName = values().associateBy { it.propertyName }
+            val byPropertyName = entries.associateBy { it.propertyName }
 
             /**
              * Get the [CustomizableProperty] by name, throwing an [ApiParseException] if it could
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt
new file mode 100644
index 000000000..1d2687aab
--- /dev/null
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.JAVA_LANG_PACKAGE
+import com.android.tools.metalava.model.JAVA_LANG_PREFIX
+
+/**
+ * Encapsulates information about the contents of the `java.lang` package obtained from a number of
+ * different sources, e.g. a [ClassResolver] or Metalava's own classpath, depending on what is
+ * available.
+ */
+abstract class JavaLangPackage {
+    /** Cache for the result of [check]. */
+    private val nameToBoolean = mutableMapOf<String, Boolean>()
+
+    /**
+     * Check to see if [name] exists.
+     *
+     * @param name the qualified name of a class in `java.lang` package and not its sub-packages.
+     */
+    fun containsQualified(name: String): Boolean {
+        require(name.startsWith(JAVA_LANG_PREFIX)) { "'$name' must start with '$JAVA_LANG_PREFIX'" }
+        require(name.lastIndexOf('.') == JAVA_LANG_PACKAGE.length) {
+            "'$name' must not be in a sub-package of '$JAVA_LANG_PACKAGE'"
+        }
+        return nameToBoolean.computeIfAbsent(name, ::check)
+    }
+
+    protected abstract fun check(name: String): Boolean
+
+    companion object {
+        /**
+         * A [JavaLangPackage] implementation that uses reflection to check the running process's
+         * `java.lang` package.
+         *
+         * This may not be exactly the same as the `java.lang` package that is usable from the API
+         * being read, but it is better than just assuming every unqualified type is part of
+         * `java.lang`.
+         */
+        val DEFAULT: JavaLangPackage = JavaLangPackageViaReflection()
+    }
+
+    private class JavaLangPackageViaReflection : JavaLangPackage() {
+        private val platformClassLoader = ClassLoader.getPlatformClassLoader()
+
+        override fun check(name: String) =
+            try {
+                // Try and load the class.
+                platformClassLoader.loadClass(name)
+                // The class was loaded so it
+                true
+            } catch (_: ClassNotFoundException) {
+                // The class could not be found so it does not exist.
+                false
+            }
+    }
+}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt
new file mode 100644
index 000000000..b9613a1ee
--- /dev/null
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.reporter.Issues
+
+/**
+ * Provides support for reporting recoverable errors while parsing signature files.
+ *
+ * A recoverable error is one that is not caused by syntax issues and there is an obvious way of
+ * moving past after reporting the problem, e.g. not the invalid information in the [Codebase].
+ *
+ * This is primarily for testing and reading historical versions which may not quite match the
+ * expected format. In normal use signature files are always generated by Metalava and so should
+ * always be readable by Metalava.
+ */
+internal interface SignatureErrorReporter {
+    /** Report recoverable errors encountered while parsing. */
+    fun report(issue: Issues.Issue, message: String)
+
+    /** Report recoverable errors encountered while parsing, using [Issues.SIGNATURE_FILE_ERROR]. */
+    fun report(message: String) = report(Issues.SIGNATURE_FILE_ERROR, message)
+
+    companion object {
+        /** A [SignatureErrorReporter] that throws an exception at the first error it encounters. */
+        val THROWING =
+            object : SignatureErrorReporter {
+                override fun report(issue: Issues.Issue, message: String) {
+                    throw ApiParseException("$message [$issue]")
+                }
+            }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
similarity index 89%
rename from metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
rename to metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
index 0d5e0886f..96547007f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
@@ -32,7 +32,7 @@ import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeStringConfiguration
-import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.FileFormat.TypeArgumentSpacing
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.ApiVisitor
@@ -119,8 +119,13 @@ class SignatureWriter(
     override fun visitProperty(property: PropertyItem) {
         write("    property ")
         writeModifiers(property)
+        writeTypeParameterList(property.typeParameterList, addSpace = true)
         if (fileFormat.kotlinNameTypeOrder) {
             // Kotlin style: write the name of the property, then the type.
+            property.receiver?.let {
+                writeType(it)
+                write(".")
+            }
             write(property.name())
             write(": ")
             writeType(property.type())
@@ -128,6 +133,10 @@ class SignatureWriter(
             // Java style: write the type, then the name of the property.
             writeType(property.type())
             write(" ")
+            property.receiver?.let {
+                writeType(it)
+                write(".")
+            }
             write(property.name())
         }
         write(";\n")
@@ -155,7 +164,7 @@ class SignatureWriter(
         writeThrowsList(method)
 
         if (method.containingClass().isAnnotationType()) {
-            val default = method.defaultValue()
+            val default = method.legacyDefaultValue()
             if (default.isNotEmpty()) {
                 write(" default ")
                 write(default)
@@ -193,7 +202,7 @@ class SignatureWriter(
     }
 
     private fun writeModifiers(item: Item) {
-        modifierListWriter.write(item)
+        modifierListWriter.write(item, normalizeFinal = fileFormat.normalizeFinalModifier)
     }
 
     private fun writeSuperClassStatement(cls: ClassItem) {
@@ -245,8 +254,21 @@ class SignatureWriter(
         orderedInterfaces.forEach { typeItem -> writeExtendsOrImplementsType(typeItem) }
     }
 
+    /** [TypeStringConfiguration] for use when writing types in [writeTypeParameterList]. */
+    private val typeParameterItemStringConfiguration =
+        TypeStringConfiguration(
+            spaceBetweenTypeArguments = fileFormat.typeArgumentSpacing != TypeArgumentSpacing.NONE,
+            stripJavaLangPrefix =
+                // Only strip `java.lang.` prefix if always requested. That is because the LEGACY
+                // behavior is not to strip `java.lang.` prefix in bounds.
+                when (fileFormat.stripJavaLangPrefix) {
+                    StripJavaLangPrefix.ALWAYS -> StripJavaLangPrefix.ALWAYS
+                    else -> StripJavaLangPrefix.NEVER
+                },
+        )
+
     private fun writeTypeParameterList(typeList: TypeParameterList, addSpace: Boolean) {
-        val typeListString = typeList.toString()
+        val typeListString = typeList.toSource(typeParameterItemStringConfiguration)
         if (typeListString.isNotEmpty()) {
             write(typeListString)
             if (addSpace) {
@@ -262,8 +284,8 @@ class SignatureWriter(
             if (writtenParams > 0) {
                 write(", ")
             }
-            if (parameter.hasDefaultValue() && fileFormat.conciseDefaultValues) {
-                // Concise representation of a parameter with a default
+            if (parameter.hasDefaultValue() && fileFormat.includeDefaultParameterValues) {
+                // Indicate the parameter has a default.
                 write("optional ")
             }
             writeModifiers(parameter)
@@ -285,16 +307,6 @@ class SignatureWriter(
                 }
             }
 
-            if (parameter.isDefaultValueKnown() && !fileFormat.conciseDefaultValues) {
-                write(" = ")
-                val defaultValue = parameter.defaultValueAsString()
-                if (defaultValue != null) {
-                    write(defaultValue)
-                } else {
-                    // null is a valid default value!
-                    write("null")
-                }
-            }
             writtenParams++
         }
         write(")")
@@ -305,6 +317,7 @@ class SignatureWriter(
         TypeStringConfiguration(
             annotations = fileFormat.includeTypeUseAnnotations,
             kotlinStyleNulls = fileFormat.kotlinStyleNulls,
+            spaceBetweenTypeArguments = fileFormat.typeArgumentSpacing == TypeArgumentSpacing.SPACE,
             stripJavaLangPrefix = fileFormat.stripJavaLangPrefix,
         )
 
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SnapshotDeltaMaker.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SnapshotDeltaMaker.kt
new file mode 100644
index 000000000..4cef38ef5
--- /dev/null
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SnapshotDeltaMaker.kt
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.MemberItem
+import com.android.tools.metalava.model.ModifierList
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.snapshot.EmittableDelegatingVisitor
+import com.android.tools.metalava.model.snapshot.NonFilteringDelegatingVisitor
+
+/**
+ * Creates a snapshot that is a delta between two [Codebase]s.
+ *
+ * This effectively does the opposite of what [ApiFile] does when creating a [Codebase] from
+ * multiple signature files, where the first is a standalone surface and each subsequent file is for
+ * a surface that extends the surface in the preceding file.
+ *
+ * This can be used to create deltas that can be used when class nesting is not maintained as it
+ * does not emit a class just because a nested class needs emitting.
+ */
+class SnapshotDeltaMaker private constructor(private val base: Codebase) :
+    BaseItemVisitor(
+        preserveClassNesting = true,
+        visitParameterItems = false,
+    ) {
+    /**
+     * Mark the package to emit.
+     *
+     * The containing package is not marked to emit as packages are flattened before visiting.
+     */
+    private fun PackageItem.markEmit() {
+        if (!emit) {
+            emit = true
+        }
+    }
+
+    /**
+     * Mark the class to emit.
+     *
+     * The containing package is marked to emit as otherwise its contents will not usually be
+     * visited. The containing class of nested classes is not marked to emit as this is used for
+     * files that flatten nested classes so nested classes can be visited without checking the
+     * [SelectableItem.emit] of the containing class.
+     */
+    private fun ClassItem.markEmit() {
+        if (!emit) {
+            emit = true
+            containingPackage().markEmit()
+        }
+    }
+
+    /**
+     * Mark a member to emit.
+     *
+     * The containing class is marked to emit as otherwise its members will not be visited.
+     */
+    private fun MemberItem.markEmit() {
+        if (!emit) {
+            emit = true
+            containingClass().markEmit()
+        }
+    }
+
+    /** Override to visit all packages. */
+    override fun skipPackage(pkg: PackageItem) = false
+
+    /** Override to skip any non-public or protected items. */
+    override fun skip(item: Item): Boolean = !item.modifiers.isPublicOrProtected()
+
+    /** Convert a list of [AnnotationItem]s into a list of [String]s for comparison. */
+    // TODO(b/354633349): Use equality once value abstraction provides consistent behavior across
+    //   models.
+    private fun List<AnnotationItem>.normalize() = map { it.toString() }.sorted()
+
+    override fun visitClass(cls: ClassItem) {
+        cls.findCorrespondingItemIn(base)?.let { baseClass ->
+            // If super class type is set and is different to the base class then drop out to emit
+            // this class.
+            val superClassType = cls.superClassType()
+            if (superClassType != null && baseClass.superClassType() != superClassType) {
+                return@let
+            }
+
+            // If this class has different annotations to the base class then drop out to emit
+            // this class.
+            val annotations = cls.modifiers.annotations().normalize()
+            val baseAnnotations = baseClass.modifiers.annotations().normalize()
+            if (annotations != baseAnnotations) {
+                return@let
+            }
+
+            // The class is not different so do not emit it.
+            return
+        }
+
+        // The class is new or different.
+        cls.markEmit()
+    }
+
+    override fun visitCallable(callable: CallableItem) {
+        callable.findCorrespondingItemIn(base)?.let {
+            return
+        }
+
+        // The callable is new.
+        callable.markEmit()
+    }
+
+    override fun visitField(field: FieldItem) {
+        field.findCorrespondingItemIn(base)?.let {
+            return
+        }
+
+        // The field is new.
+        field.markEmit()
+    }
+
+    override fun visitProperty(property: PropertyItem) {
+        property.findCorrespondingItemIn(base)?.let {
+            return
+        }
+
+        // The property is new.
+        property.markEmit()
+    }
+
+    companion object {
+        /**
+         * Create a text [Codebase] that is a delta between [base] and [codebaseFragment], i.e. it
+         * includes all the [Item] that are in [codebaseFragment] but not in [base].
+         *
+         * This is expected to be used where [codebaseFragment] is a super set of [base] but that is
+         * not enforced. If [base] contains [Item]s which are not present in [codebaseFragment] then
+         * they will not appear in the delta.
+         *
+         * [ClassItem]s are treated specially. If [codebaseFragment] and [base] have [ClassItem]s
+         * with the same name and [codebaseFragment]'s has members which are not present in [base]'s
+         * then a [ClassItem] containing the additional [codebaseFragment] members will appear in
+         * the delta, otherwise it will not unless the two [ClassItem]s differ in one of the
+         * following ways:
+         * * The modifiers are not [ModifierList.equivalentTo] each other.
+         * * The [ClassItem.superClassType]s are not the same.
+         *
+         * Note: A [MemberItem] that exists in both will not be emitted even if they differ in some
+         * way, e.g. annotations, extends list. That is because [ApiFile] has no mechanism to
+         * combine them and does not even throw an error if it encounters duplicates.
+         */
+        fun createDelta(
+            base: Codebase,
+            codebaseFragment: CodebaseFragment,
+        ): CodebaseFragment {
+            // Take a snapshot.
+            val snapshotFragment =
+                codebaseFragment.snapshotIncludingRevertedItems(
+                    referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
+                )
+
+            val snapshot = snapshotFragment.codebase
+
+            // Assume that none of it will be emitted.
+            snapshot.accept(
+                object : BaseItemVisitor() {
+                    override fun visitSelectableItem(item: SelectableItem) {
+                        item.emit = false
+                    }
+                }
+            )
+
+            // Mark those items that are new (or different) to be emitted. Also, marks their
+            // containers, e.g. class members and nested classes will mark their containing class,
+            // classes will mark their containing package.
+            val deltaMaker = SnapshotDeltaMaker(base)
+            snapshot.accept(deltaMaker)
+
+            return CodebaseFragment.create(snapshot, ::EmittableDelegatingVisitor)
+        }
+    }
+}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
deleted file mode 100644
index 9fb4e2382..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PropertyItem
-import com.android.tools.metalava.model.item.DefaultClassItem
-import com.android.tools.metalava.model.item.DefaultCodebase
-import com.android.tools.metalava.model.item.DefaultPackageItem
-import com.android.tools.metalava.reporter.FileLocation
-import java.io.File
-
-/** Supports building a [DefaultCodebase] that is a subset of another [DefaultCodebase]. */
-class TextCodebaseBuilder private constructor(private val assembler: TextCodebaseAssembler) {
-
-    companion object {
-        fun build(
-            location: File,
-            description: String,
-            codebaseConfig: Codebase.Config,
-            block: TextCodebaseBuilder.() -> Unit
-        ): Codebase {
-            val assembler =
-                TextCodebaseAssembler.createAssembler(
-                    location = location,
-                    description = description,
-                    codebaseConfig = codebaseConfig,
-                    classResolver = null,
-                )
-            val builder = TextCodebaseBuilder(assembler)
-            builder.block()
-
-            return assembler.codebase
-        }
-    }
-
-    val codebase = assembler.codebase
-
-    val description by codebase::description
-
-    private val itemFactory = assembler.itemFactory
-
-    private fun getOrAddPackage(pkgName: String) = codebase.findOrCreatePackage(pkgName)
-
-    fun addPackage(pkg: PackageItem) {
-        codebase.addPackage(pkg as DefaultPackageItem)
-    }
-
-    fun addClass(cls: ClassItem) {
-        // Replicate some of the registration code from DefaultClassItem initialization block. This
-        // does not register classes correctly. e.g. It adds nested classes as top level classes in
-        // the package. While that is strictly speaking invalid it works for this which is only used
-        // to create a very short-lived Codebase that is written out to a JDiff file.
-        // TODO(b/369078254): Clean this up.
-        codebase.registerClass(cls as DefaultClassItem)
-        val containingPackage = getOrAddPackage(cls.containingPackage().qualifiedName())
-        containingPackage.addTopClass(cls)
-
-        // If the class is emittable then make sure its package is too.
-        if (cls.emit) {
-            containingPackage.emit = true
-        }
-    }
-
-    fun addConstructor(ctor: ConstructorItem) {
-        val cls = getOrAddClass(ctor.containingClass())
-        cls.addConstructor(ctor)
-    }
-
-    fun addMethod(method: MethodItem) {
-        val cls = getOrAddClass(method.containingClass())
-        cls.addMethod(method)
-    }
-
-    fun addField(field: FieldItem) {
-        val cls = getOrAddClass(field.containingClass())
-        cls.addField(field)
-    }
-
-    fun addProperty(property: PropertyItem) {
-        val cls = getOrAddClass(property.containingClass())
-        cls.addProperty(property)
-    }
-
-    private fun getOrAddClass(fullClass: ClassItem): DefaultClassItem {
-        val cls = codebase.findClassInCodebase(fullClass.qualifiedName())
-        if (cls != null) {
-            return cls
-        }
-        val pkg = getOrAddPackage(fullClass.containingPackage().qualifiedName())
-
-        return itemFactory.createClassItem(
-            fileLocation = FileLocation.UNKNOWN,
-            modifiers = fullClass.modifiers,
-            classKind = fullClass.classKind,
-            containingClass = null,
-            containingPackage = pkg,
-            qualifiedName = fullClass.qualifiedName(),
-            typeParameterList = fullClass.typeParameterList,
-            origin = fullClass.origin,
-            superClassType = fullClass.superClassType(),
-            interfaceTypes = fullClass.interfaceTypes(),
-        )
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
index ae579c85d..9e500c5a4 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
@@ -41,10 +41,47 @@ import com.android.tools.metalava.model.type.DefaultPrimitiveTypeItem
 import com.android.tools.metalava.model.type.DefaultTypeModifiers
 import com.android.tools.metalava.model.type.DefaultVariableTypeItem
 import com.android.tools.metalava.model.type.DefaultWildcardTypeItem
+import com.android.tools.metalava.reporter.Issues
 import kotlin.collections.HashMap
 
 /** Parses and caches types for a [codebase]. */
-internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Boolean = false) {
+internal class TextTypeParser(
+    val codebase: Codebase,
+    val kotlinStyleNulls: Boolean = false,
+    delegateErrorReporter: SignatureErrorReporter = SignatureErrorReporter.THROWING,
+) {
+    /**
+     * Tracks whether types that were unqualified and so implicitly treated as being part of the
+     * 'java.lang` package are actually part of that package. If they are not then an error is
+     * reported and it is not prefixed with `java.lang`.
+     */
+    private val javaLangPackage: JavaLangPackage = JavaLangPackage.DEFAULT
+
+    /**
+     * A count of the errors reported through [errorReporter].
+     *
+     * This is used to prevent caching [TypeItem]s that reported errors to make sure that every such
+     * case is reported.
+     */
+    private var errorCount = 0
+
+    /**
+     * Report a recoverable error.
+     *
+     * This keeps a count of how many were reported so that [CacheEntry.getTypeItem] can use that to
+     * determine if any errors were found while parsing a type ([errorCount] increased) and so
+     * prevent it from being cached which would suppress any more errors with that type string.
+     */
+    private val errorReporter: SignatureErrorReporter =
+        object : SignatureErrorReporter {
+            override fun report(
+                issue: Issues.Issue,
+                message: String,
+            ) {
+                delegateErrorReporter.report(issue, message)
+                errorCount += 1
+            }
+        }
 
     /**
      * The cache key, incorporates some information from [ContextNullability] and [kotlinStyleNulls]
@@ -137,7 +174,8 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                 // If forceClassToBeNonNull is true then a plain class type without any nullability
                 // suffix must be treated as if it was not null, which is just how it would be
                 // treated when kotlinStyleNulls is true. So, pretend that kotlinStyleNulls is true.
-                kotlinStyleNulls || forceClassToBeNonNull
+                kotlinStyleNulls || forceClassToBeNonNull,
+                errorReporter,
             )
         val trimmed = withoutNullability.trim()
 
@@ -190,7 +228,7 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                 else -> return null
             }
         if (nullability != null && nullability != TypeNullability.NONNULL) {
-            throw ApiParseException("Invalid nullability suffix on primitive: $original")
+            errorReporter.report("Invalid nullability suffix on primitive: $original")
         }
         return DefaultPrimitiveTypeItem(modifiers(annotations, TypeNullability.NONNULL), kind)
     }
@@ -237,7 +275,12 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
 
         // Remove nullability marker from the component type, but don't add it to the list yet, as
         // it might not be an array.
-        var nullabilityResult = splitNullabilitySuffix(componentString, kotlinStyleNulls)
+        var nullabilityResult =
+            splitNullabilitySuffix(
+                componentString,
+                kotlinStyleNulls,
+                errorReporter,
+            )
         componentString = nullabilityResult.first
         var componentNullability = nullabilityResult.second
 
@@ -254,7 +297,12 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
 
             // Remove nullability marker from the new component type, but don't add it to the list
             // yet, as the next component type might not be an array.
-            nullabilityResult = splitNullabilitySuffix(componentString, kotlinStyleNulls)
+            nullabilityResult =
+                splitNullabilitySuffix(
+                    componentString,
+                    kotlinStyleNulls,
+                    errorReporter,
+                )
             componentString = nullabilityResult.first
             componentNullability = nullabilityResult.second
         }
@@ -302,35 +350,33 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
         // See if this is a wildcard
         if (!type.startsWith("?")) return null
 
+        val modifiers = modifiers(annotations, TypeNullability.UNDEFINED)
+
         // Unbounded wildcard type: there is an implicit Object extends bound
-        if (type == "?")
-            return DefaultWildcardTypeItem(
-                modifiers(annotations, TypeNullability.UNDEFINED),
-                objectType,
-                null,
-            )
+        if (type == "?") return DefaultWildcardTypeItem(modifiers, objectType, null)
 
         // If there's a bound, the nullability suffix applies there instead.
         val bound = type.substring(2) + nullability?.suffix.orEmpty()
         return if (bound.startsWith("extends")) {
             val extendsBound = bound.substring(8)
             DefaultWildcardTypeItem(
-                modifiers(annotations, TypeNullability.UNDEFINED),
+                modifiers,
                 getWildcardBound(extendsBound, typeParameterScope),
                 null,
             )
         } else if (bound.startsWith("super")) {
             val superBound = bound.substring(6)
             DefaultWildcardTypeItem(
-                modifiers(annotations, TypeNullability.UNDEFINED),
+                modifiers,
                 // All wildcards have an implicit Object extends bound
                 objectType,
                 getWildcardBound(superBound, typeParameterScope),
             )
         } else {
-            throw ApiParseException(
-                "Type starts with \"?\" but doesn't appear to be wildcard: $type"
-            )
+            errorReporter.report("Type starts with \"?\" but doesn't appear to be wildcard: $type")
+
+            // Ignore the part after the "?" and treat it as an unbounded wildcard.
+            DefaultWildcardTypeItem(modifiers, objectType, null)
         }
     }
 
@@ -390,8 +436,17 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                 // This is a nested type, add the prefix of the outer name
                 "${outerClassType.qualifiedName}.$name"
             } else if (!name.contains('.')) {
-                // Reverse the effect of [TypeItem.stripJavaLangPrefix].
-                "java.lang.$name"
+                val javaLangName = "java.lang.$name"
+                if (javaLangPackage.containsQualified(javaLangName)) {
+                    // Reverse the effect of [TypeItem.stripJavaLangPrefix].
+                    javaLangName
+                } else {
+                    errorReporter.report(
+                        Issues.UNQUALIFIED_TYPE_ERROR,
+                        "Unqualified type '$name' is not in 'java.lang' and is not a type parameter in scope"
+                    )
+                    name
+                }
             } else {
                 name
             }
@@ -412,10 +467,13 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
 
         if (remainder != null) {
             if (!remainder.startsWith('.')) {
-                throw ApiParseException(
+                errorReporter.report(
                     "Could not parse type `$type`. Found unexpected string after type parameters: $remainder"
                 )
+                // Ignore the remainder.
+                return classType
             }
+
             // This is a nested class type, recur with the new outer class
             return createClassType(
                 remainder.substring(1),
@@ -578,7 +636,8 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
          */
         fun splitNullabilitySuffix(
             type: String,
-            kotlinStyleNulls: Boolean
+            kotlinStyleNulls: Boolean,
+            errorReporter: SignatureErrorReporter = SignatureErrorReporter.THROWING,
         ): Pair<String, TypeNullability?> {
             return if (kotlinStyleNulls) {
                 // Don't interpret the wildcard type `?` as a nullability marker.
@@ -591,10 +650,9 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                 } else {
                     Pair(type, TypeNullability.NONNULL)
                 }
-            } else if (type.length > 1 && type.endsWith("?") || type.endsWith("!")) {
-                throw ApiParseException(
-                    "Format does not support Kotlin-style null type syntax: $type"
-                )
+            } else if (((type.length > 1) && type.endsWith("?")) || type.endsWith("!")) {
+                errorReporter.report("Format does not support Kotlin-style null type syntax: $type")
+                Pair(type.dropLast(1), TypeNullability.PLATFORM)
             } else {
                 Pair(type, null)
             }
@@ -770,8 +828,17 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                     null
                 }
 
-            // Parse the [type] to produce a [TypeItem].
+            // Remember the number of errors that have been reported so far.
+            val startErrorCount = errorCount
+
+            // Parse the [type] to produce a [TypeItem]. This may report errors.
             val typeItem = createTypeItem(typeParameterScope)
+
+            // If the error count is different then do not cache this.
+            if (errorCount != startErrorCount) {
+                return typeItem
+            }
+
             cacheSize++
 
             // Find the scope for caching if it was not found above.
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
index 8cd7a4f1b..11bf98ee1 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
@@ -38,38 +38,40 @@ class ApiFileTest : BaseTextCodebaseTest() {
 
     @Test
     fun `Test mixture of kotlinStyleNulls settings`() {
-        val exception =
-            assertThrows(ApiParseException::class.java) {
-                runSignatureTest(
-                    signature(
-                        "file1.txt",
-                        """
-                            // Signature format: 5.0
-                            // - kotlin-style-nulls=yes
-                            package test.pkg {
-                                public class Foo {
-                                    method void foo(Object);
-                                }
-                            }
-                        """
-                    ),
-                    signature(
-                        "file2.txt",
-                        """
-                            // Signature format: 5.0
-                            // - kotlin-style-nulls=no
-                            package test.pkg {
-                                public class Bar {
-                                    method void bar(Object);
-                                }
-                            }
-                        """
-                    )
-                ) {}
-            }
+        runSignatureTest(
+            signature(
+                "file1.txt",
+                """
+                    // Signature format: 5.0
+                    // - kotlin-style-nulls=yes
+                    package test.pkg {
+                        public class Foo {
+                            method void foo(Object);
+                        }
+                    }
+                """
+            ),
+            signature(
+                "file2.txt",
+                """
+                    // Signature format: 5.0
+                    // - kotlin-style-nulls=no
+                    package test.pkg {
+                        public class Bar {
+                            method void bar(Object);
+                        }
+                    }
+                """
+            ),
+        ) {
+            assertThat(reportedIssues)
+                .isEqualTo(
+                    "MAIN_SRC/file2.txt:1: error: Preceding file MAIN_SRC/file1.txt has different setting of kotlin-style-nulls which may cause issues [SignatureFileError]"
+                )
 
-        assertThat(exception.message)
-            .contains("Cannot mix signature files with different settings of kotlinStyleNulls")
+            codebase.assertClass("test.pkg.Foo")
+            codebase.assertClass("test.pkg.Bar")
+        }
     }
 
     @Test
@@ -386,6 +388,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
     fun `Test split across multiple files, middle missing`() {
         checkPackageStructureCreatedCorrectly(
             signature(
+                "api1.txt",
                 """
                     // Signature format: 2.0
                     package test.pkg {
@@ -395,6 +398,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 """
             ),
             signature(
+                "api2.txt",
                 """
                     // Signature format: 2.0
                     package test.pkg {
@@ -410,6 +414,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
     fun `Test split across multiple files`() {
         checkPackageStructureCreatedCorrectly(
             signature(
+                "api1.txt",
                 """
                     // Signature format: 2.0
                     package test.pkg {
@@ -419,6 +424,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 """
             ),
             signature(
+                "api2.txt",
                 """
                     // Signature format: 2.0
                     package test.pkg {
@@ -428,6 +434,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 """
             ),
             signature(
+                "api3.txt",
                 """
                     // Signature format: 2.0
                     package test.pkg {
@@ -439,6 +446,57 @@ class ApiFileTest : BaseTextCodebaseTest() {
         )
     }
 
+    @Test
+    fun `Test duplicate methods across multiple files`() {
+        runSignatureTest(
+            signature(
+                "api1.txt",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                            method public void foo();
+                        }
+                    }
+                """
+            ),
+            signature(
+                "api2.txt",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                            method public void foo();
+                        }
+                    }
+                """
+            ),
+        ) {
+            // Make sure that duplicate methods loaded from multiple files are de-duped.
+            assertThat(codebase.assertClass("test.pkg.Foo").methods().size).isEqualTo(1)
+        }
+    }
+
+    @Test
+    fun `Test duplicate methods within single file`() {
+        runSignatureTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                            method public void foo();
+                            method public void foo();
+                        }
+                    }
+                """
+            ),
+        ) {
+            // Make sure that duplicate methods loaded from multiple files are not de-duped.
+            assertThat(codebase.assertClass("test.pkg.Foo").methods().size).isEqualTo(2)
+        }
+    }
+
     @Test
     fun `Test unknown interface should still be marked as such`() {
         runSignatureTest(
@@ -463,6 +521,78 @@ class ApiFileTest : BaseTextCodebaseTest() {
         }
     }
 
+    @Test
+    fun `Test type parser issues - kotlin-style-nulls=no`() {
+        runSignatureTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public abstract class Foo implements Comparable<? blah1> {
+                            field public static final int? FIELD1 = 0;
+                            method public void foo(Comparable<test.pkg.Foo>blah2);
+                            field public static final int? FIELD2 = 0;
+                        }
+                        public abstract class Bar implements Comparable<? blah1> {
+                        }
+                    }
+                """
+            ),
+        ) {
+            assertThat(reportedIssues)
+                .isEqualTo(
+                    """
+                        MAIN_SRC/api.txt:3: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [SignatureFileError]
+                        MAIN_SRC/api.txt:4: error: Format does not support Kotlin-style null type syntax: int? [SignatureFileError]
+                        MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [SignatureFileError]
+                        MAIN_SRC/api.txt:5: error: Could not parse type `Comparable<test.pkg.Foo>blah2`. Found unexpected string after type parameters: blah2 [SignatureFileError]
+                        MAIN_SRC/api.txt:6: error: Format does not support Kotlin-style null type syntax: int? [SignatureFileError]
+                        MAIN_SRC/api.txt:6: error: Invalid nullability suffix on primitive: int? [SignatureFileError]
+                        MAIN_SRC/api.txt:8: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [SignatureFileError]
+                    """
+                        .trimIndent()
+                )
+
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val barClass = codebase.assertClass("test.pkg.Bar")
+
+            // Implements lists should drop blah1 and be an unbounded wildcard.
+            assertThat(fooClass.interfaceTypes().map { it.toString() })
+                .isEqualTo(listOf("java.lang.Comparable<?>"))
+            assertThat(barClass.interfaceTypes().map { it.toString() })
+                .isEqualTo(listOf("java.lang.Comparable<?>"))
+
+            // The type of Foo.FIELD1 should just be `int`.
+            assertThat(fooClass.assertField("FIELD1").type().toString()).isEqualTo("int")
+        }
+    }
+
+    @Test
+    fun `Test type parser issues - kotlin-style-nulls=yes`() {
+        runSignatureTest(
+            signature(
+                """
+                    // Signature format: 4.0
+                    package test.pkg {
+                        public abstract class Foo {
+                            field public static final int? FIELD1 = 0;
+                        }
+                    }
+                """
+            ),
+        ) {
+            assertThat(reportedIssues)
+                .isEqualTo(
+                    "MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [SignatureFileError]"
+                )
+
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            // The type of FIELD1 should just be `int`.
+            assertThat(fooClass.assertField("FIELD1").type().toString()).isEqualTo("int")
+        }
+    }
+
     @Test
     fun testTypeParameterNames() {
         assertThat(ApiFile.extractTypeParameterBoundsStringList(null).toString()).isEqualTo("[]")
@@ -542,7 +672,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 annotationManager = noOpAnnotationManager,
                 apiSurfaces = apiSurfaces,
             )
-        val classResolver = ClassLoaderBasedClassResolver(getAndroidJar())
+        val classResolver = ClassLoaderBasedClassResolver(listOf(getAndroidJar()))
         val codebase =
             ApiFile.parseApi(
                 signatureFiles,
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
index a339b306e..7a7703faf 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
@@ -19,6 +19,9 @@ package com.android.tools.metalava.model.text
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.reporter.RecordingReporter
+import javax.annotation.CheckReturnValue
+import kotlin.test.assertEquals
 
 /**
  * Base class for text test classes that parse signature files to create a [Codebase] that can then
@@ -26,8 +29,41 @@ import com.android.tools.metalava.model.testsuite.BaseModelTest
  */
 abstract class BaseTextCodebaseTest : BaseModelTest() {
 
+    /** A [CodebaseContext] wrapper that records and provides access to any reported issues. */
+    class RecordingCodebaseContext(
+        private val delegate: CodebaseContext,
+        private val recordingReporter: RecordingReporter
+    ) : CodebaseContext by delegate {
+        /**
+         * The reported issues, with any test specific directories replaced with fixed symbols.
+         *
+         * Accessing this will remove any issues from the [recordingReporter] and it is the caller's
+         * responsibility to check the returned value.
+         */
+        @get:CheckReturnValue
+        val reportedIssues
+            get() = removeTestSpecificDirectories(recordingReporter.removeIssues())
+    }
+
     /** Run a single signature test with a set of signature files. */
-    fun runSignatureTest(vararg sources: TestFile, test: CodebaseContext.() -> Unit) {
-        runCodebaseTest(inputSet(*sources), test = test)
+    fun runSignatureTest(
+        vararg sources: TestFile,
+        test: RecordingCodebaseContext.() -> Unit,
+    ) {
+        // Create a recorder.
+        val recordingReporter = RecordingReporter()
+        val testFixture = TestFixture(reporter = recordingReporter)
+
+        runCodebaseTest(
+            inputSet(*sources),
+            testFixture = testFixture,
+            test = {
+                val recordingContext = RecordingCodebaseContext(delegate = this, recordingReporter)
+                recordingContext.test()
+            }
+        )
+
+        // Make sure that any unchecked issues will cause the test to fail.
+        assertEquals("", recordingReporter.issues, message = "Unexpected issues were reported")
     }
 }
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ClassLoaderBasedClassResolverTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ClassLoaderBasedClassResolverTest.kt
index da405d7d2..19856ecce 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ClassLoaderBasedClassResolverTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ClassLoaderBasedClassResolverTest.kt
@@ -24,7 +24,7 @@ import org.junit.Test
 class ClassLoaderBasedClassResolverTest {
 
     private fun checkClassResolved(qualifiedName: String) {
-        val resolver = ClassLoaderBasedClassResolver(getAndroidJar())
+        val resolver = ClassLoaderBasedClassResolver(listOf(getAndroidJar()))
         val classItem = resolver.resolveClass(qualifiedName)
         assertNotNull(classItem)
         assertEquals(qualifiedName, classItem.qualifiedName())
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
index bfb42abff..e641aa921 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
@@ -28,9 +28,11 @@ import org.junit.Test
 val DEFAULTABLE_PROPERTY_NAMES =
     listOf(
         "add-additional-overrides",
+        "normalize-final-modifier",
         "overloaded-method-order",
         "sort-whole-extends-list",
         "strip-java-lang-prefix",
+        "type-argument-spacing",
     )
 
 val DEFAULTABLE_PROPERTIES = DEFAULTABLE_PROPERTY_NAMES.joinToString { "'$it'" }
@@ -158,7 +160,7 @@ class FileFormatTest {
                 }
                 """,
             expectedError =
-                "api.txt:1: Signature format error - invalid version, found '3.14', expected one of '2.0', '3.0', '4.0', '5.0'",
+                "api.txt:1: Signature format error - invalid version, found '3.14', expected one of '2.0', '4.0', '5.0'",
         )
     }
 
@@ -180,17 +182,17 @@ class FileFormatTest {
     }
 
     @Test
-    fun `Check format parsing (v3)`() {
+    fun `Check format parsing (v4)`() {
         checkParseHeader(
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.collection {
                   public final class LruCacheKt {
                     ctor public LruCacheKt();
                   }
                 }
             """,
-            expectedFormat = FileFormat.V3,
+            expectedFormat = FileFormat.V4,
             expectedNextLine = "package androidx.collection {",
         )
     }
@@ -268,29 +270,29 @@ class FileFormatTest {
     }
 
     @Test
-    fun `Check format parsing (v3 + kotlin-style-nulls=no but no migrating)`() {
+    fun `Check format parsing (v4 + kotlin-style-nulls=no but no migrating)`() {
         checkParseHeader(
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 // - kotlin-style-nulls=no
             """,
             expectedError =
-                "api.txt:2: Signature format error - must provide a 'migrating' property when customizing version 3.0",
+                "api.txt:2: Signature format error - must provide a 'migrating' property when customizing version 4.0",
         )
     }
 
     @Test
-    fun `Check header and specifier (v3 + kotlin-style-nulls=no,migrating=test)`() {
+    fun `Check header and specifier (v4 + kotlin-style-nulls=no,migrating=test)`() {
         headerAndSpecifierTest(
             header =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 // - kotlin-style-nulls=no
                 // - migrating=test
 
             """,
-            specifier = "3.0:kotlin-style-nulls=no,migrating=test",
-            format = FileFormat.V3.copy(kotlinStyleNulls = false, migrating = "test"),
+            specifier = "4.0:kotlin-style-nulls=no,migrating=test",
+            format = FileFormat.V4.copy(kotlinStyleNulls = false, migrating = "test"),
         )
     }
 
@@ -387,17 +389,17 @@ class FileFormatTest {
     }
 
     @Test
-    fun `Check header and specifier (v3 + kotlin-style-nulls=no)`() {
+    fun `Check header and specifier (v4 + kotlin-style-nulls=no)`() {
         headerAndSpecifierTest(
             header =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 // - kotlin-style-nulls=no
                 // - migrating=test
 
             """,
-            specifier = "3.0:kotlin-style-nulls=no,migrating=test",
-            format = FileFormat.V3.copy(kotlinStyleNulls = false, migrating = "test"),
+            specifier = "4.0:kotlin-style-nulls=no,migrating=test",
+            format = FileFormat.V4.copy(kotlinStyleNulls = false, migrating = "test"),
         )
     }
 
@@ -493,7 +495,7 @@ class FileFormatTest {
             format =
                 FileFormat.V5.copy(
                     language = FileFormat.Language.JAVA,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                     kotlinStyleNulls = false,
                 ),
         )
@@ -513,7 +515,7 @@ class FileFormatTest {
             format =
                 FileFormat.V5.copy(
                     language = FileFormat.Language.JAVA,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                     kotlinStyleNulls = true,
                 ),
         )
@@ -537,20 +539,20 @@ class FileFormatTest {
     }
 
     @Test
-    fun `Check header and specifier (v5 + concise-default-values=no,language=kotlin)`() {
+    fun `Check header and specifier (v5 + include-default-parameter-values=no,language=kotlin)`() {
         headerAndSpecifierTest(
             header =
                 """
                 // Signature format: 5.0
                 // - language=kotlin
-                // - concise-default-values=no
+                // - include-default-parameter-values=no
 
             """,
-            specifier = "5.0:language=kotlin,concise-default-values=no",
+            specifier = "5.0:language=kotlin,include-default-parameter-values=no",
             format =
                 FileFormat.V5.copy(
                     language = FileFormat.Language.KOTLIN,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                 ),
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
similarity index 71%
rename from metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
rename to metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
index 4f672fdb0..5881fa3b8 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.Assertions
@@ -23,10 +23,7 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.text.ApiFile
-import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.text.assertSignatureFilesMatch
+import com.android.tools.metalava.model.text.FileFormat.TypeArgumentSpacing
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.google.common.truth.Truth.assertThat
@@ -52,13 +49,15 @@ class SignatureInputOutputTest : Assertions {
     /**
      * Parses the API (without a header line, the header from [fileFormat] will be added) from the
      * [signature], runs the [codebaseTest] on the parsed codebase, and then writes the codebase
-     * back out in the [fileFormat], verifying that the output matches the original [signature].
+     * back out in the [fileFormat], verifying that the output matches [expectedOutput] which
+     * defaults to the original [signature].
      *
      * This tests both [ApiFile] and [SignatureWriter].
      */
     private fun runInputOutputTest(
         signature: String,
         fileFormat: FileFormat,
+        expectedOutput: String = signature,
         codebaseTest: CodebaseContext.() -> Unit = {},
     ) {
         val fullSignature = fileFormat.header() + signature
@@ -92,7 +91,7 @@ class SignatureInputOutputTest : Assertions {
                 stringWriter.toString()
             }
 
-        assertSignatureFilesMatch(signature, output, fileFormat)
+        assertSignatureFilesMatch(expectedOutput, output, fileFormat)
     }
 
     @Test
@@ -156,7 +155,7 @@ class SignatureInputOutputTest : Assertions {
             assertThat(field.name()).isEqualTo("foo")
             assertThat(field.type().isString()).isTrue()
             assertThat(field.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PROTECTED)
-            assertThat(field.initialValue()).isNull()
+            assertThat(field.legacyInitialValue()).isNull()
         }
     }
 
@@ -180,7 +179,7 @@ class SignatureInputOutputTest : Assertions {
             assertThat(field.type().isString()).isTrue()
             assertThat(field.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
             assertThat(field.modifiers.isStatic()).isTrue()
-            assertThat(field.initialValue()).isEqualTo("hi")
+            assertThat(field.legacyInitialValue()).isEqualTo("hi")
         }
     }
 
@@ -257,8 +256,7 @@ class SignatureInputOutputTest : Assertions {
                 .isEqualTo(PrimitiveTypeItem.Primitive.INT)
             assertThat(method.parameters()).isEmpty()
 
-            assertThat(method.hasDefaultValue()).isTrue()
-            assertThat(method.defaultValue()).isEqualTo("java.lang.Integer.MIN_VALUE")
+            assertThat(method.legacyDefaultValue()).isEqualTo("java.lang.Integer.MIN_VALUE")
         }
     }
 
@@ -287,7 +285,7 @@ class SignatureInputOutputTest : Assertions {
     }
 
     @Test
-    fun `Test method with one named parameter with concise default value`() {
+    fun `Test method with one named parameter with default value`() {
         val api =
             """
                 package test.pkg {
@@ -309,36 +307,6 @@ class SignatureInputOutputTest : Assertions {
                 .isEqualTo(PrimitiveTypeItem.Primitive.INT)
 
             assertThat(param.hasDefaultValue()).isTrue()
-            assertThat(param.isDefaultValueKnown()).isFalse()
-        }
-    }
-
-    @Test
-    fun `Test method with one named parameter with non-concise default value`() {
-        val format = kotlinStyleFormat.copy(conciseDefaultValues = false)
-        val api =
-            """
-                package test.pkg {
-                  public class Foo {
-                    method public foo(arg: int = 3): String;
-                  }
-                }
-            """
-                .trimIndent()
-        runInputOutputTest(api, format) {
-            val foo = codebase.assertClass("test.pkg.Foo")
-            val method = foo.methods().single()
-
-            assertThat(method.parameters()).hasSize(1)
-            val param = method.parameters().single()
-            assertThat(param.name()).isEqualTo("arg")
-            assertThat(param.publicName()).isEqualTo("arg")
-            assertThat((param.type() as PrimitiveTypeItem).kind)
-                .isEqualTo(PrimitiveTypeItem.Primitive.INT)
-
-            assertThat(param.hasDefaultValue()).isTrue()
-            assertThat(param.isDefaultValueKnown()).isTrue()
-            assertThat(param.defaultValueAsString()).isEqualTo("3")
         }
     }
 
@@ -585,6 +553,121 @@ class SignatureInputOutputTest : Assertions {
         runInputOutputTest(api, kotlinStyleFormat)
     }
 
+    @Test
+    fun `Test property receivers, java name-type order`() {
+        val api =
+            """
+                package test.pkg {
+                  public class Foo {
+                    property public int int.intProperty;
+                    property public boolean String?.nullableStringProperty;
+                    property public boolean String[].stringArrayProperty;
+                    property public boolean java.util.List<java.lang.String>.stringListProperty;
+                    property public static int String.stringProperty;
+                  }
+                }
+            """
+        runInputOutputTest(api, FileFormat.V4)
+    }
+
+    @Test
+    fun `Test property receivers, kotlin name-type order`() {
+        val api =
+            """
+                package test.pkg {
+                  public class Foo {
+                    property public int.intProperty: int;
+                    property public String?.nullableStringProperty: boolean;
+                    property public String[].stringArrayProperty: boolean;
+                    property public java.util.List<java.lang.String>.stringListProperty: boolean;
+                    property public static String.stringProperty: int;
+                  }
+                }
+            """
+        runInputOutputTest(api, kotlinStyleFormat)
+    }
+
+    @Test
+    fun `Test property type parameters, java name-type order`() {
+        // A property with type parameters must have a receiver
+        val api =
+            """
+                package test.pkg {
+                  public class Foo {
+                    property public static <T> int java.util.List<? extends T>.oneTypeParameterListReceiver;
+                    property public static <T> int T.oneTypeParameterReceiver;
+                    property public static <T extends java.lang.String> int T.oneTypeParameterWithBoundsReceiver;
+                    property public static <T1, T2> int java.util.Map<T1,? extends T2>.twoTypeParameterMapReceiver;
+                    property public static <T1 extends java.lang.String, T2 extends java.util.List<? extends T1>> int java.util.Map<T1,? extends T2>.twoTypeParameterWithBoundsMapReceiver;
+                  }
+                }
+            """
+        runInputOutputTest(api, FileFormat.V4)
+    }
+
+    @Test
+    fun `Test property type parameters, kotlin name-type order`() {
+        // A property with type parameters must have a receiver
+        val api =
+            """
+                package test.pkg {
+                  public class Foo {
+                    property public static <T> java.util.List<? extends T>.oneTypeParameterListReceiver: int;
+                    property public static <T> T.oneTypeParameterReceiver: int;
+                    property public static <T extends java.lang.String> T.oneTypeParameterWithBoundsReceiver: int;
+                    property public static <T1, T2> java.util.Map<T1,? extends T2>.twoTypeParameterMapReceiver: int;
+                    property public static <T1 extends java.lang.String, T2 extends java.util.List<? extends T1>> java.util.Map<T1,? extends T2>.twoTypeParameterWithBoundsMapReceiver: int;
+                  }
+                }
+            """
+        runInputOutputTest(api, kotlinStyleFormat)
+    }
+
+    @Test
+    fun `Test normalize-final-modifier=yes`() {
+        runInputOutputTest(
+            """
+                package test.pkg {
+                  public final class Final {
+                    method public final void foo();
+                  }
+                  public class NotFinal {
+                    method public final void foo();
+                  }
+                }
+            """,
+            FileFormat.V2.copy(specifiedNormalizeFinalModifier = true),
+            expectedOutput =
+                """
+                    package test.pkg {
+                      public final class Final {
+                        method public void foo();
+                      }
+                      public class NotFinal {
+                        method public final void foo();
+                      }
+                    }
+                """,
+        )
+    }
+
+    @Test
+    fun `Test normalize-final-modifier=no`() {
+        runInputOutputTest(
+            """
+                package test.pkg {
+                  public final class Final {
+                    method public final void foo();
+                  }
+                  public class NotFinal {
+                    method public final void foo();
+                  }
+                }
+            """,
+            FileFormat.V2.copy(specifiedNormalizeFinalModifier = false),
+        )
+    }
+
     /**
      * Make sure that despite the `java.lang.` prefix being stripped from various types when writing
      * the signature file that they have the correct type when the [Codebase] is loaded.
@@ -610,7 +693,7 @@ class SignatureInputOutputTest : Assertions {
             """
                 // Signature format: 2.0
                 package test.pkg {
-                  public class Foo extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
+                  public class Foo<T extends java.util.Map<java.lang.Integer, java.lang.String>> extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
                     method public java.lang.String foo(java.lang.String...) throws java.lang.Exception;
                   }
                 }
@@ -630,7 +713,7 @@ class SignatureInputOutputTest : Assertions {
             """
                 // Signature format: 2.0
                 package test.pkg {
-                  public class Foo extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
+                  public class Foo<T extends java.util.Map<java.lang.Integer, java.lang.String>> extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
                     method public String foo(java.lang.String...) throws java.lang.Exception;
                   }
                 }
@@ -650,7 +733,7 @@ class SignatureInputOutputTest : Assertions {
             """
                 // Signature format: 2.0
                 package test.pkg {
-                  public abstract class Foo extends java.util.AbstractList<String> implements Comparable<String> kotlin.collections.List<String> {
+                  public abstract class Foo<T extends java.util.Map<Integer, String>> extends java.util.AbstractList<String> implements Comparable<String> kotlin.collections.List<String> {
                     method public String foo(String...) throws Exception;
                   }
                 }
@@ -664,6 +747,104 @@ class SignatureInputOutputTest : Assertions {
         }
     }
 
+    @Test
+    fun `Test type-argument-spacing=none`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo<T extends java.util.Map<Integer,String>> extends java.util.Map<String,Integer> {
+                    method public java.util.Map<String,String> foo(java.util.Map<Integer,Integer>);
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(
+                specifiedTypeArgumentSpacing = TypeArgumentSpacing.NONE,
+                // Strip java.lang. prefix to make test less verbose.
+                specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+            ),
+        )
+    }
+
+    @Test
+    fun `Test type-argument-spacing=legacy`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo<T extends java.util.Map<Integer, String>> extends java.util.Map<String,Integer> {
+                    method public java.util.Map<String,String> foo(java.util.Map<Integer,Integer>);
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(
+                specifiedTypeArgumentSpacing = TypeArgumentSpacing.LEGACY,
+                // Strip java.lang. prefix to make test less verbose.
+                specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+            ),
+        )
+    }
+
+    @Test
+    fun `Test type-argument-spacing=space`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo<T extends java.util.Map<Integer, String>> extends java.util.Map<String, Integer> {
+                    method public java.util.Map<String, String> foo(java.util.Map<Integer, Integer>);
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(
+                specifiedTypeArgumentSpacing = TypeArgumentSpacing.SPACE,
+                // Strip java.lang. prefix to make test less verbose.
+                specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+            ),
+        )
+    }
+
+    @Test
+    fun `Check order of SuppressCompatibility annotation`() {
+        val api =
+            """
+                // Signature format: 5.0
+                package test.pkg {
+                  @SuppressCompatibility @kotlin.RequiresOptIn @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public @interface ExperimentalBar {
+                  }
+                  @SuppressCompatibility @test.pkg.ExperimentalBar public final class FancyBar {
+                    ctor public FancyBar();
+                    method @SuppressCompatibility @ReturnThis public test.pkg.FancyBar fancy(@SuppressCompatibility int);
+                  }
+                }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
+    @Test
+    fun `Check loading signature file with duplicate method signatures`() {
+        val api =
+            """
+                // Signature format: 5.0
+                package test.pkg {
+                  public class Foo {
+                    method public void method(int);
+                    method public void method(int);
+                  }
+                }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
     companion object {
         private val kotlinStyleFormat =
             FileFormat.V5.copy(kotlinNameTypeOrder = true, formatDefaults = FileFormat.V5)
diff --git a/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureWriterTest.kt
similarity index 92%
rename from metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt
rename to metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureWriterTest.kt
index 538df1bb2..9c84ce0f4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureWriterTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,8 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.text
 
-import com.android.tools.metalava.model.text.FileFormat
 import java.io.PrintWriter
 import java.io.StringWriter
 import kotlin.test.assertEquals
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SnapshotDeltaMakerTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SnapshotDeltaMakerTest.kt
new file mode 100644
index 000000000..a43967392
--- /dev/null
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SnapshotDeltaMakerTest.kt
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.snapshot.NonFilteringDelegatingVisitor
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
+import java.io.PrintWriter
+import java.io.StringWriter
+import kotlin.test.assertEquals
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/**
+ * Tests [SnapshotDeltaMaker] by round tripping base, extends and combined signature files.
+ *
+ * This also tests [ApiFile]s ability to combine base and extends signature files.
+ */
+class SnapshotDeltaMakerTest : BaseTextCodebaseTest() {
+
+    @Parameterized.Parameter(0) lateinit var testData: TestParams
+
+    data class TestParams(
+        val name: String,
+        val baseSignature: String,
+        val extendsSignature: String,
+        val combinedSignature: String,
+    ) {
+        override fun toString(): String {
+            return name
+        }
+    }
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters
+        fun params() =
+            listOf(
+                TestParams(
+                    name = "class",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Extends {
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                              }
+                              public class Extends {
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "class - super class type",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class BaseSuper {
+                              }
+                              public class Foo extends test.pkg.BaseSuper {
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class ExtendsSuper extends test.pkg.BaseSuper {
+                              }
+                              public class Foo extends test.pkg.ExtendsSuper {
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class BaseSuper {
+                              }
+                              public class ExtendsSuper extends test.pkg.BaseSuper {
+                              }
+                              public class Foo extends test.pkg.ExtendsSuper {
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "class - different annotations",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public @interface BaseAnnotation {
+                              }
+                              @test.pkg.BaseAnnotation public class Foo {
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public @interface ExtendsAnnotation {
+                              }
+                              @test.pkg.BaseAnnotation @test.pkg.ExtendsAnnotation public class Foo {
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public @interface BaseAnnotation {
+                              }
+                              public @interface ExtendsAnnotation {
+                              }
+                              @test.pkg.BaseAnnotation @test.pkg.ExtendsAnnotation public class Foo {
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "constructors",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                ctor public Base();
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                ctor public Base(int);
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                ctor public Base();
+                                ctor public Base(int);
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "methods",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                method public void baseMethod();
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                method public void extendsMethod();
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                method public void baseMethod();
+                                method public void extendsMethod();
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "properties",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                property public int baseProperty;
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                property public int extendsProperty;
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                property public int baseProperty;
+                                property public int extendsProperty;
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "fields",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                field public int baseField;
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                field public int extendsField;
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                field public int baseField;
+                                field public int extendsField;
+                              }
+                            }
+                        """,
+                ),
+                TestParams(
+                    name = "nested",
+                    baseSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                              }
+                            }
+                        """,
+                    extendsSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base.Nested {
+                              }
+                            }
+                        """,
+                    combinedSignature =
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                              }
+                              public class Base.Nested {
+                              }
+                            }
+                        """,
+                ),
+            )
+    }
+
+    private fun Codebase.assertSignatureFile(expected: String, message: String? = null) {
+        val trimmedExpected = expected.trimIndent()
+        val output = writeSignatureFile(this)
+
+        assertEquals(trimmedExpected, output, message)
+    }
+
+    private fun writeSignatureFile(deltaCodebase: Codebase): String {
+        val stringWriter = StringWriter()
+        PrintWriter(stringWriter).use { printWriter ->
+            val fileFormat = FileFormat.V2
+            val signatureWriter =
+                SignatureWriter(
+                    writer = printWriter,
+                    fileFormat = fileFormat,
+                )
+            val visitor =
+                createFilteringVisitorForSignatures(
+                    signatureWriter,
+                    fileFormat,
+                    ApiType.ALL,
+                    preFiltered = true,
+                    showUnannotated = true,
+                    apiPredicateConfig = ApiPredicate.Config()
+                )
+            deltaCodebase.accept(visitor)
+        }
+        val output = stringWriter.toString().replace("\n\n", "\n").trimEnd()
+        return output
+    }
+
+    /**
+     * Check that merging [TestParams.baseSignature] and [TestParams.extendsSignature] together will
+     * result in [TestParams.combinedSignature].
+     */
+    private fun checkMergedCodebase(baseFile: SignatureFile) {
+        val extendsFile =
+            SignatureFile.fromText("extends.txt", contents = testData.extendsSignature)
+        val mergedCodebase = ApiFile.parseApi(listOf(baseFile, extendsFile))
+        mergedCodebase.assertSignatureFile(
+            expected = testData.combinedSignature,
+            message = "merged signature"
+        )
+    }
+
+    /**
+     * Check that computing the delta between [TestParams.baseSignature] and
+     * [TestParams.combinedSignature] will result in [TestParams.extendsSignature].
+     */
+    private fun checkDeltaCodebase(baseFile: SignatureFile) {
+        val baseCodebase = ApiFile.parseApi(listOf(baseFile))
+        val combinedCodebase =
+            ApiFile.parseApi(
+                listOf(
+                    SignatureFile.fromText("combined.txt", contents = testData.combinedSignature)
+                )
+            )
+        val deltaCodebase =
+            SnapshotDeltaMaker.createDelta(
+                    baseCodebase,
+                    CodebaseFragment.create(combinedCodebase, ::NonFilteringDelegatingVisitor)
+                )
+                .codebase
+        deltaCodebase.assertSignatureFile(
+            expected = testData.extendsSignature,
+            message = "delta signature"
+        )
+    }
+
+    @Test
+    fun `Round trip`() {
+        val baseFile = SignatureFile.fromText("base.txt", contents = testData.baseSignature)
+        checkMergedCodebase(baseFile)
+
+        checkDeltaCodebase(baseFile)
+    }
+}
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
index 61432ef7e..93e7a609a 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
@@ -316,7 +316,8 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
     fun `Test caching of generic type arguments`() {
         runTextTypeParserTest {
             val first = parser.obtainTypeFromString("Number", emptyScope)
-            val second = parser.obtainTypeFromString("List<Number>", emptyScope) as ClassTypeItem
+            val second =
+                parser.obtainTypeFromString("java.util.List<Number>", emptyScope) as ClassTypeItem
 
             assertThat(second.arguments[0]).isSameInstanceAs(first)
         }
@@ -327,7 +328,8 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
         runTextTypeParserTest {
             val first = parser.obtainTypeFromString("Number", emptyScope)
             val second =
-                parser.obtainTypeFromString("List<? extends Number>", emptyScope) as ClassTypeItem
+                parser.obtainTypeFromString("java.util.List<? extends Number>", emptyScope)
+                    as ClassTypeItem
 
             assertThat((second.arguments[0] as WildcardTypeItem).extendsBound)
                 .isSameInstanceAs(first)
@@ -339,7 +341,8 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
         runTextTypeParserTest {
             val first = parser.obtainTypeFromString("Number", emptyScope)
             val second =
-                parser.obtainTypeFromString("List<? super Number>", emptyScope) as ClassTypeItem
+                parser.obtainTypeFromString("java.util.List<? super Number>", emptyScope)
+                    as ClassTypeItem
 
             assertThat((second.arguments[0] as WildcardTypeItem).superBound).isSameInstanceAs(first)
         }
diff --git a/metalava-model-text/src/test/resources/model-test-suite-baseline.txt b/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
index 14077fc83..9ebac1b0d 100644
--- a/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
@@ -16,3 +16,83 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonIsAssignableFromTest
 
 com.android.tools.metalava.model.testsuite.typeitem.CommonTypeParameterItemTest
   Test type parameter with annotations
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
+  testLegacySource[source,String using constant]
+  testLegacySource[source,annotation]
+  testLegacySource[source,char escaped]
+  testLegacySource[source,char unicode]
+  testLegacySource[source,char]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double negative infinity]
+  testLegacySource[source,double positive infinity]
+  testLegacySource[source,double with exponent]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float negative infinity]
+  testLegacySource[source,float positive infinity]
+  testLegacySource[source,float with exponent]
+  testLegacySource[source,float with upper F]
+  testLegacySource[source,int negative]
+  testLegacySource[source,int positive]
+  testLegacySource[source,long with lower l]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
+  testLegacySource[source,String array]
+  testLegacySource[source,String using constant]
+  testLegacySource[source,annotation]
+  testLegacySource[source,char escaped]
+  testLegacySource[source,char unicode]
+  testLegacySource[source,char]
+  testLegacySource[source,class array literal]
+  testLegacySource[source,class void wrapper class]
+  testLegacySource[source,class]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double negative infinity]
+  testLegacySource[source,double positive infinity]
+  testLegacySource[source,double with exponent]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float negative infinity]
+  testLegacySource[source,float positive infinity]
+  testLegacySource[source,float with exponent]
+  testLegacySource[source,float with upper F]
+  testLegacySource[source,int positive]
+  testLegacySource[source,long with lower l]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
+  testLegacySource[source,annotation]
+  testLegacySource[source,char escaped]
+  testLegacySource[source,char unicode]
+  testLegacySource[source,char]
+  testLegacySource[source,enum]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
+  testLegacySource[source,String using constant]
+  testLegacySource[source,class array literal]
+  testLegacySource[source,class int array literal]
+  testLegacySource[source,class void primitive class]
+  testLegacySource[source,class void wrapper class]
+  testLegacySource[source,class]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double negative infinity]
+  testLegacySource[source,double positive infinity]
+  testLegacySource[source,enum]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float negative infinity]
+  testLegacySource[source,float positive infinity]
+  testLegacySource[source,long with int]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
+  testLegacySource[source,String using constant]
+  testLegacySource[source,class array literal]
+  testLegacySource[source,class int array literal]
+  testLegacySource[source,class void primitive class]
+  testLegacySource[source,class void wrapper class]
+  testLegacySource[source,class]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double negative infinity]
+  testLegacySource[source,double positive infinity]
+  testLegacySource[source,enum]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float negative infinity]
+  testLegacySource[source,float positive infinity]
+  testLegacySource[source,long with int]
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
index 6f39a2058..8812f7a8f 100644
--- a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
@@ -21,17 +21,19 @@ package com.android.tools.metalava.model.text
 private val FILE_FORMAT_PROPERTY_NAMES =
     listOf(
         "add-additional-overrides",
-        "concise-default-values",
+        "include-default-parameter-values",
         "include-type-use-annotations",
         "kotlin-name-type-order",
         "kotlin-style-nulls",
         "language",
         "migrating",
         "name",
+        "normalize-final-modifier",
         "overloaded-method-order",
         "sort-whole-extends-list",
         "strip-java-lang-prefix",
         "surface",
+        "type-argument-spacing",
     )
 
 val FILE_FORMAT_PROPERTIES = FILE_FORMAT_PROPERTY_NAMES.joinToString { "'$it'" }
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/SignatureFixtures.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/SignatureFixtures.kt
new file mode 100644
index 000000000..939cce98a
--- /dev/null
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/SignatureFixtures.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import java.io.File
+import kotlin.test.assertEquals
+
+/**
+ * Assert that the file contents match the [expectedContents].
+ *
+ * See [String.assertSignatureContents] for how the comparison is performed.
+ */
+fun File.assertSignatureContents(expectedContents: String, message: String? = null) {
+    readText().assertSignatureContents(expectedContents, message)
+}
+
+/**
+ * Assert that the string contents match the [expectedContents].
+ *
+ * This has blank lines removed and the trailing new line removed and [expectedContents] has
+ * [String.trimIndent] called on before comparing.
+ */
+fun String.assertSignatureContents(expectedContents: String, message: String? = null) {
+    val contents = replace("\n\n", "\n").trimEnd()
+    val expected = expectedContents.trimIndent()
+    assertEquals(expected, contents, message)
+}
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
index f87bec814..3cf1750c2 100644
--- a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
@@ -47,15 +47,16 @@ class TextModelSuiteRunner : ModelSuiteRunner {
         inputs: ModelSuiteRunner.TestInputs,
         test: (Codebase) -> Unit
     ) {
-        if (inputs.commonSourceDir != null) {
-            error("text model does not support common sources")
+        if (inputs.projectDescription != null) {
+            error("text model does not support project description")
         }
 
         val testFixture = inputs.testFixture
         val codebaseConfig = testFixture.codebaseConfig
 
         val signatureFiles = SignatureFile.forTest(inputs.mainSourceDir.createFiles())
-        val resolver = ClassLoaderBasedClassResolver(getAndroidJar(), codebaseConfig)
+        val classPath = listOf(getAndroidJar()) + inputs.testFixture.additionalClassPath
+        val resolver = ClassLoaderBasedClassResolver(classPath, codebaseConfig)
         val codebase =
             ApiFile.parseApi(
                 signatureFiles,
@@ -85,15 +86,16 @@ class TextModelSuiteRunner : ModelSuiteRunner {
  * change in the future.
  */
 class ClassLoaderBasedClassResolver(
-    jar: File,
+    jars: List<File>,
     codebaseConfig: Codebase.Config = Codebase.Config.NOOP,
 ) : ClassResolver {
 
     private val assembler by
         lazy(LazyThreadSafetyMode.NONE) {
+            val location = jars.first()
             TextCodebaseAssembler.createAssembler(
-                location = jar,
-                description = "Codebase for resolving classes in $jar for tests",
+                location = location,
+                description = "Codebase for resolving classes in $location for tests",
                 codebaseConfig = codebaseConfig,
                 classResolver = null,
             )
@@ -102,7 +104,10 @@ class ClassLoaderBasedClassResolver(
     private val codebase by lazy(LazyThreadSafetyMode.NONE) { assembler.codebase }
 
     private val classLoader by
-        lazy(LazyThreadSafetyMode.NONE) { URLClassLoader(arrayOf(jar.toURI().toURL()), null) }
+        lazy(LazyThreadSafetyMode.NONE) {
+            val urls = jars.map { it.toURI().toURL() }.toTypedArray()
+            URLClassLoader(urls, null)
+        }
 
     private fun findClassInClassLoader(qualifiedName: String): Class<*>? {
         var binaryName = qualifiedName
diff --git a/metalava-model-turbine/Android.bp b/metalava-model-turbine/Android.bp
index 30f48d49d..9153e9ac1 100644
--- a/metalava-model-turbine/Android.bp
+++ b/metalava-model-turbine/Android.bp
@@ -23,6 +23,7 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     java_resource_dirs: ["src/main/resources/"],
     libs: [
         "metalava-model",
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt
new file mode 100644
index 000000000..35d5204e7
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationAttributeValue
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
+import com.android.tools.metalava.model.DefaultAnnotationAttribute
+import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
+import com.android.tools.metalava.reporter.FileLocation
+import com.google.common.collect.ImmutableList
+import com.google.common.collect.ImmutableMap
+import com.google.turbine.model.Const
+import com.google.turbine.model.Const.ArrayInitValue
+import com.google.turbine.model.Const.Kind
+import com.google.turbine.tree.Tree
+import com.google.turbine.tree.Tree.ArrayInit
+import com.google.turbine.tree.Tree.Assign
+import com.google.turbine.tree.Tree.Expression
+import com.google.turbine.tree.Tree.Literal
+import com.google.turbine.type.AnnoInfo
+
+/**
+ * Factory for creating [AnnotationItem]s from [AnnoInfo]s.
+ *
+ * @param codebase the [Codebase] to which the [AnnotationItem] will belong.
+ * @param sourceFileCache provides mapping from [AnnoInfo.source] to location.
+ */
+internal class TurbineAnnotationFactory(
+    private val codebase: Codebase,
+    private val sourceFileCache: TurbineSourceFileCache,
+) {
+    /** Creates a list of AnnotationItems from given list of Turbine Annotations */
+    internal fun createAnnotations(annotations: List<AnnoInfo>): List<AnnotationItem> {
+        return annotations.mapNotNull { createAnnotation(it) }
+    }
+
+    /** Create an [AnnotationItem] from an [AnnoInfo]. */
+    private fun createAnnotation(annotation: AnnoInfo): AnnotationItem? {
+        // Get the source representation of the annotation. This will be null for an annotation
+        // loaded from a class file.
+        val tree: Tree.Anno? = annotation.tree()
+        // An annotation that has no definition in scope has a null sym, in that case fall back
+        // to use the name used in the source. The sym can only be null in sources, so if sym is
+        // null then tree cannot be null.
+        val qualifiedName = annotation.sym()?.qualifiedName ?: tree!!.name().dotSeparatedName
+
+        val fileLocation =
+            annotation
+                .source()
+                ?.let { sourceFile -> sourceFileCache.turbineSourceFile(sourceFile) }
+                ?.let { sourceFile -> TurbineFileLocation.forTree(sourceFile, tree) }
+                ?: FileLocation.UNKNOWN
+
+        return DefaultAnnotationItem.create(codebase, fileLocation, qualifiedName) {
+            getAnnotationAttributes(annotation.values(), tree?.args())
+        }
+    }
+
+    /** Creates a list of AnnotationAttribute from the map of name-value attribute pairs */
+    private fun getAnnotationAttributes(
+        attrs: ImmutableMap<String, Const>,
+        exprs: ImmutableList<Expression>?
+    ): List<AnnotationAttribute> {
+        val attributes = mutableListOf<AnnotationAttribute>()
+        if (exprs != null) {
+            for (exp in exprs) {
+                when (exp.kind()) {
+                    Tree.Kind.ASSIGN -> {
+                        exp as Assign
+                        val name = exp.name().value()
+                        val assignExp = exp.expr()
+                        attributes.add(
+                            DefaultAnnotationAttribute(
+                                name,
+                                createAttrValue(attrs[name]!!, assignExp)
+                            )
+                        )
+                    }
+                    else -> {
+                        val name = ANNOTATION_ATTR_VALUE
+                        val value =
+                            attrs[name]
+                                ?: (exp as? Literal)?.value()
+                                    ?: error(
+                                    "Cannot find value for default 'value' attribute from $exp"
+                                )
+                        attributes.add(
+                            DefaultAnnotationAttribute(name, createAttrValue(value, exp))
+                        )
+                    }
+                }
+            }
+        } else {
+            for ((name, value) in attrs) {
+                attributes.add(DefaultAnnotationAttribute(name, createAttrValue(value, null)))
+            }
+        }
+        return attributes
+    }
+
+    private fun createAttrValue(const: Const, expr: Expression?): AnnotationAttributeValue {
+        if (const.kind() == Kind.ARRAY) {
+            const as ArrayInitValue
+            if (const.elements().count() == 1 && expr != null && expr !is ArrayInit) {
+                // This is case where defined type is array type but provided attribute value is
+                // single non-array element
+                // For e.g. @Anno(5) where Anno is @interface Anno {int [] value()}
+                val constLiteral = const.elements().single()
+                return DefaultAnnotationSingleAttributeValue(
+                    { TurbineValue(constLiteral, expr).getSourceForAnnotationValue() },
+                    { constLiteral.underlyingValue }
+                )
+            }
+            return DefaultAnnotationArrayAttributeValue(
+                { TurbineValue(const, expr).getSourceForAnnotationValue() },
+                { const.elements().map { createAttrValue(it, null) } }
+            )
+        }
+        return DefaultAnnotationSingleAttributeValue(
+            { TurbineValue(const, expr).getSourceForAnnotationValue() },
+            { const.underlyingValue }
+        )
+    }
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt
new file mode 100644
index 000000000..ea0b6ea44
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt
@@ -0,0 +1,676 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.BoundsTypeItem
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.DefaultTypeParameterList
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.FixedFieldValue
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
+import com.android.tools.metalava.model.ModifierFlags.Companion.DEFAULT
+import com.android.tools.metalava.model.ModifierFlags.Companion.FINAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PROTECTED
+import com.android.tools.metalava.model.ModifierFlags.Companion.PUBLIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
+import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
+import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
+import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
+import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
+import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeParameterListAndFactory
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.addDefaultRetentionPolicyAnnotation
+import com.android.tools.metalava.model.createMutableModifiers
+import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
+import com.android.tools.metalava.model.item.FieldValue
+import com.android.tools.metalava.model.item.ParameterDefaultValue
+import com.android.tools.metalava.model.type.MethodFingerprint
+import com.android.tools.metalava.reporter.FileLocation
+import com.google.common.collect.ImmutableList
+import com.google.common.collect.ImmutableMap
+import com.google.turbine.binder.bound.SourceTypeBoundClass
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.binder.bound.TypeBoundClass.FieldInfo
+import com.google.turbine.binder.bound.TypeBoundClass.MethodInfo
+import com.google.turbine.binder.bound.TypeBoundClass.ParamInfo
+import com.google.turbine.binder.bound.TypeBoundClass.TyVarInfo
+import com.google.turbine.binder.sym.ClassSymbol
+import com.google.turbine.binder.sym.TyVarSymbol
+import com.google.turbine.model.TurbineFlag
+import com.google.turbine.model.TurbineTyKind
+import com.google.turbine.tree.Tree
+import com.google.turbine.tree.Tree.Anno
+import com.google.turbine.tree.Tree.AnnoExpr
+import com.google.turbine.tree.Tree.Expression
+import com.google.turbine.tree.Tree.Literal
+import com.google.turbine.tree.Tree.MethDecl
+import com.google.turbine.tree.Tree.TyDecl
+import com.google.turbine.tree.Tree.VarDecl
+import com.google.turbine.type.AnnoInfo
+import com.google.turbine.type.Type
+
+/**
+ * Responsible for creating [ClassItem]s from either source or binary [ClassSymbol] and
+ * [TypeBoundClass] pairs.
+ *
+ * @param globalContext provides access to various pieces of data that apply across all classes.
+ * @param classSymbol the unique identifier for the [TypeBoundClass].
+ * @param typeBoundClass the definition of the class as recorded by Turbine.
+ */
+internal class TurbineClassBuilder(
+    private val globalContext: TurbineGlobalContext,
+    private val classSymbol: ClassSymbol,
+    private val typeBoundClass: TypeBoundClass,
+) : TurbineGlobalContext by globalContext {
+    /** The [SourceTypeBoundClass] if this is a source class. */
+    private val sourceTypeBoundClass = typeBoundClass as? SourceTypeBoundClass
+
+    /**
+     * The [TurbineFieldResolver] used for resolving [Tree.ConstVarName] to
+     * [TypeBoundClass.FieldInfo].
+     */
+    private var fieldResolver: TurbineFieldResolver?
+
+    init {
+        if (sourceTypeBoundClass == null) {
+            // Only source classes need to resolve fields.
+            fieldResolver = null
+        } else {
+            // Source files need
+            fieldResolver = createFieldResolver(classSymbol, sourceTypeBoundClass)
+        }
+    }
+
+    /**
+     * Create a [ClassItem] for the [classSymbol]/[typeBoundClass] pair.
+     *
+     * @param containingClassItem the containing [DefaultClassItem] to which the created [ClassItem]
+     *   will belong, if any.
+     * @param enclosingClassTypeItemFactory the [TurbineTypeItemFactory] that is used to create
+     *   [TypeItem]s and tracks the in scope type parameters.
+     */
+    internal fun createClass(
+        containingClassItem: DefaultClassItem?,
+        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
+        origin: ClassOrigin,
+    ): ClassItem {
+        val decl = sourceTypeBoundClass?.decl()
+
+        // Get the package item
+        val pkgName = classSymbol.dotSeparatedPackageName
+        val pkgItem = codebase.findOrCreatePackage(pkgName)
+
+        // Create the sourcefile
+        val sourceFile =
+            if (sourceTypeBoundClass != null) {
+                sourceFileCache.turbineSourceFile(sourceTypeBoundClass.source())
+            } else null
+        val fileLocation =
+            when {
+                sourceFile != null -> TurbineFileLocation.forTree(sourceFile, decl)
+                containingClassItem != null ->
+                    TurbineFileLocation.forTree(containingClassItem, decl)
+                else -> FileLocation.UNKNOWN
+            }
+
+        // Create class
+        val qualifiedName = classSymbol.qualifiedName
+        val documentation = javadoc(decl)
+        val modifierItem =
+            createModifiers(
+                typeBoundClass.access(),
+                typeBoundClass.annotations(),
+            )
+        val (typeParameters, classTypeItemFactory) =
+            createTypeParameters(
+                typeBoundClass.typeParameterTypes(),
+                enclosingClassTypeItemFactory,
+                "class $qualifiedName",
+            )
+        val classKind = getClassKind(typeBoundClass.kind())
+
+        modifierItem.setSynchronized(false) // A class can not be synchronized in java
+
+        if (classKind == ClassKind.ANNOTATION_TYPE) {
+            if (!modifierItem.hasAnnotation(AnnotationItem::isRetention)) {
+                modifierItem.addDefaultRetentionPolicyAnnotation(codebase, isKotlin = false)
+            }
+        }
+
+        // Set up the SuperClass
+        val superClassType =
+            when (classKind) {
+                // Normal classes and enums have a non-null super class type.
+                ClassKind.CLASS,
+                ClassKind.ENUM ->
+                    typeBoundClass.superClassType()?.let {
+                        classTypeItemFactory.getSuperClassType(it)
+                    }
+                // Interfaces and annotations (which are a form of interface) do not.
+                ClassKind.INTERFACE,
+                ClassKind.ANNOTATION_TYPE -> null
+            }
+
+        // Set interface types
+        val interfaceTypes =
+            typeBoundClass.interfaceTypes().map { classTypeItemFactory.getInterfaceType(it) }
+
+        val classItem =
+            itemFactory.createClassItem(
+                fileLocation = fileLocation,
+                modifiers = modifierItem,
+                documentationFactory = getCommentedDoc(documentation),
+                source = sourceFile,
+                classKind = classKind,
+                containingClass = containingClassItem,
+                containingPackage = pkgItem,
+                qualifiedName = qualifiedName,
+                typeParameterList = typeParameters,
+                origin = origin,
+                superClassType = superClassType,
+                interfaceTypes = interfaceTypes,
+            )
+
+        // Create fields
+        createFields(classItem, typeBoundClass.fields(), classTypeItemFactory)
+
+        // Create methods
+        createMethods(classItem, typeBoundClass.methods(), classTypeItemFactory)
+
+        // Create constructors
+        createConstructors(classItem, typeBoundClass.methods(), classTypeItemFactory)
+
+        // Create InnerClasses.
+        val children = typeBoundClass.children()
+        createNestedClasses(classItem, children.values.asList(), classTypeItemFactory)
+
+        return classItem
+    }
+
+    private fun createModifiers(flag: Int, annoInfos: List<AnnoInfo>): MutableModifierList {
+        val annotations = annotationFactory.createAnnotations(annoInfos)
+        val modifierItem =
+            when (flag) {
+                0 -> { // No Modifier. Default modifier is PACKAGE_PRIVATE in such case
+                    createMutableModifiers(
+                        visibility = VisibilityLevel.PACKAGE_PRIVATE,
+                        annotations = annotations,
+                    )
+                }
+                else -> {
+                    createMutableModifiers(computeFlag(flag), annotations)
+                }
+            }
+        modifierItem.setDeprecated(isDeprecated(annotations))
+        return modifierItem
+    }
+
+    /**
+     * Given flag value corresponding to Turbine modifiers compute the equivalent flag in Metalava.
+     */
+    private fun computeFlag(flag: Int): Int {
+        // If no visibility flag is provided, result remains 0, implying a 'package-private' default
+        // state.
+        var result = 0
+
+        if (flag and TurbineFlag.ACC_STATIC != 0) {
+            result = result or STATIC
+        }
+        if (flag and TurbineFlag.ACC_ABSTRACT != 0) {
+            result = result or ABSTRACT
+        }
+        if (flag and TurbineFlag.ACC_FINAL != 0) {
+            result = result or FINAL
+        }
+        if (flag and TurbineFlag.ACC_NATIVE != 0) {
+            result = result or NATIVE
+        }
+        if (flag and TurbineFlag.ACC_SYNCHRONIZED != 0) {
+            result = result or SYNCHRONIZED
+        }
+        if (flag and TurbineFlag.ACC_STRICT != 0) {
+            result = result or STRICT_FP
+        }
+        if (flag and TurbineFlag.ACC_TRANSIENT != 0) {
+            result = result or TRANSIENT
+        }
+        if (flag and TurbineFlag.ACC_VOLATILE != 0) {
+            result = result or VOLATILE
+        }
+        if (flag and TurbineFlag.ACC_DEFAULT != 0) {
+            result = result or DEFAULT
+        }
+        if (flag and TurbineFlag.ACC_SEALED != 0) {
+            result = result or SEALED
+        }
+        if (flag and TurbineFlag.ACC_VARARGS != 0) {
+            result = result or VARARG
+        }
+
+        // Visibility Modifiers
+        if (flag and TurbineFlag.ACC_PUBLIC != 0) {
+            result = result or PUBLIC
+        }
+        if (flag and TurbineFlag.ACC_PRIVATE != 0) {
+            result = result or PRIVATE
+        }
+        if (flag and TurbineFlag.ACC_PROTECTED != 0) {
+            result = result or PROTECTED
+        }
+
+        return result
+    }
+
+    private fun isDeprecated(annotations: List<AnnotationItem>?): Boolean {
+        return annotations?.any { it.qualifiedName == "java.lang.Deprecated" } ?: false
+    }
+
+    private fun getClassKind(type: TurbineTyKind): ClassKind {
+        return when (type) {
+            TurbineTyKind.INTERFACE -> ClassKind.INTERFACE
+            TurbineTyKind.ENUM -> ClassKind.ENUM
+            TurbineTyKind.ANNOTATION -> ClassKind.ANNOTATION_TYPE
+            else -> ClassKind.CLASS
+        }
+    }
+
+    private fun createTypeParameters(
+        tyParams: ImmutableMap<TyVarSymbol, TyVarInfo>,
+        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
+        description: String,
+    ): TypeParameterListAndFactory<TurbineTypeItemFactory> {
+
+        if (tyParams.isEmpty())
+            return TypeParameterListAndFactory(
+                TypeParameterList.NONE,
+                enclosingClassTypeItemFactory
+            )
+
+        // Create a list of [TypeParameterItem]s from turbine specific classes.
+        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+            enclosingClassTypeItemFactory,
+            description,
+            tyParams.toList(),
+            { (sym, tyParam) -> createTypeParameter(sym, tyParam) },
+            { typeItemFactory, (_, tParam) -> createTypeParameterBounds(tParam, typeItemFactory) },
+        )
+    }
+
+    /**
+     * Create the [DefaultTypeParameterItem] without any bounds and register it so that any uses of
+     * it within the type bounds, e.g. `<E extends Enum<E>>`, or from other type parameters within
+     * the same [TypeParameterList] can be resolved.
+     */
+    private fun createTypeParameter(sym: TyVarSymbol, param: TyVarInfo): DefaultTypeParameterItem {
+        val modifiers = createModifiers(0, param.annotations())
+        val typeParamItem =
+            itemFactory.createTypeParameterItem(
+                modifiers,
+                name = sym.name(),
+                // Java does not supports reified generics
+                isReified = false,
+            )
+        return typeParamItem
+    }
+
+    /** Create the bounds of a [DefaultTypeParameterItem]. */
+    private fun createTypeParameterBounds(
+        param: TyVarInfo,
+        typeItemFactory: TurbineTypeItemFactory,
+    ): List<BoundsTypeItem> {
+        val typeBounds = mutableListOf<BoundsTypeItem>()
+        val upperBounds = param.upperBound()
+
+        upperBounds.bounds().mapTo(typeBounds) { typeItemFactory.getBoundsType(it) }
+        param.lowerBound()?.let { typeBounds.add(typeItemFactory.getBoundsType(it)) }
+
+        return typeBounds.toList()
+    }
+
+    /** This method sets up the nested class hierarchy. */
+    private fun createNestedClasses(
+        classItem: DefaultClassItem,
+        nestedClasses: ImmutableList<ClassSymbol>,
+        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
+    ) {
+        for (nestedClassSymbol in nestedClasses) {
+            val nestedTypeBoundClass = typeBoundClassForSymbol(nestedClassSymbol)
+            val nestedClassBuilder =
+                TurbineClassBuilder(
+                    globalContext = globalContext,
+                    classSymbol = nestedClassSymbol,
+                    typeBoundClass = nestedTypeBoundClass,
+                )
+            nestedClassBuilder.createClass(
+                containingClassItem = classItem,
+                enclosingClassTypeItemFactory = enclosingClassTypeItemFactory,
+                origin = classItem.origin,
+            )
+        }
+    }
+
+    /** This method creates and sets the fields of a class */
+    private fun createFields(
+        classItem: DefaultClassItem,
+        fields: ImmutableList<FieldInfo>,
+        typeItemFactory: TurbineTypeItemFactory,
+    ) {
+        for (field in fields) {
+            val flags = field.access()
+            val decl = field.decl()
+            val fieldModifierItem =
+                createModifiers(
+                    flags,
+                    field.annotations(),
+                )
+            val isEnumConstant = (flags and TurbineFlag.ACC_ENUM) != 0
+            val fieldValue = createInitialValue(field)
+            val type =
+                typeItemFactory.getFieldType(
+                    underlyingType = field.type(),
+                    itemAnnotations = fieldModifierItem.annotations(),
+                    isEnumConstant = isEnumConstant,
+                    isFinal = fieldModifierItem.isFinal(),
+                    isInitialValueNonNull = {
+                        // The initial value is non-null if the value is a literal which is not
+                        // null.
+                        fieldValue.initialValue(false) != null
+                    }
+                )
+
+            val documentation = javadoc(decl)
+            val fieldItem =
+                itemFactory.createFieldItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = fieldModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    name = field.name(),
+                    containingClass = classItem,
+                    type = type,
+                    isEnumConstant = isEnumConstant,
+                    fieldValue = fieldValue,
+                )
+
+            classItem.addField(fieldItem)
+        }
+    }
+
+    private fun createMethods(
+        classItem: DefaultClassItem,
+        methods: List<MethodInfo>,
+        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
+    ) {
+        for (method in methods) {
+            // Ignore constructors.
+            if (method.sym().name() == "<init>") continue
+
+            val decl: MethDecl? = method.decl()
+            val methodModifierItem =
+                createModifiers(
+                    method.access(),
+                    method.annotations(),
+                )
+            val name = method.name()
+            val (typeParams, methodTypeItemFactory) =
+                createTypeParameters(
+                    method.tyParams(),
+                    enclosingClassTypeItemFactory,
+                    name,
+                )
+            val documentation = javadoc(decl)
+            val defaultValueExpr = getAnnotationDefaultExpression(method)
+            val defaultValue =
+                method.defaultValue()?.let { defaultConst ->
+                    TurbineValue(defaultConst, defaultValueExpr, fieldResolver)
+                        .getSourceForMethodDefault()
+                }
+                    ?: ""
+
+            val parameters = method.parameters()
+            val fingerprint = MethodFingerprint(name, parameters.size)
+            val isAnnotationElement = classItem.isAnnotationType() && !methodModifierItem.isStatic()
+            val returnType =
+                methodTypeItemFactory.getMethodReturnType(
+                    underlyingReturnType = method.returnType(),
+                    itemAnnotations = methodModifierItem.annotations(),
+                    fingerprint = fingerprint,
+                    isAnnotationElement = isAnnotationElement,
+                )
+
+            val methodItem =
+                itemFactory.createMethodItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = methodModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    name = name,
+                    containingClass = classItem,
+                    typeParameterList = typeParams,
+                    returnType = returnType,
+                    parameterItemsFactory = { containingCallable ->
+                        createParameters(
+                            containingCallable,
+                            decl?.params(),
+                            parameters,
+                            methodTypeItemFactory,
+                        )
+                    },
+                    throwsTypes = getThrowsList(method.exceptions(), methodTypeItemFactory),
+                    annotationDefault = defaultValue,
+                )
+
+            // Ignore enum synthetic methods.
+            if (methodItem.isEnumSyntheticMethod()) continue
+
+            classItem.addMethod(methodItem)
+        }
+    }
+
+    private fun createParameters(
+        containingCallable: CallableItem,
+        parameterDecls: List<VarDecl>?,
+        parameters: List<ParamInfo>,
+        typeItemFactory: TurbineTypeItemFactory,
+    ): List<ParameterItem> {
+        val fingerprint = MethodFingerprint(containingCallable.name(), parameters.size)
+        // Some parameters in [parameters] are implicit parameters that do not have a corresponding
+        // entry in the [parameterDecls] list. The number of implicit parameters is the total
+        // number of [parameters] minus the number of declared parameters [parameterDecls]. The
+        // implicit parameters are always at the beginning so the offset from the declared parameter
+        // in [parameterDecls] to the corresponding parameter in [parameters] is simply the number
+        // of the implicit parameters.
+        val declaredParameterOffset = parameters.size - (parameterDecls?.size ?: 0)
+        return parameters.mapIndexed { idx, parameter ->
+            val parameterModifierItem =
+                createModifiers(parameter.access(), parameter.annotations()).toImmutable()
+            val type =
+                typeItemFactory.getMethodParameterType(
+                    underlyingParameterType = parameter.type(),
+                    itemAnnotations = parameterModifierItem.annotations(),
+                    fingerprint = fingerprint,
+                    parameterIndex = idx,
+                    isVarArg = parameterModifierItem.isVarArg(),
+                )
+            // Get the [Tree.VarDecl] corresponding to the [ParamInfo], if available.
+            val decl =
+                if (parameterDecls != null && idx >= declaredParameterOffset)
+                    parameterDecls.get(idx - declaredParameterOffset)
+                else null
+
+            val fileLocation =
+                TurbineFileLocation.forTree(containingCallable.containingClass(), decl)
+            val parameterItem =
+                itemFactory.createParameterItem(
+                    fileLocation = fileLocation,
+                    modifiers = parameterModifierItem,
+                    name = parameter.name(),
+                    publicNameProvider = { null },
+                    containingCallable = containingCallable,
+                    parameterIndex = idx,
+                    type = type,
+                    defaultValueFactory = { ParameterDefaultValue.NONE },
+                )
+            parameterItem
+        }
+    }
+
+    private fun createConstructors(
+        classItem: DefaultClassItem,
+        methods: List<MethodInfo>,
+        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
+    ) {
+        for (constructor in methods) {
+            // Skip real methods.
+            if (constructor.sym().name() != "<init>") continue
+
+            val decl: MethDecl? = constructor.decl()
+            val constructorModifierItem =
+                createModifiers(
+                    constructor.access(),
+                    constructor.annotations(),
+                )
+            val (typeParams, constructorTypeItemFactory) =
+                createTypeParameters(
+                    constructor.tyParams(),
+                    enclosingClassTypeItemFactory,
+                    constructor.name(),
+                )
+            val isImplicitDefaultConstructor =
+                (constructor.access() and TurbineFlag.ACC_SYNTH_CTOR) != 0
+            val name = classItem.simpleName()
+            val documentation = javadoc(decl)
+            val constructorItem =
+                itemFactory.createConstructorItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = constructorModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    // Turbine's Binder gives return type of constructors as void but the
+                    // model expects it to the type of object being created. So, use the
+                    // containing [ClassItem]'s type as the constructor return type.
+                    name = name,
+                    containingClass = classItem,
+                    typeParameterList = typeParams,
+                    returnType = classItem.type(),
+                    parameterItemsFactory = { constructorItem ->
+                        createParameters(
+                            constructorItem,
+                            decl?.params(),
+                            constructor.parameters(),
+                            constructorTypeItemFactory,
+                        )
+                    },
+                    throwsTypes =
+                        getThrowsList(constructor.exceptions(), constructorTypeItemFactory),
+                    implicitConstructor = isImplicitDefaultConstructor,
+                )
+
+            classItem.addConstructor(constructorItem)
+        }
+    }
+
+    private fun javadoc(item: TyDecl?): String {
+        if (!allowReadingComments) return ""
+        return item?.javadoc() ?: ""
+    }
+
+    private fun javadoc(item: VarDecl?): String {
+        if (!allowReadingComments) return ""
+        return item?.javadoc() ?: ""
+    }
+
+    private fun javadoc(item: MethDecl?): String {
+        if (!allowReadingComments) return ""
+        return item?.javadoc() ?: ""
+    }
+
+    private fun getThrowsList(
+        throwsTypes: List<Type>,
+        enclosingTypeItemFactory: TurbineTypeItemFactory
+    ): List<ExceptionTypeItem> {
+        return throwsTypes.map { type -> enclosingTypeItemFactory.getExceptionType(type) }
+    }
+
+    private fun getCommentedDoc(doc: String): ItemDocumentationFactory {
+        return buildString {
+                if (doc != "") {
+                    append("/**")
+                    append(doc)
+                    append("*/")
+                }
+            }
+            .toItemDocumentationFactory()
+    }
+
+    private fun createInitialValue(field: FieldInfo): FieldValue {
+        val optExpr = field.decl()?.init()
+        val expr = if (optExpr != null && optExpr.isPresent()) optExpr.get() else null
+        val constantValue = field.value()?.getValue()
+
+        val initialValueWithoutRequiredConstant =
+            when {
+                constantValue != null -> constantValue
+                expr == null -> null
+                else ->
+                    when (expr.kind()) {
+                        Tree.Kind.LITERAL -> {
+                            (expr as Literal).value().underlyingValue
+                        }
+                        // Class Type
+                        Tree.Kind.CLASS_LITERAL -> {
+                            expr
+                        }
+                        else -> {
+                            null
+                        }
+                    }
+            }
+
+        return FixedFieldValue(constantValue, initialValueWithoutRequiredConstant)
+    }
+
+    /**
+     * Extracts the expression corresponding to the default value of a given annotation method. If
+     * the method does not have a default value, returns null.
+     */
+    private fun getAnnotationDefaultExpression(method: MethodInfo) =
+        method.decl()?.defaultValue()?.orElse(null)?.let { defaultTree ->
+
+            // Turbine stores the default value as a Tree not an Expression so that it can use an
+            // Anno class (which is not an Expression). It could wrap the Anno in an AnnoExpr but
+            // does not, presumably as an optimization. However, this does wrap it in an AnnoExpr
+            // as it allows for more consistent handling.
+            when (defaultTree) {
+                is Expression -> defaultTree
+                is Anno -> AnnoExpr(defaultTree.position(), defaultTree)
+                else -> error("unknown default value type (${defaultTree.javaClass}: $defaultTree")
+            }
+        }
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
index e3566e5ea..c5dcaa25f 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
@@ -16,66 +16,26 @@
 
 package com.android.tools.metalava.model.turbine
 
-import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
-import com.android.tools.metalava.model.AnnotationAttribute
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ApiVariantSelectors
-import com.android.tools.metalava.model.BoundsTypeItem
-import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassOrigin
-import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
-import com.android.tools.metalava.model.DefaultTypeParameterList
-import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.FixedFieldValue
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
-import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
-import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
-import com.android.tools.metalava.model.ModifierFlags.Companion.DEFAULT
-import com.android.tools.metalava.model.ModifierFlags.Companion.FINAL
-import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
-import com.android.tools.metalava.model.ModifierFlags.Companion.PRIVATE
-import com.android.tools.metalava.model.ModifierFlags.Companion.PROTECTED
-import com.android.tools.metalava.model.ModifierFlags.Companion.PUBLIC
-import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
-import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
-import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
-import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
-import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
-import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
-import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
-import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.PackageFilter
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.android.tools.metalava.model.TypeParameterScope
 import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.addDefaultRetentionPolicyAnnotation
 import com.android.tools.metalava.model.createImmutableModifiers
-import com.android.tools.metalava.model.createMutableModifiers
-import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
 import com.android.tools.metalava.model.item.DefaultCodebaseFactory
 import com.android.tools.metalava.model.item.DefaultItemFactory
 import com.android.tools.metalava.model.item.DefaultPackageItem
-import com.android.tools.metalava.model.item.DefaultTypeParameterItem
-import com.android.tools.metalava.model.item.FieldValue
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.source.utils.gatherPackageJavadoc
-import com.android.tools.metalava.model.type.MethodFingerprint
 import com.android.tools.metalava.reporter.FileLocation
 import com.google.common.collect.ImmutableList
 import com.google.common.collect.ImmutableMap
@@ -83,45 +43,23 @@ import com.google.turbine.binder.Binder
 import com.google.turbine.binder.Binder.BindingResult
 import com.google.turbine.binder.ClassPathBinder
 import com.google.turbine.binder.Processing.ProcessorInfo
-import com.google.turbine.binder.bound.EnumConstantValue
 import com.google.turbine.binder.bound.SourceTypeBoundClass
-import com.google.turbine.binder.bound.TurbineClassValue
 import com.google.turbine.binder.bound.TypeBoundClass
-import com.google.turbine.binder.bound.TypeBoundClass.FieldInfo
-import com.google.turbine.binder.bound.TypeBoundClass.MethodInfo
-import com.google.turbine.binder.bound.TypeBoundClass.ParamInfo
-import com.google.turbine.binder.bound.TypeBoundClass.TyVarInfo
 import com.google.turbine.binder.env.CompoundEnv
 import com.google.turbine.binder.env.SimpleEnv
 import com.google.turbine.binder.lookup.LookupKey
 import com.google.turbine.binder.lookup.TopLevelIndex
 import com.google.turbine.binder.sym.ClassSymbol
-import com.google.turbine.binder.sym.TyVarSymbol
 import com.google.turbine.diag.SourceFile
 import com.google.turbine.diag.TurbineLog
-import com.google.turbine.model.Const
-import com.google.turbine.model.Const.ArrayInitValue
-import com.google.turbine.model.Const.Kind
-import com.google.turbine.model.Const.Value
-import com.google.turbine.model.TurbineConstantTypeKind as PrimKind
 import com.google.turbine.model.TurbineFlag
-import com.google.turbine.model.TurbineTyKind
 import com.google.turbine.parse.Parser
 import com.google.turbine.processing.ModelFactory
 import com.google.turbine.processing.TurbineElements
 import com.google.turbine.processing.TurbineTypes
-import com.google.turbine.tree.Tree
-import com.google.turbine.tree.Tree.ArrayInit
-import com.google.turbine.tree.Tree.Assign
 import com.google.turbine.tree.Tree.CompUnit
-import com.google.turbine.tree.Tree.Expression
 import com.google.turbine.tree.Tree.Ident
-import com.google.turbine.tree.Tree.Literal
-import com.google.turbine.tree.Tree.MethDecl
-import com.google.turbine.tree.Tree.TyDecl
-import com.google.turbine.tree.Tree.VarDecl
 import com.google.turbine.type.AnnoInfo
-import com.google.turbine.type.Type
 import java.io.File
 import java.util.Optional
 import javax.lang.model.SourceVersion
@@ -136,10 +74,10 @@ import javax.lang.model.element.TypeElement
 internal class TurbineCodebaseInitialiser(
     codebaseFactory: DefaultCodebaseFactory,
     private val classpath: List<File>,
-    private val allowReadingComments: Boolean,
-) : DefaultCodebaseAssembler() {
+    override val allowReadingComments: Boolean,
+) : DefaultCodebaseAssembler(), TurbineGlobalContext {
 
-    internal val codebase = codebaseFactory(this)
+    override val codebase = codebaseFactory(this)
 
     /** The output from Turbine Binder */
     private lateinit var bindingResult: BindingResult
@@ -152,10 +90,14 @@ internal class TurbineCodebaseInitialiser(
 
     private lateinit var index: TopLevelIndex
 
-    /** Map between Class declaration and the corresponding source CompUnit */
-    private val classSourceMap: MutableMap<TyDecl, CompUnit> = mutableMapOf()
+    /** Caches [TurbineSourceFile] instances. */
+    override lateinit var sourceFileCache: TurbineSourceFileCache
 
-    private val globalTypeItemFactory = TurbineTypeItemFactory(this, TypeParameterScope.empty)
+    /** Factory for creating [AnnotationItem]s from [AnnoInfo]s. */
+    override lateinit var annotationFactory: TurbineAnnotationFactory
+
+    /** Global [TurbineTypeItemFactory] from which all other instances are created. */
+    private lateinit var globalTypeItemFactory: TurbineTypeItemFactory
 
     /** Creates [Item] instances for [codebase]. */
     override val itemFactory =
@@ -260,8 +202,19 @@ internal class TurbineCodebaseInitialiser(
         // provides access to code elements (packages, types, members) for analysis.
         turbineElements = TurbineElements(factory, turbineTypes)
 
-        // Split all the units into package-info.java units and normal class units.
-        val (packageInfoUnits, classUnits) = allUnits.partition { it.isPackageInfo() }
+        // Create a cache from SourceFile to the TurbineSourceFile wrapper. The latter needs the
+        // CompUnit associated with the SourceFile so pass in all the CompUnits so it can find it.
+        sourceFileCache = TurbineSourceFileCache(codebase, allUnits)
+
+        // Create a factory for creating annotations from AnnoInfo.
+        annotationFactory = TurbineAnnotationFactory(codebase, sourceFileCache)
+
+        // Create the global TurbineTypeItemFactory.
+        globalTypeItemFactory =
+            TurbineTypeItemFactory(this, annotationFactory, TypeParameterScope.empty)
+
+        // Find the package-info.java units.
+        val packageInfoUnits = allUnits.filter { it.isPackageInfo() }
 
         // Split the map from ClassSymbol to SourceTypeBoundClass into separate package-info and
         // normal classes.
@@ -286,31 +239,52 @@ internal class TurbineCodebaseInitialiser(
                 val fileLocation = FileLocation.forFile(file)
                 val comment = getHeaderComments(source).toItemDocumentationFactory()
 
-                // Create a `TurbineSourceFile` for this unit. It is not used here but is used when
-                // creating annotations below.
-                createTurbineSourceFile(unit)
-                val annotations = createAnnotations(sourceTypeBoundClass.annotations())
+                val annotations =
+                    annotationFactory.createAnnotations(sourceTypeBoundClass.annotations())
 
                 val modifiers = createImmutableModifiers(VisibilityLevel.PUBLIC, annotations)
                 MutablePackageDoc(packageName, fileLocation, modifiers, comment)
             }
 
-        // Create a mapping between all the top level classes and their containing `CompUnit` so
-        // that the latter can be looked up in createClass to create a TurbineSourceFile.
-        for (unit in classUnits) {
-            unit.decls().forEach { decl -> classSourceMap[decl] = unit }
-        }
-
         // Get the map from ClassSymbol to SourceTypeBoundClass for only those classes provided on
         // the command line as only those classes can contribute directly to the API.
         val commandLineSourceClasses =
-            allSourceClasses.filter { (_, typeBoundClass) ->
-                val unit = classSourceMap[typeBoundClass.decl()]
-                unit !in extraUnits
-            }
+            topLevelAccessibleCommandLineClasses(allSourceClasses, commandLineSources)
 
         createAllPackages(packageDocs)
-        createAllClasses(commandLineSourceClasses, apiPackages)
+        createAllCommandLineClasses(commandLineSourceClasses, apiPackages)
+    }
+
+    /**
+     * Compute the set of accessible, top level classes that were specified on the command line.
+     *
+     * @param allSourceClasses all the [SourceTypeBoundClass]s found during binding, includes those
+     *   from the source path as well as those whose containing file was provided on the command
+     *   line.
+     * @param commandLineSources the list of source [File]s provided on the command line.
+     */
+    private fun topLevelAccessibleCommandLineClasses(
+        allSourceClasses: Map<ClassSymbol, SourceTypeBoundClass>,
+        commandLineSources: List<File>
+    ): Map<ClassSymbol, SourceTypeBoundClass> {
+        // The set of paths supplied on the command line.
+        val commandLinePaths = commandLineSources.map { it.path }.toSet()
+
+        // Get the map from ClassSymbol to SourceTypeBoundClass for only the accessible, top level
+        // classes provided on the command line as only those classes (and their nested classes) can
+        // contribute directly to the API.
+        return allSourceClasses.filter { (_, sourceTypeBoundClass) ->
+            // Ignore nested classes, they will be created as part of the construction of their
+            // containing class.
+            if (sourceTypeBoundClass.owner() != null) return@filter false
+
+            // Ignore inaccessible classes.
+            if (!sourceTypeBoundClass.isAccessible) return@filter false
+
+            // Ignore classes whose paths were not specified on the command line.
+            val path = sourceTypeBoundClass.source().path()
+            path in commandLinePaths
+        }
     }
 
     /**
@@ -355,7 +329,7 @@ internal class TurbineCodebaseInitialiser(
      * then look in the class path. It is guaranteed to be found in one of those places as otherwise
      * there would be no `ClassSymbol`.
      */
-    private fun typeBoundClassForSymbol(classSymbol: ClassSymbol) = envClassMap.get(classSymbol)!!
+    override fun typeBoundClassForSymbol(classSymbol: ClassSymbol) = envClassMap.get(classSymbol)!!
 
     /**
      * Separate `package-info.java` synthetic classes from real classes.
@@ -409,33 +383,6 @@ internal class TurbineCodebaseInitialiser(
         }
     }
 
-    /** Map from file path to the [TurbineSourceFile]. */
-    private val turbineSourceFiles = mutableMapOf<String, TurbineSourceFile>()
-
-    /**
-     * Create a [TurbineSourceFile] for the specified [compUnit].
-     *
-     * This may be called multiple times for the same [compUnit] in which case it will return the
-     * same [TurbineSourceFile]. It will throw an exception if two [CompUnit]s have the same path.
-     */
-    private fun createTurbineSourceFile(compUnit: CompUnit): TurbineSourceFile {
-        val path = compUnit.source().path()
-        val existing = turbineSourceFiles[path]
-        if (existing != null && existing.compUnit != compUnit) {
-            error("duplicate source file found for $path")
-        }
-        return TurbineSourceFile(codebase, compUnit).also { turbineSourceFiles[path] = it }
-    }
-
-    /**
-     * Get the [TurbineSourceFile] for a [SourceFile], failing if it could not be found.
-     *
-     * A [TurbineSourceFile] must be created by [createTurbineSourceFile] before calling this.
-     */
-    private fun turbineSourceFile(sourceFile: SourceFile): TurbineSourceFile =
-        turbineSourceFiles[sourceFile.path()]
-            ?: error("unrecognized source file: ${sourceFile.path()}")
-
     /** Check if this is for a `package-info.java` file or not. */
     private fun CompUnit.isPackageInfo() =
         source().path().let { it == JAVA_PACKAGE_INFO || it.endsWith("/" + JAVA_PACKAGE_INFO) }
@@ -445,22 +392,12 @@ internal class TurbineCodebaseInitialiser(
         codebase.packageTracker.createInitialPackages(packageDocs)
     }
 
-    private fun createAllClasses(
+    private fun createAllCommandLineClasses(
         sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>,
         apiPackages: PackageFilter?,
     ) {
         // Iterate over all the classes in the sources.
         for ((classSymbol, sourceBoundClass) in sourceClassMap) {
-            // Ignore nested classes, they will be created when the outer class is created.
-            if (sourceBoundClass.owner() != null) {
-                continue
-            }
-
-            // Ignore inaccessible classes.
-            if (!sourceBoundClass.isAccessible) {
-                continue
-            }
-
             // If a package filter is supplied then ignore any classes that do not match it.
             if (apiPackages != null) {
                 val packageName = classSymbol.dotSeparatedPackageName
@@ -470,7 +407,7 @@ internal class TurbineCodebaseInitialiser(
             val classItem =
                 createTopLevelClassAndContents(
                     classSymbol = classSymbol,
-                    sourceBoundClass,
+                    typeBoundClass = sourceBoundClass,
                     origin = ClassOrigin.COMMAND_LINE,
                 )
             codebase.addTopLevelClassFromSource(classItem)
@@ -488,13 +425,17 @@ internal class TurbineCodebaseInitialiser(
      */
     private fun createTopLevelClassAndContents(
         classSymbol: ClassSymbol,
-        typeBoundClass: TypeBoundClass = typeBoundClassForSymbol(classSymbol),
+        typeBoundClass: TypeBoundClass,
         origin: ClassOrigin,
     ): ClassItem {
         if (!classSymbol.isTopClass) error("$classSymbol is not a top level class")
-        return createClass(
-            classSymbol = classSymbol,
-            typeBoundClass = typeBoundClass,
+        val classBuilder =
+            TurbineClassBuilder(
+                globalContext = this,
+                classSymbol = classSymbol,
+                typeBoundClass = typeBoundClass,
+            )
+        return classBuilder.createClass(
             containingClassItem = null,
             enclosingClassTypeItemFactory = globalTypeItemFactory,
             origin = origin,
@@ -513,7 +454,7 @@ internal class TurbineCodebaseInitialiser(
             // It is possible that the top level class has already been created but just did not
             // contain the requested nested class so check to make sure it exists before
             // creating it.
-            val topClassName = getQualifiedName(topClassSym.binaryName())
+            val topClassName = topClassSym.qualifiedName
             codebase.findClass(topClassName)
                 ?: let {
                     // Get the origin of the class.
@@ -541,652 +482,17 @@ internal class TurbineCodebaseInitialiser(
         return null
     }
 
-    private fun createModifiers(flag: Int, annoInfos: List<AnnoInfo>): MutableModifierList {
-        val annotations = createAnnotations(annoInfos)
-        val modifierItem =
-            when (flag) {
-                0 -> { // No Modifier. Default modifier is PACKAGE_PRIVATE in such case
-                    createMutableModifiers(
-                        visibility = VisibilityLevel.PACKAGE_PRIVATE,
-                        annotations = annotations,
-                    )
-                }
-                else -> {
-                    createMutableModifiers(computeFlag(flag), annotations)
-                }
-            }
-        modifierItem.setDeprecated(isDeprecated(annotations))
-        return modifierItem
-    }
-
-    /**
-     * Given flag value corresponding to Turbine modifiers compute the equivalent flag in Metalava.
-     */
-    private fun computeFlag(flag: Int): Int {
-        // If no visibility flag is provided, result remains 0, implying a 'package-private' default
-        // state.
-        var result = 0
-
-        if (flag and TurbineFlag.ACC_STATIC != 0) {
-            result = result or STATIC
-        }
-        if (flag and TurbineFlag.ACC_ABSTRACT != 0) {
-            result = result or ABSTRACT
-        }
-        if (flag and TurbineFlag.ACC_FINAL != 0) {
-            result = result or FINAL
-        }
-        if (flag and TurbineFlag.ACC_NATIVE != 0) {
-            result = result or NATIVE
-        }
-        if (flag and TurbineFlag.ACC_SYNCHRONIZED != 0) {
-            result = result or SYNCHRONIZED
-        }
-        if (flag and TurbineFlag.ACC_STRICT != 0) {
-            result = result or STRICT_FP
-        }
-        if (flag and TurbineFlag.ACC_TRANSIENT != 0) {
-            result = result or TRANSIENT
-        }
-        if (flag and TurbineFlag.ACC_VOLATILE != 0) {
-            result = result or VOLATILE
-        }
-        if (flag and TurbineFlag.ACC_DEFAULT != 0) {
-            result = result or DEFAULT
-        }
-        if (flag and TurbineFlag.ACC_SEALED != 0) {
-            result = result or SEALED
-        }
-        if (flag and TurbineFlag.ACC_VARARGS != 0) {
-            result = result or VARARG
-        }
-
-        // Visibility Modifiers
-        if (flag and TurbineFlag.ACC_PUBLIC != 0) {
-            result = result or PUBLIC
-        }
-        if (flag and TurbineFlag.ACC_PRIVATE != 0) {
-            result = result or PRIVATE
-        }
-        if (flag and TurbineFlag.ACC_PROTECTED != 0) {
-            result = result or PROTECTED
-        }
-
-        return result
-    }
-
-    private fun isDeprecated(annotations: List<AnnotationItem>?): Boolean {
-        return annotations?.any { it.qualifiedName == "java.lang.Deprecated" } ?: false
-    }
-
-    private val ClassSymbol.dotSeparatedPackageName
-        get() = packageName().replace('/', '.')
-
-    private fun createClass(
+    override fun createFieldResolver(
         classSymbol: ClassSymbol,
-        typeBoundClass: TypeBoundClass = typeBoundClassForSymbol(classSymbol),
-        containingClassItem: DefaultClassItem?,
-        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-        origin: ClassOrigin,
-    ): ClassItem {
-        val decl = (typeBoundClass as? SourceTypeBoundClass)?.decl()
-
-        val isTopClass = typeBoundClass.owner() == null
-
-        // Get the package item
-        val pkgName = classSymbol.dotSeparatedPackageName
-        val pkgItem = codebase.findOrCreatePackage(pkgName)
-
-        // Create the sourcefile
-        val sourceFile =
-            if (isTopClass && typeBoundClass is SourceTypeBoundClass) {
-                classSourceMap[typeBoundClass.decl()]?.let { createTurbineSourceFile(it) }
-            } else null
-        val fileLocation =
-            when {
-                sourceFile != null -> TurbineFileLocation.forTree(sourceFile, decl)
-                containingClassItem != null ->
-                    TurbineFileLocation.forTree(containingClassItem, decl)
-                else -> FileLocation.UNKNOWN
-            }
-
-        // Create class
-        val qualifiedName = getQualifiedName(classSymbol.binaryName())
-        val documentation = javadoc(decl)
-        val modifierItem =
-            createModifiers(
-                typeBoundClass.access(),
-                typeBoundClass.annotations(),
-            )
-        val (typeParameters, classTypeItemFactory) =
-            createTypeParameters(
-                typeBoundClass.typeParameterTypes(),
-                enclosingClassTypeItemFactory,
-                "class $qualifiedName",
-            )
-        val classKind = getClassKind(typeBoundClass.kind())
-
-        modifierItem.setSynchronized(false) // A class can not be synchronized in java
-
-        if (classKind == ClassKind.ANNOTATION_TYPE) {
-            if (!modifierItem.hasAnnotation(AnnotationItem::isRetention)) {
-                modifierItem.addDefaultRetentionPolicyAnnotation(codebase, isKotlin = false)
-            }
-        }
-
-        // Setup the SuperClass
-        val superClassType =
-            if (classKind != ClassKind.INTERFACE) {
-                typeBoundClass.superClassType()?.let { classTypeItemFactory.getSuperClassType(it) }
-            } else null
-
-        // Set interface types
-        val interfaceTypes =
-            typeBoundClass.interfaceTypes().map { classTypeItemFactory.getInterfaceType(it) }
-
-        val classItem =
-            itemFactory.createClassItem(
-                fileLocation = fileLocation,
-                modifiers = modifierItem,
-                documentationFactory = getCommentedDoc(documentation),
-                source = sourceFile,
-                classKind = classKind,
-                containingClass = containingClassItem,
-                containingPackage = pkgItem,
-                qualifiedName = qualifiedName,
-                typeParameterList = typeParameters,
-                origin = origin,
-                superClassType = superClassType,
-                interfaceTypes = interfaceTypes,
-            )
-
-        // Create fields
-        createFields(classItem, typeBoundClass.fields(), classTypeItemFactory)
-
-        // Create methods
-        createMethods(classItem, typeBoundClass.methods(), classTypeItemFactory)
-
-        // Create constructors
-        createConstructors(classItem, typeBoundClass.methods(), classTypeItemFactory)
-
-        // Create InnerClasses.
-        val children = typeBoundClass.children()
-        createNestedClasses(classItem, children.values.asList(), classTypeItemFactory)
-
-        return classItem
-    }
-
-    fun getClassKind(type: TurbineTyKind): ClassKind {
-        return when (type) {
-            TurbineTyKind.INTERFACE -> ClassKind.INTERFACE
-            TurbineTyKind.ENUM -> ClassKind.ENUM
-            TurbineTyKind.ANNOTATION -> ClassKind.ANNOTATION_TYPE
-            else -> ClassKind.CLASS
-        }
-    }
-
-    /** Creates a list of AnnotationItems from given list of Turbine Annotations */
-    internal fun createAnnotations(annotations: List<AnnoInfo>): List<AnnotationItem> {
-        return annotations.mapNotNull { createAnnotation(it) }
-    }
-
-    private fun createAnnotation(annotation: AnnoInfo): AnnotationItem? {
-        val tree = annotation.tree()
-        val simpleName = tree?.let { extractNameFromIdent(it.name()) }
-        val clsSym = annotation.sym()
-        val qualifiedName =
-            if (clsSym == null) simpleName!! else getQualifiedName(clsSym.binaryName())
-
-        val fileLocation =
-            annotation
-                .source()
-                ?.let { sourceFile -> turbineSourceFile(sourceFile) }
-                ?.let { sourceFile -> TurbineFileLocation.forTree(sourceFile, tree) }
-                ?: FileLocation.UNKNOWN
-
-        return DefaultAnnotationItem.create(codebase, fileLocation, qualifiedName) {
-            getAnnotationAttributes(annotation.values(), tree?.args())
-        }
-    }
-
-    /** Creates a list of AnnotationAttribute from the map of name-value attribute pairs */
-    private fun getAnnotationAttributes(
-        attrs: ImmutableMap<String, Const>,
-        exprs: ImmutableList<Expression>?
-    ): List<AnnotationAttribute> {
-        val attributes = mutableListOf<AnnotationAttribute>()
-        if (exprs != null) {
-            for (exp in exprs) {
-                when (exp.kind()) {
-                    Tree.Kind.ASSIGN -> {
-                        exp as Assign
-                        val name = exp.name().value()
-                        val assignExp = exp.expr()
-                        attributes.add(
-                            DefaultAnnotationAttribute(
-                                name,
-                                createAttrValue(attrs[name]!!, assignExp)
-                            )
-                        )
-                    }
-                    else -> {
-                        val name = ANNOTATION_ATTR_VALUE
-                        val value =
-                            attrs[name]
-                                ?: (exp as? Literal)?.value()
-                                    ?: error(
-                                    "Cannot find value for default 'value' attribute from $exp"
-                                )
-                        attributes.add(
-                            DefaultAnnotationAttribute(name, createAttrValue(value, exp))
-                        )
-                    }
-                }
-            }
-        } else {
-            for ((name, value) in attrs) {
-                attributes.add(DefaultAnnotationAttribute(name, createAttrValue(value, null)))
-            }
-        }
-        return attributes
-    }
-
-    private fun createAttrValue(const: Const, expr: Expression?): AnnotationAttributeValue {
-        if (const.kind() == Kind.ARRAY) {
-            const as ArrayInitValue
-            if (const.elements().count() == 1 && expr != null && !(expr is ArrayInit)) {
-                // This is case where defined type is array type but provided attribute value is
-                // single non-array element
-                // For e.g. @Anno(5) where Anno is @interfacce Anno {int [] value()}
-                val constLiteral = const.elements().single()
-                return DefaultAnnotationSingleAttributeValue(
-                    { getSource(constLiteral, expr) },
-                    { getValue(constLiteral) }
-                )
-            }
-            return DefaultAnnotationArrayAttributeValue(
-                { getSource(const, expr) },
-                { const.elements().map { createAttrValue(it, null) } }
-            )
-        }
-        return DefaultAnnotationSingleAttributeValue(
-            { getSource(const, expr) },
-            { getValue(const) }
+        sourceTypeBoundClass: SourceTypeBoundClass
+    ) =
+        TurbineFieldResolver(
+            classSymbol,
+            classSymbol,
+            sourceTypeBoundClass.memberImports(),
+            sourceTypeBoundClass.scope(),
+            envClassMap,
         )
-    }
-
-    private fun getSource(const: Const, expr: Expression?): String {
-        return when (const.kind()) {
-            Kind.PRIMITIVE -> {
-                when ((const as Value).constantTypeKind()) {
-                    PrimKind.INT -> {
-                        val value = (const as Const.IntValue).value()
-                        if (value < 0 || (expr != null && expr.kind() == Tree.Kind.TYPE_CAST))
-                            "0x" + value.toUInt().toString(16) // Hex Value
-                        else value.toString()
-                    }
-                    PrimKind.SHORT -> {
-                        val value = (const as Const.ShortValue).value()
-                        if (value < 0) "0x" + value.toUInt().toString(16) else value.toString()
-                    }
-                    PrimKind.FLOAT -> {
-                        val value = (const as Const.FloatValue).value()
-                        when {
-                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
-                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
-                            value < 0 -> value.toString() + "F" // Handling negative values
-                            else -> value.toString() + "f" // Handling positive values
-                        }
-                    }
-                    PrimKind.DOUBLE -> {
-                        val value = (const as Const.DoubleValue).value()
-                        when {
-                            value == Double.POSITIVE_INFINITY ->
-                                "java.lang.Double.POSITIVE_INFINITY"
-                            value == Double.NEGATIVE_INFINITY ->
-                                "java.lang.Double.NEGATIVE_INFINITY"
-                            else -> const.toString()
-                        }
-                    }
-                    PrimKind.BYTE -> const.getValue().toString()
-                    else -> const.toString()
-                }
-            }
-            Kind.ARRAY -> {
-                const as ArrayInitValue
-                val pairs =
-                    if (expr != null) const.elements().zip((expr as ArrayInit).exprs())
-                    else const.elements().map { Pair(it, null) }
-                buildString {
-                    append("{")
-                    pairs.joinTo(this, ", ") { getSource(it.first, it.second) }
-                    append("}")
-                }
-            }
-            Kind.ENUM_CONSTANT -> getValue(const).toString()
-            Kind.CLASS_LITERAL -> {
-                if (expr != null) expr.toString() else getValue(const).toString()
-            }
-            else -> const.toString()
-        }
-    }
-
-    private fun getValue(const: Const): Any? {
-        when (const.kind()) {
-            Kind.PRIMITIVE -> {
-                val value = const as Value
-                return value.getValue()
-            }
-            // For cases like AnyClass.class, return the qualified name of AnyClass
-            Kind.CLASS_LITERAL -> {
-                val value = const as TurbineClassValue
-                return value.type().toString()
-            }
-            Kind.ENUM_CONSTANT -> {
-                val value = const as EnumConstantValue
-                val temp =
-                    getQualifiedName(value.sym().owner().binaryName()) + "." + value.toString()
-                return temp
-            }
-            else -> {
-                return const.toString()
-            }
-        }
-    }
-
-    private fun createTypeParameters(
-        tyParams: ImmutableMap<TyVarSymbol, TyVarInfo>,
-        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-        description: String,
-    ): TypeParameterListAndFactory<TurbineTypeItemFactory> {
-
-        if (tyParams.isEmpty())
-            return TypeParameterListAndFactory(
-                TypeParameterList.NONE,
-                enclosingClassTypeItemFactory
-            )
-
-        // Create a list of [TypeParameterItem]s from turbine specific classes.
-        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
-            enclosingClassTypeItemFactory,
-            description,
-            tyParams.toList(),
-            { (sym, tyParam) -> createTypeParameter(sym, tyParam) },
-            { typeItemFactory, (_, tParam) -> createTypeParameterBounds(tParam, typeItemFactory) },
-        )
-    }
-
-    /**
-     * Create the [DefaultTypeParameterItem] without any bounds and register it so that any uses of
-     * it within the type bounds, e.g. `<E extends Enum<E>>`, or from other type parameters within
-     * the same [TypeParameterList] can be resolved.
-     */
-    private fun createTypeParameter(sym: TyVarSymbol, param: TyVarInfo): DefaultTypeParameterItem {
-        val modifiers = createModifiers(0, param.annotations())
-        val typeParamItem =
-            itemFactory.createTypeParameterItem(
-                modifiers,
-                name = sym.name(),
-                // Java does not supports reified generics
-                isReified = false,
-            )
-        return typeParamItem
-    }
-
-    /** Create the bounds of a [DefaultTypeParameterItem]. */
-    private fun createTypeParameterBounds(
-        param: TyVarInfo,
-        typeItemFactory: TurbineTypeItemFactory,
-    ): List<BoundsTypeItem> {
-        val typeBounds = mutableListOf<BoundsTypeItem>()
-        val upperBounds = param.upperBound()
-
-        upperBounds.bounds().mapTo(typeBounds) { typeItemFactory.getBoundsType(it) }
-        param.lowerBound()?.let { typeBounds.add(typeItemFactory.getBoundsType(it)) }
-
-        return typeBounds.toList()
-    }
-
-    /** This method sets up the nested class hierarchy. */
-    private fun createNestedClasses(
-        classItem: DefaultClassItem,
-        nestedClasses: ImmutableList<ClassSymbol>,
-        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-    ) {
-        for (nestedClassSymbol in nestedClasses) {
-            createClass(
-                classSymbol = nestedClassSymbol,
-                containingClassItem = classItem,
-                enclosingClassTypeItemFactory = enclosingClassTypeItemFactory,
-                origin = classItem.origin,
-            )
-        }
-    }
-
-    /** This methods creates and sets the fields of a class */
-    private fun createFields(
-        classItem: DefaultClassItem,
-        fields: ImmutableList<FieldInfo>,
-        typeItemFactory: TurbineTypeItemFactory,
-    ) {
-        for (field in fields) {
-            val flags = field.access()
-            val decl = field.decl()
-            val fieldModifierItem =
-                createModifiers(
-                    flags,
-                    field.annotations(),
-                )
-            val isEnumConstant = (flags and TurbineFlag.ACC_ENUM) != 0
-            val fieldValue = createInitialValue(field)
-            val type =
-                typeItemFactory.getFieldType(
-                    underlyingType = field.type(),
-                    itemAnnotations = fieldModifierItem.annotations(),
-                    isEnumConstant = isEnumConstant,
-                    isFinal = fieldModifierItem.isFinal(),
-                    isInitialValueNonNull = {
-                        // The initial value is non-null if the value is a literal which is not
-                        // null.
-                        fieldValue.initialValue(false) != null
-                    }
-                )
-
-            val documentation = javadoc(decl)
-            val fieldItem =
-                itemFactory.createFieldItem(
-                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
-                    modifiers = fieldModifierItem,
-                    documentationFactory = getCommentedDoc(documentation),
-                    name = field.name(),
-                    containingClass = classItem,
-                    type = type,
-                    isEnumConstant = isEnumConstant,
-                    fieldValue = fieldValue,
-                )
-
-            classItem.addField(fieldItem)
-        }
-    }
-
-    private fun createMethods(
-        classItem: DefaultClassItem,
-        methods: List<MethodInfo>,
-        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-    ) {
-        for (method in methods) {
-            // Ignore constructors.
-            if (method.sym().name() == "<init>") continue
-
-            val decl: MethDecl? = method.decl()
-            val methodModifierItem =
-                createModifiers(
-                    method.access(),
-                    method.annotations(),
-                )
-            val name = method.name()
-            val (typeParams, methodTypeItemFactory) =
-                createTypeParameters(
-                    method.tyParams(),
-                    enclosingClassTypeItemFactory,
-                    name,
-                )
-            val documentation = javadoc(decl)
-            val defaultValueExpr = getAnnotationDefaultExpression(method)
-            val defaultValue =
-                if (method.defaultValue() != null)
-                    extractAnnotationDefaultValue(method.defaultValue()!!, defaultValueExpr)
-                else ""
-
-            val parameters = method.parameters()
-            val fingerprint = MethodFingerprint(name, parameters.size)
-            val isAnnotationElement = classItem.isAnnotationType() && !methodModifierItem.isStatic()
-            val returnType =
-                methodTypeItemFactory.getMethodReturnType(
-                    underlyingReturnType = method.returnType(),
-                    itemAnnotations = methodModifierItem.annotations(),
-                    fingerprint = fingerprint,
-                    isAnnotationElement = isAnnotationElement,
-                )
-
-            val methodItem =
-                itemFactory.createMethodItem(
-                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
-                    modifiers = methodModifierItem,
-                    documentationFactory = getCommentedDoc(documentation),
-                    name = name,
-                    containingClass = classItem,
-                    typeParameterList = typeParams,
-                    returnType = returnType,
-                    parameterItemsFactory = { containingCallable ->
-                        createParameters(
-                            containingCallable,
-                            decl?.params(),
-                            parameters,
-                            methodTypeItemFactory,
-                        )
-                    },
-                    throwsTypes = getThrowsList(method.exceptions(), methodTypeItemFactory),
-                    annotationDefault = defaultValue,
-                )
-
-            // Ignore enum synthetic methods.
-            if (methodItem.isEnumSyntheticMethod()) continue
-
-            classItem.addMethod(methodItem)
-        }
-    }
-
-    private fun createParameters(
-        containingCallable: CallableItem,
-        parameterDecls: List<VarDecl>?,
-        parameters: List<ParamInfo>,
-        typeItemFactory: TurbineTypeItemFactory,
-    ): List<ParameterItem> {
-        val fingerprint = MethodFingerprint(containingCallable.name(), parameters.size)
-        // Some parameters in [parameters] are implicit parameters that do not have a corresponding
-        // entry in the [parameterDecls] list. The number of implicit parameters is the total
-        // number of [parameters] minus the number of declared parameters [parameterDecls]. The
-        // implicit parameters are always at the beginning so the offset from the declared parameter
-        // in [parameterDecls] to the corresponding parameter in [parameters] is simply the number
-        // of the implicit parameters.
-        val declaredParameterOffset = parameters.size - (parameterDecls?.size ?: 0)
-        return parameters.mapIndexed { idx, parameter ->
-            val parameterModifierItem =
-                createModifiers(parameter.access(), parameter.annotations()).toImmutable()
-            val type =
-                typeItemFactory.getMethodParameterType(
-                    underlyingParameterType = parameter.type(),
-                    itemAnnotations = parameterModifierItem.annotations(),
-                    fingerprint = fingerprint,
-                    parameterIndex = idx,
-                    isVarArg = parameterModifierItem.isVarArg(),
-                )
-            // Get the [Tree.VarDecl] corresponding to the [ParamInfo], if available.
-            val decl =
-                if (parameterDecls != null && idx >= declaredParameterOffset)
-                    parameterDecls.get(idx - declaredParameterOffset)
-                else null
-
-            val fileLocation =
-                TurbineFileLocation.forTree(containingCallable.containingClass(), decl)
-            val parameterItem =
-                itemFactory.createParameterItem(
-                    fileLocation = fileLocation,
-                    modifiers = parameterModifierItem,
-                    name = parameter.name(),
-                    publicNameProvider = { item ->
-                        // Java: Look for @ParameterName annotation
-                        val modifiers = item.modifiers
-                        val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
-                        annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
-                    },
-                    containingCallable = containingCallable,
-                    parameterIndex = idx,
-                    type = type,
-                    defaultValueFactory = { TurbineDefaultValue(parameterModifierItem) },
-                )
-            parameterItem
-        }
-    }
-
-    private fun createConstructors(
-        classItem: DefaultClassItem,
-        methods: List<MethodInfo>,
-        enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-    ) {
-        for (constructor in methods) {
-            // Skip real methods.
-            if (constructor.sym().name() != "<init>") continue
-
-            val decl: MethDecl? = constructor.decl()
-            val constructorModifierItem =
-                createModifiers(
-                    constructor.access(),
-                    constructor.annotations(),
-                )
-            val (typeParams, constructorTypeItemFactory) =
-                createTypeParameters(
-                    constructor.tyParams(),
-                    enclosingClassTypeItemFactory,
-                    constructor.name(),
-                )
-            val isImplicitDefaultConstructor =
-                (constructor.access() and TurbineFlag.ACC_SYNTH_CTOR) != 0
-            val name = classItem.simpleName()
-            val documentation = javadoc(decl)
-            val constructorItem =
-                itemFactory.createConstructorItem(
-                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
-                    modifiers = constructorModifierItem,
-                    documentationFactory = getCommentedDoc(documentation),
-                    // Turbine's Binder gives return type of constructors as void but the
-                    // model expects it to the type of object being created. So, use the
-                    // containing [ClassItem]'s type as the constructor return type.
-                    name = name,
-                    containingClass = classItem,
-                    typeParameterList = typeParams,
-                    returnType = classItem.type(),
-                    parameterItemsFactory = { constructorItem ->
-                        createParameters(
-                            constructorItem,
-                            decl?.params(),
-                            constructor.parameters(),
-                            constructorTypeItemFactory,
-                        )
-                    },
-                    throwsTypes =
-                        getThrowsList(constructor.exceptions(), constructorTypeItemFactory),
-                    implicitConstructor = isImplicitDefaultConstructor,
-                )
-
-            classItem.addConstructor(constructorItem)
-        }
-    }
-
-    internal fun getQualifiedName(binaryName: String): String {
-        return binaryName.replace('/', '.').replace('$', '.')
-    }
 
     /**
      * Get the ClassSymbol corresponding to a qualified name. Since the Turbine's lookup method
@@ -1204,123 +510,6 @@ internal class TurbineCodebaseInitialiser(
         return LookupKey(ImmutableList.copyOf(idents))
     }
 
-    private fun javadoc(item: TyDecl?): String {
-        if (!allowReadingComments) return ""
-        return item?.javadoc() ?: ""
-    }
-
-    private fun javadoc(item: VarDecl?): String {
-        if (!allowReadingComments) return ""
-        return item?.javadoc() ?: ""
-    }
-
-    private fun javadoc(item: MethDecl?): String {
-        if (!allowReadingComments) return ""
-        return item?.javadoc() ?: ""
-    }
-
-    private fun getThrowsList(
-        throwsTypes: List<Type>,
-        enclosingTypeItemFactory: TurbineTypeItemFactory
-    ): List<ExceptionTypeItem> {
-        return throwsTypes.map { type -> enclosingTypeItemFactory.getExceptionType(type) }
-    }
-
-    private fun getCommentedDoc(doc: String): ItemDocumentationFactory {
-        return buildString {
-                if (doc != "") {
-                    append("/**")
-                    append(doc)
-                    append("*/")
-                }
-            }
-            .toItemDocumentationFactory()
-    }
-
-    private fun createInitialValue(field: FieldInfo): FieldValue {
-        val optExpr = field.decl()?.init()
-        val expr = if (optExpr != null && optExpr.isPresent()) optExpr.get() else null
-        val constantValue = field.value()?.getValue()
-
-        val initialValueWithoutRequiredConstant =
-            when {
-                constantValue != null -> constantValue
-                expr == null -> null
-                else ->
-                    when (expr.kind()) {
-                        Tree.Kind.LITERAL -> {
-                            getValue((expr as Literal).value())
-                        }
-                        // Class Type
-                        Tree.Kind.CLASS_LITERAL -> {
-                            expr
-                        }
-                        else -> {
-                            null
-                        }
-                    }
-            }
-
-        return FixedFieldValue(constantValue, initialValueWithoutRequiredConstant)
-    }
-
-    /**
-     * Extracts the expression corresponding to the default value of a given annotation method. If
-     * the method does not have a default value, returns null.
-     */
-    private fun getAnnotationDefaultExpression(method: MethodInfo): Tree? {
-        val optExpr = method.decl()?.defaultValue()
-        return if (optExpr != null && optExpr.isPresent()) optExpr.get() else null
-    }
-
-    /**
-     * Extracts the default value of an annotation method and returns it as a string.
-     *
-     * @param const The constant object representing the annotation value.
-     * @param expr An optional expression tree that might provide additional context for value
-     *   extraction.
-     * @return The default value of the annotation method as a string.
-     */
-    private fun extractAnnotationDefaultValue(const: Const, expr: Tree?): String {
-        return when (const.kind()) {
-            Kind.PRIMITIVE -> {
-                when ((const as Value).constantTypeKind()) {
-                    PrimKind.FLOAT -> {
-                        val value = (const as Const.FloatValue).value()
-                        when {
-                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
-                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
-                            else -> value.toString() + "f"
-                        }
-                    }
-                    PrimKind.DOUBLE -> {
-                        val value = (const as Const.DoubleValue).value()
-                        when {
-                            value == Double.POSITIVE_INFINITY ->
-                                "java.lang.Double.POSITIVE_INFINITY"
-                            value == Double.NEGATIVE_INFINITY ->
-                                "java.lang.Double.NEGATIVE_INFINITY"
-                            else -> const.toString()
-                        }
-                    }
-                    PrimKind.BYTE -> const.getValue().toString()
-                    else -> const.toString()
-                }
-            }
-            Kind.ARRAY -> {
-                const as ArrayInitValue
-                // This is case where defined type is array type but default value is
-                // single non-array element
-                // For e.g. char[] letter() default 'a';
-                if (const.elements().count() == 1 && expr != null && !(expr is ArrayInit)) {
-                    extractAnnotationDefaultValue(const.elements().single(), expr)
-                } else getValue(const).toString()
-            }
-            Kind.CLASS_LITERAL -> getValue(const).toString() + ".class"
-            else -> getValue(const).toString()
-        }
-    }
-
     internal fun getTypeElement(name: String): TypeElement? = turbineElements.getTypeElement(name)
 }
 
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt
deleted file mode 100644
index 2aa0adb77..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.ModifierList
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.item.DefaultValue
-
-/** Encapsulates information about default values retrieved from the annotations. */
-class TurbineDefaultValue(private val modifiers: ModifierList) : DefaultValue {
-
-    override fun hasDefaultValue(): Boolean = isDefaultValueKnown()
-
-    override fun isDefaultValueKnown(): Boolean {
-        return modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
-    }
-
-    override fun value(): String? {
-        val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
-        return annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
-    }
-
-    override fun duplicate(parameter: ParameterItem) = TurbineDefaultValue(parameter.modifiers)
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
index a2ac4a41b..15fbf03b9 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
@@ -32,7 +32,6 @@ internal class TurbineEnvironmentManager() : EnvironmentManager {
         modelOptions: ModelOptions,
         allowReadingComments: Boolean,
         jdkHome: File?,
-        projectDescription: File?,
     ): SourceParser {
         return TurbineSourceParser(codebaseConfig, allowReadingComments)
     }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldResolver.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldResolver.kt
new file mode 100644
index 000000000..0344171f1
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldResolver.kt
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.google.common.collect.Iterables
+import com.google.turbine.binder.ConstEvaluator
+import com.google.turbine.binder.Resolve
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.binder.env.CompoundEnv
+import com.google.turbine.binder.env.Env
+import com.google.turbine.binder.lookup.LookupKey
+import com.google.turbine.binder.lookup.MemberImportIndex
+import com.google.turbine.binder.lookup.Scope
+import com.google.turbine.binder.sym.ClassSymbol
+import com.google.turbine.model.TurbineFlag
+import com.google.turbine.tree.Tree
+
+/**
+ * This copies functionality used within [ConstEvaluator].
+ *
+ * Ideally, the Turbine team will be able to refactor [ConstEvaluator] to pull that functionality
+ * out for use by us.
+ */
+internal class TurbineFieldResolver(
+    private val origin: ClassSymbol,
+    private val owner: ClassSymbol,
+    private val memberImports: MemberImportIndex,
+    private val scope: Scope,
+    private val env: CompoundEnv<ClassSymbol, TypeBoundClass>
+) {
+    override fun toString() = "TurbineFieldResolver($origin)"
+
+    fun resolveField(t: Tree.ConstVarName): TypeBoundClass.FieldInfo? {
+        val simpleName = t.name()[0]
+        var field = lexicalField(env, owner, simpleName)
+        if (field != null) {
+            return field
+        }
+        field = resolveQualifiedField(t)
+        if (field != null) {
+            return field
+        }
+        val classSymbol = memberImports.singleMemberImport(simpleName.value())
+        if (classSymbol != null) {
+            field = Resolve.resolveField(env, origin, classSymbol, simpleName)
+            if (field != null) {
+                return field
+            }
+        }
+        val it = memberImports.onDemandImports()
+        while (it.hasNext()) {
+            field = Resolve.resolveField(env, origin, it.next(), simpleName)
+            if (field == null) {
+                continue
+            }
+            if ((field.access() and TurbineFlag.ACC_PRIVATE) == TurbineFlag.ACC_PRIVATE) {
+                continue
+            }
+            return field
+        }
+
+        return null
+    }
+
+    private fun resolveQualifiedField(t: Tree.ConstVarName): TypeBoundClass.FieldInfo? {
+        if (t.name().size <= 1) {
+            return null
+        }
+        val result = scope.lookup(LookupKey(t.name())) ?: return null
+        if (result.remaining().isEmpty()) {
+            return null
+        }
+        var sym = result.sym() as ClassSymbol
+        for (i in 0 until result.remaining().size - 1) {
+            sym = Resolve.resolve(env, sym, sym, result.remaining()[i]) ?: return null
+        }
+        return Resolve.resolveField(env, origin, sym, Iterables.getLast(result.remaining()))
+    }
+
+    private fun lexicalField(
+        env: Env<ClassSymbol, TypeBoundClass>,
+        initialSym: ClassSymbol?,
+        name: Tree.Ident
+    ): TypeBoundClass.FieldInfo? {
+        var sym = initialSym
+        while (sym != null) {
+            val info = env.getNonNull(sym)
+            val field = Resolve.resolveField(env, origin, sym, name)
+            if (field != null) {
+                return field
+            }
+            sym = info.owner()
+        }
+        return null
+    }
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt
new file mode 100644
index 000000000..1f22d97a3
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.DefaultItem
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.google.turbine.binder.bound.SourceTypeBoundClass
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.binder.sym.ClassSymbol
+import com.google.turbine.type.AnnoInfo
+
+/** Global context that is shared between [TurbineCodebaseInitialiser] and [TurbineClassBuilder]. */
+internal interface TurbineGlobalContext {
+    /** The [DefaultCodebase] being built. */
+    val codebase: DefaultCodebase
+
+    /** Cache of [TurbineSourceFile]s. */
+    val sourceFileCache: TurbineSourceFileCache
+
+    /** Factory for creating [DefaultItem] implementations. */
+    val itemFactory: DefaultItemFactory
+
+    /** Factory for creating [DefaultAnnotationItem]s from [AnnoInfo] objects. */
+    val annotationFactory: TurbineAnnotationFactory
+
+    /** True if comments should be read, false otherwise. */
+    val allowReadingComments: Boolean
+
+    /** Find the [TypeBoundClass] for the `ClassSymbol`. */
+    fun typeBoundClassForSymbol(classSymbol: ClassSymbol): TypeBoundClass
+
+    /**
+     * Create a [TurbineFieldResolver] for resolving fields from within
+     * [classSymbol]/[sourceTypeBoundClass].
+     */
+    fun createFieldResolver(
+        classSymbol: ClassSymbol,
+        sourceTypeBoundClass: SourceTypeBoundClass,
+    ): TurbineFieldResolver
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
index 5c6b9e620..48033bbec 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
@@ -52,7 +52,7 @@ internal class TurbineSourceFile(
         val imports = TreeSet<Import>(compareBy { it.pattern })
 
         for (import in compUnit.imports()) {
-            val resolvedName = extractNameFromIdent(import.type())
+            val resolvedName = import.type().dotSeparatedName
             // Package import
             if (import.wild()) {
                 val pkgItem = codebase.findPackage(resolvedName) ?: continue
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFileCache.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFileCache.kt
new file mode 100644
index 000000000..67254fb10
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFileCache.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.google.turbine.diag.SourceFile
+import com.google.turbine.tree.Tree.CompUnit
+
+/**
+ * Creates [TurbineSourceFile]s on demand for a [SourceFile] and caches the result for reuse.
+ *
+ * @param codebase the [DefaultCodebase] of which any created [TurbineSourceFile]s are part.
+ * @param units the [CompUnit]s from which the [TurbineSourceFile]s will be created.
+ */
+internal class TurbineSourceFileCache(
+    private val codebase: DefaultCodebase,
+    units: List<CompUnit>,
+) {
+    /** Map from [SourceFile.path] to [CompUnit]. */
+    private val pathToCompUnit = units.associateBy { it.source().path() }
+
+    /** Map from file path to the [TurbineSourceFile]. */
+    private val turbineSourceFiles = mutableMapOf<String, TurbineSourceFile>()
+
+    /**
+     * Get the [TurbineSourceFile] for a [SourceFile].
+     *
+     * If none exists then find the [CompUnit] for [sourceFile] by [SourceFile.path], failing if it
+     * could not be found. Then create a [TurbineSourceFile] from that, cache it for future use and
+     * return it.
+     */
+    internal fun turbineSourceFile(sourceFile: SourceFile): TurbineSourceFile =
+        turbineSourceFiles.computeIfAbsent(sourceFile.path()) { path ->
+            val unit = pathToCompUnit[path] ?: error("cannot find CompUnit for $path")
+            TurbineSourceFile(codebase, unit)
+        }
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
index 9a510a975..b061f25ed 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
@@ -38,10 +38,10 @@ internal class TurbineSourceParser(
      */
     override fun parseSources(
         sourceSet: SourceSet,
-        commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
         apiPackages: PackageFilter?,
+        projectDescription: File?
     ): Codebase {
         val rootDir = sourceSet.sourcePath.firstOrNull() ?: File("").canonicalFile
 
@@ -69,7 +69,7 @@ internal class TurbineSourceParser(
         return assembler.codebase
     }
 
-    override fun loadFromJar(apiJar: File): Codebase {
+    override fun loadFromJar(apiJar: File, classPath: List<File>): Codebase {
         TODO("b/299044569 handle this")
     }
 }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
index f599915ad..fb0b4c52b 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
@@ -42,6 +42,7 @@ import javax.lang.model.type.TypeKind
 /** Creates [TypeItem]s from [Type]s. */
 internal class TurbineTypeItemFactory(
     private val initializer: TurbineCodebaseInitialiser,
+    private val annotationFactory: TurbineAnnotationFactory,
     typeParameterScope: TypeParameterScope,
 ) : DefaultTypeItemFactory<Type, TurbineTypeItemFactory>(typeParameterScope) {
 
@@ -50,7 +51,7 @@ internal class TurbineTypeItemFactory(
     override fun self() = this
 
     override fun createNestedFactory(scope: TypeParameterScope) =
-        TurbineTypeItemFactory(initializer, scope)
+        TurbineTypeItemFactory(initializer, annotationFactory, scope)
 
     override fun getType(
         underlyingType: Type,
@@ -62,7 +63,7 @@ internal class TurbineTypeItemFactory(
         annos: List<AnnoInfo>,
         contextNullability: ContextNullability,
     ): TypeModifiers {
-        val typeAnnotations = initializer.createAnnotations(annos)
+        val typeAnnotations = annotationFactory.createAnnotations(annos)
         // Compute the nullability, factoring in any context nullability and type annotations.
         // Turbine does not support kotlin so the kotlin nullability is always null.
         val nullability = contextNullability.compute(null, typeAnnotations)
@@ -244,7 +245,7 @@ internal class TurbineTypeItemFactory(
      * @return The `ClassTypeItem` representing the outer class.
      */
     private fun getOuterClassType(type: Type.ClassTy.SimpleClassTy): ClassTypeItem {
-        val className = initializer.getQualifiedName(type.sym().binaryName())
+        val className = type.sym().qualifiedName
         val classTypeElement = initializer.getTypeElement(className)!!
         return createOuterClassType(classTypeElement.enclosingElement!!)!!
     }
@@ -283,15 +284,16 @@ internal class TurbineTypeItemFactory(
         outerClass: ClassTypeItem?,
         contextNullability: ContextNullability,
     ): ClassTypeItem {
+        val sym = type.sym()
         val outerClassItem =
-            if (type.sym().binaryName().contains("$") && outerClass == null) {
+            if (sym.binaryName().contains("$") && outerClass == null) {
                 getOuterClassType(type)
             } else {
                 outerClass
             }
 
         val modifiers = createModifiers(type.annos(), contextNullability)
-        val qualifiedName = initializer.getQualifiedName(type.sym().binaryName())
+        val qualifiedName = sym.qualifiedName
         val parameters = type.targs().map { getGeneralType(it) as TypeArgumentTypeItem }
         return DefaultClassTypeItem(codebase, modifiers, qualifiedName, parameters, outerClassItem)
     }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineUtils.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineUtils.kt
index 1fb135eda..6a57ac166 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineUtils.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineUtils.kt
@@ -16,6 +16,12 @@
 
 package com.android.tools.metalava.model.turbine
 
+import com.google.turbine.binder.bound.EnumConstantValue
+import com.google.turbine.binder.bound.TurbineClassValue
+import com.google.turbine.binder.sym.ClassSymbol
+import com.google.turbine.model.Const
+import com.google.turbine.model.Const.Kind
+import com.google.turbine.model.Const.Value
 import com.google.turbine.tree.Tree.CompUnit
 import com.google.turbine.tree.Tree.Ident
 
@@ -29,20 +35,22 @@ import com.google.turbine.tree.Tree.Ident
 internal fun getPackageName(unit: CompUnit): String {
     val optPkg = unit.pkg()
     val pkg = if (optPkg.isPresent()) optPkg.get() else null
-    return pkg?.let { extractNameFromIdent(it.name()) } ?: ""
+    return pkg?.name()?.dotSeparatedName ?: ""
 }
 
 /**
- * Extracts a dot-separated name from a list of Ident objects. This is often used for constructing
- * fully qualified names or package structures.
+ * Creates a dot-separated name from a list of [Ident] objects.
  *
- * @param identNameList The list of Ident objects representing name segments.
+ * This is often used for constructing fully qualified names or package structures.
+ *
+ * @param this@extractNameFromIdent The list of [Ident] objects representing name segments.
  * @return The combined name with segments joined by "." (e.g., "java.util.List")
  */
-internal fun extractNameFromIdent(identNameList: List<Ident>): String {
-    val nameList = identNameList.map { it.value() }
-    return nameList.joinToString(separator = ".")
-}
+internal val List<Ident>.dotSeparatedName: String
+    get() {
+        val nameList = map { it.value() }
+        return nameList.joinToString(separator = ".")
+    }
 
 /**
  * Extracts header comments from a source file string. Header comments are defined as any content
@@ -57,3 +65,40 @@ internal fun getHeaderComments(source: String): String {
     // Return everything before "package" keyword
     return if (packageIndex == -1) "" else source.substring(0, packageIndex)
 }
+
+/**
+ * Get the qualified name, i.e. what would be used in an `import` statement, for this [ClassSymbol].
+ */
+internal val ClassSymbol.qualifiedName: String
+    get() = binaryName().replace('/', '.').replace('$', '.')
+
+/**
+ * The underlying value of this [Const].
+ *
+ * e.g. [Integer] for integers, [String]s for strings and any other values.
+ */
+internal val Const.underlyingValue: Any?
+    get() {
+        when (kind()) {
+            Kind.PRIMITIVE -> {
+                val value = this as Value
+                return value.value
+            }
+            // For cases like AnyClass.class, return the qualified name of AnyClass
+            Kind.CLASS_LITERAL -> {
+                val value = this as TurbineClassValue
+                return value.type().toString()
+            }
+            Kind.ENUM_CONSTANT -> {
+                val value = this as EnumConstantValue
+                val temp = "${value.sym().owner().qualifiedName}.$value"
+                return temp
+            }
+            else -> {
+                return toString()
+            }
+        }
+    }
+
+internal val ClassSymbol.dotSeparatedPackageName
+    get() = packageName().replace('/', '.')
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt
new file mode 100644
index 000000000..bfda4befa
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.model.Const
+import com.google.turbine.model.Const.ArrayInitValue
+import com.google.turbine.model.Const.Kind
+import com.google.turbine.model.Const.Value
+import com.google.turbine.model.TurbineConstantTypeKind
+import com.google.turbine.tree.Tree
+import com.google.turbine.tree.Tree.ArrayInit
+import com.google.turbine.tree.Tree.ConstVarName
+import com.google.turbine.tree.Tree.Expression
+
+/**
+ * A representation of a value in Turbine.
+ *
+ * A value could be:
+ * * A literal constant, e.g. `"string"`, or `3.4`.
+ * * An enum constant, e.g. `RetentionPolicy.CLASS`.
+ * * A class literal.
+ * * A constant field.
+ * * An array of one of the above types.
+ *
+ * They can be used as constant field values and annotation attribute values, including default
+ * values.
+ *
+ * It consists of two parts.
+ * * [const] - this is the constant value and has been evaluated by Turbine.
+ * * [expr] - the optional source representation of the value. This is `null` when the value is
+ *   obtained from a binary file, e.g. the value of an annotation attribute of an annotation on a
+ *   class loaded from the class path.
+ *
+ * The model needs information from both so this encapsulates them together to make them easier to
+ * use and provide a convenient place for code that manipulate them.
+ */
+internal class TurbineValue(
+    /** The constant object representing the annotation value. */
+    val const: Const,
+
+    /** An optional [Expression] that might provide additional context for value extraction. */
+    val expr: Expression?,
+
+    /** If available, then can be used to resolve [ConstVarName] to [TypeBoundClass.FieldInfo]. */
+    val fieldResolver: TurbineFieldResolver? = null,
+) {
+    /**
+     * Get the source representation of this value suitable for use when writing a method's default
+     * value.
+     */
+    fun getSourceForMethodDefault(): String {
+        // Check for field references first.
+        if (expr != null) {
+            when (expr.kind()) {
+                Tree.Kind.CONST_VAR_NAME -> {
+                    // If the const is an enum then use that as it will be fully qualified but the
+                    // ConstVarName will not.
+                    if (const.kind() != Kind.ENUM_CONSTANT && fieldResolver != null) {
+                        expr as ConstVarName
+                        val fieldInfo = fieldResolver.resolveField(expr)
+                        val fieldSymbol = fieldInfo?.sym()
+                        if (fieldSymbol != null) {
+                            return "${fieldSymbol.owner().qualifiedName}.${fieldSymbol.name()}"
+                        }
+                    }
+                }
+                // Fall back to using the const.
+                else -> {}
+            }
+        }
+
+        return when (const.kind()) {
+            Kind.PRIMITIVE -> {
+                when ((const as Value).constantTypeKind()) {
+                    TurbineConstantTypeKind.FLOAT -> {
+                        val value = (const as Const.FloatValue).value()
+                        when {
+                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
+                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
+                            else -> value.toString() + "f"
+                        }
+                    }
+                    TurbineConstantTypeKind.DOUBLE -> {
+                        val value = (const as Const.DoubleValue).value()
+                        when {
+                            value == Double.POSITIVE_INFINITY ->
+                                "java.lang.Double.POSITIVE_INFINITY"
+                            value == Double.NEGATIVE_INFINITY ->
+                                "java.lang.Double.NEGATIVE_INFINITY"
+                            else -> const.toString()
+                        }
+                    }
+                    TurbineConstantTypeKind.BYTE -> const.getValue().toString()
+                    else -> const.toString()
+                }
+            }
+            Kind.ARRAY -> {
+                const as ArrayInitValue
+                // This is case where defined type is array type but default value is
+                // single non-array element
+                // For e.g. char[] letter() default 'a';
+                if (const.elements().count() == 1 && expr != null && expr !is ArrayInit) {
+                    TurbineValue(const.elements().single(), expr).getSourceForMethodDefault()
+                } else const.underlyingValue.toString()
+            }
+            Kind.CLASS_LITERAL -> "${const.underlyingValue}.class"
+            else -> const.underlyingValue.toString()
+        }
+    }
+
+    /**
+     * Get the source representation of this value suitable for use when writing an annotation
+     * attribute's value.
+     */
+    fun getSourceForAnnotationValue(): String {
+        return when (const.kind()) {
+            Kind.PRIMITIVE -> {
+                when ((const as Value).constantTypeKind()) {
+                    TurbineConstantTypeKind.INT -> {
+                        val value = (const as Const.IntValue).value()
+                        if (value < 0 || (expr != null && expr.kind() == Tree.Kind.TYPE_CAST))
+                            "0x" + value.toUInt().toString(16) // Hex Value
+                        else value.toString()
+                    }
+                    TurbineConstantTypeKind.SHORT -> {
+                        val value = (const as Const.ShortValue).value()
+                        if (value < 0) "0x" + value.toUInt().toString(16) else value.toString()
+                    }
+                    TurbineConstantTypeKind.FLOAT -> {
+                        val value = (const as Const.FloatValue).value()
+                        when {
+                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
+                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
+                            value < 0 -> value.toString() + "F" // Handling negative values
+                            else -> value.toString() + "f" // Handling positive values
+                        }
+                    }
+                    TurbineConstantTypeKind.DOUBLE -> {
+                        val value = (const as Const.DoubleValue).value()
+                        when {
+                            value == Double.POSITIVE_INFINITY ->
+                                "java.lang.Double.POSITIVE_INFINITY"
+                            value == Double.NEGATIVE_INFINITY ->
+                                "java.lang.Double.NEGATIVE_INFINITY"
+                            else -> const.toString()
+                        }
+                    }
+                    TurbineConstantTypeKind.BYTE -> const.getValue().toString()
+                    else -> const.toString()
+                }
+            }
+            Kind.ARRAY -> {
+                const as ArrayInitValue
+                val values =
+                    if (expr != null)
+                        const.elements().zip((expr as ArrayInit).exprs(), ::TurbineValue)
+                    else const.elements().map { TurbineValue(it, null) }
+                values.joinToString(prefix = "{", postfix = "}") {
+                    it.getSourceForAnnotationValue()
+                }
+            }
+            Kind.ENUM_CONSTANT -> const.underlyingValue.toString()
+            Kind.CLASS_LITERAL -> {
+                expr?.toString() ?: "${const.underlyingValue}.class"
+            }
+            else -> const.toString()
+        }
+    }
+}
diff --git a/metalava-model-turbine/src/test/java/com/android/tools/metalava/model/turbine/TurbineFieldResolverTest.kt b/metalava-model-turbine/src/test/java/com/android/tools/metalava/model/turbine/TurbineFieldResolverTest.kt
new file mode 100644
index 000000000..6aaff1b79
--- /dev/null
+++ b/metalava-model-turbine/src/test/java/com/android/tools/metalava/model/turbine/TurbineFieldResolverTest.kt
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.testing.TemporaryFolderOwner
+import com.android.tools.metalava.testing.java
+import com.google.common.collect.ImmutableList
+import com.google.turbine.binder.Binder
+import com.google.turbine.binder.ClassPathBinder
+import com.google.turbine.binder.JimageClassBinder
+import com.google.turbine.binder.bound.SourceTypeBoundClass
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.binder.env.CompoundEnv
+import com.google.turbine.binder.env.SimpleEnv
+import com.google.turbine.binder.sym.ClassSymbol
+import com.google.turbine.diag.SourceFile
+import com.google.turbine.parse.Parser
+import com.google.turbine.tree.Tree
+import com.google.turbine.tree.Tree.Ident
+import java.util.Optional
+import kotlin.test.fail
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class TurbineFieldResolverTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    /** Parse and bind [sources] into a [CompoundEnv]. */
+    private fun bind(sources: List<TestFile>): CompoundEnv<ClassSymbol, TypeBoundClass> {
+        val srcDir = temporaryFolder.newFolder("src")
+
+        // Parse all the files.
+        val units =
+            sources
+                .stream()
+                .map { it.createFile(srcDir) }
+                .map { file -> Parser.parse(SourceFile(file.path, file.readText())) }
+                .collect(ImmutableList.toImmutableList())
+
+        // Bind them together.
+        val classPath = ClassPathBinder.bindClasspath(listOf())
+        val bootClassPath = JimageClassBinder.bindDefault()
+        val result =
+            Binder.bind(units, classPath, bootClassPath, /* moduleVersion= */ Optional.empty())
+                ?: error("Binding failed")
+
+        // Get mapping from ClassSymbol to TypeBoundClass from the class path.
+        val classPathEnv: CompoundEnv<ClassSymbol, TypeBoundClass> =
+            CompoundEnv.of(result.classPathEnv())
+
+        // Get mapping from ClassSymbol to SourceTypeBoundClass from sources.
+        val sourceEnv = SimpleEnv(result.units())
+
+        // Combine the mappings together. Searching sources first then class path.
+        val combinedEnv = classPathEnv.append(sourceEnv)
+        return combinedEnv
+    }
+
+    /** Create a [TurbineFieldResolver] for resolving fields as if from within [binaryClassName]. */
+    private fun CompoundEnv<ClassSymbol, TypeBoundClass>.resolverFor(
+        binaryClassName: String
+    ): TurbineFieldResolver {
+        // Select the class from where the field will be resolved.
+        val testClassSym = ClassSymbol(binaryClassName)
+        val testClassInfo =
+            this[testClassSym] as? SourceTypeBoundClass ?: error("unknown class $testClassSym")
+
+        // Create a resolver.
+        val fieldResolver =
+            TurbineFieldResolver(
+                testClassSym,
+                testClassSym,
+                testClassInfo.memberImports(),
+                testClassInfo.scope(),
+                this
+            )
+        return fieldResolver
+    }
+
+    private fun assertFieldCanBeResolved(fieldResolver: TurbineFieldResolver, fieldName: String) {
+        val idents =
+            fieldName
+                .split(".")
+                .stream()
+                .map { Ident(1, it) }
+                .collect(ImmutableList.toImmutableList())
+
+        fieldResolver.resolveField(Tree.ConstVarName(0, idents))
+            ?: fail("Could not resolve field $fieldName within $fieldResolver")
+    }
+
+    @Test
+    fun `Test basic resolver`() {
+        val sources =
+            listOf(
+                java(
+                    """
+                        package test.pkg;
+                        import test.other.pkg.Imported;
+                        import static test.other.pkg.ImportedStatically.STATIC;
+                        import test.wildcard.pkg.*;
+                        import static test.wildcard.pkg.ImportedWildcardStatically.*;
+                        public class Test {
+                          public static int instanceField = 1;
+                          public static final int STATIC_FIELD = 2;
+                          public class Nested {
+                            public static final int NESTED_FIELD = 3;
+                          }
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.other.pkg;
+                        public enum NotImported {
+                          ENUM1,
+                          ENUM2,
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.other.pkg;
+                        public enum Imported {
+                          CONST,
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.other.pkg;
+                        public enum ImportedStatically {
+                          STATIC,
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.wildcard.pkg;
+                        public enum ImportedWildcard {
+                          WILDCARD,
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.wildcard.pkg;
+                        public enum ImportedWildcardStatically {
+                          STATIC_WILDCARD,
+                        }
+                    """
+                ),
+            )
+
+        val combinedEnv = bind(sources)
+
+        combinedEnv.resolverFor("test/pkg/Test").let { fieldResolver ->
+            assertFieldCanBeResolved(fieldResolver, "instanceField")
+            assertFieldCanBeResolved(fieldResolver, "STATIC_FIELD")
+            assertFieldCanBeResolved(fieldResolver, "Nested.NESTED_FIELD")
+            assertFieldCanBeResolved(fieldResolver, "Float.NaN")
+            assertFieldCanBeResolved(fieldResolver, "test.other.pkg.NotImported.ENUM1")
+            assertFieldCanBeResolved(fieldResolver, "Imported.CONST")
+            assertFieldCanBeResolved(fieldResolver, "STATIC")
+            assertFieldCanBeResolved(fieldResolver, "ImportedWildcard.WILDCARD")
+            assertFieldCanBeResolved(fieldResolver, "STATIC_WILDCARD")
+        }
+
+        combinedEnv.resolverFor("test/pkg/Test${"$"}Nested").let { fieldResolver ->
+            assertFieldCanBeResolved(fieldResolver, "instanceField")
+            assertFieldCanBeResolved(fieldResolver, "STATIC_FIELD")
+        }
+    }
+}
diff --git a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
index 03c5faec6..d025395ee 100644
--- a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
@@ -29,3 +29,78 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeModifiersTest
   Test interface types
   Test leading annotation on array type
   Test super class and interface types of interface
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
+  testLegacySource[jar,annotation]
+  testLegacySource[jar,double NaN]
+  testLegacySource[jar,double negative infinity]
+  testLegacySource[jar,double positive infinity]
+  testLegacySource[jar,float NaN]
+  testLegacySource[jar,float negative infinity]
+  testLegacySource[jar,float positive infinity]
+  testLegacySource[source,String using constant]
+  testLegacySource[source,annotation]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double with int]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float with int]
+  testLegacySource[source,int positive]
+  testLegacySource[source,long with int]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
+  testLegacySource[jar,annotation]
+  testLegacySource[jar,double NaN]
+  testLegacySource[jar,double negative infinity]
+  testLegacySource[jar,double positive infinity]
+  testLegacySource[jar,float NaN]
+  testLegacySource[jar,float negative infinity]
+  testLegacySource[jar,float positive infinity]
+  testLegacySource[source,annotation]
+  testLegacySource[source,double with int]
+  testLegacySource[source,float with int]
+  testLegacySource[source,long with int]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
+  testLegacySource[jar,annotation]
+  testLegacySource[jar,char unicode]
+  testLegacySource[jar,double NaN]
+  testLegacySource[jar,double negative infinity]
+  testLegacySource[jar,double positive infinity]
+  testLegacySource[jar,float NaN]
+  testLegacySource[jar,float negative infinity]
+  testLegacySource[jar,float positive infinity]
+  testLegacySource[jar,int negative]
+  testLegacySource[source,String using constant]
+  testLegacySource[source,annotation]
+  testLegacySource[source,double NaN]
+  testLegacySource[source,double negative infinity]
+  testLegacySource[source,double positive infinity]
+  testLegacySource[source,double with exponent]
+  testLegacySource[source,double with int]
+  testLegacySource[source,enum]
+  testLegacySource[source,float NaN]
+  testLegacySource[source,float negative infinity]
+  testLegacySource[source,float positive infinity]
+  testLegacySource[source,float with exponent]
+  testLegacySource[source,float with int]
+  testLegacySource[source,float with upper F]
+  testLegacySource[source,int negative]
+  testLegacySource[source,int positive]
+  testLegacySource[source,long with int]
+  testLegacySource[source,long with lower l]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
+  testLegacySource[jar,double NaN]
+  testLegacySource[jar,double negative infinity]
+  testLegacySource[jar,double positive infinity]
+  testLegacySource[jar,float NaN]
+  testLegacySource[jar,float negative infinity]
+  testLegacySource[jar,float positive infinity]
+
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
+  testLegacySource[jar,double NaN]
+  testLegacySource[jar,double negative infinity]
+  testLegacySource[jar,double positive infinity]
+  testLegacySource[jar,float NaN]
+  testLegacySource[jar,float negative infinity]
+  testLegacySource[jar,float positive infinity]
diff --git a/metalava-model/Android.bp b/metalava-model/Android.bp
index 4dc717fc5..b8222be8d 100644
--- a/metalava-model/Android.bp
+++ b/metalava-model/Android.bp
@@ -23,6 +23,7 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     static_libs: [
         "metalava-reporter",
     ],
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
index 10d767f5e..e3f77dcee 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+const val ANDROID_ANNOTATION_PACKAGE = "android.annotation"
 const val ANDROID_ANNOTATION_PREFIX = "android.annotation."
 const val ANDROID_INT_DEF = "android.annotation.IntDef"
 const val ANDROID_LONG_DEF = "android.annotation.LongDef"
@@ -25,6 +26,7 @@ const val ANDROID_SYSTEM_API = "android.annotation.SystemApi"
 const val ANDROID_TEST_API = "android.annotation.TestApi"
 const val ANDROID_FLAGGED_API = "android.annotation.FlaggedApi"
 
+const val ANDROIDX_ANNOTATION_PACKAGE = "androidx.annotation"
 const val ANDROIDX_ANNOTATION_PREFIX = "androidx.annotation."
 const val ANDROIDX_INT_DEF = "androidx.annotation.IntDef"
 const val ANDROIDX_LONG_DEF = "androidx.annotation.LongDef"
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
index 6bdc831df..673b3d9a9 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
@@ -16,6 +16,9 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.api.flags.ApiFlags
+
 /**
  * Encapsulates information that metalava needs to know about a specific annotation type.
  *
@@ -42,6 +45,15 @@ interface AnnotationInfo {
      */
     val showability: Showability
 
+    /**
+     * The [ApiFlag] referenced by the annotation.
+     *
+     * This will be `null` if no [ApiFlags] have been provided or the annotation type is not
+     * [ANDROID_FLAGGED_API]. Otherwise, it will be one of the instances of [ApiFlag], e.g.
+     * [ApiFlag.REVERT_FLAGGED_API].
+     */
+    val apiFlag: ApiFlag?
+
     val suppressCompatibility: Boolean
 }
 
@@ -242,5 +254,16 @@ data class Showability(
                 recursive = ShowOrHide.NO_EFFECT,
                 forStubsOnly = ShowOrHide.NO_EFFECT
             )
+
+        /**
+         * The annotation will cause the annotated item (and any enclosed items unless overridden by
+         * a closer annotation) to not be shown.
+         */
+        val REVERT_UNSTABLE_API =
+            Showability(
+                show = ShowOrHide.REVERT_UNSTABLE_API,
+                recursive = ShowOrHide.REVERT_UNSTABLE_API,
+                forStubsOnly = ShowOrHide.REVERT_UNSTABLE_API,
+            )
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
index f9fb82a40..44677ce55 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.api.flags.ApiFlags
 import com.android.tools.metalava.reporter.FileLocation
 import kotlin.reflect.KClass
 
@@ -42,7 +44,7 @@ fun isJvmSyntheticAnnotation(qualifiedName: String): Boolean {
 }
 
 sealed interface AnnotationItem {
-    val codebase: Codebase
+    val annotationContext: AnnotationContext
 
     /**
      * The location of this annotation with the source file.
@@ -61,6 +63,15 @@ sealed interface AnnotationItem {
      */
     val showability: Showability
 
+    /**
+     * The [ApiFlag] referenced by this [AnnotationItem].
+     *
+     * This will be `null` if no [ApiFlags] have been provided or this [AnnotationItem]'s type is
+     * not [ANDROID_FLAGGED_API]. Otherwise, it will be one of the instances of [ApiFlag], e.g.
+     * [ApiFlag.REVERT_FLAGGED_API].
+     */
+    val apiFlag: ApiFlag?
+
     /** Generates source code for this annotation (using fully qualified names) */
     fun toSource(
         target: AnnotationTarget = AnnotationTarget.SIGNATURE_FILE,
@@ -109,22 +120,6 @@ sealed interface AnnotationItem {
             ANDROID_LONG_DEF == name)
     }
 
-    /**
-     * True if this annotation represents a @ParameterName annotation (or some synonymous
-     * annotation). The parameter name should be the default attribute or "value".
-     */
-    fun isParameterName(): Boolean {
-        return qualifiedName.endsWith(".ParameterName")
-    }
-
-    /**
-     * True if this annotation represents a @DefaultValue annotation (or some synonymous
-     * annotation). The default value should be the default attribute or "value".
-     */
-    fun isDefaultValue(): Boolean {
-        return qualifiedName.endsWith(".DefaultValue")
-    }
-
     /** Returns the given named attribute if specified */
     fun findAttribute(name: String?): AnnotationAttribute? {
         val actualName = name ?: ANNOTATION_ATTR_VALUE
@@ -293,7 +288,7 @@ inline fun <reified T : Any> AnnotationItem.getAttributeValue(name: String): T?
  */
 @PublishedApi
 internal fun AnnotationItem.nonInlineGetAttributeValue(kClass: KClass<*>, name: String): Any? {
-    val attributeValue = findAttribute(name)?.value ?: return null
+    val attributeValue = findAttribute(name)?.legacyValue ?: return null
     val value =
         when (attributeValue) {
             is AnnotationArrayAttributeValue ->
@@ -302,7 +297,7 @@ internal fun AnnotationItem.nonInlineGetAttributeValue(kClass: KClass<*>, name:
         }
             ?: return null
 
-    return convertValue(codebase, kClass, value)
+    return convertValue(annotationContext, kClass, value)
 }
 
 /**
@@ -328,14 +323,14 @@ internal fun <T : Any> AnnotationItem.nonInlineGetAttributeValues(
     name: String,
     caster: (Any) -> T
 ): List<T>? {
-    val attributeValue = findAttribute(name)?.value ?: return null
+    val attributeValue = findAttribute(name)?.legacyValue ?: return null
     val values =
         when (attributeValue) {
             is AnnotationArrayAttributeValue -> attributeValue.values.mapNotNull { it.value() }
             else -> listOfNotNull(attributeValue.value())
         }
 
-    return values.mapNotNull { convertValue(codebase, kClass, it) }.map { caster(it) }
+    return values.mapNotNull { convertValue(annotationContext, kClass, it) }.map { caster(it) }
 }
 
 /**
@@ -345,7 +340,11 @@ internal fun <T : Any> AnnotationItem.nonInlineGetAttributeValues(
  * simply returns the value it is given. It is the caller's responsibility to actually cast the
  * returned value to the correct type.
  */
-private fun convertValue(codebase: Codebase, kClass: KClass<*>, value: Any): Any? {
+private fun convertValue(
+    annotationContext: AnnotationContext,
+    kClass: KClass<*>,
+    value: Any
+): Any? {
     // The value stored for number types is not always the same as the type of the annotation
     // attributes. This is for a number of reasons, e.g.
     // * In a .class file annotation values are stored in the constant pool and some number types do
@@ -371,17 +370,33 @@ private fun convertValue(codebase: Codebase, kClass: KClass<*>, value: Any): Any
 
     // TODO: Push down into the model as that is likely to be more efficient.
     if (kClass == AnnotationItem::class) {
-        return DefaultAnnotationItem.create(codebase, value as String)
+        return DefaultAnnotationItem.create(annotationContext, value as String)
     }
 
     return value
 }
 
+/** Provides contextual information needed by [AnnotationItem]s. */
+interface AnnotationContext : ClassResolver {
+    /** The manager of annotations within this context. */
+    val annotationManager: AnnotationManager
+
+    /**
+     * Creates an annotation item for the given (fully qualified) Java source.
+     *
+     * Returns `null` if the source contains an annotation that is not recognized by Metalava.
+     */
+    fun createAnnotation(
+        source: String,
+        context: Item? = null,
+    ): AnnotationItem?
+}
+
 /** Default implementation of an annotation item */
 open class DefaultAnnotationItem
-/** The primary constructor is private to force sub-classes to use the secondary constructor. */
+/** The primary constructor is private to force subclasses to use the secondary constructor. */
 protected constructor(
-    override val codebase: Codebase,
+    override val annotationContext: AnnotationContext,
     override val fileLocation: FileLocation,
 
     /** Fully qualified name of the annotation (prior to name mapping) */
@@ -391,16 +406,19 @@ protected constructor(
     final override val qualifiedName: String,
 
     /** Possibly empty list of attributes. */
-    attributesGetter: () -> List<AnnotationAttribute>,
+    attributesGetter: (AnnotationItem) -> List<AnnotationAttribute>,
 ) : AnnotationItem {
 
     override val targets
         get() = info.targets
 
-    final override val attributes: List<AnnotationAttribute> by lazy(attributesGetter)
+    final override val attributes: List<AnnotationAttribute> by
+        lazy(LazyThreadSafetyMode.NONE) { attributesGetter(this) }
 
     /** Information that metalava has gathered about this annotation item. */
-    internal val info: AnnotationInfo by lazy { codebase.annotationManager.getAnnotationInfo(this) }
+    internal val info: AnnotationInfo by lazy {
+        annotationContext.annotationManager.getAnnotationInfo(this)
+    }
 
     override val typeNullability: TypeNullability?
         get() = info.typeNullability
@@ -420,8 +438,11 @@ protected constructor(
     override val showability: Showability
         get() = info.showability
 
+    override val apiFlag: ApiFlag?
+        get() = info.apiFlag
+
     override fun resolve(): ClassItem? {
-        return codebase.resolveClass(originalName)
+        return annotationContext.resolveClass(originalName)
     }
 
     /** If this annotation has a typedef annotation associated with it, return it */
@@ -454,7 +475,7 @@ protected constructor(
             originalName,
             qualifiedName,
         ) {
-            attributes.map { DefaultAnnotationAttribute(it.name, it.value.snapshot()) }
+            attributes.map { DefaultAnnotationAttribute(it.name, it.legacyValue.snapshot()) }
         }
     }
 
@@ -471,7 +492,8 @@ protected constructor(
 
     override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
         val qualifiedName =
-            codebase.annotationManager.normalizeOutputName(qualifiedName, target) ?: return ""
+            annotationContext.annotationManager.normalizeOutputName(qualifiedName, target)
+                ?: return ""
 
         return formatAnnotationItem(qualifiedName, attributes)
     }
@@ -500,20 +522,21 @@ protected constructor(
                             append(attribute.name)
                             append("=")
                         }
-                        append(attribute.value)
+                        append(attribute.legacyValue)
                     }
                     append(")")
                 }
             }
         }
 
-        fun create(codebase: Codebase, source: String): AnnotationItem? {
+        fun create(annotationContext: AnnotationContext, source: String): AnnotationItem? {
             val index = source.indexOf("(")
             val originalName =
                 if (index == -1) source.substring(1) // Strip @
                 else source.substring(1, index)
 
-            fun attributes(): List<AnnotationAttribute> =
+            @Suppress("UNUSED_PARAMETER")
+            fun attributes(annotationItem: AnnotationItem): List<AnnotationAttribute> =
                 if (index == -1) {
                     emptyList()
                 } else {
@@ -522,33 +545,33 @@ protected constructor(
                     )
                 }
 
-            return create(codebase, FileLocation.UNKNOWN, originalName, ::attributes)
+            return create(annotationContext, FileLocation.UNKNOWN, originalName, ::attributes)
         }
 
         fun create(
-            codebase: Codebase,
+            annotationContext: AnnotationContext,
             originalName: String,
             attributes: List<AnnotationAttribute> = emptyList(),
             context: Item? = null
         ): AnnotationItem? {
             val source = formatAnnotationItem(originalName, attributes)
-            return codebase.createAnnotation(source, context)
+            return annotationContext.createAnnotation(source, context)
         }
 
         /**
          * Create a [DefaultAnnotationItem] by mapping the [originalName] to a [qualifiedName] by
-         * using the [codebase]'s [AnnotationManager.normalizeInputName].
+         * using the [annotationContext]'s [AnnotationManager.normalizeInputName].
          */
         fun create(
-            codebase: Codebase,
+            annotationContext: AnnotationContext,
             fileLocation: FileLocation,
             originalName: String,
-            attributesGetter: () -> List<AnnotationAttribute>,
+            attributesGetter: (AnnotationItem) -> List<AnnotationAttribute>,
         ): AnnotationItem? {
             val qualifiedName =
-                codebase.annotationManager.normalizeInputName(originalName) ?: return null
+                annotationContext.annotationManager.normalizeInputName(originalName) ?: return null
             return DefaultAnnotationItem(
-                codebase = codebase,
+                annotationContext = annotationContext,
                 fileLocation = fileLocation,
                 originalName = originalName,
                 qualifiedName = qualifiedName,
@@ -565,8 +588,15 @@ const val ANNOTATION_ATTR_VALUE = "value"
 sealed interface AnnotationAttribute {
     /** The name of the annotation */
     val name: String
-    /** The annotation value */
-    val value: AnnotationAttributeValue
+
+    /**
+     * The legacy annotation value.
+     *
+     * This is called `legacy` because this an old, inconsistent representation of an attribute
+     * value that exposes implementation details. It will be replaced by a properly modelled value
+     * representation.
+     */
+    val legacyValue: AnnotationAttributeValue
 
     /**
      * Return all leaf values; this flattens the complication of handling
@@ -574,7 +604,7 @@ sealed interface AnnotationAttribute {
      */
     fun leafValues(): List<AnnotationAttributeValue> {
         val result = mutableListOf<AnnotationAttributeValue>()
-        AnnotationAttributeValue.addValues(value, result)
+        AnnotationAttributeValue.addValues(legacyValue, result)
         return result
     }
 }
@@ -637,7 +667,7 @@ sealed interface AnnotationArrayAttributeValue : AnnotationAttributeValue {
 
 class DefaultAnnotationAttribute(
     override val name: String,
-    override val value: AnnotationAttributeValue
+    override val legacyValue: AnnotationAttributeValue
 ) : AnnotationAttribute {
     companion object {
         fun create(name: String, value: String): DefaultAnnotationAttribute {
@@ -719,17 +749,17 @@ class DefaultAnnotationAttribute(
     }
 
     override fun toString(): String {
-        return "$name=$value"
+        return "$name=$legacyValue"
     }
 
     override fun equals(other: Any?): Boolean {
         if (other !is AnnotationAttribute) return false
-        return name == other.name && value == other.value
+        return name == other.name && legacyValue == other.legacyValue
     }
 
     override fun hashCode(): Int {
         var result = name.hashCode()
-        result = 31 * result + value.hashCode()
+        result = 31 * result + legacyValue.hashCode()
         return result
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
index bcebd3886..40007b4f0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
@@ -180,8 +180,11 @@ internal class NoOpAnnotationInfo(
     override val showability
         get() = Showability.NO_EFFECT
 
+    override val apiFlag
+        get() = null
+
     override val suppressCompatibility
-        get() = false
+        get() = qualifiedName == SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED
 }
 
 val noOpAnnotationManager: AnnotationManager = NoOpAnnotationManager()
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
index fe03d3fb6..e3fdb8a83 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
@@ -163,9 +163,7 @@ open class BaseItemVisitor(
     }
 
     override fun visit(pkg: PackageItem) {
-        // Ignore any packages whose `emit` property is `false`. That is basically any package that
-        // does not contain at least one class that could be emitted as part of the API.
-        if (!pkg.emit) {
+        if (skipPackage(pkg)) {
             return
         }
 
@@ -180,10 +178,20 @@ open class BaseItemVisitor(
                 cls.accept(this)
             }
 
+            for (typeAlias in pkg.typeAliases()) {
+                typeAlias.accept(this)
+            }
+
             afterVisitPackage(pkg)
         }
     }
 
+    /**
+     * Ignore any packages whose `emit` property is `false`. That is basically any package that does
+     * not contain at least one class that could be emitted as part of the API.
+     */
+    open fun skipPackage(pkg: PackageItem) = !pkg.emit
+
     override fun visit(parameter: ParameterItem) {
         if (skip(parameter)) {
             return
@@ -200,6 +208,14 @@ open class BaseItemVisitor(
         wrapBodyWithCallsToVisitMethodsForSelectableItem(property) { visitProperty(property) }
     }
 
+    override fun visit(typeAlias: TypeAliasItem) {
+        if (skip(typeAlias)) {
+            return
+        }
+
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(typeAlias) { visitTypeAlias(typeAlias) }
+    }
+
     open fun skip(item: Item): Boolean = false
 
     /**
@@ -236,6 +252,8 @@ open class BaseItemVisitor(
 
     open fun visitProperty(property: PropertyItem) {}
 
+    open fun visitTypeAlias(typeAlias: TypeAliasItem) {}
+
     /**
      * Visits any [SelectableItem], i.e. everything for which [afterVisitItem] is called except
      * [ParameterItem]s.
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
index fa0eff533..732d4b155 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
@@ -258,7 +258,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
             val modifiers = cls.modifiers
             val annotation = modifiers.findAnnotation(AnnotationItem::isRetention)
             val value = annotation?.findAttribute(ANNOTATION_ATTR_VALUE)
-            val source = value?.value?.toSource()
+            val source = value?.legacyValue?.toSource()
             return when {
                 source == null -> AnnotationRetention.getDefault(cls)
                 source.contains("CLASS") -> AnnotationRetention.CLASS
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
index f10f7e38c..ad9d323aa 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
@@ -17,15 +17,15 @@
 package com.android.tools.metalava.model
 
 import com.android.tools.metalava.model.api.surface.ApiSurfaces
-import com.android.tools.metalava.reporter.BasicReporter
 import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.ThrowingReporter
 import java.io.File
 
 /**
  * Represents a complete unit of code -- typically in the form of a set of source trees, but also
  * potentially backed by .jar files or even signature files
  */
-interface Codebase {
+interface Codebase : ClassResolver, AnnotationContext {
     /** Description of what this codebase is (useful during debugging) */
     val description: String
 
@@ -41,9 +41,6 @@ interface Codebase {
     /** [Reporter] to which any issues found within the [Codebase] can be reported. */
     val reporter: Reporter
 
-    /** The manager of annotations within this codebase. */
-    val annotationManager: AnnotationManager
-
     /** The [ApiSurfaces] that will be tracked in this [Codebase]. */
     val apiSurfaces: ApiSurfaces
 
@@ -83,11 +80,14 @@ interface Codebase {
      * available). That may include fabricating the [ClassItem] from nothing in the case of models
      * that work with a partial set of classes (like text model).
      */
-    fun resolveClass(className: String): ClassItem?
+    override fun resolveClass(erasedName: String): ClassItem?
 
     /** Returns a package identified by fully qualified name, if in the codebase */
     fun findPackage(pkgName: String): PackageItem?
 
+    /** Returns a typealias identified by fully qualified name, if in the codebase */
+    fun findTypeAlias(typeAliasName: String): TypeAliasItem?
+
     /** Returns true if this codebase supports documentation. */
     fun supportsDocumentation(): Boolean
 
@@ -102,16 +102,6 @@ interface Codebase {
         visitor.visit(this)
     }
 
-    /**
-     * Creates an annotation item for the given (fully qualified) Java source.
-     *
-     * Returns `null` if the source contains an annotation that is not recognized by Metalava.
-     */
-    fun createAnnotation(
-        source: String,
-        context: Item? = null,
-    ): AnnotationItem?
-
     /** Reports that the given operation is unsupported for this codebase type */
     fun unsupported(desc: String? = null): Nothing {
         error(
@@ -130,6 +120,12 @@ interface Codebase {
         return getPackages().packages.isEmpty()
     }
 
+    /** Indicates whether this [Codebase] contains a reverted item, or not. */
+    val containsRevertedItem: Boolean
+
+    /** Record that this [Codebase] contains at least one reverted item. */
+    fun markContainsRevertedItem()
+
     /**
      * Contains configuration for [Codebase] that can, or at least could, come from command line
      * options.
@@ -142,7 +138,7 @@ interface Codebase {
         val apiSurfaces: ApiSurfaces = ApiSurfaces.DEFAULT,
 
         /** The reporter to use for issues found during processing of the [Codebase]. */
-        val reporter: Reporter = BasicReporter.ERR,
+        val reporter: Reporter = ThrowingReporter.INSTANCE,
     ) {
         companion object {
             /**
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
index b4ac05b38..f2b74aa77 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
@@ -32,6 +32,8 @@ import com.android.tools.metalava.model.ModifierFlags.Companion.INLINE
 import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
 import com.android.tools.metalava.model.ModifierFlags.Companion.OPERATOR
 import com.android.tools.metalava.model.ModifierFlags.Companion.PACKAGE_PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PROTECTED
 import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
 import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
 import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
@@ -264,7 +266,7 @@ interface ModifierFlags {
          * An internal copy of VisibilityLevel.values() to avoid paying the cost of duplicating the
          * array on every call.
          */
-        internal val VISIBILITY_LEVEL_ENUMS = VisibilityLevel.values()
+        internal val VISIBILITY_LEVEL_ENUMS = VisibilityLevel.entries
 
         // Check that the constants above are consistent with the VisibilityLevel enum, i.e. the
         // mask is large enough
@@ -536,6 +538,41 @@ fun createMutableModifiers(
     return DefaultMutableModifierList(visibility.visibilityFlagValue, annotations)
 }
 
+/**
+ * Modifies the modifier flags based on the `VisibleForTesting` annotation's `otherwise` value.
+ *
+ * @param otherwiseValue the value of the `otherwise` attribute, or `""` if no attribute is
+ *   provided.
+ */
+private fun useVisibilityFromVisibleForTesting(otherwiseValue: String, flags: Int): Int {
+    /** Check to see if this matches [visibility] or numeric [value]. */
+    fun String.matchesVisibility(visibility: String, value: Int) =
+        endsWith(visibility) || equals(value.toString())
+
+    val visibilityFlags =
+        when {
+            otherwiseValue.matchesVisibility("PROTECTED", VisibleForTesting.PROTECTED) -> {
+                PROTECTED
+            }
+            otherwiseValue.matchesVisibility(
+                "PACKAGE_PRIVATE",
+                VisibleForTesting.PACKAGE_PRIVATE
+            ) -> {
+                PACKAGE_PRIVATE
+            }
+            otherwiseValue.matchesVisibility("PRIVATE", VisibleForTesting.PRIVATE) ||
+                otherwiseValue.matchesVisibility("NONE", VisibleForTesting.NONE) -> {
+                PRIVATE
+            }
+            else -> {
+                // Return the flags without changes.
+                return flags
+            }
+        }
+
+    return (flags and VISIBILITY_MASK.inv()) or visibilityFlags
+}
+
 /**
  * Create a [MutableModifierList] from a set of [flags] and an optional list of [AnnotationItem]s.
  */
@@ -543,5 +580,30 @@ fun createMutableModifiers(
     flags: Int,
     annotations: List<AnnotationItem> = emptyList(),
 ): MutableModifierList {
-    return DefaultMutableModifierList(flags, annotations)
+    val actualFlags =
+        annotations
+            .find { it.qualifiedName == ANDROIDX_VISIBLE_FOR_TESTING }
+            ?.let { visibleForTesting ->
+                visibleForTesting.findAttribute(ATTR_OTHERWISE)?.legacyValue?.let { otherwiseValue
+                    ->
+                    useVisibilityFromVisibleForTesting(otherwiseValue.toSource(), flags)
+                }
+            }
+            ?: flags
+
+    return DefaultMutableModifierList(actualFlags, annotations)
+}
+
+private const val ANDROIDX_VISIBLE_FOR_TESTING = "androidx.annotation.VisibleForTesting"
+private const val ATTR_OTHERWISE = "otherwise"
+
+/** Defines the numeric values of the symbols used in tests that use numbers instead of symbols. */
+// TODO(b/387992791): Use a real VisibleForTesting annotation.
+interface VisibleForTesting {
+    companion object {
+        const val PRIVATE = 2
+        const val PACKAGE_PRIVATE = 3
+        const val PROTECTED = 4
+        const val NONE = 5
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt
index 2a8b3f4fa..f761596f1 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt
@@ -51,4 +51,6 @@ interface DelegatedVisitor {
     fun visitMethod(method: MethodItem) {}
 
     fun visitProperty(property: PropertyItem) {}
+
+    fun visitTypeAlias(typeAlias: TypeAliasItem) {}
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
index 42cc900f1..578f7bf7a 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
@@ -34,14 +34,24 @@ interface FieldItem : MemberItem, InheritableItem {
         duplicate: Boolean,
     ) = containingClass().findCorrespondingItemIn(codebase)?.findField(name())
 
-    /** The optional value of this [FieldItem]. */
-    val fieldValue: FieldValue?
+    /**
+     * The optional value of this [FieldItem].
+     *
+     * This is called `legacy` because this an old, inconsistent representation of the field value
+     * that exposes implementation details. It will be replaced by a properly modelled value
+     * representation.
+     */
+    val legacyFieldValue: FieldValue?
 
     /**
-     * The initial/constant value, if any. If [requireConstant] the initial value will only be
-     * returned if it's constant.
+     * The legacy initial/constant value, if any. If [requireConstant] the initial value will only
+     * be returned if it's constant.
+     *
+     * This is called `legacy` because this an old, inconsistent representation of the field value
+     * that exposes implementation details. It will be replaced by a properly modelled value
+     * representation.
      */
-    fun initialValue(requireConstant: Boolean = true): Any?
+    fun legacyInitialValue(requireConstant: Boolean = true): Any?
 
     /**
      * An enum can contain both enum constants and fields; this method provides a way to distinguish
@@ -80,8 +90,8 @@ interface FieldItem : MemberItem, InheritableItem {
      * toolchains with different fp -> string conversions.
      */
     fun hasSameValue(other: FieldItem): Boolean {
-        val thisConstant = initialValue()
-        val otherConstant = other.initialValue()
+        val thisConstant = legacyInitialValue()
+        val otherConstant = other.legacyInitialValue()
         if (thisConstant == null != (otherConstant == null)) {
             return false
         }
@@ -109,17 +119,6 @@ interface FieldItem : MemberItem, InheritableItem {
         return false
     }
 
-    /**
-     * Warn if companion constants are not marked with @JvmField.
-     *
-     * Checks the field to see if it is a companion object constant and if it is then make sure that
-     * it is annotated with `@JvmField`, reporting an issue otherwise.
-     *
-     * TODO: This should probably be in a PSI specific API Lint check (when they are supported) but
-     *   it is here for now to avoid dependencies on PSI specific code in API Lint.
-     */
-    fun ensureCompanionFieldJvmField() {}
-
     companion object {
         val comparator: java.util.Comparator<FieldItem> = Comparator { a, b ->
             a.name().compareTo(b.name())
@@ -134,7 +133,7 @@ interface FieldItem : MemberItem, InheritableItem {
     }
 
     /**
-     * If this field has an initial value, it just writes ";", otherwise it writes " = value;" with
+     * If this field has no initial value, it just writes ";", otherwise it writes " = value;" with
      * the correct Java syntax for the initial value
      */
     fun writeValueWithSemicolon(
@@ -143,7 +142,7 @@ interface FieldItem : MemberItem, InheritableItem {
         requireInitialValue: Boolean = false
     ) {
         val value =
-            initialValue(!allowDefaultValue)
+            legacyInitialValue(!allowDefaultValue)
                 ?: if (allowDefaultValue && !containingClass().isClass()) type().defaultValue()
                 else null
         if (value != null) {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt
deleted file mode 100644
index 504d6e8b1..000000000
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model
-
-import com.android.tools.metalava.model.item.DefaultValue
-
-/** Encapsulates information about a fixed default value. */
-internal class FixedDefaultValue(private val value: String?) : DefaultValue {
-
-    /** This is always true as the text model will use [DefaultValue.NONE] for no value. */
-    override fun hasDefaultValue() = true
-
-    /** This is always true as the text model will use [DefaultValue.UNKNOWN] for no value. */
-    override fun isDefaultValueKnown() = true
-
-    override fun value() = value
-
-    /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
-    override fun duplicate(parameter: ParameterItem) = this
-
-    /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
-    override fun snapshot(parameter: ParameterItem) = this
-
-    override fun toString() = "DefaultValue($value)"
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
index 312a4edb8..5eb7a7375 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
@@ -193,6 +193,7 @@ interface Item : Reportable {
      *   as the type arguments.
      * * For type parameters it's a [VariableTypeItem] reference the type parameter.
      * * For packages and files, it's null.
+     * * For type aliases it's the underlying type for which the alias is an alternative name.
      */
     fun type(): TypeItem?
 
@@ -453,7 +454,7 @@ abstract class DefaultItem(
                     for (attribute in annotation.attributes) {
                         // Assumption that all annotations in SUPPRESS_ANNOTATIONS only have
                         // one attribute such as value/names that is varargs of String
-                        val value = attribute.value
+                        val value = attribute.legacyValue
                         if (value is AnnotationArrayAttributeValue) {
                             // Example: @SuppressLint({"RequiresFeature", "AllUpper"})
                             for (innerValue in value.values) {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
index b045454a0..ed5e6fe5d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
@@ -32,4 +32,6 @@ interface ItemVisitor {
     fun visit(parameter: ParameterItem) {}
 
     fun visit(property: PropertyItem) {}
+
+    fun visit(typeAlias: TypeAliasItem) {}
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
index d980d3285..111f9c293 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.model
 const val JAVA_ENUM_VALUES = "values"
 const val JAVA_ENUM_VALUE_OF = "valueOf"
 
+const val JAVA_LANG_PACKAGE = "java.lang"
 const val JAVA_LANG_PREFIX = "java.lang."
 
 const val JAVA_LANG_ANNOTATION = "java.lang.annotation.Annotation"
@@ -37,6 +38,8 @@ const val JAVA_LANG_PARAMETER_TARGET = "java.lang.annotation.ElementType.PARAMET
 const val JAVA_RETENTION = "java.lang.annotation.Retention"
 const val KT_RETENTION = "kotlin.annotation.Retention"
 
+const val JVM_STATIC = "kotlin.jvm.JvmStatic"
+
 /** True if the annotation name represents @Retention (either the Java or Kotlin version) */
 fun isRetention(qualifiedName: String?): Boolean =
     JAVA_RETENTION == qualifiedName || KT_RETENTION == qualifiedName
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
index ba8bc799a..52e836140 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
@@ -25,6 +25,15 @@ interface MethodItem : CallableItem, InheritableItem {
     val property: PropertyItem?
         get() = null
 
+    override val effectivelyDeprecated: Boolean
+        get() =
+            originallyDeprecated ||
+                containingClass().effectivelyDeprecated ||
+                // Accessors inherit deprecation from their properties. Uses originallyDeprecated to
+                // prevent a cycle because effectivelyDeprecated on the property checks the getter.
+                // Also prevents deprecation from propagating getter -> property -> setter.
+                property?.originallyDeprecated == true
+
     @Deprecated(
         message =
             "There is no point in calling this method on MethodItem as it always returns false",
@@ -218,12 +227,14 @@ interface MethodItem : CallableItem, InheritableItem {
         }
     }
 
-    /** If annotation method, returns the default value as a source expression */
-    fun defaultValue(): String
-
-    fun hasDefaultValue(): Boolean {
-        return defaultValue() != ""
-    }
+    /**
+     * If annotation method, returns the legacy default value as a source expression.
+     *
+     * This is called `legacy` because this an old, inconsistent representation of the default value
+     * that exposes implementation details. It will be replaced by a properly modelled value
+     * representation.
+     */
+    fun legacyDefaultValue(): String
 
     /** Whether this method is a getter/setter for an underlying Kotlin property (val/var) */
     fun isKotlinProperty(): Boolean = false
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
index 3b107e59b..4f898c843 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
@@ -28,7 +28,6 @@ private constructor(
     private val target: AnnotationTarget,
     private val runtimeAnnotationsOnly: Boolean = false,
     private val skipNullnessAnnotations: Boolean = false,
-    private val language: Language = Language.JAVA,
 ) {
     companion object {
         fun forSignature(
@@ -45,7 +44,6 @@ private constructor(
             writer: Writer,
             docStubs: Boolean,
             runtimeAnnotationsOnly: Boolean = false,
-            language: Language = Language.JAVA,
         ) =
             ModifierListWriter(
                 writer = writer,
@@ -53,8 +51,6 @@ private constructor(
                     if (docStubs) AnnotationTarget.DOC_STUBS_FILE
                     else AnnotationTarget.SDK_STUBS_FILE,
                 runtimeAnnotationsOnly = runtimeAnnotationsOnly,
-                skipNullnessAnnotations = language == Language.KOTLIN,
-                language = language,
             )
 
         /**
@@ -94,13 +90,13 @@ private constructor(
     }
 
     /** Write the modifier list (possibly including annotations) to the supplied [writer]. */
-    fun write(item: Item) {
+    fun write(item: Item, normalizeFinal: Boolean = false) {
         writeAnnotations(item)
-        writeKeywords(item)
+        writeKeywords(item, normalizeFinal = normalizeFinal)
     }
 
     /** Write the modifier keywords. */
-    fun writeKeywords(item: Item, normalize: Boolean = false) {
+    fun writeKeywords(item: Item, normalizeFinal: Boolean = false) {
         if (
             item is PackageItem ||
                 (target != AnnotationTarget.SIGNATURE_FILE &&
@@ -121,12 +117,7 @@ private constructor(
 
         val list = item.modifiers
         val visibilityLevel = list.getVisibilityLevel()
-        val modifier =
-            if (language == Language.JAVA) {
-                visibilityLevel.javaSourceCodeModifier
-            } else {
-                visibilityLevel.kotlinSourceCodeModifier
-            }
+        val modifier = visibilityLevel.javaSourceCodeModifier
         if (modifier.isNotEmpty()) {
             writer.write("$modifier ")
         }
@@ -158,26 +149,17 @@ private constructor(
             writer.write("static ")
         }
 
-        when (language) {
-            Language.JAVA -> {
-                if (
-                    list.isFinal() &&
-                        // Don't show final on parameters: that's an implementation detail
-                        item !is ParameterItem &&
-                        // Don't add final on enum or enum members as they are implicitly final.
-                        classItem?.isEnum() != true &&
-                        // If normalizing and the current item is a method and its containing class
-                        // is final then do not write out the final keyword.
-                        (!normalize || methodItem?.containingClass()?.modifiers?.isFinal() != true)
-                ) {
-                    writer.write("final ")
-                }
-            }
-            Language.KOTLIN -> {
-                if (!list.isFinal()) {
-                    writer.write("open ")
-                }
-            }
+        if (
+            list.isFinal() &&
+                // Don't show final on parameters: that's an implementation detail
+                item !is ParameterItem &&
+                // Don't add final on enum or enum members as they are implicitly final.
+                classItem?.isEnum() != true &&
+                // If normalizing and the current item is a method and its containing class is final
+                // then do not write out the final keyword.
+                (!normalizeFinal || methodItem?.containingClass()?.modifiers?.isFinal() != true)
+        ) {
+            writer.write("final ")
         }
 
         if (list.isSealed()) {
@@ -223,12 +205,6 @@ private constructor(
         if (list.isFunctional()) {
             writer.write("fun ")
         }
-
-        if (language == Language.KOTLIN) {
-            if (list.isData()) {
-                writer.write("data ")
-            }
-        }
     }
 
     private fun writeAnnotations(item: Item) {
@@ -244,6 +220,9 @@ private constructor(
                     else -> false
                 }
 
+        val list = item.modifiers
+        var annotations = list.annotations()
+
         // Do not write deprecate or suppress compatibility annotations on a package.
         if (item !is PackageItem) {
             val writeDeprecated =
@@ -258,15 +237,16 @@ private constructor(
                 writer.write(if (separateLines) "\n" else " ")
             }
 
-            if (item.hasSuppressCompatibilityMetaAnnotation()) {
+            if (annotations.any { it.isSuppressCompatibilityAnnotation() }) {
                 writer.write("@$SUPPRESS_COMPATIBILITY_ANNOTATION")
                 writer.write(if (separateLines) "\n" else " ")
             }
         }
 
-        val list = item.modifiers
-        var annotations = list.annotations()
-
+        // Remove @SuppressCompatibility if it exists (it will for text codebases) because it was
+        // already written out above.
+        annotations =
+            annotations.filter { it.qualifiedName != SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED }
         // Ensure stable signature file order
         if (annotations.size > 1) {
             annotations = annotations.sortedBy { it.qualifiedName }
@@ -388,3 +368,12 @@ private constructor(
  * Because this is used in API files, it needs to maintain compatibility.
  */
 const val SUPPRESS_COMPATIBILITY_ANNOTATION = "SuppressCompatibility"
+
+/**
+ * Fully-qualified version of [SUPPRESS_COMPATIBILITY_ANNOTATION].
+ *
+ * This is only used at run-time for matching against [AnnotationItem.qualifiedName], so it doesn't
+ * need to maintain compatibility.
+ */
+internal val SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED =
+    AnnotationItem.unshortenAnnotation("@$SUPPRESS_COMPATIBILITY_ANNOTATION").substring(1)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
index f897d3867..0ced80897 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
@@ -48,6 +48,9 @@ interface PackageItem : SelectableItem {
         return topLevelClasses().asSequence().flatMap { it.allClasses() }
     }
 
+    /** All type aliases defined in this package. */
+    fun typeAliases(): List<TypeAliasItem>
+
     override fun type(): TypeItem? = null
 
     override fun setType(type: TypeItem) =
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
index e0fdd2d91..8c320d2c6 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.item.DefaultValue
+import com.android.tools.metalava.model.item.ParameterDefaultValue
 
 @MetalavaApi
 interface ParameterItem : ClassContentItem, Item {
@@ -47,8 +47,7 @@ interface ParameterItem : ClassContentItem, Item {
 
     /**
      * The public name of this parameter. In Kotlin, names are part of the public API; in Java they
-     * are not. In Java, you can annotate a parameter with {@literal @ParameterName("foo")} to name
-     * the parameter something (potentially different from the actual code parameter name).
+     * are not.
      */
     fun publicName(): String?
 
@@ -57,35 +56,11 @@ interface ParameterItem : ClassContentItem, Item {
      * Java, it's supported via a special annotation, {@literal @DefaultValue("source"). This does
      * not necessarily imply that the default value is accessible, and we know the body of the
      * default value.
-     *
-     * @see isDefaultValueKnown
      */
     fun hasDefaultValue(): Boolean
 
-    /**
-     * Returns whether this parameter has an accessible default value that we plan to keep. This is
-     * a superset of [hasDefaultValue] - if we are not writing the default values to the signature
-     * file, then the default value might not be available, even though the parameter does have a
-     * default.
-     *
-     * @see hasDefaultValue
-     */
-    fun isDefaultValueKnown(): Boolean
-
-    /**
-     * Returns the default value.
-     *
-     * **This method should only be called if [isDefaultValueKnown] returned true!** (This is
-     * necessary since the null return value is a valid default value separate from no default value
-     * specified.)
-     *
-     * The default value is the source string literal representation of the value, e.g. strings
-     * would be surrounded by quotes, Booleans are the strings "true" or "false", and so on.
-     */
-    fun defaultValueAsString(): String?
-
     /** The default value of this [ParameterItem]. */
-    val defaultValue: DefaultValue
+    val defaultValue: ParameterDefaultValue
 
     /** Whether this is a varargs parameter */
     fun isVarArgs(): Boolean = modifiers.isVarArg()
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
index 9c0dcbedf..7cf28f1ee 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
@@ -39,6 +39,12 @@ interface PropertyItem : MemberItem {
     /** The type of this property */
     override fun type(): TypeItem
 
+    /** The receiver type of this property, if one exists. */
+    val receiver: TypeItem?
+
+    /** The type parameters of this property. */
+    val typeParameterList: TypeParameterList
+
     override fun findCorrespondingItemIn(
         codebase: Codebase,
         superMethods: Boolean,
@@ -67,6 +73,16 @@ interface PropertyItem : MemberItem {
 
     override fun toStringForItem(): String = "property ${containingClass().fullName()}.${name()}"
 
+    // Inherit deprecation from the getter
+    override val effectivelyDeprecated: Boolean
+        get() =
+            originallyDeprecated ||
+                if (getter == null) {
+                    containingClass().effectivelyDeprecated
+                } else {
+                    getter!!.effectivelyDeprecated
+                }
+
     companion object {
         val comparator: java.util.Comparator<PropertyItem> = Comparator { a, b ->
             a.name().compareTo(b.name())
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
index 36ffb3880..016b3e9ce 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
@@ -122,6 +122,7 @@ interface SourceFile {
 }
 
 /** Encapsulates information about the imports used in a [SourceFile]. */
+@ConsistentCopyVisibility
 data class Import
 internal constructor(
     /**
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
index ee1c515a6..c9fa034f3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
@@ -114,6 +114,10 @@ abstract class TraversingVisitor : ItemVisitor {
                     cls.accept(this)
                     if (traversalFinished) return
                 }
+                for (typeAlias in pkg.typeAliases()) {
+                    typeAlias.accept(this)
+                    if (traversalFinished) return
+                }
             }
         }
     }
@@ -126,4 +130,9 @@ abstract class TraversingVisitor : ItemVisitor {
         val action = visitItem(property)
         traversalFinished = action == TraversalAction.SKIP_TRAVERSAL
     }
+
+    final override fun visit(typeAlias: TypeAliasItem) {
+        val action = visitItem(typeAlias)
+        traversalFinished = action == TraversalAction.SKIP_TRAVERSAL
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeAliasItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeAliasItem.kt
new file mode 100644
index 000000000..60257144b
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeAliasItem.kt
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/**
+ * Represents a Kotlin type alias (https://kotlinlang.org/docs/type-aliases.html), which provides an
+ * alternative name for an existing type.
+ */
+interface TypeAliasItem : SelectableItem, TypeParameterListOwner {
+    /** The underlying type for which this type alias is an alternative name. */
+    val aliasedType: TypeItem
+
+    /** The fully qualified name of this type alias (including the package name). */
+    val qualifiedName: String
+
+    /** The simple name of this type alias (not including the package name). */
+    val simpleName: String
+
+    /**
+     * The parent [PackageItem] of this type alias (type aliases can only be defined at the package
+     * level, not nested in other kinds of [Item]s).
+     */
+    override fun parent(): PackageItem = containingPackage()
+
+    override fun containingPackage(): PackageItem
+
+    override fun type(): TypeItem = aliasedType
+
+    override val effectivelyDeprecated: Boolean
+        get() = originallyDeprecated
+
+    override fun accept(visitor: ItemVisitor) {
+        visitor.visit(this)
+    }
+
+    /** Type aliases cannot be defined within classes, this is always null. */
+    override fun containingClass(): ClassItem? = null
+
+    override fun baselineElementId(): String = qualifiedName
+
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is TypeAliasItem) return false
+
+        return qualifiedName == other.qualifiedName
+    }
+
+    override fun hashCodeForItem(): Int = qualifiedName.hashCode()
+
+    override fun toStringForItem(): String = "typealias $qualifiedName"
+
+    override fun findCorrespondingItemIn(
+        codebase: Codebase,
+        superMethods: Boolean,
+        duplicate: Boolean
+    ): TypeAliasItem? {
+        return codebase.findTypeAlias(qualifiedName)
+    }
+
+    /** A type alias's type cannot be reset, this will error. */
+    override fun setType(type: TypeItem) =
+        error("Cannot call setType(TypeItem) on TypeAliasItem: $this")
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
index 08084da92..ecc472b94 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
@@ -160,6 +160,9 @@ interface TypeItem {
      */
     fun transform(transformer: TypeTransformer): TypeItem
 
+    /** Whether this type was originally a value class type. Defaults to false if not overridden. */
+    fun isValueClassType(): Boolean = false
+
     companion object {
         /** [TypeStringConfiguration] for [toSimpleType] to pass to [toTypeString]. */
         private val SIMPLE_TYPE_CONFIGURATION =
@@ -540,7 +543,7 @@ abstract class DefaultTypeItem(
                             appendTypeString(parameter, configuration)
                             if (index != type.arguments.size - 1) {
                                 append(",")
-                                if (configuration.spaceBetweenParameters) {
+                                if (configuration.spaceBetweenTypeArguments) {
                                     append(" ")
                                 }
                             }
@@ -726,7 +729,8 @@ abstract class DefaultTypeItem(
  *   `@Nullable List<String>` would be represented as `List<String!>?`.
  * @param nestedClassSeparator The character that is used to separate a nested class from its
  *   containing class.
- * @param spaceBetweenParameters Whether to include a space between class type params.
+ * @param spaceBetweenTypeArguments Whether to include a space between type arguments of a generic
+ *   type.
  * @param stripJavaLangPrefix Controls how `java.lang.` prefixes are removed from the types.
  * @param treatVarargsAsArray If `false` then a varargs type will use `...` to indicate that it is a
  *   varargs type, otherwise it will use `[]` like a normal array.
@@ -736,7 +740,7 @@ data class TypeStringConfiguration(
     val eraseGenerics: Boolean = false,
     val kotlinStyleNulls: Boolean = false,
     val nestedClassSeparator: Char = '.',
-    val spaceBetweenParameters: Boolean = false,
+    val spaceBetweenTypeArguments: Boolean = false,
     val stripJavaLangPrefix: StripJavaLangPrefix = StripJavaLangPrefix.NEVER,
     val treatVarargsAsArray: Boolean = false,
 ) {
@@ -853,17 +857,63 @@ interface PrimitiveTypeItem : TypeItem {
     enum class Primitive(
         val primitiveName: String,
         val defaultValue: Any?,
-        val defaultValueString: String
+        val defaultValueString: String,
+        val wrapperClass: Class<*>,
     ) {
-        BOOLEAN("boolean", false, "false"),
-        BYTE("byte", 0.toByte(), "0"),
-        CHAR("char", 0.toChar(), "0"),
-        DOUBLE("double", 0.0, "0"),
-        FLOAT("float", 0F, "0"),
-        INT("int", 0, "0"),
-        LONG("long", 0L, "0"),
-        SHORT("short", 0.toShort(), "0"),
-        VOID("void", null, "null")
+        BOOLEAN(
+            primitiveName = "boolean",
+            defaultValue = false,
+            defaultValueString = "false",
+            wrapperClass = java.lang.Boolean::class.java,
+        ),
+        BYTE(
+            primitiveName = "byte",
+            defaultValue = 0.toByte(),
+            defaultValueString = "0",
+            wrapperClass = java.lang.Byte::class.java,
+        ),
+        CHAR(
+            primitiveName = "char",
+            defaultValue = 0.toChar(),
+            defaultValueString = "0",
+            wrapperClass = java.lang.Character::class.java,
+        ),
+        DOUBLE(
+            primitiveName = "double",
+            defaultValue = 0.0,
+            defaultValueString = "0",
+            wrapperClass = java.lang.Double::class.java,
+        ),
+        FLOAT(
+            primitiveName = "float",
+            defaultValue = 0F,
+            defaultValueString = "0",
+            wrapperClass = java.lang.Float::class.java,
+        ),
+        INT(
+            primitiveName = "int",
+            defaultValue = 0,
+            defaultValueString = "0",
+            wrapperClass = java.lang.Integer::class.java,
+        ),
+        LONG(
+            primitiveName = "long",
+            defaultValue = 0L,
+            defaultValueString = "0",
+            wrapperClass = java.lang.Long::class.java,
+        ),
+        SHORT(
+            primitiveName = "short",
+            defaultValue = 0.toShort(),
+            defaultValueString = "0",
+            wrapperClass = java.lang.Short::class.java,
+        ),
+        VOID(
+            primitiveName = "void",
+            defaultValue = null,
+            defaultValueString = "null",
+            wrapperClass = java.lang.Void::class.java,
+        )
     }
 
     override fun defaultValue(): Any? = kind.defaultValue
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
index 0a2042b62..fe8d72797 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
@@ -41,7 +41,9 @@ interface TypeParameterItem {
 
     fun isReified(): Boolean
 
-    fun toSource(): String {
+    fun toSource(
+        configuration: TypeStringConfiguration = SOURCE_TYPE_STRING_CONFIGURATION
+    ): String {
         return buildString {
             if (isReified()) {
                 append("reified ")
@@ -60,7 +62,7 @@ interface TypeParameterItem {
                         append(" ")
                     }
                     first = false
-                    append(bound.toTypeString(SOURCE_TYPE_STRING_CONFIGURATION))
+                    append(bound.toTypeString(configuration))
                 }
             }
         }
@@ -68,7 +70,7 @@ interface TypeParameterItem {
 
     companion object {
         /** [TypeStringConfiguration] for use by [toSource]. */
-        private val SOURCE_TYPE_STRING_CONFIGURATION =
-            TypeStringConfiguration(spaceBetweenParameters = true)
+        internal val SOURCE_TYPE_STRING_CONFIGURATION =
+            TypeStringConfiguration(spaceBetweenTypeArguments = true)
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
index bcae985fb..38229e604 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.TypeParameterItem.Companion.SOURCE_TYPE_STRING_CONFIGURATION
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.type.TypeItemFactory
 
@@ -25,6 +26,12 @@ import com.android.tools.metalava.model.type.TypeItemFactory
  * parameter T has bounds List<String>.
  */
 interface TypeParameterList : List<TypeParameterItem> {
+    /**
+     * Returns source representation of this type parameter, using fully qualified names (possibly
+     * with java.lang. removed if requested via [configuration]).
+     */
+    fun toSource(configuration: TypeStringConfiguration = SOURCE_TYPE_STRING_CONFIGURATION): String
+
     /**
      * Returns source representation of this type parameter, using fully qualified names (possibly
      * with java.lang. removed if requested via options)
@@ -43,7 +50,11 @@ interface TypeParameterList : List<TypeParameterItem> {
         /** Type parameter list when there are no type parameters */
         val NONE: TypeParameterList =
             object : TypeParameterList, List<TypeParameterItem> by emptyListDelegate {
-                override fun toString(): String = ""
+                override fun toSource(configuration: TypeStringConfiguration): String {
+                    return ""
+                }
+
+                override fun toString() = toSource()
 
                 override fun equals(other: Any?) = emptyListDelegate == other
 
@@ -56,20 +67,20 @@ class DefaultTypeParameterList
 private constructor(private val typeParameters: List<TypeParameterItem>) :
     TypeParameterList, List<TypeParameterItem> by typeParameters {
 
-    private val toString by lazy {
-        buildString {
-            if (this@DefaultTypeParameterList.isNotEmpty()) {
-                append("<")
-                var first = true
-                for (param in this@DefaultTypeParameterList) {
-                    if (!first) {
-                        append(", ")
-                    }
-                    first = false
-                    append(param.toSource())
+    private val toString by lazy(LazyThreadSafetyMode.NONE) { toSource() }
+
+    override fun toSource(configuration: TypeStringConfiguration) = buildString {
+        if (this@DefaultTypeParameterList.isNotEmpty()) {
+            append("<")
+            var first = true
+            for (param in this@DefaultTypeParameterList) {
+                if (!first) {
+                    append(", ")
                 }
-                append(">")
+                first = false
+                append(param.toSource(configuration))
             }
+            append(">")
         }
     }
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
index 6e6366c40..3fe2ac9c0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
@@ -25,17 +25,35 @@ enum class VisibilityLevel(
     /** String representation in source code. */
     val javaSourceCodeModifier: String,
 
-    /** String representation in Kotlin source code. */
-    val kotlinSourceCodeModifier: String,
-
     /** String representation in user visible messages. */
     val userVisibleDescription: String,
+
     /** Representation in the internal flags. */
     internal val visibilityFlagValue: Int
 ) {
-    PACKAGE_PRIVATE("", "", "package private", ModifierFlags.PACKAGE_PRIVATE),
-    PRIVATE("private", "private", "private", ModifierFlags.PRIVATE),
-    INTERNAL("internal", "internal", "internal", ModifierFlags.INTERNAL),
-    PROTECTED("protected", "protected", "protected", ModifierFlags.PROTECTED),
-    PUBLIC("public", "", "public", ModifierFlags.PUBLIC)
+    PACKAGE_PRIVATE(
+        javaSourceCodeModifier = "",
+        userVisibleDescription = "package private",
+        visibilityFlagValue = ModifierFlags.PACKAGE_PRIVATE,
+    ),
+    PRIVATE(
+        javaSourceCodeModifier = "private",
+        userVisibleDescription = "private",
+        visibilityFlagValue = ModifierFlags.PRIVATE,
+    ),
+    INTERNAL(
+        javaSourceCodeModifier = "internal",
+        userVisibleDescription = "internal",
+        visibilityFlagValue = ModifierFlags.INTERNAL,
+    ),
+    PROTECTED(
+        javaSourceCodeModifier = "protected",
+        userVisibleDescription = "protected",
+        visibilityFlagValue = ModifierFlags.PROTECTED,
+    ),
+    PUBLIC(
+        javaSourceCodeModifier = "public",
+        userVisibleDescription = "public",
+        visibilityFlagValue = ModifierFlags.PUBLIC,
+    )
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
index cd35adc36..60c3fb2ff 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
@@ -160,18 +160,18 @@ private class ImmutableAnnotationFilter(
             return false
         }
         for (attribute in filter.attributes) {
-            val existingValue = existingAnnotation.findAttribute(attribute.name)?.value
+            val existingValue = existingAnnotation.findAttribute(attribute.name)?.legacyValue
             val existingValueSource = existingValue?.toSource()
-            val attributeValueSource = attribute.value.toSource()
+            val attributeValueSource = attribute.legacyValue.toSource()
             if (attribute.name == "value") {
                 // Special-case where varargs value annotation attribute can be specified with
                 // either @Foo(BAR) or @Foo({BAR}) and they are equivalent.
                 when {
-                    attribute.value is AnnotationSingleAttributeValue &&
+                    attribute.legacyValue is AnnotationSingleAttributeValue &&
                         existingValue is AnnotationArrayAttributeValue -> {
                         if (existingValueSource != "{$attributeValueSource}") return false
                     }
-                    attribute.value is AnnotationArrayAttributeValue &&
+                    attribute.legacyValue is AnnotationArrayAttributeValue &&
                         existingValue is AnnotationSingleAttributeValue -> {
                         if ("{$existingValueSource}" != attributeValueSource) return false
                     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
index 7499a2b00..1947112d3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
@@ -26,6 +26,7 @@ import com.android.tools.metalava.model.ANDROID_NONNULL
 import com.android.tools.metalava.model.ANDROID_NULLABLE
 import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.ANDROID_TEST_API
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL_ONLY
 import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
@@ -43,17 +44,21 @@ import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.JAVA_LANG_PREFIX
+import com.android.tools.metalava.model.JVM_STATIC
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
 import com.android.tools.metalava.model.RECENTLY_NONNULL
 import com.android.tools.metalava.model.RECENTLY_NULLABLE
-import com.android.tools.metalava.model.SUPPRESS_COMPATIBILITY_ANNOTATION
+import com.android.tools.metalava.model.SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.ShowOrHide
 import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.Showability.Companion.REVERT_UNSTABLE_API
 import com.android.tools.metalava.model.TypedefMode
 import com.android.tools.metalava.model.annotation.DefaultAnnotationManager.Config
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.api.flags.ApiFlags
 import com.android.tools.metalava.model.computeTypeNullability
 import com.android.tools.metalava.model.hasAnnotation
 import com.android.tools.metalava.model.isNonNullAnnotation
@@ -71,7 +76,6 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         val showSingleAnnotations: AnnotationFilter = AnnotationFilter.emptyFilter(),
         val showForStubPurposesAnnotations: AnnotationFilter = AnnotationFilter.emptyFilter(),
         val hideAnnotations: AnnotationFilter = AnnotationFilter.emptyFilter(),
-        val revertAnnotations: AnnotationFilter = AnnotationFilter.emptyFilter(),
         val suppressCompatibilityMetaAnnotations: Set<String> = emptySet(),
         val excludeAnnotations: Set<String> = emptySet(),
         val typedefMode: TypedefMode = TypedefMode.NONE,
@@ -80,6 +84,15 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
          * Provider of an optional [Codebase] object that will be used when reverting flagged APIs.
          */
         val previouslyReleasedCodebaseProvider: () -> Codebase? = { null },
+
+        /**
+         * The set of available [ApiFlag]s.
+         *
+         * If this is `null` then no [ApiFlag]s have been provided, otherwise it contains an
+         * [ApiFlag] for every provided flag. Flags that are not provided will default to
+         * [ApiFlag.REVERT_FLAGGED_API].
+         */
+        val apiFlags: ApiFlags? = null,
     )
 
     /**
@@ -110,23 +123,36 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             }
         }
 
-        // Iterate over all the annotation names matched by all the filters currently used by
-        // [LazyAnnotationInfo] and associate them with a [KeyFactory] that will use the complete
-        // source representation of the annotation as the key. This is needed because filters can
-        // match on attribute values as well as the name.
+        // The list of all filters.
         val filters =
-            arrayOf(
+            listOf(
                 config.allShowAnnotations,
                 config.showSingleAnnotations,
                 config.showForStubPurposesAnnotations,
                 config.hideAnnotations,
-                config.revertAnnotations,
             )
-        annotationNameToKeyFactory =
-            filters
-                .asSequence()
-                .flatMap { it.getIncludedAnnotationNames().asSequence() }
-                .associate { Pair(it, ::useSourceAsKey) }
+
+        // Build a list of the names of annotations whose AnnotationInfo could be dependent on an
+        // annotation attributes and not just its name.
+        val annotationNames = buildList {
+            // Iterate over all the annotation names matched by all the filters currently used by
+            // [LazyAnnotationInfo] and associate them with a [KeyFactory] that will use the
+            // complete source representation of the annotation as the key. This is needed because
+            // filters can match on attribute values as well as the name.
+            for (filter in filters) {
+                addAll(filter.getIncludedAnnotationNames())
+            }
+
+            // ApiFlags have been provided so the flag name specified on an
+            // `android.annotation.FlaggedApi` will affect the state of the associated
+            // AnnotationInfo so make sure to use the flag name in the cache key for `FlaggedApi`
+            // annotations.
+            if (config.apiFlags != null) add(ANDROID_FLAGGED_API)
+        }
+
+        // Use KeyFactory that uses the complete source representation as the key and not just the
+        // annotation name which is the default.
+        annotationNameToKeyFactory = annotationNames.associateWith { ::useSourceAsKey }
     }
 
     override fun getKeyForAnnotationItem(annotationItem: AnnotationItem): String {
@@ -201,6 +227,10 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "android.annotation.Px" -> return "androidx.annotation.Px"
             "android.annotation.Dimension" -> return "androidx.annotation.Dimension"
 
+            // Environments
+            "android.annotation.RestrictedForEnvironment" ->
+                return "androidx.annotation.RestrictedForEnvironment"
+
             // Null
             // Preserve recently/newly nullable annotation as they need to be passed through to
             // stubs. They will be treated as nullable/non-null just as if they were mapped to
@@ -273,16 +303,14 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
 
             // This implementation only annotation shouldn't be used by metalava at all.
             "dalvik.annotation.codegen.CovariantReturnType" -> return null
+
+            // TODO(b/399105459): remove this workaround once there is full support for typealias
+            //  annotations from the classpath
+            "kotlin.jvm.JvmRepeatable" -> return "java.lang.annotation.Repeatable"
             else -> {
                 // Some new annotations added to the platform: assume they are support
                 // annotations?
                 return when {
-                    // Special Kotlin annotations recognized by the compiler: map to supported
-                    // package name
-                    qualifiedName.endsWith(".ParameterName") ||
-                        qualifiedName.endsWith(".DefaultValue") ->
-                        "kotlin.annotations.jvm.internal${qualifiedName.substring(qualifiedName.lastIndexOf('.'))}"
-
                     // Other third party nullness annotations?
                     isNullableAnnotation(qualifiedName) -> ANDROIDX_NULLABLE
                     isNonNullAnnotation(qualifiedName) -> ANDROIDX_NONNULL
@@ -361,6 +389,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "androidx.annotation.StringDef",
             "android.annotation.LongDef",
             "androidx.annotation.LongDef" -> return TYPEDEF_ANNOTATION_TARGETS
+            "android.annotation.RestrictedForEnvironment" -> return ANNOTATION_EXTERNAL
 
             // Not directly API relevant
             "android.view.ViewDebug.ExportedProperty",
@@ -371,18 +400,9 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             // from those. This is useful for modularizing the main SDK stubs without having to
             // add a separate module SDK artifact for sdk constants.
             "android.annotation.SdkConstant" -> return ANNOTATION_SDK_STUBS_ONLY
-            ANDROID_FLAGGED_API ->
-                // If FlaggedApi annotations are being reverted in general then do not output them
-                // at all. This means that if some FlaggedApi annotations with specific flags are
-                // not reverted then the annotations will not be written out to the signature or
-                // stub files. That is the correct behavior as those APIs are intended to be
-                // released and should look like any other released API and released APIs do not
-                // include FlaggedApi annotations.
-                if (config.revertAnnotations.matchesAnnotationName(ANDROID_FLAGGED_API)) {
-                    return NO_ANNOTATION_TARGETS
-                } else {
-                    return ANNOTATION_IN_ALL_STUBS
-                }
+            ANDROID_FLAGGED_API -> {
+                return annotation.apiFlag?.annotationTargets ?: ANNOTATION_IN_ALL_STUBS
+            }
 
             // Skip known annotations that we (a) never want in external annotations and (b) we
             // are
@@ -435,7 +455,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             // annotations.
             "kotlin.jvm.JvmOverloads",
             "kotlin.jvm.JvmField",
-            "kotlin.jvm.JvmStatic",
+            JVM_STATIC,
             "kotlin.jvm.JvmName" -> return NO_ANNOTATION_TARGETS
         }
 
@@ -514,22 +534,23 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
     override fun isShowAnnotationName(annotationName: String): Boolean =
         config.allShowAnnotations.matchesAnnotationName(annotationName)
 
+    /** Check whether this has been configured in a way that could cause items to be reverted. */
+    private fun couldRevertItems(): Boolean = config.apiFlags != null
+
     override fun hasAnyStubPurposesAnnotations(): Boolean {
-        // Revert annotations are checked because they can behave like
-        // `--show-for-stub-purposes-annotation` if they end up reverting an API that was added in
-        // an extended API. e.g. if a change to item `X` from the public API was reverted then the
+        // This checks if items can be reverted because they can behave like
+        // `--show-for-stub-purposes-annotation` if a reverted Item was added in an extended API.
+        // e.g. if a change to item `X` from the public API was reverted then the
         // previously released version `X'` will need to be written out to the stubs for the system
         // API, just as if it was annotated with an annotation from
         // `--show-for-stub-purposes-annotation`.
-        return config.showForStubPurposesAnnotations.isNotEmpty() ||
-            config.revertAnnotations.isNotEmpty()
+        return config.showForStubPurposesAnnotations.isNotEmpty() || couldRevertItems()
     }
 
     override fun hasHideAnnotations(modifiers: ModifierList): Boolean {
-        // If there are no hide annotations or revert annotations registered then this can never
-        // return true. Revert annotations are checked because they can behave like hide if they end
-        // up reverting a newly added API.
-        if (config.hideAnnotations.isEmpty() && config.revertAnnotations.isEmpty()) {
+        // If there are no hide annotations and items cannot be reverted then this can never return
+        // true. Reverted items can behave as if they are hidden it they are newly added.
+        if (config.hideAnnotations.isEmpty() && !couldRevertItems()) {
             return false
         }
         return modifiers.hasAnnotation(AnnotationItem::isHideAnnotation)
@@ -574,22 +595,20 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
                             previouslyReleasedCodebase == null)
                 }
             if (revertUnstableApi) {
-                itemShowability =
-                    itemShowability.combineWith(LazyAnnotationInfo.REVERT_UNSTABLE_API)
+                itemShowability = itemShowability.combineWith(REVERT_UNSTABLE_API)
             }
         }
 
         val containingClass = item.containingClass()
         if (containingClass != null) {
             if (containingClass.showability.revertUnstableApi()) {
-                itemShowability =
-                    itemShowability.combineWith(LazyAnnotationInfo.REVERT_UNSTABLE_API)
+                itemShowability = itemShowability.combineWith(REVERT_UNSTABLE_API)
             }
         }
 
         // If the item is to be reverted then find the [Item] to which it will be reverted, if any,
         // and incorporate that into the [Showability].
-        if (itemShowability == LazyAnnotationInfo.REVERT_UNSTABLE_API) {
+        if (itemShowability == REVERT_UNSTABLE_API) {
             val revertItem = findRevertItem(item)
 
             // If the [revertItem] cannot be found then there is no need to modify the item
@@ -618,6 +637,9 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
                         // Incorporate the item to be reverted into the [Showability].
                         revertItem = revertItem,
                     )
+
+                // The codebase contains items which are to be reverted.
+                item.codebase.markContainsRevertedItem()
             }
         }
 
@@ -681,11 +703,24 @@ private class LazyAnnotationInfo(
                 config.showForStubPurposesAnnotations.matches(annotationItem) -> SHOW_FOR_STUBS
                 config.showSingleAnnotations.matches(annotationItem) -> SHOW_SINGLE
                 config.hideAnnotations.matches(annotationItem) -> HIDE
-                config.revertAnnotations.matches(annotationItem) -> REVERT_UNSTABLE_API
-                else -> Showability.NO_EFFECT
+                else -> {
+                    // Check flags before using default
+                    apiFlag?.showability ?: Showability.NO_EFFECT
+                }
             }
         }
 
+    override val apiFlag by lazy(LazyThreadSafetyMode.NONE) { getFlagForAnnotation(annotationItem) }
+
+    private fun getFlagForAnnotation(annotationItem: AnnotationItem): ApiFlag? {
+        if (annotationItem.qualifiedName != ANDROID_FLAGGED_API) return null
+        val apiFlags = config.apiFlags ?: return null
+        val valueAttribute =
+            annotationItem.attributes.find { it.name == ANNOTATION_ATTR_VALUE } ?: return null
+        val flagName = valueAttribute.legacyValue.value() as String
+        return apiFlags[flagName]
+    }
+
     companion object {
         /**
          * The annotation will cause the annotated item (and any enclosed items unless overridden by
@@ -727,26 +762,6 @@ private class LazyAnnotationInfo(
                 recursive = ShowOrHide.HIDE,
                 forStubsOnly = ShowOrHide.NO_EFFECT,
             )
-
-        /**
-         * The annotation will cause the annotated item (and any enclosed items unless overridden by
-         * a closer annotation) to not be shown.
-         */
-        val REVERT_UNSTABLE_API =
-            Showability(
-                show = ShowOrHide.REVERT_UNSTABLE_API,
-                recursive = ShowOrHide.REVERT_UNSTABLE_API,
-                forStubsOnly = ShowOrHide.REVERT_UNSTABLE_API,
-            )
-
-        /**
-         * Fully-qualified version of [SUPPRESS_COMPATIBILITY_ANNOTATION].
-         *
-         * This is only used at run-time for matching against [AnnotationItem.qualifiedName], so it
-         * doesn't need to maintain compatibility.
-         */
-        private val SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED =
-            AnnotationItem.unshortenAnnotation("@$SUPPRESS_COMPATIBILITY_ANNOTATION").substring(1)
     }
 
     /** Resolve the [AnnotationItem] to a [ClassItem] lazily. */
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt
new file mode 100644
index 000000000..e9ea46497
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.flags
+
+import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
+import com.android.tools.metalava.model.AnnotationTarget
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
+import com.android.tools.metalava.model.Showability
+
+/**
+ * The available set of configured [ApiFlag]s.
+ *
+ * @param byQualifiedName map from qualified flag name to [ApiFlag].
+ */
+class ApiFlags(val byQualifiedName: Map<String, ApiFlag>) {
+    /**
+     * Get the [ApiFlag] by qualified name.
+     *
+     * If no such [ApiFlag] exists then return [ApiFlag.REVERT_FLAGGED_API].
+     */
+    operator fun get(qualifiedName: String) =
+        byQualifiedName[qualifiedName] ?: ApiFlag.REVERT_FLAGGED_API
+
+    override fun toString(): String {
+        return "ApiFlags(byQualifiedName=$byQualifiedName)"
+    }
+}
+
+/** A representation of an [ApiFlag] that is associated with an `@FlaggedApi` annotation. */
+class ApiFlag
+private constructor(
+    /**
+     * The qualified name of the flag.
+     *
+     * Provided for debug purposes only and cannot be relied upon to be the name of an actual flag,
+     * e.g. [REVERT_FLAGGED_API]'s [qualifiedName] is simply `<disabled>`.
+     */
+    val description: String,
+
+    /**
+     * The [Showability] of any [Item]s annotated with an `@FlaggedApi` annotation that references
+     * this [ApiFlag].
+     */
+    val showability: Showability,
+
+    /** Controls whether `@FlaggedApi` annotations for this [ApiFlag] are kept or discarded. */
+    val annotationTargets: Set<AnnotationTarget>,
+) {
+    override fun toString(): String {
+        return "ApiFlag(description='$description')"
+    }
+
+    companion object {
+        /** Revert any associated [Item]s. */
+        val REVERT_FLAGGED_API =
+            ApiFlag(
+                "<revert>",
+                showability = Showability.REVERT_UNSTABLE_API,
+                annotationTargets = NO_ANNOTATION_TARGETS
+            )
+
+        /** Keep any associated [Item]s and their `@FlaggedApi` annotation. */
+        val KEEP_FLAGGED_API =
+            ApiFlag(
+                "<keep>",
+                showability = Showability.NO_EFFECT,
+                annotationTargets = ANNOTATION_IN_ALL_STUBS,
+            )
+
+        /**
+         * Keep any associated [Item]s but remove their `@FlaggedApi` annotation as this is being
+         * (or has been) finalized.
+         */
+        val FINALIZE_FLAGGED_API =
+            ApiFlag(
+                "<finalize>",
+                showability = Showability.NO_EFFECT,
+                annotationTargets = NO_ANNOTATION_TARGETS,
+            )
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt
index b65d6a7c2..54da5bfea 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt
@@ -16,8 +16,12 @@
 
 package com.android.tools.metalava.model.api.surface
 
-/** A specific API surface. */
-sealed interface ApiSurface {
+/**
+ * A specific API surface.
+ *
+ * Their natural ordering is determined by the order in which they were created in [surfaces].
+ */
+sealed interface ApiSurface : Comparable<ApiSurface> {
     /** The set of [ApiSurface]s to which this belongs. */
     val surfaces: ApiSurfaces
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt
index 6d1cf3acd..788deaf16 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt
@@ -37,7 +37,31 @@ sealed interface ApiSurfaces {
     /** An immutable, empty set of variants. */
     val emptyVariantSet: ApiVariantSet
 
+    /** Map from [ApiSurface.name] to [ApiSurface]. */
+    val byName: Map<String, ApiSurface>
+
     companion object {
+        /** Returns a simple initializer for use with [build]. */
+        private fun simpleSurfacesInitializer(needsBase: Boolean): Builder.() -> Unit = {
+            val extends =
+                if (needsBase) {
+                    createSurface(
+                        "base",
+                        extends = null,
+                        isMain = false,
+                    )
+                    "base"
+                } else {
+                    null
+                }
+
+            createSurface(
+                "main",
+                extends = extends,
+                isMain = true,
+            )
+        }
+
         /**
          * Create an [ApiSurfaces] instance.
          *
@@ -45,7 +69,11 @@ sealed interface ApiSurfaces {
          *   is null, otherwise it is an [ApiSurface] that the [ApiSurfaces.main] references in its
          *   [ApiSurface.extends] property.
          */
-        fun create(needsBase: Boolean = false): ApiSurfaces = DefaultApiSurfaces(needsBase)
+        fun create(needsBase: Boolean = false): ApiSurfaces =
+            build(simpleSurfacesInitializer(needsBase))
+
+        /** Create an [ApiSurfaces] instance using a [Builder]. */
+        fun build(initializer: Builder.() -> Unit): ApiSurfaces = DefaultApiSurfaces(initializer)
 
         /**
          * A default set of [ApiSurface]s.
@@ -55,94 +83,158 @@ sealed interface ApiSurfaces {
         val DEFAULT = create()
     }
 
-    /** Default implementation of [ApiSurfaces]. */
-    private class DefaultApiSurfaces(needsBase: Boolean) : ApiSurfaces {
+    /**
+     * Provides support for creating a more complicated [ApiSurfaces] instance than is supported by
+     * [create].
+     */
+    interface Builder {
+        /**
+         * Create an [ApiSurface] with the specified [name] which has an optional [extends].
+         *
+         * If [extends] is not `null` then the referenced [ApiSurface] must already have been
+         * created with this method.
+         *
+         * If the surface is the one to be created then [isMain] must be `true`. Exactly one surface
+         * can have [isMain] set to `true`, none or more than one will fail.
+         */
+        fun createSurface(name: String, extends: String? = null, isMain: Boolean = false)
+    }
+}
 
-        override val all: List<DefaultApiSurface>
+/** Default implementation of [ApiSurfaces]. */
+private class DefaultApiSurfaces(initializer: ApiSurfaces.Builder.() -> Unit) : ApiSurfaces {
 
-        override val base: DefaultApiSurface?
+    override val all: List<DefaultApiSurface>
 
-        override val main: DefaultApiSurface
+    override val base: DefaultApiSurface?
 
-        override val variants: List<ApiVariant>
+    override val main: DefaultApiSurface
 
-        init {
-            val surfaceList = mutableListOf<DefaultApiSurface>()
+    override val variants: List<ApiVariant>
 
-            // The list of all ApiVariants belonging to this. Will be populated in the
-            // DefaultApiSurface initializer.
-            val allVariants = mutableListOf<ApiVariant>()
+    override val byName: Map<String, ApiSurface>
 
-            /**
-             * Create an [ApiSurface] with the specified [name] which has an optional [extends].
-             *
-             * Adds the created [ApiSurface] to [all].
-             */
-            fun createSurface(name: String, extends: DefaultApiSurface?) =
-                DefaultApiSurface(
-                        surfaces = this,
-                        name = name,
-                        extends = extends,
-                        allVariants = allVariants,
-                    )
-                    .also { surfaceList.add(it) }
+    init {
+        // Create a builder for this.
+        val builder = BuilderImpl(this)
 
-            base =
-                if (needsBase)
-                    createSurface(
-                        "base",
-                        extends = null,
-                    )
-                else null
+        // Invoke the initializer on the builder.
+        builder.initializer()
 
-            main =
-                createSurface(
-                    "main",
-                    extends = base,
-                )
+        // Populate the fields from the builder.
+        main = builder.mainSurface
+        base = main.extends
 
-            all = surfaceList.toList()
-            variants = allVariants.toList()
-        }
+        all = builder.all
+        variants = builder.variants
 
-        override val emptyVariantSet: ApiVariantSet = ApiVariantSet.emptySet(this)
+        byName = all.associateBy { it.name }
     }
 
-    /**
-     * Default implementation of [ApiSurface].
-     *
-     * @param allVariants the list of all [ApiVariant]s belonging to [surfaces]. This must be
-     *   initialised with all the [ApiVariant]s belonging to this [ApiSurface].
-     */
-    private class DefaultApiSurface(
-        override val surfaces: ApiSurfaces,
-        override val name: String,
-        override val extends: DefaultApiSurface?,
-        allVariants: MutableList<ApiVariant>,
-    ) : ApiSurface {
+    override val emptyVariantSet: ApiVariantSet = ApiVariantSet.emptySet(this)
+
+    /** Provides support for initializing [apiSurfaces] by implementing [ApiSurfaces.Builder]. */
+    private class BuilderImpl(private val apiSurfaces: DefaultApiSurfaces) : ApiSurfaces.Builder {
+        /** Map from name to [DefaultApiSurface]. */
+        private val nameToSurface = mutableMapOf<String, DefaultApiSurface>()
 
         /**
-         * Create a list of [ApiVariant]s for this surface, one for each [ApiVariantType]. Each
-         * [ApiVariant] will add themselves to the `allVariants` list that contains all the
-         * [ApiVariant]s belong to [surfaces].
+         * The list of all ApiVariants belonging to this. Will be populated in the DefaultApiSurface
+         * initializer.
          */
-        override val variants =
-            ApiVariantType.values().map { type -> ApiVariant(this, type, allVariants) }
-
-        override val variantSet =
-            // Create an ApiVariantSet that contains all ApiVariants in this surface.
-            ApiVariantSet.build(surfaces) {
-                for (variant in variants) {
-                    add(variant)
+        private val allVariants = mutableListOf<ApiVariant>()
+
+        /** Backing property for [mainSurface]. */
+        private lateinit var _mainSurface: DefaultApiSurface
+
+        /** Get the main surface, error if none has been set. */
+        val mainSurface
+            get() =
+                if (::_mainSurface.isInitialized) _mainSurface
+                else error("No call to createSurface() set isMain to true")
+
+        /** Get the list of all the [DefaultApiSurface]s added to this. */
+        val all
+            get() = nameToSurface.values.toList()
+
+        /** Get the list of all the [ApiVariant]s of all the [DefaultApiSurface]s. */
+        val variants
+            get() = allVariants.toList()
+
+        override fun createSurface(name: String, extends: String?, isMain: Boolean) {
+            val existing = nameToSurface[name]
+            if (existing != null) error("Duplicate surfaces called `$name`")
+
+            val extendsSurface =
+                extends?.let {
+                    nameToSurface[it]
+                        ?: error("Unknown extends surface `$it` referenced from `$name`")
                 }
+
+            val index = nameToSurface.size
+            val surface =
+                DefaultApiSurface(
+                    apiSurfaces,
+                    index,
+                    name,
+                    extendsSurface,
+                    isMain,
+                    allVariants,
+                )
+            nameToSurface[name] = surface
+
+            if (isMain) {
+                if (::_mainSurface.isInitialized)
+                    error(
+                        "Main surface already set to `${_mainSurface.name}`, cannot set to `$name`"
+                    )
+                _mainSurface = surface
             }
+        }
+    }
+}
 
-        override fun variantFor(type: ApiVariantType): ApiVariant {
-            return variants[type.ordinal]
+/**
+ * Default implementation of [ApiSurface].
+ *
+ * @param index the index of this within the [ApiSurfaces], used to sort [ApiSurface] by order they
+ *   were added to [ApiSurfaces].
+ * @param allVariants the list of all [ApiVariant]s belonging to [surfaces]. This must be
+ *   initialised with all the [ApiVariant]s belonging to this [ApiSurface].
+ */
+private class DefaultApiSurface(
+    override val surfaces: ApiSurfaces,
+    private val index: Int,
+    override val name: String,
+    override val extends: DefaultApiSurface?,
+    override val isMain: Boolean,
+    allVariants: MutableList<ApiVariant>,
+) : ApiSurface {
+
+    /**
+     * Create a list of [ApiVariant]s for this surface, one for each [ApiVariantType]. Each
+     * [ApiVariant] will add themselves to the `allVariants` list that contains all the
+     * [ApiVariant]s belong to [surfaces].
+     */
+    override val variants =
+        ApiVariantType.entries.map { type -> ApiVariant(this, type, allVariants) }
+
+    override val variantSet =
+        // Create an ApiVariantSet that contains all ApiVariants in this surface.
+        ApiVariantSet.build(surfaces) {
+            for (variant in variants) {
+                add(variant)
+            }
         }
 
-        override val isMain = name == "main"
+    override fun variantFor(type: ApiVariantType): ApiVariant {
+        return variants[type.ordinal]
+    }
 
-        override fun toString(): String = "ApiSurface($name)"
+    /** * Order by index within [surfaces]. */
+    override fun compareTo(other: ApiSurface): Int {
+        return index.compareTo((other as DefaultApiSurface).index)
     }
+
+    override fun toString(): String = "ApiSurface($name)"
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
index 26e18ccf8..d3948e681 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
@@ -73,7 +73,8 @@ open class DefaultClassItem(
         // fileLocation, both of which have been initialized. If registration succeeded then wire
         // the class into the containing package/containing class. If it failed, because it is a
         // duplicate, then do nothing.
-        if (codebase.registerClass(@Suppress("LeakingThis") this)) {
+        @Suppress("LeakingThis") val classItem = this
+        if (codebase.registerClass(classItem)) {
             // Only emit classes that were specified on the command line.
             emit = emit && origin == ClassOrigin.COMMAND_LINE
 
@@ -83,10 +84,10 @@ open class DefaultClassItem(
             }
 
             if (containingClass == null) {
-                (containingPackage as DefaultPackageItem).addTopClass(this)
+                (containingPackage as DefaultPackageItem).addTopClass(classItem)
                 fullName = simpleName
             } else {
-                (containingClass as DefaultClassItem).addNestedClass(this)
+                (containingClass as DefaultClassItem).addNestedClass(classItem)
                 fullName = "${containingClass.fullName()}.$simpleName"
             }
         } else {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
index 4c5ba3bda..109bf275f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
@@ -58,6 +59,13 @@ open class DefaultCodebase(
         description += " [disposed]"
     }
 
+    final override var containsRevertedItem: Boolean = false
+        private set
+
+    override fun markContainsRevertedItem() {
+        containsRevertedItem = true
+    }
+
     override val reporter: Reporter = config.reporter
 
     /** Tracks [DefaultPackageItem] use in this [Codebase]. */
@@ -74,17 +82,12 @@ open class DefaultCodebase(
         packageDocs: PackageDocs = PackageDocs.EMPTY,
     ) = packageTracker.findOrCreatePackage(packageName, packageDocs)
 
-    /** Add the package to this. */
-    fun addPackage(packageItem: DefaultPackageItem) {
-        packageTracker.addPackage(packageItem)
-    }
-
     /**
      * Map from fully qualified name to [DefaultClassItem] for every class created by this.
      *
      * Classes are added via [registerClass] while initialising the codebase.
      */
-    protected val allClassesByName = HashMap<String, DefaultClassItem>(CLASS_ESTIMATE)
+    private val allClassesByName = HashMap<String, DefaultClassItem>(CLASS_ESTIMATE)
 
     /** Find a class created by this [Codebase]. */
     fun findClassInCodebase(className: String) = allClassesByName[className]
@@ -109,6 +112,24 @@ open class DefaultCodebase(
         }
     }
 
+    /** Tracks all known type aliases in the codebase by qualified name. */
+    private val allTypeAliasesByName = HashMap<String, DefaultTypeAliasItem>()
+
+    override fun findTypeAlias(typeAliasName: String): TypeAliasItem? {
+        return allTypeAliasesByName[typeAliasName]
+    }
+
+    /**
+     * Adds the [typeAlias] to the [Codebase], throwing an error if there is already a type alias
+     * with the same qualified name.
+     */
+    internal fun addTypeAlias(typeAlias: DefaultTypeAliasItem) {
+        if (typeAlias.qualifiedName in allTypeAliasesByName) {
+            error("Duplicate typealias ${typeAlias.qualifiedName}")
+        }
+        allTypeAliasesByName[typeAlias.qualifiedName] = typeAlias
+    }
+
     /**
      * Look for classes in this [Codebase].
      *
@@ -158,21 +179,21 @@ open class DefaultCodebase(
      * Looks for an existing class in this [Codebase] and if that cannot be found then delegate to
      * the [assembler] to see if it can create a class from the underlying model.
      */
-    final override fun resolveClass(className: String): ClassItem? {
-        findClass(className)?.let {
+    final override fun resolveClass(erasedName: String): ClassItem? {
+        findClass(erasedName)?.let {
             return it
         }
-        val created = assembler.createClassFromUnderlyingModel(className) ?: return null
+        val created = assembler.createClassFromUnderlyingModel(erasedName) ?: return null
         // If the returned class was not created as part of this Codebase then register it as an
         // external class so that findClass(...) will find it next time.
         if (created.codebase !== this) {
             // Register as an external class.
-            externalClassesByName[className] = created
+            externalClassesByName[erasedName] = created
         }
         return created
     }
 
-    open override fun createAnnotation(
+    override fun createAnnotation(
         source: String,
         context: Item?,
     ): AnnotationItem? {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
index 0e0da4166..3298f1da3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
@@ -37,7 +37,7 @@ open class DefaultFieldItem(
     containingClass: ClassItem,
     private var type: TypeItem,
     private val isEnumConstant: Boolean,
-    override val fieldValue: FieldValue?,
+    override val legacyFieldValue: FieldValue?,
 ) :
     DefaultMemberItem(
         codebase = codebase,
@@ -71,12 +71,12 @@ open class DefaultFieldItem(
                 containingClass = targetContainingClass,
                 type = type,
                 isEnumConstant = isEnumConstant,
-                fieldValue = fieldValue,
+                legacyFieldValue = legacyFieldValue,
             )
             .also { duplicated -> duplicated.inheritedFrom = containingClass() }
 
-    final override fun initialValue(requireConstant: Boolean) =
-        fieldValue?.initialValue(requireConstant)
+    final override fun legacyInitialValue(requireConstant: Boolean) =
+        legacyFieldValue?.initialValue(requireConstant)
 
     final override fun isEnumConstant(): Boolean = isEnumConstant
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
index cda2d6450..98bfd37c9 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
@@ -37,6 +37,7 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.reporter.FileLocation
@@ -215,7 +216,7 @@ class DefaultItemFactory(
         containingCallable: CallableItem,
         parameterIndex: Int,
         type: TypeItem,
-        defaultValueFactory: DefaultValueFactory,
+        defaultValueFactory: ParameterDefaultValueFactory,
     ): ParameterItem =
         DefaultParameterItem(
             codebase,
@@ -239,6 +240,8 @@ class DefaultItemFactory(
         name: String,
         containingClass: ClassItem,
         type: TypeItem,
+        receiver: TypeItem?,
+        typeParameterList: TypeParameterList,
         getter: MethodItem? = null,
         setter: MethodItem? = null,
         constructorParameter: ParameterItem? = null,
@@ -258,6 +261,30 @@ class DefaultItemFactory(
             setter,
             constructorParameter,
             backingField,
+            receiver,
+            typeParameterList,
+        )
+
+    /** Create a [TypeAliasItem]. */
+    fun createTypeAliasItem(
+        fileLocation: FileLocation,
+        modifiers: BaseModifierList,
+        qualifiedName: String,
+        containingPackage: DefaultPackageItem,
+        aliasedType: TypeItem,
+        typeParameterList: TypeParameterList,
+        documentationFactory: ItemDocumentationFactory = ItemDocumentation.NONE_FACTORY,
+    ): TypeAliasItem =
+        DefaultTypeAliasItem(
+            codebase,
+            fileLocation,
+            modifiers,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            aliasedType,
+            qualifiedName,
+            typeParameterList,
+            containingPackage
         )
 
     /**
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
index e94945cb0..d74f5e45d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
@@ -66,7 +66,7 @@ open class DefaultMethodItem(
 
     override fun isExtensionMethod(): Boolean = false // java does not support extension methods
 
-    override fun defaultValue() = annotationDefault
+    override fun legacyDefaultValue() = annotationDefault
 
     private lateinit var superMethodList: List<MethodItem>
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
index 645d92367..0a62b6183 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
@@ -23,6 +23,7 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultPackageItem(
@@ -49,7 +50,7 @@ open class DefaultPackageItem(
     init {
         // Newly created package's always have `emit = false` as they should only be emitted if they
         // have at least one class that has `emit = true`. That will be updated, if necessary, when
-        // adding a class to the package.
+        // adding a class or type alias to the package.
         emit = false
     }
 
@@ -71,4 +72,14 @@ open class DefaultPackageItem(
     fun addTopClass(classItem: ClassItem) {
         topClasses.add(classItem)
     }
+
+    private val typeAliases = mutableListOf<TypeAliasItem>()
+
+    internal fun addTypeAlias(typeAlias: DefaultTypeAliasItem) {
+        typeAliases += typeAlias
+    }
+
+    override fun typeAliases(): List<TypeAliasItem> {
+        return typeAliases.toList()
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
index 6ce0fdc38..18aea2abd 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
@@ -38,7 +38,7 @@ open class DefaultParameterItem(
     private val containingCallable: CallableItem,
     override val parameterIndex: Int,
     private var type: TypeItem,
-    defaultValueFactory: DefaultValueFactory,
+    defaultValueFactory: ParameterDefaultValueFactory,
 ) :
     DefaultItem(
         codebase = codebase,
@@ -55,8 +55,8 @@ open class DefaultParameterItem(
     }
 
     /**
-     * Create the [DefaultValue] during initialization of this parameter to allow it to contain an
-     * immutable reference to this object.
+     * Create the [ParameterDefaultValue] during initialization of this parameter to allow it to
+     * contain an immutable reference to this object.
      */
     final override val defaultValue = defaultValueFactory(this)
 
@@ -74,10 +74,6 @@ open class DefaultParameterItem(
 
     final override fun hasDefaultValue(): Boolean = defaultValue.hasDefaultValue()
 
-    final override fun isDefaultValueKnown(): Boolean = defaultValue.isDefaultValueKnown()
-
-    final override fun defaultValueAsString(): String? = defaultValue.value()
-
     override fun duplicate(
         containingCallable: CallableItem,
         typeVariableMap: TypeParameterBindings,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
index 5317bdf6d..301c03f28 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
@@ -27,6 +27,7 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultPropertyItem(
@@ -43,6 +44,8 @@ open class DefaultPropertyItem(
     override val setter: MethodItem?,
     override val constructorParameter: ParameterItem?,
     override val backingField: FieldItem?,
+    override val receiver: TypeItem?,
+    override val typeParameterList: TypeParameterList,
 ) :
     DefaultMemberItem(
         codebase,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt
new file mode 100644
index 000000000..876fa0db9
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.TypeAliasItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultTypeAliasItem(
+    codebase: DefaultCodebase,
+    fileLocation: FileLocation,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    final override val aliasedType: TypeItem,
+    final override val qualifiedName: String,
+    final override val typeParameterList: TypeParameterList,
+    private val containingPackage: DefaultPackageItem,
+) :
+    TypeAliasItem,
+    DefaultSelectableItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        // Type aliases only exist in Kotlin
+        itemLanguage = ItemLanguage.KOTLIN,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
+    ) {
+
+    init {
+        // Register the new type alias with the codebase and package. Leaking `this` is ok as it
+        // only uses its qualified name, which has been initialized.
+        codebase.addTypeAlias(@Suppress("LeakingThis") this)
+        containingPackage.addTypeAlias(@Suppress("LeakingThis") this)
+
+        // If this type alias is emittable then make sure its package is too.
+        if (emit) {
+            containingPackage.emit = true
+        }
+    }
+
+    override val simpleName: String = qualifiedName.substringAfterLast(".")
+
+    override fun containingPackage(): PackageItem = containingPackage
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt
deleted file mode 100644
index aea824c63..000000000
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.item
-
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.FixedDefaultValue
-import com.android.tools.metalava.model.ParameterItem
-
-/**
- * A lamda that given a [ParameterItem] will create a [DefaultValue] for it.
- *
- * This is called from within the constructor of the [ParameterItem] and should not access any
- * properties of [ParameterItem] as they may not have been initialized. This should just store a
- * reference for later use.
- */
-typealias DefaultValueFactory = (ParameterItem) -> DefaultValue
-
-/**
- * Represents a parameter's default value.
- *
- * TODO: Investigate this abstraction to see if it matches what we need. It is a little confusing as
- *   [hasDefaultValue] and [isDefaultValueKnown] seem like they should be different but are
- *   implemented in Psi and Turbine to be identical.
- */
-interface DefaultValue {
-
-    /** A [DefaultValue] to use for a parameter that has no default value. */
-    @Suppress("ConvertObjectToDataObject") // Requires language level 1.9
-    object NONE : DefaultValue {
-        override fun hasDefaultValue() = false
-
-        override fun isDefaultValueKnown() = false
-
-        override fun value() = error("cannot call on NONE DefaultValue")
-
-        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
-        override fun duplicate(parameter: ParameterItem) = this
-
-        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
-        override fun snapshot(parameter: ParameterItem) = this
-
-        override fun toString() = "NONE"
-    }
-
-    /**
-     * A [DefaultValue] to use for a parameter that has a default value but its actual value is not
-     * known.
-     */
-    @Suppress("ConvertObjectToDataObject") // Requires language level 1.9
-    object UNKNOWN : DefaultValue {
-        override fun hasDefaultValue() = true
-
-        override fun isDefaultValueKnown() = false
-
-        override fun value() = error("cannot call on UNKNOWN DefaultValue")
-
-        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
-        override fun duplicate(parameter: ParameterItem) = this
-
-        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
-        override fun snapshot(parameter: ParameterItem) = this
-
-        override fun toString() = "UNKNOWN"
-    }
-
-    companion object {
-        /** Get a [DefaultValue] wrapper around a fixed [String] value. */
-        fun fixedDefaultValue(value: String?): DefaultValue {
-            return FixedDefaultValue(value)
-        }
-    }
-
-    /**
-     * Returns whether this parameter has a default value. In Kotlin, this is supported directly; in
-     * Java, it's supported via a special annotation, {@literal @DefaultValue("source"). This does
-     * not necessarily imply that the default value is accessible, and we know the body of the
-     * default value.
-     *
-     * @see isDefaultValueKnown
-     */
-    fun hasDefaultValue(): Boolean
-
-    /**
-     * Returns whether this parameter has an accessible default value that we plan to keep. This is
-     * a superset of [hasDefaultValue] - if we are not writing the default values to the signature
-     * file, then the default value might not be available, even though the parameter does have a
-     * default.
-     *
-     * @see hasDefaultValue
-     */
-    fun isDefaultValueKnown(): Boolean
-
-    /**
-     * Returns the default value.
-     *
-     * **This method should only be called if [isDefaultValueKnown] returned true!** (This is
-     * necessary since the null return value is a valid default value separate from no default value
-     * specified.)
-     *
-     * The default value is the source string literal representation of the value, e.g. strings
-     * would be surrounded by quotes, Booleans are the strings "true" or "false", and so on.
-     */
-    fun value(): String?
-
-    /**
-     * Return a duplicate of this instance to use by [parameter] which will be in the same type of
-     * [Codebase] as this.
-     */
-    fun duplicate(parameter: ParameterItem): DefaultValue
-
-    /**
-     * Creates a snapshot of this.
-     *
-     * The default implementation assumes that this is either dependent on a model or the codebase
-     * and so creates a new [DefaultValue] based on the functions above.
-     */
-    fun snapshot(parameter: ParameterItem) =
-        when {
-            !hasDefaultValue() -> NONE
-            !isDefaultValueKnown() -> UNKNOWN
-            else -> fixedDefaultValue(value())
-        }
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt
index 5db632df3..4aac53568 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt
@@ -118,7 +118,7 @@ class PackageTracker(private val packageItemFactory: PackageItemFactory) {
             }
 
     /** Add the package to this. */
-    fun addPackage(packageItem: DefaultPackageItem) {
+    private fun addPackage(packageItem: DefaultPackageItem) {
         packagesByName[packageItem.qualifiedName()] = packageItem
     }
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/ParameterDefaultValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/ParameterDefaultValue.kt
new file mode 100644
index 000000000..a80753e8e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/ParameterDefaultValue.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ParameterItem
+
+/**
+ * A lamda that given a [ParameterItem] will create a [ParameterDefaultValue] for it.
+ *
+ * This is called from within the constructor of the [ParameterItem] and should not access any
+ * properties of [ParameterItem] as they may not have been initialized. This should just store a
+ * reference for later use.
+ */
+typealias ParameterDefaultValueFactory = (ParameterItem) -> ParameterDefaultValue
+
+/** Indicates whether a parameter has a default value. */
+interface ParameterDefaultValue {
+
+    /** A [ParameterDefaultValue] to use for a parameter that has no default value. */
+    data object NONE : ParameterDefaultValue {
+        override fun hasDefaultValue() = false
+
+        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
+        override fun duplicate(parameter: ParameterItem) = this
+
+        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
+        override fun snapshot(parameter: ParameterItem) = this
+    }
+
+    /**
+     * A [ParameterDefaultValue] to use for a parameter that has a default value but its actual
+     * value is not known.
+     */
+    data object UNKNOWN : ParameterDefaultValue {
+        override fun hasDefaultValue() = true
+
+        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
+        override fun duplicate(parameter: ParameterItem) = this
+
+        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
+        override fun snapshot(parameter: ParameterItem) = this
+    }
+
+    /**
+     * Returns whether this parameter has a default value.
+     *
+     * This is only supported in Kotlin.
+     */
+    fun hasDefaultValue(): Boolean
+
+    /**
+     * Return a duplicate of this instance to use by [parameter] which will be in the same type of
+     * [Codebase] as this.
+     */
+    fun duplicate(parameter: ParameterItem): ParameterDefaultValue
+
+    /**
+     * Creates a snapshot of this.
+     *
+     * The default implementation assumes that this is either dependent on a model or the codebase
+     * and so creates a new [ParameterDefaultValue] based on the functions above.
+     */
+    fun snapshot(parameter: ParameterItem) =
+        when {
+            !hasDefaultValue() -> NONE
+            else -> UNKNOWN
+        }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
index 8d0bf0811..fb1e25103 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
@@ -36,6 +36,7 @@ import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeParameterListAndFactory
@@ -43,6 +44,7 @@ import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
 import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDoc
@@ -315,7 +317,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                     throwsTypes =
                         methodToSnapshot.throwsTypes().map { typeItemFactory.getExceptionType(it) },
                     callableBodyFactory = methodToSnapshot.body::snapshot,
-                    annotationDefault = methodToSnapshot.defaultValue(),
+                    annotationDefault = methodToSnapshot.legacyDefaultValue(),
                 )
             }
         newMethod.copySelectedApiVariants(methodToSnapshot)
@@ -340,7 +342,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                     containingClass = containingClass,
                     type = fieldToSnapshot.type().snapshot(),
                     isEnumConstant = fieldToSnapshot.isEnumConstant(),
-                    fieldValue = fieldToSnapshot.fieldValue?.snapshot(),
+                    fieldValue = fieldToSnapshot.legacyFieldValue?.snapshot(),
                 )
             }
         newField.copySelectedApiVariants(fieldToSnapshot)
@@ -350,12 +352,18 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
 
     override fun visitProperty(property: PropertyItem) {
         val propertyToSnapshot = property.actualItemToSnapshot
-
         val containingClass = property.containingClass().getSnapshotClass()
+
+        // Create a TypeParameterList and SnapshotTypeItemFactory for the property.
+        val (typeParameterList, propertyTypeItemFactory) =
+            globalTypeItemFactory.from(containingClass).inScope {
+                propertyToSnapshot.typeParameterList.snapshot(propertyToSnapshot.describe())
+            }
+
         val newProperty =
             // Resolve any type parameters used in the property's type within the scope of the
             // containing class's SnapshotTypeItemFactory.
-            globalTypeItemFactory.from(containingClass).inScope {
+            propertyTypeItemFactory.inScope {
                 itemFactory.createPropertyItem(
                     fileLocation = propertyToSnapshot.fileLocation,
                     itemLanguage = propertyToSnapshot.itemLanguage,
@@ -368,6 +376,8 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                     setter = property.setter,
                     constructorParameter = property.constructorParameter,
                     backingField = property.backingField,
+                    receiver = property.receiver?.snapshot(),
+                    typeParameterList = typeParameterList
                 )
             }
         newProperty.copySelectedApiVariants(propertyToSnapshot)
@@ -375,6 +385,30 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
         containingClass.addProperty(newProperty)
     }
 
+    override fun visitTypeAlias(typeAlias: TypeAliasItem) {
+        val typeAliasToSnapshot = typeAlias.actualItemToSnapshot
+        val containingPackage = typeAlias.containingPackage().getSnapshotPackage()
+
+        val (typeParameterList, typeAliasTypeItemFactory) =
+            globalTypeItemFactory.inScope {
+                typeAliasToSnapshot.typeParameterList.snapshot(typeAliasToSnapshot.describe())
+            }
+
+        val newTypeAlias =
+            typeAliasTypeItemFactory.inScope {
+                itemFactory.createTypeAliasItem(
+                    fileLocation = typeAliasToSnapshot.fileLocation,
+                    modifiers = typeAliasToSnapshot.modifiers.snapshot(),
+                    qualifiedName = typeAliasToSnapshot.qualifiedName,
+                    containingPackage = containingPackage as DefaultPackageItem,
+                    aliasedType = typeAliasToSnapshot.aliasedType.snapshot(),
+                    typeParameterList = typeParameterList,
+                    documentationFactory = snapshotDocumentation(typeAliasToSnapshot, typeAlias),
+                )
+            }
+        newTypeAlias.copySelectedApiVariants(typeAliasToSnapshot)
+    }
+
     /** Take a snapshot of [qualifiedName]. */
     override fun createClassFromUnderlyingModel(qualifiedName: String): ClassItem? {
         // Resolve the class in the original codebase, if possible.
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
index 6949e1846..884414060 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
@@ -25,6 +25,7 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.TypeAliasItem
 
 /**
  * A [BaseItemVisitor] that will delegate to [delegate].
@@ -63,7 +64,7 @@ open class NonFilteringDelegatingVisitor(private val delegate: DelegatedVisitor)
         delegate.afterVisitClass(cls)
     }
 
-    override fun visit(constructor: ConstructorItem) {
+    override fun visitConstructor(constructor: ConstructorItem) {
         delegate.visitConstructor(constructor)
     }
 
@@ -78,4 +79,8 @@ open class NonFilteringDelegatingVisitor(private val delegate: DelegatedVisitor)
     override fun visitProperty(property: PropertyItem) {
         delegate.visitProperty(property)
     }
+
+    override fun visitTypeAlias(typeAlias: TypeAliasItem) {
+        delegate.visitTypeAlias(typeAlias)
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
index c2f59fb93..015a8cb43 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
@@ -16,14 +16,14 @@
 
 package com.android.tools.metalava.model.type
 
+import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeModifiers
 
 open class DefaultClassTypeItem(
-    internal val codebase: Codebase,
+    internal val classResolver: ClassResolver,
     modifiers: TypeModifiers,
     final override val qualifiedName: String,
     final override val arguments: List<TypeArgumentTypeItem>,
@@ -32,7 +32,7 @@ open class DefaultClassTypeItem(
     override val className: String = ClassTypeItem.computeClassName(qualifiedName)
 
     private val asClassCache by
-        lazy(LazyThreadSafetyMode.NONE) { codebase.resolveClass(qualifiedName) }
+        lazy(LazyThreadSafetyMode.NONE) { classResolver.resolveClass(qualifiedName) }
 
     override fun asClass() = asClassCache
 
@@ -45,6 +45,12 @@ open class DefaultClassTypeItem(
         outerClassType: ClassTypeItem?,
         arguments: List<TypeArgumentTypeItem>
     ): ClassTypeItem {
-        return DefaultClassTypeItem(codebase, modifiers, qualifiedName, arguments, outerClassType)
+        return DefaultClassTypeItem(
+            classResolver,
+            modifiers,
+            qualifiedName,
+            arguments,
+            outerClassType
+        )
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt
index 30fc1b03b..479b74778 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt
@@ -16,15 +16,15 @@
 
 package com.android.tools.metalava.model.type
 
+import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.LambdaTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeModifiers
 
 class DefaultLambdaTypeItem(
-    codebase: Codebase,
+    classResolver: ClassResolver,
     modifiers: TypeModifiers,
     qualifiedName: String,
     arguments: List<TypeArgumentTypeItem>,
@@ -35,7 +35,7 @@ class DefaultLambdaTypeItem(
     override val returnType: TypeItem,
 ) :
     DefaultClassTypeItem(
-        codebase = codebase,
+        classResolver = classResolver,
         modifiers = modifiers,
         qualifiedName = qualifiedName,
         arguments = arguments,
@@ -53,7 +53,7 @@ class DefaultLambdaTypeItem(
         arguments: List<TypeArgumentTypeItem>
     ): LambdaTypeItem {
         return DefaultLambdaTypeItem(
-            codebase = codebase,
+            classResolver = classResolver,
             qualifiedName = qualifiedName,
             arguments = arguments,
             outerClassType = outerClassType,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
index ed3726130..91e52b8c0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
@@ -127,6 +127,7 @@ open class ApiVisitor(
             packageClassesAsSequence(pkg).mapNotNull { getVisitCandidateIfNeeded(it) }.toList()
 
         // If none of the classes in this package will be visited them ignore the package entirely.
+        // TODO (b/135191699): also check if there are type aliases before returning
         if (classesToVisitDirectly.isEmpty()) return
 
         wrapBodyWithCallsToVisitMethodsForSelectableItem(pkg) {
@@ -134,6 +135,8 @@ open class ApiVisitor(
 
             visitClassList(classesToVisitDirectly)
 
+            pkg.typeAliases().sortedBy { it.simpleName }.forEach { it.accept(this) }
+
             afterVisitPackage(pkg)
         }
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
index 140eea313..4ffadad8f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
@@ -31,6 +31,7 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeTransformer
 import com.android.tools.metalava.model.typeUseAnnotationFilter
@@ -169,6 +170,11 @@ class FilteringApiVisitor(
         delegate.visitProperty(filteringProperty)
     }
 
+    override fun visitTypeAlias(typeAlias: TypeAliasItem) {
+        val filteringTypeAlias = FilteringTypeAliasItem(typeAlias)
+        delegate.visitTypeAlias(filteringTypeAlias)
+    }
+
     /**
      * [SourceFile] that will filter out anything which is not to be written out by the
      * [FilteringApiVisitor.delegate].
@@ -335,4 +341,14 @@ class FilteringApiVisitor(
 
         override fun type() = delegate.type().transform(typeAnnotationFilter)
     }
+
+    /**
+     * [TypeAliasItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringTypeAliasItem(private val delegate: TypeAliasItem) :
+        TypeAliasItem by delegate {
+
+        override fun type() = delegate.type().transform(typeAnnotationFilter)
+    }
 }
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
index 8e6df976e..145c9c750 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
@@ -21,11 +21,10 @@ import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.item.PackageDoc
 import java.io.File
 import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertTrue
 import org.junit.Test
 
-class DefaultAnnotationItemTest {
+class DefaultAnnotationItemTest : Assertions {
     // Placeholder for use in test where we don't need codebase functionality
     private val placeholderCodebase =
         DefaultCodebase(
@@ -66,10 +65,10 @@ class DefaultAnnotationItemTest {
         assertEquals("@androidx.annotation.IntRange(from=20, to=40)", annotation.toSource())
         assertEquals("androidx.annotation.IntRange", annotation.qualifiedName)
         assertEquals(2, annotation.attributes.size)
-        assertEquals("from", annotation.findAttribute("from")?.name)
-        assertEquals("20", annotation.findAttribute("from")?.value.toString())
-        assertEquals("to", annotation.findAttribute("to")?.name)
-        assertEquals("40", annotation.findAttribute("to")?.value.toString())
+        assertEquals("from", annotation.assertAttribute("from").name)
+        assertEquals("20", annotation.assertAttribute("from").legacyValue.toString())
+        assertEquals("to", annotation.assertAttribute("to").name)
+        assertEquals("40", annotation.assertAttribute("to").legacyValue.toString())
     }
 
     @Test
@@ -84,15 +83,14 @@ class DefaultAnnotationItemTest {
         )
         assertEquals("androidx.annotation.IntDef", annotation.qualifiedName)
         assertEquals(1, annotation.attributes.size)
-        val attribute = annotation.findAttribute("value")
-        assertNotNull(attribute)
-        assertEquals("value", attribute?.name)
+        val attribute = annotation.assertAttribute("value")
+        assertEquals("value", attribute.name)
         assertEquals(
             "{STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT}",
-            annotation.findAttribute("value")?.value.toString()
+            attribute.legacyValue.toString()
         )
 
-        assertTrue(attribute?.value is AnnotationArrayAttributeValue)
+        assertTrue(attribute.legacyValue is AnnotationArrayAttributeValue)
         if (attribute is AnnotationArrayAttributeValue) {
             val list = attribute.values
             assertEquals(3, list.size)
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/api/flags/ApiFlagsTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/api/flags/ApiFlagsTest.kt
new file mode 100644
index 000000000..a5b988c1a
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/api/flags/ApiFlagsTest.kt
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.flags
+
+import kotlin.test.assertEquals
+import org.junit.Test
+
+class ApiFlagsTest {
+    @Test
+    fun `Test get`() {
+        val apiFlags =
+            ApiFlags(
+                mapOf(
+                    "test.pkg.flag1" to ApiFlag.KEEP_FLAGGED_API,
+                    "test.pkg.flag2" to ApiFlag.REVERT_FLAGGED_API,
+                    "test.pkg.flag3" to ApiFlag.FINALIZE_FLAGGED_API,
+                )
+            )
+
+        assertEquals(ApiFlag.KEEP_FLAGGED_API, apiFlags["test.pkg.flag1"])
+        assertEquals(ApiFlag.REVERT_FLAGGED_API, apiFlags["test.pkg.flag2"])
+        assertEquals(ApiFlag.FINALIZE_FLAGGED_API, apiFlags["test.pkg.flag3"])
+        // Unknown flags default to reverting.
+        assertEquals(ApiFlag.REVERT_FLAGGED_API, apiFlags["test.pkg.flag4"])
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiSurfacesTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiSurfacesTest.kt
new file mode 100644
index 000000000..a8c082489
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiSurfacesTest.kt
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertNotNull
+import kotlin.test.assertNull
+import kotlin.test.assertSame
+import kotlin.test.assertTrue
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+class ApiSurfacesTest {
+    /**
+     * Check for basic self-consistency.
+     *
+     * This does not place any requirements on whether [ApiSurfaces.base] is `null` or not just that
+     * whatever it is that it is consistent.
+     */
+    private fun ApiSurfaces.assertSelfConsistent() {
+        assertTrue(main.isMain, "main is main")
+        if (base == null) {
+            assertNull(main.extends, "main does not extend anything")
+        } else {
+            assertSame(base, main.extends, "main extends base")
+            assertFalse(base!!.isMain, "base is not main")
+        }
+    }
+
+    @Test
+    fun `Test without base`() {
+        val apiSurfaces = ApiSurfaces.create(needsBase = false)
+        apiSurfaces.assertSelfConsistent()
+        assertNull(apiSurfaces.base, "base not expected")
+    }
+
+    @Test
+    fun `Test with base`() {
+        val apiSurfaces = ApiSurfaces.create(needsBase = true)
+        apiSurfaces.assertSelfConsistent()
+        assertNotNull(apiSurfaces.base, "base is expected")
+    }
+
+    @Test
+    fun `Test with no main`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                ApiSurfaces.build { createSurface(name = "public") }
+            }
+        assertEquals("No call to createSurface() set isMain to true", exception.message)
+    }
+
+    @Test
+    fun `Test with two mains`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                ApiSurfaces.build {
+                    createSurface(name = "public", isMain = true)
+                    createSurface(name = "other", isMain = true)
+                }
+            }
+        assertEquals(
+            "Main surface already set to `public`, cannot set to `other`",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Test with other names needs base`() {
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface(name = "public")
+                createSurface(name = "system", extends = "public", isMain = true)
+            }
+        apiSurfaces.assertSelfConsistent()
+        assertEquals(apiSurfaces.main.name, "system")
+        assertNotNull(apiSurfaces.base, "base is expected")
+        assertEquals(apiSurfaces.base?.name, "public")
+    }
+
+    @Test
+    fun `Test with other names does not need base`() {
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface(name = "public", isMain = true)
+                createSurface(name = "system", extends = "public")
+            }
+        apiSurfaces.assertSelfConsistent()
+        assertEquals(apiSurfaces.main.name, "public")
+        assertNull(apiSurfaces.base, "base is not expected")
+    }
+
+    @Test
+    fun `Test sorting`() {
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface(name = "public")
+                createSurface(name = "system", extends = "public")
+                createSurface(name = "module-lib", extends = "system", isMain = true)
+            }
+
+        val byName = apiSurfaces.byName
+
+        val unsorted =
+            listOf(
+                byName["system"]!!,
+                byName["module-lib"]!!,
+                byName["public"]!!,
+            )
+
+        assertEquals("public, system, module-lib", unsorted.sorted().joinToString { it.name })
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedParametersProviderTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedParametersProviderTest.kt
index 396659cae..5f07903e4 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedParametersProviderTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedParametersProviderTest.kt
@@ -17,11 +17,16 @@
 package com.android.tools.metalava.model.junit4
 
 import com.google.common.truth.Truth.assertThat
+import kotlin.test.assertEquals
+import org.junit.ClassRule
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestName
+import org.junit.rules.TestRule
+import org.junit.runner.Description
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized.Parameter
+import org.junit.runners.model.Statement
 import org.junit.runners.model.TestClass
 
 /**
@@ -31,6 +36,10 @@ import org.junit.runners.model.TestClass
 @CustomParameters(1, 2, pattern = "{0}")
 class CustomizableParameterizedParametersProviderTest {
 
+    companion object {
+        @ClassRule @JvmField val classRule = CountingTestRule()
+    }
+
     @get:Rule val testName = TestName()
 
     @JvmField @Parameter(0) var parameter: Int = -1
@@ -45,12 +54,12 @@ class CustomizableParameterizedParametersProviderTest {
     }
 
     class ParameterProvider(clazz: Class<*>) :
-        CustomizableParameterizedRunner(clazz, ::mergeParameters) {
+        CustomizableParameterizedRunner<Int>(clazz, ::mergeParameters) {
         companion object {
             private fun mergeParameters(
                 testClass: TestClass,
                 additionalParameters: List<Array<Any>>?,
-            ): TestArguments {
+            ): TestArguments<Int> {
                 val customParameters = testClass.getAnnotation(CustomParameters::class.java)
                 if (additionalParameters != null)
                     error("did not expect ${additionalParameters.size} additional parameters")
@@ -65,3 +74,19 @@ class CustomizableParameterizedParametersProviderTest {
 
 /** Annotation used by [CustomizableParameterizedParametersProviderTest] to provide values. */
 annotation class CustomParameters(vararg val values: Int, val pattern: String)
+
+class CountingTestRule : TestRule {
+    var applyCount: Int = 0
+
+    override fun apply(base: Statement, description: Description): Statement {
+        applyCount += 1
+        return object : Statement() {
+            override fun evaluate() {
+                base.evaluate()
+
+                // Make sure this is only applied once.
+                assertEquals(1, applyCount, "expected test rule to be applied once")
+            }
+        }
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/reporter/BasicReporterTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/reporter/BasicReporterTest.kt
new file mode 100644
index 000000000..ad86e5a9b
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/reporter/BasicReporterTest.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.reporter
+
+import java.io.BufferedWriter
+import java.io.File
+import java.io.StringWriter
+import kotlin.test.assertEquals
+import org.junit.Test
+
+class BasicReporterTest {
+    @Test
+    fun `Test flushes output through buffered writer`() {
+        val stringWriter = StringWriter()
+        // Insert a buffered writer to buffer the output to make sure that the reporter is flushing.
+        val bufferedWriter = BufferedWriter(stringWriter)
+        val reporter = BasicReporter(bufferedWriter)
+        val location = FileLocation.forFile(File("test"))
+        reporter.report(Issues.PARSE_ERROR, reportable = null, "error", location)
+        assertEquals("test: error: error [ParseError]", stringWriter.toString().trim())
+    }
+}
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
index 3fa92d242..ea5670563 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
@@ -67,6 +67,13 @@ interface Assertions {
         return packageItem
     }
 
+    /** Get the type alias from the [Codebase], failing if it does not exist. */
+    fun Codebase.assertTypeAlias(qualifiedName: String): TypeAliasItem {
+        val typeAliasItem = findTypeAlias(qualifiedName)
+        assertNotNull(typeAliasItem, message = "Expected $qualifiedName to be a defined type alias")
+        return typeAliasItem
+    }
+
     /**
      * Return a dump of the state of [SelectableItem.selectedApiVariants] across this [Codebase].
      */
@@ -194,6 +201,13 @@ interface Assertions {
         append(returnType().testTypeString(kotlinStyleNulls = true))
     }
 
+    /** Get the [AnnotationAttribute] from the [AnnotationItem], failing if it does not exist. */
+    fun AnnotationItem.assertAttribute(name: String): AnnotationAttribute {
+        val attribute = findAttribute(name)
+        assertNotNull(attribute, message = "Expected $this to contain attribute $name")
+        return attribute
+    }
+
     /** Get the list of fully qualified annotation names associated with the [TypeItem]. */
     fun TypeItem.annotationNames(): List<String?> {
         return modifiers.annotations.map { it.qualifiedName }
@@ -275,6 +289,8 @@ interface Assertions {
     fun TypeItem?.assertWildcardItem(body: (WildcardTypeItem.() -> Unit)? = null) {
         assertIsInstanceOf(body ?: {})
     }
+
+    companion object : Assertions {}
 }
 
 private inline fun <reified T> Any?.assertIsInstanceOf(body: (T).() -> Unit) {
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
index b95bf4a57..5532e4c06 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
@@ -16,120 +16,75 @@
 
 package com.android.tools.metalava.model.junit4
 
-import java.lang.reflect.Constructor
-import java.lang.reflect.Field
-import java.lang.reflect.InaccessibleObjectException
-import java.lang.reflect.Method
-import java.lang.reflect.Modifier
-import kotlin.reflect.KClass
-import kotlin.reflect.KProperty
-import org.junit.AssumptionViolatedException
-import org.junit.runner.Description
+import com.android.tools.metalava.model.junit4.ParameterizedRunner.TestArguments
 import org.junit.runner.Runner
-import org.junit.runner.notification.RunNotifier
 import org.junit.runners.Parameterized
 import org.junit.runners.Parameterized.Parameters
-import org.junit.runners.Parameterized.UseParametersRunnerFactory
-import org.junit.runners.ParentRunner
 import org.junit.runners.model.FrameworkMethod
 import org.junit.runners.model.TestClass
+import org.junit.runners.parameterized.BlockJUnit4ClassRunnerWithParametersFactory
 import org.junit.runners.parameterized.ParametersRunnerFactory
+import org.junit.runners.parameterized.TestWithParameters
 
 /**
- * A customizable wrapper around the JUnit [Parameterized] runner.
- *
- * While it is very capable unfortunately, is not very customizable, e.g.
- * * Test arguments can only be retrieved from a function annotated with [Parameters], so there is
- *   no way to provide arguments automatically by the runner.
- * * The function that provides the arguments is not given the test [Class] that is being run (which
- *   may be a subclass of the class with the [Parameters] function). That means the argument
- *   generation cannot take into account information from the test class, e.g. class annotations.
- * * Once provided the arguments cannot be filtered.
- * * A custom [ParametersRunnerFactory] can be provided through the [UseParametersRunnerFactory]
- *   annotation, but it has to be specified on the test class, and cannot be inherited from the
- *   class that specifies the `@RunWith(Parameterized.class)`. There is no way to provide a single
- *   `@RunWith(ExtensionOfParameterized.class)` annotation that hard codes the
- *   [ParametersRunnerFactory].
- *
- * JUnit 4 is no longer under active development so there is no chance of getting these capabilities
- * added to the [Parameterized] runner. The JUnit Params library is a more capable parameterized
- * runner but unfortunately, it is not being actively maintained. JUnit 5 parameterization does not
- * support parameterizing the whole class.
- *
- * So, this class is being provided to rectify those limitations by providing a wrapper around a
- * [Parameterized] instance, using copious quantities of reflection to construct and manipulate it.
- * On top of that wrapper it will provide support for doing some (or all) of the above as needed.
+ * Extends [ParameterizedRunner] to combine parameters from the test class (specified using
+ * [Parameters] and additional arguments from [argumentsProvider].
  *
  * @param clazz the test class to run.
  * @param argumentsProvider provider of [TestArguments] used by this runner. Is also passed any
  *   additional parameters (provided by the test class using the standard [Parameterized]
  *   mechanism), if any. They can be filtered and/or combined in some way with parameters provides
  *   by this.
+ * @param parametersRunnerFactory factory for creating a [Runner] from a [TestWithParameters].
  */
-abstract class CustomizableParameterizedRunner(
+abstract class CustomizableParameterizedRunner<A : Any>(
     clazz: Class<*>,
-    argumentsProvider: (TestClass, List<Array<Any>>?) -> TestArguments,
-    parametersRunnerFactoryClass: KClass<out ParametersRunnerFactory>? = null,
-) : ParentRunner<Runner>(clazz) {
-
-    /** The set of test arguments to use. */
-    class TestArguments(
-        /**
-         * The pattern describing how to construct the test name suffix for a set of arguments.
-         *
-         * See [Parameters.name] for more details.
-         */
-        val pattern: String,
-
-        /**
-         * The sets of arguments.
-         *
-         * Each entry can be either an `Array<Any>` (for multiple arguments) or any other value (for
-         * a single argument).
-         */
-        val argumentSets: List<Any>,
-    )
-
-    /** The wrapped [Parameterized] class. */
-    private val parameterized: Parameterized =
-        ParameterizedBuilder.build(clazz) {
-
-            // Create a [TestClass] for the real test class and inject it.
-            val testClass =
-                InjectedTestClass(clazz, parametersRunnerFactoryClass).also {
-                    // Inject it into [runnersFactory]
-                    testClass = it
-                }
-
-            // Get additional arguments (if any) from the actual test class.
-            val additionalArguments = getAdditionalArguments(testClass)
-
-            // Obtain [TestArguments] from the provider and store the list of argument sets in the
-            // [RunnersFactory.allParametersField].
-            val testArguments = argumentsProvider(testClass, additionalArguments)
-            allParameters = testArguments.argumentSets
+    private val argumentsProvider: (TestClass, List<Array<Any>>?) -> TestArguments<A>,
+    parametersRunnerFactory: ParametersRunnerFactory =
+        BlockJUnit4ClassRunnerWithParametersFactory(),
+) : ParameterizedRunner<A>(TestClass(clazz), parametersRunnerFactory) {
+
+    override fun computeTestArguments(testClass: TestClass): TestArguments<A> {
+        // Get additional arguments (if any) from the actual test class.
+        val additionalArguments = getAdditionalArguments(testClass)
+
+        // Obtain [TestArguments] from the provider and store the list of argument sets in the
+        // [RunnersFactory.allParametersField].
+        val testArguments = argumentsProvider(testClass, additionalArguments)
+
+        // Check to see if there is a parameters filter method provided.
+        val parametersFilterMethod =
+            testClass.getAnnotatedMethods(ParameterFilter::class.java).firstOrNull {
+                it.isPublic && it.isStatic
+            }
 
-            // Get the [FrameworkMethod] for the [FakeTestClass.fakeParameters] method, extract its
-            // [FrameworkMethod.method], wrap that and the [TestArguments.pattern] in an
-            // [InjectedFrameworkMethod] that will intercept a request for [Parameters] annotation
-            // and return one containing the pattern supplied.
-            val fakeParametersMethod = parametersMethod
-            val injectedParametersMethod =
-                InjectedFrameworkMethod(fakeParametersMethod.method, testArguments.pattern)
-            parametersMethod = injectedParametersMethod
+        // If there is then apply it to the testArguments, otherwise return it unfiltered.
+        val filteredArguments =
+            if (parametersFilterMethod == null) {
+                testArguments
+            } else {
+                testArguments.copy(
+                    argumentSets =
+                        testArguments.argumentSets.filter {
+                            invokeFilterMethod(parametersFilterMethod, it)
+                        }
+                )
+            }
 
-            // Make sure that the [RunnersFactory.parameterCount] field is set correctly to the
-            // number of parameters.
-            parameterCount =
-                if (allParameters.isEmpty()) 0
-                else {
-                    val first = allParameters.first()
-                    (first as? Array<*>)?.size ?: 1
-                }
-        }
+        return filteredArguments
+    }
 
-    /** List containing [parameterized]. */
-    private val children: List<Runner> = mutableListOf(parameterized)
+    /**
+     * Invoke the [parametersFilterMethod] on [argument].
+     *
+     * Subclasses that wish to use filters must override this.
+     */
+    protected open fun invokeFilterMethod(
+        parametersFilterMethod: FrameworkMethod,
+        argument: A
+    ): Boolean {
+        error("Subclass does not implement invokeFilterMethod(...) method")
+    }
 
     companion object {
         /**
@@ -168,187 +123,4 @@ abstract class CustomizableParameterizedRunner(
                 }
         }
     }
-
-    /**
-     * A [TestClass] subclass that is injected into the [Parameterized.RunnersFactory] in order to
-     * intercept requests for information about the test class being run and supply information
-     * provide by this.
-     */
-    private class InjectedTestClass(
-        clazz: Class<*>,
-        /**
-         * The [ParametersRunnerFactory] class to use for creating runners for a specific set of
-         * test parameters.
-         */
-        private val runnerFactoryClass: KClass<out ParametersRunnerFactory>?,
-    ) : TestClass(clazz) {
-        override fun <T : Annotation> getAnnotation(annotationType: Class<T>): T? {
-            if (
-                runnerFactoryClass != null &&
-                    annotationType == UseParametersRunnerFactory::class.java
-            ) {
-                @Suppress("UNCHECKED_CAST")
-                return UseParametersRunnerFactory(runnerFactoryClass) as T
-            }
-            return super.getAnnotation(annotationType)
-        }
-    }
-
-    /**
-     * An extension of [FrameworkMethod] that exists to provide the custom [TestArguments.pattern]
-     * to [Parameterized.RunnersFactory] by intercepting a request for the [Parameters] annotation
-     * and returning one with the supplied [pattern].
-     */
-    private class InjectedFrameworkMethod(method: Method, val pattern: String) :
-        FrameworkMethod(method) {
-        override fun <T : Annotation> getAnnotation(annotationType: Class<T>): T? {
-            if (annotationType == Parameters::class.java) {
-                @Suppress("UNCHECKED_CAST") return Parameters(name = pattern) as T
-            }
-            return super.getAnnotation(annotationType)
-        }
-    }
-
-    override fun getDescription(): Description {
-        // Return the wrapped [parameterized]'s [Description] otherwise the description ends up
-        // looking something like this:
-        //     <class>
-        //         <class>
-        //             ...<method>...
-        //
-        // Which can cause issues with gradle test runner's handling of @Ignore.
-        return parameterized.description
-    }
-
-    override fun getChildren() = children
-
-    override fun describeChild(child: Runner): Description = child.description
-
-    override fun runChild(child: Runner, notifier: RunNotifier) {
-        child.run(notifier)
-    }
-
-    /**
-     * The main functionality of [Parameterized] is provided by the private class
-     * [Parameterized.RunnersFactory]. This class provides an abstract that allows instances of that
-     * to be constructed through reflection which is then used to construct a [Parameterized]
-     * instance.
-     */
-    private class ParameterizedBuilder {
-
-        private val runnersFactory =
-            runnersFactoryConstructor.newInstance(FakeTestClass::class.java)
-
-        // The following delegate to the corresponding field in [runnersFactory]
-        var testClass: TestClass by testClassField
-        var parametersMethod: FrameworkMethod by parametersMethodField
-        var allParameters: List<Any> by allParametersField
-        var parameterCount: Int by parameterCountField
-        private var runnerOverride: Runner? by runnerOverrideField
-
-        init {
-            // The [FakeTestClass.fakeParameters] method throws an error so `runnerOverride` was set
-            // to a special runner that will report an error when the tests are run. Set the field
-            // to `null` to avoid that as actual arguments will be provided below.
-            runnerOverride = null
-        }
-
-        /** Get this field from [runnersFactory]. */
-        operator fun <T, V> Field.getValue(thisRef: T, property: KProperty<*>): V {
-            @Suppress("UNCHECKED_CAST") return get(runnersFactory) as V
-        }
-
-        /** Set this field on [runnersFactory]. */
-        operator fun <T, V> Field.setValue(thisRef: T, property: KProperty<*>, value: V) {
-            set(runnersFactory, value)
-        }
-
-        /**
-         * Fake test class that is passed to the [Parameterized.RunnersFactory] to ensure that its
-         * constructor will complete successfully. Afterwards the fields in
-         * [Parameterized.RunnersFactory] will be updated to match the actual test class.
-         */
-        class FakeTestClass {
-            companion object {
-                @JvmStatic
-                @Parameters
-                fun fakeArguments(): List<Any> = throw AssumptionViolatedException("fake arguments")
-            }
-        }
-
-        companion object {
-            fun build(clazz: Class<*>, block: ParameterizedBuilder.() -> Unit): Parameterized {
-                val builder = ParameterizedBuilder()
-                builder.block()
-                // Create a new `Parameterized` object.
-                return parameterizedConstructor.newInstance(clazz, builder.runnersFactory)
-            }
-            /** [Parameterized] class. */
-            private val parameterizedClass = Parameterized::class.java
-
-            /** The private [Parameterized.RunnersFactory] class. */
-            private val runnersFactoryClass =
-                parameterizedClass.declaredClasses.first { it.simpleName == "RunnersFactory" }
-
-            // Get the private `Parameterized(Class, RunnersFactory)` constructor.
-            private val parameterizedConstructor: Constructor<Parameterized> =
-                parameterizedClass
-                    .getDeclaredConstructor(Class::class.java, runnersFactoryClass)
-                    .apply { isAccessible = true }
-
-            // Create a new [Parameterized.RunnersFactory]. Uses [FakeTestClass] not the real test
-            // class. The correct information will be injected into it below.
-            private val runnersFactoryConstructor: Constructor<out Any> =
-                runnersFactoryClass.getDeclaredConstructor(Class::class.java).apply {
-                    isAccessible = true
-                }
-
-            /** [Field.modifiers] field. */
-            private val modifiersField =
-                getModifiersField().apply {
-                    try {
-                        // Modify the `modifiers` field for the field to remove `final`.
-                        // This requires "--add-opens=java.base/java.lang.reflect=ALL-UNNAMED".
-                        isAccessible = true
-                    } catch (e: InaccessibleObjectException) {
-                        throw IllegalStateException(
-                            "Add --add-opens=java.base/java.lang.reflect=ALL-UNNAMED to jvm options",
-                            e
-                        )
-                    }
-                }
-
-            // Get various [Parameterized.RunnersFactory] fields and make them accessible and
-            // settable.
-            val testClassField = getSettableField("testClass")
-            val parametersMethodField = getSettableField("parametersMethod")
-            val allParametersField = getSettableField("allParameters")
-            val parameterCountField = getSettableField("parameterCount")
-            val runnerOverrideField = getSettableField("runnerOverride")
-
-            /**
-             * Get an accessible and settable (i.e. not `final`) declared field called [name] in
-             * [runnersFactoryClass].
-             */
-            private fun getSettableField(name: String): Field {
-                val field = runnersFactoryClass.getDeclaredField(name)
-                field.isAccessible = true
-                modifiersField.setInt(field, field.modifiers and Modifier.FINAL.inv())
-                return field
-            }
-
-            /**
-             * Need to use reflection to invoke `getDeclaredFields0` to get the hidden fields of the
-             * [Field] class, then select the one called `modifiers`.
-             */
-            private fun getModifiersField(): Field {
-                val getDeclaredFields0 =
-                    Class::class.java.getDeclaredMethod("getDeclaredFields0", Boolean::class.java)
-                getDeclaredFields0.isAccessible = true
-                @Suppress("UNCHECKED_CAST")
-                val fields = getDeclaredFields0.invoke(Field::class.java, false) as Array<Field>
-                return fields.first { it.name == "modifiers" }
-            }
-        }
-    }
 }
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterFilter.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterFilter.kt
new file mode 100644
index 000000000..fe5efed17
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterFilter.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.junit4
+
+import com.android.tools.metalava.model.testing.BaseModelProviderRunner
+import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
+import org.junit.runners.Parameterized
+
+/**
+ * Marks a public static method that will be called with each set of arguments provided to a
+ * parameterized test and determines whether they are a valid combination.
+ *
+ * This can only be used in a test that is run by a subclass of [BaseModelProviderRunner]. In that
+ * case the method takes one more parameter than the number of [Parameterized.Parameter] annotated
+ * fields in the test class. The first parameter of the method is of [CodebaseCreatorConfig] type,
+ * the subsequent parameters correspond to the [Parameterized.Parameter] whose value is 1 less than
+ * the parameter index.
+ *
+ * The method must return true if the parameters are a valid combination, false otherwise.
+ */
+@Target(AnnotationTarget.FUNCTION) annotation class ParameterFilter
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterizedRunner.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterizedRunner.kt
new file mode 100644
index 000000000..fb7315c29
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/ParameterizedRunner.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.junit4
+
+import java.text.MessageFormat
+import org.junit.runner.Description
+import org.junit.runner.Runner
+import org.junit.runner.notification.RunNotifier
+import org.junit.runners.Parameterized.Parameters
+import org.junit.runners.ParentRunner
+import org.junit.runners.model.TestClass
+import org.junit.runners.parameterized.ParametersRunnerFactory
+import org.junit.runners.parameterized.TestWithParameters
+
+/**
+ * A simple [ParentRunner] that will use [parametersRunnerFactory] to create a [Runner] for each of
+ * the [TestArguments.argumentSets] returned from [computeTestArguments].
+ */
+abstract class ParameterizedRunner<A : Any>(
+    private val testClass: TestClass,
+    private val parametersRunnerFactory: ParametersRunnerFactory,
+) : ParentRunner<Runner>(testClass) {
+
+    /** The set of test arguments to use. */
+    data class TestArguments<A : Any>(
+        /**
+         * The pattern describing how to construct the test name suffix for a set of arguments.
+         *
+         * See [Parameters.name] for more details.
+         */
+        val pattern: String,
+
+        /**
+         * The sets of arguments.
+         *
+         * Each entry can be either an `Array<Any>` (for multiple arguments) or any other value (for
+         * a single argument).
+         */
+        val argumentSets: List<A>,
+    )
+
+    /** Compute [TestArguments] for [testClass]. */
+    abstract fun computeTestArguments(testClass: TestClass): TestArguments<A>
+
+    /** Create the runners lazily. */
+    private val runners: List<Runner> by
+        lazy(LazyThreadSafetyMode.NONE) {
+            val testArguments = computeTestArguments(testClass)
+
+            // Add brackets around the pattern.
+            val pattern = "[${testArguments.pattern}]"
+
+            testArguments.argumentSets.map { argumentSet ->
+                val name = MessageFormat.format(pattern, argumentSet)
+                val testWithParameters = TestWithParameters(name, testClass, listOf(argumentSet))
+                parametersRunnerFactory.createRunnerForTestWithParameters(testWithParameters)
+            }
+        }
+
+    override fun getChildren(): List<Runner> {
+        return runners
+    }
+
+    override fun describeChild(child: Runner): Description = child.description
+
+    override fun runChild(child: Runner, notifier: RunNotifier?) {
+        child.run(notifier)
+    }
+}
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/BaseModelProviderRunner.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/BaseModelProviderRunner.kt
index 468ed4f01..2e85fdaeb 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/BaseModelProviderRunner.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/BaseModelProviderRunner.kt
@@ -79,7 +79,7 @@ open class BaseModelProviderRunner<C : FilterableCodebaseCreator, I : Any>(
     baselineResourcePath: String,
     minimumCapabilities: Set<Capability> = emptySet(),
 ) :
-    CustomizableParameterizedRunner(
+    CustomizableParameterizedRunner<ModelProviderWrapper<C>>(
         clazz,
         { testClass, additionalArguments ->
             createTestArguments(
@@ -90,7 +90,7 @@ open class BaseModelProviderRunner<C : FilterableCodebaseCreator, I : Any>(
                 minimumCapabilities,
             )
         },
-        InstanceRunnerFactory::class,
+        InstanceRunnerFactory(),
     ) {
 
     init {
@@ -100,11 +100,27 @@ open class BaseModelProviderRunner<C : FilterableCodebaseCreator, I : Any>(
         }
     }
 
+    /**
+     * Apply [parametersFilterMethod] to [argument] by combining
+     * [ModelProviderWrapper.codebaseCreatorConfig] and [ModelProviderWrapper.additionalArgumentSet]
+     * into a single list of arguments and the invoking [parametersFilterMethod] with them.
+     */
+    override fun invokeFilterMethod(
+        parametersFilterMethod: FrameworkMethod,
+        argument: ModelProviderWrapper<C>
+    ): Boolean {
+        val args = buildList {
+            add(argument.codebaseCreatorConfig)
+            addAll(argument.additionalArgumentSet)
+        }
+        return parametersFilterMethod.invokeExplosively(null, *args.toTypedArray()) as Boolean
+    }
+
     /**
      * A wrapper around a [CodebaseCreatorConfig] that tunnels information needed by
      * [InstanceRunnerFactory] through [TestWithParameters].
      */
-    private class ModelProviderWrapper<C : FilterableCodebaseCreator>(
+    class ModelProviderWrapper<C : FilterableCodebaseCreator>(
         val codebaseCreatorConfig: CodebaseCreatorConfig<C>,
         val baselineResourcePath: String,
         val additionalArgumentSet: List<Any> = emptyList(),
@@ -242,7 +258,7 @@ open class BaseModelProviderRunner<C : FilterableCodebaseCreator, I : Any>(
             baselineResourcePath: String,
             additionalArguments: List<Array<Any>>?,
             minimumCapabilities: Set<Capability>,
-        ): TestArguments {
+        ): TestArguments<ModelProviderWrapper<C>> {
             // Generate a sequence that traverse the super class hierarchy starting with the test
             // class.
             val hierarchy = generateSequence(testClass.javaClass) { it.superclass }
diff --git a/metalava-reporter/Android.bp b/metalava-reporter/Android.bp
index 28dfc9c14..3a3176784 100644
--- a/metalava-reporter/Android.bp
+++ b/metalava-reporter/Android.bp
@@ -23,4 +23,5 @@ java_library_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
 }
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
index 9a0416bbf..a3a301911 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
@@ -30,7 +30,10 @@ object Issues {
     val PARSE_ERROR by Issue(Severity.ERROR)
     val DUPLICATE_SOURCE_CLASS by Issue(Severity.WARNING)
 
-    val CONFIG_FILE_PROBLEM by Issue(Severity.ERROR)
+    // Signature file parsing
+    val SIGNATURE_FILE_ERROR by Issue(Severity.ERROR)
+    // TODO(b/394789173): Hide until AndroidX has disabled it.
+    val UNQUALIFIED_TYPE_ERROR by Issue(Severity.HIDDEN)
 
     // Compatibility issues
     val ADDED_ANNOTATION by Issue(Severity.ERROR, Category.COMPATIBILITY)
@@ -47,7 +50,6 @@ object Issues {
     val REMOVED_INTERFACE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val CHANGED_STATIC by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val ADDED_FINAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_TRANSIENT by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val CHANGED_VOLATILE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val CHANGED_TYPE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val CHANGED_VALUE by Issue(Severity.ERROR, Category.COMPATIBILITY)
@@ -59,8 +61,6 @@ object Issues {
     val CHANGED_NATIVE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val CHANGED_CLASS by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val CHANGED_DEPRECATED by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val CHANGED_SYNCHRONIZED by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val CONFLICTING_SHOW_ANNOTATIONS by Issue(Severity.ERROR, Category.UNKNOWN)
     val ADDED_FINAL_UNINSTANTIABLE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val REMOVED_FINAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val REMOVED_FINAL_STRICT by Issue(Severity.ERROR, Category.COMPATIBILITY)
@@ -86,8 +86,6 @@ object Issues {
     val BROADCAST_BEHAVIOR by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val SDK_CONSTANT by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val TODO by Issue(Severity.ERROR, Category.DOCUMENTATION)
-    val NO_ARTIFACT_DATA by Issue(Severity.HIDDEN, Category.DOCUMENTATION)
-    val BROKEN_ARTIFACT_FILE by Issue(Severity.ERROR, Category.DOCUMENTATION)
 
     // Metalava warnings (not from doclava)
 
@@ -95,7 +93,6 @@ object Issues {
 
     val MISSING_PERMISSION by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val MULTIPLE_THREAD_ANNOTATIONS by Issue(Severity.ERROR, Category.DOCUMENTATION)
-    val UNRESOLVED_CLASS by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val INVALID_NULL_CONVERSION by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val PARAMETER_NAME_CHANGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val OPERATOR_REMOVAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
@@ -109,7 +106,6 @@ object Issues {
     val HIDDEN_TYPEDEF_CONSTANT by Issue(Severity.ERROR)
     val INTERNAL_ERROR by Issue(Severity.ERROR)
     val RETURNING_UNEXPECTED_CONSTANT by Issue(Severity.WARNING)
-    val DEPRECATED_OPTION by Issue(Severity.WARNING)
     val BOTH_PACKAGE_INFO_AND_HTML by Issue(Severity.WARNING, Category.DOCUMENTATION)
     val UNMATCHED_MERGE_ANNOTATION by Issue(Severity.ERROR, Category.API_LINT)
     val INCONSISTENT_MERGE_ANNOTATION by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
@@ -156,7 +152,6 @@ object Issues {
     val PARCEL_CONSTRUCTOR by Issue(Severity.ERROR, Category.API_LINT)
     val PROTECTED_MEMBER by Issue(Severity.ERROR, Category.API_LINT)
     val PAIRED_REGISTRATION by Issue(Severity.ERROR, Category.API_LINT)
-    val REGISTRATION_NAME by Issue(Severity.ERROR, Category.API_LINT)
     val VISIBLY_SYNCHRONIZED by Issue(Severity.ERROR, Category.API_LINT)
     val INTENT_BUILDER_NAME by Issue(Severity.WARNING, Category.API_LINT)
     val CONTEXT_NAME_SUFFIX by Issue(Severity.ERROR, Category.API_LINT)
@@ -173,7 +168,6 @@ object Issues {
     val CONCRETE_COLLECTION by Issue(Severity.ERROR, Category.API_LINT)
     val OVERLAPPING_CONSTANTS by Issue(Severity.WARNING, Category.API_LINT)
     val GENERIC_EXCEPTION by Issue(Severity.ERROR, Category.API_LINT)
-    val ILLEGAL_STATE_EXCEPTION by Issue(Severity.WARNING, Category.API_LINT)
     val RETHROW_REMOTE_EXCEPTION by Issue(Severity.ERROR, Category.API_LINT)
     val MENTIONS_GOOGLE by Issue(Severity.ERROR, Category.API_LINT)
     val HEAVY_BIT_SET by Issue(Severity.ERROR, Category.API_LINT)
@@ -240,21 +234,21 @@ object Issues {
     val GETTER_SETTER_NULLABILITY by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     val CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED by Issue(Severity.HIDDEN, Category.API_LINT)
     val VALUE_CLASS_DEFINITION by Issue(Severity.ERROR, Category.API_LINT)
+    val INVALID_ENVIRONMENT_IN_RESTRICTED_FOR_ENVIRONMENT by
+        Issue(Severity.ERROR, Category.API_LINT)
+    val MISSING_FROM_VALUE by Issue(Severity.ERROR, Category.API_LINT)
+    val INHERIT_CHANGES_SIGNATURE by Issue(Severity.WARNING_ERROR_WHEN_NEW)
+    val DATA_CLASS_DEFINITION by Issue(Severity.HIDDEN, Category.API_LINT)
 
     fun findIssueById(id: String?): Issue? {
         return nameToIssue[id]
     }
 
-    fun findIssueByIdIgnoringCase(id: String): Issue? {
-        for (e in allIssues) {
-            if (id.equals(e.name, ignoreCase = true)) {
-                return e
-            }
-        }
-        return null
-    }
-
-    fun findCategoryById(id: String?): Category? = Category.values().find { it.id == id }
+    fun findCategoryById(id: String?): Category =
+        Category.entries.find { it.id == id }
+            ?: error(
+                "Unknown category: '$id', expected one of ${Category.entries.joinToString { it.id }}"
+            )
 
     fun findIssuesByCategory(category: Category?): List<Issue> =
         allIssues.filter { it.category == category }
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
index 3451a77d8..8e5c7f79c 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.reporter
 import java.io.File
 import java.io.OutputStream
 import java.io.PrintWriter
+import java.io.StringWriter
 import java.io.Writer
 
 interface Reporter {
@@ -105,14 +106,10 @@ interface Reporter {
 }
 
 /**
- * Basic implementation of a [Reporter] that performs no filtering and simply outputs the message to
- * the supplied [PrintWriter].
+ * Abstract implementation of a [Reporter] that performs no filtering and delegates the handling of
+ * a report to [handleFormattedMessage].
  */
-class BasicReporter(private val stderr: PrintWriter) : Reporter {
-    constructor(writer: Writer) : this(PrintWriter(writer))
-
-    constructor(outputStream: OutputStream) : this(PrintWriter(outputStream))
-
+abstract class AbstractBasicReporter : Reporter {
     override fun report(
         id: Issues.Issue,
         reportable: Reportable?,
@@ -120,25 +117,47 @@ class BasicReporter(private val stderr: PrintWriter) : Reporter {
         location: FileLocation,
         maximumSeverity: Severity,
     ): Boolean {
-        stderr.println(
-            buildString {
-                val usableLocation = reportable?.fileLocation ?: location
-                append(usableLocation.path)
-                if (usableLocation.line > 0) {
-                    append(":")
-                    append(usableLocation.line)
-                }
-                append(": ")
-                val severity = id.defaultLevel
-                append(severity)
-                append(": ")
-                append(message)
-                append(severity.messageSuffix)
-                append(" [")
-                append(id.name)
-                append("]")
+        val formattedMessage = buildString {
+            val usableLocation = reportable?.fileLocation ?: location
+            append(usableLocation.path)
+            if (usableLocation.line > 0) {
+                append(":")
+                append(usableLocation.line)
             }
-        )
+            append(": ")
+            val severity = id.defaultLevel
+            append(severity)
+            append(": ")
+            append(message)
+            append(severity.messageSuffix)
+            append(" [")
+            append(id.name)
+            append("]")
+        }
+        return handleFormattedMessage(formattedMessage)
+    }
+
+    abstract fun handleFormattedMessage(formattedMessage: String): Boolean
+
+    override fun isSuppressed(
+        id: Issues.Issue,
+        reportable: Reportable?,
+        message: String?
+    ): Boolean = false
+}
+
+/**
+ * Basic implementation of a [Reporter] that performs no filtering and simply outputs the message to
+ * the supplied [PrintWriter].
+ */
+class BasicReporter(private val stderr: PrintWriter) : AbstractBasicReporter() {
+    constructor(writer: Writer) : this(stderr = PrintWriter(writer))
+
+    constructor(outputStream: OutputStream) : this(stderr = PrintWriter(outputStream))
+
+    override fun handleFormattedMessage(formattedMessage: String): Boolean {
+        stderr.println(formattedMessage)
+        stderr.flush()
         return true
     }
 
@@ -147,8 +166,41 @@ class BasicReporter(private val stderr: PrintWriter) : Reporter {
         reportable: Reportable?,
         message: String?
     ): Boolean = false
+}
+
+/** A [Reporter] which will record issues in an internal buffer, accessible through [issues]. */
+class RecordingReporter : AbstractBasicReporter() {
+    private val stringWriter = StringWriter()
+
+    override fun handleFormattedMessage(formattedMessage: String): Boolean {
+        stringWriter.append(formattedMessage).append("\n")
+        return true
+    }
+
+    val issues: String
+        get() = stringWriter.toString().trim()
+
+    /** Remove and return any existing issues. */
+    fun removeIssues(): String {
+        val issues = stringWriter.toString().trim()
+        stringWriter.buffer.setLength(0)
+        return issues
+    }
+}
+
+/**
+ * A [Reporter] which will throw an exception for the first issue, even warnings or hidden, that is
+ * reported.
+ *
+ * Safe to use when no issues are expected as it will prevent any issues from being silently
+ * ignored.
+ */
+class ThrowingReporter private constructor() : AbstractBasicReporter() {
+    override fun handleFormattedMessage(formattedMessage: String): Boolean {
+        error(formattedMessage)
+    }
 
     companion object {
-        val ERR = BasicReporter(System.err)
+        val INSTANCE = ThrowingReporter()
     }
 }
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
index df5d477c3..b1b7ff383 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
@@ -39,9 +39,9 @@ private fun File.isMetalavaRootDir(): Boolean = resolve("metalava-model").isDire
 
 /** Get a [File] for the public `android.jar` of the specified [apiLevel]. */
 fun getAndroidJar(apiLevel: Int = API_LEVEL): File {
-    val metalavaDir = getMetalavaDir()
+    val androidDir = getAndroidDir()
 
-    val localFile = metalavaDir.resolve("../../prebuilts/sdk/$apiLevel/public/android.jar")
+    val localFile = androidDir.resolve("prebuilts/sdk/$apiLevel/public/android.jar")
     if (localFile.exists()) {
         return localFile
     } else {
@@ -53,9 +53,9 @@ fun getAndroidJar(apiLevel: Int = API_LEVEL): File {
 
 /** Get a [File] for the [apiSurface] `android.txt` of the specified [apiLevel]. */
 fun getAndroidTxt(apiLevel: Int = API_LEVEL, apiSurface: String = "public"): File {
-    val metalavaDir = getMetalavaDir()
+    val androidDir = getAndroidDir()
 
-    val localFile = metalavaDir.resolve("../../prebuilts/sdk/$apiLevel/$apiSurface/api/android.txt")
+    val localFile = androidDir.resolve("prebuilts/sdk/$apiLevel/$apiSurface/api/android.txt")
     if (!localFile.exists()) {
         error("Missing ${localFile.absolutePath} file in the SDK")
     }
@@ -78,3 +78,10 @@ private fun getMetalavaDir(): File {
         }
     return metalavaDir
 }
+
+/**
+ * The root directory containing the Android source.
+ *
+ * This is used to retrieve files from the `prebuilts` directory for testing.
+ */
+fun getAndroidDir() = getMetalavaDir().resolve("../../")
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/DirectoryBuilder.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/DirectoryBuilder.kt
new file mode 100644
index 000000000..b347a19cb
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/DirectoryBuilder.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.File
+
+/**
+ * Helper to build directory structures for testing.
+ *
+ * @param dir the directory being populated.
+ */
+class DirectoryBuilder(val dir: File) {
+    /**
+     * Populate a directory [relative] to [dir], creating the directory and its parents, if
+     * necessary. if necessary.
+     *
+     * Once the directory is created a new [DirectoryBuilder] is created for that directory on which
+     * [body] is called to populate it.
+     */
+    fun dir(relative: String, body: DirectoryBuilder.() -> Unit): File {
+        val newDir = dir.resolve(relative)
+        newDir.mkdirs()
+        val builder = DirectoryBuilder(newDir)
+        builder.body()
+        return newDir
+    }
+
+    /** Create an empty file [relative] to [dir], creating parent directories, if necessary. */
+    fun emptyFile(relative: String): File {
+        val file = dir.resolve(relative)
+        file.parentFile.mkdirs()
+        file.createNewFile()
+        return file
+    }
+
+    /** Create a jar file [relative] to [dir], containing compiled [sources]. */
+    fun jar(
+        relative: String,
+        vararg sources: TestFile,
+        classPath: List<TestFile> = emptyList(),
+    ) = testFile(jarFromSources(relative, *sources, classPath = classPath))
+
+    /**
+     * Create a signature file [relative] to [dir], contains [contents] trimmed by
+     * [String.trimIndent].
+     */
+    fun signature(relative: String, contents: String) =
+        testFile(source(relative, contents.trimIndent()))
+
+    /** Create a [TestFile] in [dir]. */
+    fun testFile(testFile: TestFile): File = testFile.createFile(dir)
+}
+
+/**
+ * Build a file structure within this [File], which must be a directory.
+ *
+ * Creates a [DirectoryBuilder] for this directory and then invokes [body] on it to populate the
+ * directory.
+ */
+fun File.buildFileStructure(body: DirectoryBuilder.() -> Unit) {
+    require(isDirectory) { "Cannot build a file structure in $this as it is not a directory" }
+
+    val builder = DirectoryBuilder(this)
+    builder.body()
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/JarFromSourcesFile.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/JarFromSourcesFile.kt
new file mode 100644
index 000000000..412b6ca7f
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/JarFromSourcesFile.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.File
+
+/**
+ * [TestFile] implementation that creates a jar file [relative] from a set of [sources] compiled
+ * against [classPath].
+ */
+private class JarFromSourcesFile(
+    relative: String,
+    private val sources: List<TestFile>,
+    private val classPath: List<TestFile>
+) : TestFile() {
+    init {
+        to(relative)
+    }
+
+    override fun createFile(targetDir: File): File {
+        val jarFile = targetDir.resolve(targetRelativePath)
+        JavacHelper.compileAndJar(jarFile, sources, classPath)
+        return jarFile
+    }
+}
+
+/**
+ * Create a [TestFile] that will create a jar file [relative] from a set of [sources] compiled
+ * against [classPath].
+ */
+fun jarFromSources(
+    relative: String,
+    vararg sources: TestFile,
+    classPath: List<TestFile> = emptyList()
+): TestFile = JarFromSourcesFile(relative, sources.toList(), classPath)
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/JavacHelper.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/JavacHelper.kt
new file mode 100644
index 000000000..614714c09
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/JavacHelper.kt
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.nio.file.Files
+
+object JavacHelper {
+    private val jdkPath = getJdkPath()
+
+    private fun getJdkPath(): String {
+        val javaHome = System.getProperty("java.home")
+        if (javaHome != null) {
+            var javaHomeFile = File(javaHome)
+            if (File(javaHomeFile, "bin${File.separator}javac").exists()) {
+                return javaHome
+            } else if (javaHomeFile.name == "jre") {
+                javaHomeFile = javaHomeFile.parentFile
+                if (File(javaHomeFile, "bin${File.separator}javac").exists()) {
+                    return javaHomeFile.path
+                }
+            }
+        }
+        return System.getenv("JAVA_HOME") ?: error("Could not get JDK path")
+    }
+
+    private fun runCommand(executable: String, args: List<String>) {
+        val command = buildList {
+            add(executable)
+            addAll(args)
+        }
+
+        val output = ByteArrayOutputStream()
+        val exitCode =
+            try {
+                val process = ProcessBuilder(command).redirectErrorStream(true).start()
+                process.inputStream.copyTo(output)
+                process.waitFor()
+            } catch (e: Exception) {
+                error("Failed to run `$command` (${e.message})")
+            }
+
+        if (exitCode != 0) {
+            error(
+                "Executing `$command` failed with the following output:\n${output.toString(Charsets.UTF_8).prependIndent()}"
+            )
+        }
+    }
+
+    /** Compile the [sources] into [outputDirectory] throwing an exception if it fails. */
+    fun compile(outputDirectory: File, sources: List<File>, classPath: List<File> = emptyList()) {
+        runCommand(
+            "$jdkPath/bin/javac",
+            buildList {
+                add("-d")
+                add(outputDirectory.path)
+                if (classPath.isNotEmpty()) {
+                    add("-cp")
+                    add(classPath.joinToString(":"))
+                }
+                sources.mapTo(this) { it.path }
+            }
+        )
+    }
+
+    /** Use the `jar` tool to create [jarFile] containing [classesDir]. */
+    private fun jar(jarFile: File, classesDir: File) {
+        runCommand(
+            "$jdkPath/bin/jar",
+            buildList {
+                add("--create")
+                add("--file")
+                add(jarFile.path)
+                // Change directory to classesDir
+                add("-C")
+                add(classesDir.path)
+                // Include everything from this directory.
+                add(".")
+            }
+        )
+    }
+
+    /** Compile the [sources] into [jarFile] throwing an exception if it fails. */
+    fun compileAndJar(
+        jarFile: File,
+        sources: List<TestFile>,
+        classPath: List<TestFile> = emptyList(),
+    ) {
+        // Make sure that the directory in which the jar file will be written exists.
+        val jarDir = jarFile.parentFile
+        jarDir.mkdirs()
+
+        // Create a temporary directory for building the jar.
+        val tempDir = Files.createTempDirectory(jarDir.toPath(), "jar").toFile()
+        val srcDir = tempDir.resolve("src")
+        val sourceFiles = sources.map { it.createFile(srcDir) }
+        val classesDir = tempDir.resolve("classes")
+
+        val classPathDir = tempDir.resolve("class-path")
+        val classPathFiles = classPath.map { it.createFile(classPathDir) }
+
+        // Compile the source files.
+        compile(outputDirectory = classesDir, sourceFiles, classPathFiles)
+
+        // Jar up the class files.
+        jar(jarFile, classesDir)
+
+        // Clean-up the temporary directory.
+        tempDir.deleteRecursively()
+    }
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownJarFiles.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownJarFiles.kt
new file mode 100644
index 000000000..831789d15
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownJarFiles.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.File
+import java.nio.file.Files
+
+object KnownJarFiles {
+    /**
+     * The jar produced by the `:stub-annotations` project.
+     *
+     * This must only be access from a project that depends on `:stub-annotations` and sets the
+     * `METALAVA_STUB_ANNOTATIONS_JAR` environment variable to the jar produced by the project.
+     */
+    val stubAnnotationsJar by lazy {
+        val envValue =
+            System.getenv("METALAVA_STUB_ANNOTATIONS_JAR")
+                ?: error("Environment variable METALAVA_STUB_ANNOTATIONS_JAR was not set")
+        require(envValue.isNotBlank()) {
+            "Invalid environment variable METALAVA_STUB_ANNOTATIONS_JAR: '$envValue'"
+        }
+        val jar = File(envValue)
+        require(jar.isFile) { "stub-annotations jar not found: $jar" }
+        jar
+    }
+
+    /** The jar produced by the `:stub-annotations` project, exposed as a [TestFile]. */
+    val stubAnnotationsTestFile: TestFile by lazy {
+        ExistingFile(stubAnnotationsJar).to("known-jar-files/stub-annotations.jar")
+    }
+}
+
+/** A simple [TestFile] that just uses an existing file by creating a symbolic link to it. */
+private class ExistingFile(private val file: File) : TestFile() {
+    override fun createFile(targetDir: File): File {
+        val link = targetDir.resolve(targetPath)
+        link.parentFile.mkdirs()
+        Files.createSymbolicLink(link.toPath(), file.toPath())
+        return link
+    }
+}
+
+/**
+ * Wrap an existing file in a [TestFile].
+ *
+ * By default, this will create a symbolic link in the `targetDir` passed to [TestFile.createFile]
+ * called [File.getName].
+ */
+fun File.toTestFile(): TestFile = ExistingFile(this).to(name)
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
index e8a705743..99858e357 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
@@ -63,14 +63,6 @@ object KnownSourceFiles {
             """
         )
 
-    val androidAnnotationHide: TestFile =
-        TestFiles.java(
-            """
-                /** @hide */
-                package android.annotation;
-            """
-        )
-
     val nonNullSource: TestFile =
         TestFiles.java(
             """
@@ -113,14 +105,6 @@ object KnownSourceFiles {
     """
         )
 
-    val libcodeUtilHide: TestFile =
-        TestFiles.java(
-            """
-                /** @hide */
-                package libcore.util;
-            """
-        )
-
     val libcoreNonNullSource: TestFile =
         TestFiles.java(
             """
@@ -164,14 +148,6 @@ object KnownSourceFiles {
             """
         )
 
-    val androidxAnnotationHide: TestFile =
-        TestFiles.java(
-            """
-                /** @hide */
-                package androidx.annotation;
-            """
-        )
-
     /** TYPE_USE version of [com.android.tools.metalava.intRangeAnnotationSource] */
     val intRangeTypeUseSource =
         java(
@@ -189,22 +165,6 @@ object KnownSourceFiles {
         """
         )
 
-    val supportParameterName =
-        java(
-            """
-                package androidx.annotation;
-                import java.lang.annotation.*;
-                import static java.lang.annotation.ElementType.*;
-                import static java.lang.annotation.RetentionPolicy.SOURCE;
-                @SuppressWarnings("WeakerAccess")
-                @Retention(SOURCE)
-                @Target({METHOD, PARAMETER, FIELD})
-                public @interface ParameterName {
-                    String value();
-                }
-            """
-        )
-
     val systemApiSource: TestFile =
         TestFiles.java(
             """
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt
new file mode 100644
index 000000000..31f5f7622
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+
+private val standardClasspath = getKotlinStdlibPaths() + getAndroidJar()
+val standardProjectXmlClasspath =
+    standardClasspath.joinToString("\n") { "<classpath file=\"$it\"/>" }
+
+/** The XML string for one module of a project (using the [standardProjectXmlClasspath]). */
+fun createModuleDescription(
+    moduleName: String,
+    android: Boolean,
+    sourceFiles: Array<TestFile>,
+    dependsOn: List<String> = listOf("commonMain"),
+): String {
+    val sourceLines = sourceFiles.joinToString("\n") { "<src file=\"${it.targetRelativePath}\" />" }
+    val dependsOnLines = dependsOn.joinToString("\n") { "<dep module=\"$it\" kind=\"dependsOn\"/>" }
+    return """
+        <module name="$moduleName" android="$android">
+          $dependsOnLines
+          $sourceLines
+          $standardProjectXmlClasspath
+        </module>
+        """
+}
+
+/** The XML string for the common module of a project. */
+fun createCommonModuleDescription(sourceFiles: Array<TestFile>): String {
+    return createModuleDescription("commonMain", false, sourceFiles, emptyList())
+}
+
+/** The XML string for the android module of a project. */
+fun createAndroidModuleDescription(
+    sourceFiles: Array<TestFile>,
+    dependsOn: List<String> = listOf("commonMain"),
+): String {
+    return createModuleDescription("androidMain", true, sourceFiles, dependsOn)
+}
+
+/** The XML string for a project, with no root dir set (so the file location is the root dir). */
+fun createProjectDescription(vararg modules: String): TestFile {
+    return xml(
+        "project.xml",
+        """
+        <project>
+          ${modules.joinToString("\n")}
+        </project>
+        """
+    )
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/TemporaryFolderOwner.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TemporaryFolderOwner.kt
index 93eab79f8..0a045f036 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/TemporaryFolderOwner.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TemporaryFolderOwner.kt
@@ -31,41 +31,104 @@ interface TemporaryFolderOwner {
      * write the files to the folder and then return the folder.
      */
     fun createProject(files: Array<TestFile>): File {
-        val dir = newFolder("project")
+        val dir = getOrCreateFolder("project")
 
         files.map { it.createFile(dir) }.forEach { assertNotNull(it) }
 
         return dir
     }
 
-    fun newFolder(children: String = ""): File {
-        val dir = File(temporaryFolder.root.path, children)
-        return if (dir.exists()) {
+    /**
+     * Get a folder with a path [relative] to the root.
+     *
+     * Use an existing folder, or create a new one if necessary. It is an error if a file exists but
+     * is not a directory.
+     */
+    fun getOrCreateFolder(relative: String = ""): File {
+        val dir = temporaryFolder.root.resolve(relative)
+        // If the directory exists and is a directory then use it, otherwise drop through to create
+        // a new one. If the directory exists but is not a directory then attempting to create a new
+        // one will report an issue.
+        return if (dir.isDirectory) {
             dir
         } else {
-            temporaryFolder.newFolder(children)
+            temporaryFolder.newFolder(relative)
         }
     }
 
-    fun newFile(children: String = ""): File {
-        val dir = File(temporaryFolder.root.path, children)
-        return if (dir.exists()) {
-            dir
+    /**
+     * Get a file with a path [relative] to the root.
+     *
+     * Use an existing file, or create an empty new one if necessary. It is an error if a file
+     * exists but is not a normal file.
+     */
+    fun getOrCreateFile(relative: String = ""): File {
+        val file = temporaryFolder.root.resolve(relative)
+        // If the file exists and is a normal file then use it, otherwise drop through to create
+        // a new one. If the file exists but is not a normal file then attempting to create a new
+        // one will report an issue.
+        return if (file.isFile) {
+            file
         } else {
-            temporaryFolder.newFile(children)
+            file.parentFile.mkdirs()
+            temporaryFolder.newFile(relative)
         }
     }
 
-    /** Hides path prefixes from /tmp folders used by the testing infrastructure */
+    /** Create a file (and containing directory if necessary) with a path [relative] to the root. */
+    fun newFile(relative: String = ""): File {
+        val file = temporaryFolder.root.resolve(relative)
+        file.parentFile.mkdirs()
+        return temporaryFolder.newFile(relative)
+    }
+
+    /**
+     * Build a file structure in the directory [relative] to the root.
+     *
+     * Creates the directory first, if needed. Then creates a [DirectoryBuilder] for the directory
+     * and then invokes [body] on it to populate the directory.
+     */
+    fun buildFileStructure(relative: String = "", body: DirectoryBuilder.() -> Unit): File {
+        val dir = getOrCreateFolder(relative)
+        dir.buildFileStructure(body)
+        return dir
+    }
+
+    /**
+     * Hides path prefixes from /tmp folders used by the testing infrastructure.
+     *
+     * First, if [project] is provided, this will replace any usages of its [File.getPath] or
+     * [File.getCanonicalPath] with `TESTROOT`.
+     *
+     * Finally, it will replace the [temporaryFolder]'s [TemporaryFolder.getRoot] with `TESTROOT`.
+     */
     fun cleanupString(
         string: String,
         project: File? = null,
+    ) =
+        if (project == null) {
+            replaceFileWithSymbol(string)
+        } else {
+            replaceFileWithSymbol(string, mapOf(project to "TESTROOT"))
+        }
+
+    /**
+     * Hides path prefixes from /tmp folders used by the testing infrastructure.
+     *
+     * First, for each [Map.Entry] in [fileToSymbol] it will replace any usages of its
+     * [Map.Entry.key]'s [File.getPath] or [File.getCanonicalPath] with its [Map.Entry.value].
+     *
+     * Finally, it will replace the [temporaryFolder]'s [TemporaryFolder.getRoot] with `TESTROOT`.
+     */
+    fun replaceFileWithSymbol(
+        string: String,
+        fileToSymbol: Map<File, String> = emptyMap(),
     ): String {
         var s = string
 
-        if (project != null) {
-            s = s.replace(project.path, "TESTROOT")
-            s = s.replace(project.canonicalPath, "TESTROOT")
+        for ((file, symbol) in fileToSymbol) {
+            s = s.replace(file.path, symbol)
+            s = s.replace(file.canonicalPath, symbol)
         }
 
         s = s.replace(temporaryFolder.root.path, "TESTROOT")
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestFileCache.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestFileCache.kt
new file mode 100644
index 000000000..1aa52d0cc
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestFileCache.kt
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.File
+import java.nio.file.Files
+import org.junit.rules.TemporaryFolder
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+/**
+ * Cache [TestFile]s such that they can be easily shared between tests.
+ *
+ * The primary purpose of this is to amortize the cost of creating jars for testing by sharing the
+ * resulting [File] across multiple tests at the cost of increased disk usage. However, it can be
+ * used to cache, and share, any [TestFile] whose [TestFile.createFile] will create a [File] in the
+ * supplied `targetDir`.
+ *
+ * Must call [open] before calling [TestFile.createFile] on any [TestFile] returned from [cache].
+ */
+class TestFileCache : AutoCloseable {
+    /** The directory in which [File]s are created. */
+    private lateinit var cacheDir: File
+
+    /** Map from [TestFile.targetRelativePath] to [CachedTestFile] wrapper. */
+    private val targetRelativePathToTestFile = mutableMapOf<String, CachedTestFile>()
+
+    /**
+     * Open the cache for use by supplying it with a [cacheDir] in which it will create the [File]s.
+     *
+     * This can be called after calling [cache] to cache a [TestFile] but must be called before any
+     * of those [TestFile]s are created. Separating this from initialization allows the cache to be
+     * created and used to cache [TestFile]s without creating a directory that may never be used and
+     * may not be easily cleaned up.
+     *
+     * It is the responsibility of the caller of [open] to ensure that [cacheDir] is deleted, either
+     * by calling [close] or some other way, e.g. by passing in a directory created by
+     * [TemporaryFolder].
+     */
+    fun open(cacheDir: File): TestFileCache {
+        if (::cacheDir.isInitialized) {
+            error(
+                "Cannot open cache with `$cacheDir` as it has already been opened with `${this.cacheDir}"
+            )
+        }
+        this.cacheDir = cacheDir
+        return this
+    }
+
+    /**
+     * Cache a [TestFile] for sharing.
+     *
+     * This returns a [TestFile] wrapper around [testFile] that will ensure that [testFile] will
+     * only be created once within this cache. The [TestFile.targetRelativePath] must uniquely
+     * identify [testFile] among all [TestFile]s added to this cache.
+     */
+    fun cache(testFile: TestFile): TestFile {
+        val relative =
+            testFile.targetRelativePath
+                ?: error("Cannot cache $testFile as it has no targetRelativePath")
+        val existing = targetRelativePathToTestFile[relative]
+        if (existing != null) {
+            if (existing.underlying !== testFile) {
+                error(
+                    "Cannot cache $testFile as its targetRelativePath of `$relative` clashes with $existing"
+                )
+            }
+            return existing
+        }
+
+        val cached = CachedTestFile(testFile).apply { to(testFile.targetRelativePath) }
+        targetRelativePathToTestFile[relative] = cached
+        return cached
+    }
+
+    override fun close() {
+        if (::cacheDir.isInitialized) {
+            cacheDir.deleteRecursively()
+        }
+    }
+
+    private fun createUnderlyingFile(underlyingFile: TestFile): TestFile {
+        if (!::cacheDir.isInitialized) {
+            error("Cannot create underlying file as cache has not yet been opened")
+        }
+        val file = underlyingFile.createFile(cacheDir)
+        // Compute the path of the newly created file relative to the directory.
+        val relative = file.relativeTo(cacheDir).path
+
+        // Create a TestFile that when created will create a symbolic link to `file` in the same
+        // directory relative to the target directory.
+        return file.toTestFile().to(relative)
+    }
+
+    /** Wrapper around a [TestFile] that ensures that only one instance will be created. */
+    private inner class CachedTestFile(val underlying: TestFile) : TestFile() {
+        /** Lazily create the [File] from [underlying] and wrap in a [TestFile]. */
+        private val file by lazy { createUnderlyingFile(underlying) }
+
+        override fun createFile(targetDir: File?): File =
+            // Create the underlying file if necessary and then create a symbolic link to it.
+            file.createFile(targetDir)
+    }
+}
+
+/**
+ * A [TestRule] that is intended to be used with `@ClassRule` to create a per test class cache of
+ * [TestFile]s.
+ *
+ * It can also be used with `@Rule` to create a per test cache if a [TestFile] might be created
+ * multiple times within the same test.
+ */
+class TestFileCacheRule : TestRule {
+    /**
+     * Create the [TestFileCache] immediately so it can be used to cache [TestFile]s before entering
+     * the [Statement] returned by [apply].
+     */
+    private var _cache: TestFileCache? = TestFileCache()
+
+    /** Get the cache to use. */
+    val cache: TestFileCache
+        get() = _cache ?: error("Cannot access cache outside test run")
+
+    override fun apply(base: Statement, description: Description): Statement {
+        return object : Statement() {
+            override fun evaluate() {
+                try {
+                    val cacheDir = Files.createTempDirectory("test-file-cache").toFile()
+                    _cache!!.open(cacheDir).use { base.evaluate() }
+                } finally {
+                    // Prevent the cache from being accessed after it has been used.
+                    _cache = null
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Cache this [TestFile] in [cache].
+ *
+ * Returns a [TestFile] that will only create this file once and will use a symbolic link to add it
+ * to the `targetDir` of [TestFile.createFile].
+ */
+fun TestFile.cacheIn(cache: TestFileCache) = cache.cache(this)
+
+/**
+ * Cache this [TestFile] in [cacheRule]'s [TestFileCacheRule.cache].
+ *
+ * Returns a [TestFile] that will only create this file once and will use a symbolic link to add it
+ * to the `targetDir` of [TestFile.createFile].
+ */
+fun TestFile.cacheIn(cacheRule: TestFileCacheRule) = cacheRule.cache.cache(this)
diff --git a/metalava-testing/src/test/java/com/android/tools/metalava/testing/DirectoryBuilderTest.kt b/metalava-testing/src/test/java/com/android/tools/metalava/testing/DirectoryBuilderTest.kt
new file mode 100644
index 000000000..8f7fc2449
--- /dev/null
+++ b/metalava-testing/src/test/java/com/android/tools/metalava/testing/DirectoryBuilderTest.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import java.io.File
+import java.util.jar.JarInputStream
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class DirectoryBuilderTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    private fun File.assertJarFileContents(expected: String) {
+        val entries = buildList {
+            JarInputStream(inputStream()).use { inputStream ->
+                var entry = inputStream.nextEntry
+                while (entry != null) {
+                    if (!entry.isDirectory) {
+                        this.add(entry.name)
+                    }
+                    entry = inputStream.nextEntry
+                }
+            }
+        }
+        assertEquals(expected, entries.sorted().joinToString("\n").trim())
+    }
+
+    @Test
+    fun `Test jar with classpath`() {
+        lateinit var jarFile: File
+        buildFileStructure {
+            val classPathJarFile =
+                jar(
+                    "classpath.jar",
+                    java(
+                        """
+                        package test.pkg;
+                        public class Bar {}
+                    """
+                    ),
+                )
+
+            // This will fail to compile if the class path is not provided.
+            jarFile =
+                jar(
+                    "test.jar",
+                    java(
+                        """
+                        package test.pkg;
+                        public class Foo extends Bar {}
+                    """
+                    ),
+                    classPath = listOf(classPathJarFile.toTestFile()),
+                )
+        }
+
+        jarFile.assertJarFileContents("test/pkg/Foo.class")
+    }
+}
diff --git a/metalava-testing/src/test/java/com/android/tools/metalava/testing/TestFileCacheTest.kt b/metalava-testing/src/test/java/com/android/tools/metalava/testing/TestFileCacheTest.kt
new file mode 100644
index 000000000..d1eab545a
--- /dev/null
+++ b/metalava-testing/src/test/java/com/android/tools/metalava/testing/TestFileCacheTest.kt
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import java.io.File
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class TestFileCacheTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    @get:Rule val testFileCacheRule = TestFileCacheRule()
+
+    private val underlyingTestFile = TouchCountingTestFile().apply { to("subdir/cached.txt") }
+
+    private val cachedTestFile = underlyingTestFile.cacheIn(testFileCacheRule)
+
+    /** Check that this [TestFile] creates a file properly in [targetDirName]. */
+    private fun TestFile.checkTestFileCreated(targetDirName: String) {
+        val dir = temporaryFolder.newFolder(targetDirName)
+        val file = createFile(dir)
+        assertEquals(dir.resolve(targetPath), file, "created file has wrong path")
+        assertTrue(file.exists(), "$targetDirName file does not exist")
+    }
+
+    @Test
+    fun `Test normal TestFile is called multiple times`() {
+        val normalTestFile = TouchCountingTestFile().apply { to("subdir/uncached.txt") }
+
+        normalTestFile.checkTestFileCreated("first")
+        normalTestFile.checkTestFileCreated("second")
+
+        assertEquals(2, normalTestFile.count)
+    }
+
+    @Test
+    fun `Test cached TestFile is only called once`() {
+        cachedTestFile.checkTestFileCreated("first")
+        cachedTestFile.checkTestFileCreated("second")
+
+        assertEquals(1, underlyingTestFile.count)
+    }
+
+    class TouchCountingTestFile : TestFile() {
+        var count: Int = 0
+
+        override fun createFile(targetDir: File): File {
+            count += 1
+            val file = targetDir.resolve(targetPath)
+            file.parentFile.mkdirs()
+            file.writeText("")
+            return file
+        }
+    }
+}
diff --git a/metalava/Android.bp b/metalava/Android.bp
index d9d75cf33..615d819db 100644
--- a/metalava/Android.bp
+++ b/metalava/Android.bp
@@ -33,6 +33,7 @@ java_binary_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
+    kotlin_lang_version: "2",
     java_resources: [
         ":metalava-version",
         ":metalava-resources",
diff --git a/metalava/build.gradle.kts b/metalava/build.gradle.kts
index 34119e1ba..b4a8842ed 100644
--- a/metalava/build.gradle.kts
+++ b/metalava/build.gradle.kts
@@ -47,6 +47,8 @@ dependencies {
     implementation(libs.asm)
     implementation(libs.asmTree)
     implementation(libs.gson)
+    implementation(libs.jacksonDataformatXml)
+    implementation(libs.jacksonModuleKotlin)
 
     testImplementation(project(":metalava-model-turbine"))
     testImplementation(project(":metalava-testing"))
@@ -61,6 +63,8 @@ dependencies {
 /** The location into which a fake representation of the prebuilts/sdk directory will be written. */
 val testPrebuiltsSdkDir = layout.buildDirectory.dir("prebuilts/sdk")
 
+val testDataDir = layout.projectDirectory.dir("src/testdata")
+
 /**
  * Register tasks to emulate parts of the prebuilts/sdk repository using source from this directory.
  *
@@ -139,8 +143,13 @@ project.tasks.register("test-prebuilts-sdk") {
 
 tasks.named<Test>("test").configure {
     dependsOn("test-prebuilts-sdk")
-    setEnvironment(
-        "METALAVA_TEST_PREBUILTS_SDK_ROOT" to testPrebuiltsSdkDir.get().asFile.absolutePath
+
+    // Add some additional environment variables to pass in some directories needed by the test.
+    environment.putAll(
+        mapOf(
+            "METALAVA_TEST_PREBUILTS_SDK_ROOT" to testPrebuiltsSdkDir.get().asFile.absolutePath,
+            "METALAVA_TESTDATA_DIR" to testDataDir.asFile.absolutePath,
+        )
     )
 }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
index 03c0b02c8..b0b6c15a7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
@@ -210,7 +210,7 @@ class AndroidApiChecks(val reporter: Reporter) {
                         attribute.leafValues().mapTo(permissions) { it.toSource() }
                     }
                     "conditional" -> {
-                        conditional = attribute.value.value() == true
+                        conditional = attribute.legacyValue.value() == true
                     }
                 }
             }
diff --git a/metalava/src/main/java/com/android/tools/metalava/AndroidJarsToSignaturesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/AndroidJarsToSignaturesCommand.kt
deleted file mode 100644
index ca0b486d7..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/AndroidJarsToSignaturesCommand.kt
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava
-
-import com.android.tools.metalava.cli.common.MetalavaCliException
-import com.android.tools.metalava.cli.common.MetalavaSubCommand
-import com.android.tools.metalava.cli.common.executionEnvironment
-import com.android.tools.metalava.cli.common.existingDir
-import com.android.tools.metalava.cli.common.progressTracker
-import com.android.tools.metalava.cli.common.stderr
-import com.android.tools.metalava.cli.common.stdout
-import com.android.tools.metalava.cli.signature.SignatureFormatOptions
-import com.android.tools.metalava.reporter.BasicReporter
-import com.github.ajalt.clikt.parameters.arguments.argument
-import com.github.ajalt.clikt.parameters.arguments.validate
-import com.github.ajalt.clikt.parameters.groups.provideDelegate
-
-private const val ARG_ANDROID_ROOT_DIR = "<android-root-dir>"
-
-class AndroidJarsToSignaturesCommand :
-    MetalavaSubCommand(
-        help =
-            """
-    Rewrite the signature files in the `prebuilts/sdk` directory in the Android source tree.
-
-    It does this by reading the API defined in the corresponding `android.jar` files.
-"""
-                .trimIndent(),
-    ) {
-
-    private val androidRootDir by
-        argument(
-                ARG_ANDROID_ROOT_DIR,
-                help =
-                    """
-        The root directory of the Android source tree. The new signature files will be generated in
-        the `prebuilts/sdk/<api>/public/api/android.txt` sub-directories.
-    """
-                        .trimIndent()
-            )
-            .existingDir()
-            .validate {
-                require(it.resolve("prebuilts/sdk").isDirectory) {
-                    throw MetalavaCliException(
-                        "$ARG_ANDROID_ROOT_DIR does not point to an Android source tree"
-                    )
-                }
-            }
-
-    /** Add options for controlling the format of the generated files. */
-    private val signatureFormat by SignatureFormatOptions()
-
-    override fun run() {
-        // Make sure that none of the code called by this command accesses the global `options`
-        // property.
-        OptionsDelegate.disallowAccess()
-
-        StandaloneJarCodebaseLoader.create(
-                executionEnvironment,
-                progressTracker,
-                BasicReporter(stderr),
-            )
-            .use { jarCodebaseLoader ->
-                ConvertJarsToSignatureFiles(
-                        stderr,
-                        stdout,
-                        progressTracker,
-                        signatureFormat.fileFormat,
-                    )
-                    .convertJars(jarCodebaseLoader, androidRootDir)
-            }
-    }
-}
diff --git a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
index 8418ac314..cf252f4f6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
@@ -41,7 +41,7 @@ import com.android.tools.lint.annotations.Extractor.IDEA_NULLABLE
 import com.android.tools.lint.annotations.Extractor.SUPPORT_NOTNULL
 import com.android.tools.lint.annotations.Extractor.SUPPORT_NULLABLE
 import com.android.tools.lint.detector.api.getChildren
-import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.model.ANDROIDX_INT_DEF
 import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
@@ -103,11 +103,7 @@ class AnnotationsMerger(
     fun mergeInclusionAnnotationsFromFiles(files: List<File>) {
         mergeAll(
             files,
-            {
-                throw MetalavaCliException(
-                    "External inclusion annotations files must be .java, found ${it.path}"
-                )
-            },
+            { cliError("External inclusion annotations files must be .java, found ${it.path}") },
             ::mergeInclusionAnnotationsFromCodebase
         )
     }
@@ -136,10 +132,10 @@ class AnnotationsMerger(
                 val javaStubsCodebase =
                     sourceParser.parseSources(
                         SourceSet(javaStubFiles, roots),
-                        SourceSet.empty(),
                         "Codebase loaded from stubs",
                         classPath = options.classpath,
                         apiPackages = options.apiPackages,
+                        projectDescription = null,
                     )
                 mergeJavaStubsCodebase(javaStubsCodebase)
             }
@@ -252,7 +248,7 @@ class AnnotationsMerger(
             mergeQualifierAnnotationsFromCodebase(signatureCodebase)
         } catch (ex: ApiParseException) {
             val message = "Unable to parse signature file $file: ${ex.message}"
-            throw MetalavaCliException(message)
+            cliError(message)
         }
     }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
index 9139295c6..9e7829f18 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.apilevels.internalDesc
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION
@@ -117,10 +118,6 @@ class ApiAnalyzer(
         propagateHiddenRemovedAndDocOnly()
     }
 
-    // TODO: Annotation test: @ParameterName, if present, must be supplied on *all* the arguments!
-    // Warn about @DefaultValue("null"); they probably meant @DefaultNull
-    // Supplying default parameter in override is not allowed!
-
     fun generateInheritedStubs(filterEmit: FilterPredicate, filterReference: FilterPredicate) {
         // When analyzing libraries we may discover some new classes during traversal; these aren't
         // part of the API but may be super classes or interfaces; these will then be added into the
@@ -330,6 +327,24 @@ class ApiAnalyzer(
                 return@forEach
             }
 
+            val runtimeDesc = it.internalDesc()
+            val stubDesc = method.internalDesc()
+            if (filterEmit.test(method) && runtimeDesc != stubDesc) {
+                // This is problematic primarily for the platform where we use stubs, and the
+                // generated method in the android.jar won't actually exist at runtime.
+                // While we don't use stubs in AndroidX, this can still cause compat issues because
+                // the current.txt (which will show the equivalent of stubDesc) won't actually match
+                // the ABI of the library (because call sites will reference runtimeDesc).
+                reporter.report(
+                    Issues.INHERIT_CHANGES_SIGNATURE,
+                    it,
+                    "Explicitly override $it in $cls, or hide it in ${it.containingClass()};" +
+                        " it cannot be implicitly inherited as API from the hidden super class" +
+                        " because that would change its erased signature from $runtimeDesc to" +
+                        " $stubDesc, and cause failures at runtime.",
+                )
+            }
+
             cls.addMethod(method)
 
             // Make sure that the same method is not added from multiple super classes.
@@ -561,7 +576,7 @@ class ApiAnalyzer(
                                 )
                             } else {
                                 val value = deprecatedForSdk.findAttribute(ANNOTATION_ATTR_VALUE)
-                                val message = value?.value?.value()?.toString() ?: ""
+                                val message = value?.legacyValue?.value()?.toString() ?: ""
                                 item.appendDocumentation(message, "@deprecated")
                             }
                         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt b/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt
new file mode 100644
index 000000000..b57842897
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.config.ApiFlagConfig
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.IMMUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.MUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Status.DISABLED
+import com.android.tools.metalava.config.ApiFlagConfig.Status.ENABLED
+import com.android.tools.metalava.config.ApiFlagsConfig
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.api.flags.ApiFlags
+import com.android.utils.associateNotNull
+
+/** Create [ApiFlags] from some source of information about the flags. */
+object ApiFlagsCreator {
+    /** Create [ApiFlags] from [apiFlagsConfig]. */
+    fun createFromConfig(apiFlagsConfig: ApiFlagsConfig?): ApiFlags? {
+        return apiFlagsConfig?.createApiFlags()
+    }
+
+    /** Create [ApiFlags] from [ApiFlagsConfig]. */
+    private fun ApiFlagsConfig.createApiFlags(): ApiFlags {
+        val byQualifiedName = flags.associateNotNull { config -> config.createApiFlag() }
+        return ApiFlags(byQualifiedName)
+    }
+
+    /**
+     * Create [Pair] of qualified flag name and [ApiFlag] from [ApiFlagConfig].
+     *
+     * Returns `null` if [ApiFlagConfig.mutability] is [IMMUTABLE] and [ApiFlagConfig.status] is
+     * [DISABLED] as that is the default [ApiFlags.get] returns for flags that cannot be found.
+     */
+    private fun ApiFlagConfig.createApiFlag(): Pair<String, ApiFlag>? {
+        val apiFlag =
+            when (mutability) {
+                MUTABLE -> ApiFlag.KEEP_FLAGGED_API
+                IMMUTABLE ->
+                    when (status) {
+                        ENABLED -> ApiFlag.FINALIZE_FLAGGED_API
+                        DISABLED -> return null
+                    }
+            }
+        val qualifiedName = "$pkg.$name"
+        return Pair(qualifiedName, apiFlag)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
index eeeab7e1d..6ad81f620 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
@@ -17,34 +17,39 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.apilevels.ApiGenerator
-import com.android.tools.metalava.apilevels.ApiJsonPrinter
+import com.android.tools.metalava.apilevels.ApiHistoryUpdater
 import com.android.tools.metalava.apilevels.ApiVersion
-import com.android.tools.metalava.apilevels.ApiXmlPrinter
-import com.android.tools.metalava.apilevels.GenerateApiVersionsFromVersionedApisConfig
-import com.android.tools.metalava.apilevels.GenerateXmlConfig
+import com.android.tools.metalava.apilevels.ExtVersion
+import com.android.tools.metalava.apilevels.GenerateApiHistoryConfig
+import com.android.tools.metalava.apilevels.MatchedPatternFile
+import com.android.tools.metalava.apilevels.MissingClassAction
+import com.android.tools.metalava.apilevels.PatternNode
+import com.android.tools.metalava.apilevels.SdkExtensionInfo
+import com.android.tools.metalava.apilevels.VersionedApi
+import com.android.tools.metalava.apilevels.VersionedJarApi
 import com.android.tools.metalava.apilevels.VersionedSignatureApi
 import com.android.tools.metalava.apilevels.VersionedSourceApi
 import com.android.tools.metalava.cli.common.EarlyOptions
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
-import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.RequiresOtherGroups
 import com.android.tools.metalava.cli.common.SignatureFileLoader
-import com.android.tools.metalava.cli.common.existingDir
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.fileForPathInner
 import com.android.tools.metalava.cli.common.map
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.OptionWithValues
+import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.default
 import com.github.ajalt.clikt.parameters.options.flag
 import com.github.ajalt.clikt.parameters.options.multiple
 import com.github.ajalt.clikt.parameters.options.option
 import com.github.ajalt.clikt.parameters.options.split
-import com.github.ajalt.clikt.parameters.options.validate
-import com.github.ajalt.clikt.parameters.types.int
 import java.io.File
-import java.io.IOException
 
 // XML API version related arguments.
 const val ARG_GENERATE_API_LEVELS = "--generate-api-levels"
@@ -58,17 +63,25 @@ const val ARG_CURRENT_CODENAME = "--current-codename"
 
 const val ARG_ANDROID_JAR_PATTERN = "--android-jar-pattern"
 
-const val ARG_SDK_JAR_ROOT = "--sdk-extensions-root"
 const val ARG_SDK_INFO_FILE = "--sdk-extensions-info"
 
+const val ARG_API_VERSION_SIGNATURE_PATTERN = "--api-version-signature-pattern"
+
 // JSON API version related arguments
 const val ARG_GENERATE_API_VERSION_HISTORY = "--generate-api-version-history"
 const val ARG_API_VERSION_SIGNATURE_FILES = "--api-version-signature-files"
-const val ARG_API_VERSION_NAMES = "--api-version-names"
+
+/**
+ * Factory for creating a [VersionedApi] from an [ApiHistoryUpdater] and a list of
+ * [MatchedPatternFile].
+ */
+private typealias VersionedApiFactory =
+    (ApiHistoryUpdater, List<MatchedPatternFile>) -> VersionedApi
 
 class ApiLevelsGenerationOptions(
     private val executionEnvironment: ExecutionEnvironment = ExecutionEnvironment(),
     private val earlyOptions: EarlyOptions = EarlyOptions(),
+    private val apiSurfacesProvider: () -> ApiSurfaces? = { null },
 ) :
     OptionGroup(
         name = "Api Levels Generation",
@@ -77,7 +90,13 @@ class ApiLevelsGenerationOptions(
                 Options controlling the API levels file, e.g. `api-versions.xml` file.
             """
                 .trimIndent()
-    ) {
+    ),
+    RequiresOtherGroups {
+
+    /** Make sure that the [earlyOptions] is correctly initialized when testing. */
+    override val requiredGroups: List<OptionGroup>
+        get() = listOf(earlyOptions)
+
     /** API level XML file to generate. */
     val generateApiLevelXml: File? by
         option(
@@ -86,7 +105,8 @@ class ApiLevelsGenerationOptions(
                 help =
                     """
                         Reads android.jar SDK files and generates an XML file recording the API
-                        level for each class, method and field
+                        level for each class, method and field. The $ARG_CURRENT_VERSION must also
+                        be provided and must be greater than or equal to 27.
                     """
                         .trimIndent(),
             )
@@ -107,62 +127,63 @@ class ApiLevelsGenerationOptions(
             )
             .flag()
 
+    /** Convert an option value to an [ApiVersion]. */
+    fun OptionWithValues<String?, String, String>.apiVersion() = convert {
+        ApiVersion.fromString(it)
+    }
+
     /**
-     * The first api level of the codebase; typically 1 but can be higher for example for the System
-     * API.
+     * The first api version of the codebase; typically 1 but can be higher for example for the
+     * System API.
      */
-    private val firstApiLevel: Int by
+    private val firstApiVersion: ApiVersion by
         option(
                 ARG_FIRST_VERSION,
-                metavar = "<numeric-version>",
+                metavar = "<api-version>",
                 help =
                     """
-                        Sets the first API level to generate an API database from.
+                        Sets the first API version to include in the API history file. See
+                        $ARG_CURRENT_VERSION for acceptable `<api-version>`s.
                     """
                         .trimIndent()
             )
-            .int()
-            .default(1)
+            .apiVersion()
+            .default(ApiVersion.fromLevel(1))
 
     /**
      * The last api level.
      *
-     * This is one more than [currentApiLevel] if this is a developer preview build.
+     * This is one more than [currentApiVersion] if this is a developer preview build.
      */
-    private val lastApiLevel
-        get() = currentApiLevel + if (isDeveloperPreviewBuild) 1 else 0
+    private val lastApiVersion
+        get() = currentApiVersion + if (isDeveloperPreviewBuild) 1 else 0
 
-    /** The api level of the codebase, or null if not known/specified */
-    private val optionalCurrentApiLevel: Int? by
+    /** The [ApiVersion] of the codebase, or null if not known/specified */
+    private val optionalCurrentApiVersion: ApiVersion? by
         option(
                 ARG_CURRENT_VERSION,
-                metavar = "<numeric-version>",
+                metavar = "<api-version>",
                 help =
                     """
-                        Sets the current API level of the current source code. Must be greater than
-                        or equal to 27.
+                        Sets the current API version of the current source code. This supports a
+                        single integer level, `major.minor`, `major.minor.patch` and
+                        `major.minor.patch-quality` formats. Where `major`, `minor` and `patch` are
+                        all non-negative integers and `quality` is an alphanumeric string.
                     """
                         .trimIndent(),
             )
-            .int()
-            .validate {
-                if (it <= 26) {
-                    throw MetalavaCliException("Suspicious currentApi=$it, expected at least 27")
-                }
-            }
+            .apiVersion()
 
     /**
-     * Get the current API level.
+     * Get the current API version.
      *
      * This must only be called if needed as it will fail if [ARG_CURRENT_VERSION] has not been
      * specified.
      */
-    private val currentApiLevel: Int
+    internal val currentApiVersion: ApiVersion
         get() =
-            optionalCurrentApiLevel
-                ?: throw MetalavaCliException(
-                    stderr = "$ARG_GENERATE_API_LEVELS requires $ARG_CURRENT_VERSION"
-                )
+            optionalCurrentApiVersion
+                ?: cliError("$ARG_GENERATE_API_LEVELS requires $ARG_CURRENT_VERSION")
 
     /**
      * The codename of the codebase: non-null string if this is a developer preview build, null if
@@ -180,7 +201,12 @@ class ApiLevelsGenerationOptions(
             )
             .map { if (it == "REL") null else it }
 
-    /** True if [currentCodeName] is specified, false otherwise. */
+    /**
+     * True if [currentCodeName] is specified, false otherwise.
+     *
+     * If this is `true` then the API defined in the sources will be added to the API levels file
+     * with an API level of [currentApiVersion]` - 1`.
+     */
     private val isDeveloperPreviewBuild
         get() = currentCodeName != null
 
@@ -188,43 +214,34 @@ class ApiLevelsGenerationOptions(
     private val androidJarPatterns: List<String> by
         option(
                 ARG_ANDROID_JAR_PATTERN,
-                metavar = "<android-jar-pattern>",
+                metavar = "<historical-api-pattern>",
                 help =
                     """
-                        Pattern to use to locate Android JAR files. Each pattern must contain a %
-                        character that will be replaced with each API level that is being included
-                        and if the result is an existing jar file then it will be taken as the
-                        definition of the API at that level.
+                        Pattern to use to locate Android JAR files. Must end with `.jar`.
+
+                        See `metalava help historical-api-patterns` for more information.
                     """
                         .trimIndent(),
             )
             .multiple(default = emptyList())
-            .map {
-                buildList {
-                    addAll(it)
-                    // Fallbacks
-                    add("prebuilts/tools/common/api-versions/android-%/android.jar")
-                    add("prebuilts/sdk/%/public/android.jar")
-                }
-            }
 
-    /** Directory of prebuilt extension SDK jars that contribute to the API */
-    private val sdkJarRoot: File? by
+    /**
+     * The list of patterns used to find matching signature files in the set of files visible to
+     * Metalava.
+     */
+    private val signaturePatterns by
         option(
-                ARG_SDK_JAR_ROOT,
-                metavar = "<sdk-jar-root>",
+                ARG_API_VERSION_SIGNATURE_PATTERN,
+                metavar = "<historical-api-pattern>",
                 help =
                     """
-                        Points to root of prebuilt extension SDK jars, if any. This directory is
-                        expected to contain snapshots of historical extension SDK versions in the
-                        form of stub jars. The paths should be on the format
-                        \"<int>/public/<module-name>.jar\", where <int> corresponds to the extension
-                        SDK version, and <module-name> to the name of the mainline module.
+                        Pattern to use to locate signature files. Typically ends with `.txt`.
+
+                        See `metalava help historical-api-patterns` for more information.
                     """
                         .trimIndent(),
             )
-            .existingDir()
-            .validate { checkSdkJarRootAndSdkInfoFile() }
+            .multiple()
 
     /**
      * Rules to filter out some extension SDK APIs from the API, and assign extensions to the APIs
@@ -251,108 +268,106 @@ class ApiLevelsGenerationOptions(
                         whitespace. A mainline module may be listed multiple times.
                         The special pattern \"*\" refers to all APIs in the given mainline module.
                         Lines beginning with # are comments.
+
+                        If specified then the $ARG_ANDROID_JAR_PATTERN must include at least one
+                        pattern that uses `{version:extension}` and `{module}` placeholders and that
+                        pattern must match at least one file.
                     """
                         .trimIndent(),
             )
             .existingFile()
-            .validate { checkSdkJarRootAndSdkInfoFile() }
-
-    /**
-     * Check the [sdkJarRoot] and [sdkInfoFile] to make sure that if one is specified they are both
-     * specified
-     *
-     * This is called if either of those is set to a non-null value so all this needs to do is make
-     * sure that neither are `null`.
-     */
-    private fun checkSdkJarRootAndSdkInfoFile() {
-        if ((sdkJarRoot == null) || (sdkInfoFile == null)) {
-            throw MetalavaCliException(
-                stderr = "$ARG_SDK_JAR_ROOT and $ARG_SDK_INFO_FILE must both be supplied"
-            )
-        }
-    }
 
     /**
-     * Get label for [level].
+     * Get label for [version].
      *
-     * If a codename has been specified and [level] is greater than the current API level (which
-     * defaults to `-1` when not set) then use the codename as the label, otherwise use the number
-     * itself.
+     * If a codename has been specified and [version] is greater than the current API version (which
+     * defaults to `null` when not set) then use the codename as the label, otherwise use the
+     * version itself.
      */
-    fun getApiLevelLabel(level: Int): String {
+    fun getApiVersionLabel(version: ApiVersion): String {
         val codename = currentCodeName
-        val current = optionalCurrentApiLevel
-        return if (current == null || codename == null || level <= current) level.toString()
+        val current = optionalCurrentApiVersion
+        return if (current == null || codename == null || version <= current) version.toString()
         else codename
     }
 
     /**
-     * Check whether [level] should be included in documentation.
+     * Check whether [version] should be included in documentation.
      *
-     * If [isDeveloperPreviewBuild] is `true` then allow any API level as the documentation is not
-     * going to be published outside Android, so it is safe to include all API levels, including the
-     * next one.
+     * If [isDeveloperPreviewBuild] is `true` then allow any [ApiVersion] as the documentation is
+     * not going to be published outside Android, so it is safe to include all [ApiVersion]s,
+     * including the next one.
      *
-     * If no [currentApiLevel] has been provided then allow any API level as there is no way to
-     * determine whether the API level is a future API or not.
+     * If no [currentApiVersion] has been provided then allow any [ApiVersion] level as there is no
+     * way to determine whether the [ApiVersion] is a future API or not.
      *
-     * Otherwise, it is a release build so ignore any API levels after the current one.
+     * Otherwise, it is a release build so ignore any [ApiVersion]s after the current one.
      */
-    fun includeApiLevelInDocumentation(level: Int): Boolean {
+    fun includeApiVersionInDocumentation(version: ApiVersion): Boolean {
         if (isDeveloperPreviewBuild) return true
-        val current = optionalCurrentApiLevel ?: return true
-        return level <= current
+        val current = optionalCurrentApiVersion ?: return true
+        return version <= current
     }
 
     /**
-     * The list of jar files from which the API levels file will be populated. One for each API
-     * level, indexed by API level, starting from 1. The 0th element plus any element less than
-     * [firstApiLevel] is a placeholder that is an invalid file and should not be used.
+     * Find all historical files that matches the patterns in [patterns] and are in the range from
+     * [firstApiVersion] to [lastApiVersion].
+     *
+     * @param dir the directory to scan.
+     * @param patterns the patterns that determine the files that will be found.
      */
-    private val apiLevelJars
-        get() = findAndroidJars()
-
-    /** Find an android stub jar that matches the given criteria. */
-    private fun findAndroidJars(): List<File> {
-        val apiLevelFiles = mutableListOf<File>()
-        // api level 0: placeholder, should not be processed.
-        // (This is here because we want the array index to match
-        // the API level)
-        val element = File("not an api: the starting API index is $firstApiLevel")
-        for (i in 0 until firstApiLevel) {
-            apiLevelFiles.add(element)
-        }
-
-        // Get all the android.jar. They are in platforms-#
-        for (apiLevel in firstApiLevel.rangeTo(lastApiLevel)) {
-            try {
-                val jar = getAndroidJarFile(apiLevel, androidJarPatterns)
-                if (jar == null || !jar.isFile) {
-                    verbosePrint { "Last API level found: ${apiLevel - 1}" }
-
-                    if (apiLevel < 28) {
-                        // Clearly something is wrong with the patterns; this should result in a
-                        // build error
-                        throw MetalavaCliException(
-                            stderr =
-                                "Could not find android.jar for API level $apiLevel; the " +
-                                    "$ARG_ANDROID_JAR_PATTERN set might be invalid see:" +
-                                    " ${androidJarPatterns.joinToString()} (the last two entries are defaults)"
-                        )
-                    }
-
-                    break
-                }
-
-                verbosePrint { "Found API $apiLevel at ${jar.path}" }
+    private fun findHistoricalFiles(dir: File, patterns: List<String>): List<MatchedPatternFile> {
+        // Find all the historical files for versions within the required range.
+        val patternNode = PatternNode.parsePatterns(patterns)
+        val versionRange = firstApiVersion.rangeTo(lastApiVersion)
+        val apiSurfaceByName = apiSurfacesProvider()?.byName
+        val scanConfig =
+            PatternNode.ScanConfig(
+                dir = dir,
+                apiVersionFilter = versionRange::contains,
+                apiSurfaceByName = apiSurfaceByName,
+            )
+        return patternNode.scan(scanConfig)
+    }
 
-                apiLevelFiles.add(jar)
-            } catch (e: IOException) {
-                e.printStackTrace()
-            }
+    /**
+     * Create [VersionedJarApi]s for each historical file in [matchedFiles].
+     *
+     * @param matchedFiles a list of files that matched the historical API patterns.
+     */
+    private fun constructVersionedApisForHistoricalFiles(
+        matchedFiles: List<MatchedPatternFile>,
+        versionedApiFactory: VersionedApiFactory,
+    ): List<VersionedApi> {
+        // TODO(b/383288863): Check to make sure that there is one VersionedApi for every major
+        //  version in the range.
+
+        val byVersion = matchedFiles.groupBy { it.version }
+
+        // Convert the MatchedPatternFiles into VersionedApis.
+        return byVersion.map { (apiVersion, files) ->
+            val updater = ApiHistoryUpdater.forApiVersion(apiVersion)
+            versionedApiFactory(updater, files)
         }
+    }
 
-        return apiLevelFiles.toList()
+    /**
+     * Create a [VersionedApi] from [updater] and [files].
+     *
+     * It requires [files] to contain a single entry.
+     */
+    private fun createVersionedJarApi(
+        updater: ApiHistoryUpdater,
+        files: List<MatchedPatternFile>,
+    ): VersionedApi {
+        val version = updater.apiVersion
+        val jar =
+            files.singleOrNull()?.file
+                ?: error(
+                    "Expected only one jar file for version $version but found ${files.size}:\n${files.joinToString("\n") {"    $it"}}"
+                )
+        verbosePrint { "Found API $version at $jar" }
+        return VersionedJarApi(jar, updater)
     }
 
     /** Print string returned by [message] if verbose output has been requested. */
@@ -362,37 +377,176 @@ class ApiLevelsGenerationOptions(
         }
     }
 
-    private fun getAndroidJarFile(apiLevel: Int, patterns: List<String>): File? {
-        return patterns
-            .map { fileForPathInner(it.replace("%", apiLevel.toString())) }
-            .firstOrNull { it.isFile }
-    }
+    /**
+     * Get the [GenerateApiHistoryConfig] for Android.
+     *
+     * This has some Android specific code, e.g. structure of SDK extensions.
+     */
+    fun forAndroidConfig(
+        signatureFileLoader: SignatureFileLoader,
+        codebaseFragmentProvider: () -> CodebaseFragment,
+    ) =
+        generateApiLevelXml?.let { outputFile ->
+            // Scan for all the files that could contribute to the API history.
+            val currentDir = fileForPathInner(".")
+            val (patterns, matchedFiles, versionedApiFactory) =
+                if (signaturePatterns.isEmpty()) {
+                    Triple(
+                        androidJarPatterns,
+                        findHistoricalFiles(currentDir, androidJarPatterns),
+                        ::createVersionedJarApi,
+                    )
+                } else if (androidJarPatterns.isNotEmpty()) {
+                    cliError(
+                        "Cannot combine $ARG_API_VERSION_SIGNATURE_PATTERN with $ARG_ANDROID_JAR_PATTERN"
+                    )
+                } else {
+                    fun createVersionedSignatureApi(
+                        updater: ApiHistoryUpdater,
+                        files: List<MatchedPatternFile>,
+                    ) = VersionedSignatureApi(signatureFileLoader, files.map { it.file }, updater)
+
+                    Triple(
+                        signaturePatterns,
+                        findHistoricalFiles(currentDir, signaturePatterns),
+                        ::createVersionedSignatureApi,
+                    )
+                }
 
-    private val sdkExtensionsArguments
-        get() =
-            if (sdkJarRoot != null && sdkInfoFile != null) {
-                ApiGenerator.SdkExtensionsArguments(
-                    sdkJarRoot!!,
-                    sdkInfoFile!!,
-                )
-            } else {
-                null
+            // Split the files into extension api files and primary api files.
+            val (extensionApiFiles, primaryApiFiles) = matchedFiles.partition { it.extension }
+
+            // Get a VersionedApi for each of the released API files.
+            val versionedHistoricalApis =
+                constructVersionedApisForHistoricalFiles(primaryApiFiles, versionedApiFactory)
+
+            val currentSdkVersion = currentApiVersion
+            if (currentSdkVersion.major <= 26) {
+                cliError("Suspicious $ARG_CURRENT_VERSION $currentSdkVersion, expected at least 27")
             }
 
-    val generateXmlConfig
-        get() =
-            generateApiLevelXml?.let { outputFile ->
-                GenerateXmlConfig(
-                    apiLevels = apiLevelJars,
-                    firstApiLevel = firstApiLevel,
-                    currentSdkVersion = ApiVersion.fromLevel(currentApiLevel),
-                    isDeveloperPreviewBuild = isDeveloperPreviewBuild,
-                    outputFile = outputFile,
-                    sdkExtensionsArguments = sdkExtensionsArguments,
-                    removeMissingClasses = removeMissingClassReferencesInApiLevels,
-                )
+            val nextSdkVersion = currentSdkVersion + 1
+            val lastFinalizedVersion = versionedHistoricalApis.lastOrNull()?.apiVersion
+
+            // Compute the version to use for the current codebase, or null if the current codebase
+            // should not be added to the API history. If a non-null version is selected it will
+            // always be after the last historical version.
+            val codebaseSdkVersion =
+                when {
+                    // The current codebase is a developer preview so use the next, in the
+                    // process of being finalized version.
+                    isDeveloperPreviewBuild -> nextSdkVersion
+
+                    // If no finalized versions were provided or the last finalized version is less
+                    // than the current version then use the current version as the version of the
+                    // codebase.
+                    lastFinalizedVersion == null || lastFinalizedVersion < currentSdkVersion ->
+                        currentSdkVersion
+
+                    // Else do not include the current codebase.
+                    else -> null
+                }
+
+            // Get the optional SDK extension arguments.
+            val sdkExtensionsArguments =
+                if (sdkInfoFile != null) {
+                    // The not finalized SDK version is the version after the last historical
+                    // version. That is either the version used for the current codebase or the
+                    // next version.
+                    val notFinalizedSdkVersion = codebaseSdkVersion ?: nextSdkVersion
+                    ApiGenerator.SdkExtensionsArguments(
+                        sdkInfoFile!!,
+                        notFinalizedSdkVersion,
+                    )
+                } else {
+                    null
+                }
+
+            // Create a list of VersionedApis that need to be incorporated into the Api history.
+            val versionedApis = buildList {
+                addAll(versionedHistoricalApis)
+
+                // Add a VersionedSourceApi for the current codebase if required.
+                if (codebaseSdkVersion != null) {
+                    add(
+                        VersionedSourceApi(
+                            codebaseFragmentProvider,
+                            codebaseSdkVersion,
+                        )
+                    )
+                }
+
+                // Add any VersionedApis for SDK extensions. These must be added after all
+                // VersionedApis for SDK versions as their behavior depends on whether an API was
+                // defined in an SDK version.
+                if (sdkExtensionsArguments != null) {
+                    require(extensionApiFiles.isNotEmpty()) {
+                        "no extension api files found by ${patterns.joinToString()}"
+                    }
+                    addVersionedExtensionApis(
+                        this,
+                        sdkExtensionsArguments.notFinalizedSdkVersion,
+                        extensionApiFiles,
+                        sdkExtensionsArguments.sdkExtensionInfo,
+                        versionedApiFactory,
+                    )
+                }
             }
 
+            GenerateApiHistoryConfig(
+                versionedApis = versionedApis,
+                outputFile = outputFile,
+                sdkExtensionsArguments = sdkExtensionsArguments,
+                missingClassAction =
+                    if (removeMissingClassReferencesInApiLevels) MissingClassAction.REMOVE
+                    else MissingClassAction.REPORT,
+                // Use internal names.
+                useInternalNames = true,
+            )
+        }
+
+    /**
+     * Add [VersionedApi] instances to [list] for each of the [extensionApiFiles].
+     *
+     * Some APIs only exist in extension SDKs and not in the Android SDK, but for backwards
+     * compatibility with tools that expect the Android SDK to be the only SDK, metalava needs to
+     * assign such APIs some Android SDK API version. This uses [versionNotInAndroidSdk].
+     *
+     * @param versionNotInAndroidSdk fallback API level for APIs not in the Android SDK
+     * @param extensionApiFiles extension api files.
+     * @param sdkExtensionInfo the [SdkExtensionInfo] read from sdk-extension-info.xml file.
+     * @param versionedApiFactory factory for creating [VersionedApi]s.
+     */
+    private fun addVersionedExtensionApis(
+        list: MutableList<VersionedApi>,
+        versionNotInAndroidSdk: ApiVersion,
+        extensionApiFiles: List<MatchedPatternFile>,
+        sdkExtensionInfo: SdkExtensionInfo,
+        versionedApiFactory: VersionedApiFactory,
+    ) {
+        val byModule = extensionApiFiles.groupBy({ it.module!! })
+        // Iterate over the mainline modules and their different versions.
+        for ((mainlineModule, moduleFiles) in byModule) {
+            // Get the extensions information for the mainline module. If no information exists for
+            // a particular module then the module is ignored.
+            val moduleMap = sdkExtensionInfo.extensionsMapForJarOrEmpty(mainlineModule)
+            if (moduleMap.isEmpty())
+                continue // TODO(b/259115852): remove this (though it is an optimization too).
+
+            val byVersion = moduleFiles.groupBy { it.version }
+            byVersion.mapTo(list) { (version, files) ->
+                val extVersion = ExtVersion.fromLevel(version.major)
+                val updater =
+                    ApiHistoryUpdater.forExtVersion(
+                        versionNotInAndroidSdk,
+                        extVersion,
+                        mainlineModule,
+                    )
+                versionedApiFactory(updater, files)
+            }
+        }
+    }
+
     /** API version history file to generate */
     private val generateApiVersionHistory by
         option(
@@ -431,89 +585,87 @@ class ApiLevelsGenerationOptions(
             )
             .existingFile()
             .split(File.pathSeparator)
+            .default(emptyList(), defaultForHelp = "")
 
     /**
-     * The names of the API versions in [apiVersionSignatureFiles], in the same order, and the name
-     * of the current API version
-     */
-    private val apiVersionNames by
-        option(
-                ARG_API_VERSION_NAMES,
-                metavar = "<api-versions>",
-                help =
-                    """
-                        An ordered list of strings with the names to use for the API versions from
-                        $ARG_API_VERSION_SIGNATURE_FILES, and the name of the current API version.
-                        Required for $ARG_GENERATE_API_VERSION_HISTORY.
-                    """
-                        .trimIndent()
-            )
-            .split(" ")
-
-    /**
-     * Construct the [GenerateApiVersionsFromVersionedApisConfig] from the options.
+     * Construct the [GenerateApiHistoryConfig] from the options.
      *
      * If no relevant command line options were provided then this will return `null`, otherwise it
      * will validate the options and if all is well construct and return a
-     * [GenerateApiVersionsFromVersionedApisConfig] object.
+     * [GenerateApiHistoryConfig] object.
      *
      * @param signatureFileLoader used for loading [Codebase]s from signature files.
      * @param codebaseFragmentProvider provides access to the [CodebaseFragment] for the API defined
-     *   in the sources. This will only be called if a [GenerateApiVersionsFromVersionedApisConfig]
-     *   needs to be created.
+     *   in the sources. This will only be called if a [GenerateApiHistoryConfig] needs to be
+     *   created.
      */
     fun fromSignatureFilesConfig(
         signatureFileLoader: SignatureFileLoader,
         codebaseFragmentProvider: () -> CodebaseFragment,
-    ): GenerateApiVersionsFromVersionedApisConfig? {
-        // apiVersionNames will include the current version but apiVersionSignatureFiles will not,
-        // so there should be 1 more name than signature file (or both can be null)
-        val numVersionNames = apiVersionNames?.size ?: 0
-        val numVersionFiles = apiVersionSignatureFiles?.size ?: 0
-        if (numVersionNames != 0 && numVersionNames != numVersionFiles + 1) {
-            throw MetalavaCliException(
-                "$ARG_API_VERSION_NAMES must have one more version than $ARG_API_VERSION_SIGNATURE_FILES to include the current version name"
-            )
-        }
-
+    ): GenerateApiHistoryConfig? {
         val apiVersionsFile = generateApiVersionHistory
-        val apiVersionNames = apiVersionNames
-        return if (apiVersionsFile != null && apiVersionNames != null) {
-            // The signature files can be null if the current version is the only version
-            val pastApiVersions = apiVersionSignatureFiles ?: emptyList()
-
-            val allVersions = apiVersionNames.map { ApiVersion.fromString(it) }
-
-            val sourceVersion = allVersions.last()
+        return if (apiVersionsFile != null) {
+            val (sourceVersion, matchedPatternFiles) =
+                sourceVersionAndMatchedPatternFilesFromSignaturePatterns()
 
-            // Combine the `pastApiVersions` and `apiVersionNames` into a list of
-            // `VersionedSignatureApi`s.
+            // Create VersionedApis for the signature files and the source codebase.
             val versionedApis = buildList {
-                pastApiVersions.mapIndexedTo(this) { index, file ->
-                    VersionedSignatureApi(signatureFileLoader, file, allVersions[index])
+                matchedPatternFiles.mapTo(this) {
+                    val updater = ApiHistoryUpdater.forApiVersion(it.version)
+                    VersionedSignatureApi(signatureFileLoader, listOf(it.file), updater)
                 }
                 // Add a VersionedSourceApi for the source code.
-                val codebaseFragment = codebaseFragmentProvider()
-                add(VersionedSourceApi(codebaseFragment, sourceVersion))
+                add(VersionedSourceApi(codebaseFragmentProvider, sourceVersion))
             }
 
-            val printer =
-                when (val extension = apiVersionsFile.extension) {
-                    "xml" -> ApiXmlPrinter(null, 1, allVersions)
-                    "json" -> ApiJsonPrinter()
-                    else ->
-                        error(
-                            "unexpected extension for $apiVersionsFile, expected 'xml', or 'json' got '$extension'"
-                        )
-                }
-
-            GenerateApiVersionsFromVersionedApisConfig(
+            GenerateApiHistoryConfig(
                 versionedApis = versionedApis,
                 outputFile = apiVersionsFile,
-                printer = printer,
+                // None are available when generating from signature files.
+                sdkExtensionsArguments = null,
+                // Keep any references to missing classes.
+                missingClassAction = MissingClassAction.KEEP,
+                // Do not use internal names.
+                useInternalNames = false,
             )
         } else {
             null
         }
     }
+
+    /**
+     * Get the source [ApiVersion] and list of [MatchedPatternFile]s from [signaturePatterns] as
+     * well as [optionalCurrentApiVersion] and [apiVersionSignatureFiles].
+     */
+    private fun sourceVersionAndMatchedPatternFilesFromSignaturePatterns():
+        Pair<ApiVersion, List<MatchedPatternFile>> {
+
+        val sourceVersion =
+            optionalCurrentApiVersion
+                ?: cliError(
+                    "Must specify $ARG_CURRENT_VERSION with $ARG_API_VERSION_SIGNATURE_PATTERN"
+                )
+
+        val historicalSignatureFiles = apiVersionSignatureFiles
+        if (historicalSignatureFiles.isEmpty()) return sourceVersion to emptyList()
+
+        val patternNode = PatternNode.parsePatterns(signaturePatterns)
+        val matchedFiles =
+            patternNode.scan(
+                PatternNode.ScanConfig(
+                    dir = File(".").canonicalFile,
+                    fileProvider = PatternNode.LimitedFileSystemProvider(historicalSignatureFiles)
+                )
+            )
+
+        if (matchedFiles.size != historicalSignatureFiles.size) {
+            val matched = matchedFiles.map { it.file }.toSet()
+            val unmatched = historicalSignatureFiles.filter { it !in matched }
+            cliError(
+                "$ARG_API_VERSION_SIGNATURE_FILES: The following files were unmatched by a signature pattern:\n${unmatched.joinToString("\n") {"    $it"}}"
+            )
+        }
+
+        return sourceVersion to matchedFiles
+    }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
index 1374ce700..99d879546 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
@@ -16,22 +16,41 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.config.ApiSurfaceConfig
+import com.android.tools.metalava.config.ApiSurfacesConfig
 import com.android.tools.metalava.model.annotation.AnnotationFilter
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.defaultLazy
 import com.github.ajalt.clikt.parameters.options.multiple
 import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.switch
 
+const val ARG_API_SURFACE = "--api-surface"
+const val ARG_SHOW_UNANNOTATED = "--show-unannotated"
 const val ARG_SHOW_ANNOTATION = "--show-annotation"
 const val ARG_SHOW_SINGLE_ANNOTATION = "--show-single-annotation"
 const val ARG_SHOW_FOR_STUB_PURPOSES_ANNOTATION = "--show-for-stub-purposes-annotation"
 
+const val ARG_HIDE_ANNOTATION = "--hide-annotation"
+
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val API_SELECTION_OPTIONS_GROUP = "Api Selection"
 
 /**
  * Options related to selecting which parts of the source files will be part of the generated API.
+ *
+ * @param apiSurfacesConfigProvider Provides the [ApiSurfacesConfig] that was provided in an
+ *   [ARG_CONFIG_FILE], if any. This must only be called after all the options have been parsed.
+ * @param checkSurfaceConsistencyProvider Returns `true` if the configured [ApiSurfaces] should be
+ *   checked for consistency with the [showUnannotated] property.
  */
-class ApiSelectionOptions() :
+class ApiSelectionOptions(
+    private val apiSurfacesConfigProvider: () -> ApiSurfacesConfig? = { null },
+    private val checkSurfaceConsistencyProvider: () -> Boolean = { true },
+) :
     OptionGroup(
         name = API_SELECTION_OPTIONS_GROUP,
         help =
@@ -42,6 +61,27 @@ class ApiSelectionOptions() :
                 .trimIndent()
     ) {
 
+    private val apiSurface by
+        option(
+            ARG_API_SURFACE,
+            metavar = "<surface>",
+            help =
+                """
+                    The API surface currently being generated. Must correspond to an <api-surface>
+                    element in a $ARG_CONFIG_FILE.
+                """,
+        )
+
+    val showUnannotated by
+        option(help = "Include un-annotated public APIs in the signature file as well.")
+            .switch(ARG_SHOW_UNANNOTATED to true)
+            .defaultLazy(defaultForHelp = "true if no --show*-annotation options specified") {
+                // If the caller has not explicitly requested that unannotated classes and members
+                // should be shown in the output then only show them if no show annotations were
+                // provided.
+                allShowAnnotations.isEmpty()
+            }
+
     private val showAnnotationValues by
         option(
                 ARG_SHOW_ANNOTATION,
@@ -83,6 +123,14 @@ class ApiSelectionOptions() :
             )
             .multiple()
 
+    private val hideAnnotationValues by
+        option(
+                ARG_HIDE_ANNOTATION,
+                help = "Treat any elements annotated with the given annotation as hidden.",
+                metavar = "<annotation-filter>",
+            )
+            .multiple()
+
     /**
      * Whether to include APIs with annotations (intended for documentation purposes). This includes
      * [showAnnotations], [showSingleAnnotations] and [showForStubPurposesAnnotations].
@@ -124,4 +172,137 @@ class ApiSelectionOptions() :
         lazy(LazyThreadSafetyMode.NONE) {
             AnnotationFilter.create(showForStubPurposesAnnotationValues)
         }
+
+    /** Annotations that mark items which should be treated as hidden. */
+    internal val hideAnnotations by
+        lazy(LazyThreadSafetyMode.NONE) { AnnotationFilter.create(hideAnnotationValues) }
+
+    val apiSurfaces by
+        lazy(LazyThreadSafetyMode.NONE) {
+            val apiSurfacesConfig = apiSurfacesConfigProvider()
+            val checkSurfaceConsistency = checkSurfaceConsistencyProvider()
+            createApiSurfaces(
+                showUnannotated,
+                apiSurface,
+                apiSurfacesConfig,
+                checkSurfaceConsistency,
+            )
+        }
+
+    companion object {
+        /**
+         * Create [ApiSurfaces] and associated [ApiSurface] objects from these options.
+         *
+         * @param showUnannotated true if unannotated items should be included in the API, false
+         *   otherwise.
+         * @param targetApiSurface the optional name of the target API surface to be created. If
+         *   supplied it MUST reference an [ApiSurfaceConfig] in [apiSurfacesConfig].
+         * @param apiSurfacesConfig the optional [ApiSurfacesConfig].
+         * @param checkSurfaceConsistency if `true` and [targetApiSurface] is not-null then check
+         *   the consistency between the configured surfaces and the [ApiSelectionOptions].
+         */
+        private fun createApiSurfaces(
+            showUnannotated: Boolean,
+            targetApiSurface: String?,
+            apiSurfacesConfig: ApiSurfacesConfig?,
+            checkSurfaceConsistency: Boolean,
+        ): ApiSurfaces {
+            // A base API surface is needed if and only if the main API surface being generated
+            // extends another API surface. That is not currently explicitly specified on the
+            // command line so has to be inferred from the existing arguments. There are four main
+            // supported cases:
+            //
+            // * Public which does not extend another API surface so does not need a base. This
+            //   happens by default unless one or more `--show*annotation` options were specified.
+            //   In that case it behaves as if `--show-unannotated` was specified.
+            //
+            // * Restricted API in AndroidX which is basically public + other and does not need a
+            //   base. This happens when `--show-unannotated` was provided (the public part) as well
+            //   as `--show-annotation RestrictTo(...)` (the other part).
+            //
+            // * System delta on public in Android build. This happens when --show-unannotated was
+            //   not specified (so the public part is not included in signature files at least) but
+            //   `--show-annotation SystemApi` was.
+            //
+            // * Test API delta on system (or similar) in Android build. This happens when
+            //   `--show-unannotated` was not specified (so the public part is not included),
+            //   `--show-for-stub-purposes-only SystemApi` was (so system API is included in the
+            //   stubs but not the signature files) and `--show-annotation TestApi` was.
+            //
+            // There are other combinations of the `--show*` options which are not used, and it is
+            // not clear whether they make any sense so this does not cover them.
+            //
+            // This does not need a base if --show-unannotated was specified, or it defaulted to
+            // behaving as if it was.
+            val needsBase = !showUnannotated
+
+            // If no --api-surface option was provided, then create the ApiSurfaces from the command
+            // line options.
+            if (targetApiSurface == null) {
+                return ApiSurfaces.create(
+                    needsBase = needsBase,
+                )
+            }
+
+            // Otherwise, create it from the configured API surfaces.
+            if (apiSurfacesConfig == null || apiSurfacesConfig.apiSurfaceList.isEmpty()) {
+                throw MetalavaCliException(
+                    "$ARG_API_SURFACE requires at least one <api-surface> to have been configured in a --config-file"
+                )
+            }
+
+            val targetApiSurfaceConfig =
+                apiSurfacesConfig.getByNameOrError(targetApiSurface) {
+                    "$ARG_API_SURFACE (`$it`) does not match an <api-surface> in a --config-file"
+                }
+
+            val extendedSurface = targetApiSurfaceConfig.extends
+            val extendsSurface = extendedSurface != null
+
+            // If show annotations should not be ignored then perform a consistency check to ensure
+            // that the configuration and command line options are compatible.
+            if (checkSurfaceConsistency) {
+                if (extendsSurface != needsBase) {
+                    val reason =
+                        if (extendsSurface)
+                            "extends $extendedSurface which requires that it not show unannotated items but $ARG_SHOW_UNANNOTATED is true"
+                        else
+                            "does not extend another surface which requires that it show unannotated items but $ARG_SHOW_UNANNOTATED is false"
+                    throw MetalavaCliException(
+                        """Configuration of `<api-surface name="$targetApiSurface">` is inconsistent with command line options because `$targetApiSurface` $reason"""
+                    )
+                }
+            }
+
+            // Create the ApiSurfaces from the configured API surfaces.
+            return apiSurfacesFromConfig(
+                apiSurfacesConfig.contributesTo(targetApiSurfaceConfig),
+                targetApiSurface
+            )
+        }
+    }
 }
+
+/**
+ * Create [ApiSurfaces] from a collection of [ApiSurfaceConfig]s.
+ *
+ * The [ApiSurfaceConfig]s must be in order such that every [ApiSurfaceConfig] comes before any
+ * [ApiSurfaceConfig] that extends it. It must also be complete such that the collection must
+ * contain every [ApiSurfaceConfig] that is extended by another in the collection.
+ */
+internal fun apiSurfacesFromConfig(
+    surfaceConfigs: Collection<ApiSurfaceConfig>,
+    targetApiSurface: String?
+) =
+    ApiSurfaces.build {
+        // Add ApiSurface instances in order so that surfaces referenced by another (i.e.
+        // through `extends`) come before the surfaces that reference them. This ensures
+        // that the `extends` can be resolved to an existing `ApiSurface`.
+        for (surfaceConfig in surfaceConfigs) {
+            createSurface(
+                name = surfaceConfig.name,
+                extends = surfaceConfig.extends,
+                isMain = surfaceConfig.name == targetApiSurface,
+            )
+        }
+    }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ConfigFileOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ConfigFileOptions.kt
new file mode 100644
index 000000000..7bf2596c6
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/ConfigFileOptions.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.existingFile
+import com.android.tools.metalava.config.Config
+import com.android.tools.metalava.config.ConfigParser
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.multiple
+import com.github.ajalt.clikt.parameters.options.option
+
+const val ARG_CONFIG_FILE = "--config-file"
+
+/** The name of the group, can be used in help text to refer to the options in this group. */
+const val CONFIG_FILE_OPTIONS_GROUP = "Config Files"
+
+class ConfigFileOptions :
+    OptionGroup(
+        name = CONFIG_FILE_OPTIONS_GROUP,
+        help =
+            """
+                Options that control the configuration files.
+            """
+                .trimIndent(),
+    ) {
+
+    private val configFiles by
+        option(
+                ARG_CONFIG_FILE,
+                help =
+                    """
+                        A configuration file that can be consumed by Metalava. This can be specified
+                        multiple times in which case later config files will override/merge with
+                        earlier ones.
+                    """,
+                metavar = "<file>",
+            )
+            .existingFile()
+            .multiple(required = false)
+
+    /** The [Config] loaded from [configFiles]. */
+    val config by
+        lazy(LazyThreadSafetyMode.NONE) {
+            try {
+                ConfigParser.parse(configFiles)
+            } catch (e: Exception) {
+                throw MetalavaCliException(e.message!!, cause = e)
+            }
+        }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt b/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
deleted file mode 100644
index a9031f11d..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava
-
-import com.android.SdkConstants
-import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
-import com.android.tools.metalava.model.ANDROIDX_NONNULL
-import com.android.tools.metalava.model.ANDROIDX_NULLABLE
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.FilterPredicate
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
-import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
-import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.visitors.ApiPredicate
-import com.android.tools.metalava.model.visitors.ApiType
-import com.android.tools.metalava.model.visitors.ApiVisitor
-import java.io.File
-import java.io.IOException
-import java.io.PrintWriter
-import java.util.zip.ZipFile
-import org.objectweb.asm.ClassReader
-import org.objectweb.asm.Opcodes
-import org.objectweb.asm.Type
-import org.objectweb.asm.tree.ClassNode
-import org.objectweb.asm.tree.FieldNode
-import org.objectweb.asm.tree.MethodNode
-
-/**
- * In an Android source tree, rewrite the signature files in prebuilts/sdk by reading what's
- * actually there in the android.jar files.
- */
-class ConvertJarsToSignatureFiles(
-    private val stderr: PrintWriter,
-    private val stdout: PrintWriter,
-    private val progressTracker: ProgressTracker,
-    private val fileFormat: FileFormat,
-) {
-    fun convertJars(jarCodebaseLoader: JarCodebaseLoader, root: File) {
-        var api = 1
-        while (true) {
-            val apiJar =
-                File(
-                    root,
-                    if (api <= 3) "prebuilts/tools/common/api-versions/android-$api/android.jar"
-                    else "prebuilts/sdk/$api/public/android.jar"
-                )
-            if (!apiJar.isFile) {
-                break
-            }
-            val signatureFile = "prebuilts/sdk/$api/public/api/android.txt"
-            val oldApiFile = File(root, "prebuilts/sdk/$api/public/api/android.txt")
-            val newApiFile =
-                // Place new-style signature files in separate files?
-                File(root, "prebuilts/sdk/$api/public/api/android.txt")
-
-            progressTracker.progress("Writing signature files $signatureFile for $apiJar")
-
-            val annotationManager = DefaultAnnotationManager()
-            val codebaseConfig =
-                Codebase.Config(
-                    annotationManager = annotationManager,
-                )
-            val signatureFileLoader = DefaultSignatureFileLoader(codebaseConfig)
-
-            val jarCodebase = jarCodebaseLoader.loadFromJarFile(apiJar)
-
-            if (api >= 28) {
-                // As of API 28 we'll put nullness annotations into the jar but some of them
-                // may be @RecentlyNullable/@RecentlyNonNull. Translate these back into
-                // normal @Nullable/@NonNull
-                jarCodebase.accept(
-                    object :
-                        ApiVisitor(
-                            apiPredicateConfig = ApiPredicate.Config(),
-                        ) {
-                        override fun visitItem(item: Item) {
-                            unmarkRecent(item)
-                            super.visitItem(item)
-                        }
-
-                        private fun unmarkRecent(new: Item) {
-                            val annotation = NullnessMigration.findNullnessAnnotation(new) ?: return
-                            // Nullness information change: Add migration annotation
-                            val annotationClass =
-                                if (annotation.isNullable()) ANDROIDX_NULLABLE else ANDROIDX_NONNULL
-
-                            val replacementAnnotation =
-                                new.codebase.createAnnotation("@$annotationClass", new)
-                            new.mutateModifiers {
-                                mutateAnnotations {
-                                    remove(annotation)
-                                    replacementAnnotation?.let { add(it) }
-                                }
-                            }
-                        }
-                    }
-                )
-                assert(!SUPPORT_TYPE_USE_ANNOTATIONS) {
-                    "We'll need to rewrite type annotations here too"
-                }
-            }
-
-            // Read deprecated attributes. Seem to be missing from code model;
-            // try to read via ASM instead since it must clearly be there.
-            markDeprecated(jarCodebase, apiJar, apiJar.path)
-
-            // ASM doesn't seem to pick up everything that's actually there according to
-            // javap. So as another fallback, read from the existing signature files:
-            if (oldApiFile.isFile) {
-                try {
-                    val oldCodebase = signatureFileLoader.load(SignatureFile.fromFiles(oldApiFile))
-                    val visitor =
-                        object : ComparisonVisitor() {
-                            override fun compareItems(old: Item, new: Item) {
-                                if (old.originallyDeprecated && old !is PackageItem) {
-                                    new.deprecateIfRequired("previous signature file for $old")
-                                }
-                            }
-                        }
-                    CodebaseComparator().compare(visitor, oldCodebase, jarCodebase, null)
-                } catch (e: Exception) {
-                    throw IllegalStateException("Could not load $oldApiFile: ${e.message}", e)
-                }
-            }
-
-            createReportFile(progressTracker, jarCodebase, newApiFile, "API") { printWriter ->
-                val signatureWriter =
-                    SignatureWriter(
-                        writer = printWriter,
-                        fileFormat = fileFormat,
-                    )
-
-                createFilteringVisitorForSignatures(
-                    delegate = signatureWriter,
-                    fileFormat = fileFormat,
-                    apiType = ApiType.PUBLIC_API,
-                    preFiltered = jarCodebase.preFiltered,
-                    showUnannotated = false,
-                    apiPredicateConfig = ApiPredicate.Config()
-                )
-            }
-
-            // Delete older redundant .xml files
-            val xmlFile = File(newApiFile.parentFile, "android.xml")
-            if (xmlFile.isFile) {
-                xmlFile.delete()
-            }
-
-            api++
-        }
-    }
-
-    private fun markDeprecated(codebase: Codebase, file: File, path: String) {
-        when {
-            file.name.endsWith(SdkConstants.DOT_JAR) ->
-                try {
-                    ZipFile(file).use { jar ->
-                        val enumeration = jar.entries()
-                        while (enumeration.hasMoreElements()) {
-                            val entry = enumeration.nextElement()
-                            if (entry.name.endsWith(SdkConstants.DOT_CLASS)) {
-                                try {
-                                    jar.getInputStream(entry).use { inputStream ->
-                                        val bytes = inputStream.readBytes()
-                                        markDeprecated(codebase, bytes, path + ":" + entry.name)
-                                    }
-                                } catch (e: Exception) {
-                                    stdout.println(
-                                        "Could not read jar file entry ${entry.name} from $file: $e"
-                                    )
-                                }
-                            }
-                        }
-                    }
-                } catch (e: IOException) {
-                    stdout.println("Could not read jar file contents from $file: $e")
-                }
-            file.isDirectory -> {
-                val listFiles = file.listFiles()
-                listFiles?.forEach { markDeprecated(codebase, it, it.path) }
-            }
-            file.path.endsWith(SdkConstants.DOT_CLASS) -> {
-                val bytes = file.readBytes()
-                markDeprecated(codebase, bytes, file.path)
-            }
-            else -> stdout.println("Ignoring entry $file")
-        }
-    }
-
-    private fun markDeprecated(codebase: Codebase, bytes: ByteArray, path: String) {
-        val reader: ClassReader
-        val classNode: ClassNode
-        try {
-            // TODO: We don't actually need to build a DOM.
-            reader = ClassReader(bytes)
-            classNode = ClassNode()
-            reader.accept(classNode, 0)
-        } catch (t: Throwable) {
-            stderr.println("Error processing $path: broken class file?")
-            return
-        }
-
-        if ((classNode.access and Opcodes.ACC_DEPRECATED) != 0) {
-            val item = codebase.findClass(classNode, MATCH_ALL)
-            item.deprecateIfRequired("byte code for ${classNode.name}")
-        }
-
-        val methodList = classNode.methods
-        for (f in methodList) {
-            val methodNode = f as MethodNode
-            if ((methodNode.access and Opcodes.ACC_DEPRECATED) == 0) {
-                continue
-            }
-            val item = codebase.findMethod(classNode, methodNode, MATCH_ALL)
-            item.deprecateIfRequired("byte code for ${methodNode.name}")
-        }
-
-        val fieldList = classNode.fields
-        for (f in fieldList) {
-            val fieldNode = f as FieldNode
-            if ((fieldNode.access and Opcodes.ACC_DEPRECATED) == 0) {
-                continue
-            }
-            val item = codebase.findField(classNode, fieldNode, MATCH_ALL)
-            item.deprecateIfRequired("byte code for ${fieldNode.name}")
-        }
-    }
-
-    /** Mark the [Item] as deprecated if required. */
-    private fun Item?.deprecateIfRequired(source: String) {
-        this ?: return
-        if (!originallyDeprecated) {
-            // Set the deprecated flag in the modifiers which underpins [originallyDeprecated].
-            mutateModifiers { setDeprecated(true) }
-            progressTracker.progress("Turned deprecation on for $this from $source")
-        }
-    }
-
-    companion object {
-        val MATCH_ALL: FilterPredicate = FilterPredicate { true }
-    }
-}
-
-/** Finds the given class by JVM owner */
-private fun Codebase.findClassByOwner(owner: String, apiFilter: FilterPredicate): ClassItem? {
-    val className = owner.replace('/', '.').replace('$', '.')
-    val cls = findClass(className)
-    return if (cls != null && apiFilter.test(cls)) {
-        cls
-    } else {
-        null
-    }
-}
-
-private fun Codebase.findClass(node: ClassNode, apiFilter: FilterPredicate): ClassItem? {
-    return findClassByOwner(node.name, apiFilter)
-}
-
-private fun Codebase.findMethod(
-    classNode: ClassNode,
-    node: MethodNode,
-    apiFilter: FilterPredicate
-): MethodItem? {
-    val cls = findClass(classNode, apiFilter) ?: return null
-    val types = Type.getArgumentTypes(node.desc)
-    val parameters =
-        if (types.isNotEmpty()) {
-            val sb = StringBuilder()
-            for (type in types) {
-                if (sb.isNotEmpty()) {
-                    sb.append(", ")
-                }
-                sb.append(type.className.replace('/', '.').replace('$', '.'))
-            }
-            sb.toString()
-        } else {
-            ""
-        }
-    val methodName = if (node.name == "<init>") cls.simpleName() else node.name
-    val method = cls.findMethod(methodName, parameters)
-    return if (method != null && apiFilter.test(method)) {
-        method
-    } else {
-        null
-    }
-}
-
-private fun Codebase.findField(
-    classNode: ClassNode,
-    node: FieldNode,
-    apiFilter: FilterPredicate
-): FieldItem? {
-    val cls = findClass(classNode, apiFilter) ?: return null
-    val field = cls.findField(node.name + 2)
-    return if (field != null && apiFilter.test(field)) {
-        field
-    } else {
-        null
-    }
-}
diff --git a/metalava/src/main/java/com/android/tools/metalava/Driver.kt b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
index 876cdc4f9..732b55438 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Driver.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
@@ -24,19 +24,22 @@ import com.android.tools.metalava.cli.common.ActionContext
 import com.android.tools.metalava.cli.common.CheckerContext
 import com.android.tools.metalava.cli.common.EarlyOptions
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
-import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.cli.common.MetalavaCommand
 import com.android.tools.metalava.cli.common.VersionCommand
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.commonOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
 import com.android.tools.metalava.cli.help.HelpCommand
+import com.android.tools.metalava.cli.historical.AndroidJarsToSignaturesCommand
 import com.android.tools.metalava.cli.internal.MakeAnnotationsPackagePrivateCommand
 import com.android.tools.metalava.cli.signature.MergeSignaturesCommand
+import com.android.tools.metalava.cli.signature.SignatureCatCommand
 import com.android.tools.metalava.cli.signature.SignatureToDexCommand
 import com.android.tools.metalava.cli.signature.SignatureToJDiffCommand
 import com.android.tools.metalava.cli.signature.UpdateSignatureHeaderCommand
 import com.android.tools.metalava.compatibility.CompatibilityCheck
 import com.android.tools.metalava.doc.DocAnalyzer
+import com.android.tools.metalava.jar.JarCodebaseLoader
 import com.android.tools.metalava.lint.ApiLint
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassResolver
@@ -54,6 +57,8 @@ import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.text.SignatureWriter
+import com.android.tools.metalava.model.text.createFilteringVisitorForSignatures
 import com.android.tools.metalava.model.visitors.ApiFilters
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
@@ -78,12 +83,18 @@ const val PROGRAM_NAME = "metalava"
 
 fun main(args: Array<String>) {
     val executionEnvironment = ExecutionEnvironment()
-    val exitCode = run(executionEnvironment = executionEnvironment, originalArgs = args)
-
-    executionEnvironment.stdout.flush()
-    executionEnvironment.stderr.flush()
-
-    exitProcess(exitCode)
+    var exitCode = 0
+    try {
+        exitCode = run(executionEnvironment = executionEnvironment, originalArgs = args)
+    } catch (e: Throwable) {
+        exitCode = -1
+        e.printStackTrace(executionEnvironment.stderr)
+    } finally {
+        executionEnvironment.stdout.flush()
+        executionEnvironment.stderr.flush()
+
+        exitProcess(exitCode)
+    }
 }
 
 /**
@@ -160,7 +171,6 @@ internal fun processFlags(
             modelOptions = modelOptions,
             allowReadingComments = options.allowReadingComments,
             jdkHome = options.jdkHome,
-            projectDescription = options.projectDescription,
         )
 
     val signatureFileCache = options.signatureFileCache
@@ -187,7 +197,7 @@ internal fun processFlags(
             sources
                 .firstOrNull { !it.path.endsWith(DOT_TXT) }
                 ?.let {
-                    throw MetalavaCliException(
+                    cliError(
                         "Inconsistent input file types: The first file is of $DOT_TXT, but detected different extension in ${it.path}"
                     )
                 }
@@ -221,35 +231,45 @@ internal fun processFlags(
         actionContext.subtractApi(signatureFileCache, codebase, it)
     }
 
-    val generateXmlConfig = options.apiLevelsGenerationOptions.generateXmlConfig
+    val generateXmlConfig =
+        options.apiLevelsGenerationOptions.forAndroidConfig(
+            // Do not use a cache here as each file loaded is only loaded once and the created
+            // Codebase is discarded immediately after use so caching just uses memory for no
+            // performance benefit.
+            options.signatureFileLoader,
+        ) {
+            var codebaseFragment =
+                CodebaseFragment.create(codebase) { delegatedVisitor ->
+                    FilteringApiVisitor(
+                        delegate = delegatedVisitor,
+                        apiFilters = ApiVisitor.defaultFilters(options.apiPredicateConfig),
+                        preFiltered = false,
+                    )
+                }
+
+            // If reverting some changes then create a snapshot that combines the items from the
+            // sources for any un-reverted changes and items from the previously released API for
+            // any reverted changes.
+            if (codebaseFragment.codebase.containsRevertedItem) {
+                codebaseFragment =
+                    codebaseFragment.snapshotIncludingRevertedItems(
+                        // Allow references to any of the ClassItems in the original Codebase. This
+                        // should not be a problem for api-versions.xml files as they only refer to
+                        // them
+                        // by name and do not care about their contents.
+                        referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
+                    )
+            }
+
+            codebaseFragment
+        }
     val apiGenerator = ApiGenerator()
     if (generateXmlConfig != null) {
         progressTracker.progress(
             "Generating API levels XML descriptor file, ${generateXmlConfig.outputFile.name}: "
         )
-        var codebaseFragment =
-            CodebaseFragment.create(codebase) { delegatedVisitor ->
-                FilteringApiVisitor(
-                    delegate = delegatedVisitor,
-                    apiFilters = ApiVisitor.defaultFilters(options.apiPredicateConfig),
-                    preFiltered = false,
-                )
-            }
-
-        // If reverting some changes then create a snapshot that combines the items from the sources
-        // for any un-reverted changes and items from the previously released API for any reverted
-        // changes.
-        if (options.revertAnnotations.isNotEmpty()) {
-            codebaseFragment =
-                codebaseFragment.snapshotIncludingRevertedItems(
-                    // Allow references to any of the ClassItems in the original Codebase. This
-                    // should not be a problem for api-versions.xml files as they only refer to them
-                    // by name and do not care about their contents.
-                    referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
-                )
-        }
 
-        apiGenerator.generateXml(codebaseFragment, generateXmlConfig)
+        apiGenerator.generateApiHistory(generateXmlConfig)
     }
 
     if (options.docStubsDir != null || options.enhanceDocumentation) {
@@ -262,7 +282,7 @@ internal fun processFlags(
                 executionEnvironment,
                 codebase,
                 reporter,
-                options.apiLevelLabelProvider,
+                options.apiVersionLabelProvider,
                 options.includeApiLevelInDocumentation,
                 options.apiPredicateConfig,
             )
@@ -270,7 +290,7 @@ internal fun processFlags(
         val applyApiLevelsXml = options.applyApiLevelsXml
         if (applyApiLevelsXml != null) {
             progressTracker.progress("Applying API levels")
-            docAnalyzer.applyApiLevels(applyApiLevelsXml)
+            docAnalyzer.applyApiVersions(applyApiLevelsXml)
         }
     }
 
@@ -297,10 +317,10 @@ internal fun processFlags(
         )
         ?.let { config ->
             progressTracker.progress(
-                "Generating API version history ${config.printer} file, ${config.outputFile.name}: "
+                "Generating API version history file ${config.outputFile.name}: "
             )
 
-            apiGenerator.generateFromVersionedApis(config)
+            apiGenerator.generateApiHistory(config)
         }
 
     // Generate the documentation stubs *before* we migrate nullness information.
@@ -332,7 +352,7 @@ internal fun processFlags(
         // If reverting some changes then create a snapshot that combines the items from the sources
         // for any un-reverted changes and items from the previously released API for any reverted
         // changes.
-        if (options.revertAnnotations.isNotEmpty()) {
+        if (codebaseFragment.codebase.containsRevertedItem) {
             codebaseFragment =
                 codebaseFragment.snapshotIncludingRevertedItems(
                     // Allow references to any of the ClassItems in the original Codebase. This
@@ -367,7 +387,7 @@ internal fun processFlags(
         // If reverting some changes then create a snapshot that combines the items from the sources
         // for any un-reverted changes and items from the previously released API for any reverted
         // changes.
-        if (options.revertAnnotations.isNotEmpty()) {
+        if (codebaseFragment.codebase.containsRevertedItem) {
             codebaseFragment =
                 codebaseFragment.snapshotIncludingRevertedItems(
                     // Allow references to any of the ClassItems in the original Codebase. This
@@ -464,29 +484,32 @@ private fun ActionContext.subtractApi(
     subtractApiFile: File,
 ) {
     val path = subtractApiFile.path
-    val oldCodebase =
+    val codebaseToSubtract =
         when {
             path.endsWith(DOT_TXT) ->
                 signatureFileCache.load(SignatureFile.fromFiles(subtractApiFile))
             path.endsWith(DOT_JAR) -> loadFromJarFile(subtractApiFile)
             else ->
-                throw MetalavaCliException(
+                cliError(
                     "Unsupported $ARG_SUBTRACT_API format, expected .txt or .jar: ${subtractApiFile.name}"
                 )
         }
 
-    @Suppress("DEPRECATION")
-    CodebaseComparator()
-        .compare(
-            object : ComparisonVisitor() {
-                override fun compareClassItems(old: ClassItem, new: ClassItem) {
-                    new.emit = false
-                }
-            },
-            oldCodebase,
-            codebase,
-            ApiType.ALL.getReferenceFilter(options.apiPredicateConfig)
-        )
+    // Iterate over the top level classes in the codebase and if they are present in the codebase
+    // being subtracted then do not emit the class or any of its nested classes.
+    for (classItem in codebase.getTopLevelClassesFromSource()) {
+        if (codebaseToSubtract.findClass(classItem.qualifiedName()) != null) {
+            stopEmittingClassAndContents(classItem)
+        }
+    }
+}
+
+/** Stop emitting [classItem] and any of its nested classes. */
+private fun stopEmittingClassAndContents(classItem: ClassItem) {
+    classItem.emit = false
+    for (nestedClass in classItem.nestedClasses()) {
+        stopEmittingClassAndContents(nestedClass)
+    }
 }
 
 /** Checks compatibility of the given codebase with the codebase described in the signature file. */
@@ -619,19 +642,14 @@ private fun ActionContext.loadFromSources(
             SourceSet(options.sources, options.sourcePath)
         }
 
-    val commonSourceSet =
-        if (options.commonSourcePath.isNotEmpty())
-            SourceSet.createFromSourcePath(options.reporter, options.commonSourcePath)
-        else SourceSet.empty()
-
     progressTracker.progress("Reading Codebase: ")
     val codebase =
         sourceParser.parseSources(
             sourceSet,
-            commonSourceSet,
             "Codebase loaded from source folders",
             classPath = options.classpath,
             apiPackages = options.apiPackages,
+            projectDescription = options.projectDescription,
         )
 
     progressTracker.progress("Analyzing API: ")
@@ -683,6 +701,7 @@ private fun ActionContext.loadFromSources(
             reporter,
             options.manifest,
             options.apiPredicateConfig,
+            options.apiLintOptions.allowedAcronyms,
         )
         progressTracker.progress(
             "$PROGRAM_NAME ran api-lint in ${localTimer.elapsed(SECONDS)} seconds"
@@ -777,7 +796,7 @@ private fun createStubFiles(
 
     // If reverting some changes then create a snapshot that combines the items from the sources for
     // any un-reverted changes and items from the previously released API for any reverted changes.
-    if (options.revertAnnotations.isNotEmpty()) {
+    if (codebaseFragment.codebase.containsRevertedItem) {
         codebaseFragment =
             codebaseFragment.snapshotIncludingRevertedItems(
                 referenceVisitorFactory = { delegate ->
@@ -851,7 +870,6 @@ fun createReportFile(
     }
 }
 
-@Suppress("DEPRECATION")
 fun createReportFile(
     progressTracker: ProgressTracker,
     codebase: Codebase,
@@ -873,10 +891,11 @@ fun createReportFile(
         }
         val text = stringWriter.toString()
         if (text.isNotEmpty() || !deleteEmptyFiles) {
+            apiFile.parentFile.mkdirs()
             apiFile.writeText(text)
         }
     } catch (e: IOException) {
-        options.reporter.report(Issues.IO_ERROR, apiFile, "Cannot open file for write.")
+        codebase.reporter.report(Issues.IO_ERROR, apiFile, "Cannot open file for write.")
     }
     if (description != null) {
         progressTracker.progress(
@@ -902,6 +921,7 @@ private fun createMetalavaCommand(
         JarToJDiffCommand(),
         MakeAnnotationsPackagePrivateCommand(),
         MergeSignaturesCommand(),
+        SignatureCatCommand(),
         SignatureToDexCommand(),
         SignatureToJDiffCommand(),
         UpdateSignatureHeaderCommand(),
diff --git a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
index 470ce7dff..965811c0a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
@@ -160,6 +160,7 @@ class ExtractAnnotations(
     private fun addItem(item: Item, annotation: AnnotationItem) {
         val pkg =
             when (item) {
+                is ClassItem -> item.containingPackage()
                 is MemberItem -> item.containingClass().containingPackage()
                 is ParameterItem -> item.containingCallable().containingClass().containingPackage()
                 else -> return
@@ -175,6 +176,10 @@ class ExtractAnnotations(
         list.add(Pair(item, annotation))
     }
 
+    override fun visitClass(cls: ClassItem) {
+        checkItem(cls)
+    }
+
     override fun visitField(field: FieldItem) {
         checkItem(field)
     }
@@ -440,10 +445,16 @@ class ExtractAnnotations(
                 continue
             }
 
+            // The value could contain fully qualified references to enum values that are in the
+            // android.annotation package. If so, then replace them with references in the
+            // androidx.annotation package.
+            val normalizedValue =
+                value.replace(ANDROID_ANNOTATION_PREFIX, ANDROIDX_ANNOTATION_PREFIX)
+
             writer.print("      <val name=\"")
             writer.print(name)
             writer.print("\" val=\"")
-            writer.print(escapeXml(value))
+            writer.print(escapeXml(normalizedValue))
             writer.println("\" />")
         }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
index 91e0e0960..3d383c699 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
@@ -156,7 +156,7 @@ class JDiffXmlWriter(
 
     override fun visitField(field: FieldItem) {
         val modifiers = field.modifiers
-        val initialValue = field.initialValue(true)
+        val initialValue = field.legacyInitialValue(true)
         val value =
             if (initialValue != null) {
                 XmlUtils.toXmlAttributeValue(CodePrinter.constantToSource(initialValue))
@@ -292,26 +292,26 @@ class JDiffXmlWriter(
             }
         }
     }
-
-    /**
-     * Create an [ApiVisitor] that will filter the [Item] to which is applied according to the
-     * supplied parameters and in a manner appropriate for writing signatures, e.g. not nesting
-     * classes. It will delegate any visitor calls that pass through its filter to this
-     * [JDiffXmlWriter] instance.
-     */
-    fun createFilteringVisitor(
-        apiFilters: ApiFilters,
-        preFiltered: Boolean,
-        showUnannotated: Boolean,
-        filterSuperClassType: Boolean = true,
-    ): ApiVisitor =
-        FilteringApiVisitor(
-            this,
-            inlineInheritedFields = true,
-            interfaceListComparator = TypeItem.totalComparator,
-            apiFilters = apiFilters,
-            preFiltered = preFiltered,
-            filterSuperClassType = filterSuperClassType,
-            showUnannotated = showUnannotated,
-        )
 }
+
+/**
+ * Create an [ApiVisitor] that will filter the [Item] to which is applied according to the supplied
+ * parameters and in a manner appropriate for writing JDiff files, e.g. not nesting classes. It will
+ * delegate any visitor calls that pass through its filter to [delegate].
+ */
+fun createFilteringVisitorForJDiffWriter(
+    delegate: DelegatedVisitor,
+    apiFilters: ApiFilters,
+    preFiltered: Boolean,
+    showUnannotated: Boolean,
+    filterSuperClassType: Boolean = true,
+): ApiVisitor =
+    FilteringApiVisitor(
+        delegate,
+        inlineInheritedFields = true,
+        interfaceListComparator = TypeItem.totalComparator,
+        apiFilters = apiFilters,
+        preFiltered = preFiltered,
+        filterSuperClassType = filterSuperClassType,
+        showUnannotated = showUnannotated,
+    )
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
index 69468a620..3e878f1e6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
@@ -22,6 +22,8 @@ import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
 import com.android.tools.metalava.cli.common.stderr
+import com.android.tools.metalava.jar.StandaloneJarCodebaseLoader
+import com.android.tools.metalava.model.CodebaseFragment
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.reporter.BasicReporter
@@ -69,7 +71,7 @@ class JarToJDiffCommand :
         OptionsDelegate.disallowAccess()
 
         StandaloneJarCodebaseLoader.create(
-                executionEnvironment,
+                executionEnvironment.disableStderrDumping(),
                 progressTracker,
                 BasicReporter(stderr)
             )
@@ -80,15 +82,21 @@ class JarToJDiffCommand :
                 val apiPredicateConfig = ApiPredicate.Config()
                 val apiFilters = apiType.getApiFilters(apiPredicateConfig)
 
-                createReportFile(progressTracker, codebase, xmlFile, "JDiff File") { printWriter ->
-                    JDiffXmlWriter(
-                            writer = printWriter,
-                        )
-                        .createFilteringVisitor(
+                val codebaseFragment =
+                    CodebaseFragment.create(codebase) { delegate ->
+                        createFilteringVisitorForJDiffWriter(
+                            delegate,
                             apiFilters = apiFilters,
                             preFiltered = false,
                             showUnannotated = false,
                         )
+                    }
+
+                createReportFile(progressTracker, codebaseFragment, xmlFile, "JDiff File") {
+                    printWriter ->
+                    JDiffXmlWriter(
+                        writer = printWriter,
+                    )
                 }
             }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
index 20fac6c74..5898ace42 100644
--- a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
@@ -19,8 +19,10 @@ package com.android.tools.metalava
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.JVM_STATIC
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.psi.PsiEnvironmentManager
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
@@ -37,9 +39,6 @@ class KotlinInteropChecks(val reporter: Reporter) {
         PsiEnvironmentManager.javaLanguageLevelFromString(options.javaLanguageLevelAsString)
 
     fun checkField(field: FieldItem, isKotlin: Boolean = field.isKotlin()) {
-        if (isKotlin) {
-            field.ensureCompanionFieldJvmField()
-        }
         ensureFieldNameNotKeyword(field)
     }
 
@@ -61,6 +60,10 @@ class KotlinInteropChecks(val reporter: Reporter) {
         }
     }
 
+    fun checkProperty(property: PropertyItem) {
+        ensureCompanionJvmField(property)
+    }
+
     private fun ensureExceptionsDocumented(method: MethodItem) {
         if (!method.isKotlin()) {
             return
@@ -132,54 +135,69 @@ class KotlinInteropChecks(val reporter: Reporter) {
     private fun ensureCompanionJvmStatic(method: MethodItem) {
         if (
             method.containingClass().simpleName() == "Companion" &&
-                method.isKotlin() &&
-                method.modifiers.isPublic()
+                // Many properties will be checked through [ensureCompanionJvmField]. If this method
+                // is not a property or its property can't use @JvmField, it should use @JvmStatic.
+                method.property?.canHaveJvmField() != true &&
+                method.modifiers.findAnnotation(JVM_STATIC) == null &&
+                method.property?.modifiers?.findAnnotation(JVM_STATIC) == null
         ) {
-            if (method.isKotlinProperty()) {
-                /* Not yet working; can't find the @JvmStatic/@JvmField in the AST
-                // Only flag the read method, not the write method
-                if (method.name().startsWith("get")) {
-                    // Find the backing field; *that's* where the @JvmStatic/@JvmField annotations
-                    // are available (but the field itself is not visited since it is typically private
-                    // and therefore not part of the API visitor. Dip into Kotlin PSI to accurately
-                    // find the field name instead of guessing based on getter name.
-                    var field: FieldItem? = null
-                    val psi = method.psi()
-                    if (psi is KotlinUMethod) {
-                        val property = psi.sourcePsi as? KtProperty
-                        if (property != null) {
-                            val propertyName = property.name
-                            if (propertyName != null) {
-                                field = method.containingClass().containingClass()?.findField(propertyName)
-                            }
-                        }
-                    }
+            reporter.report(
+                Issues.MISSING_JVMSTATIC,
+                method,
+                "Companion object methods like ${method.name()} should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions"
+            )
+        }
+    }
 
-                    if (field != null) {
-                        if (field.modifiers.findAnnotation("kotlin.jvm.JvmStatic") != null) {
-                            reporter.report(
-                                Errors.MISSING_JVMSTATIC, method,
-                                "Companion object constants should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        } else if (field.modifiers.findAnnotation("kotlin.jvm.JvmField") == null) {
-                            reporter.report(
-                                Errors.MISSING_JVMSTATIC, method,
-                                "Companion object constants should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        }
-                    }
-                }
-                */
-            } else if (method.modifiers.findAnnotation("kotlin.jvm.JvmStatic") == null) {
+    /**
+     * Warn if companion constants are not marked with @JvmField.
+     *
+     * Properties that we can expect to be constant (that is, declared via `val`, so they don't have
+     * a setter) but that aren't declared 'const' in a companion object should have @JvmField, and
+     * not have @JvmStatic.
+     *
+     * See https://developer.android.com/kotlin/interop#companion_constants
+     */
+    private fun ensureCompanionJvmField(property: PropertyItem) {
+        if (property.containingClass().modifiers.isCompanion() && property.canHaveJvmField()) {
+            if (property.modifiers.findAnnotation(JVM_STATIC) != null) {
                 reporter.report(
                     Issues.MISSING_JVMSTATIC,
-                    method,
-                    "Companion object methods like ${method.name()} should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions"
+                    property,
+                    "Companion object constants like ${property.name()} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
+                )
+            } else if (property.modifiers.findAnnotation("kotlin.jvm.JvmField") == null) {
+                reporter.report(
+                    Issues.MISSING_JVMSTATIC,
+                    property,
+                    "Companion object constants like ${property.name()} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
                 )
             }
         }
     }
 
+    /**
+     * Whether the property (assumed to be a companion property) is allowed to be have @JvmField.
+     *
+     * If it can't be annotated with @JvmField, it should use @JvmStatic for its accessors instead.
+     */
+    private fun PropertyItem.canHaveJvmField(): Boolean {
+        val companionContainer = containingClass().containingClass()
+        return !modifiers.isConst() &&
+            setter == null &&
+            // @JvmField can only be used on interface companion properties in limited situations --
+            // all the companion properties must be public and constant, so adding more properties
+            // might mean @JvmField would no longer be allowed even if it was originally. Because of
+            // this, don't suggest using @JvmField for interface companion properties.
+            // https://github.com/Kotlin/KEEP/blob/master/proposals/jvm-field-annotation-in-interface-companion.md
+            containingClass().containingClass()?.isInterface() != true &&
+            // @JvmField can only be used when the property has a backing field. The backing
+            // field is present on the containing class of the companion.
+            companionContainer?.findField(name()) != null &&
+            // The compiler does not allow @JvmField on value class type properties.
+            !type().isValueClassType()
+    }
+
     private fun ensureFieldNameNotKeyword(field: FieldItem) {
         checkKotlinKeyword(field.name(), "field", field)
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
index ecbc728d6..f72455bcd 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
@@ -88,8 +88,7 @@ class MainCommand(
     private val sourceOptions by SourceOptions()
 
     /** Issue reporter configuration. */
-    private val issueReportingOptions by
-        IssueReportingOptions(executionEnvironment.reporterEnvironment, commonOptions)
+    private val issueReportingOptions by IssueReportingOptions(commonOptions)
 
     private val commonBaselineOptions by
         CommonBaselineOptions(
@@ -105,7 +104,34 @@ class MainCommand(
             defaultBaselineFileProvider = { getDefaultBaselineFile() },
         )
 
-    private val apiSelectionOptions by ApiSelectionOptions()
+    private val configFileOptions by ConfigFileOptions()
+
+    private val apiSelectionOptions: ApiSelectionOptions by
+        ApiSelectionOptions(
+            apiSurfacesConfigProvider = { configFileOptions.config.apiSurfaces },
+            checkSurfaceConsistencyProvider = {
+                val sources = optionGroup.sources
+                // The --show-unannotated and --show*-annotation options affect the ApiSurfaces that
+                // is used. As do the --api-surface and API surfaces defined in a config file. In
+                // the long term the former will be discarded in favor of the latter but during the
+                // transition it is important that they are consistent. Consistency is important
+                // when the --show* options are significant, i.e. affect the output of Metalava.
+                // Unfortunately, they can be significant even if they are not specified, i.e. if
+                // none of them are specified then it behaves as if --show-unannotated was specified
+                // and depending on other options they may be significant or not.
+                //
+                // The --show* options are always significant if sources are provided, and they are
+                // not signature files or jar files. If they are signature files then the --show*
+                // options are not significant because signature files are already pre-filtered. If
+                // they are jar files then they are almost certainly stubs and so the --show*
+                // options are not significant because stub jar files are are also already
+                // pre-filtered.
+                sources.isNotEmpty() &&
+                    sources[0].extension.let { extension ->
+                        extension != "jar" && extension != "txt"
+                    }
+            },
+        )
 
     /** API lint options. */
     private val apiLintOptions by
@@ -135,6 +161,7 @@ class MainCommand(
         ApiLevelsGenerationOptions(
             executionEnvironment = executionEnvironment,
             earlyOptions = commonOptions,
+            apiSurfacesProvider = { apiSelectionOptions.apiSurfaces },
         )
 
     /**
@@ -148,6 +175,7 @@ class MainCommand(
             sourceOptions = sourceOptions,
             issueReportingOptions = issueReportingOptions,
             generalReportingOptions = generalReportingOptions,
+            configFileOptions = configFileOptions,
             apiSelectionOptions = apiSelectionOptions,
             apiLintOptions = apiLintOptions,
             compatibilityCheckOptions = compatibilityCheckOptions,
diff --git a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
index c02d952c7..f0d73716f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.CallableItem
@@ -88,7 +88,7 @@ class NullabilityAnnotationsValidator(
         for (topLevelClassName in topLevelClassNames) {
             val topLevelClass =
                 codebase.findClass(topLevelClassName)
-                    ?: throw MetalavaCliException(
+                    ?: cliError(
                         "Trying to validate nullability annotations for class $topLevelClassName which could not be found in main codebase"
                     )
             // Visit methods to check their return type, and parameters to check them. Don't visit
@@ -136,7 +136,7 @@ class NullabilityAnnotationsValidator(
 
     private fun checkItem(callable: CallableItem, label: String, type: TypeItem?, item: Item) {
         if (type == null) {
-            throw MetalavaCliException("Missing type on $callable item $label")
+            cliError("Missing type on $callable item $label")
         }
         val annotations = item.modifiers.annotations()
         val nullabilityAnnotations = annotations.filter(this::isAnyNullabilityAnnotation)
diff --git a/metalava/src/main/java/com/android/tools/metalava/Options.kt b/metalava/src/main/java/com/android/tools/metalava/Options.kt
index d6c7cdf2b..f2839adcb 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Options.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Options.kt
@@ -23,12 +23,12 @@ import com.android.tools.metalava.cli.common.CommonOptions
 import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.IssueReportingOptions
-import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.cli.common.PreviouslyReleasedApi
 import com.android.tools.metalava.cli.common.SourceOptions
 import com.android.tools.metalava.cli.common.Terminal
 import com.android.tools.metalava.cli.common.TerminalColor
 import com.android.tools.metalava.cli.common.Verbosity
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.enumOption
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.fileForPathInner
@@ -41,9 +41,8 @@ import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
 import com.android.tools.metalava.cli.lint.ApiLintOptions
 import com.android.tools.metalava.cli.signature.SignatureFormatOptions
-import com.android.tools.metalava.config.ConfigParser
-import com.android.tools.metalava.doc.ApiLevelFilter
-import com.android.tools.metalava.doc.ApiLevelLabelProvider
+import com.android.tools.metalava.doc.ApiVersionFilter
+import com.android.tools.metalava.doc.ApiVersionLabelProvider
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.AnnotationManager
@@ -52,12 +51,11 @@ import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.TypedefMode
-import com.android.tools.metalava.model.annotation.AnnotationFilterBuilder
 import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
-import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.DEFAULT_KOTLIN_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.text.ApiClassResolution
+import com.android.tools.metalava.model.text.EmitFileHeader
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.reporter.Baseline
 import com.android.tools.metalava.reporter.DefaultReporter
@@ -159,7 +157,6 @@ const val ARG_VALIDATE_NULLABILITY_FROM_LIST = "--validate-nullability-from-list
 const val ARG_NULLABILITY_WARNINGS_TXT = "--nullability-warnings-txt"
 const val ARG_NULLABILITY_ERRORS_NON_FATAL = "--nullability-errors-non-fatal"
 const val ARG_DOC_STUBS = "--doc-stubs"
-const val ARG_KOTLIN_STUBS = "--kotlin-stubs"
 /** Used by Firebase, see b/116185431#comment15, not used by Android Platform or AndroidX */
 const val ARG_PROGUARD = "--proguard"
 const val ARG_EXTRACT_ANNOTATIONS = "--extract-annotations"
@@ -168,10 +165,7 @@ const val ARG_ENHANCE_DOCUMENTATION = "--enhance-documentation"
 const val ARG_SKIP_READING_COMMENTS = "--ignore-comments"
 const val ARG_MANIFEST = "--manifest"
 const val ARG_MIGRATE_NULLNESS = "--migrate-nullness"
-const val ARG_HIDE_ANNOTATION = "--hide-annotation"
-const val ARG_REVERT_ANNOTATION = "--revert-annotation"
 const val ARG_SUPPRESS_COMPATIBILITY_META_ANNOTATION = "--suppress-compatibility-meta-annotation"
-const val ARG_SHOW_UNANNOTATED = "--show-unannotated"
 const val ARG_APPLY_API_LEVELS = "--apply-api-levels"
 const val ARG_JAVA_SOURCE = "--java-source"
 const val ARG_KOTLIN_SOURCE = "--kotlin-source"
@@ -188,7 +182,6 @@ const val ARG_IGNORE_CLASSES_ON_CLASSPATH = "--ignore-classes-on-classpath"
 const val ARG_USE_K2_UAST = "--Xuse-k2-uast"
 const val ARG_PROJECT = "--project"
 const val ARG_SOURCE_MODEL_PROVIDER = "--source-model-provider"
-const val ARG_CONFIG_FILE = "--config-file"
 
 class Options(
     private val executionEnvironment: ExecutionEnvironment = ExecutionEnvironment(),
@@ -197,7 +190,8 @@ class Options(
     private val issueReportingOptions: IssueReportingOptions =
         IssueReportingOptions(commonOptions = commonOptions),
     private val generalReportingOptions: GeneralReportingOptions = GeneralReportingOptions(),
-    private val apiSelectionOptions: ApiSelectionOptions = ApiSelectionOptions(),
+    internal val configFileOptions: ConfigFileOptions = ConfigFileOptions(),
+    val apiSelectionOptions: ApiSelectionOptions = ApiSelectionOptions(),
     val apiLintOptions: ApiLintOptions = ApiLintOptions(),
     private val compatibilityCheckOptions: CompatibilityCheckOptions = CompatibilityCheckOptions(),
     signatureFileOptions: SignatureFileOptions = SignatureFileOptions(),
@@ -217,10 +211,6 @@ class Options(
     private val mutableSources: MutableList<File> = mutableListOf()
     /** Internal list backing [classpath] */
     private val mutableClassPath: MutableList<File> = mutableListOf()
-    /** Internal builder backing [hideAnnotations] */
-    private val hideAnnotationsBuilder = AnnotationFilterBuilder()
-    /** Internal builder backing [revertAnnotations] */
-    private val revertAnnotationsBuilder = AnnotationFilterBuilder()
     /** Internal list backing [mergeQualifierAnnotations] */
     private val mutableMergeQualifierAnnotations: MutableList<File> = mutableListOf()
     /** Internal list backing [mergeInclusionAnnotations] */
@@ -299,9 +289,6 @@ class Options(
      */
     var allowReadingComments = true
 
-    /** Ths list of source roots in the common module */
-    val commonSourcePath: List<File> by sourceOptions::commonSourcePath
-
     /** The list of source roots */
     val sourcePath: List<File> by sourceOptions::sourcePath
 
@@ -314,20 +301,6 @@ class Options(
     /** Lint project description that describes project's module structure in details */
     var projectDescription: File? = null
 
-    private val configFiles by
-        option(
-                ARG_CONFIG_FILE,
-                help =
-                    """
-                        A configuration file that can be consumed by Metalava. This can be specified
-                        multiple times in which case later config files will override/merge with
-                        earlier ones.
-                    """,
-                metavar = "<file>",
-            )
-            .existingFile()
-            .multiple(required = false)
-
     val apiClassResolution by
         enumOption(
             help =
@@ -347,41 +320,11 @@ class Options(
      * Whether to include unannotated elements if {@link #showAnnotations} is set. Note: This only
      * applies to signature files, not stub files.
      */
-    var showUnannotated = false
+    val showUnannotated
+        get() = apiSelectionOptions.showUnannotated
 
-    val apiSurfaces by
-        lazy(LazyThreadSafetyMode.NONE) {
-            ApiSurfaces.create(
-                // A base API surface is needed if and only if the main API surface being generated
-                // extends another API surface. That is not currently explicitly specified on the
-                // command line so has to be inferred from the existing arguments. There are four
-                // main supported cases:
-                //
-                // * Public which does not extend another API surface so does not need a base. This
-                //   happens by default unless one or more `--show*annotation` options were
-                //   specified. In that case it behaves as if `--show-unannotated` was specified.
-                //
-                // * Restricted API in AndroidX which is basically public + other and does not need
-                //   a base. This happens when `--show-unannotated` was provided (the public part)
-                //   as well as `--show-annotation RestrictTo(...)` (the other part).
-                //
-                // * System delta on public in Android build. This happens when --show-unannotated
-                //   was not specified (so the public part is not included in signature files at
-                //   least) but `--show-annotation SystemApi` was.
-                //
-                // * Test API delta on system (or similar) in Android build. This happens when
-                //   `--show-unannotated` was not specified (so the public part is not included),
-                //   `--show-for-stub-purposes-only SystemApi` was (so system API is included in the
-                //   stubs but not the signature files) and `--show-annotation TestApi` was.
-                //
-                // There are other combinations of the `--show*` options which are not used, and it
-                // is not clear whether they make any sense so this does not cover them.
-                //
-                // This does not need a base if --show-unannotated was specified, or it defaulted to
-                // behaving as if it was.
-                needsBase = !showUnannotated,
-            )
-        }
+    val apiSurfaces
+        get() = apiSelectionOptions.apiSurfaces
 
     /** Packages to include in the API (if null, include all) */
     val apiPackages: PackageFilter? by sourceOptions::apiPackages
@@ -410,12 +353,6 @@ class Options(
     val skipEmitPackages
         get() = executionEnvironment.testEnvironment?.skipEmitPackages ?: emptyList()
 
-    /** Annotations to hide */
-    private val hideAnnotations by lazy(hideAnnotationsBuilder::build)
-
-    /** Annotations to revert */
-    val revertAnnotations by lazy(revertAnnotationsBuilder::build)
-
     private val annotationManager: AnnotationManager by lazy {
         DefaultAnnotationManager(
             DefaultAnnotationManager.Config(
@@ -424,13 +361,13 @@ class Options(
                 showAnnotations = apiSelectionOptions.showAnnotations,
                 showSingleAnnotations = apiSelectionOptions.showSingleAnnotations,
                 showForStubPurposesAnnotations = apiSelectionOptions.showForStubPurposesAnnotations,
-                hideAnnotations = hideAnnotations,
-                revertAnnotations = revertAnnotations,
+                hideAnnotations = apiSelectionOptions.hideAnnotations,
                 suppressCompatibilityMetaAnnotations = suppressCompatibilityMetaAnnotations,
                 excludeAnnotations = excludeAnnotations,
                 typedefMode = typedefMode,
                 apiPredicate = ApiPredicate(config = apiPredicateConfig),
                 previouslyReleasedCodebaseProvider = { previouslyReleasedCodebase },
+                apiFlags = ApiFlagsCreator.createFromConfig(configFileOptions.config.apiFlags),
             )
         )
     }
@@ -516,7 +453,6 @@ class Options(
 
     internal val stubWriterConfig by lazy {
         StubWriterConfig(
-            kotlinStubs = kotlinStubs,
             includeDocumentationInStubs = includeDocumentationInStubs,
         )
     }
@@ -532,9 +468,6 @@ class Options(
      */
     var docStubsDir: File? = null
 
-    /** Whether code compiled from Kotlin should be emitted as .kt stubs instead of .java stubs */
-    private var kotlinStubs = false
-
     /** Proguard Keep list file to write */
     var proguard: File? = null
 
@@ -609,10 +542,11 @@ class Options(
     private var mergeQualifierAnnotations: List<File> = mutableMergeQualifierAnnotations
     private var mergeInclusionAnnotations: List<File> = mutableMergeInclusionAnnotations
 
-    val apiLevelLabelProvider: ApiLevelLabelProvider = apiLevelsGenerationOptions::getApiLevelLabel
+    val apiVersionLabelProvider: ApiVersionLabelProvider =
+        apiLevelsGenerationOptions::getApiVersionLabel
 
-    val includeApiLevelInDocumentation: ApiLevelFilter =
-        apiLevelsGenerationOptions::includeApiLevelInDocumentation
+    val includeApiLevelInDocumentation: ApiVersionFilter =
+        apiLevelsGenerationOptions::includeApiVersionInDocumentation
 
     /** Reads API XML file to apply into documentation */
     var applyApiLevelsXml: File? = null
@@ -712,9 +646,7 @@ class Options(
                 }
                 ARG_SUBTRACT_API -> {
                     if (subtractApi != null) {
-                        throw MetalavaCliException(
-                            stderr = "Only one $ARG_SUBTRACT_API can be supplied"
-                        )
+                        cliError("Only one $ARG_SUBTRACT_API can be supplied")
                     }
                     subtractApi = stringToExistingFile(getValue(args, ++index))
                 }
@@ -741,11 +673,7 @@ class Options(
                     nullabilityWarningsTxt = stringToNewFile(getValue(args, ++index))
                 ARG_NULLABILITY_ERRORS_NON_FATAL -> nullabilityErrorsFatal = false
                 ARG_SDK_VALUES -> sdkValueDir = stringToNewDir(getValue(args, ++index))
-                ARG_SHOW_UNANNOTATED -> showUnannotated = true
-                ARG_HIDE_ANNOTATION -> hideAnnotationsBuilder.add(getValue(args, ++index))
-                ARG_REVERT_ANNOTATION -> revertAnnotationsBuilder.add(getValue(args, ++index))
                 ARG_DOC_STUBS -> docStubsDir = stringToNewDir(getValue(args, ++index))
-                ARG_KOTLIN_STUBS -> kotlinStubs = true
                 ARG_EXCLUDE_DOCUMENTATION_FROM_STUBS -> includeDocumentationInStubs = false
                 ARG_ENHANCE_DOCUMENTATION -> enhanceDocumentation = true
                 ARG_SKIP_READING_COMMENTS -> allowReadingComments = false
@@ -824,13 +752,6 @@ class Options(
             ++index
         }
 
-        // If the caller has not explicitly requested that unannotated classes and
-        // members should be shown in the output then only show them if no annotations were
-        // provided.
-        if (!showUnannotated && allShowAnnotations.isEmpty()) {
-            showUnannotated = true
-        }
-
         // Initialize the reporters.
         val baseline = generalReportingOptions.baseline
         val reporterUnknown =
@@ -876,7 +797,6 @@ class Options(
         // Reporters are non-null.
         allReporters =
             listOf(
-                issueReportingOptions.bootstrapReporter,
                 reporterUnknown,
                 reporterApiLint,
                 reporterCompatibilityReleased,
@@ -885,7 +805,7 @@ class Options(
         updateClassPath()
 
         // Make sure that any config files are processed.
-        ConfigParser.parse(reporter, configFiles)
+        configFileOptions.config
     }
 
     /**
@@ -920,16 +840,12 @@ class Options(
             if (jar.isFile) {
                 mutableClassPath.add(jar)
             } else {
-                throw MetalavaCliException(
-                    stderr =
-                        "Could not find android.jar for API level " +
-                            "$compileSdkVersion in SDK $sdkHome: $jar does not exist"
+                cliError(
+                    "Could not find android.jar for API level $compileSdkVersion in SDK $sdkHome: $jar does not exist"
                 )
             }
             if (jdkHome != null) {
-                throw MetalavaCliException(
-                    stderr = "Do not specify both $ARG_SDK_HOME and $ARG_JDK_HOME"
-                )
+                cliError("Do not specify both $ARG_SDK_HOME and $ARG_JDK_HOME")
             }
         } else if (jdkHome != null) {
             val isJre = !isJdkFolder(jdkHome)
@@ -940,7 +856,7 @@ class Options(
 
     private fun getValue(args: Array<String>, index: Int): String {
         if (index >= args.size) {
-            throw MetalavaCliException("Missing argument for ${args[index - 1]}")
+            cliError("Missing argument for ${args[index - 1]}")
         }
         return args[index]
     }
@@ -950,7 +866,7 @@ class Options(
         for (path in value.split(File.pathSeparatorChar)) {
             val file = fileForPathInner(path)
             if (!file.isDirectory && !(file.path.endsWith(SdkConstants.DOT_JAR) && file.isFile)) {
-                throw MetalavaCliException("$file is not a jar or directory")
+                cliError("$file is not a jar or directory")
             }
             files.add(file)
         }
@@ -962,7 +878,7 @@ class Options(
         for (path in value.split(File.pathSeparatorChar)) {
             val file = fileForPathInner(path)
             if (!file.exists()) {
-                throw MetalavaCliException("$file does not exist")
+                cliError("$file does not exist")
             }
             files.add(file)
         }
@@ -973,7 +889,7 @@ class Options(
     private fun stringToExistingFileOrDir(value: String): File {
         val file = fileForPathInner(value)
         if (!file.exists()) {
-            throw MetalavaCliException("$file is not a file or directory")
+            cliError("$file is not a file or directory")
         }
         return file
     }
@@ -984,7 +900,7 @@ class Options(
             .map { fileForPathInner(it) }
             .map { file ->
                 if (!file.isFile) {
-                    throw MetalavaCliException("$file is not a file")
+                    cliError("$file is not a file")
                 }
                 file
             }
@@ -995,7 +911,7 @@ class Options(
         if (!dir.isDirectory) {
             val ok = dir.mkdirs()
             if (!ok) {
-                throw MetalavaCliException("Could not create $dir")
+                cliError("Could not create $dir")
             }
         }
         return dir
@@ -1048,10 +964,6 @@ object OptionsHelp {
                 "Specifies that errors encountered during validation of " +
                     "nullability annotations should not be treated as errors. They will be written out to the " +
                     "file specified in $ARG_NULLABILITY_WARNINGS_TXT instead.",
-                "$ARG_HIDE_ANNOTATION <annotation class>",
-                "Treat any elements annotated with the given annotation " + "as hidden",
-                ARG_SHOW_UNANNOTATED,
-                "Include un-annotated public APIs in the signature file as well",
                 "$ARG_JAVA_SOURCE <level>",
                 "Sets the source level for Java source files; default is $DEFAULT_JAVA_LANGUAGE_LEVEL.",
                 "$ARG_KOTLIN_SOURCE <level>",
@@ -1087,9 +999,6 @@ object OptionsHelp {
                     "indicate that an element is recently marked as non null, whereas in the documentation stubs we'll " +
                     "just list this as @NonNull. Another difference is that @doconly elements are included in " +
                     "documentation stubs, but not regular stubs, etc.",
-                ARG_KOTLIN_STUBS,
-                "[CURRENTLY EXPERIMENTAL] If specified, stubs generated from Kotlin source code will " +
-                    "be written in Kotlin rather than the Java programming language.",
                 "$ARG_PASS_THROUGH_ANNOTATION <annotation classes>",
                 "A comma separated list of fully qualified names of " +
                     "annotation classes that must be passed through unchanged.",
diff --git a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
index 005e64bda..06702a632 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
@@ -73,7 +73,7 @@ class SdkFileWriter(val codebase: Codebase, private val outputDir: File) {
             // first check constant fields for the SdkConstant annotation.
             val fields = clazz.fields()
             for (field in fields) {
-                val value = field.initialValue() ?: continue
+                val value = field.legacyInitialValue() ?: continue
                 val annotations = field.modifiers.annotations()
                 for (annotation in annotations) {
                     if (ANDROID_SDK_CONSTANT == annotation.qualifiedName) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
index 993817452..3f8e45b60 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.apilevels
 
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.CodebaseFragment
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.DelegatedVisitor
@@ -32,16 +33,16 @@ import com.android.tools.metalava.model.MethodItem
  */
 fun addApisFromCodebase(
     api: Api,
-    apiVersion: ApiVersion,
+    updater: ApiHistoryUpdater,
     codebaseFragment: CodebaseFragment,
-    useInternalNames: Boolean,
 ) {
-    // Keep track of the versions added to this api.
-    api.update(apiVersion)
+    val useInternalNames = api.useInternalNames
+
+    // Keep track of the versions added to this api, if necessary.
+    updater.update(api)
 
     val delegatedVisitor =
         object : DelegatedVisitor {
-            val updater = ApiElement.Updater.forApiVersion(apiVersion)
 
             var currentClass: ApiClass? = null
 
@@ -53,49 +54,35 @@ fun addApisFromCodebase(
                 val newClass = api.updateClass(cls.nameInApi(), updater, cls.effectivelyDeprecated)
                 currentClass = newClass
 
-                if (cls.isClass()) {
-                    val superClass = cls.superClass()
-                    if (superClass != null) {
-                        newClass.updateSuperClass(superClass.nameInApi(), updater)
+                when (cls.classKind) {
+                    ClassKind.CLASS -> {
+                        val superClass = cls.superClass()
+                        if (superClass != null) {
+                            newClass.updateSuperClass(superClass.nameInApi(), updater)
+                        }
                     }
-                } else if (cls.isInterface()) {
-                    val superClass = cls.superClass()
-                    if (superClass != null && !superClass.isJavaLangObject()) {
-                        newClass.updateInterface(superClass.nameInApi(), updater)
+                    ClassKind.INTERFACE -> {
+                        // Implicit super class; match convention from bytecode
+                        newClass.updateSuperClass(objectClass, updater)
                     }
-                } else if (cls.isEnum()) {
-                    // Implicit super class; match convention from bytecode
-                    if (newClass.name != enumClass) {
-                        newClass.updateSuperClass(enumClass, updater)
+                    ClassKind.ENUM -> {
+                        // Implicit super class; match convention from bytecode
+                        if (newClass.name != enumClass) {
+                            newClass.updateSuperClass(enumClass, updater)
+                        }
+
+                        // Mimic doclava enum methods
+                        enumMethodNames(newClass.name).forEach { name ->
+                            newClass.updateMethod(name, updater, false)
+                        }
                     }
-
-                    // Mimic doclava enum methods
-                    enumMethodNames(newClass.name).forEach { name ->
-                        newClass.updateMethod(name, updater, false)
+                    ClassKind.ANNOTATION_TYPE -> {
+                        // Implicit super class; match convention from bytecode
+                        if (newClass.name != annotationClass) {
+                            newClass.updateSuperClass(objectClass, updater)
+                            newClass.updateInterface(annotationClass, updater)
+                        }
                     }
-                } else if (cls.isAnnotationType()) {
-                    // Implicit super class; match convention from bytecode
-                    if (newClass.name != annotationClass) {
-                        newClass.updateSuperClass(objectClass, updater)
-                        newClass.updateInterface(annotationClass, updater)
-                    }
-                }
-
-                // Ensure we don't end up with
-                //    -  <extends name="java/lang/Object"/>
-                //    +  <extends name="java/lang/Object" removed="29"/>
-                // which can happen because the bytecode always explicitly contains extends
-                // java.lang.Object
-                // but in the source code we don't see it, and the lack of presence of this
-                // shouldn't be
-                // taken as a sign that we no longer extend object. But only do this if the class
-                // didn't
-                // previously extend object and now extends something else.
-                if (
-                    (cls.isClass() || cls.isInterface()) &&
-                        newClass.superClasses.singleOrNull()?.name == objectClass
-                ) {
-                    newClass.updateSuperClass(objectClass, updater)
                 }
 
                 for (interfaceType in cls.interfaceTypes()) {
@@ -130,7 +117,7 @@ fun addApisFromCodebase(
                 currentClass?.updateField(field.nameInApi(), updater, field.effectivelyDeprecated)
             }
 
-            /** The name of the field in this [Api], based on [useInternalNames] */
+            /** The name of the field in this [Api], based on [Api.useInternalNames] */
             fun FieldItem.nameInApi(): String {
                 return if (useInternalNames) {
                     internalName()
@@ -139,7 +126,7 @@ fun addApisFromCodebase(
                 }
             }
 
-            /** The name of the method in this [Api], based on [useInternalNames] */
+            /** The name of the method in this [Api], based on [Api.useInternalNames] */
             fun CallableItem.nameInApi(): String {
                 return if (useInternalNames) {
                     internalName() +
@@ -153,7 +140,7 @@ fun addApisFromCodebase(
                 }
             }
 
-            /** The name of the class in this [Api], based on [useInternalNames] */
+            /** The name of the class in this [Api], based on [Api.useInternalNames] */
             fun ClassItem.nameInApi(): String {
                 return if (useInternalNames) {
                     internalName()
@@ -173,7 +160,7 @@ fun addApisFromCodebase(
                 return nameParts.joinToString(separator)
             }
 
-            /** The names of the doclava enum methods, based on [useInternalNames] */
+            /** The names of the doclava enum methods, based on [Api.useInternalNames] */
             fun enumMethodNames(className: String): List<String> {
                 return if (useInternalNames) {
                     listOf("valueOf(Ljava/lang/String;)L$className;", "values()[L$className;")
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
index f492f7860..d83f6460e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
@@ -19,8 +19,12 @@ import java.util.Collections
 import java.util.TreeMap
 import java.util.TreeSet
 
-/** Represents the whole Android API. */
-class Api : ParentApiElement {
+/**
+ * Represents the whole Android API.
+ *
+ * @param useInternalNames `true` if JVM internal names should be used, `false` otherwise.
+ */
+class Api(val useInternalNames: Boolean) : ParentApiElement {
     /**
      * This has to behave as if it exists since before any specific version (so that every class
      * always specifies its `since` attribute.
@@ -54,14 +58,14 @@ class Api : ParentApiElement {
      * Updates the [ApiClass] for the class called [name], creating and adding one if necessary.
      *
      * @param name the name of the class
-     * @param updater the [ApiElement.Updater] that will update the element with information about
+     * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
      * @param deprecated whether the class was deprecated in the API version
      * @return the newly created or a previously existed class
      */
     fun updateClass(
         name: String,
-        updater: ApiElement.Updater,
+        updater: ApiHistoryUpdater,
         deprecated: Boolean,
     ): ApiClass {
         val existing = mClasses[name]
@@ -85,21 +89,25 @@ class Api : ParentApiElement {
     val classes: Collection<ApiClass>
         get() = Collections.unmodifiableCollection(mClasses.values)
 
-    fun backfillHistoricalFixes() {
-        backfillSdkExtensions()
-    }
+    /**
+     * Patch up the `android.os.ext.SdkExtensions` history to improve backward compatibility.
+     *
+     * This does nothing if the class is not defined in this [Api].
+     */
+    fun patchSdkExtensionsHistory() {
+        val sdkExtensions =
+            findClass("android/os/ext/SdkExtensions")
+            // This is either for the module-lib/system-server (null) or for a non-Android API.
+            // Either way it does not need patching.
+            ?: return
 
-    private fun backfillSdkExtensions() {
         val sdk30 = ApiVersion.fromLevel(30)
         val sdk31 = ApiVersion.fromLevel(31)
         val sdk33 = ApiVersion.fromLevel(33)
-        val sdkExtensions = findClass("android/os/ext/SdkExtensions")
-        if (sdkExtensions != null && sdkExtensions.since != sdk30 && sdkExtensions.since != sdk33) {
+        val sdkExtensionsSince = sdkExtensions.since
+        if (sdkExtensionsSince != sdk30 && sdkExtensionsSince != sdk33) {
             throw AssertionError("Received unexpected historical data")
-        } else if (sdkExtensions == null) {
-            // This is the module-lib/system-server dbs (null) and so don't need patching.
-            return
-        } else if (sdkExtensions.since == sdk30) {
+        } else if (sdkExtensionsSince == sdk30) {
             // This is the system API db (30). The class does not need patching but the members do.
             // Drop through.
         } else {
@@ -109,8 +117,8 @@ class Api : ParentApiElement {
             sdkExtensions.update(sdk30, false)
         }
 
-        val sdk30Updater = ApiElement.Updater.forApiVersion(sdk30)
-        val sdk31Updater = ApiElement.Updater.forApiVersion(sdk31)
+        val sdk30Updater = ApiHistoryUpdater.forApiVersion(sdk30)
+        val sdk31Updater = ApiHistoryUpdater.forApiVersion(sdk31)
 
         // Remove the sdks attribute from the extends for public and system.
         sdkExtensions.updateSuperClass("java/lang/Object", sdk30Updater).apply {
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
index fd39c4ecc..d1e28fdac 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
@@ -16,7 +16,6 @@
 package com.android.tools.metalava.apilevels
 
 import com.google.common.collect.Iterables
-import java.util.concurrent.ConcurrentHashMap
 
 /**
  * Represents a class or an interface and its methods/fields. This is used to write the simplified
@@ -29,20 +28,20 @@ class ApiClass(name: String) : ApiElement(name) {
 
     /** If `true`, never seen as public. */
     var alwaysHidden = false // Package private class?
-    private val mFields = ConcurrentHashMap<String, ApiElement>()
-    private val mMethods = ConcurrentHashMap<String, ApiElement>()
+    private val mFields = mutableMapOf<String, ApiElement>()
+    private val mMethods = mutableMapOf<String, ApiElement>()
 
     /**
      * Updates the [ApiElement] for field with [name], creating and adding one if necessary.
      *
      * @param name the name of the field.
-     * @param updater the [ApiElement.Updater] that will update the element with information about
+     * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
      * @param deprecated the deprecated status.
      */
     fun updateField(
         name: String,
-        updater: Updater,
+        updater: ApiHistoryUpdater,
         deprecated: Boolean,
     ): ApiElement {
         return updateElementInMap(mFields, name, updater, deprecated)
@@ -56,13 +55,13 @@ class ApiClass(name: String) : ApiElement(name) {
      *
      * @param signature the signature of the method, which includes the name and parameter/return
      *   types
-     * @param updater the [ApiElement.Updater] that will update the element with information about
+     * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
      * @param deprecated the deprecated status.
      */
     fun updateMethod(
         signature: String,
-        updater: Updater,
+        updater: ApiHistoryUpdater,
         deprecated: Boolean,
     ): ApiElement {
         // Correct historical mistake in android.jar files
@@ -84,10 +83,10 @@ class ApiClass(name: String) : ApiElement(name) {
      * Updates an element for [superClassType], creating and adding one if necessary.
      *
      * @param superClassType the name of the super class type.
-     * @param updater the [ApiElement.Updater] that will update the element with information about
+     * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
      */
-    fun updateSuperClass(superClassType: String, updater: Updater) =
+    fun updateSuperClass(superClassType: String, updater: ApiHistoryUpdater) =
         updateElementInMap(
             mSuperClasses,
             superClassType,
@@ -107,10 +106,10 @@ class ApiClass(name: String) : ApiElement(name) {
      * Updates an element for [interfaceType], creating and adding one if necessary.
      *
      * @param interfaceType the interface type.
-     * @param updater the [ApiElement.Updater] that will update the element with information about
+     * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
      */
-    fun updateInterface(interfaceType: String, updater: Updater) =
+    fun updateInterface(interfaceType: String, updater: ApiHistoryUpdater) =
         updateElementInMap(
             mInterfaces,
             interfaceType,
@@ -125,7 +124,7 @@ class ApiClass(name: String) : ApiElement(name) {
     private fun updateElementInMap(
         elements: MutableMap<String, ApiElement>,
         name: String,
-        updater: Updater,
+        updater: ApiHistoryUpdater,
         deprecated: Boolean,
     ): ApiElement {
         val existing = elements[name]
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
index f122d9dd7..f92157702 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
@@ -135,7 +135,7 @@ open class ApiElement(val name: String) : ParentApiElement, Comparable<ApiElemen
     /**
      * Clears the sdk extension information from this [ApiElement].
      *
-     * This is only intended for use by [Api.backfillSdkExtensions].
+     * This is only intended for use by [Api.patchSdkExtensionsHistory].
      */
     fun clearSdkExtensionInfo() {
         this.sinceExtension = null
@@ -153,63 +153,6 @@ open class ApiElement(val name: String) : ParentApiElement, Comparable<ApiElemen
     override fun compareTo(other: ApiElement): Int {
         return name.compareTo(other.name)
     }
-
-    /**
-     * Encapsulates the process of updating an [ApiElement] to mark it as being included in a
-     * specific API version.
-     */
-    sealed interface Updater {
-        /**
-         * Updates the API element with information for a specific API version.
-         *
-         * @param apiElement the [ApiElement] to update.
-         * @param deprecated whether the API element was deprecated in the API version in question
-         */
-        fun update(
-            apiElement: ApiElement,
-            deprecated: Boolean = apiElement.deprecatedIn != null,
-        )
-
-        /** Updates the [ApiElement] by calling [ApiElement.update]. */
-        private open class ApiVersionUpdater(private val apiVersion: ApiVersion) : Updater {
-            override fun update(apiElement: ApiElement, deprecated: Boolean) {
-                apiElement.update(apiVersion, deprecated)
-            }
-        }
-
-        /**
-         * Extends [ApiVersionUpdater] to also update the [ApiElement.sinceExtension] and
-         * [ApiElement.mainlineModule] properties.
-         */
-        private class ExtensionUpdater(
-            nextSdkVersion: ApiVersion,
-            private val extVersion: ExtVersion,
-            private val module: String
-        ) : ApiVersionUpdater(nextSdkVersion) {
-            override fun update(apiElement: ApiElement, deprecated: Boolean) {
-                super.update(apiElement, deprecated)
-                apiElement.updateExtension(extVersion)
-                if (apiElement is ApiClass) {
-                    apiElement.updateMainlineModule(module)
-                }
-            }
-        }
-
-        companion object {
-            /** Create an [Updater] for [apiVersion]. */
-            fun forApiVersion(apiVersion: ApiVersion): Updater {
-                return ApiVersionUpdater(apiVersion)
-            }
-
-            fun forExtVersion(
-                nextSdkVersion: ApiVersion,
-                extVersion: ExtVersion,
-                module: String
-            ): Updater {
-                return ExtensionUpdater(nextSdkVersion, extVersion, module)
-            }
-        }
-    }
 }
 
 operator fun ApiVersion?.compareTo(other: ApiVersion?): Int =
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
index 02bf4ce01..05fa59392 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
@@ -15,156 +15,78 @@
  */
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.apilevels.ApiToExtensionsMap.Companion.fromXml
-import com.android.tools.metalava.apilevels.ExtensionSdkJarReader.Companion.findExtensionSdkJarFiles
-import com.android.tools.metalava.model.CodebaseFragment
 import java.io.File
 import java.io.IOException
 
-/**
- * Main class for command line command to convert the existing API XML/TXT files into diff-based
- * simple text files.
- */
+/** Generates API version history. */
 class ApiGenerator {
     /**
-     * Generates an XML API version history file based on the API surfaces of the versions provided.
+     * Generates an API version history file based on the API surfaces of the versions provided.
      *
-     * @param codebaseFragment A [CodebaseFragment] representing the current API surface.
      * @param config Configuration provided from command line options.
      */
-    fun generateXml(
-        codebaseFragment: CodebaseFragment,
-        config: GenerateXmlConfig,
-    ): Boolean {
-        val apiLevels = config.apiLevels
-        val lastApiVersion = ApiVersion.fromLevel(apiLevels.size - 1)
-        val firstApiLevel = config.firstApiLevel
-        val currentSdkVersion = config.currentSdkVersion
-        val notFinalizedSdkVersion = currentSdkVersion + 1
-        val versionedApis =
-            (firstApiLevel until apiLevels.size).map { apiLevel ->
-                val jar = apiLevels[apiLevel]
-                val sdkVersion = ApiVersion.fromLevel(apiLevel)
-                VersionedJarApi(jar, sdkVersion)
-            }
-        val api = createApiFromVersionedApis(versionedApis)
-        val isDeveloperPreviewBuild = config.isDeveloperPreviewBuild
-
-        // Compute the version to use for the current codebase.
-        val codebaseSdkVersion =
-            when {
-                // The current codebase is a developer preview so use the next, in the process of
-                // being finalized version.
-                isDeveloperPreviewBuild -> notFinalizedSdkVersion
-
-                // There is no prebuilt, finalized jar matching the current API level so use the
-                // current codebase for the current API version.
-                lastApiVersion < currentSdkVersion -> currentSdkVersion
-
-                // Else do not include the current codebase.
-                else -> null
-            }
+    fun generateApiHistory(config: GenerateApiHistoryConfig) {
+        val versionedApis = config.versionedApis
+        val api = createApiFromVersionedApis(config.useInternalNames, versionedApis)
 
-        // Get a list of all versions, including the codebase version, if necessary.
-        val allVersions = buildList {
-            (firstApiLevel until apiLevels.size).mapTo(this) { ApiVersion.fromLevel(it) }
-            if (codebaseSdkVersion != null) add(codebaseSdkVersion)
+        // If necessary, update the sdks properties.
+        config.sdkExtensionsArguments?.let { sdkExtensionsArguments ->
+            updateSdksAttributes(
+                api,
+                sdkExtensionsArguments.notFinalizedSdkVersion,
+                sdkExtensionsArguments.sdkExtensionInfo,
+            )
         }
 
-        if (codebaseSdkVersion != null) {
-            addApisFromCodebase(api, codebaseSdkVersion, codebaseFragment, true)
-        }
-        var availableSdkExtensions: AvailableSdkExtensions? = null
-        val sdkExtensionsArguments = config.sdkExtensionsArguments
-        if (sdkExtensionsArguments != null) {
-            availableSdkExtensions =
-                processExtensionSdkApis(
-                    api,
-                    notFinalizedSdkVersion,
-                    sdkExtensionsArguments.sdkExtJarRoot,
-                    sdkExtensionsArguments.sdkExtInfoFile,
-                )
-        }
-        api.backfillHistoricalFixes()
+        // If android.os.ext.SdkExtensions exists in the Api then patch up its history.
+        api.patchSdkExtensionsHistory()
+
         api.clean()
-        if (config.removeMissingClasses) {
-            api.removeMissingClasses()
-        } else {
-            api.verifyNoMissingClasses()
-        }
-        val printer = ApiXmlPrinter(availableSdkExtensions, firstApiLevel, allVersions)
-        return createApiLevelsFile(config.outputFile, printer, api)
-    }
 
-    /**
-     * Creates an [Api] from a list of [VersionedApi]s.
-     *
-     * @param versionedApis A list of [VersionedApi]s, one for each version of the API, in order
-     *   from oldest to newest API version.
-     */
-    private fun createApiFromVersionedApis(versionedApis: List<VersionedApi>): Api {
-        val api = Api()
-        for (versionedApi in versionedApis) {
-            versionedApi.updateApi(api)
-        }
-        return api
-    }
+        // Apply the appropriate action for missing classes.
+        config.missingClassAction.apply(api)
 
-    /**
-     * Generates an API version history file based on the API surfaces of the versions provided.
-     *
-     * @param config Configuration provided from command line options.
-     */
-    fun generateFromVersionedApis(
-        config: GenerateApiVersionsFromVersionedApisConfig,
-    ) {
-        val api = createApiFromVersionedApis(config.versionedApis)
-        api.clean()
-        createApiLevelsFile(config.outputFile, config.printer, api)
+        val outputFile = config.outputFile
+        val printer =
+            when (val extension = outputFile.extension) {
+                "xml" -> {
+                    val availableSdkExtensions =
+                        config.sdkExtensionsArguments?.sdkExtensionInfo?.availableSdkExtensions
+                    ApiXmlPrinter(availableSdkExtensions, versionedApis)
+                }
+                "json" -> ApiJsonPrinter()
+                else ->
+                    error(
+                        "unexpected extension for $outputFile, expected 'xml', or 'json' got '$extension'"
+                    )
+            }
+
+        createApiLevelsFile(outputFile, printer, api)
     }
 
     /**
-     * Modify the extension SDK API parts of an API as dictated by a filter.
-     * - remove APIs not listed in the filter
-     * - assign APIs listed in the filter their corresponding extensions
+     * Traverses [api] updating the [ApiElement.sdks] properties to list the appropriate extensions.
      *
      * Some APIs only exist in extension SDKs and not in the Android SDK, but for backwards
      * compatibility with tools that expect the Android SDK to be the only SDK, metalava needs to
-     * assign such APIs some Android SDK API level. The recommended value is current-api-level + 1,
-     * which is what non-finalized APIs use.
+     * assign such APIs some Android SDK API version. This uses [versionNotInAndroidSdk].
      *
      * @param api the api to modify
      * @param versionNotInAndroidSdk fallback API level for APIs not in the Android SDK
-     * @param sdkJarRoot path to directory containing extension SDK jars (usually
-     *   $ANDROID_ROOT/prebuilts/sdk/extensions)
-     * @param filterPath path to the filter file. @see ApiToExtensionsMap
-     * @throws IOException if the filter file can not be read
-     * @throws IllegalArgumentException if an error is detected in the filter file, or if no jar
-     *   files were found
+     * @param sdkExtensionInfo the [SdkExtensionInfo] read from sdk-extension-info.xml file.
      */
-    private fun processExtensionSdkApis(
+    private fun updateSdksAttributes(
         api: Api,
         versionNotInAndroidSdk: ApiVersion,
-        sdkJarRoot: File,
-        filterPath: File,
-    ): AvailableSdkExtensions {
-        val rules = filterPath.readText()
-        val map = findExtensionSdkJarFiles(sdkJarRoot)
-        require(map.isNotEmpty()) { "no extension sdk jar files found in $sdkJarRoot" }
-        val moduleMaps: MutableMap<String, ApiToExtensionsMap> = HashMap()
-        for ((mainlineModule, value) in map) {
-            val moduleMap = fromXml(mainlineModule, rules)
-            if (moduleMap.isEmpty())
-                continue // TODO(b/259115852): remove this (though it is an optimization too).
-            moduleMaps[mainlineModule] = moduleMap
-            for ((level, path) in value) {
-                val extVersion = ExtVersion.fromLevel(level)
-                api.readExtensionJar(extVersion, mainlineModule, path, versionNotInAndroidSdk)
-            }
-        }
+        sdkExtensionInfo: SdkExtensionInfo,
+    ) {
         for (clazz in api.classes) {
             val module = clazz.mainlineModule ?: continue
-            val extensionsMap = moduleMaps[module]!!
+
+            // Get the extensions information for the mainline module. If no information exists for
+            // a particular module then the returned information is empty but can still be used to
+            // calculate sdks attribute.
+            val extensionsMap = sdkExtensionInfo.extensionsMapForJarOrEmpty(module)
 
             /** Update the sdks on each [ApiElement] in [elements]. */
             fun updateSdks(elements: Collection<ApiElement>) {
@@ -194,7 +116,6 @@ class ApiGenerator {
             updateSdks(clazz.fields)
             updateSdks(clazz.methods)
         }
-        return fromXml("", rules).availableSdkExtensions
     }
 
     /**
@@ -208,26 +129,54 @@ class ApiGenerator {
         outFile: File,
         printer: ApiPrinter,
         api: Api,
-    ): Boolean {
+    ) {
         val parentFile = outFile.parentFile
         if (!parentFile.exists()) {
             val ok = parentFile.mkdirs()
             if (!ok) {
-                System.err.println("Could not create directory $parentFile")
-                return false
+                throw IOException("Could not create directory $parentFile")
             }
         }
-        try {
-            outFile.printWriter().use { writer -> printer.print(api, writer) }
-        } catch (e: Exception) {
-            e.printStackTrace()
-            return false
+
+        outFile.printWriter().use { writer ->
+            printer.print(api, writer)
+            if (writer.checkError()) throw IOException("Error writing $outFile")
         }
-        return true
     }
 
     data class SdkExtensionsArguments(
-        var sdkExtJarRoot: File,
-        var sdkExtInfoFile: File,
-    )
+        /**
+         * The `sdk-extension-info.xml` file containing information about the available sdk
+         * extensions and the APIs each module contributes to them.
+         */
+        private val sdkExtInfoFile: File,
+
+        /**
+         * A version that has not yet been finalized. Used when an API was added in an SDK extension
+         * but not yet part of an SDK release.
+         */
+        val notFinalizedSdkVersion: ApiVersion,
+    ) {
+        /** [SdkExtensionInfo] loaded on demand from [sdkExtInfoFile]. */
+        val sdkExtensionInfo by
+            lazy(LazyThreadSafetyMode.NONE) { SdkExtensionInfo.fromXml(sdkExtInfoFile.readText()) }
+    }
+}
+
+/**
+ * Creates an [Api] from a list of [VersionedApi]s.
+ *
+ * @param useInternalNames `true` if JVM internal names should be used, `false` otherwise.
+ * @param versionedApis A list of [VersionedApi]s, one for each version of the API, in order from
+ *   oldest to newest API version.
+ */
+internal fun createApiFromVersionedApis(
+    useInternalNames: Boolean,
+    versionedApis: List<VersionedApi>
+): Api {
+    val api = Api(useInternalNames)
+    for (versionedApi in versionedApis) {
+        versionedApi.updateApi(api)
+    }
+    return api
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt
new file mode 100644
index 000000000..ccf0d68d8
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+/**
+ * Encapsulates the process of updating the API history by marking an [ApiElement] as being included
+ * in a specific [apiVersion].
+ */
+sealed interface ApiHistoryUpdater {
+    /** The [ApiVersion] that this will use to update the [Api]. */
+    val apiVersion: ApiVersion
+
+    /**
+     * Updates the API with information for a specific API version.
+     *
+     * @param api the [Api] to update.
+     */
+    fun update(api: Api)
+
+    /**
+     * Updates the API element with information for a specific API version.
+     *
+     * @param apiElement the [ApiElement] to update.
+     * @param deprecated whether the API element was deprecated in the API version in question
+     */
+    fun update(
+        apiElement: ApiElement,
+        deprecated: Boolean = apiElement.deprecatedIn != null,
+    )
+
+    override fun toString(): String
+
+    /** Updates the [ApiElement] by calling [ApiElement.update]. */
+    private open class ApiVersionUpdater(override val apiVersion: ApiVersion) : ApiHistoryUpdater {
+        override fun update(api: Api) {
+            api.update(apiVersion)
+        }
+
+        override fun update(apiElement: ApiElement, deprecated: Boolean) {
+            apiElement.update(apiVersion, deprecated)
+        }
+
+        override fun toString() = "ApiVersionUpdater(version=$apiVersion)"
+    }
+
+    /**
+     * Extends [ApiVersionUpdater] to also update the [ApiElement.sinceExtension] and
+     * [ApiElement.mainlineModule] properties.
+     */
+    private class ExtensionUpdater(
+        nextSdkVersion: ApiVersion,
+        private val extVersion: ExtVersion,
+        private val module: String
+    ) : ApiVersionUpdater(nextSdkVersion) {
+        override fun update(api: Api) {
+            // Do not update the Api with the next sdk version as that could cause all classes
+            // which are not provided by an extension to be treated as being removed as they
+            // may not have been recorded as being part of the next sdk version.
+        }
+
+        override fun update(apiElement: ApiElement, deprecated: Boolean) {
+            super.update(apiElement, deprecated)
+            apiElement.updateExtension(extVersion)
+            if (apiElement is ApiClass) {
+                apiElement.updateMainlineModule(module)
+            }
+        }
+
+        override fun toString() =
+            "ExtensionUpdater(extVersion=$extVersion, module=$module, nextSdkVersion=$apiVersion)"
+    }
+
+    companion object {
+        /** Create an [ApiHistoryUpdater] for [apiVersion]. */
+        fun forApiVersion(apiVersion: ApiVersion): ApiHistoryUpdater {
+            return ApiVersionUpdater(apiVersion)
+        }
+
+        /**
+         * Create an [ApiHistoryUpdater] for an extension version [extVersion] of [module].
+         *
+         * If an [ApiElement] was not defined in a previously finalized SDK then this assumes it
+         * will be finalized in the[nextSdkVersion].
+         */
+        fun forExtVersion(
+            nextSdkVersion: ApiVersion,
+            extVersion: ExtVersion,
+            module: String
+        ): ApiHistoryUpdater {
+            return ExtensionUpdater(nextSdkVersion, extVersion, module)
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
index 5190cba38..30f969ea4 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
@@ -34,8 +34,8 @@ internal class ApiJsonPrinter : ApiPrinter {
     private fun ApiClass.toJson() =
         toJson("class") +
             mapOf(
-                "methods" to methods.map { it.toJson("method") },
-                "fields" to fields.map { it.toJson("field") }
+                "methods" to methods.sorted().map { it.toJson("method") },
+                "fields" to fields.sorted().map { it.toJson("field") }
             )
 
     private fun ApiElement.toJson(elementType: String) =
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
index c5aad595e..10128b37e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
@@ -15,11 +15,6 @@
  */
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.SdkExtension
-import javax.xml.parsers.SAXParserFactory
-import org.xml.sax.Attributes
-import org.xml.sax.helpers.DefaultHandler
-
 /**
  * A filter of classes, fields and methods that are allowed in and extension SDK, and for each item,
  * what extension SDK it first appeared in. Also, a mapping between SDK name and numerical ID.
@@ -40,9 +35,9 @@ import org.xml.sax.helpers.DefaultHandler
  * ```
  */
 class ApiToExtensionsMap
-private constructor(
-    val availableSdkExtensions: AvailableSdkExtensions,
-    private val root: Node,
+internal constructor(
+    private val availableSdkExtensions: AvailableSdkExtensions,
+    internal val root: Node,
 ) {
     fun isEmpty(): Boolean = root.children.isEmpty() && root.extensions.isEmpty()
 
@@ -58,7 +53,7 @@ private constructor(
             return listOf()
         }
 
-        val parts = what.split(REGEX_DELIMITERS)
+        val parts = what.splitIntoBreadcrumbs()
 
         var lastSeenExtensions = root.extensions
         var node = root.children.findNode(parts[0]) ?: return lastSeenExtensions
@@ -147,158 +142,32 @@ private constructor(
         // Hard-coded ID for the Android platform SDK. Used identically as the extension SDK IDs
         // to express when an API first appeared in an SDK.
         const val ANDROID_PLATFORM_SDK_ID = 0
-
-        private val REGEX_DELIMITERS = Regex("[.#$]")
-
-        /**
-         * Create an ApiToExtensionsMap from a list of text based rules.
-         *
-         * The input is XML:
-         *
-         *     <?xml version="1.0" encoding="utf-8"?>
-         *     <sdk-extensions-info version="1">
-         *         <sdk name="<name>" shortname="<short-name>" id="<int>" reference="<constant>" />
-         *         <symbol jar="<jar>" pattern="<pattern>" sdks="<sdks>" />
-         *     </sdk-extensions-info>
-         *
-         * The <sdk> and <symbol> tags may be repeated.
-         * - <name> is a long name for the SDK, e.g. "R Extensions".
-         * - <short-name> is a short name for the SDK, e.g. "R-ext".
-         * - <id> is the numerical identifier for the SDK, e.g. 30. It is an error to use the
-         *   Android SDK ID (0).
-         * - <jar> is the jar file symbol belongs to, named after the jar file in
-         *   prebuilts/sdk/extensions/<int>/public, e.g. "framework-sdkextensions".
-         * - <constant> is a Java symbol that can be passed to `SdkExtensions.getExtensionVersion`
-         *   to look up the version of the corresponding SDK, e.g.
-         *   "android/os/Build$VERSION_CODES$R"
-         * - <pattern> is either '*', which matches everything, or a 'com.foo.Bar$Inner#member'
-         *   string (or prefix thereof terminated before . or $), which matches anything with that
-         *   prefix. Note that arguments and return values of methods are omitted (and there is no
-         *   way to distinguish overloaded methods).
-         * - <sdks> is a comma separated list of SDKs in which the symbol defined by <jar> and
-         *   <pattern> appears; the list items are <name> attributes of SDKs defined in the XML.
-         *
-         * It is an error to specify the same <jar> and <pattern> pair twice.
-         *
-         * A more specific <symbol> rule has higher precedence than a less specific rule.
-         *
-         * @param filterByJar jar file to limit lookups to: ignore symbols not present in this jar
-         *   file
-         * @param xml XML as described above
-         * @throws IllegalArgumentException if the XML is malformed
-         */
-        fun fromXml(filterByJar: String, xml: String): ApiToExtensionsMap {
-            val root = Node("<root>")
-            val sdkExtensions = mutableSetOf<SdkExtension>()
-            val allSeenExtensions = mutableSetOf<String>()
-
-            val parser = SAXParserFactory.newDefaultInstance().newSAXParser()
-            try {
-                parser.parse(
-                    xml.byteInputStream(),
-                    object : DefaultHandler() {
-                        override fun startElement(
-                            uri: String,
-                            localName: String,
-                            qualifiedName: String,
-                            attributes: Attributes
-                        ) {
-                            when (qualifiedName) {
-                                "sdk" -> {
-                                    val id = attributes.getIntOrThrow(qualifiedName, "id")
-                                    val shortname =
-                                        attributes.getStringOrThrow(qualifiedName, "shortname")
-                                    val name = attributes.getStringOrThrow(qualifiedName, "name")
-                                    val reference =
-                                        attributes.getStringOrThrow(qualifiedName, "reference")
-                                    sdkExtensions.add(
-                                        SdkExtension.fromXmlAttributes(
-                                            id,
-                                            shortname,
-                                            name,
-                                            reference,
-                                        )
-                                    )
-                                }
-                                "symbol" -> {
-                                    val jar = attributes.getStringOrThrow(qualifiedName, "jar")
-                                    if (jar != filterByJar) {
-                                        return
-                                    }
-                                    val sdks =
-                                        attributes
-                                            .getStringOrThrow(qualifiedName, "sdks")
-                                            .split(',')
-                                    if (sdks != sdks.distinct()) {
-                                        throw IllegalArgumentException(
-                                            "symbol lists the same SDK multiple times: '$sdks'"
-                                        )
-                                    }
-                                    allSeenExtensions.addAll(sdks)
-                                    val pattern =
-                                        attributes.getStringOrThrow(qualifiedName, "pattern")
-                                    if (pattern == "*") {
-                                        root.extensions = sdks
-                                        return
-                                    }
-                                    // add each part of the pattern as separate nodes, e.g. if
-                                    // pattern is
-                                    // com.example.Foo, add nodes, "com" -> "example" -> "Foo"
-                                    val parts = pattern.split(REGEX_DELIMITERS)
-                                    var node = root.children.addNode(parts[0])
-                                    for (name in parts.stream().skip(1)) {
-                                        node = node.children.addNode(name)
-                                    }
-                                    if (node.extensions.isNotEmpty()) {
-                                        throw IllegalArgumentException(
-                                            "duplicate pattern: $pattern"
-                                        )
-                                    }
-                                    node.extensions = sdks
-                                }
-                            }
-                        }
-                    }
-                )
-            } catch (e: Throwable) {
-                throw IllegalArgumentException("failed to parse xml", e)
-            }
-
-            val availableSdkExtensions = AvailableSdkExtensions(sdkExtensions)
-
-            // verify: all rules refer to declared SDKs
-            for (ext in allSeenExtensions) {
-                if (!availableSdkExtensions.containsSdkExtension(ext)) {
-                    throw IllegalArgumentException("bad SDK definitions: undefined SDK $ext")
-                }
-            }
-
-            return ApiToExtensionsMap(availableSdkExtensions, root)
-        }
     }
 }
 
-private fun MutableSet<Node>.addNode(name: String): Node {
-    findNode(name)?.let {
-        return it
-    }
-    val node = Node(name)
-    add(node)
-    return node
-}
-
-private fun Attributes.getStringOrThrow(tag: String, attr: String): String =
-    getValue(attr) ?: throw IllegalArgumentException("<$tag>: missing attribute: $attr")
-
-private fun Attributes.getIntOrThrow(tag: String, attr: String): Int =
-    getStringOrThrow(tag, attr).toIntOrNull()
-        ?: throw IllegalArgumentException("<$tag>: attribute $attr: not an integer")
-
-private fun Set<Node>.findNode(breadcrumb: String): Node? = find { it.breadcrumb == breadcrumb }
+internal fun Set<Node>.findNode(breadcrumb: String): Node? = find { it.breadcrumb == breadcrumb }
 
 private fun String.toDotNotation(): String = split('(')[0].replace('/', '.')
 
-private class Node(val breadcrumb: String) {
+internal class Node(val breadcrumb: String) {
     var extensions: List<String> = emptyList()
     val children: MutableSet<Node> = mutableSetOf()
 }
+
+/**
+ * Regular expression used to split an internal symbol name into separate breadcrumbs, i.e. values
+ * that will be used in [Node.breadcrumb].
+ */
+private val REGEX_DELIMITERS = Regex("[.#$]")
+
+/**
+ * Split the string into breadcrumbs, i.e. values that will be used in [Node.breadcrumb].
+ *
+ * e.g. if this is com.example.Foo$Inner#method(I)I then this will split it into:
+ * * "com"
+ * * "example"
+ * * "Foo"
+ * * "Inner"
+ * * "method(I)I"
+ */
+internal fun String.splitIntoBreadcrumbs() = split(REGEX_DELIMITERS)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt
index e079d2029..96bf76b24 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt
@@ -20,10 +20,11 @@ import com.android.tools.metalava.apilevels.ApiVersion.Companion.toString
 import java.util.regex.Pattern
 
 /** Version of an SDK, e.g. Android or AndroidX. */
+@ConsistentCopyVisibility
 data class ApiVersion
 internal constructor(
     /** The major version. */
-    private val major: Int,
+    val major: Int,
 
     /**
      * The optional minor version.
@@ -31,7 +32,7 @@ internal constructor(
      * If it is `null` then neither it nor [patch] or [preReleaseQuality] are included in
      * [toString]. If it is not `null` then it must be greater than or equal to 0.
      */
-    private val minor: Int? = null,
+    internal val minor: Int? = null,
 
     /**
      * The optional patch version.
@@ -167,6 +168,9 @@ internal constructor(
             return ApiVersion(major, minor, patch, quality)
         }
 
+        /** Create an [ApiVersion] with the specified [major] and [minor] properties. */
+        fun fromMajorMinor(major: Int, minor: Int? = null) = ApiVersion(major, minor)
+
         /**
          * The lowest [ApiVersion], used as the default value when higher versions override lower
          * ones.
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt
index 4905dbd5e..9cfdfd81b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt
@@ -17,25 +17,34 @@
 package com.android.tools.metalava.apilevels
 
 import java.io.PrintWriter
+import java.util.TreeSet
 
 /**
  * Printer that will write an XML representation of an [Api] instance.
  *
  * @param availableSdkExtensions the optional set of [AvailableSdkExtensions].
- * @param firstApiLevel the first API level which the file contains, used to populate the `<api
- *   min="..."...>` attribute.
- * @param allVersions the list of all the versions in order, from earliest to latest.
+ * @param versionedApis the list of all the [VersionedApi]s that will provide information for the
+ *   [Api]. Must include at least one [VersionedApi]. The API version of the first is used to
+ *   populate the `<api min="..."...>` attribute, if it is later than version `1`.
  */
 class ApiXmlPrinter(
     private val availableSdkExtensions: AvailableSdkExtensions?,
-    private val firstApiLevel: Int,
-    allVersions: List<ApiVersion>,
+    versionedApis: List<VersionedApi>,
 ) : ApiPrinter {
+    /** The set of versions, sorted from lowest to highest. */
+    private val sortedVersions = versionedApis.mapTo(TreeSet()) { it.apiVersion }
+
+    /** Get the first [ApiVersion]. */
+    private val firstApiVersion = sortedVersions.first()
+
     /**
      * Map from version to the next version. This is used to compute the version in which an API
      * element was removed by finding the version after the version it was last present in.
      */
-    private val versionToNext = allVersions.zipWithNext().toMap()
+    private val versionToNext = sortedVersions.zipWithNext().toMap()
+
+    /** True if the [Api] being printed has any minor versions. */
+    private val hasMinorVersions = sortedVersions.any { it.minor != null }
 
     override fun print(api: Api, writer: PrintWriter) {
         writer.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
@@ -50,9 +59,12 @@ class ApiXmlPrinter(
      * @param writer the writer to which the XML elements will be written.
      */
     private fun Api.print(writer: PrintWriter, availableSdkExtensions: AvailableSdkExtensions?) {
-        writer.print("<api version=\"3\"")
-        if (firstApiLevel > 1) {
-            writer.print(" min=\"$firstApiLevel\"")
+        // Select the lowest version that supports the necessary capabilities.
+        val fileVersion = if (hasMinorVersions) 4 else 3
+
+        writer.print("<api version=\"$fileVersion\"")
+        if (firstApiVersion > DEFAULT_MIN_VERSION) {
+            writer.print(" min=\"$firstApiVersion\"")
         }
         writer.println(">")
         if (availableSdkExtensions != null) {
@@ -172,7 +184,7 @@ class ApiXmlPrinter(
         if (lastPresentIn < parentApiElement.lastPresentIn) {
             val removedFrom =
                 versionToNext[lastPresentIn]
-                    ?: error("could not find next version for $lastPresentIn")
+                    ?: error("could not find next version for $lastPresentIn in $name")
             writer.print("\" removed=\"")
             writer.print(removedFrom)
         }
@@ -184,6 +196,9 @@ class ApiXmlPrinter(
     }
 
     companion object {
+        /** The default minimum [ApiVersion] expected by consumers of `api-versions.xml`. */
+        private val DEFAULT_MIN_VERSION = ApiVersion.fromLevel(1)
+
         /**
          * Prints a closing tag of an XML element terminated by a line break.
          *
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt
deleted file mode 100644
index 88a06c56d..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.tools.metalava.apilevels
-
-import com.android.SdkConstants
-import com.android.SdkConstants.PLATFORM_WINDOWS
-import java.io.File
-
-class ExtensionSdkJarReader {
-
-    companion object {
-        private val REGEX_JAR_PATH = run {
-            var pattern = ".*/(\\d+)/[^/]+/(.*)\\.jar$"
-            if (SdkConstants.currentPlatform() == PLATFORM_WINDOWS) {
-                pattern = pattern.replace("/", "\\\\")
-            }
-            Regex(pattern)
-        }
-
-        /**
-         * Find extension SDK jar files in an extension SDK tree.
-         *
-         * @return a mapping SDK jar file -> list of VersionAndPath objects, sorted from earliest to
-         *   last version
-         */
-        fun findExtensionSdkJarFiles(root: File): Map<String, List<VersionAndPath>> {
-            val map = mutableMapOf<String, MutableList<VersionAndPath>>()
-            root
-                .walk()
-                .maxDepth(3)
-                .mapNotNull { file ->
-                    REGEX_JAR_PATH.matchEntire(file.path)?.groups?.let { groups ->
-                        Triple(groups[2]!!.value, groups[1]!!.value.toInt(), file)
-                    }
-                }
-                .sortedBy { it.second }
-                .forEach {
-                    map.getOrPut(it.first) { mutableListOf() }
-                        .add(VersionAndPath(it.second, it.third))
-                }
-            return map
-        }
-    }
-}
-
-data class VersionAndPath(@JvmField val version: Int, @JvmField val path: File)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiHistoryConfig.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiHistoryConfig.kt
new file mode 100644
index 000000000..db4ccd469
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiHistoryConfig.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.apilevels.ApiGenerator.SdkExtensionsArguments
+import com.android.tools.metalava.model.Codebase
+import java.io.File
+
+/**
+ * Properties for the [ApiGenerator.generateApiHistory] method that come from command line options.
+ */
+data class GenerateApiHistoryConfig(
+    /**
+     * A list of [VersionedApi]s that contribute to the API history.
+     *
+     * i.e.
+     * 1. Historical, i.e. previously released, APIs, in order from the oldest API version to the
+     *    newest.
+     * 2. An optional [VersionedApi] for the current sources [Codebase], whose version is higher
+     *    than the last historical version.
+     * 3. The optional [VersionedApi]s for SDK extensions, grouped by module and in order from the
+     *    oldest. API version to the newest.
+     */
+    val versionedApis: List<VersionedApi>,
+
+    /** The API levels file that will be generated. */
+    val outputFile: File,
+
+    /**
+     * Optional SDK extensions arguments.
+     *
+     * If provided then SDK extension information will be included in the API levels file.
+     */
+    val sdkExtensionsArguments: SdkExtensionsArguments?,
+
+    /**
+     * Determines what to do with If `true` then any references to undefined classes will be removed
+     * from super class and interface lists; otherwise any such references will be treated as an
+     * error.
+     *
+     * An undefined class is one that is not defined within any of the API versions loaded.
+     */
+    val missingClassAction: MissingClassAction,
+
+    /**
+     * Determines whether the [Api] should use internal names for the elements, or more source like
+     * names.
+     */
+    val useInternalNames: Boolean,
+)
+
+/**
+ * Possible actions to take when an [Api] object contains references in extends and implements types
+ * to classes which are not defined within the [Api] (i.e. have no corresponding [ApiClass] because
+ * they were not defined within any of the API versions loaded).
+ */
+enum class MissingClassAction {
+    /** Keep the references in the [Api]. */
+    KEEP {
+        override fun apply(api: Api) {
+            // Do nothing.
+        }
+    },
+
+    /** Remove the references from the [Api]. */
+    REMOVE {
+        override fun apply(api: Api) {
+            api.removeMissingClasses()
+        }
+    },
+
+    /** Report the references as errors. */
+    REPORT {
+        override fun apply(api: Api) {
+            api.verifyNoMissingClasses()
+        }
+    };
+
+    /** Apply this action to [api]. */
+    abstract fun apply(api: Api)
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt
deleted file mode 100644
index 86074b0cb..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.apilevels
-
-import java.io.File
-
-/**
- * Properties for the [ApiGenerator.generateFromVersionedApis] method that come from command line
- * options.
- */
-data class GenerateApiVersionsFromVersionedApisConfig(
-    /** A list of versioned APIs, ordered from the oldest API version to newest. */
-    val versionedApis: List<VersionedApi>,
-
-    /** The api versions file that will be generated. */
-    val outputFile: File,
-
-    /** The [ApiPrinter] to use to write the API versions to [outputFile]. */
-    val printer: ApiPrinter,
-)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt
deleted file mode 100644
index 736fb5044..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.apilevels
-
-import com.android.tools.metalava.apilevels.ApiGenerator.SdkExtensionsArguments
-import java.io.File
-
-/** Properties for the [ApiGenerator.generateXml] method that come from comment line options. */
-data class GenerateXmlConfig(
-    /**
-     * The list of jar files from which the API levels file will be populated. One for each API
-     * level, indexed by API level, starting from 1. The 0th element plus any element less than
-     * [firstApiLevel] is a placeholder that is an invalid file and should not be used.
-     */
-    val apiLevels: List<File>,
-
-    /** The first API level to include the API levels file. */
-    val firstApiLevel: Int,
-
-    /**
-     * The current version.
-     *
-     * If there is no corresponding element in [apiLevels] for this then the API defined in the
-     * sources will be added to the API levels file for this API level unless
-     * [isDeveloperPreviewBuild] is `true`.
-     */
-    val currentSdkVersion: ApiVersion,
-
-    /**
-     * True if the [currentSdkVersion] level is for a developer preview build.
-     *
-     * If this is `true` then the API defined in the sources will be added to the API levels file
-     * with an API level of [currentSdkVersion]` - 1`.
-     */
-    val isDeveloperPreviewBuild: Boolean,
-
-    /** The API levels file that will be generated. */
-    val outputFile: File,
-
-    /**
-     * Optional SDK extensions arguments.
-     *
-     * If provided then SDK extension information will be included in the API levels file.
-     */
-    val sdkExtensionsArguments: SdkExtensionsArguments?,
-
-    /**
-     * If `true` then any references to undefined classes will be removed from super class and
-     * interface lists; otherwise any such references will be treated as an error.
-     *
-     * An undefined class is one that is not defined within any of the API versions loaded.
-     */
-    val removeMissingClasses: Boolean,
-)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
index 1f0e35b61..756ab6fb9 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
@@ -25,32 +25,25 @@ import org.objectweb.asm.tree.ClassNode
 import org.objectweb.asm.tree.FieldNode
 import org.objectweb.asm.tree.MethodNode
 
-fun Api.readAndroidJar(sdkVersion: ApiVersion, jar: File) {
-    update(sdkVersion)
-    val updater = ApiElement.Updater.forApiVersion(sdkVersion)
-    readJar(jar, updater)
-}
-
-fun Api.readExtensionJar(
-    extVersion: ExtVersion,
-    module: String,
-    jar: File,
-    nextSdkVersion: ApiVersion
-) {
-    val updater = ApiElement.Updater.forExtVersion(nextSdkVersion, extVersion, module)
-    readJar(jar, updater)
-}
-
-private fun Api.readJar(
+fun Api.readJar(
     jar: File,
-    updater: ApiElement.Updater,
+    updater: ApiHistoryUpdater,
+    filter: ((String) -> Boolean)? = null,
 ) {
+    require(useInternalNames) { "Cannot add jars to Api that does not use internal names" }
+    // Update the Api for this version of the jar.
+    updater.update(this)
     val fis = FileInputStream(jar)
     ZipInputStream(fis).use { zis ->
-        var entry = zis.nextEntry
-        while (entry != null) {
-            if (!entry.name.endsWith(SdkConstants.DOT_CLASS)) {
-                entry = zis.nextEntry
+        while (true) {
+            val entry = zis.nextEntry ?: break
+            val entryName = entry.name
+            if (!entryName.endsWith(SdkConstants.DOT_CLASS)) {
+                continue
+            }
+
+            // If a filter is provided and returns false then ignore the entry.
+            if (filter != null && !filter(entryName)) {
                 continue
             }
             val bytes = zis.readBytes()
@@ -107,8 +100,6 @@ private fun Api.readJar(
                     )
                 }
             }
-
-            entry = zis.nextEntry
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt
new file mode 100644
index 000000000..e6793274f
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt
@@ -0,0 +1,922 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.ARG_CURRENT_VERSION
+import com.android.tools.metalava.ARG_FIRST_VERSION
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import java.io.File
+import java.util.TreeSet
+
+/**
+ * A node in a tree of path patterns used to select historical API files.
+ *
+ * e.g. the nodes of `prebuilts/sdk/{version:level}/public/android.jar` would be:
+ * 1. The root element.
+ * 2. `prebuilts`
+ * 3. `sdk`
+ * 4. `{version:level}` - a wild card representing any numbered directory.
+ * 5. `public`
+ * 6. `android.jar`
+ *
+ * Where each node is the child of the preceding node.
+ *
+ * If two or more patterns had matching nodes, then they will share the nodes. e.g.
+ * `prebuilts/sdk/{version:level}/system/android.jar` would share the first 4 nodes with above
+ * followed by two more nodes `system` and `android.jar`.
+ *
+ * These will be used to either find matching files in the file system by scanning through matching
+ * directories or determine whether a specific file path that is passed in matches the pattern. In
+ * either case this will also be used to extract information from the path, e.g. the api version.
+ */
+sealed class PatternNode {
+    /**
+     * List of all the children of this node.
+     *
+     * Nodes are added in the order in which they should be checked.
+     */
+    private val children = mutableListOf<PatternNode>()
+
+    /** Check to see if this node has any children. */
+    internal fun hasChildren() = children.isNotEmpty()
+
+    /**
+     * Dump the contents of this node and return as a string.
+     *
+     * Useful for debugging and testing.
+     */
+    internal fun dump(): String {
+        return buildString { dumpTo(this, "") }
+    }
+
+    /** Dump the contents of this node to the [builder] using [indent]. */
+    private fun dumpTo(builder: StringBuilder, indent: String) {
+        builder.apply {
+            append(indent)
+            append(this@PatternNode.toString())
+            append("\n")
+            for (child in children) {
+                child.dumpTo(this, "$indent  ")
+            }
+        }
+    }
+
+    /**
+     * Get [text] plus a `/` suffix if this has any children as in that case it is assumed to match
+     * a directory.
+     */
+    protected fun withDirectorySuffixIfHasChildren(text: String) =
+        text + if (children.isEmpty() || text == "/") "" else "/"
+
+    /**
+     * Get an existing child node that matches [child] or if none exist add [child] and return it.
+     */
+    private fun getExistingOrAdd(child: PatternNode): PatternNode {
+        // The child node must be new without any children of its own.
+        require(child.children.isEmpty()) { "Cannot add $child as it has children of its own" }
+        return children.find { it == child } ?: child.also { children.add(child) }
+    }
+
+    /**
+     * Provides access to the files that are to be scanned.
+     *
+     * Callers that want to limit the scanning to only some files can provide a custom
+     * implementation of this.
+     */
+    internal interface FileProvider {
+        /**
+         * Resolve [name] relative to [base] and if the resulting file exists then return it,
+         * otherwise return null.
+         */
+        fun resolve(base: File, name: String): File?
+
+        /** Return a sequence of the files in [dir], or null if [dir] is not a directory. */
+        fun listFiles(dir: File): Sequence<File>?
+    }
+
+    /** Provides access to all files in the whole file system. */
+    internal open class WholeFileSystemProvider : FileProvider {
+        override fun resolve(base: File, name: String): File? {
+            val file = base.resolve(name)
+            return if (file.exists()) file else null
+        }
+
+        override fun listFiles(dir: File): Sequence<File>? {
+            return dir.listFiles()?.asSequence()
+        }
+    }
+
+    /**
+     * A [FileProvider] that limits access to a supplied list of [File]s.
+     *
+     * @param files The list of [File]s to which this will provide access.
+     */
+    internal class LimitedFileSystemProvider(files: List<File>) : WholeFileSystemProvider() {
+        /**
+         * Map from [File] to the list of [File]s it contains (or an empty list for [File]s that
+         * have no contents).
+         */
+        private val fileToContents =
+            buildMap<File, MutableList<File>> {
+                for (file in files) {
+                    // Remember the file.
+                    computeIfAbsent(file) { mutableListOf() }
+
+                    // Add the file to its parent file's contents. Repeat for its parent file.
+                    var f: File = file
+                    while (true) {
+                        val parent = f.parentFile ?: break
+                        val contents = computeIfAbsent(parent) { mutableListOf() }
+                        contents.add(f)
+                        f = parent
+                    }
+                }
+            }
+
+        override fun resolve(base: File, name: String): File? {
+            val file = super.resolve(base, name)
+            return if (file in fileToContents) file else null
+        }
+
+        override fun listFiles(dir: File): Sequence<File>? {
+            if (!dir.isDirectory) return null
+            return fileToContents[dir]?.asSequence()
+        }
+    }
+
+    /** Configuration provided when scanning. */
+    internal data class ScanConfig(
+        /** The root directory from which the scanning will be performed. */
+        val dir: File,
+
+        /**
+         * An optional filter which, if specified, will limit the versions that will be returned.
+         * This is provided when scanning, instead of just filtering afterward, to save time when
+         * scanning by ignoring version directories that are not accepted by the filter.
+         */
+        val apiVersionFilter: ((ApiVersion) -> Boolean)? = null,
+
+        /** Provides access to [File]s. */
+        val fileProvider: FileProvider = WholeFileSystemProvider(),
+
+        /**
+         * Map from [ApiSurface.name] to [ApiSurface]s that is used by [Placeholder.SURFACE] to map
+         * from surface name to [ApiSurface].
+         *
+         * It is an error if a [Placeholder.SURFACE] is used and this is not provided.
+         */
+        val apiSurfaceByName: Map<String, ApiSurface>? = null,
+    )
+
+    /**
+     * Scan the [ScanConfig.dir] using this pattern node as the guide.
+     *
+     * Returns a list of [MatchedPatternFile] objects, ordered such that the files are ordered by:
+     * * [MatchedPatternFile.extension], i.e. primary API (i.e. when [MatchedPatternFile.extension]
+     *   is `false`) come before those for extensions.
+     * * [MatchedPatternFile.module], i.e. those for which this is `null` come before everything
+     *   else, and they are sorted alphabetically.
+     * * [MatchedPatternFile.version], i.e. from lowest to highest.
+     * * [MatchedPatternFile.surface], i.e. those for which this is `null` come before everything
+     *   else, and they are sorted according to their natural order.
+     *
+     * If multiple [MatchedPatternFile]s differ only in [MatchedPatternFile.file] then only the
+     * first instance found will be used. The order of discovery is determined by the order in which
+     * patterns were passed to [PatternNode.parsePatterns].
+     */
+    internal fun scan(config: ScanConfig): List<MatchedPatternFile> {
+        val dir = config.dir
+        val start = PatternFileState(file = dir)
+
+        // Create a sorted set into which the matched files will be added.
+        val sortedSet = TreeSet(matchedPatternFileComparator)
+
+        // Scan for files and add them to the sorted set if an equivalent one does not exist. That
+        // will eliminate duplicates and order them.
+        for (matchedPatternFile in scan(config, start)) {
+            // Add the file if it does not already exist in the set. That ensures that the set
+            // contains the first instance of each duplicate.
+            sortedSet.add(matchedPatternFile)
+        }
+
+        return sortedSet.toList()
+    }
+
+    /**
+     * Scan the [PatternFileState.file] using this pattern node as the guide to find the matching
+     * files.
+     *
+     * This returns the result as a [Sequence] of [MatchedPatternFile] which have each been
+     * populated with information extracted from matching [File]s.
+     *
+     * The basic idea is that the [PatternNode] will guide the scanning by using information within
+     * the [PatternNode] hierarchy to limit scanning to only those directories that could possibly
+     * match the patterns from which the [PatternNode] hierarchy was created.
+     *
+     * Each implementation of this consumes a [PatternFileState] (whose [PatternFileState.file] is
+     * the directory to scan) and then applies its own rules to select [File]s that match. It then
+     * creates copies of [state] for each [File] (possibly updating other properties too). Those new
+     * [PatternFileState]s are either passed to [children] for further scanning, or if this is a
+     * leaf node then they are converted into a sequence of [MatchedPatternFile]s that are returned
+     * to the caller.
+     */
+    internal abstract fun scan(
+        config: ScanConfig,
+        state: PatternFileState
+    ): Sequence<MatchedPatternFile>
+
+    /**
+     * Pass the [PatternFileState] on for further scanning or return [MatchedPatternFile]s if no
+     * further scanning is necessary.
+     *
+     * If [children] is empty then this just returns a [Sequence] containing the
+     * [MatchedPatternFile] created from [state]. Otherwise, this passes [state] to each of the
+     * [children] to scan, and flattens the resulting [Sequence]s of [MatchedPatternFile]s and
+     * returns that.
+     */
+    internal fun scanChildrenOrReturnMatching(
+        config: ScanConfig,
+        state: PatternFileState,
+    ): Sequence<MatchedPatternFile> =
+        if (children.isEmpty())
+            sequenceOf(
+                // Convert the PatternFileState into MatchedPatternFile objects relative to dir.
+                state.matchedPatternFile(),
+            )
+        else children.asSequence().flatMap { it.scan(config, state) }
+
+    /**
+     * Used by [getExistingOrAdd] to allow duplicate nodes to be ignored.
+     *
+     * This must not include [children] in the check as in [getExistingOrAdd] the existing
+     * [PatternNode]s being compared are likely to have a non-empty [children] list but the new
+     * [PatternNode] will have an empty [children] list.
+     */
+    abstract override fun equals(other: Any?): Boolean
+
+    /** Not currently used but should be implemented consistent with [equals]. */
+    abstract override fun hashCode(): Int
+
+    /**
+     * The root [PatternNode].
+     *
+     * Just acts as a container for other [PatternNode]s.
+     */
+    private class RootPatternNode : PatternNode() {
+        override fun toString() = "<root>"
+
+        override fun scan(
+            config: ScanConfig,
+            state: PatternFileState
+        ): Sequence<MatchedPatternFile> {
+            if (!hasChildren()) return emptySequence()
+            return scanChildrenOrReturnMatching(config, state)
+        }
+
+        /** Root nodes are unique. */
+        override fun equals(other: Any?): Boolean {
+            return this === other
+        }
+
+        /** Root nodes are unique. */
+        override fun hashCode(): Int {
+            return System.identityHashCode(this)
+        }
+    }
+
+    /**
+     * Matches a fixed file called [name].
+     *
+     * e.g. if [name] is `foo` then when scanning/matching directory `bar`, this will scan/match
+     * `bar/foo`.
+     */
+    private data class FixedNamePatternNode(
+        /** The fixed name of the file that this matches. */
+        val name: String,
+    ) : PatternNode() {
+        override fun toString() = withDirectorySuffixIfHasChildren(name)
+
+        /** Check to see if there i */
+        override fun scan(
+            config: ScanConfig,
+            state: PatternFileState
+        ): Sequence<MatchedPatternFile> {
+            // Resolve this against the file in [properties] to get a new file. If that file does
+            // not exist then ignore it by returning an empty sequence.
+            val newFile = config.fileProvider.resolve(state.file, name) ?: return emptySequence()
+
+            // Create a new set of properties by copying the original properties, replacing the file
+            // with the new file.
+            val newProperties = state.copy(file = newFile)
+
+            // Pass the properties on to the next nodes in the scanning, or return if this is the
+            // last node.
+            return scanChildrenOrReturnMatching(config, newProperties)
+        }
+    }
+
+    /**
+     * Matches any file name containing one or more placeholders.
+     *
+     * The [pattern] is used to create a [regex] which is matched against each file name that could
+     * match. If it matches then for each placeholder at position `i` in the list of [placeholders]
+     * the `i+1`th group is retrieved from the [MatchResult] and passed to the [Placeholder]'s
+     * [Property]'s [Property.track] method. That will then process the value and update a property
+     * in [PatternFileState].
+     *
+     * e.g. assume [pattern] is `android-(\d+)` and [placeholders] contains a single instance of
+     * [Placeholder.VERSION_LEVEL]. When scanning/matching directory `bar`, this will scan any file
+     * in that directory called `android-<version>`, e.g. `bar/android-1`, `bar/android-2`, etc. The
+     * 1st group will be retrieved and passed to the [Property.track] method for the
+     * [Property.VERSION] which will create an [ApiVersion] and if appropriate store it in the
+     * [PatternFileState.version] property.
+     *
+     * This is a data class as it needs to implement [equals] and [hashCode] so that instances can
+     * be dedup-ed by [PatternNode.getExistingOrAdd].
+     *
+     * @param pattern the regular expression pattern that will match the file name and which has a
+     *   capturing group for each [Placeholder] in [placeholders] in the same order.
+     * @param placeholders the list of [Placeholder]s that will extract information from a matching
+     *   file name and track it in a [PatternFileState].
+     */
+    private data class PlaceholderPatternNode(
+        private val pattern: String,
+        val placeholders: List<Placeholder>,
+    ) : PatternNode() {
+        override fun toString() = withDirectorySuffixIfHasChildren(pattern)
+
+        private val regex = Regex(pattern)
+
+        override fun scan(
+            config: ScanConfig,
+            state: PatternFileState
+        ): Sequence<MatchedPatternFile> {
+            val contents = config.fileProvider.listFiles(state.file) ?: return emptySequence()
+            return contents.flatMap { file ->
+                // Match the regex against the file name, if it does not match then ignore this
+                // file and all its contents by returning an empty sequence.
+                val name = file.name
+                val matcher = regex.matchEntire(name) ?: return@flatMap emptySequence()
+
+                var newState = state.copy(file = file)
+                for ((index, placeholder) in placeholders.withIndex()) {
+                    // There is a one-to-one correspondence between each capturing group in the
+                    // [pattern] and each placeholder in [placeholders] and each placeholder is
+                    // associated with the groups index is one more than the index of the
+                    // placeholder in the placeholders list. It is one more because group indices
+                    // are one based as group 0 corresponds to the text that matches the whole
+                    // pattern.
+                    val groupIndex = index + 1
+
+                    // Retrieve the value of the group for the placeholder. Throws an error if it
+                    // could not be found as that should never happen.
+                    val matchGroup =
+                        matcher.groups[groupIndex]
+                            ?: error("No matching group found for placeholder $placeholder")
+
+                    // Extract the value and store it in the appropriate [PatternFileState]
+                    // property.
+                    newState =
+                        placeholder.property.track(config, newState, matchGroup.value, placeholder)
+                            ?: return@flatMap emptySequence()
+                }
+
+                scanChildrenOrReturnMatching(config, newState)
+            }
+        }
+    }
+
+    /** The properties for which placeholders can be provided. */
+    enum class Property(val propertyName: String, val help: () -> String) {
+        /**
+         * Corresponds to the [PatternFileState.version] and [MatchedPatternFile.version]
+         * properties.
+         */
+        VERSION(
+            "version",
+            help = {
+                """
+                    Mandatory property that stores the version of a matched file.
+
+                    Apart from the ${Placeholder.VERSION_EXTENSION} all placeholders for this will
+                    ignore versions that fall outside the range $ARG_FIRST_VERSION and
+                    $ARG_CURRENT_VERSION, if provided.
+                """
+            },
+        ) {
+            override fun track(
+                config: ScanConfig,
+                state: PatternFileState,
+                value: String,
+                placeholder: Placeholder,
+            ): PatternFileState? {
+                // Extract the API version from the value.
+                val version = ApiVersion.fromString(value)
+
+                val extension = placeholder == Placeholder.VERSION_EXTENSION
+
+                // Make sure that it is accepted by the filter (if one was specified). If it is not
+                // then ignore this file and all its contents by returning an empty sequence. The
+                // filter does not apply to extension versions, all extension versions are used.
+                if (!extension) {
+                    config.apiVersionFilter?.let { apiVersionFilter ->
+                        if (!apiVersionFilter(version)) return null
+                    }
+                }
+
+                return state.copy(version = version, extension = extension)
+            }
+        },
+
+        /**
+         * Corresponds to the [PatternFileState.module] and [MatchedPatternFile.module] properties.
+         */
+        MODULE(
+            "module",
+            help = {
+                """
+                    Optional property that stores the name of the SDK extension module.
+
+                    Patterns that use a placeholder for this are assumed to be matching files for
+                    SDK extensions.
+                """
+            },
+        ) {
+            override fun track(
+                config: ScanConfig,
+                state: PatternFileState,
+                value: String,
+                placeholder: Placeholder,
+            ) = state.copy(module = value)
+        },
+
+        /**
+         * Corresponds to the [PatternFileState.surface] and [MatchedPatternFile.surface]
+         * properties.
+         */
+        SURFACE(
+            "surface",
+            help = {
+                """
+                    Optional property that stores the API surface.
+                """
+            },
+        ) {
+            override fun track(
+                config: ScanConfig,
+                state: PatternFileState,
+                value: String,
+                placeholder: Placeholder,
+            ): PatternFileState? {
+                val apiSurfaceByName =
+                    config.apiSurfaceByName
+                        ?: error(
+                            "Must provide ScanConfig.apiSurfaceByName when ${Placeholder.SURFACE} is used"
+                        )
+                // Look the surface up in the available surfaces, if it could not be found then
+                // ignore this file.
+                val surface = apiSurfaceByName[value] ?: return null
+                return state.copy(surface = surface)
+            }
+        },
+        ;
+
+        /**
+         * Tracks the placeholder value by extracting it from [value] and creating a copy of [state]
+         * with the value stored in the appropriate property.
+         *
+         * If the placeholder value is invalid for some reason then returns `null` to indicate that
+         * the [state] should be ignored.
+         *
+         * @param config configuration that affects the matching.
+         * @param state the input [PatternFileState].
+         * @param value the value of the placeholder extracted from the path.
+         * @param placeholder the [Placeholder] for which this is being called.
+         */
+        internal abstract fun track(
+            config: ScanConfig,
+            state: PatternFileState,
+            value: String,
+            placeholder: Placeholder,
+        ): PatternFileState?
+
+        override fun toString() = propertyName
+    }
+
+    /**
+     * Enumeration of all possible placeholders.
+     *
+     * @param property the name of the property in [PatternFileState] that will be updated by the
+     *   placeholder.
+     * @param format the format of the property. This differentiates between placeholders with the
+     *   same [property] but which have different [pattern]s.
+     * @param pattern the pattern that determines which part of a file name will be matched by the
+     *   placeholder. This must not contain any capturing groups.
+     * @param help lambda for providing help used in the `metalava help historical-api-patterns`
+     *   command. A lambda is used to allow references to [Property] instances that may not have
+     *   been initialized before this is initialized.
+     */
+    enum class Placeholder(
+        val property: Property,
+        private val format: String?,
+        val pattern: String,
+        val help: () -> String,
+    ) {
+        /** The {version:level} placeholder. */
+        VERSION_LEVEL(
+            property = Property.VERSION,
+            format = "level",
+            pattern = """\d+""",
+            help = {
+                """
+                    Matches a single non-negative integer and treats it as an API version.
+                """
+            },
+        ),
+
+        /** The {version:major.minor?} placeholder. */
+        VERSION_MAJOR_MINOR(
+            property = Property.VERSION,
+            format = "major.minor?",
+            // Match either a single major version or a major and minor version together.
+            pattern = """\d+(?:\.\d+)?""",
+            help = {
+                """
+                    Matches a single non-negative integer or two such integers separated by a `.`.
+                """
+            },
+        ),
+
+        /** The {version:major.minor.patch} placeholder. */
+        VERSION_MAJOR_MINOR_PATCH(
+            property = Property.VERSION,
+            format = "major.minor.patch",
+            // Only match a version with major, minor and patch components.
+            pattern = """\d+\.\d+\.\d+""",
+            help = {
+                """
+                    Matches three non-negative integers separated by `.`s.
+                """
+            },
+        ),
+
+        /** The {version:extension} placeholder. */
+        VERSION_EXTENSION(
+            property = Property.VERSION,
+            format = "extension",
+            // Only match a version with extension version.
+            pattern = """\d+""",
+            help = {
+                """
+                    Matches a single non-negative integer and treats it as an extension version.
+
+                    A pattern that includes this must also include `$MODULE` as SDK extension APIs
+                    are stored in a file per extension module.
+                """
+            },
+        ),
+
+        /** The {module} placeholder. */
+        MODULE(
+            property = Property.MODULE,
+            format = null,
+            pattern = """[a-z-.]+""",
+            help = {
+                """
+                    Matches a module name which must consist of lower case letters, hyphens and
+                    `.`s.
+                """
+            },
+        ),
+
+        /** The {surface} placeholder. */
+        SURFACE(
+            property = Property.SURFACE,
+            format = null,
+            pattern = """[a-z-]+""",
+            help = {
+                """
+                    Matches a surface name which must consist of lower case letters and hyphens.
+                """
+            },
+        ),
+        ;
+
+        /** The label for this that will be used in a path pattern, e.g. `{version:level}`. */
+        val label = if (format == null) "{$property}" else "{$property:$format}"
+
+        override fun toString() = label
+
+        companion object {
+            fun placeholderForLabel(label: String, pathPattern: String): Placeholder {
+                return placeholderByLabel[label]
+                    ?: error(
+                        "Pattern '$pathPattern' contains an unknown placeholder '$label', expected one of ${placeholderByLabel.keys.joinToString {"'$it'"}}"
+                    )
+            }
+
+            /** Map from [Placeholder.label] to [Placeholder]. */
+            internal val placeholderByLabel = Placeholder.entries.associateBy { it.label }
+        }
+    }
+
+    companion object {
+        /**
+         * Parse a list of [patterns] into a tree of [PatternNode]s.
+         *
+         * Each pattern in [patterns] must contain a single `{version:level}` that is a placeholder
+         * for the version number.
+         */
+        fun parsePatterns(patterns: List<String>): PatternNode {
+            val root = RootPatternNode()
+            for (pattern in patterns) {
+                addPattern(root, pattern)
+            }
+            return root
+        }
+
+        /**
+         * Add a new pattern [pathPattern] to [root], where [pathPattern] consists of name patterns
+         * separated by `/`.
+         *
+         * Creates a [PatternNode] for each name pattern in the supplied [pathPattern] inserting it
+         * into the [root], reusing existing [PatternNode]s where possible.
+         */
+        private fun addPattern(root: PatternNode, pathPattern: String) {
+            // The list of nodes used for the pattern.
+            val nodes = mutableListOf<PatternNode>()
+
+            var parent = root
+            // Split the pattern using `/` and iterate over each of the parts adding them into the
+            // tree structure.
+            for (namePattern in pathPattern.split("/")) {
+                // Create a node for the pattern.
+                val node =
+                    when {
+                        // Handle when the path is absolute and starts with a /
+                        namePattern == "" -> {
+                            FixedNamePatternNode("/")
+                        }
+                        '{' in namePattern || '*' in namePattern -> {
+                            parseParameterizedPattern(pathPattern, namePattern)
+                        }
+                        else -> FixedNamePatternNode(namePattern)
+                    }
+
+                nodes.add(node)
+
+                // Find a matching node in the parent adding the new node if no existing node
+                // exists. Use the result as the parent for the next node.
+                parent = parent.getExistingOrAdd(node)
+            }
+
+            // Check to make sure that exactly one of the nodes will match an API version.
+            val usedPlaceholders =
+                nodes.mapNotNull { it as? PlaceholderPatternNode }.flatMap { it.placeholders }
+            val placeholdersByProperty = usedPlaceholders.groupBy { it.property }
+
+            // Do some basic validation of the placeholders in the pattern.
+            if (Property.VERSION !in placeholdersByProperty) {
+                // At least one placeholder that will set the version property must be provided.
+                error("Pattern '$pathPattern' does not contain placeholder for ${Property.VERSION}")
+            }
+
+            for ((property, placeholders) in placeholdersByProperty.entries) {
+                val count = placeholders.size
+                // An entry in a map created by groupBy will always have a list containing at least
+                // one item.
+                if (count != 1) {
+                    // No property can have multiple placeholders for it as that could lead to a
+                    // conflict over which value will be used and/or complicate the logic to make
+                    // sure that all the values are the same.
+                    error(
+                        "Pattern '$pathPattern' contains multiple placeholders for $property; found ${placeholders.joinToString()}"
+                    )
+                }
+            }
+
+            if (
+                Placeholder.VERSION_EXTENSION in usedPlaceholders &&
+                    Placeholder.MODULE !in usedPlaceholders
+            ) {
+                error(
+                    "Pattern '$pathPattern' contains `${Placeholder.VERSION_EXTENSION}` but does not contain `${Placeholder.MODULE}`"
+                )
+            }
+        }
+
+        /** [Regex] to find placeholders or wildcards in a pattern. */
+        private val PLACEHOLDER_OR_WILDCARD_REGEX = Regex("""(\{[^}]+})|(\*)""")
+
+        /**
+         * Parse a parameterized pattern, i.e. one with a placeholder like '{version:level}'.
+         *
+         * The basic approach is to convert the [pattern] into a standard regular expression and a
+         * list of [Placeholder]s such that each placeholder in [pattern] has a corresponding
+         * capture group in the regular expression and a [Placeholder] in the list. The list is in
+         * the same order as the groups. Together they are used to create a [PlaceholderPatternNode]
+         * that will use that information to update a [PatternFileState] with information extracted
+         * from a matching file.
+         *
+         * @param pathPattern the pattern for the whole file path, used for error reporting.
+         * @param pattern the pattern for one file name in the path. This is the pattern that this
+         *   method will parse.
+         */
+        private fun parseParameterizedPattern(pathPattern: String, pattern: String): PatternNode {
+            val regexBuilder = StringBuilder()
+            var literalStart = 0
+
+            val placeholders = mutableListOf<Placeholder>()
+
+            /**
+             * Quote any literal text found between the start of the pattern or last placeholder and
+             * the [firstNonLiteral].
+             */
+            fun quoteLiteralText(firstNonLiteral: Int) {
+                if (firstNonLiteral > literalStart) {
+                    regexBuilder.append(
+                        Regex.escape(pattern.substring(literalStart, firstNonLiteral))
+                    )
+                }
+            }
+
+            // Convert the pattern into a regular expression, quoting any literal text and replacing
+            // placeholders/wildcards with an appropriate regular expression.
+            for (matchResult in PLACEHOLDER_OR_WILDCARD_REGEX.findAll(pattern)) {
+                // Quote any literal text found between the start of the pattern or last
+                // placeholder/wildcard and this match.
+                quoteLiteralText(matchResult.range.first)
+
+                // The next block of literal text (if any) will start after the match.
+                literalStart = matchResult.range.last + 1
+
+                // Extract the text representation of the placeholder/wildcard from the pattern and
+                // process it accordingly.
+                when (val placeholderOrWildcardText = matchResult.value) {
+                    "*" -> {
+                        regexBuilder.append("""[^/]*""")
+                    }
+                    else -> {
+                        // Find the corresponding [Placeholder], failing if it could not be found.
+                        val placeholder =
+                            Placeholder.placeholderForLabel(placeholderOrWildcardText, pathPattern)
+
+                        // Add a capturing group to the pattern for the placeholder. This requires
+                        // that the placeholder pattern does not contain any capturing groups of its
+                        // own.
+                        regexBuilder.append("""(${placeholder.pattern})""")
+
+                        // Add a placeholder. As placeholder patterns do not contain capturing
+                        // groups the combined pattern has a single group for each placeholder and
+                        // in the same order as the placeholders.
+                        placeholders.add(placeholder)
+                    }
+                }
+            }
+
+            // Quote any literal text found at the end of the pattern after the last placeholder.
+            quoteLiteralText(pattern.length)
+
+            return PlaceholderPatternNode(regexBuilder.toString(), placeholders.toList())
+        }
+    }
+}
+
+/**
+ * Encapsulates the information accrued about a specific [file] that matches a pattern during
+ * scanning.
+ */
+internal data class PatternFileState(
+    /**
+     * The [File] that has been matched so far.
+     *
+     * This could be a directory, e.g. `prebuilts/sdk` after matching
+     */
+    val file: File,
+
+    /** The optional [ApiVersion] that was extracted from the path. */
+    val version: ApiVersion? = null,
+
+    /** Indicates whether the file is for an SDK extension module. */
+    val extension: Boolean = false,
+
+    /** The optional module that was extracted from the path. */
+    val module: String? = null,
+
+    /** The optional surface that was extracted from the path. */
+    val surface: ApiSurface? = null,
+) {
+    /**
+     * Construct a [MatchedPatternFile] from this.
+     *
+     * This must only be called when this has been matched by a leaf [PatternNode] and so is
+     * guaranteed to have had [version] set to a non-null value.
+     */
+    fun matchedPatternFile() =
+        if (version == null) error("matching pattern could not extract version from $file")
+        else
+            MatchedPatternFile(
+                file = file,
+                version = version,
+                extension = extension,
+                module = module,
+                surface = surface,
+            )
+
+    /**
+     * If this [File] is a descendant of [base] then return a relative path from [base] to this,
+     * otherwise just return this.
+     *
+     * This ensures that an absolute path does not end up being turned into an even more complicated
+     * relative path that starts with lots of `../../`. This is only needed for tests that use
+     * patterns in a temporary directory which is not relative to the current directory in which the
+     * scanning is performed. It should not be an issue in practice as callers typically run with
+     * patterns relative to the current directory.
+     */
+    private fun File.relativeDescendantOfOrSelf(base: File) =
+        relativeTo(base).let { relative -> if (relative.startsWith("../")) file else relative }
+}
+
+/** Represents a [File] that matches a pattern encapsulate in a hierarchy of [PatternNode]s. */
+data class MatchedPatternFile(
+    /**
+     * The matched [File].
+     *
+     * This is relative to the directory supplied in [PatternNode.ScanConfig.dir].
+     */
+    val file: File,
+
+    /** The [ApiVersion] extracted from the [File] path. */
+    val version: ApiVersion,
+
+    /** True if this represents a file from an extension module. */
+    val extension: Boolean = false,
+
+    /** The optional module that was extracted from the [File] path. */
+    val module: String? = null,
+
+    /** The optional surface that was extracted from the [File] path. */
+    val surface: ApiSurface? = null,
+) {
+    /**
+     * Create a string representation of the properties, used for testing and debugging.
+     *
+     * Any optional properties will only be included in the string representation if they are
+     * provided, e.g. not `null`. That means adding a new optional property will not affect any
+     * tests that rely on the output of this.
+     */
+    override fun toString(): String {
+        return buildString {
+            append("MatchedPatternFile(")
+            append("file=")
+            append(file.path)
+            append(", version=")
+            append(version)
+            if (extension) {
+                append(", extension=true")
+            }
+            if (module != null) {
+                append(", module='")
+                append(module)
+                append("'")
+            }
+            if (surface != null) {
+                append(", surface='")
+                append(surface.name)
+                append("'")
+            }
+            append(")")
+        }
+    }
+}
+
+/**
+ * Comparator that is used to identify duplicate [MatchedPatternFile]s and defined an order for the
+ * unique instances.
+ */
+private val matchedPatternFileComparator: Comparator<MatchedPatternFile> =
+    // If any of the selectors return `null` that will compare before any other value.
+    compareBy(
+        // Group into those that are for the primary API and those that are for an extension.
+        { it.extension },
+        // Group into those without modules and then by those with module, in order.
+        { it.module },
+        // Then sort them from the lowest version to the highest version.
+        { it.version },
+        // Then group into those without surface and then by those with a surface, in order.
+        { it.surface },
+    )
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/SdkExtensionInfo.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/SdkExtensionInfo.kt
new file mode 100644
index 000000000..899eb6ef3
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/SdkExtensionInfo.kt
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.SdkExtension
+import javax.xml.parsers.SAXParserFactory
+import org.xml.sax.Attributes
+import org.xml.sax.helpers.DefaultHandler
+
+/** Encapsulates information read from the `sdk-extension-info.xml` file. */
+class SdkExtensionInfo(
+    /** Information retrieved from `<sdk>` elements. */
+    val availableSdkExtensions: AvailableSdkExtensions,
+
+    /** Information retrieved from `<symbol>` elements, organized by jar. */
+    private val extensionsByJar: Map<String, ApiToExtensionsMap>,
+) {
+    /**
+     * An empty [ApiToExtensionsMap], returned from [extensionsMapForJarOrEmpty] if a jar specific
+     * map could not be found.
+     *
+     * This is given [availableSdkExtensions] as it will be used to check the validity of sdk names
+     * even if there is no information about the symbols.
+     */
+    private val empty = ApiToExtensionsMap(availableSdkExtensions, Node("<empty>"))
+
+    /**
+     * Get the [ApiToExtensionsMap] for [jar], returning an empty map if no specific map for [jar]
+     * could be found.
+     */
+    fun extensionsMapForJarOrEmpty(jar: String) = extensionsByJar[jar] ?: empty
+
+    companion object {
+        /**
+         * Create an ApiToExtensionsMap from a list of text based rules.
+         *
+         * The input is XML:
+         *
+         *     <?xml version="1.0" encoding="utf-8"?>
+         *     <sdk-extensions-info version="1">
+         *         <sdk name="<name>" shortname="<short-name>" id="<int>" reference="<constant>" />
+         *         <symbol jar="<jar>" pattern="<pattern>" sdks="<sdks>" />
+         *     </sdk-extensions-info>
+         *
+         * The <sdk> and <symbol> tags may be repeated.
+         * - <name> is a long name for the SDK, e.g. "R Extensions".
+         * - <short-name> is a short name for the SDK, e.g. "R-ext".
+         * - <id> is the numerical identifier for the SDK, e.g. 30. It is an error to use the
+         *   Android SDK ID (0).
+         * - <jar> is the jar file symbol belongs to, named after the jar file in
+         *   prebuilts/sdk/extensions/<int>/public, e.g. "framework-sdkextensions".
+         * - <constant> is a Java symbol that can be passed to `SdkExtensions.getExtensionVersion`
+         *   to look up the version of the corresponding SDK, e.g.
+         *   "android/os/Build$VERSION_CODES$R"
+         * - <pattern> is either '*', which matches everything, or a 'com.foo.Bar$Inner#member'
+         *   string (or prefix thereof terminated before . or $), which matches anything with that
+         *   prefix. Note that arguments and return values of methods are omitted (and there is no
+         *   way to distinguish overloaded methods).
+         * - <sdks> is a comma separated list of SDKs in which the symbol defined by <jar> and
+         *   <pattern> appears; the list items are <name> attributes of SDKs defined in the XML.
+         *
+         * It is an error to specify the same <jar> and <pattern> pair twice.
+         *
+         * A more specific <symbol> rule has higher precedence than a less specific rule.
+         *
+         * @param filterByJar jar file to limit lookups to: ignore symbols not present in this jar
+         *   file
+         * @param xml XML as described above
+         * @throws IllegalArgumentException if the XML is malformed
+         */
+        fun fromXml(xml: String): SdkExtensionInfo {
+            val sdkExtensions = mutableSetOf<SdkExtension>()
+            val allSeenExtensions = mutableSetOf<String>()
+
+            // Map from jar name to the root node.
+            val jarToRoot = mutableMapOf<String, Node>()
+
+            val parser = SAXParserFactory.newDefaultInstance().newSAXParser()
+            try {
+                parser.parse(
+                    xml.byteInputStream(),
+                    object : DefaultHandler() {
+                        override fun startElement(
+                            uri: String,
+                            localName: String,
+                            qualifiedName: String,
+                            attributes: Attributes
+                        ) {
+                            when (qualifiedName) {
+                                "sdk" -> {
+                                    val id = attributes.getIntOrThrow(qualifiedName, "id")
+                                    val shortname =
+                                        attributes.getStringOrThrow(qualifiedName, "shortname")
+                                    val name = attributes.getStringOrThrow(qualifiedName, "name")
+                                    val reference =
+                                        attributes.getStringOrThrow(qualifiedName, "reference")
+                                    sdkExtensions.add(
+                                        SdkExtension.fromXmlAttributes(
+                                            id,
+                                            shortname,
+                                            name,
+                                            reference,
+                                        )
+                                    )
+                                }
+                                "symbol" -> {
+                                    val jar = attributes.getStringOrThrow(qualifiedName, "jar")
+                                    // Get the root node for the jar, creating one if needed.
+                                    val rootForJar =
+                                        jarToRoot.computeIfAbsent(jar) { Node("<jar $jar>") }
+
+                                    val sdks =
+                                        attributes
+                                            .getStringOrThrow(qualifiedName, "sdks")
+                                            .split(',')
+                                    if (sdks != sdks.distinct()) {
+                                        throw IllegalArgumentException(
+                                            "symbol lists the same SDK multiple times: '$sdks'"
+                                        )
+                                    }
+                                    allSeenExtensions.addAll(sdks)
+                                    val pattern =
+                                        attributes.getStringOrThrow(qualifiedName, "pattern")
+                                    if (pattern == "*") {
+                                        rootForJar.extensions = sdks
+                                        return
+                                    }
+                                    // pattern is com.example.Foo, add nodes:
+                                    //     "com" -> "example" -> "Foo"
+                                    val parts = pattern.splitIntoBreadcrumbs()
+                                    var node = rootForJar
+                                    for (name in parts) {
+                                        node = node.children.addNode(name)
+                                    }
+                                    if (node.extensions.isNotEmpty()) {
+                                        throw IllegalArgumentException(
+                                            "duplicate pattern: $pattern"
+                                        )
+                                    }
+                                    node.extensions = sdks
+                                }
+                            }
+                        }
+                    }
+                )
+            } catch (e: Throwable) {
+                throw IllegalArgumentException("failed to parse xml", e)
+            }
+
+            val availableSdkExtensions = AvailableSdkExtensions(sdkExtensions)
+
+            // verify: all rules refer to declared SDKs
+            for (ext in allSeenExtensions) {
+                if (!availableSdkExtensions.containsSdkExtension(ext)) {
+                    throw IllegalArgumentException("bad SDK definitions: undefined SDK $ext")
+                }
+            }
+
+            // Transform the map from jar to root node into a map from jar to ApiToExtensionsMap.
+            val extensionsByJar =
+                jarToRoot.entries.associate { (jar, root) ->
+                    jar to ApiToExtensionsMap(availableSdkExtensions, root)
+                }
+            return SdkExtensionInfo(availableSdkExtensions, extensionsByJar)
+        }
+    }
+}
+
+private fun MutableSet<Node>.addNode(name: String): Node {
+    findNode(name)?.let {
+        return it
+    }
+    val node = Node(name)
+    add(node)
+    return node
+}
+
+private fun Attributes.getStringOrThrow(tag: String, attr: String): String =
+    getValue(attr) ?: throw IllegalArgumentException("<$tag>: missing attribute: $attr")
+
+private fun Attributes.getIntOrThrow(tag: String, attr: String): Int =
+    getStringOrThrow(tag, attr).toIntOrNull()
+        ?: throw IllegalArgumentException("<$tag>: attribute $attr: not an integer")
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt
index 41eb91a80..19d23d0ea 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt
@@ -19,10 +19,18 @@ package com.android.tools.metalava.apilevels
 /**
  * Represents a specific [ApiVersion] of an API.
  *
- * Supports updating [Api] with information from the [apiVersion] of the API that is defined in
- * * the signature [file].
+ * Supports updating [Api] with information from the [apiVersion] of the API that is defined by
+ * this.
  */
-interface VersionedApi {
+sealed class VersionedApi(
+    protected val updater: ApiHistoryUpdater,
+) {
+    /** The [ApiVersion] of the API defined by this. */
+    val apiVersion = updater.apiVersion
+
     /** Update [api] with information from this version of the API. */
-    fun updateApi(api: Api)
+    abstract fun updateApi(api: Api)
+
+    /** Provide a string representation for debugging and testing. */
+    abstract override fun toString(): String
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
index e4844b442..1b6cbeaa6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
@@ -19,14 +19,18 @@ package com.android.tools.metalava.apilevels
 import java.io.File
 
 /**
- * Supports updating [Api] with information from the [sdkVersion] of the API that is defined in
- * [jar].
+ * Supports updating [Api] with information from the version of the API that is defined in [jar].
+ *
+ * The [updater] is responsible for updating the [Api].
  */
 class VersionedJarApi(
-    private val jar: File,
-    private val sdkVersion: ApiVersion,
-) : VersionedApi {
+    val jar: File,
+    updater: ApiHistoryUpdater,
+    private val filter: ((String) -> Boolean)? = null,
+) : VersionedApi(updater) {
     override fun updateApi(api: Api) {
-        api.readAndroidJar(sdkVersion, jar)
+        api.readJar(jar, updater, filter)
     }
+
+    override fun toString() = "VersionedJarApi(jar=$jar, updater=$updater)"
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt
index e3166a567..718c3ddc0 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt
@@ -24,16 +24,52 @@ import java.io.File
 
 /**
  * Supports updating [Api] with information from the [apiVersion] of the API that is defined in the
- * signature [file].
+ * signature [files].
  */
 class VersionedSignatureApi(
     private val signatureFileLoader: SignatureFileLoader,
-    private val file: File,
-    private val apiVersion: ApiVersion,
-) : VersionedApi {
+    private val files: List<File>,
+    updater: ApiHistoryUpdater,
+) : VersionedApi(updater) {
+
+    init {
+        require(files.isNotEmpty()) { "files must contain at least one file" }
+    }
+
     override fun updateApi(api: Api) {
-        val codebase = signatureFileLoader.load(SignatureFile.fromFiles(file))
+        val codebase = signatureFileLoader.load(SignatureFile.fromFiles(files))
         val codebaseFragment = CodebaseFragment.create(codebase, ::NonFilteringDelegatingVisitor)
-        addApisFromCodebase(api, apiVersion, codebaseFragment, false)
+        addApisFromCodebase(api, updater, codebaseFragment)
+    }
+
+    override fun toString(): String {
+        // Compute the string representation of the files. Listing a number of potentially long
+        // files all on one line can make it difficult to debug. As the files are likely to contain
+        // common prefixes and suffixes, e.g. `prebuilts/sdk/28/public/api/android.txt` and
+        // `prebuilts/sdk/28/system/api/android.txt` this replaces it with a string that uses bash
+        // brace expansion syntax so it would generate all the original if used in bash, e.g.
+        // `prebuilts/sdk/28/{public,system}/api/android.txt`.
+        val filesAsString = stringsToBashBraceExpansion(files.map { it.path })
+        return "VersionedSignatureApi(files=$filesAsString, updater=$updater)"
+    }
+
+    companion object {
+        /** Generate a bash string expansion that will generate [strings]. */
+        internal fun stringsToBashBraceExpansion(strings: List<String>) =
+            if (strings.size == 1) {
+                strings.first()
+            } else {
+                val commonPrefix = strings.reduce { p1, p2 -> p1.commonPrefixWith(p2) }
+                val commonSuffix = strings.reduce { p1, p2 -> p1.commonSuffixWith(p2) }
+                buildString {
+                    append(commonPrefix)
+                    append("{")
+                    strings.joinTo(this, ",") {
+                        it.removePrefix(commonPrefix).removeSuffix(commonSuffix)
+                    }
+                    append("}")
+                    append(commonSuffix)
+                }
+            }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt
index 78d3d4977..1359b70b3 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt
@@ -20,13 +20,16 @@ import com.android.tools.metalava.model.CodebaseFragment
 
 /**
  * Supports updating an [Api] with information from the [apiVersion] of the API that is defined by
- * the [codebaseFragment] of the sources.
+ * the [CodebaseFragment] of the sources created by [codebaseFragmentProvider].
  */
 class VersionedSourceApi(
-    private val codebaseFragment: CodebaseFragment,
-    private val apiVersion: ApiVersion,
-) : VersionedApi {
+    private val codebaseFragmentProvider: () -> CodebaseFragment,
+    apiVersion: ApiVersion,
+) : VersionedApi(ApiHistoryUpdater.forApiVersion(apiVersion)) {
     override fun updateApi(api: Api) {
-        addApisFromCodebase(api, apiVersion, codebaseFragment, useInternalNames = false)
+        val codebaseFragment = codebaseFragmentProvider()
+        addApisFromCodebase(api, updater, codebaseFragment)
     }
+
+    override fun toString() = "VersionedSourceApi(version=$apiVersion)"
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
index 8419e8f1a..e5ac514b0 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.ENV_VAR_METALAVA_DUMP_ARGV
 import com.android.tools.metalava.model.source.SourceModelProvider
 import com.android.tools.metalava.reporter.DefaultReporterEnvironment
 import com.android.tools.metalava.reporter.ReporterEnvironment
+import java.io.InputStream
 import java.io.OutputStreamWriter
 import java.io.PrintWriter
 import java.io.StringWriter
@@ -35,6 +36,7 @@ import java.io.StringWriter
 data class ExecutionEnvironment(
     val stdout: PrintWriter = PrintWriter(OutputStreamWriter(System.out)),
     val stderr: PrintWriter = PrintWriter(OutputStreamWriter(System.err)),
+    val stdin: InputStream = System.`in`,
     val reporterEnvironment: ReporterEnvironment = DefaultReporterEnvironment(),
     val testEnvironment: TestEnvironment? = null,
 ) {
@@ -53,7 +55,7 @@ data class ExecutionEnvironment(
 
     companion object {
         /** Get an [ExecutionEnvironment] suitable for use by tests. */
-        fun forTest(): Triple<ExecutionEnvironment, StringWriter, StringWriter> {
+        fun forTest(stdin: String = ""): Triple<ExecutionEnvironment, StringWriter, StringWriter> {
             val stdoutString = StringWriter()
             val stderrString = StringWriter()
             val stdout = PrintWriter(stdoutString)
@@ -62,6 +64,7 @@ data class ExecutionEnvironment(
                 ExecutionEnvironment(
                     stdout = stdout,
                     stderr = stderr,
+                    stdin = stdin.byteInputStream(),
                     reporterEnvironment =
                         DefaultReporterEnvironment(
                             stdout = stdout,
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
index 2454cd507..607b2a900 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
@@ -17,12 +17,9 @@
 package com.android.tools.metalava.cli.common
 
 import com.android.tools.metalava.reporter.DefaultReporter
-import com.android.tools.metalava.reporter.DefaultReporterEnvironment
 import com.android.tools.metalava.reporter.ERROR_WHEN_NEW_SUFFIX
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reporter
-import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.default
@@ -30,7 +27,6 @@ import com.github.ajalt.clikt.parameters.options.flag
 import com.github.ajalt.clikt.parameters.options.option
 import com.github.ajalt.clikt.parameters.types.int
 import com.github.ajalt.clikt.parameters.types.restrictTo
-import java.io.File
 
 const val ARG_ERROR = "--error"
 const val ARG_ERROR_WHEN_NEW = "--error-when-new"
@@ -49,7 +45,6 @@ const val ARG_REPORT_EVEN_IF_SUPPRESSED = "--report-even-if-suppressed"
 const val REPORTING_OPTIONS_GROUP = "Issue Reporting"
 
 class IssueReportingOptions(
-    reporterEnvironment: ReporterEnvironment = DefaultReporterEnvironment(),
     commonOptions: CommonOptions = CommonOptions(),
 ) :
     OptionGroup(
@@ -68,18 +63,6 @@ class IssueReportingOptions(
     /** The [IssueConfiguration] that is configured by these options. */
     val issueConfiguration = IssueConfiguration()
 
-    /**
-     * The [Reporter] that is used to report issues encountered while parsing these options.
-     *
-     * A slight complexity is that this [Reporter] and its [IssueConfiguration] are both modified
-     * and used during the process of processing the options.
-     */
-    internal val bootstrapReporter: DefaultReporter =
-        DefaultReporter(
-            reporterEnvironment,
-            issueConfiguration,
-        )
-
     init {
         // Create a Clikt option for handling the issue options and updating them as a side effect.
         // This needs to be a single option for handling all the issue options in one go because the
@@ -94,13 +77,10 @@ class IssueReportingOptions(
         // However, when processed after grouping they would be equivalent to one of the following
         // depending on which was processed last:
         //     --hide Foo,Bar
-        //     --error Foo,Bar
+        //     --error Bar,Foo
         //
-        // Instead, this creates a single Clikt option to handle all the issue options but they are
-        // still collated before processing so if they are interleaved with other options whose
-        // parsing makes use of the `reporter` then there is the potential for a change in behavior.
-        // However, currently it does not look as though that is the case except for reporting
-        // issues with deprecated options which is tested.
+        // Instead, this creates a single Clikt option to handle all the issue options, but they are
+        // still collated before processing.
         //
         // Having a single Clikt option with lots of different option names does make the help hard
         // to read as it produces a single line with all the option names on it. So, this uses a
@@ -109,19 +89,16 @@ class IssueReportingOptions(
         val issueOption =
             compositeSideEffectOption(
                 // Create one side effect option per label.
-                ConfigLabel.values().map {
-                    sideEffectOption(it.optionName, help = it.help) {
+                ConfigLabel.entries.map { label ->
+                    sideEffectOption(label.optionName, help = label.help) { optionValue ->
                         // if `--hide id1,id2` was supplied on the command line then this will split
-                        // it into
-                        // ["id1", "id2"]
-                        val values = it.split(",")
-
-                        // Get the label from the name of the option.
-                        val label = ConfigLabel.fromOptionName(name)
+                        // it into ["id1", "id2"]
+                        val values = optionValue.split(",")
 
                         // Update the configuration immediately
-                        values.forEach {
-                            label.setAspectForId(bootstrapReporter, issueConfiguration, it.trim())
+                        for (value in values) {
+                            val trimmed = value.trim()
+                            label.setAspectForId(issueConfiguration, trimmed)
                         }
                     }
                 }
@@ -183,23 +160,13 @@ private enum class ConfigurableAspect {
     /** A single issue needs configuring. */
     ISSUE {
         override fun setAspectSeverityForId(
-            reporter: Reporter,
             configuration: IssueConfiguration,
             optionName: String,
             severity: Severity,
             id: String
         ) {
             val issue =
-                Issues.findIssueById(id)
-                    ?: Issues.findIssueByIdIgnoringCase(id)?.also {
-                        reporter.report(
-                            Issues.DEPRECATED_OPTION,
-                            null as File?,
-                            "Case-insensitive issue matching is deprecated, use " +
-                                "$optionName ${it.name} instead of $optionName $id"
-                        )
-                    }
-                        ?: throw MetalavaCliException("Unknown issue id: '$optionName' '$id'")
+                Issues.findIssueById(id) ?: cliError("Unknown issue id: '$optionName' '$id'")
 
             configuration.setSeverity(issue, severity)
         }
@@ -207,23 +174,23 @@ private enum class ConfigurableAspect {
     /** A whole category of issues needs configuring. */
     CATEGORY {
         override fun setAspectSeverityForId(
-            reporter: Reporter,
             configuration: IssueConfiguration,
             optionName: String,
             severity: Severity,
             id: String
         ) {
-            val issues =
-                Issues.findCategoryById(id)?.let { Issues.findIssuesByCategory(it) }
-                    ?: throw MetalavaCliException("Unknown category: $optionName $id")
+            try {
+                val issues = Issues.findCategoryById(id).let { Issues.findIssuesByCategory(it) }
 
-            issues.forEach { configuration.setSeverity(it, severity) }
+                issues.forEach { configuration.setSeverity(it, severity) }
+            } catch (e: Exception) {
+                throw MetalavaCliException("Option $optionName is invalid: ${e.message}", cause = e)
+            }
         }
     };
 
     /** Configure the [IssueConfiguration] appropriately. */
     abstract fun setAspectSeverityForId(
-        reporter: Reporter,
         configuration: IssueConfiguration,
         optionName: String,
         severity: Severity,
@@ -294,17 +261,7 @@ private enum class ConfigLabel(
     );
 
     /** Configure the aspect identified by [id] into the [configuration]. */
-    fun setAspectForId(reporter: Reporter, configuration: IssueConfiguration, id: String) {
-        aspect.setAspectSeverityForId(reporter, configuration, optionName, severity, id)
-    }
-
-    companion object {
-        private val optionNameToLabel = ConfigLabel.values().associateBy { it.optionName }
-
-        /**
-         * Get the label for the option name. This is only called with an option name that has been
-         * obtained from [ConfigLabel.optionName] so it is known that it must match.
-         */
-        fun fromOptionName(option: String): ConfigLabel = optionNameToLabel[option]!!
+    fun setAspectForId(configuration: IssueConfiguration, id: String) {
+        aspect.setAspectSeverityForId(configuration, optionName, severity, id)
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCliException.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCliException.kt
index 5802dd4e2..a9ecfe635 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCliException.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCliException.kt
@@ -33,3 +33,9 @@ class MetalavaCliException(
     /** Optional cause. */
     cause: Throwable? = null,
 ) : RuntimeException(stdout + stderr, cause)
+
+/**
+ * Throw a [MetalavaCliException] printing [message] to [stderr] and exiting with a non-zero exit
+ * code.
+ */
+fun cliError(message: String): Nothing = throw MetalavaCliException(stderr = message)
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCommand.kt
index 6945120d9..f9a0c03ce 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaCommand.kt
@@ -29,6 +29,7 @@ import com.github.ajalt.clikt.parameters.groups.provideDelegate
 import com.github.ajalt.clikt.parameters.options.eagerOption
 import com.github.ajalt.clikt.parameters.options.flag
 import com.github.ajalt.clikt.parameters.options.option
+import java.io.InputStream
 import java.io.PrintWriter
 
 const val ARG_VERSION = "--version"
@@ -266,7 +267,7 @@ internal open class MetalavaCommand(
                 // Get the default command.
                 val defaultCommand =
                     registeredSubcommands().singleOrNull { it.commandName == defaultCommandName }
-                        ?: throw MetalavaCliException(
+                        ?: cliError(
                             "Invalid default command name '$defaultCommandName', expected one of '${registeredSubcommandNames().joinToString("', '")}'"
                         )
 
@@ -305,17 +306,21 @@ private val CliktCommand.metalavaCommand
     get() = if (this is MetalavaCommand) this else currentContext.findObject()!!
 
 /** The [ExecutionEnvironment] within which the command is being run. */
-val CliktCommand.executionEnvironment: ExecutionEnvironment
+val CliktCommand.executionEnvironment
     get() = metalavaCommand.executionEnvironment
 
 /** The [PrintWriter] to use for error output from the command. */
-val CliktCommand.stderr: PrintWriter
+val CliktCommand.stderr
     get() = executionEnvironment.stderr
 
 /** The [PrintWriter] to use for non-error output from the command. */
-val CliktCommand.stdout: PrintWriter
+val CliktCommand.stdout
     get() = executionEnvironment.stdout
 
+/** The [InputStream] to use for input to the command. */
+val CliktCommand.stdin
+    get() = executionEnvironment.stdin
+
 val CliktCommand.commonOptions
     // Retrieve the CommonOptions that is made available by the containing MetalavaCommand.
     get() = metalavaCommand.common
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaHelpFormatter.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaHelpFormatter.kt
index 3f9005228..feff31c26 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaHelpFormatter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaHelpFormatter.kt
@@ -120,8 +120,17 @@ internal open class MetalavaHelpFormatter(
                 .sortedBy { (it as? Option)?.groupName != defaultOptionGroupName }
                 .toList()
 
+        // Scan for enum help text and style for the terminal.
+        val styledProlog = styleEnumHelpTextIfNeeded(prolog, mutableMapOf(), terminal)
+
         // Use the default help format.
-        val help = super.formatHelp(prolog, epilog, transformedParameters, formattedProgramName)
+        val help =
+            super.formatHelp(
+                styledProlog,
+                epilog,
+                transformedParameters,
+                formattedProgramName,
+            )
 
         return removePadding(help)
     }
@@ -183,12 +192,7 @@ internal open class MetalavaHelpFormatter(
         val styledHelp = styleEnumHelpTextIfNeeded(help, mutableTags, terminal)
 
         // Add any additional help text.
-        val helpText = super.renderHelpText(styledHelp, mutableTags)
-
-        // Remove any trailing NEL to prevent additional blank lines being added. This is done here
-        // rather than before as super.renderHelpText(...) may append content to the end which would
-        // need to be separated from the rest of the text by a blank line.
-        return helpText.removeSuffix(HARD_NEWLINE)
+        return super.renderHelpText(styledHelp, mutableTags)
     }
 
     override fun renderOptionName(name: String): String {
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
index 31b0f9072..932a32ea8 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
@@ -136,7 +136,7 @@ internal fun fileForPathInner(path: String): File {
 internal fun stringToExistingDir(value: String): File {
     val file = fileForPathInner(value)
     if (!file.isDirectory) {
-        throw MetalavaCliException("$file is not a directory")
+        cliError("$file is not a directory")
     }
     return file
 }
@@ -164,7 +164,7 @@ internal fun stringToNewDir(value: String): File {
             output.mkdirs()
         }
     if (!ok) {
-        throw MetalavaCliException("Could not create $output")
+        cliError("Could not create $output")
     }
 
     return output
@@ -179,7 +179,7 @@ internal fun stringToNewDir(value: String): File {
 internal fun stringToExistingFile(value: String): File {
     val file = fileForPathInner(value)
     if (!file.isFile) {
-        throw MetalavaCliException("$file is not a file")
+        cliError("$file is not a file")
     }
     return file
 }
@@ -197,16 +197,16 @@ internal fun stringToNewFile(value: String): File {
 
     if (output.exists()) {
         if (output.isDirectory) {
-            throw MetalavaCliException("$output is a directory")
+            cliError("$output is a directory")
         }
         val deleted = output.delete()
         if (!deleted) {
-            throw MetalavaCliException("Could not delete previous version of $output")
+            cliError("Could not delete previous version of $output")
         }
     } else if (output.parentFile != null && !output.parentFile.exists()) {
         val ok = output.parentFile.mkdirs()
         if (!ok) {
-            throw MetalavaCliException("Could not create ${output.parentFile}")
+            cliError("Could not create ${output.parentFile}")
         }
     }
 
@@ -227,7 +227,7 @@ internal fun stringToNewOrExistingFile(value: String): File {
         if (parentFile != null && !parentFile.isDirectory) {
             val ok = parentFile.mkdirs()
             if (!ok) {
-                throw MetalavaCliException("Could not create $parentFile")
+                cliError("Could not create $parentFile")
             }
         }
     }
@@ -238,6 +238,9 @@ internal fun stringToNewOrExistingFile(value: String): File {
 // collapsing the `\n` into adjacent spaces. Acts like an HTML <br/>.
 const val HARD_NEWLINE = "\u0085"
 
+// Two consecutive newline characters will result in a blank line in the Clikt formatted output.
+const val BLANK_LINE = "\n\n"
+
 /**
  * Create a property delegate for an enum.
  *
@@ -279,34 +282,75 @@ internal fun <T : Enum<T>> ParameterHolder.nonInlineEnumOption(
     enumValues: Array<T>,
     help: String,
     enumValueHelpGetter: (T) -> String,
-    key: (T) -> String,
+    enumLabelGetter: (T) -> String,
     default: T
 ): OptionWithValues<T, T, T> {
-    // Filter out any enum values that do not provide any help.
-    val optionToValue = enumValues.filter { enumValueHelpGetter(it) != "" }.associateBy { key(it) }
+    val labelToEnumValue =
+        enumValues
+            // Filter out any enum values that do not provide any help.
+            .filter { enumValueHelpGetter(it) != "" }
+            // Convert to a map from label to enum value.
+            .associateBy { enumLabelGetter(it) }
 
     // Get the help representation of the default value.
-    val defaultForHelp = key(default)
+    val defaultForHelp = enumLabelGetter(default)
 
     val constructedHelp = buildString {
         append(help)
-        append(HARD_NEWLINE)
-        for (enumValue in optionToValue.values) {
-            val value = key(enumValue)
-            // This must match the pattern used in MetalavaHelpFormatter.styleEnumHelpTextIfNeeded
-            // which is used to deconstruct this.
-            append(constructStyleableChoiceOption(value))
-            append(" - ")
-            append(enumValueHelpGetter(enumValue))
-            append(HARD_NEWLINE)
-        }
+        appendDefinitionListHelp(
+            labelToEnumValue.entries.map { (label, enumValue) ->
+                label to enumValueHelpGetter(enumValue)
+            }
+        )
     }
 
     return option(names = names, help = constructedHelp)
-        .choice(optionToValue)
+        .choice(labelToEnumValue)
         .default(default, defaultForHelp = defaultForHelp)
 }
 
+/**
+ * Build definition list help.
+ *
+ * @param definitionList is a list of [Pair]s, where [Pair.first] is the term being defined and
+ *   [Pair.second] is the definition of that term.
+ * @param termPrefix the prefix to add before each term being defined, e.g. `* ` to represent a
+ *   bullet list.
+ */
+fun buildDefinitionListHelp(
+    definitionList: List<Pair<String, String>>,
+    termPrefix: String = "",
+): String {
+    return buildString { appendDefinitionListHelp(definitionList, termPrefix) }
+}
+
+/**
+ * Append help for what is effectively a definition list, e.g. `<dl>...</dl>` in HTML.
+ *
+ * Each entry in the list has a term that is being defined and the definition of that term. If the
+ * terminal supports it then the term will be in bold. The term and definition are separate by ` -
+ * `.
+ *
+ * @param definitionList is a list of [Pair]s, where [Pair.first] is the term being defined and
+ *   [Pair.second] is the definition of that term.
+ * @param termPrefix the prefix to add before each term being defined, e.g. `* ` to represent a
+ *   bullet list.
+ */
+private fun StringBuilder.appendDefinitionListHelp(
+    definitionList: List<Pair<String, String>>,
+    termPrefix: String = "",
+) {
+    append(BLANK_LINE)
+    for ((term, body) in definitionList) {
+        // This must match the pattern used in MetalavaHelpFormatter.styleEnumHelpTextIfNeeded
+        // which is used to deconstruct this.
+        append(constructStyleableChoiceOption(term, termPrefix))
+        append(" - ")
+        append(body)
+        append(BLANK_LINE)
+    }
+}
+
 /**
  * Construct a styleable choice option.
  *
@@ -314,13 +358,32 @@ internal fun <T : Enum<T>> ParameterHolder.nonInlineEnumOption(
  * in the help text using [deconstructStyleableChoiceOption] and replaced with actual styling
  * sequences if needed.
  */
-private fun constructStyleableChoiceOption(value: String) = "$HARD_NEWLINE**$value**"
+private fun constructStyleableChoiceOption(value: String, prefix: String = "") =
+    "$BLANK_LINE$prefix**$value**"
 
 /**
  * A regular expression that will match choice options created using
  * [constructStyleableChoiceOption].
  */
-private val deconstructStyleableChoiceOption = """$HARD_NEWLINE\*\*([^*]+)\*\*""".toRegex()
+private val deconstructStyleableChoiceOption = """$BLANK_LINE(.*?)(\*\*([^*]+)\*\*)""".toRegex()
+
+/**
+ * The index of the group in [deconstructStyleableChoiceOption] that matches the prefix provided to
+ * [constructStyleableChoiceOption].
+ */
+private const val PREFIX_GROUP_INDEX = 1
+
+/**
+ * The index of the group in [deconstructStyleableChoiceOption] that must be replaced by
+ * [replaceChoiceOption].
+ */
+private const val REPLACEMENT_GROUP_INDEX = PREFIX_GROUP_INDEX + 1
+
+/**
+ * The index of the group in [deconstructStyleableChoiceOption] that contains the label that will be
+ * transformed by [replaceChoiceOption].
+ */
+private const val LABEL_GROUP_INDEX = REPLACEMENT_GROUP_INDEX + 1
 
 /**
  * Replace the choice option (i.e. the value passed to [constructStyleableChoiceOption]) with the
@@ -333,11 +396,20 @@ private fun MatchResult.replaceChoiceOption(
     builder: StringBuilder,
     transformer: (String) -> String
 ) {
-    val group = groups[1] ?: throw IllegalStateException("group 1 not found in $this")
-    val choiceOption = group.value
-    val replacementText = transformer(choiceOption)
-    // Replace the choice option and the surrounding style markers but not the leading NEL.
-    builder.replace(range.first + 1, range.last + 1, replacementText)
+    // Get the text for the label of the choice option.
+    val labelGroup =
+        groups[LABEL_GROUP_INDEX] ?: error("label group $LABEL_GROUP_INDEX not found in $this")
+    val label = labelGroup.value
+
+    // Transform the label.
+    val transformedLabel = transformer(label)
+
+    // Replace the label and the surrounding style markers but not the leading blank line or prefix
+    // with the transformed label.
+    val replacementGroup =
+        groups[REPLACEMENT_GROUP_INDEX]
+            ?: error("replacement group $REPLACEMENT_GROUP_INDEX not found in $this")
+    builder.replace(replacementGroup.range.first, replacementGroup.range.last + 1, transformedLabel)
 }
 
 /**
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/RequiresOtherGroups.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/RequiresOtherGroups.kt
new file mode 100644
index 000000000..4601396e5
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/RequiresOtherGroups.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.common
+
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+
+/**
+ * Interface for [OptionGroup] implementations that depend on, and access command line options from
+ * other [OptionGroup]s and so need to make sure that those other groups are initialized (by being
+ * parsed by Clikt).
+ *
+ * At the moment this is only used for testing purposes.
+ */
+interface RequiresOtherGroups {
+    /** The list of [OptionGroup]s required by this. */
+    val requiredGroups: List<OptionGroup>
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
index f2bde5637..96040d88e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
@@ -52,7 +52,7 @@ class DefaultSignatureFileLoader(
                 formatForLegacyFiles = formatForLegacyFiles,
             )
         } catch (ex: ApiParseException) {
-            throw MetalavaCliException("Unable to parse signature file: ${ex.message}")
+            cliError("Unable to parse signature file: ${ex.message}")
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
index 37f3f6c1c..958080e71 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
@@ -23,7 +23,6 @@ import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.option
 import java.io.File
 
-const val ARG_COMMON_SOURCE_PATH = "--common-source-path"
 const val ARG_SOURCE_PATH = "--source-path"
 
 const val ARG_STUB_PACKAGES = "--stub-packages"
@@ -41,20 +40,6 @@ class SourceOptions :
                 .trimIndent()
     ) {
 
-    private val commonSourcePathString by
-        option(
-            ARG_COMMON_SOURCE_PATH,
-            metavar = "<path>",
-            help =
-                """
-                    A ${File.pathSeparator} separated list of directories containing common source
-                    files (organized in a standard Java package hierarchy). Common source files
-                    are where platform-agnostic `expect` declarations for Kotlin multi-platform code
-                    as well as common business logic are defined.
-                """
-                    .trimIndent(),
-        )
-
     private val sourcePathString by
         option(
             ARG_SOURCE_PATH,
@@ -67,11 +52,6 @@ class SourceOptions :
                     .trimIndent(),
         )
 
-    internal val commonSourcePath by
-        lazy(LazyThreadSafetyMode.NONE) {
-            getSourcePath(ARG_COMMON_SOURCE_PATH, commonSourcePathString)
-        }
-
     internal val sourcePath by
         lazy(LazyThreadSafetyMode.NONE) { getSourcePath(ARG_SOURCE_PATH, sourcePathString) }
 
@@ -85,7 +65,7 @@ class SourceOptions :
         } else {
             path.split(File.pathSeparator).map {
                 if (it.endsWith(SdkConstants.DOT_JAVA)) {
-                    throw MetalavaCliException(
+                    cliError(
                         "$argName should point to a source root directory, not a source file ($it)"
                     )
                 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
index 8595ee145..3bfe98a10 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
@@ -16,11 +16,15 @@
 
 package com.android.tools.metalava.cli.help
 
+import com.android.tools.metalava.ARG_ANDROID_JAR_PATTERN
+import com.android.tools.metalava.apilevels.PatternNode
 import com.android.tools.metalava.cli.common.ARG_STUB_PACKAGES
 import com.android.tools.metalava.cli.common.MetalavaHelpFormatter
+import com.android.tools.metalava.cli.common.buildDefinitionListHelp
 import com.android.tools.metalava.cli.common.stdout
 import com.android.tools.metalava.cli.common.terminal
 import com.android.tools.metalava.cli.signature.ARG_FORMAT
+import com.android.tools.metalava.model.text.FileFormat
 import com.github.ajalt.clikt.core.CliktCommand
 import com.github.ajalt.clikt.core.context
 import com.github.ajalt.clikt.core.subcommands
@@ -28,7 +32,7 @@ import com.github.ajalt.clikt.output.Localization
 
 class HelpCommand :
     CliktCommand(
-        help = "Provides help for general metalava concepts",
+        help = "Provides help for general metalava concepts.",
         invokeWithoutSubcommand = true,
     ) {
 
@@ -53,7 +57,8 @@ class HelpCommand :
         subcommands(
             IssuesCommand(),
             packageFilterHelp,
-            signatureFileFormatsHelp,
+            signatureFileFormatsHelp(),
+            historicalApiPatterns(),
         )
     }
 
@@ -92,8 +97,48 @@ will match `foo` and `foo.bar` and `foo.bar.baz` but not `foobar`.
                 .trimIndent()
     )
 
-private val signatureFileFormatsHelp =
-    SimpleHelpCommand(
+private fun signatureFileFormatsHelp(): CliktCommand {
+    /** Construct help for the different [FileFormat.Version]s. */
+    fun versionHelp(): String {
+        /** Generate a label for a [FileFormat.Version]. */
+        fun FileFormat.Version.labelGetter() = buildString {
+            append('`')
+            append(versionNumber)
+            append('`')
+            if (legacyCommandLineAlias != null) {
+                append(" (")
+                append(ARG_FORMAT)
+                append("=")
+                append(legacyCommandLineAlias)
+                append(")")
+            }
+        }
+
+        return buildDefinitionListHelp(
+            FileFormat.Version.entries.map { it.labelGetter() to it.help.trimIndent() },
+            termPrefix = "* ",
+        )
+    }
+
+    /**
+     * Construct help for the different [FileFormat.CustomizableProperty]s.
+     *
+     * @param filter filter the properties for which help will be provided.
+     */
+    fun customizablePropertyHelp(filter: (FileFormat.CustomizableProperty) -> Boolean): String {
+        fun FileFormat.CustomizableProperty.labelGetter() = "`$propertyName = $valueSyntax`"
+        return buildDefinitionListHelp(
+            FileFormat.CustomizableProperty.entries.mapNotNull {
+                if (!filter(it)) return@mapNotNull null
+                val help = it.help
+                if (help == "") return@mapNotNull null
+                it.labelGetter() to help.trimIndent()
+            },
+            termPrefix = "* ",
+        )
+    }
+
+    return SimpleHelpCommand(
         name = "signature-file-formats",
         help =
             """
@@ -106,55 +151,79 @@ that will be output to the API signature file and how it is represented. A forma
 a set of defaults for those properties.
 
 The supported properties are:
+${customizablePropertyHelp {!it.defaultable}}
+
+Plus the following properties which can have their default changed using the `--format-defaults`
+option.
+${customizablePropertyHelp {it.defaultable}}
+
+Currently, metalava supports the following versions:
+${versionHelp()}
+            """
+                .trimIndent()
+    )
+}
 
-* `kotlin-style-nulls = yes|no` - if `no` then the signature file will use `@Nullable` and `@NonNull`
-  annotations to indicate that the annotated item accepts `null` and does not accept `null`
-  respectively and neither indicates that it's not defined.
+private fun historicalApiPatterns(): CliktCommand {
+    /** Construct help for the different [PatternNode.Placeholder]s. */
+    fun placeholderHelp(): String {
+        fun PatternNode.Placeholder.labelGetter() = "`$label`"
+        return buildDefinitionListHelp(
+            PatternNode.Placeholder.entries.mapNotNull {
+                val help = it.help()
+                if (help == "") return@mapNotNull null
+                it.labelGetter() to
+                    "Placeholder for property `${it.property}`. ${help.trimIndent()}"
+            },
+            termPrefix = "* ",
+        )
+    }
 
-  If `yes` then the signature file will use a type suffix of `?`, no type suffix and a type suffix
-  of `!` to indicate the that the type accepts `null`, does not accept `null` or it's not defined
-  respectively.
+    /** Construct help for the different [PatternNode.Property]s. */
+    fun propertyHelp(): String {
+        fun PatternNode.Property.labelGetter() = "`$propertyName`"
+        return buildDefinitionListHelp(
+            PatternNode.Property.entries.mapNotNull {
+                val help = it.help()
+                if (help == "") return@mapNotNull null
+                it.labelGetter() to help.trimIndent()
+            },
+            termPrefix = "* ",
+        )
+    }
 
-* `concise-default-values = yes|no` - if `no` then Kotlin parameters that have a default value will
-  include that value in the signature file. If `yes` then those parameters will simply be prefixed
-  with `optional`, as if it was a keyword and no value will be included.
+    return SimpleHelpCommand(
+        name = "historical-api-patterns",
+        help =
+            """
+Explains the syntax and behavior of historical API patterns used in options like $ARG_ANDROID_JAR_PATTERN.
 
-Plus the following properties which can have their default changed using the `--format-defaults`
-option.
+A historical API pattern is used to find historical versioned API files that are used to construct a
+history of an API surface, e.g. when items were added, removed, deprecated, etc.. It allows for
+efficiently scanning a directory for matching files, or matching a given file. In both cases
+information is extracted from the file path, e.g. version, that is used when constructing the API
+history.
 
-* `overloaded-method-order = source|signature` - Specifies the order of overloaded methods in
-  signature files. Applies to the contents of the files specified on `--api` and `--removed-api`.
+Each pattern contains placeholders which match part of a file name, extracts the value, possibly
+filters it and then stores it in a property. Each property can have at most a single associated
+placeholder in each pattern.
 
-  `source` - preserves the order in which overloaded methods appear in the source files. This means
-   that refactorings of the source files which change the order but not the API can cause
-   unnecessary changes in the API signature files.
+A `version` placeholder is mandatory but the other options are optional. Files that match a
+pattern are assumed to provide the definition of that version of the API. e.g. given a pattern of
+`prebuilts/sdk/{version:level}/public/android.jar` then it will match a file like
+`prebuilts/sdk/1/public/android.jar` and that file is assumed to define version 1 of the API.
 
-  `signature` (default) - sorts overloaded methods by their signature. This means that refactorings
-  of the source files which change the order but not the API will have no effect on the API
-  signature files.
+Patterns can also include any number of wildcards:
 
-Currently, metalava supports the following versions:
+* `*` - matches any characters within  a file name, but not into sub-directories. e.g. `foo/b*h/bar`
+  will match `foo/blah/bar` but not `foo/blah/blah/bar`.
 
-* `2.0` ($ARG_FORMAT=v2) - this is the base version (more details in `FORMAT.md`) on which all the
-  others are based. It sets the properties as follows:
-```
-+ kotlin-style-nulls = no
-+ concise-default-values = no
-```
-
-* `3.0` ($ARG_FORMAT=v3) - this is `2.0` plus `kotlin-style-nulls = yes` giving the following
-properties:
-```
-+ kotlin-style-nulls = yes
-+ concise-default-values = no
-```
-
-* `4.0` ($ARG_FORMAT=v4) - this is 3.0` plus `concise-default-values = yes` giving the following
-properties:
-```
-+ kotlin-style-nulls = yes
-+ concise-default-values = yes
-```
+The supported properties are:
+${propertyHelp()}
+
+The supported placeholders are:
+${placeholderHelp()}
             """
                 .trimIndent()
     )
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommand.kt
new file mode 100644
index 000000000..2914c1925
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommand.kt
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.historical
+
+import com.android.tools.metalava.ARG_CONFIG_FILE
+import com.android.tools.metalava.ConfigFileOptions
+import com.android.tools.metalava.OptionsDelegate
+import com.android.tools.metalava.apiSurfacesFromConfig
+import com.android.tools.metalava.apilevels.ApiVersion
+import com.android.tools.metalava.cli.common.MetalavaSubCommand
+import com.android.tools.metalava.cli.common.cliError
+import com.android.tools.metalava.cli.common.executionEnvironment
+import com.android.tools.metalava.cli.common.existingDir
+import com.android.tools.metalava.cli.common.map
+import com.android.tools.metalava.cli.common.progressTracker
+import com.android.tools.metalava.cli.common.stderr
+import com.android.tools.metalava.cli.common.stdout
+import com.android.tools.metalava.cli.signature.SignatureFormatOptions
+import com.android.tools.metalava.jar.StandaloneJarCodebaseLoader
+import com.android.tools.metalava.reporter.BasicReporter
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.arguments.validate
+import com.github.ajalt.clikt.parameters.groups.provideDelegate
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.split
+
+private const val ARG_ANDROID_ROOT_DIR = "<android-root-dir>"
+
+const val ARG_API_SURFACES = "--api-surfaces"
+
+class AndroidJarsToSignaturesCommand :
+    MetalavaSubCommand(
+        help =
+            """
+    Rewrite the signature files in the `prebuilts/sdk` directory in the Android source tree.
+
+    It does this by reading the API defined in the corresponding `android.jar` files.
+"""
+                .trimIndent(),
+    ) {
+
+    private val androidRootDir by
+        argument(
+                ARG_ANDROID_ROOT_DIR,
+                help =
+                    """
+                        The root directory of the Android source tree. The new signature files will
+                        be generated in the `prebuilts/sdk/<api>/<surface>/api/android.txt`
+                        sub-directories.
+                    """
+                        .trimIndent()
+            )
+            .existingDir()
+            .validate {
+                require(it.resolve("prebuilts/sdk").isDirectory) {
+                    cliError("$ARG_ANDROID_ROOT_DIR does not point to an Android source tree")
+                }
+            }
+
+    private val configFileOptions by ConfigFileOptions()
+
+    /** Add options for controlling the format of the generated files. */
+    private val signatureFormat by SignatureFormatOptions()
+
+    /** Optional set of [ApiVersion]s to convert. */
+    private val apiVersions by
+        option(
+                help =
+                    """
+                        Comma separated list of api versions to convert. If unspecified then all
+                        versions will be converted.
+                    """
+                        .trimIndent(),
+                metavar = "<api-version-list>",
+            )
+            .split(",")
+            .map { list -> list?.map { ApiVersion.fromString(it) }?.toSet() }
+
+    private val apiSurfaceNames by
+        option(
+                ARG_API_SURFACES,
+                help =
+                    """
+                        Comma separated list of api surfaces to convert. If unspecified then only
+                        `public` will be converted.
+                    """
+                        .trimIndent(),
+                metavar = "<api-surface-list>",
+            )
+            .split(",")
+            .map { list -> list?.distinct() ?: listOf("public") }
+
+    override fun run() {
+        // Make sure that none of the code called by this command accesses the global `options`
+        // property.
+        OptionsDelegate.disallowAccess()
+
+        // Create a self-consistent set of ApiSurfaces that either need to be converted or
+        // contribute to a surface that needs to be converted.
+        val apiSurfaces =
+            configFileOptions.config.apiSurfaces?.let { apiSurfacesConfig ->
+
+                // Collect the transitive closure of the configured ApiSurfaceConfigs for the
+                // required
+                // API surfaces.
+                val surfaceConfigs = buildSet {
+                    for (name in apiSurfaceNames) {
+                        val surfaceConfig =
+                            apiSurfacesConfig.getByNameOrError(name) {
+                                "$ARG_API_SURFACES (`$it`) does not match an <api-surface> in a --config-file"
+                            }
+                        addAll(apiSurfacesConfig.contributesTo(surfaceConfig))
+                    }
+                }
+
+                apiSurfacesFromConfig(surfaceConfigs, apiSurfaceNames.last())
+            }
+                ?: error(
+                    "$ARG_CONFIG_FILE is either not specified or does not define any API surfaces"
+                )
+
+        // Get the selected ApiSurface(s). The lookup is guaranteed to not be null because the
+        // name was checked above. Sort, so any extended ApiSurface comes before an extended
+        // ApiSurface.
+        val selectedApiSurfaces = apiSurfaceNames.map { apiSurfaces.byName[it]!! }.sorted()
+
+        StandaloneJarCodebaseLoader.create(
+                executionEnvironment.disableStderrDumping(),
+                progressTracker,
+                BasicReporter(stderr),
+            )
+            .use { jarCodebaseLoader ->
+                ConvertJarsToSignatureFiles(
+                        stderr,
+                        stdout,
+                        progressTracker,
+                        signatureFormat.fileFormat,
+                        apiVersions,
+                        apiSurfaces,
+                        selectedApiSurfaces,
+                        jarCodebaseLoader,
+                        androidRootDir,
+                    )
+                    .convertJars()
+            }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt b/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt
new file mode 100644
index 000000000..109ef2284
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.historical
+
+import com.android.SdkConstants
+import com.android.tools.metalava.CodebaseComparator
+import com.android.tools.metalava.ComparisonVisitor
+import com.android.tools.metalava.NullnessMigration
+import com.android.tools.metalava.ProgressTracker
+import com.android.tools.metalava.apilevels.ApiVersion
+import com.android.tools.metalava.apilevels.PatternNode
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
+import com.android.tools.metalava.createReportFile
+import com.android.tools.metalava.jar.JarCodebaseLoader
+import com.android.tools.metalava.model.ANDROIDX_NONNULL
+import com.android.tools.metalava.model.ANDROIDX_NULLABLE
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.SignatureWriter
+import com.android.tools.metalava.model.text.SnapshotDeltaMaker
+import com.android.tools.metalava.model.text.createFilteringVisitorForSignatures
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
+import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.reporter.BasicReporter
+import java.io.File
+import java.io.IOException
+import java.io.PrintWriter
+import java.util.zip.ZipFile
+import org.objectweb.asm.ClassReader
+import org.objectweb.asm.Opcodes
+import org.objectweb.asm.Type
+import org.objectweb.asm.tree.ClassNode
+import org.objectweb.asm.tree.FieldNode
+import org.objectweb.asm.tree.MethodNode
+
+/**
+ * In an Android source tree, rewrite the signature files in prebuilts/sdk by reading what's
+ * actually there in the android.jar files.
+ */
+class ConvertJarsToSignatureFiles(
+    private val stderr: PrintWriter,
+    private val stdout: PrintWriter,
+    private val progressTracker: ProgressTracker,
+    private val fileFormat: FileFormat,
+    private val apiVersions: Set<ApiVersion>?,
+    private val apiSurfaces: ApiSurfaces,
+    private val selectedApiSurfaces: List<ApiSurface>,
+    private val jarCodebaseLoader: JarCodebaseLoader,
+    private val root: File
+) {
+    private val reporter = BasicReporter(stderr)
+
+    fun convertJars() {
+        val scanConfig =
+            PatternNode.ScanConfig(
+                dir = root,
+                apiVersionFilter = apiVersions?.let { it::contains },
+                apiSurfaceByName = apiSurfaces.byName,
+            )
+
+        val historicalApis =
+            HistoricalApiVersionInfo.scan(
+                reporter,
+                jarFilePattern = "prebuilts/sdk/{version:major.minor?}/{surface}/android.jar",
+                signatureFilePattern =
+                    "prebuilts/sdk/{version:major.minor?}/{surface}/api/android.txt",
+                scanConfig,
+            )
+
+        for (historicalApi in historicalApis) {
+            // Only convert the files of the selected ApiSurfaces, even if the other surfaces
+            // contribute to this, e.g. if `system` extends `public` and only `system` is selected
+            // then do not convert `public` files.
+            for (selectedApiSurface in selectedApiSurfaces) {
+                val surfaceInfo = historicalApi.infoBySurface[selectedApiSurface] ?: continue
+                convertJar(historicalApi.version, surfaceInfo)
+            }
+        }
+    }
+
+    /**
+     * Convert a single jar for [version] in [SurfaceInfo.jarFile] into its corresponding signature
+     * file, i.e. [SurfaceInfo.signatureFile].
+     */
+    private fun convertJar(version: ApiVersion, surfaceInfo: SurfaceInfo) {
+        val jarFile = surfaceInfo.jarFile
+        val signatureFile = surfaceInfo.signatureFile
+
+        progressTracker.progress("Writing signature files $signatureFile for $jarFile")
+
+        val annotationManager = DefaultAnnotationManager()
+        val codebaseConfig =
+            Codebase.Config(
+                annotationManager = annotationManager,
+                apiSurfaces = apiSurfaces,
+                reporter = reporter,
+            )
+        val signatureFileLoader = DefaultSignatureFileLoader(codebaseConfig)
+
+        val jarCodebase =
+            jarCodebaseLoader.loadFromJarFile(
+                jarFile,
+                // Do not freeze codebases after loading as they may need to be modified.
+                freezeCodebase = false,
+            )
+
+        if (version.major >= 28) {
+            // As of API 28 we'll put nullness annotations into the jar but some of them may be
+            // @RecentlyNullable/@RecentlyNonNull. Translate these back into normal
+            // @Nullable/@NonNull
+            jarCodebase.accept(
+                object :
+                    ApiVisitor(
+                        apiPredicateConfig = ApiPredicate.Config(),
+                    ) {
+                    override fun visitItem(item: Item) {
+                        unmarkRecent(item)
+                        super.visitItem(item)
+                    }
+
+                    private fun unmarkRecent(new: Item) {
+                        val annotation = NullnessMigration.findNullnessAnnotation(new) ?: return
+                        // Nullness information change: Add migration annotation
+                        val annotationClass =
+                            if (annotation.isNullable()) ANDROIDX_NULLABLE else ANDROIDX_NONNULL
+
+                        val replacementAnnotation =
+                            new.codebase.createAnnotation("@$annotationClass", new)
+                        new.mutateModifiers {
+                            mutateAnnotations {
+                                remove(annotation)
+                                replacementAnnotation?.let { add(it) }
+                            }
+                        }
+                    }
+                }
+            )
+            assert(!SUPPORT_TYPE_USE_ANNOTATIONS) {
+                "We'll need to rewrite type annotations here too"
+            }
+        }
+
+        // Read deprecated attributes. Seem to be missing from code model; try to read via ASM
+        // instead since it must clearly be there.
+        markDeprecated(jarCodebase, jarFile, jarFile.path)
+
+        // ASM doesn't seem to pick up everything that's actually there according to javap. So as
+        // another fallback, read from the existing signature files:
+        try {
+            // Read all the signature files that contribute to this surface to ensure that any
+            // deprecated classes in the extended surface are also deprecated in the extending
+            // surface.
+            val signatureFiles = surfaceInfo.contributingSignatureFiles()
+            val oldCodebase = signatureFileLoader.load(signatureFiles)
+            val visitor =
+                object : ComparisonVisitor() {
+                    override fun compareItems(old: Item, new: Item) {
+                        if (old.originallyDeprecated && old !is PackageItem) {
+                            new.deprecateIfRequired("previous signature file for $old")
+                        }
+                    }
+                }
+            CodebaseComparator().compare(visitor, oldCodebase, jarCodebase, null)
+        } catch (e: Exception) {
+            throw IllegalStateException("Could not load existing signature file: ${e.message}", e)
+        }
+
+        val jarCodebaseFragment =
+            CodebaseFragment.create(
+                jarCodebase,
+                { delegate ->
+                    createFilteringVisitorForSignatures(
+                        delegate = delegate,
+                        fileFormat = fileFormat,
+                        apiType = ApiType.PUBLIC_API,
+                        preFiltered = jarCodebase.preFiltered,
+                        showUnannotated = false,
+                        apiPredicateConfig =
+                            ApiPredicate.Config(
+                                addAdditionalOverrides = fileFormat.addAdditionalOverrides,
+                            ),
+                    )
+                }
+            )
+
+        val extendsInfo = surfaceInfo.extends
+        val outputCodebaseFragment =
+            if (extendsInfo == null) jarCodebaseFragment
+            else {
+                val signatureFiles = extendsInfo.contributingSignatureFiles()
+                val extendedCodebase = signatureFileLoader.load(signatureFiles)
+
+                SnapshotDeltaMaker.createDelta(
+                    base = extendedCodebase,
+                    codebaseFragment = jarCodebaseFragment,
+                )
+            }
+
+        createReportFile(progressTracker, outputCodebaseFragment, signatureFile, "API") {
+            printWriter ->
+            SignatureWriter(
+                writer = printWriter,
+                fileFormat = fileFormat,
+            )
+        }
+    }
+
+    private fun markDeprecated(codebase: Codebase, file: File, path: String) {
+        when {
+            file.name.endsWith(SdkConstants.DOT_JAR) ->
+                try {
+                    ZipFile(file).use { jar ->
+                        val enumeration = jar.entries()
+                        while (enumeration.hasMoreElements()) {
+                            val entry = enumeration.nextElement()
+                            if (entry.name.endsWith(SdkConstants.DOT_CLASS)) {
+                                try {
+                                    jar.getInputStream(entry).use { inputStream ->
+                                        val bytes = inputStream.readBytes()
+                                        markDeprecated(codebase, bytes, path + ":" + entry.name)
+                                    }
+                                } catch (e: Exception) {
+                                    stdout.println(
+                                        "Could not read jar file entry ${entry.name} from $file: $e"
+                                    )
+                                }
+                            }
+                        }
+                    }
+                } catch (e: IOException) {
+                    stdout.println("Could not read jar file contents from $file: $e")
+                }
+            file.isDirectory -> {
+                val listFiles = file.listFiles()
+                listFiles?.forEach { markDeprecated(codebase, it, it.path) }
+            }
+            file.path.endsWith(SdkConstants.DOT_CLASS) -> {
+                val bytes = file.readBytes()
+                markDeprecated(codebase, bytes, file.path)
+            }
+            else -> stdout.println("Ignoring entry $file")
+        }
+    }
+
+    private fun markDeprecated(codebase: Codebase, bytes: ByteArray, path: String) {
+        val reader: ClassReader
+        val classNode: ClassNode
+        try {
+            // TODO: We don't actually need to build a DOM.
+            reader = ClassReader(bytes)
+            classNode = ClassNode()
+            reader.accept(classNode, 0)
+        } catch (t: Throwable) {
+            stderr.println("Error processing $path: broken class file?")
+            return
+        }
+
+        if ((classNode.access and Opcodes.ACC_DEPRECATED) != 0) {
+            val item = codebase.findClass(classNode, MATCH_ALL)
+            item.deprecateIfRequired("byte code for ${classNode.name}")
+        }
+
+        val methodList = classNode.methods
+        for (f in methodList) {
+            val methodNode = f as MethodNode
+            if ((methodNode.access and Opcodes.ACC_DEPRECATED) == 0) {
+                continue
+            }
+            val item = codebase.findMethod(classNode, methodNode, MATCH_ALL)
+            item.deprecateIfRequired("byte code for ${methodNode.name}")
+        }
+
+        val fieldList = classNode.fields
+        for (f in fieldList) {
+            val fieldNode = f as FieldNode
+            if ((fieldNode.access and Opcodes.ACC_DEPRECATED) == 0) {
+                continue
+            }
+            val item = codebase.findField(classNode, fieldNode, MATCH_ALL)
+            item.deprecateIfRequired("byte code for ${fieldNode.name}")
+        }
+    }
+
+    /** Mark the [Item] as deprecated if required. */
+    private fun Item?.deprecateIfRequired(source: String) {
+        this ?: return
+        if (!originallyDeprecated) {
+            // Set the deprecated flag in the modifiers which underpins [originallyDeprecated].
+            mutateModifiers {
+                setDeprecated(true)
+                // Add a Deprecated annotation to be consistent with model providers.
+                addAnnotation(
+                    DefaultAnnotationItem.create(
+                        codebase,
+                        JAVA_LANG_DEPRECATED,
+                        emptyList(),
+                        context = this@deprecateIfRequired
+                    )
+                )
+            }
+            progressTracker.progress("Turned deprecation on for $this from $source")
+        }
+    }
+
+    companion object {
+        val MATCH_ALL: FilterPredicate = FilterPredicate { true }
+    }
+}
+
+/** Finds the given class by JVM owner */
+private fun Codebase.findClassByOwner(owner: String, apiFilter: FilterPredicate): ClassItem? {
+    val className = owner.replace('/', '.').replace('$', '.')
+    val cls = findClass(className)
+    return if (cls != null && apiFilter.test(cls)) {
+        cls
+    } else {
+        null
+    }
+}
+
+private fun Codebase.findClass(node: ClassNode, apiFilter: FilterPredicate): ClassItem? {
+    return findClassByOwner(node.name, apiFilter)
+}
+
+private fun Codebase.findMethod(
+    classNode: ClassNode,
+    node: MethodNode,
+    apiFilter: FilterPredicate
+): MethodItem? {
+    val cls = findClass(classNode, apiFilter) ?: return null
+    val types = Type.getArgumentTypes(node.desc)
+    val parameters =
+        if (types.isNotEmpty()) {
+            val sb = StringBuilder()
+            for (type in types) {
+                if (sb.isNotEmpty()) {
+                    sb.append(", ")
+                }
+                sb.append(type.className.replace('/', '.').replace('$', '.'))
+            }
+            sb.toString()
+        } else {
+            ""
+        }
+    val methodName = if (node.name == "<init>") cls.simpleName() else node.name
+    val method = cls.findMethod(methodName, parameters)
+    return if (method != null && apiFilter.test(method)) {
+        method
+    } else {
+        null
+    }
+}
+
+private fun Codebase.findField(
+    classNode: ClassNode,
+    node: FieldNode,
+    apiFilter: FilterPredicate
+): FieldItem? {
+    val cls = findClass(classNode, apiFilter) ?: return null
+    val field = cls.findField(node.name + 2)
+    return if (field != null && apiFilter.test(field)) {
+        field
+    } else {
+        null
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfo.kt b/metalava/src/main/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfo.kt
new file mode 100644
index 000000000..d2ba1876a
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfo.kt
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.historical
+
+import com.android.tools.metalava.apilevels.ApiVersion
+import com.android.tools.metalava.apilevels.MatchedPatternFile
+import com.android.tools.metalava.apilevels.PatternNode
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Reporter
+import java.io.File
+
+/**
+ * Encapsulates information relating to a historical API version.
+ *
+ * Includes all API files related to [version], and the set of [ApiSurface]s. The [infoBySurface]
+ * maps from [ApiSurface] to [SurfaceInfo].
+ */
+class HistoricalApiVersionInfo
+private constructor(
+    /** The [ApiVersion] to which this refers. */
+    val version: ApiVersion,
+    /** Information about each surface found for this version. */
+    val infoBySurface: Map<ApiSurface, SurfaceInfo>,
+) {
+    companion object {
+        /**
+         * Scan for historical API version information and create a list of
+         * [HistoricalApiVersionInfo] representing that.
+         *
+         * @param reporter for errors found.
+         * @param jarFilePattern the pattern for jar files, see [PatternNode.parsePatterns].
+         * @param signatureFilePattern the pattern for signature files, see
+         *   [PatternNode.parsePatterns].
+         * @param scanConfig see [PatternNode.scan].
+         */
+        internal fun scan(
+            reporter: Reporter,
+            jarFilePattern: String,
+            signatureFilePattern: String,
+            scanConfig: PatternNode.ScanConfig,
+        ): List<HistoricalApiVersionInfo> {
+            // Get all the matching jar and signature files.
+            val matchedPatternFiles =
+                scanForPattern(jarFilePattern, scanConfig) +
+                    scanForPattern(signatureFilePattern, scanConfig)
+
+            // Construct a list of HistoricalApiVersionInfo from them.
+            return fromMatchedPatternFiles(reporter, matchedPatternFiles)
+        }
+
+        /**
+         * Construct a [PatternNode] for [pattern] and then use that to scan for files with
+         * [scanConfig].
+         */
+        private fun scanForPattern(pattern: String, scanConfig: PatternNode.ScanConfig) =
+            PatternNode.parsePatterns(listOf(pattern)).scan(scanConfig)
+
+        /** Construct a list of [HistoricalApiVersionInfo]s from a list of [MatchedPatternFile]s. */
+        private fun fromMatchedPatternFiles(
+            reporter: Reporter,
+            matchedPatternFiles: List<MatchedPatternFile>,
+        ) =
+            // Group by versions.
+            matchedPatternFiles
+                .groupBy { it.version }
+                // Map to list of HistoricalApiVersionInfo
+                .mapNotNull { (version, versionFiles) ->
+                    fromVersionFiles(reporter, version, versionFiles)
+                }
+
+        /**
+         * Construct a [HistoricalApiVersionInfo] from [versionFiles] for [version].
+         *
+         * If an error is encountered which prevents it from being constructed then the error is
+         * reported to [reporter] and this returns `null`.
+         */
+        private fun fromVersionFiles(
+            reporter: Reporter,
+            version: ApiVersion,
+            versionFiles: List<MatchedPatternFile>,
+        ): HistoricalApiVersionInfo? {
+            val noSurface = versionFiles.filter { it.surface == null }
+            if (noSurface.isNotEmpty()) {
+                reporter.report(
+                    Issues.IO_ERROR,
+                    reportable = null,
+                    "All files must have a surface but found ${noSurface.size} files without:${
+                        noSurface.joinToString(
+                            "\n    ",
+                            prefix = "\n    "
+                        ) { it.file.path }
+                    }"
+                )
+                return null
+            }
+
+            val infoBySurface =
+                buildMap<ApiSurface, SurfaceInfo> {
+                    val bySurface = versionFiles.groupBy { it.surface!! }
+                    for ((surface, surfaceFiles) in bySurface) {
+                        fromSurfaceFiles(reporter, this, version, surface, surfaceFiles)
+                    }
+                }
+
+            return HistoricalApiVersionInfo(version, infoBySurface)
+        }
+
+        /**
+         * Construct a [SurfaceInfo] from [surfaceFiles] for [surface] in [version] and add it to
+         * [infoBySurface].
+         *
+         * If an error is encountered which prevents it from being constructed then the error is
+         * reported to [reporter] and this returns `null`.
+         */
+        private fun fromSurfaceFiles(
+            reporter: Reporter,
+            infoBySurface: MutableMap<ApiSurface, SurfaceInfo>,
+            version: ApiVersion,
+            surface: ApiSurface,
+            surfaceFiles: List<MatchedPatternFile>,
+        ) {
+            // Partition into jar files and other files which are assumed to be signature files.
+            val (jarFiles, signatureFiles) =
+                surfaceFiles.map { it.file }.partition { it.extension == ("jar") }
+
+            val jarFile =
+                singleFileIfPossible(jarFiles, reporter, version, surface, "jar") ?: return
+
+            val signatureFile =
+                singleFileIfPossible(signatureFiles, reporter, version, surface, "signature")
+                    ?: return
+
+            val extendsInfo = surface.extends?.let { infoBySurface[it] }
+
+            val info = SurfaceInfo(surface, jarFile, signatureFile, extendsInfo)
+            infoBySurface[surface] = info
+        }
+
+        /**
+         * Get a single file from [files].
+         *
+         * If [files] is empty then it is an error and this will return `null` as it has no [File]
+         * to return. If it has more than one [File] then it is also an error, but it returns the
+         * first [File] in the list. Otherwise, it just returns the first [File].
+         */
+        private fun singleFileIfPossible(
+            files: List<File>,
+            reporter: Reporter,
+            version: ApiVersion,
+            surface: ApiSurface,
+            label: String,
+        ): File? {
+            val count = files.size
+            if (count != 1) {
+                if (count == 0) {
+                    reporter.report(
+                        Issues.IO_ERROR,
+                        reportable = null,
+                        "Expected exactly one $label file per version per surface but did not find any, skipping version $version, surface $surface"
+                    )
+                    return null
+                } else {
+                    reporter.report(
+                        Issues.IO_ERROR,
+                        reportable = null,
+                        "Version $version: Expected exactly one $label file per version but found $count; using first:${
+                            files.joinToString(
+                                "\n    ",
+                                prefix = "\n    "
+                            )
+                        }"
+                    )
+                }
+            }
+
+            return files.first()
+        }
+    }
+}
+
+/** Information related to a specific surface. */
+class SurfaceInfo(
+    /** The [ApiSurface] to which this refers. */
+    val surface: ApiSurface,
+
+    /** The jar [File]. */
+    val jarFile: File,
+
+    /** The signature [File]. */
+    val signatureFile: File,
+
+    /**
+     * Optional [SurfaceInfo] that this extends.
+     *
+     * This refers to the [SurfaceInfo] corresponding to [surface]'s [ApiSurface.extends] property,
+     * if any.
+     */
+    val extends: SurfaceInfo?,
+) {
+    /**
+     * Get the [SignatureFile]s that contribute to this surface.
+     *
+     * In order, such that the file for an extending surface comes after the files for the extended
+     * surface.
+     */
+    fun contributingSignatureFiles(): List<SignatureFile> {
+        val files = buildList { addContributingSignatureFiles(this) }
+        return SignatureFile.fromFiles(files)
+    }
+
+    /**
+     * Add extended [SurfaceInfo]s files that contribute to this surface, if any, followed by this
+     * surfaces file.
+     */
+    private fun addContributingSignatureFiles(list: MutableList<File>) {
+        // Add any files for the extended surface, if any, first.
+        extends?.addContributingSignatureFiles(list)
+
+        // Then add the files for this surface.
+        list.add(signatureFile)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/historical/package-info.java b/metalava/src/main/java/com/android/tools/metalava/cli/historical/package-info.java
new file mode 100644
index 000000000..ef7f34937
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/historical/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Contains commands for managing the historical files in Android, i.e. in `prebuilts/sdk/{version}` and
+ * `prebuilts/sdk/extension/{version}`.
+ */
+package com.android.tools.metalava.cli.historical;
\ No newline at end of file
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommand.kt
index cf6112160..464a87f11 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommand.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.cli.internal
 
-import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.existingDir
 import com.android.tools.metalava.cli.common.newDir
 import com.github.ajalt.clikt.core.CliktCommand
@@ -53,9 +53,9 @@ class MakeAnnotationsPackagePrivateCommand :
         val rewrite = RewriteAnnotations()
         sourceDir.listFiles()?.forEach { file ->
             try {
-                rewrite.modifyAnnotationSources(null, file, File(targetDir, file.name))
+                rewrite.modifyAnnotationSources(file, File(targetDir, file.name))
             } catch (e: IllegalStateException) {
-                throw MetalavaCliException(e.message!!)
+                cliError(e.message!!)
             }
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
index f0f30da4e..b3d42254b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
@@ -21,8 +21,6 @@ import com.android.tools.metalava.ANDROID_SDK_CONSTANT
 import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.ANDROID_NONNULL
 import com.android.tools.metalava.model.ANDROID_NULLABLE
-import com.android.tools.metalava.model.AnnotationRetention
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.RECENTLY_NONNULL
 import com.android.tools.metalava.model.RECENTLY_NULLABLE
 import java.io.File
@@ -36,12 +34,12 @@ import kotlin.text.Charsets.UTF_8
  */
 internal class RewriteAnnotations {
     /** Modifies annotation source files such that they are package private */
-    fun modifyAnnotationSources(codebase: Codebase?, source: File, target: File, pkg: String = "") {
+    fun modifyAnnotationSources(source: File, target: File, pkg: String = "") {
         val fileName = source.name
         if (fileName.endsWith(SdkConstants.DOT_JAVA)) {
             // Only copy non-source retention annotation classes
             val qualifiedName = pkg + "." + fileName.substring(0, fileName.indexOf('.'))
-            if (hasSourceRetention(source, codebase, qualifiedName)) {
+            if (hasSourceRetention(source, qualifiedName)) {
                 return
             }
 
@@ -51,7 +49,7 @@ internal class RewriteAnnotations {
         } else if (source.isDirectory) {
             val newPackage = if (pkg.isEmpty()) fileName else "$pkg.$fileName"
             source.listFiles()?.forEach {
-                modifyAnnotationSources(codebase, it, File(target, it.name), newPackage)
+                modifyAnnotationSources(it, File(target, it.name), newPackage)
             }
         }
     }
@@ -60,11 +58,7 @@ internal class RewriteAnnotations {
      * Returns true if the given annotation class name has source retention as far as the stub
      * annotations are concerned.
      */
-    private fun hasSourceRetention(
-        source: File,
-        codebase: Codebase?,
-        qualifiedName: String
-    ): Boolean {
+    private fun hasSourceRetention(source: File, qualifiedName: String): Boolean {
         when {
             qualifiedName == RECENTLY_NULLABLE ||
                 qualifiedName == RECENTLY_NONNULL ||
@@ -75,13 +69,6 @@ internal class RewriteAnnotations {
             qualifiedName.startsWith("androidx.annotation.") -> return true
         }
 
-        // See if the annotation is pointing to an annotation class that is part of the API; if not,
-        // skip it.
-        if (codebase != null) {
-            val cls = codebase.findClass(qualifiedName) ?: return true
-            return cls.isAnnotationType() && cls.getRetention() == AnnotationRetention.SOURCE
-        } else {
-            error("$source: Found annotation with unknown desired retention: $qualifiedName")
-        }
+        error("$source: Found annotation with unknown desired retention: $qualifiedName")
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/lint/ApiLintOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/lint/ApiLintOptions.kt
index 77cfda069..4db1dfe54 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/lint/ApiLintOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/lint/ApiLintOptions.kt
@@ -36,6 +36,8 @@ const val ARG_ERROR_MESSAGE_API_LINT = "--error-message:api-lint"
 const val ARG_BASELINE_API_LINT = "--baseline:api-lint"
 const val ARG_UPDATE_BASELINE_API_LINT = "--update-baseline:api-lint"
 
+const val ARG_ALLOWED_ACRONYM = "--api-lint-allowed-acronym"
+
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val API_LINT_GROUP = "Api Lint"
 
@@ -111,6 +113,18 @@ class ApiLintOptions(
             .default(DefaultLintErrorMessage, defaultForHelp = "")
             .allowStructuredOptionName()
 
+    internal val allowedAcronyms: List<String> by
+        option(
+                ARG_ALLOWED_ACRONYM,
+                help =
+                    """
+                    An acronym that should be allowed by API lint. Can be specified multiple times.
+                    """
+                        .trimIndent(),
+                metavar = "<acronym>"
+            )
+            .multiple()
+
     private val baselineOptionsMixin =
         BaselineOptionsMixin(
             containingGroup = this,
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
index 96a91a984..ec5c2faac 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
@@ -17,17 +17,17 @@
 package com.android.tools.metalava.cli.signature
 
 import com.android.tools.metalava.OptionsDelegate
-import com.android.tools.metalava.SignatureWriter
-import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.cli.common.MetalavaSubCommand
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
-import com.android.tools.metalava.createFilteringVisitorForSignatures
 import com.android.tools.metalava.createReportFile
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.ApiParseException
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.text.SignatureWriter
+import com.android.tools.metalava.model.text.createFilteringVisitorForSignatures
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.github.ajalt.clikt.parameters.arguments.argument
@@ -103,7 +103,7 @@ class MergeSignaturesCommand :
                 )
             }
         } catch (e: ApiParseException) {
-            throw MetalavaCliException(stderr = e.message)
+            cliError(e.message)
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureCatCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureCatCommand.kt
new file mode 100644
index 000000000..a5bed1875
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureCatCommand.kt
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.signature
+
+import com.android.tools.metalava.OptionsDelegate
+import com.android.tools.metalava.cli.common.MetalavaSubCommand
+import com.android.tools.metalava.cli.common.existingFile
+import com.android.tools.metalava.cli.common.newOrExistingFile
+import com.android.tools.metalava.cli.common.stderr
+import com.android.tools.metalava.cli.common.stdin
+import com.android.tools.metalava.cli.common.stdout
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.text.ApiFile
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.text.SignatureWriter
+import com.android.tools.metalava.model.text.createFilteringVisitorForSignatures
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
+import com.android.tools.metalava.reporter.BasicReporter
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.arguments.multiple
+import com.github.ajalt.clikt.parameters.groups.provideDelegate
+import com.github.ajalt.clikt.parameters.options.option
+import java.io.PrintWriter
+
+class SignatureCatCommand :
+    MetalavaSubCommand(
+        help =
+            """
+                Cats signature files.
+
+                Reads signature files either provided on the command line, or in stdin into a
+                combined API surface and then writes it out to either the output file provided on
+                the command line or to stdout according to the format options. The resulting output
+                will be different to the input if the input does not already conform to the selected
+                format.
+            """
+                .trimIndent(),
+        printHelpOnEmptyArgs = false,
+    ) {
+
+    private val formatOptions by SignatureFormatOptions(migratingAllowed = true)
+
+    private val files by
+        argument(
+                name = "<files>",
+                help =
+                    """
+                        Signature files to read, if not specified then they stdin is read instead.
+                    """
+                        .trimIndent(),
+            )
+            .existingFile()
+            .multiple()
+
+    private val outputFile by
+        option(
+                names = arrayOf("--output-file"),
+                help =
+                    """
+                        File to write the signature output to. If not specified stdout will be used.
+                    """
+                        .trimIndent()
+            )
+            .newOrExistingFile()
+
+    override fun run() {
+        // Make sure that none of the code called by this command accesses the global `options`
+        // property.
+        OptionsDelegate.disallowAccess()
+
+        val outputFormat = formatOptions.fileFormat
+
+        val signatureFiles =
+            if (files.isEmpty()) {
+                // If no files are provided on the command line then read from stdin.
+                listOf(SignatureFile.fromStream("<stdin>", stdin))
+            } else {
+                SignatureFile.fromFiles(files)
+            }
+
+        val codebase = read(signatureFiles)
+        (outputFile?.printWriter() ?: stdout).use { outputWriter ->
+            write(codebase, outputFormat, outputWriter)
+        }
+    }
+
+    private fun read(signatureFiles: List<SignatureFile>) =
+        ApiFile.parseApi(
+            signatureFiles,
+            Codebase.Config(
+                annotationManager = noOpAnnotationManager,
+                reporter = BasicReporter(stderr),
+            ),
+        )
+
+    private fun write(codebase: Codebase, outputFormat: FileFormat, printWriter: PrintWriter) {
+        val signatureWriter =
+            SignatureWriter(
+                writer = printWriter,
+                fileFormat = outputFormat,
+            )
+
+        // Create a visitor suitable for writing signatures. It will ensure correct ordering for
+        // signature files for the outputFormat.
+        val apiWriter =
+            createFilteringVisitorForSignatures(
+                delegate = signatureWriter,
+                fileFormat = outputFormat,
+                apiType = ApiType.ALL,
+                preFiltered = true,
+                showUnannotated = true,
+                apiPredicateConfig = ApiPredicate.Config(),
+            )
+
+        codebase.accept(apiWriter)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureFormatOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureFormatOptions.kt
index 1a533976f..4f917fcbf 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureFormatOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureFormatOptions.kt
@@ -30,14 +30,15 @@ const val ARG_USE_SAME_FORMAT_AS = "--use-same-format-as"
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val SIGNATURE_FORMAT_OUTPUT_GROUP = "Signature Format Output"
 
-private val versionToFileFormat =
-    mapOf(
-        "v2" to FileFormat.V2,
-        "v3" to FileFormat.V3,
-        "v4" to FileFormat.V4,
-        "latest" to FileFormat.LATEST,
-        "recommended" to FileFormat.V2,
-    )
+private val versionToFileFormat = buildMap {
+    // For any FileFormat version that has a legacy command line alias add a mapping from that alias
+    // to the FileFormat defaults appropriate for that version.
+    FileFormat.Version.entries
+        .filter { it.legacyCommandLineAlias != null }
+        .associateByTo(this, { it.legacyCommandLineAlias!! }) { it.defaults }
+    put("latest", FileFormat.LATEST)
+    put("recommended", FileFormat.V2)
+}
 
 class SignatureFormatOptions(
     /** If true then the `migrating` property is allowed, otherwise it is not allowed at all. */
@@ -77,7 +78,7 @@ class SignatureFormatOptions(
     private val formatSpecifier by
         option(
                 ARG_FORMAT,
-                metavar = "[v2|v3|v4|latest|recommended|<specifier>]",
+                metavar = "[v2|v4|latest|recommended|<specifier>]",
                 help =
                     """
                         Specifies the output signature file format.
@@ -106,12 +107,11 @@ class SignatureFormatOptions(
 
                         v2 - The main version used in Android.
 
-                        v3 - Adds support for using kotlin style syntax to embed nullability
+                        v4 - Adds support for using kotlin style syntax to embed nullability
                         information instead of using explicit and verbose @NonNull and @Nullable
-                        annotations. This can be used for Java files and Kotlin files alike.
-
-                        v4 - Adds support for using concise default values in parameters. Instead
-                        of specifying the actual default values it just uses the `default` keyword.
+                        annotations. This can be used for Java files and Kotlin files alike. Also,
+                        adds support for recording that a parameter has a default value by using the
+                        pseudo-modifier `optional`.
                     """
                         .trimIndent(),
             )
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
index f8c8cb86d..81abb3cb6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
@@ -16,8 +16,6 @@
 
 package com.android.tools.metalava.cli.signature
 
-import com.android.tools.metalava.CodebaseComparator
-import com.android.tools.metalava.ComparisonVisitor
 import com.android.tools.metalava.JDiffXmlWriter
 import com.android.tools.metalava.OptionsDelegate
 import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
@@ -25,26 +23,22 @@ import com.android.tools.metalava.cli.common.MetalavaSubCommand
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
+import com.android.tools.metalava.cli.common.stderr
+import com.android.tools.metalava.createFilteringVisitorForJDiffWriter
 import com.android.tools.metalava.createReportFile
-import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.text.TextCodebaseBuilder
+import com.android.tools.metalava.model.text.SnapshotDeltaMaker
 import com.android.tools.metalava.model.visitors.ApiFilters
-import com.android.tools.metalava.model.visitors.ApiPredicate
-import com.android.tools.metalava.model.visitors.ApiType
+import com.android.tools.metalava.reporter.BasicReporter
 import com.github.ajalt.clikt.parameters.arguments.argument
 import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.flag
 import com.github.ajalt.clikt.parameters.options.option
-import java.io.File
 
 class SignatureToJDiffCommand :
     MetalavaSubCommand(
@@ -135,6 +129,7 @@ class SignatureToJDiffCommand :
         val codebaseConfig =
             Codebase.Config(
                 annotationManager = annotationManager,
+                reporter = BasicReporter(stderr),
             )
         val signatureFileLoader =
             DefaultSignatureFileLoader(
@@ -144,103 +139,42 @@ class SignatureToJDiffCommand :
 
         val signatureApi = signatureFileLoader.load(SignatureFile.fromFiles(apiFile))
 
-        val apiPredicateConfig = ApiPredicate.Config()
-        val apiType = ApiType.ALL
-        val apiEmit = apiType.getEmitFilter(apiPredicateConfig)
         val strip = strip
-        val apiReference =
-            if (strip) apiType.getEmitFilter(apiPredicateConfig)
-            else apiType.getReferenceFilter(apiPredicateConfig)
+        val apiEmit = FilterPredicate { it.emit }
+        val apiReference = if (strip) apiEmit else FilterPredicate { true }
         val apiFilters = ApiFilters(emit = apiEmit, reference = apiReference)
         val baseFile = baseApiFile
 
-        val outputApi =
+        val signatureFragment =
+            CodebaseFragment.create(signatureApi) { delegate ->
+                createFilteringVisitorForJDiffWriter(
+                    delegate,
+                    apiFilters = apiFilters,
+                    preFiltered = signatureApi.preFiltered && !strip,
+                    showUnannotated = false,
+                    // Historically, the super class type has not been filtered when generating
+                    // JDiff files, so do not filter here even though it could result in undefined
+                    // types being included in the JDiff file.
+                    filterSuperClassType = false,
+                )
+            }
+
+        val outputFragment =
             if (baseFile != null) {
                 // Convert base on a diff
                 val baseApi = signatureFileLoader.load(SignatureFile.fromFiles(baseFile))
-                computeDelta(baseFile, baseApi, signatureApi, apiPredicateConfig)
+                SnapshotDeltaMaker.createDelta(baseApi, signatureFragment)
             } else {
-                signatureApi
+                signatureFragment
             }
 
         // See JDiff's XMLToAPI#nameAPI
         val apiName = xmlFile.nameWithoutExtension.replace(' ', '_')
-        createReportFile(progressTracker, outputApi, xmlFile, "JDiff File") { printWriter ->
+        createReportFile(progressTracker, outputFragment, xmlFile, "JDiff File") { printWriter ->
             JDiffXmlWriter(
-                    writer = printWriter,
-                    apiName = apiName,
-                )
-                .createFilteringVisitor(
-                    apiFilters = apiFilters,
-                    preFiltered = signatureApi.preFiltered && !strip,
-                    showUnannotated = false,
-                    // Historically, the super class type has not been filtered.
-                    filterSuperClassType = false,
-                )
-        }
-    }
-}
-
-/**
- * Create a text [Codebase] that is a delta between [baseApi] and [signatureApi], i.e. it includes
- * all the [Item] that are in [signatureApi] but not in [baseApi].
- *
- * This is expected to be used where [signatureApi] is a super set of [baseApi] but that is not
- * enforced. If [baseApi] contains [Item]s which are not present in [signatureApi] then they will
- * not appear in the delta.
- *
- * [ClassItem]s are treated specially. If [signatureApi] and [baseApi] have [ClassItem]s with the
- * same name and [signatureApi]'s has members which are not present in [baseApi]'s then a
- * [ClassItem] containing the additional [signatureApi] members will appear in the delta, otherwise
- * it will not.
- *
- * @param baseFile the [Codebase.location] used for the resulting delta.
- * @param baseApi the base [Codebase] whose [Item]s will not appear in the delta.
- * @param signatureApi the extending [Codebase] whose [Item]s will appear in the delta as long as
- *   they are not part of [baseApi].
- */
-private fun computeDelta(
-    baseFile: File,
-    baseApi: Codebase,
-    signatureApi: Codebase,
-    apiPredicateConfig: ApiPredicate.Config,
-): Codebase {
-    // Compute just the delta
-    return TextCodebaseBuilder.build(
-        location = baseFile,
-        description = "Delta between $baseApi and $signatureApi",
-        codebaseConfig = signatureApi.config,
-    ) {
-        CodebaseComparator()
-            .compare(
-                object : ComparisonVisitor() {
-                    override fun addedPackageItem(new: PackageItem) {
-                        addPackage(new)
-                    }
-
-                    override fun addedClassItem(new: ClassItem) {
-                        addClass(new)
-                    }
-
-                    override fun addedConstructorItem(new: ConstructorItem) {
-                        addConstructor(new)
-                    }
-
-                    override fun addedMethodItem(new: MethodItem) {
-                        addMethod(new)
-                    }
-
-                    override fun addedFieldItem(new: FieldItem) {
-                        addField(new)
-                    }
-
-                    override fun addedPropertyItem(new: PropertyItem) {
-                        addProperty(new)
-                    }
-                },
-                baseApi,
-                signatureApi,
-                ApiType.ALL.getReferenceFilter(apiPredicateConfig)
+                writer = printWriter,
+                apiName = apiName,
             )
+        }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
index 22e4ec226..c8f62ff04 100644
--- a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
@@ -19,7 +19,7 @@ package com.android.tools.metalava.compatibility
 import com.android.tools.metalava.CodebaseComparator
 import com.android.tools.metalava.ComparisonVisitor
 import com.android.tools.metalava.JVM_DEFAULT_WITH_COMPATIBILITY
-import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.ANDROID_TEST_API
 import com.android.tools.metalava.model.ArrayTypeItem
@@ -562,9 +562,9 @@ class CompatibilityCheck(
         if (
             new.containingClass().isAnnotationType() &&
                 old.containingClass().isAnnotationType() &&
-                new.defaultValue() != old.defaultValue()
+                new.legacyDefaultValue() != old.legacyDefaultValue()
         ) {
-            val prevValue = old.defaultValue()
+            val prevValue = old.legacyDefaultValue()
             val prevString =
                 if (prevValue.isEmpty()) {
                     "nothing"
@@ -572,7 +572,7 @@ class CompatibilityCheck(
                     prevValue
                 }
 
-            val newValue = new.defaultValue()
+            val newValue = new.legacyDefaultValue()
             val newString =
                 if (newValue.isEmpty()) {
                     "nothing"
@@ -587,7 +587,7 @@ class CompatibilityCheck(
 
             // Adding a default value to an annotation method is safe
             val annotationMethodAddingDefaultValue =
-                new.containingClass().isAnnotationType() && old.defaultValue().isEmpty()
+                new.containingClass().isAnnotationType() && old.legacyDefaultValue().isEmpty()
 
             if (!annotationMethodAddingDefaultValue) {
                 report(Issues.CHANGED_VALUE, new, message)
@@ -726,7 +726,7 @@ class CompatibilityCheck(
                     "${describe(new, capitalize = true)} has changed type from $oldType to $newType"
                 report(Issues.CHANGED_TYPE, new, message)
             } else if (!old.hasSameValue(new)) {
-                val prevValue = old.initialValue()
+                val prevValue = old.legacyInitialValue()
                 val prevString =
                     if (prevValue == null && !old.modifiers.isFinal()) {
                         "nothing/not constant"
@@ -734,7 +734,7 @@ class CompatibilityCheck(
                         prevValue
                     }
 
-                val newValue = new.initialValue()
+                val newValue = new.legacyInitialValue()
                 val newString =
                     if (newValue is PsiField) {
                         newValue.containingClass?.qualifiedName + "." + newValue.name
@@ -788,7 +788,7 @@ class CompatibilityCheck(
             oldModifiers.isFinal() &&
                 !newModifiers.isFinal() &&
                 oldModifiers.isStatic() &&
-                old.initialValue() != null
+                old.legacyInitialValue() != null
         ) {
             report(
                 Issues.REMOVED_FINAL,
@@ -892,7 +892,7 @@ class CompatibilityCheck(
             // two interfaces that each now define methods with the same signature.
             // Annotation types cannot implement other interfaces, however, so it is permitted to
             // add new default methods to annotation types.
-            if (new.containingClass().isAnnotationType() && new.hasDefaultValue()) {
+            if (new.containingClass().isAnnotationType() && new.legacyDefaultValue() != "") {
                 return
             }
         }
@@ -1081,7 +1081,7 @@ class CompatibilityCheck(
                     "the ${apiType.displayName} API (${newCodebase.location}) against the API in ${oldCodebase.location}"
 
             if (checker.foundProblems) {
-                throw MetalavaCliException(exitCode = -1, stderr = message)
+                cliError(message)
             }
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/ApiFlagsConfig.kt b/metalava/src/main/java/com/android/tools/metalava/config/ApiFlagsConfig.kt
new file mode 100644
index 000000000..8e354b119
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/config/ApiFlagsConfig.kt
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.fasterxml.jackson.annotation.JsonValue
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty
+
+data class ApiFlagsConfig(
+    @field:JacksonXmlProperty(localName = "api-flag", namespace = CONFIG_NAMESPACE)
+    val flags: List<ApiFlagConfig> = emptyList(),
+) : CombinableConfig<ApiFlagsConfig> {
+
+    /** Combine with another [ApiFlagsConfig] by concatenating the [flags]s. */
+    override fun combineWith(other: ApiFlagsConfig) = ApiFlagsConfig(flags + other.flags)
+
+    /** Validate this object, i.e. check to make sure that the contained objects are consistent. */
+    fun validate() {}
+}
+
+data class ApiFlagConfig(
+    /** The flag package name. */
+    @field:JacksonXmlProperty(isAttribute = true, localName = "package") val pkg: String,
+
+    /** The flag name, within [pkg]. */
+    @field:JacksonXmlProperty(isAttribute = true) val name: String,
+
+    /**
+     * Whether the flag can be mutated during the lifetime of the platform for which the API is
+     * being built.
+     */
+    @field:JacksonXmlProperty(isAttribute = true) val mutability: Mutability,
+
+    /**
+     * The status of the flag.
+     *
+     * If the flag is [Mutability.MUTABLE] then this could change over the lifetime of the platform
+     * for which the API is being built.
+     */
+    @field:JacksonXmlProperty(isAttribute = true) val status: Status,
+) {
+    enum class Mutability {
+        MUTABLE,
+        IMMUTABLE,
+        ;
+
+        /** Name to use when serializing and deserializing this [Mutability] instance. */
+        @JsonValue fun forJackson() = name.lowercase()
+    }
+
+    enum class Status {
+        ENABLED,
+        DISABLED,
+        ;
+
+        /** Name to use when serializing and deserializing this [Status] instance. */
+        @JsonValue fun forJackson() = name.lowercase()
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/ApiSurfacesConfig.kt b/metalava/src/main/java/com/android/tools/metalava/config/ApiSurfacesConfig.kt
new file mode 100644
index 000000000..df9f8c2de
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/config/ApiSurfacesConfig.kt
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.fasterxml.jackson.annotation.JsonIgnore
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty
+
+// Neither Kotlin nor Java has an interface for an ordered collection of unique elements, i.e. an
+// ordered set. However, the standard Kotlin [Set] and [MutableSet] as returned by [setOf],
+// [buildSet], [mutableSetOf], as well as various `.toSet()` methods all return an implementation
+// that does maintain order, e.g. [LinkedHashSet].
+//
+// See https://discuss.kotlinlang.org/t/ordered-sets/5420.
+
+/**
+ * A [Set] that should be used when order is important.
+ *
+ * As [Set] does not provide any order guarantees use of this must be tested to ensure that
+ * iteration order is maintained.
+ */
+typealias OrderedSet<E> = Set<E>
+
+/**
+ * A [MutableSet] that should be used when order is important.
+ *
+ * As [MutableSet] does not provide any order guarantees use of this must be tested to ensure that
+ * iteration order is maintained.
+ */
+typealias MutableOrderedSet<E> = MutableSet<E>
+
+/** A set of [ApiSurfaceConfig]s. */
+data class ApiSurfacesConfig(
+    @field:JacksonXmlProperty(localName = "api-surface", namespace = CONFIG_NAMESPACE)
+    val apiSurfaceList: List<ApiSurfaceConfig> = emptyList(),
+) : CombinableConfig<ApiSurfacesConfig> {
+
+    /** Combine with another [ApiSurfacesConfig] by concatenating the [apiSurfaceList]s. */
+    override fun combineWith(other: ApiSurfacesConfig) =
+        ApiSurfacesConfig(apiSurfaceList + other.apiSurfaceList)
+
+    /**
+     * Map of [ApiSurfaceConfig]s by [ApiSurfaceConfig.name].
+     *
+     * Groups them by name, throws an exception if there are two surfaces with the same name.
+     */
+    @get:JsonIgnore
+    val byName by
+        lazy(LazyThreadSafetyMode.NONE) {
+            apiSurfaceList
+                .groupingBy { it.name }
+                .reduce { name, surface1, surface2 ->
+                    error("Found duplicate surfaces called `$name`")
+                }
+        }
+
+    /**
+     * Get the [ApiSurfaceConfig] by [name].
+     *
+     * If no such config exists then raise an error include [reason].
+     */
+    inline fun getByNameOrError(name: String, reason: (String) -> String) =
+        byName[name]
+            ?: error("${reason(name)}, expected one of ${byName.keys.joinToString {"`$it`"}}")
+
+    /**
+     * Ordered set of [ApiSurfaceConfig]s that maintains the order from the configuration except
+     * that an [ApiSurfaceConfig] that extends another [ApiSurfaceConfig] always comes after the one
+     * it extends.
+     */
+    @get:JsonIgnore
+    internal val orderedSurfaces: OrderedSet<ApiSurfaceConfig> by
+        lazy(LazyThreadSafetyMode.NONE) {
+            buildSet {
+                for (apiSurfaceConfig in apiSurfaceList) {
+                    apiSurfaceConfig.flatten(this, mutableSetOf())
+                }
+            }
+        }
+
+    /**
+     * Get the ordered set of [ApiSurfaceConfig]s that contribute to the [targetSurface].
+     *
+     * A surface that contributes to [targetSurface] is one which is extended (possibly indirectly)
+     * by [targetSurface] or [targetSurface] itself.
+     */
+    fun contributesTo(targetSurface: ApiSurfaceConfig): Set<ApiSurfaceConfig> {
+        return buildSet { targetSurface.flatten(this, mutableSetOf()) }
+    }
+
+    /**
+     * Flatten the [ApiSurfaceConfig.extends] hierarchy of this [ApiSurfaceConfig], if any.
+     *
+     * If this has a non-null [ApiSurfaceConfig.extends] then this will be called on the
+     * [ApiSurfaceConfig] it references and then this will be added to [flattened].
+     *
+     * @param flattened the ordered set of [ApiSurfaceConfig]s, such that each [ApiSurfaceConfig]
+     *   appears after any [ApiSurfaceConfig] that it [ApiSurfaceConfig.extends]. Any
+     *   [ApiSurfaceConfig] in this list is guaranteed not to be part of a cycle as it will only
+     *   have been added after checking for cycles.
+     * @param visited the ordered set of names of [ApiSurfaceConfig] that have already been visited
+     *   while flattening an [ApiSurfaceConfig] that extends (possibly indirectly) this one. Used to
+     *   detect cycles.
+     */
+    private fun ApiSurfaceConfig.flatten(
+        flattened: MutableOrderedSet<ApiSurfaceConfig>,
+        visited: MutableSet<String>
+    ) {
+        // If this has already been added then it is not part of a cycle as it will only have been
+        // added after checking for cycles so there is nothing to do.
+        if (this in flattened) return
+
+        // If this has already been visited while visiting a surface that extends (possibly
+        // indirectly) this one then there is a cycle in the graph.
+        if (name in visited) {
+            error(
+                "Cycle detected in extends relationship: ${visited.joinToString(" -> ") {"`$it`"}} -> `$name`."
+            )
+        }
+
+        // Remember this has been visited before visiting a surface this extends.
+        visited += name
+
+        // If this extends another surface then resolve it and flatten it first.
+        if (extends != null) {
+            val extendedSurface =
+                getByNameOrError(extends) {
+                    // This should not occur outside tests as the schema should ensure that
+                    // `extends` always references an actual surface but throw a meaningful error
+                    // anyway, just in case.
+                    "Surface `$name` extends an unknown surface `$it`"
+                }
+            extendedSurface.flatten(flattened, visited)
+        }
+
+        // Finally, add this to the set. At this point it is guaranteed not to be part of a cycle
+        // as that will have been detected above.
+        flattened += this
+    }
+
+    /** Validate this object, i.e. check to make sure that the contained objects are consistent. */
+    fun validate() {
+        // Force check for duplicates.
+        byName
+
+        // Force check for cycles.
+        orderedSurfaces
+    }
+}
+
+/** An API surface that Metalava could generate. */
+data class ApiSurfaceConfig(
+    /** The name of the API surface, e.g. `public`, `restricted`, etc. */
+    @field:JacksonXmlProperty(isAttribute = true) val name: String,
+
+    /** The optional name of the API surface that this surface extends, e.g. `public`. */
+    @field:JacksonXmlProperty(isAttribute = true) val extends: String? = null,
+)
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/Config.kt b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
index 16c7e85df..61e3cd81d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
@@ -16,5 +16,45 @@
 
 package com.android.tools.metalava.config
 
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement
+
 /** The top level configuration object. */
-class Config
+@JacksonXmlRootElement(localName = "config", namespace = CONFIG_NAMESPACE)
+// Ignore the xsi:schemaLocation property if present on the root <config> element.
+@JsonIgnoreProperties("schemaLocation")
+data class Config(
+    @field:JacksonXmlProperty(localName = "api-flags", namespace = CONFIG_NAMESPACE)
+    val apiFlags: ApiFlagsConfig? = null,
+    @field:JacksonXmlProperty(localName = "api-surfaces", namespace = CONFIG_NAMESPACE)
+    val apiSurfaces: ApiSurfacesConfig? = null,
+) : CombinableConfig<Config> {
+
+    /** Combine this [Config] with another returning a [Config] object that combines them both. */
+    override fun combineWith(other: Config): Config =
+        Config(
+            apiFlags = combine(apiFlags, other.apiFlags),
+            apiSurfaces = combine(apiSurfaces, other.apiSurfaces),
+        )
+
+    /**
+     * Combined two possibly nullable objects, if either are null then return the other, otherwise
+     * invoke [CombinableConfig.combineWith].
+     */
+    internal fun <T : CombinableConfig<T>> combine(t1: T?, t2: T?): T? {
+        return if (t1 == null) t2 else if (t2 == null) t1 else t1.combineWith(t2)
+    }
+
+    /** Validate this object, i.e. check to make sure that the contained objects are consistent. */
+    internal fun validate() {
+        apiFlags?.validate()
+        apiSurfaces?.validate()
+    }
+}
+
+/** Implemented by config objects that can be combined when loaded in separate files. */
+interface CombinableConfig<T : CombinableConfig<T>> {
+    /** Combine this with [other] returning a new instance. */
+    fun combineWith(other: T): T
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
index 66076d422..a83315528 100644
--- a/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
@@ -16,51 +16,57 @@
 
 package com.android.tools.metalava.config
 
-import com.android.tools.metalava.reporter.FileLocation
-import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reporter
-import com.android.tools.metalava.reporter.Severity
+import com.fasterxml.jackson.annotation.JsonInclude
+import com.fasterxml.jackson.databind.SerializationFeature
+import com.fasterxml.jackson.dataformat.xml.XmlMapper
+import com.fasterxml.jackson.module.kotlin.kotlinModule
 import java.io.File
-import java.net.URI
-import java.nio.file.Paths
 import javax.xml.XMLConstants
 import javax.xml.parsers.SAXParserFactory
 import javax.xml.validation.SchemaFactory
 import org.xml.sax.SAXParseException
 import org.xml.sax.helpers.DefaultHandler
 
+const val CONFIG_NAMESPACE = "http://www.google.com/tools/metalava/config"
+
 /** Parser for XML configuration files. */
-class ConfigParser(private val reporter: Reporter) : DefaultHandler() {
+class ConfigParser private constructor() : DefaultHandler() {
+    /** Errors that were reported while parsing a configuration file. */
+    private val errors = StringBuilder()
 
-    private fun reportParseException(exception: SAXParseException, severity: Severity) {
-        val systemIdAsURI = URI.create(exception.systemId)
-        val location = FileLocation.createLocation(Paths.get(systemIdAsURI), exception.lineNumber)
-        reporter.report(
-            Issues.CONFIG_FILE_PROBLEM,
-            null,
-            "Problem parsing configuration file: ${exception.message}",
-            location,
-            // The issue has a severity of ERROR, this limits it to whatever is required by the
-            // caller.
-            maximumSeverity = severity,
-        )
+    private fun recordException(path: String, message: String) {
+        errors.apply {
+            append("    ")
+            append(path)
+            append(": ")
+            append(message)
+            append("\n")
+        }
     }
 
-    override fun warning(exception: SAXParseException) {
-        reportParseException(exception, Severity.WARNING_ERROR_WHEN_NEW)
+    private fun recordParseException(exception: SAXParseException) {
+        errors.apply {
+            append("    ")
+            append(exception.systemId)
+            append(":")
+            append(exception.lineNumber)
+            append(": ")
+            append(exception.message)
+            append("\n")
+        }
     }
 
-    override fun error(exception: SAXParseException) {
-        reportParseException(exception, Severity.ERROR)
+    override fun warning(exception: SAXParseException) {
+        recordParseException(exception)
     }
 
-    override fun fatalError(exception: SAXParseException) {
-        reportParseException(exception, Severity.ERROR)
+    override fun error(exception: SAXParseException) {
+        recordParseException(exception)
     }
 
     companion object {
         /** Parse a list of configuration files in order, returning a single [Config] object. */
-        fun parse(reporter: Reporter, files: List<File>): Config {
+        fun parse(files: List<File>): Config {
             val schemaUrl = ConfigParser::class.java.getResource("/schemas/config.xsd")
             val schemafactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
             val schema = schemafactory.newSchema(schemaUrl)
@@ -68,11 +74,61 @@ class ConfigParser(private val reporter: Reporter) : DefaultHandler() {
             val saxParserFactory = SAXParserFactory.newNSInstance()
             saxParserFactory.schema = schema
             val saxParser = saxParserFactory.newSAXParser()
-            val configParser = ConfigParser(reporter)
+            val configParser = ConfigParser()
+            val xmlMapper = configXmlMapper()
+
+            // Parse all the configuration files, validating against the schema, collating any
+            // errors that are reported.
             for (file in files) {
-                saxParser.parse(file, configParser)
+                // Parse the configuration file to validate against the schema first.
+                try {
+                    saxParser.parse(file, configParser)
+                } catch (e: SAXParseException) {
+                    configParser.recordParseException(e)
+                } catch (e: Exception) {
+                    configParser.recordException(file.path, e.message ?: "")
+                }
+            }
+
+            // If any errors were reported then fail as it is unlikely that reading or using the
+            // configuration file will work.
+            if (configParser.errors.isNotEmpty()) {
+                error("Errors found while parsing configuration file(s):\n${configParser.errors}")
             }
-            return Config()
+
+            return files
+                .map { file ->
+                    // Read the configuration file into a Config object.
+                    xmlMapper.readValue(file, Config::class.java)
+                }
+                // Merge the config objects together.
+                .reduceOrNull(Config::combineWith)
+                // Validate the config.
+                ?.apply { validate() }
+            // If no configuration files were created then return an empty Config.
+            ?: Config()
+        }
+
+        /**
+         * Get an [XmlMapper] that can be used to serialize and deserialize [Config] objects.
+         *
+         * While serializing a [Config] object is not something that is used by Metalava it is
+         * helpful to be able to do that for debugging and also for development. e.g. it is easy to
+         * work out what the [XmlMapper] can read by simply seeing what it writes out as it
+         * generally supports reading what it writes. Tweaking it to match what is defined in the
+         * schema just requires adding the correct annotations to the object.
+         */
+        internal fun configXmlMapper(): XmlMapper {
+            return XmlMapper.builder()
+                // Do not add extra wrapper elements around collections.
+                .defaultUseWrapper(false)
+                // Pretty print, indenting each level by 2 spaces.
+                .enable(SerializationFeature.INDENT_OUTPUT)
+                // Exclude any `null` values from being serialized.
+                .serializationInclusion(JsonInclude.Include.NON_NULL)
+                // Add support for using Kotlin data classes.
+                .addModule(kotlinModule())
+                .build()
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
index e4737a93f..cd149b942 100644
--- a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
@@ -23,6 +23,7 @@ import com.android.tools.lint.detector.api.editDistance
 import com.android.tools.metalava.PROGRAM_NAME
 import com.android.tools.metalava.SdkExtension
 import com.android.tools.metalava.apilevels.ApiToExtensionsMap.Companion.ANDROID_PLATFORM_SDK_ID
+import com.android.tools.metalava.apilevels.ApiVersion
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
@@ -51,7 +52,6 @@ import java.io.File
 import java.nio.file.Files
 import java.util.regex.Pattern
 import javax.xml.parsers.SAXParserFactory
-import kotlin.math.min
 import org.xml.sax.Attributes
 import org.xml.sax.helpers.DefaultHandler
 
@@ -59,21 +59,21 @@ private const val DEFAULT_ENFORCEMENT = "android.content.pm.PackageManager#hasSy
 
 private const val CARRIER_PRIVILEGES_MARKER = "carrier privileges"
 
-/** Lambda that when given an API level will return a string label for it. */
-typealias ApiLevelLabelProvider = (Int) -> String
+/** Lambda that when given an [ApiVersion] will return a string label for it. */
+typealias ApiVersionLabelProvider = (ApiVersion) -> String
 
 /**
- * Lambda that when given an API level will return `true` if it can be referenced from within the
+ * Lambda that when given an [ApiVersion] will return `true` if it can be referenced from within the
  * documentation and `false` if it cannot.
  */
-typealias ApiLevelFilter = (Int) -> Boolean
+typealias ApiVersionFilter = (ApiVersion) -> Boolean
 
 /**
  * Walk over the API and apply tweaks to the documentation, such as
  * - Looking for annotations and converting them to auxiliary tags that will be processed by the
  *   documentation tools later.
- * - Reading lint's API database and inserting metadata into the documentation like api levels and
- *   deprecation levels.
+ * - Reading lint's API database and inserting metadata into the documentation like api versions and
+ *   deprecation versions.
  * - Transferring docs from hidden super methods.
  * - Performing tweaks for common documentation mistakes, such as ending the first sentence with ",
  *   e.g. " where javadoc will sadly see the ". " and think "aha, that's the end of the sentence!"
@@ -85,11 +85,11 @@ class DocAnalyzer(
     private val codebase: Codebase,
     private val reporter: Reporter,
 
-    /** Provides a string label for each API level. */
-    private val apiLevelLabelProvider: ApiLevelLabelProvider,
+    /** Provides a string label for each [ApiVersion]. */
+    private val apiVersionLabelProvider: ApiVersionLabelProvider,
 
-    /** Filter that determines whether an API level should be mentioned in the documentation. */
-    private val apiLevelFilter: ApiLevelFilter,
+    /** Filter that determines whether an [ApiVersion] should be mentioned in the documentation. */
+    private val apiVersionFilter: ApiVersionFilter,
 
     /** Selects [Item]s whose documentation will be analyzed and/or enhanced. */
     private val apiPredicateConfig: ApiPredicate.Config,
@@ -177,7 +177,9 @@ class DocAnalyzer(
                     val permClass = codebase.findClass("android.Manifest.permission")
                     permClass
                         ?.fields()
-                        ?.filter { it.initialValue(requireConstant = false)?.toString() == perm }
+                        ?.filter {
+                            it.legacyInitialValue(requireConstant = false)?.toString() == perm
+                        }
                         ?.forEach {
                             return it
                         }
@@ -223,11 +225,13 @@ class DocAnalyzer(
                             if (item is SelectableItem) handleRequiresApi(annotation, item)
                         "android.provider.Column" -> handleColumn(annotation, item)
                         "kotlin.Deprecated" -> handleKotlinDeprecation(annotation, item)
+                        "androidx.annotation.RestrictedForEnvironment" ->
+                            handleRestrictedForEnvironment(annotation, item)
                     }
 
                     visitedClasses.add(name)
                     // Thread annotations are ignored here because they're handled as a group
-                    // afterwards
+                    // afterward.
 
                     // TODO: Resource type annotations
 
@@ -248,7 +252,7 @@ class DocAnalyzer(
                     val text =
                         (annotation.findAttribute("message")
                                 ?: annotation.findAttribute(ANNOTATION_ATTR_VALUE))
-                            ?.value
+                            ?.legacyValue
                             ?.value()
                             ?.toString()
                             ?: return
@@ -324,7 +328,7 @@ class DocAnalyzer(
                                 values = attribute.leafValues()
                             }
                             "conditional" -> {
-                                conditional = attribute.value.value() == true
+                                conditional = attribute.legacyValue.value() == true
                             }
                         }
                     }
@@ -396,8 +400,8 @@ class DocAnalyzer(
                 }
 
                 private fun handleRange(annotation: AnnotationItem, item: Item) {
-                    val from: String? = annotation.findAttribute("from")?.value?.toSource()
-                    val to: String? = annotation.findAttribute("to")?.value?.toSource()
+                    val from: String? = annotation.findAttribute("from")?.legacyValue?.toSource()
+                    val to: String? = annotation.findAttribute("to")?.legacyValue?.toSource()
                     // TODO: inclusive/exclusive attributes on FloatRange!
                     if (from != null || to != null) {
                         val args = HashMap<String, String>()
@@ -418,7 +422,7 @@ class DocAnalyzer(
 
                 private fun handleTypeDef(annotation: AnnotationItem, item: Item) {
                     val values = annotation.findAttribute("value")?.leafValues() ?: return
-                    val flag = annotation.findAttribute("flag")?.value?.toSource() == "true"
+                    val flag = annotation.findAttribute("flag")?.legacyValue?.toSource() == "true"
 
                     // Look at macros_override.cs for the usage of these
                     // tags. In particular, search for def:dump_int_def
@@ -548,8 +552,42 @@ class DocAnalyzer(
                     }
 
                     if (level is Int) {
-                        addApiLevelDocumentation(level, item)
+                        addApiVersionDocumentation(ApiVersion.fromLevel(level), item)
+                    }
+                }
+
+                private fun handleRestrictedForEnvironment(
+                    annotationItem: AnnotationItem,
+                    item: Item
+                ) {
+                    val environmentsValue: String? =
+                        annotationItem.findAttribute("environments")?.legacyValue?.toSource()
+                    val fromValue: String? =
+                        annotationItem.findAttribute("from")?.legacyValue?.toSource()
+
+                    if (environmentsValue == null || !environmentsValue.endsWith("SDK_SANDBOX")) {
+                        reporter.report(
+                            Issues.INVALID_ENVIRONMENT_IN_RESTRICTED_FOR_ENVIRONMENT,
+                            item,
+                            "Invalid 'environments' value '$environmentsValue', must be 'SDK_SANDBOX'"
+                        )
+                        return
                     }
+
+                    if (fromValue == null) {
+                        reporter.report(
+                            Issues.MISSING_FROM_VALUE,
+                            item,
+                            "Missing 'from' value for @RestrictedForEnvironment annotation"
+                        )
+                        return
+                    }
+
+                    appendDocumentation(
+                        "Restricted for SDK Runtime environment in API level $fromValue.\n",
+                        item,
+                        false
+                    )
                 }
 
                 private fun handleColumn(annotation: AnnotationItem, item: Item) {
@@ -719,15 +757,15 @@ class DocAnalyzer(
         )
     }
 
-    fun applyApiLevels(applyApiLevelsXml: File) {
+    fun applyApiVersions(apiVersionsFile: File) {
         val apiLookup =
             getApiLookup(
-                xmlFile = applyApiLevelsXml,
+                xmlFile = apiVersionsFile,
                 underTest = executionEnvironment.isUnderTest(),
             )
-        val elementToSdkExtSinceMap = createSymbolToSdkExtSinceMap(applyApiLevelsXml)
+        val elementToSdkExtSinceMap = createSymbolToSdkExtSinceMap(apiVersionsFile)
 
-        val pkgApi = HashMap<PackageItem, Int?>(300)
+        val packageToVersion = HashMap<PackageItem, ApiVersion>(300)
         codebase.accept(
             object :
                 ApiVisitor(
@@ -743,7 +781,7 @@ class DocAnalyzer(
                     if (callable is ConstructorItem && callable.isImplicitConstructor()) {
                         return
                     }
-                    addApiLevelDocumentation(apiLookup.getCallableVersion(callable), callable)
+                    addApiVersionDocumentation(apiLookup.getCallableVersion(callable), callable)
                     val methodName = callable.name()
                     val key = "${callable.containingClass().qualifiedName()}#$methodName"
                     elementToSdkExtSinceMap[key]?.let {
@@ -758,13 +796,15 @@ class DocAnalyzer(
                 override fun visitClass(cls: ClassItem) {
                     val qualifiedName = cls.qualifiedName()
                     val since = apiLookup.getClassVersion(cls)
-                    if (since != -1) {
-                        addApiLevelDocumentation(since, cls)
+                    if (since != null) {
+                        addApiVersionDocumentation(since, cls)
 
                         // Compute since version for the package: it's the min of all the classes in
                         // the package
                         val pkg = cls.containingPackage()
-                        pkgApi[pkg] = min(pkgApi[pkg] ?: Integer.MAX_VALUE, since)
+                        packageToVersion[pkg] =
+                            packageToVersion[pkg]?.let { existing -> minOf(existing, since) }
+                                ?: since
                     }
                     elementToSdkExtSinceMap[qualifiedName]?.let {
                         addApiExtensionsDocumentation(it, cls)
@@ -773,7 +813,7 @@ class DocAnalyzer(
                 }
 
                 override fun visitField(field: FieldItem) {
-                    addApiLevelDocumentation(apiLookup.getFieldVersion(field), field)
+                    addApiVersionDocumentation(apiLookup.getFieldVersion(field), field)
                     elementToSdkExtSinceMap[
                             "${field.containingClass().qualifiedName()}#${field.name()}"]
                         ?.let { addApiExtensionsDocumentation(it, field) }
@@ -782,38 +822,37 @@ class DocAnalyzer(
             }
         )
 
-        for ((pkg, api) in pkgApi.entries) {
-            val code = api ?: 1
-            addApiLevelDocumentation(code, pkg)
+        for ((pkg, version) in packageToVersion.entries) {
+            addApiVersionDocumentation(version, pkg)
         }
     }
 
     /**
-     * Add API level documentation to the [item].
+     * Add API version documentation to the [item].
      *
      * This only applies to classes and class members, i.e. not parameters.
      */
-    private fun addApiLevelDocumentation(level: Int, item: SelectableItem) {
-        if (level > 0) {
+    private fun addApiVersionDocumentation(apiVersion: ApiVersion?, item: SelectableItem) {
+        if (apiVersion != null) {
             if (item.originallyHidden) {
-                // @SystemApi, @TestApi etc -- don't apply API levels here since we don't have
+                // @SystemApi, @TestApi etc -- don't apply API versions here since we don't have
                 // accurate historical data
                 return
             }
 
-            // Check to see whether an API level should not be included in the documentation.
-            if (!apiLevelFilter(level)) {
+            // Check to see whether an API version should not be included in the documentation.
+            if (!apiVersionFilter(apiVersion)) {
                 return
             }
 
-            val apiLevelLabel = apiLevelLabelProvider(level)
+            val apiVersionLabel = apiVersionLabelProvider(apiVersion)
 
             // Also add @since tag, unless already manually entered.
             // TODO: Override it everywhere in case the existing doc is wrong (we know
             // better), and at least for OpenJDK sources we *should* since the since tags
-            // are talking about language levels rather than API levels!
+            // are talking about language levels rather than API versions!
             if (!item.documentation.contains("@apiSince")) {
-                item.appendDocumentation(apiLevelLabel, "@apiSince")
+                item.appendDocumentation(apiVersionLabel, "@apiSince")
             } else {
                 reporter.report(
                     Issues.FORBIDDEN_TAG,
@@ -851,17 +890,17 @@ class DocAnalyzer(
      *
      * This only applies to classes and class members, i.e. not parameters.
      */
-    private fun addDeprecatedDocumentation(level: Int, item: SelectableItem) {
-        if (level > 0) {
+    private fun addDeprecatedDocumentation(version: ApiVersion?, item: SelectableItem) {
+        if (version != null) {
             if (item.originallyHidden) {
-                // @SystemApi, @TestApi etc -- don't apply API levels here since we don't have
+                // @SystemApi, @TestApi etc -- don't apply API versions here since we don't have
                 // accurate historical data
                 return
             }
-            val apiLevelLabel = apiLevelLabelProvider(level)
+            val apiVersionLabel = apiVersionLabelProvider(version)
 
             if (!item.documentation.contains("@deprecatedSince")) {
-                item.appendDocumentation(apiLevelLabel, "@deprecatedSince")
+                item.appendDocumentation(apiVersionLabel, "@deprecatedSince")
             } else {
                 reporter.report(
                     Issues.FORBIDDEN_TAG,
@@ -878,57 +917,63 @@ class DocAnalyzer(
 val androidSdkConstraint = ApiConstraint.get(1)
 
 /**
- * Get the min API level, i.e. the lowest version of the Android Platform SDK.
+ * Get the min [ApiVersion], i.e. the lowest version of the Android Platform SDK.
  *
  * TODO(b/282932318): Replace with call to ApiConstraint.min() when bug is fixed.
  */
-fun ApiConstraint.minApiLevel(): Int {
+fun ApiConstraint.minApiVersion(): ApiVersion? {
     return getConstraints()
         .filter { it != ApiConstraint.UNKNOWN }
         // Remove any constraints that are not for the Android Platform SDK.
         .filter { it.isAtLeast(androidSdkConstraint) }
-        // Get the minimum of all the lowest API levels, or -1 if there are no API levels in the
+        // Get the minimum of all the lowest ApiVersions, or null if there are no ApiVersions in the
         // constraints.
-        .minOfOrNull { it.fromInclusive() }
-        ?: -1
+        .minOfOrNull {
+            val major = it.fromInclusive()
+            val minor = it.fromInclusiveMinor()
+            ApiVersion.fromMajorMinor(
+                major,
+                if (minor == 0) null else minor,
+            )
+        }
 }
 
-fun ApiLookup.getClassVersion(cls: ClassItem): Int {
+fun ApiLookup.getClassVersion(cls: ClassItem): ApiVersion? {
     val owner = cls.qualifiedName()
-    return getClassVersions(owner).minApiLevel()
+    return getClassVersions(owner).minApiVersion()
 }
 
-fun ApiLookup.getCallableVersion(method: CallableItem): Int {
+fun ApiLookup.getCallableVersion(method: CallableItem): ApiVersion? {
     val containingClass = method.containingClass()
     val owner = containingClass.qualifiedName()
     val desc = method.getCallableParameterDescriptorUsingDots()
     // Metalava uses the class name as the name of the constructor but the ApiLookup uses <init>.
     val name = if (method.isConstructor()) "<init>" else method.name()
-    return getMethodVersions(owner, name, desc).minApiLevel()
+    return getMethodVersions(owner, name, desc).minApiVersion()
 }
 
-fun ApiLookup.getFieldVersion(field: FieldItem): Int {
+fun ApiLookup.getFieldVersion(field: FieldItem): ApiVersion? {
     val containingClass = field.containingClass()
     val owner = containingClass.qualifiedName()
-    return getFieldVersions(owner, field.name()).minApiLevel()
+    return getFieldVersions(owner, field.name()).minApiVersion()
 }
 
-fun ApiLookup.getClassDeprecatedIn(cls: ClassItem): Int {
+fun ApiLookup.getClassDeprecatedIn(cls: ClassItem): ApiVersion? {
     val owner = cls.qualifiedName()
-    return getClassDeprecatedInVersions(owner).minApiLevel()
+    return getClassDeprecatedInVersions(owner).minApiVersion()
 }
 
-fun ApiLookup.getCallableDeprecatedIn(callable: CallableItem): Int {
+fun ApiLookup.getCallableDeprecatedIn(callable: CallableItem): ApiVersion? {
     val containingClass = callable.containingClass()
     val owner = containingClass.qualifiedName()
-    val desc = callable.getCallableParameterDescriptorUsingDots() ?: return -1
-    return getMethodDeprecatedInVersions(owner, callable.name(), desc).minApiLevel()
+    val desc = callable.getCallableParameterDescriptorUsingDots() ?: return null
+    return getMethodDeprecatedInVersions(owner, callable.name(), desc).minApiVersion()
 }
 
-fun ApiLookup.getFieldDeprecatedIn(field: FieldItem): Int {
+fun ApiLookup.getFieldDeprecatedIn(field: FieldItem): ApiVersion? {
     val containingClass = field.containingClass()
     val owner = containingClass.qualifiedName()
-    return getFieldDeprecatedInVersions(owner, field.name()).minApiLevel()
+    return getFieldDeprecatedInVersions(owner, field.name()).minApiVersion()
 }
 
 fun getApiLookup(
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt b/metalava/src/main/java/com/android/tools/metalava/jar/JarCodebaseLoader.kt
similarity index 87%
rename from metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
rename to metalava/src/main/java/com/android/tools/metalava/jar/JarCodebaseLoader.kt
index 60f35131f..c4dd84982 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/jar/JarCodebaseLoader.kt
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.jar
 
-import com.android.tools.metalava.cli.common.ExecutionEnvironment
+import com.android.tools.metalava.ApiAnalyzer
+import com.android.tools.metalava.ProgressTracker
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.source.EnvironmentManager
@@ -34,6 +35,8 @@ sealed interface JarCodebaseLoader {
     fun loadFromJarFile(
         apiJar: File,
         apiAnalyzerConfig: ApiAnalyzer.Config = ApiAnalyzer.Config(),
+        freezeCodebase: Boolean = true,
+        classPath: List<File> = emptyList(),
     ): Codebase
 
     companion object {
@@ -56,6 +59,8 @@ sealed interface JarCodebaseLoader {
         override fun loadFromJarFile(
             apiJar: File,
             apiAnalyzerConfig: ApiAnalyzer.Config,
+            freezeCodebase: Boolean,
+            classPath: List<File>,
         ): Codebase {
             progressTracker.progress("Processing jar file: ")
 
@@ -66,15 +71,17 @@ sealed interface JarCodebaseLoader {
                 )
             val apiReference = apiEmit
 
-            val codebase = sourceParser.loadFromJar(apiJar)
+            val codebase = sourceParser.loadFromJar(apiJar, classPath)
             val analyzer = ApiAnalyzer(sourceParser, codebase, reporter, apiAnalyzerConfig)
             analyzer.mergeExternalInclusionAnnotations()
             analyzer.computeApi()
             analyzer.mergeExternalQualifierAnnotations()
             analyzer.generateInheritedStubs(apiEmit, apiReference)
 
-            // Prevent the codebase from being mutated.
-            codebase.freezeClasses()
+            if (freezeCodebase) {
+                // Prevent the codebase from being mutated.
+                codebase.freezeClasses()
+            }
 
             return codebase
         }
@@ -109,15 +116,15 @@ private constructor(
          * with to ensure prompt release of resources, e.g. using `...use { jarCodebaseLoader -> }`.
          */
         fun create(
-            executionEnvironment: ExecutionEnvironment,
+            disableStderrDumping: Boolean,
             progressTracker: ProgressTracker,
             reporter: Reporter,
+            sourceModelProvider: SourceModelProvider = SourceModelProvider.getImplementation("psi"),
         ): StandaloneJarCodebaseLoader {
-            val sourceModelProvider = SourceModelProvider.getImplementation("psi")
 
             val environmentManager =
                 sourceModelProvider.createEnvironmentManager(
-                    executionEnvironment.disableStderrDumping()
+                    disableStderrDumping,
                 )
 
             val annotationManager = DefaultAnnotationManager()
diff --git a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
index 9bb42fd46..9b905435a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
@@ -71,6 +71,7 @@ import com.android.tools.metalava.model.MultipleTypeVisitor
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
@@ -103,6 +104,7 @@ import com.android.tools.metalava.reporter.Issues.CONCRETE_COLLECTION
 import com.android.tools.metalava.reporter.Issues.CONFIG_FIELD_NAME
 import com.android.tools.metalava.reporter.Issues.CONTEXT_FIRST
 import com.android.tools.metalava.reporter.Issues.CONTEXT_NAME_SUFFIX
+import com.android.tools.metalava.reporter.Issues.DATA_CLASS_DEFINITION
 import com.android.tools.metalava.reporter.Issues.ENDS_WITH_IMPL
 import com.android.tools.metalava.reporter.Issues.ENUM
 import com.android.tools.metalava.reporter.Issues.EQUALS_AND_HASH_CODE
@@ -198,6 +200,7 @@ private constructor(
     reporter: Reporter,
     private val manifest: Manifest,
     apiPredicateConfig: ApiPredicate.Config,
+    private val allowedAcronyms: List<String>,
 ) :
     ApiVisitor(
         // ApiLint does not visit ParameterItems.
@@ -418,6 +421,10 @@ private constructor(
         }
     }
 
+    override fun visitProperty(property: PropertyItem) {
+        reporter.withContext(property) { kotlinInterop.checkProperty(property) }
+    }
+
     private fun checkType(type: TypeItem, item: Item) {
         val typeString = type.toTypeString()
         checkPfd(typeString, item)
@@ -475,6 +482,7 @@ private constructor(
         checkHasFlaggedApi(cls)
         checkFlaggedApiLiteral(cls)
         checkAccessorNullabilityMatches(methods)
+        checkDataClass(cls)
     }
 
     private fun checkField(field: FieldItem) {
@@ -504,9 +512,9 @@ private constructor(
             item.modifiers.findAnnotation { it.qualifiedName == ANDROID_FLAGGED_API } ?: return
         val attr = annotation.attributes.find { attr -> attr.name == "value" } ?: return
 
-        if (attr.value.resolve() == null) {
-            val value = attr.value.value() as? String
-            if (value == attr.value.toSource()) {
+        if (attr.legacyValue.resolve() == null) {
+            val value = attr.legacyValue.value() as? String
+            if (value == attr.legacyValue.toSource()) {
                 // For a string literal, source and value are never the same, so this happens only
                 // when a reference isn't resolvable.
                 return
@@ -570,14 +578,15 @@ private constructor(
                     method,
                     "Method name must start with lowercase char: $name"
                 )
-            hasAcronyms(name) -> {
+            hasAcronyms(name, allowedAcronyms) -> {
                 report(
                     ACRONYM_NAME,
                     method,
                     "Acronyms should not be capitalized in method names: was `$name`, should this be `${
                         decapitalizeAcronyms(
-                        name
-                    )
+                            name,
+                            allowedAcronyms
+                        )
                     }`?"
                 )
             }
@@ -602,14 +611,15 @@ private constructor(
             first !in 'A'..'Z' -> {
                 report(START_WITH_UPPER, cls, "Class must start with uppercase char: $name")
             }
-            hasAcronyms(name) -> {
+            hasAcronyms(name, allowedAcronyms) -> {
                 report(
                     ACRONYM_NAME,
                     cls,
                     "Acronyms should not be capitalized in class names: was `$name`, should this be `${
                         decapitalizeAcronyms(
-                        name
-                    )
+                            name,
+                            allowedAcronyms
+                        )
                     }`?"
                 )
             }
@@ -659,7 +669,7 @@ private constructor(
             )
         } else if (
             (field.type() is PrimitiveTypeItem || field.type().isString()) &&
-                field.initialValue(true) == null
+                field.legacyInitialValue(true) == null
         ) {
             report(
                 COMPILE_TIME_CONSTANT,
@@ -809,7 +819,7 @@ private constructor(
         if (!field.type().isString()) {
             return
         }
-        val value = field.initialValue(true) as? String ?: return
+        val value = field.legacyInitialValue(true) as? String ?: return
         if (!(name.contains("_ACTION") || name.contains("ACTION_") || value.contains(".action."))) {
             return
         }
@@ -850,7 +860,7 @@ private constructor(
         if (name.startsWith("ACTION_") || !field.type().isString()) {
             return
         }
-        val value = field.initialValue(true) as? String ?: return
+        val value = field.legacyInitialValue(true) as? String ?: return
         if (!(name.contains("_EXTRA") || name.contains("EXTRA_") || value.contains(".extra"))) {
             return
         }
@@ -1141,7 +1151,7 @@ private constructor(
             fields
                 .firstOrNull { it.name() == fieldName }
                 ?.let { field ->
-                    if (field.initialValue(true) != fieldValue) {
+                    if (field.legacyInitialValue(true) != fieldValue) {
                         report(
                             INTERFACE_CONSTANT,
                             field,
@@ -1788,7 +1798,7 @@ private constructor(
             val name = field.name()
             val index = name.indexOf("FLAG_")
             if (index != -1) {
-                val value = field.initialValue() as? Int ?: continue
+                val value = field.legacyInitialValue() as? Int ?: continue
                 val scope = name.substring(0, index)
                 val prev = known?.get(scope) ?: 0
                 if (known != null && (prev and value) != 0) {
@@ -2047,7 +2057,7 @@ private constructor(
                     writer,
                     skipNullnessAnnotations = true,
                 )
-            modifierListWriter.writeKeywords(item, normalize = true)
+            modifierListWriter.writeKeywords(item, normalizeFinal = true)
             writer.toString().trim()
         }
     }
@@ -2983,7 +2993,7 @@ private constructor(
         }
         val name = field.name()
         val endsWithService = name.endsWith("_SERVICE")
-        val value = field.initialValue(requireConstant = true) as? String
+        val value = field.legacyInitialValue(requireConstant = true) as? String
 
         if (value == null) {
             val mustEndInService =
@@ -3333,6 +3343,17 @@ private constructor(
         }
     }
 
+    private fun checkDataClass(cls: ClassItem) {
+        if (cls.modifiers.isData()) {
+            report(
+                DATA_CLASS_DEFINITION,
+                cls,
+                "Exposing data classes as public API is discouraged because they are " +
+                    "difficult to update while maintaining binary compatibility."
+            )
+        }
+    }
+
     companion object {
         /** [TypeStringConfiguration] for use in [checkAccessorNullabilityMatches] */
         private val KOTLIN_NULLS_TYPE_STRING_CONFIGURATION =
@@ -3351,8 +3372,17 @@ private constructor(
             reporter: Reporter,
             manifest: Manifest,
             apiPredicateConfig: ApiPredicate.Config,
+            allowedAcronyms: List<String>,
         ) {
-            val apiLint = ApiLint(codebase, oldCodebase, reporter, manifest, apiPredicateConfig)
+            val apiLint =
+                ApiLint(
+                    codebase,
+                    oldCodebase,
+                    reporter,
+                    manifest,
+                    apiPredicateConfig,
+                    allowedAcronyms,
+                )
             apiLint.check()
         }
 
@@ -3474,8 +3504,13 @@ private constructor(
         private val resourceValueFieldPattern = Regex("[a-z][a-zA-Z0-9]*")
         private val styleFieldPattern = Regex("[A-Z][A-Za-z0-9]+(_[A-Z][A-Za-z0-9]+?)*")
 
-        private val acronymPattern2 = Regex("([A-Z]){2,}")
-        private val acronymPattern3 = Regex("([A-Z]){3,}")
+        // An acronym is 2 or more capital letters. Following the acronym there can either be a next
+        // word (capital followed by a non-capital), digit, underscore, or word break (digits and
+        // underscores count as word characters).
+        // Including the next character in the regex means the first capture group will contain just
+        // the acronym and not the start of the next word, e.g. for "HTMLWriter" the acronym is
+        // "HTML", not "HTMLW".
+        private val acronymPattern = Regex("([A-Z]{2,})(?:[A-Z][a-z]|[0-9]|_|\\b)")
 
         private val serviceDumpMethodParameterTypes =
             listOf("java.io.FileDescriptor", "java.io.PrintWriter", "java.lang.String[]")
@@ -3494,28 +3529,28 @@ private constructor(
                 item.parameters().map { it.type().toTypeString() } ==
                     serviceDumpMethodParameterTypes
 
-        private fun hasAcronyms(name: String): Boolean {
-            // Require 3 capitals, or 2 if it's at the end of a word.
-            val result = acronymPattern2.find(name) ?: return false
-            return result.range.first == name.length - 2 || acronymPattern3.find(name) != null
+        private fun hasAcronyms(name: String, allowedAcronyms: List<String>): Boolean {
+            return getFirstAcronym(name, allowedAcronyms) != null
         }
 
-        private fun getFirstAcronym(name: String): String? {
-            // Require 3 capitals, or 2 if it's at the end of a word.
-            val result = acronymPattern2.find(name) ?: return null
-            if (result.range.first == name.length - 2) {
-                return name.substring(name.length - 2)
-            }
-            val result2 = acronymPattern3.find(name)
-            return if (result2 != null) {
-                name.substring(result2.range.first, result2.range.last + 1)
+        private fun getFirstAcronym(name: String, allowedAcronyms: List<String>): String? {
+            val fullMatch = acronymPattern.find(name) ?: return null
+            // Group 1 is just the acronym.
+            val result = fullMatch.groups[1] ?: return null
+
+            val acronym = name.substring(result.range.first, result.range.last + 1)
+            return if (acronym !in allowedAcronyms) {
+                acronym
+            } else if (fullMatch.range.last < name.length) {
+                // Keep searching from the end of the last match, if possible.
+                getFirstAcronym(name.substring(result.range.last + 1), allowedAcronyms)
             } else {
                 null
             }
         }
 
         /** for something like "HTMLWriter", returns "HtmlWriter" */
-        private fun decapitalizeAcronyms(name: String): String {
+        private fun decapitalizeAcronyms(name: String, allowedAcronyms: List<String>): String {
             var s = name
 
             if (s.none { it.isLowerCase() }) {
@@ -3532,26 +3567,14 @@ private constructor(
             }
 
             while (true) {
-                val acronym = getFirstAcronym(s) ?: return s
+                val acronym = getFirstAcronym(s, allowedAcronyms) ?: return s
                 val index = s.indexOf(acronym)
                 if (index == -1) {
                     return s
                 }
-                // The last character, if not the end of the string, is probably the beginning of
-                // the
-                // next word so capitalize it
-                s =
-                    if (index == s.length - acronym.length) {
-                        // acronym at the end of the word word
-                        val decapitalized = acronym[0] + acronym.substring(1).lowercase(Locale.US)
-                        s.replace(acronym, decapitalized)
-                    } else {
-                        val replacement =
-                            acronym[0] +
-                                acronym.substring(1, acronym.length - 1).lowercase(Locale.US) +
-                                acronym[acronym.length - 1]
-                        s.replace(acronym, replacement)
-                    }
+                // Convert all but the first character of the acronym to lowercase.
+                val decapitalized = acronym[0] + acronym.substring(1).lowercase(Locale.US)
+                s = s.replace(acronym, decapitalized)
             }
         }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
index e2b987163..72672d013 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
@@ -314,7 +314,7 @@ internal class JavaStubWriter(
         generateThrowsList(method)
 
         if (containingClass.isAnnotationType()) {
-            val default = method.defaultValue()
+            val default = method.legacyDefaultValue()
             if (default.isNotEmpty()) {
                 writer.print(" default ")
                 writer.print(default)
@@ -345,7 +345,7 @@ internal class JavaStubWriter(
         writer.print(field.name())
         val needsInitialization =
             field.modifiers.isFinal() &&
-                field.initialValue(true) == null &&
+                field.legacyInitialValue(true) == null &&
                 field.containingClass().isClass()
         field.writeValueWithSemicolon(
             writer,
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
index 45f48a83f..3d2072e88 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
@@ -23,7 +23,6 @@ import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemVisitor
-import com.android.tools.metalava.model.Language
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PackageItem
@@ -143,14 +142,8 @@ internal class StubWriter(
         assert(classItem.containingClass() == null) { "Should only be called on top level classes" }
         val packageDir = getPackageDir(classItem.containingPackage())
 
-        // Kotlin From-text stub generation is not supported.
-        // This method will raise an error if
-        // config.kotlinStubs == true and classItem is TextClassItem.
-        return if (config.kotlinStubs && classItem.isKotlin()) {
-            File(packageDir, "${classItem.simpleName()}.kt")
-        } else {
-            File(packageDir, "${classItem.simpleName()}.java")
-        }
+        // Kotlin stub generation is not supported.
+        return File(packageDir, "${classItem.simpleName()}.java")
     }
 
     /**
@@ -197,23 +190,20 @@ internal class StubWriter(
                     errorTextWriter
                 }
 
-            val kotlin = config.kotlinStubs && cls.isKotlin()
-            val language = if (kotlin) Language.KOTLIN else Language.JAVA
-
             val modifierListWriter =
                 ModifierListWriter.forStubs(
                     writer = textWriter,
                     docStubs = docStubs,
                     runtimeAnnotationsOnly = !generateAnnotations,
-                    language = language,
                 )
 
             stubWriter =
-                if (kotlin) {
-                    error("Generating Kotlin stubs is not supported")
-                } else {
-                    JavaStubWriter(textWriter, modifierListWriter, config, stubConstructorManager)
-                }
+                JavaStubWriter(
+                    textWriter,
+                    modifierListWriter,
+                    config,
+                    stubConstructorManager,
+                )
 
             // Copyright statements from the original file?
             cls.sourceFile()?.getHeaderComments()?.let { textWriter.println(it) }
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
index 1b1f5aea6..25e1dc7e2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
@@ -21,11 +21,6 @@ package com.android.tools.metalava.stub
  * options.
  */
 internal data class StubWriterConfig(
-    /**
-     * If true then generate kotlin stubs if the source is kotlin, otherwise generate java stubs.
-     */
-    val kotlinStubs: Boolean = false,
-
     /** If true then include documentation in the generated stubs. */
     val includeDocumentationInStubs: Boolean = false,
 )
diff --git a/metalava/src/main/resources/schemas/config.xsd b/metalava/src/main/resources/schemas/config.xsd
index ae1bd4ba6..38950f088 100644
--- a/metalava/src/main/resources/schemas/config.xsd
+++ b/metalava/src/main/resources/schemas/config.xsd
@@ -14,7 +14,242 @@
   ~ limitations under the License.
   -->
 
-<!-- Schema for a configuration file supplied to Metalava with the `‐‐config-file` option. -->
-<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.google.com/tools/metalava/config">
-    <xs:element name="config"/>
+<!--
+ ! Schema for a configuration file supplied to Metalava with the `‐‐config-file` option.
+ !
+ ! While this is used at runtime to validate config files during parsing its main purpose is for use by editors to
+ ! provide support for editing configuration files, e.g. providing auto-completion, validation while typing, etc.
+ !
+ ! As any element defined as a child of <xs:schema> can be used as a root element, which would often result in an
+ ! invalid document this only creates a single such element. For other elements it defines them where they are used in
+ ! terms of a top level <xs:complexType>. That prevents them from being used as root element while limiting the nested
+ ! depth of this file. That is a common approach and in fact is used in the XMLSchema that applies to this file.
+ !
+ ! Elements use lower case, hyphenated names. Types use camel case names that start with an upper case letter to
+ ! differentiate them.
+ !-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
+           elementFormDefault="qualified"
+           targetNamespace="http://www.google.com/tools/metalava/config"
+            xmlns:config="http://www.google.com/tools/metalava/config">
+    <xs:element name="config">
+        <xs:annotation>
+            <xs:documentation>
+                Root element of every configuration file.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:complexType>
+            <xs:choice>
+                <xs:element name="api-surfaces" type="config:ApiSurfacesType" minOccurs="0">
+                    <xs:annotation>
+                        <xs:documentation>
+                            The definitions of a set of API surfaces.
+                        </xs:documentation>
+                    </xs:annotation>
+                </xs:element>
+                <xs:element name="api-flags" type="config:ApiFlagsType" minOccurs="0">
+                    <xs:annotation>
+                        <xs:documentation>
+                            The definitions of a set of API flags.
+                        </xs:documentation>
+                    </xs:annotation>
+                </xs:element>
+            </xs:choice>
+        </xs:complexType>
+
+        <!-- A key that makes sure that API surface names are unique within the containing file. -->
+        <xs:key name="ApiSurfaceByName">
+            <xs:selector xpath=".//config:api-surface"/>
+            <xs:field xpath="@name"/>
+        </xs:key>
+
+        <!--
+         ! A key reference that makes sure that `extends` attributes reference a surface defined within the containing
+         ! file.
+         !-->
+        <xs:keyref name="ApiSurfaceExtendsKeyRef" refer="config:ApiSurfaceByName">
+            <xs:selector xpath=".//config:api-surface"/>
+            <xs:field xpath="@extends"/>
+        </xs:keyref>
+
+        <!--
+         ! A key that makes sure that API flag qualified names (package plus name) are unique within the containing
+         ! file.
+         !-->
+        <xs:key name="ApiFlagByQualifiedName">
+            <xs:selector xpath=".//config:api-flag"/>
+            <xs:field xpath="@package"/>
+            <xs:field xpath="@name"/>
+        </xs:key>
+
+    </xs:element>
+
+    <xs:complexType name="ApiSurfacesType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `api-surfaces` element defined inside `config`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:choice>
+            <xs:element name="api-surface" type="config:ApiSurfaceType" minOccurs="0" maxOccurs="unbounded">
+                <xs:annotation>
+                    <xs:documentation>
+                        API surface definition.
+                    </xs:documentation>
+                </xs:annotation>
+            </xs:element>
+        </xs:choice>
+    </xs:complexType>
+
+    <xs:simpleType name="ApiSurfaceNameType">
+        <xs:annotation>
+            <xs:documentation>
+                The allowable type of an API surface name. Can only include lower case letters and hyphens.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:restriction base="xs:string">
+            <xs:pattern value="[a-z-]+"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:complexType name="ApiSurfaceType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `api-surface` element defined inside `ApiSurfacesType`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:choice/>
+        <xs:attribute name="name" type="config:ApiSurfaceNameType" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required name of the surface.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="extends" type="config:ApiSurfaceNameType">
+            <xs:annotation>
+                <xs:documentation>
+                    The optional name of the surface that this surface extends.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="ApiFlagsType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `api-flags` element defined inside `config`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:choice>
+            <xs:element name="api-flag" type="config:ApiFlagType" minOccurs="0" maxOccurs="unbounded">
+                <xs:annotation>
+                    <xs:documentation>
+                        API flag definition.
+                    </xs:documentation>
+                </xs:annotation>
+            </xs:element>
+        </xs:choice>
+    </xs:complexType>
+
+    <xs:complexType name="ApiFlagType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `api-flag` element defined inside `ApiSurfacesType`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:choice/>
+        <xs:attribute name="package" type="config:ApiFlagPackageNameType" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required package of the flag.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="name" type="config:ApiFlagNameType" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required name of the flag.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="mutability" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required mutability of the flag.
+                </xs:documentation>
+            </xs:annotation>
+            <xs:simpleType>
+                <xs:restriction base="xs:string">
+                    <xs:enumeration value="mutable">
+                        <xs:annotation>
+                            <xs:documentation>
+                                The flag status can be changed.
+                            </xs:documentation>
+                        </xs:annotation>
+                    </xs:enumeration>
+                    <xs:enumeration value="immutable">
+                        <xs:annotation>
+                            <xs:documentation>
+                                The flag status is fixed.
+                            </xs:documentation>
+                        </xs:annotation>
+                    </xs:enumeration>
+                </xs:restriction>
+            </xs:simpleType>
+        </xs:attribute>
+        <xs:attribute name="status" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The status of the flag.
+                </xs:documentation>
+            </xs:annotation>
+            <xs:simpleType>
+                <xs:restriction base="xs:string">
+                    <xs:enumeration value="enabled">
+                        <xs:annotation>
+                            <xs:documentation>
+                                The flag is enabled.
+                            </xs:documentation>
+                        </xs:annotation>
+                    </xs:enumeration>
+                    <xs:enumeration value="disabled">
+                        <xs:annotation>
+                            <xs:documentation>
+                                The flag is disabled.
+                            </xs:documentation>
+                        </xs:annotation>
+                    </xs:enumeration>
+                </xs:restriction>
+            </xs:simpleType>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:simpleType name="ApiFlagPackageNameType">
+        <xs:annotation>
+            <xs:documentation>
+                The allowable type of an API package name. Can only include lower case letters, decimal digits,
+                underscores and `.` separators.
+
+                This is not as strict as the upstream flag package name check, but it is sufficient for Metalava.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:restriction base="xs:string">
+            <xs:pattern value="[a-z0-9_.]+"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="ApiFlagNameType">
+        <xs:annotation>
+            <xs:documentation>
+                The allowable type of an API surface name. Can only include lower case letters, decimal digits and
+                underscores.
+
+                This is not as strict as the upstream flag name check, but it is sufficient for Metalava.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:restriction base="xs:string">
+            <xs:pattern value="[a-z0-9_]+"/>
+        </xs:restriction>
+    </xs:simpleType>
 </xs:schema>
diff --git a/metalava/src/test/java/com/android/tools/metalava/AndroidJarsToSignaturesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/AndroidJarsToSignaturesCommandTest.kt
deleted file mode 100644
index c3742dacc..000000000
--- a/metalava/src/test/java/com/android/tools/metalava/AndroidJarsToSignaturesCommandTest.kt
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava
-
-import com.android.tools.metalava.cli.common.BaseCommandTest
-import com.android.tools.metalava.cli.signature.SIGNATURE_FORMAT_OPTIONS_HELP
-import com.android.tools.metalava.model.text.FileFormat
-import java.io.File
-import kotlin.test.assertEquals
-import org.junit.Assert
-import org.junit.Test
-
-class AndroidJarsToSignaturesCommandTest :
-    BaseCommandTest<AndroidJarsToSignaturesCommand>({ AndroidJarsToSignaturesCommand() }) {
-
-    @Test
-    fun `Test help`() {
-        commandTest {
-            args += listOf("android-jars-to-signatures")
-
-            expectedStdout =
-                """
-Aborting: Usage: metalava android-jars-to-signatures [options] <android-root-dir>
-
-  Rewrite the signature files in the `prebuilts/sdk` directory in the Android source tree.
-
-  It does this by reading the API defined in the corresponding `android.jar` files.
-
-Options:
-  -h, -?, --help                             Show this message and exit
-
-$SIGNATURE_FORMAT_OPTIONS_HELP
-
-Arguments:
-  <android-root-dir>                         The root directory of the Android source tree. The new signature files will
-                                             be generated in the `prebuilts/sdk/<api>/public/api/android.txt`
-                                             sub-directories.
-            """
-                    .trimIndent()
-        }
-    }
-
-    @Test
-    fun `Test not Android dir`() {
-        commandTest {
-            val notAndroidRoot = folder("not-android-root")
-
-            args += "android-jars-to-signatures"
-            args += notAndroidRoot.path
-
-            expectedStderr =
-                """
-                    Aborting: <android-root-dir> does not point to an Android source tree
-                """
-                    .trimIndent()
-        }
-    }
-
-    @Test
-    fun `Test convert jars`() {
-        // Get the location of an android.jar in the prebuilts/sdk files generated by the build.
-        val prebuiltsSdkDir = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
-        if (!prebuiltsSdkDir.isDirectory) {
-            Assert.fail("test prebuilts not found: $prebuiltsSdkDir")
-        }
-        val androidJar = prebuiltsSdkDir.resolve("30/public/android.jar")
-
-        commandTest {
-            // Copy the android.jar into a temporary folder structure.
-            val androidRootDir = folder("android-root-dir")
-
-            fun oldAndroidJarFile(apiVersion: Int): String {
-                return "prebuilts/tools/common/api-versions/android-$apiVersion/android.jar"
-            }
-            fun currentVersionDir(apiVersion: Int): String {
-                return "prebuilts/sdk/$apiVersion/public"
-            }
-            fun currentApiDir(apiVersion: Int): String {
-                return "${currentVersionDir(apiVersion)}/api"
-            }
-            fun currentAndroidJarFile(apiVersion: Int): String {
-                return "${currentVersionDir(apiVersion)}/android.jar"
-            }
-            fun currentApiTxtFile(apiVersion: Int): String {
-                return "${currentApiDir(apiVersion)}/android.txt"
-            }
-
-            data class ApiVersionInfo(
-                val version: Int,
-                val inputAndroidJarFile: File,
-                val inputAndroidTxtFile: File? = null,
-            )
-            val apiVersionsInfo = mutableListOf<ApiVersionInfo>()
-
-            // The first few android.jars are not in prebuilts/sdk
-            // However, the android.txt files are still output to prebuilts/sdk.
-            for (apiVersion in 1..3) {
-                val versionJar = androidRootDir.resolve(oldAndroidJarFile(apiVersion))
-                // Add to the list of api versions.
-                apiVersionsInfo.add(ApiVersionInfo(apiVersion, versionJar))
-            }
-            // The remaining android.jars are in prebuilts/sdk/<N>/public/android.jar.
-            for (apiVersion in 4..5) {
-                val versionJar = androidRootDir.resolve(currentAndroidJarFile(apiVersion))
-
-                // Some android.jar files already have a corresponding android.txt file.
-                val androidTxtFile =
-                    if (apiVersion == 5) androidRootDir.resolve(currentApiTxtFile(apiVersion))
-                    else null
-
-                // Add to the list of api versions.
-                apiVersionsInfo.add(ApiVersionInfo(apiVersion, versionJar, androidTxtFile))
-            }
-
-            // Set up the input file structure.
-            for (apiVersionInfo in apiVersionsInfo) {
-                // Copy the android.jar created in the build.gradle.kts file.
-                androidJar.copyTo(apiVersionInfo.inputAndroidJarFile, overwrite = true)
-
-                // Create an android.txt file, if provided.
-                apiVersionInfo.inputAndroidTxtFile?.apply {
-                    parentFile.mkdirs()
-                    writeText(FileFormat.V2.header())
-                }
-
-                // Make sure the directory for the android.txt file exists.
-                androidRootDir.resolve(currentApiDir(apiVersionInfo.version)).mkdirs()
-            }
-
-            args += "android-jars-to-signatures"
-            args += androidRootDir.path
-
-            // Verify that all generated android.txt files have the correct content. They are
-            // currently all the same.
-            for (apiVersionInfo in apiVersionsInfo) {
-                verify {
-                    val apiVersion = apiVersionInfo.version
-                    val file = androidRootDir.resolve(currentApiTxtFile(apiVersion))
-                    val contents = file.readText()
-                    assertEquals(
-                        """
-// Signature format: 2.0
-package android.test {
-
-  @Deprecated public class ClassAddedAndDeprecatedInApi30 {
-    ctor @Deprecated public ClassAddedAndDeprecatedInApi30(float);
-    ctor @Deprecated public ClassAddedAndDeprecatedInApi30(int);
-    method @Deprecated public void methodExplicitlyDeprecated();
-    method @Deprecated public void methodImplicitlyDeprecated();
-    field @Deprecated public static final int FIELD_EXPLICITLY_DEPRECATED = 1; // 0x1
-    field @Deprecated public static final int FIELD_IMPLICITLY_DEPRECATED = 2; // 0x2
-  }
-
-  public class ClassAddedInApi30 {
-    method public void methodAddedInApi30();
-  }
-
-}
-
-package java.lang {
-
-  public class Object {
-    ctor public Object();
-  }
-
-}
-
-
-        """
-                            .trimIndent(),
-                        contents,
-                        message = "incorrect output for $apiVersionInfo",
-                    )
-                }
-            }
-        }
-    }
-}
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt
index 9bc6558e6..917a92b5b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt
@@ -32,7 +32,7 @@ class AnnotationRetentionTest : DriverTest() {
         // part of the source tree, ensure that we compute the right retention (runtime, meaning
         // it should show up in the stubs file.).
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             extraArguments = arrayOf(ARG_EXCLUDE_ALL_ANNOTATIONS),
             sourceFiles =
                 arrayOf(
@@ -58,9 +58,11 @@ class AnnotationRetentionTest : DriverTest() {
                         """
                     ),
                 ),
+            // Override default to emit android.annotation classes.
+            skipEmitPackages = emptyList(),
             api =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package android.annotation {
                       @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE}) public @interface SuppressLint {
                         method public abstract String[] value();
@@ -109,7 +111,7 @@ class AnnotationRetentionTest : DriverTest() {
         // part of the source tree, ensure that we compute the right retention (runtime, meaning
         // it should show up in the stubs file.).
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             extraArguments = arrayOf(ARG_EXCLUDE_ALL_ANNOTATIONS),
             sourceFiles =
                 arrayOf(
@@ -127,7 +129,7 @@ class AnnotationRetentionTest : DriverTest() {
                 ),
             api =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) public @interface ExplicitRuntimeRetention {
                       }
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
index b70b6d75d..b590aedde 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
@@ -19,8 +19,6 @@ package com.android.tools.metalava
 import com.android.tools.metalava.cli.common.ARG_WARNING
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.testing.KnownSourceFiles
-import com.android.tools.metalava.testing.KnownSourceFiles.androidxAnnotationHide
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -37,7 +35,6 @@ class AnnotationsMergerTest : DriverTest() {
             format = FileFormat.V2,
             sourceFiles =
                 arrayOf(
-                    androidxAnnotationHide,
                     androidxNullableSource,
                     androidxNonNullSource,
                     java(
@@ -88,7 +85,6 @@ class AnnotationsMergerTest : DriverTest() {
             format = FileFormat.V2,
             sourceFiles =
                 arrayOf(
-                    androidxAnnotationHide,
                     androidxNullableSource,
                     androidxNonNullSource,
                     java(
@@ -160,10 +156,6 @@ class AnnotationsMergerTest : DriverTest() {
                     intRangeAnnotationSource,
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -258,7 +250,7 @@ class AnnotationsMergerTest : DriverTest() {
                 ),
             mergeSignatureAnnotations =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public interface Appendable {
                     method public test.pkg.Appendable append(java.lang.CharSequence?);
@@ -305,8 +297,6 @@ class AnnotationsMergerTest : DriverTest() {
                     ),
                     libcoreNonNullSource,
                     libcoreNullableSource,
-                    // Hide libcore.util classes.
-                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
@@ -435,8 +425,6 @@ class AnnotationsMergerTest : DriverTest() {
                     ),
                     libcoreNonNullSource,
                     libcoreNullableSource,
-                    // Hide libcore.util classes.
-                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
@@ -481,8 +469,6 @@ class AnnotationsMergerTest : DriverTest() {
                     ),
                     libcoreNonNullSource,
                     libcoreNullableSource,
-                    // Hide libcore.util classes.
-                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
index b6de08671..00e53c4af 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
@@ -17,10 +17,12 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.ARG_ERROR
+import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -372,6 +374,7 @@ class ApiAnalyzerTest : DriverTest() {
                         """
                     ),
                 ),
+            extraArguments = arrayOf(ARG_HIDE, Issues.INHERIT_CHANGES_SIGNATURE.name),
         )
     }
 
@@ -393,10 +396,9 @@ class ApiAnalyzerTest : DriverTest() {
                         """
                     ),
                 ),
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             api =
                 """
-                    // Signature format: 2.0
                     package test.pkg {
                       @Deprecated public final class Foo {
                         ctor @Deprecated public Foo(@Deprecated int i, @Deprecated boolean b);
@@ -404,8 +406,8 @@ class ApiAnalyzerTest : DriverTest() {
                         method @Deprecated public int getI();
                         method @Deprecated public void setB(boolean);
                         method @Deprecated public void setI(int);
-                        property @Deprecated public final boolean b;
-                        property @Deprecated public final int i;
+                        property @Deprecated public boolean b;
+                        property @Deprecated public int i;
                       }
                     }
                 """,
@@ -445,7 +447,7 @@ class ApiAnalyzerTest : DriverTest() {
                         """
                     ),
                 ),
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
@@ -810,4 +812,60 @@ class ApiAnalyzerTest : DriverTest() {
                 """,
         )
     }
+
+    @Test
+    fun `Fail when erased type changes after pushing down methods from hidden super class`() {
+        check(
+            expectedIssues =
+                """
+                    src/test/pkg/Hidden.java:3: error: Explicitly override method test.pkg.Hidden.bad1() in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from ()Ltest/pkg/Hidden; to ()Ltest/pkg/Public;, and cause failures at runtime. [InheritChangesSignature]
+                    src/test/pkg/Hidden.java:4: error: Explicitly override method test.pkg.Hidden.bad1(T) in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from (Ltest/pkg/Hidden;)V to (Ltest/pkg/Public;)V, and cause failures at runtime. [InheritChangesSignature]
+                    src/test/pkg/Hidden.java:6: error: Explicitly override method test.pkg.Hidden.bad2() in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from ()Ljava/lang/Object; to ()Ljava/lang/Integer;, and cause failures at runtime. [InheritChangesSignature]
+                    src/test/pkg/Hidden.java:7: error: Explicitly override method test.pkg.Hidden.bad2(U) in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from (Ljava/lang/Object;)V to (Ljava/lang/Integer;)V, and cause failures at runtime. [InheritChangesSignature]
+                    src/test/pkg/Hidden.java:9: error: Explicitly override method test.pkg.Hidden.bad3() in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from ()Ljava/lang/Object; to ()Ljava/lang/Number;, and cause failures at runtime. [InheritChangesSignature]
+                    src/test/pkg/Hidden.java:10: error: Explicitly override method test.pkg.Hidden.bad3(V) in class test.pkg.Public, or hide it in class test.pkg.Hidden; it cannot be implicitly inherited as API from the hidden super class because that would change its erased signature from (Ljava/lang/Object;)V to (Ljava/lang/Number;)V, and cause failures at runtime. [InheritChangesSignature]
+                """,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class Public<N extends Number, O> extends Hidden<Public, Integer, N, O> {
+                                @Override
+                                public Public overriddenOk() { return null; }
+                                @Override
+                                public void overriddenOk(Public t) { return null; }
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            class Hidden<T extends Hidden, U, V, W> {
+                                public T bad1() { return null; }
+                                public void bad1(T t) {}
+
+                                public U bad2() { return null; }
+                                public void bad2(U t) {}
+
+                                public V bad3() { return null; }
+                                public void bad3(V t) {}
+
+                                public W ok() { return null; }
+                                public void ok(W t) { }
+
+                                public T overriddenOk() { return null; }
+                                public void overriddenOk(T t) { }
+
+                                /** @hide */
+                                public T hiddenOk() { return null; }
+                                /** @hide */
+                                public void hiddenOk(T t) { }
+                            }
+                        """
+                    )
+                ),
+            extraArguments = arrayOf(ARG_ERROR, Issues.INHERIT_CHANGES_SIGNATURE.name)
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
index f20aa6724..7176f501a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
@@ -26,7 +26,11 @@ import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.FileFormat.OverloadedMethodOrder
-import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.testing.KnownJarFiles
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -74,7 +78,7 @@ class ApiFileTest : DriverTest() {
         // static method in interface is not overridable.
         // See https://kotlinlang.org/docs/reference/whatsnew13.html
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -98,12 +102,12 @@ class ApiFileTest : DriverTest() {
                 package test.pkg {
                   public interface Foo {
                     method public static void sayHello();
-                    field @NonNull public static final test.pkg.Foo.Companion Companion;
+                    field public static final test.pkg.Foo.Companion Companion;
                     field public static final int answer = 42; // 0x2a
                   }
                   public static final class Foo.Companion {
                     method public void sayHello();
-                    property public static final int answer;
+                    property public static int answer;
                   }
                 }
                 """,
@@ -138,233 +142,11 @@ class ApiFileTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Parameter Names in Java`() {
-        // Java code which explicitly specifies parameter names
-        check(
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import androidx.annotation.ParameterName;
-
-                    public class Foo {
-                        public void foo(int javaParameter1, @ParameterName("publicParameterName") int javaParameter2) {
-                        }
-                    }
-                    """
-                    ),
-                    supportParameterName,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                    package test.pkg {
-                      public class Foo {
-                        ctor public Foo();
-                        method public void foo(int, int publicParameterName);
-                      }
-                    }
-                 """,
-        )
-    }
-
-    @Test
-    fun `Default Values Names in Java`() {
-        // Java code which explicitly specifies parameter names
-        check(
-            format = FileFormat.V3,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import androidx.annotation.DefaultValue;
-
-                    public class Foo {
-                        public void foo(
-                            @DefaultValue("null") String prefix,
-                            @DefaultValue("\"Hello World\"") String greeting,
-                            @DefaultValue("42") int meaning) {
-                        }
-                    }
-                    """
-                    ),
-                    supportDefaultValue,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                // Signature format: 3.0
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public void foo(String! = null, String! = "Hello World", int = 42);
-                  }
-                }
-                 """,
-        )
-    }
-
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Default Values and Names in Kotlin`() {
-        // Kotlin code which explicitly specifies parameter names
-        check(
-            format = FileFormat.V3,
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                    package test.pkg
-                    import some.other.pkg.Constants.Misc.SIZE
-                    import android.graphics.Bitmap
-                    import android.view.View
-
-                    class Foo {
-                        fun method1(myInt: Int = 42,
-                            myInt2: Int? = null,
-                            myByte: Int = 2 * 21,
-                            str: String = "hello " + "world",
-                            vararg args: String) { }
-
-                        fun method2(myInt: Int, myInt2: Int = (2*myInt) * SIZE) { }
-
-                        fun method3(str: String, myInt: Int, myInt2: Int = double(myInt) + str.length) { }
-
-                        fun emptyLambda(sizeOf: () -> Unit = {  }) {}
-
-                        fun View.drawToBitmap(config: Bitmap.Config = Bitmap.Config.ARGB_8888): Bitmap? = null
-
-                        companion object {
-                            fun double(myInt: Int) = 2 * myInt
-                            fun print(foo: Foo = Foo()) { println(foo) }
-                        }
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package some.other.pkg;
-                    /** @hide */
-                    public class Constants {
-                        public static class Misc {
-                            public static final int SIZE = 5;
-                        }
-                    }
-                    """
-                    ),
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                // Signature format: 3.0
-                package test.pkg {
-                  public final class Foo {
-                    ctor public Foo();
-                    method public android.graphics.Bitmap? drawToBitmap(android.view.View, android.graphics.Bitmap.Config config = android.graphics.Bitmap.Config.ARGB_8888);
-                    method public void emptyLambda(kotlin.jvm.functions.Function0<kotlin.Unit> sizeOf = {});
-                    method public void method1(int myInt = 42, Integer? myInt2 = null, int myByte = 42, String str = "hello world", java.lang.String... args);
-                    method public void method2(int myInt, int myInt2 = (2*myInt) * some.other.pkg.Constants.Misc.SIZE);
-                    method public void method3(String str, int myInt, int myInt2 = double(myInt) + str.length);
-                    field public static final test.pkg.Foo.Companion Companion;
-                  }
-                  public static final class Foo.Companion {
-                    method public int double(int myInt);
-                    method public void print(test.pkg.Foo foo = test.pkg.Foo());
-                  }
-                }
-                """,
-        )
-    }
-
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Default Values in Kotlin for expressions`() {
-        // Testing trickier default values; regression test for problem
-        // observed in androidx.core.util with LruCache
-        check(
-            format = FileFormat.V3,
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                    package androidx.core.util
-
-                    import android.util.LruCache
-
-                    inline fun <K : Any, V : Any> lruCache(
-                        maxSize: Int,
-                        crossinline sizeOf: (key: K, value: V) -> Int = { _, _ -> 1 },
-                        @Suppress("USELESS_CAST") // https://youtrack.jetbrains.com/issue/KT-21946
-                        crossinline create: (key: K) -> V? = { null as V? },
-                        crossinline onEntryRemoved: (evicted: Boolean, key: K, oldValue: V, newValue: V?) -> Unit =
-                            { _, _, _, _ -> }
-                    ): LruCache<K, V> {
-                        return object : LruCache<K, V>(maxSize) {
-                            override fun sizeOf(key: K, value: V) = sizeOf(key, value)
-                            override fun create(key: K) = create(key)
-                            override fun entryRemoved(evicted: Boolean, key: K, oldValue: V, newValue: V?) {
-                                onEntryRemoved(evicted, key, oldValue, newValue)
-                            }
-                        }
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package androidx.collection;
-
-                    import androidx.annotation.NonNull;
-                    import androidx.annotation.Nullable;
-
-                    import java.util.LinkedHashMap;
-                    import java.util.Locale;
-                    import java.util.Map;
-
-                    /** @hide */
-                    public class LruCache<K, V> {
-                        @Nullable
-                        protected V create(@NonNull K key) {
-                            return null;
-                        }
-
-                        protected int sizeOf(@NonNull K key, @NonNull V value) {
-                            return 1;
-                        }
-
-                        protected void entryRemoved(boolean evicted, @NonNull K key, @NonNull V oldValue,
-                                @Nullable V newValue) {
-                        }
-                    }
-                    """
-                    ),
-                    androidxNullableSource,
-                    androidxNonNullSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                // Signature format: 3.0
-                package androidx.core.util {
-                  public final class TestKt {
-                    method public static inline <K, V> android.util.LruCache<K,V> lruCache(int maxSize, kotlin.jvm.functions.Function2<? super K,? super V,java.lang.Integer> sizeOf = { _, _ -> return 1 }, kotlin.jvm.functions.Function1<? super K,? extends V?> create = { it -> return null as V }, kotlin.jvm.functions.Function4<? super java.lang.Boolean,? super K,? super V,? super V?,kotlin.Unit> onEntryRemoved = { _, _, _, _ ->  });
-                  }
-                }
-                """,
-        )
-    }
-
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Basic Kotlin class`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -407,31 +189,33 @@ class ApiFileTest : DriverTest() {
                 """
                 package test.pkg {
                   public final class Kotlin extends test.pkg.Parent {
-                    ctor public Kotlin(@NonNull String property1 = "Default Value", int arg2);
-                    method @NonNull public String getProperty1();
-                    method @Nullable public String getProperty2();
+                    ctor public Kotlin(optional String property1, int arg2);
+                    method public String getProperty1();
+                    method public String? getProperty2();
                     method public void otherMethod(boolean ok, int times);
-                    method public void setProperty2(@Nullable String);
-                    property @NonNull public final String property1;
-                    property @Nullable public final String property2;
-                    property public final int someField2;
-                    field @NonNull public static final test.pkg.Kotlin.Companion Companion;
+                    method public void setProperty2(String?);
+                    property public String property1;
+                    property public String? property2;
+                    property public int someField2;
+                    field public static final test.pkg.Kotlin.Companion Companion;
                     field public static final int MY_CONST = 42; // 0x2a
                     field public int someField2;
                   }
                   public static final class Kotlin.Companion {
-                    property public static final int MY_CONST;
+                    property public static int MY_CONST;
                   }
                   public final class KotlinKt {
-                    method @NonNull public static inline operator String component1(@NonNull String);
+                    method public static inline operator String component1(String);
                     method public static inline int getRed(int);
                     method public static inline boolean isSrgb(long);
+                    property public static inline boolean long.isSrgb;
+                    property public static inline int int.red;
                   }
                   public class Parent {
                     ctor public Parent();
-                    method @Nullable public String method();
-                    method @Nullable public String method2(boolean value, @Nullable Boolean value);
-                    method public int method3(@Nullable Integer value, int value2);
+                    method public String? method();
+                    method public String? method2(boolean value, Boolean? value);
+                    method public int method3(Integer? value, int value2);
                   }
                 }
                 """
@@ -442,7 +226,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Kotlin Reified Methods`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -471,11 +255,11 @@ class ApiFileTest : DriverTest() {
                 package test.pkg {
                   public class Context {
                     ctor public Context();
-                    method public final <T> T getSystemService(Class<T>);
+                    method public final <T> T! getSystemService(Class<T!>!);
                   }
                   public final class TestKt {
-                    method public static inline <reified T> T systemService1(@NonNull test.pkg.Context);
-                    method public static inline String systemService2(@NonNull test.pkg.Context);
+                    method public static inline <reified T> T! systemService1(test.pkg.Context);
+                    method public static inline String! systemService2(test.pkg.Context);
                   }
                 }
                 """
@@ -486,7 +270,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Kotlin Reified Methods 2`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -514,8 +298,8 @@ class ApiFileTest : DriverTest() {
                     method public static inline <T> T inlineNoReified(T t);
                     method public static inline <reified T> void inlineReified(T t);
                     method public static inline <reified T> void inlineReifiedExtension(T, T t);
-                    method @NonNull public static inline <reified T> T[] inlineReifiedTakesAndReturnsArray(@NonNull T[] t);
-                    method @NonNull public static inline <reified T> java.util.List<T> inlineReifiedTakesAndReturnsList(@NonNull java.util.List<? extends T> t);
+                    method public static inline <reified T> T[] inlineReifiedTakesAndReturnsArray(T[] t);
+                    method public static inline <reified T> java.util.List<T> inlineReifiedTakesAndReturnsList(java.util.List<? extends T> t);
                     method public static inline <reified T> T publicInlineReified(T t);
                   }
                 }
@@ -527,7 +311,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Suspend functions`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -545,9 +329,9 @@ class ApiFileTest : DriverTest() {
                 """
                 package test.pkg {
                   public final class TestKt {
-                    method @Nullable public static suspend inline Object hello(int foo, @NonNull kotlin.coroutines.Continuation<? super kotlin.Unit>);
-                    method @Nullable public static suspend Object hello(@NonNull String, int foo = 0, @NonNull kotlin.coroutines.Continuation<? super kotlin.Unit>);
-                    method @Nullable public static suspend Object helloTwoContinuations(@NonNull kotlin.coroutines.Continuation<java.lang.Object> myContinuation, @NonNull kotlin.coroutines.Continuation<? super kotlin.Unit>);
+                    method public static suspend inline Object? hello(int foo, kotlin.coroutines.Continuation<? super kotlin.Unit>);
+                    method public static suspend Object? hello(String, optional int foo, kotlin.coroutines.Continuation<? super kotlin.Unit>);
+                    method public static suspend Object? helloTwoContinuations(kotlin.coroutines.Continuation<java.lang.Object> myContinuation, kotlin.coroutines.Continuation<? super kotlin.Unit>);
                   }
                 }
                 """
@@ -558,7 +342,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Var properties with private setters`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -577,14 +361,14 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class MyClass {
                     ctor public MyClass();
                     method public boolean getReadOnlyVar();
                     method public boolean getReadOnlyVarWithPublicModifier();
-                    property public final boolean readOnlyVar;
-                    property public final boolean readOnlyVarWithPublicModifier;
+                    property public boolean readOnlyVar;
+                    property public boolean readOnlyVarWithPublicModifier;
                   }
                 }
                 """
@@ -595,7 +379,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Kotlin Generics`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -611,7 +395,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class Bar {
                     ctor public Bar();
@@ -670,19 +454,17 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     uiThreadSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class TestKt {
                     method @UiThread public static inline <reified Args extends test.pkg2.NavArgs> test.pkg2.NavArgsLazy<Args> navArgs(test.pkg2.Fragment);
                   }
                 }
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             extraArguments =
                 arrayOf(
                     ARG_HIDE,
@@ -797,12 +579,10 @@ class ApiFileTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.collection {
                   public class ArrayMap<K, V> extends java.util.HashMap<K!,V!> implements java.util.Map<K!,V!> {
                     ctor public ArrayMap();
@@ -828,7 +608,7 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             extraArguments =
                 arrayOf(
                     ARG_HIDE,
@@ -975,8 +755,8 @@ class ApiFileTest : DriverTest() {
                     method public E getFirst();
                     method public E getLast();
                     method public void setLast(E);
-                    property public final E first;
-                    property public final E last;
+                    property public E first;
+                    property public E last;
                   }
                 }
             """
@@ -987,7 +767,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Propagate Platform types in Kotlin`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -1070,12 +850,10 @@ class ApiFileTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.util {
                   public class NonNullableJavaPair<F, S> {
                     ctor public NonNullableJavaPair(F, S);
@@ -1086,8 +864,8 @@ class ApiFileTest : DriverTest() {
                     ctor public NonNullableKotlinPair(F first, S second);
                     method public F getFirst();
                     method public S getSecond();
-                    property public final F first;
-                    property public final S second;
+                    property public F first;
+                    property public S second;
                   }
                   public class NullableJavaPair<F, S> {
                     ctor public NullableJavaPair(F?, S?);
@@ -1098,8 +876,8 @@ class ApiFileTest : DriverTest() {
                     ctor public NullableKotlinPair(F? first, S? second);
                     method public F? getFirst();
                     method public S? getSecond();
-                    property public final F? first;
-                    property public final S? second;
+                    property public F? first;
+                    property public S? second;
                   }
                   public class PlatformJavaPair<F, S> {
                     ctor public PlatformJavaPair(F!, S!);
@@ -1120,7 +898,7 @@ class ApiFileTest : DriverTest() {
         // Don't emit platform types for some unannotated elements that we know the
         // nullness for: annotation type members, equals-parameters, initialized constants, etc.
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -1227,12 +1005,10 @@ class ApiFileTest : DriverTest() {
                         .indented(),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test {
                   public class MyClass {
                     ctor public MyClass();
@@ -1282,7 +1058,7 @@ class ApiFileTest : DriverTest() {
     fun JvmOverloads() {
         // Regression test for https://github.com/android/android-ktx/issues/366
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -1312,19 +1088,17 @@ class ApiFileTest : DriverTest() {
                         }
                     """
                     ),
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.content {
                   public final class TestKt {
                     method public static void blahblahblah(String);
-                    method public static void blahblahblah(String, String firstArg = "hello");
-                    method public static void blahblahblah(String, String firstArg = "hello", int secondArg = 42);
-                    method public static void blahblahblah(String, String firstArg = "hello", int secondArg = 42, String thirdArg = "world");
-                    method public static inline void edit(android.content.SharedPreferences, boolean commit = false, kotlin.jvm.functions.Function1<? super android.content.SharedPreferences.Editor,kotlin.Unit> action);
+                    method public static void blahblahblah(String, optional String firstArg);
+                    method public static void blahblahblah(String, optional String firstArg, optional int secondArg);
+                    method public static void blahblahblah(String, optional String firstArg, optional int secondArg, optional String thirdArg);
+                    method public static inline void edit(android.content.SharedPreferences, optional boolean commit, kotlin.jvm.functions.Function1<? super android.content.SharedPreferences.Editor,kotlin.Unit> action);
                     method public static inline void edit(android.content.SharedPreferences, kotlin.jvm.functions.Function1<? super android.content.SharedPreferences.Editor,kotlin.Unit> action);
                   }
                 }
@@ -1352,10 +1126,10 @@ class ApiFileTest : DriverTest() {
                 """
                     )
                 ),
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class SimpleClass {
                     ctor public SimpleClass();
@@ -1390,17 +1164,17 @@ class ApiFileTest : DriverTest() {
                 """
                     )
                 ),
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class SimpleClass {
                     ctor public SimpleClass();
                     method public int getNonJvmField();
                     method public void setNonJvmField(int);
-                    property public final int jvmField;
-                    property public final int nonJvmField;
+                    property public int jvmField;
+                    property public int nonJvmField;
                     field public int jvmField;
                   }
                 }
@@ -1427,10 +1201,10 @@ class ApiFileTest : DriverTest() {
                 """
                     )
                 ),
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class SimpleClass {
                     ctor public SimpleClass();
@@ -1438,8 +1212,8 @@ class ApiFileTest : DriverTest() {
                     method public int myPropertyJvmGetter();
                     method public void setAnotherProperty(int);
                     method public void setMyProperty(int);
-                    property public final int anotherProperty;
-                    property public final int myProperty;
+                    property public int anotherProperty;
+                    property public int myProperty;
                   }
                 }
             """
@@ -1473,10 +1247,10 @@ class ApiFileTest : DriverTest() {
                 """
                     )
                 ),
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @SuppressCompatibility @kotlin.RequiresOptIn @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public @interface ExperimentalBar {
                   }
@@ -1790,6 +1564,8 @@ class ApiFileTest : DriverTest() {
                 """
                     )
                 ),
+            // Override default to emit android.annotation classes.
+            skipEmitPackages = emptyList(),
             api =
                 """
                 package android.annotation {
@@ -2455,7 +2231,8 @@ class ApiFileTest : DriverTest() {
                         method public String method2(String);
                       }
                     }
-            """
+            """,
+            extraArguments = arrayOf(ARG_HIDE, Issues.INHERIT_CHANGES_SIGNATURE.name),
         )
     }
 
@@ -2990,7 +2767,7 @@ class ApiFileTest : DriverTest() {
     fun `Test invalid class name`() {
         // Regression test for b/73018978
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -3009,7 +2786,7 @@ class ApiFileTest : DriverTest() {
                 """
                 package test.pkg {
                   public final class -Foo {
-                    method public static inline void printHelloWorld(@NonNull String);
+                    method public static inline void printHelloWorld(String);
                   }
                 }
                 """
@@ -3638,95 +3415,6 @@ class ApiFileTest : DriverTest() {
         )
     }
 
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Test Visible For Testing`() {
-        // Use the otherwise= visibility in signatures
-        // Regression test for issue 118763806
-        check(
-            format = FileFormat.V2,
-            sourceFiles =
-                arrayOf(
-                    java(
-                            """
-                    package test.pkg;
-                    import androidx.annotation.VisibleForTesting;
-
-                    @SuppressWarnings({"ClassNameDiffersFromFileName", "WeakerAccess"})
-                    public class ProductionCodeJava {
-                        private ProductionCodeJava() { }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
-                        public void shouldBeProtected() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-                        protected void shouldBePrivate1() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-                        public void shouldBePrivate2() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
-                        public void shouldBePackagePrivate() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.NONE)
-                        public void shouldBeHidden() {
-                        }
-                    }
-                    """
-                        )
-                        .indented(),
-                    kotlin(
-                            """
-                    package test.pkg
-                    import androidx.annotation.VisibleForTesting
-
-                    open class ProductionCodeKotlin private constructor() {
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
-                        fun shouldBeProtected() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-                        protected fun shouldBePrivate1() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
-                        fun shouldBePrivate2() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
-                        fun shouldBePackagePrivate() {
-                        }
-
-                        @VisibleForTesting(otherwise = VisibleForTesting.NONE)
-                        fun shouldBeHidden() {
-                        }
-                    }
-                    """
-                        )
-                        .indented(),
-                    visibleForTestingSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                package test.pkg {
-                  public class ProductionCodeJava {
-                    method @VisibleForTesting(otherwise=androidx.annotation.VisibleForTesting.PROTECTED) protected void shouldBeProtected();
-                  }
-                  public class ProductionCodeKotlin {
-                    method @VisibleForTesting(otherwise=androidx.annotation.VisibleForTesting.PROTECTED) protected final void shouldBeProtected();
-                  }
-                }
-                """,
-        )
-    }
-
     @Test
     fun `References Deprecated`() {
         check(
@@ -3778,9 +3466,9 @@ class ApiFileTest : DriverTest() {
     }
 
     @Test
-    fun `v3 format for qualified references in types`() {
+    fun `v4 format for qualified references in types`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -3806,7 +3494,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.appcompat.app {
                   public class ActionBarDrawerToggle {
                     method public android.view.View.OnClickListener! getToolbarNavigationClickListener1();
@@ -3822,7 +3510,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `FooKt class constructors are not public`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -3836,7 +3524,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class Bar {
                     ctor public Bar();
@@ -4004,8 +3692,6 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     androidxNonNullSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             expectedIssues = "",
             api =
@@ -4020,7 +3706,8 @@ class ApiFileTest : DriverTest() {
                     method public String method5(@NonNull String);
                   }
                 }
-                """
+                """,
+            extraArguments = arrayOf(ARG_HIDE, Issues.INHERIT_CHANGES_SIGNATURE.name),
         )
     }
 
@@ -4152,7 +3839,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Test tracking of @Composable annotation from classpath`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             classpath =
                 arrayOf(
                     /* The following source file, compiled, then ran
@@ -4213,7 +3900,7 @@ class ApiFileTest : DriverTest() {
             expectedIssues = "",
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class RadioGroupScope {
                     ctor public RadioGroupScope();
@@ -4228,7 +3915,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Test for experimental annotations from classpath`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             classpath =
                 arrayOf(
                     /* The following source file, compiled, then ran
@@ -4283,7 +3970,7 @@ class ApiFileTest : DriverTest() {
             expectedIssues = "",
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @SuppressCompatibility @test.pkg.ExternalExperimentalAnnotation public final class ClassUsingExternalExperimentalApi {
                     ctor public ClassUsingExternalExperimentalApi();
@@ -4304,7 +3991,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Inline suppress compatibility metadata for experimental annotations from classpath`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             classpath =
                 arrayOf(
                     /* The following source file, compiled, then ran
@@ -4359,7 +4046,7 @@ class ApiFileTest : DriverTest() {
             expectedIssues = "",
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @SuppressCompatibility @test.pkg.ExternalExperimentalAnnotation public final class ClassUsingExternalExperimentalApi {
                     ctor public ClassUsingExternalExperimentalApi();
@@ -4379,7 +4066,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `@IntRange value in kotlin`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -4394,20 +4081,19 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
+            // Access androidx.annotation.IntRange
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class KotlinClass {
                     ctor public KotlinClass(@IntRange(from=1L) int param);
                     ctor public KotlinClass(@IntRange(from=2L) int differentParam);
                     method public int getParam();
                     method public void myMethod(@IntRange(from=3L) int methodParam);
-                    property @IntRange(from=1L) public final int param;
+                    property @IntRange(from=1L) public int param;
                   }
                 }
             """
@@ -4433,10 +4119,9 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
+            // Access androidx.annotation.IntRange
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api =
                 """
                 // Signature format: 2.0
@@ -4454,7 +4139,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Kotlin properties with overriding get`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -4469,20 +4154,19 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
+            // Access androidx.annotation.IntRange
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class KotlinClass {
                     ctor public KotlinClass();
                     method public boolean getPropertyWithGetter();
                     method public boolean getPropertyWithNoGetter();
-                    property public final boolean propertyWithGetter;
-                    property public final boolean propertyWithNoGetter;
+                    property public boolean propertyWithGetter;
+                    property public boolean propertyWithNoGetter;
                   }
                 }
             """
@@ -4493,7 +4177,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Constructor property tracking`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -4519,7 +4203,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public abstract sealed class MyClass {
                     method public final int getFirstConstructorProperty();
@@ -4534,54 +4218,16 @@ class ApiFileTest : DriverTest() {
                     method public String component1();
                     method public test.pkg.MyDataClass copy(String constructorProperty, String internalConstructorProperty);
                     method public String getConstructorProperty();
-                    property public final String constructorProperty;
+                    property public String constructorProperty;
                   }
                 }
             """
         )
     }
 
-    @Test
-    fun `Concise default Values Names in Java`() {
-        // Java code which explicitly specifies parameter names
-        check(
-            format = FileFormat.V4,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import androidx.annotation.DefaultValue;
-
-                    public class Foo {
-                        public void foo(
-                            @DefaultValue("null") String prefix,
-                            @DefaultValue("\"Hello World\"") String greeting,
-                            @DefaultValue("42") int meaning) {
-                        }
-                    }
-                    """
-                    ),
-                    supportDefaultValue,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-            api =
-                """
-                // Signature format: 4.0
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public void foo(optional String!, optional String!, optional int);
-                  }
-                }
-                 """,
-        )
-    }
-
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
-    fun `Concise default Values and Names in Kotlin`() {
+    fun `Default Values and Names in Kotlin`() {
         // Kotlin code which explicitly specifies parameter names
         check(
             format = FileFormat.V4,
@@ -4627,8 +4273,6 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -4655,7 +4299,7 @@ class ApiFileTest : DriverTest() {
 
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
-    fun `Concise default Values in Kotlin for expressions`() {
+    fun `Default Values in Kotlin for expressions`() {
         // Testing trickier default values; regression test for problem
         // observed in androidx.core.util with LruCache
         check(
@@ -4716,8 +4360,6 @@ class ApiFileTest : DriverTest() {
                     ),
                     androidxNullableSource,
                     androidxNonNullSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -4797,8 +4439,8 @@ class ApiFileTest : DriverTest() {
                     method public float getValue();
                     method public inline operator float minus(float other);
                     method public inline operator float plus(float other);
-                    property public final int someBits;
-                    property public final float value;
+                    property public int someBits;
+                    property public float value;
                   }
                 }
             """
@@ -4842,8 +4484,8 @@ class ApiFileTest : DriverTest() {
                     method public float getValue();
                     method public inline operator float minus(float other);
                     method public inline operator float plus(float other);
-                    property public final int someBits;
-                    property public final float value;
+                    property public int someBits;
+                    property public float value;
                   }
                   public final class DpKt {
                     method public static void box(float p);
@@ -4857,7 +4499,7 @@ class ApiFileTest : DriverTest() {
     @Test
     fun `Kotlin doesn't expand java named constants`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -4869,7 +4511,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface Foo {
                     method public abstract long bar() default java.lang.Long.MIN_VALUE;
@@ -4947,7 +4589,7 @@ class ApiFileTest : DriverTest() {
 
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
-    fun `Kotlin expect-actual with JvmOverloads`() {
+    fun `Kotlin expect-actual with JvmOverloads constructors`() {
         check(
             format = FileFormat.V4,
             sourceFiles =
@@ -5025,11 +4667,70 @@ class ApiFileTest : DriverTest() {
         )
     }
 
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Kotlin expect-actual with JvmOverloads methods`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    import kotlin.jvm.JvmOverloads
+                    expect class Foo {
+                        @JvmOverloads
+                        fun allOptionalJvmOverloads(p1: Int = 0, p2: Int = 0, p3: Int = 0)
+
+                        @JvmOverloads
+                        fun someOptionalJvmOverloads(p1: Int, p2: Int = 0, p3: Int, p4: Int = 0, p5: Int)
+                    }
+                """
+            )
+        // @JvmOverloads needs to be annotated on the actual fun too, but the default values can't
+        // be present on actuals
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    actual class Foo {
+                        @JvmOverloads
+                        actual fun allOptionalJvmOverloads(p1: Int, p2: Int, p3: Int) = Unit
+
+                        @JvmOverloads
+                        actual fun someOptionalJvmOverloads(p1: Int, p2: Int, p3: Int, p4: Int, p5: Int) = Unit
+                    }
+                """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public void allOptionalJvmOverloads();
+                        method public void allOptionalJvmOverloads(optional int p1);
+                        method public void allOptionalJvmOverloads(optional int p1, optional int p2);
+                        method public void allOptionalJvmOverloads(optional int p1, optional int p2, optional int p3);
+                        method public void someOptionalJvmOverloads(int p1, int p3, int p5);
+                        method public void someOptionalJvmOverloads(int p1, optional int p2, int p3, int p5);
+                        method public void someOptionalJvmOverloads(int p1, optional int p2, int p3, optional int p4, int p5);
+                      }
+                    }
+                """
+        )
+    }
+
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Kotlin public methods with DeprecationLevel HIDDEN are public API`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -5060,7 +4761,7 @@ class ApiFileTest : DriverTest() {
                 ),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class TestKt {
                     method @Deprecated public static void myMethod();
@@ -5076,7 +4777,7 @@ class ApiFileTest : DriverTest() {
     fun `Annotations aren't dropped when DeprecationLevel is HIDDEN`() {
         // Regression test for http://b/219792969
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -5103,18 +4804,16 @@ class ApiFileTest : DriverTest() {
                         fun returnsNonNullImplicitly() = "42"
                     """
                     ),
-                    androidxIntRangeSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
+            // Access androidx.annotation.IntRange
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api =
                 """
-                // Signature format: 2.0
                 package test.pkg {
                   public final class TestKt {
                     method @Deprecated @IntRange(from=0L) public static void myMethod();
-                    method @Deprecated @NonNull public static String returnsNonNull();
-                    method @Deprecated @NonNull public static String returnsNonNullImplicitly();
+                    method @Deprecated public static String returnsNonNull();
+                    method @Deprecated public static String returnsNonNullImplicitly();
                   }
                 }
             """
@@ -5138,8 +4837,6 @@ class ApiFileTest : DriverTest() {
                 """
                     ),
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             format = FileFormat.V4,
             api =
@@ -5148,7 +4845,7 @@ class ApiFileTest : DriverTest() {
                 package test.pkg {
                   @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY}) public final class TestKt {
                     method public static void bar();
-                    property public static final String CONST;
+                    property public static String CONST;
                     field public static final String CONST = "Hello";
                   }
                 }
@@ -5172,8 +4869,6 @@ class ApiFileTest : DriverTest() {
                 """
                     ),
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             extraArguments = arrayOf("--show-unannotated"),
             hideAnnotations =
@@ -5239,7 +4934,7 @@ class ApiFileTest : DriverTest() {
                     ctor public Foo(int bar);
                     method public int getBar();
                     method public void setBar(int);
-                    property public final int bar;
+                    property public int bar;
                   }
                 }
             """
@@ -5304,9 +4999,9 @@ class ApiFileTest : DriverTest() {
                     field public static final int SP = 2; // 0x2
                   }
                   public static final class Dimension.Companion {
-                    property public static final int DP;
-                    property public static final int PX;
-                    property public static final int SP;
+                    property public static int DP;
+                    property public static int PX;
+                    property public static int SP;
                     field public static final int DP = 0; // 0x0
                     field public static final int PX = 1; // 0x1
                     field public static final int SP = 2; // 0x2
@@ -5479,10 +5174,9 @@ class ApiFileTest : DriverTest() {
                     )
                     """
                     ),
-                    androidxIntRangeSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
+            // Access androidx.annotation.IntRange
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api =
                 """
                 package test.pkg {
@@ -5517,7 +5211,7 @@ class ApiFileTest : DriverTest() {
                         private val baz
 
                         class Toast {
-                            val foo: Int
+                            val foo: Int = 0
                         }
                     """
                     ),
@@ -5619,8 +5313,6 @@ class ApiFileTest : DriverTest() {
                     ),
                     restrictToSource,
                     visibleForTestingSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -5658,7 +5350,7 @@ class ApiFileTest : DriverTest() {
                   public final class Toast {
                     ctor public Toast();
                     method public int getFoo();
-                    property public final int foo;
+                    property public int foo;
                   }
                 }
             """
@@ -5707,8 +5399,8 @@ class ApiFileTest : DriverTest() {
                     method public static void bar(String);
                     method public static void baz(String);
                     method public static int getNonConstVal();
-                    property public static final int constVal;
-                    property public static final int nonConstVal;
+                    property public static int constVal;
+                    property public static int nonConstVal;
                     field public static final int constVal = 4; // 0x4
                   }
                 }
@@ -5833,8 +5525,6 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -5927,8 +5617,6 @@ class ApiFileTest : DriverTest() {
                     ),
                     systemApiSource,
                     testApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -5996,8 +5684,6 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             removedApi =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFlagsCreatorTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFlagsCreatorTest.kt
new file mode 100644
index 000000000..07eb00a01
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFlagsCreatorTest.kt
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.config.ApiFlagConfig
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.IMMUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.MUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Status.DISABLED
+import com.android.tools.metalava.config.ApiFlagConfig.Status.ENABLED
+import com.android.tools.metalava.config.ApiFlagsConfig
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import org.junit.Test
+
+class ApiFlagsCreatorTest {
+    @Test
+    fun `Test creation from config`() {
+        val apiFlagsConfig =
+            ApiFlagsConfig(
+                flags =
+                    listOf(
+                        ApiFlagConfig(
+                            pkg = "test.pkg",
+                            name = "flag1",
+                            mutability = MUTABLE,
+                            status = DISABLED
+                        ),
+                        ApiFlagConfig(
+                            pkg = "test.pkg",
+                            name = "flag2",
+                            mutability = IMMUTABLE,
+                            status = DISABLED
+                        ),
+                        ApiFlagConfig(
+                            pkg = "test.pkg",
+                            name = "flag3",
+                            mutability = MUTABLE,
+                            status = ENABLED
+                        ),
+                        ApiFlagConfig(
+                            pkg = "test.pkg",
+                            name = "flag4",
+                            mutability = IMMUTABLE,
+                            status = ENABLED
+                        ),
+                    ),
+            )
+
+        val apiFlags = ApiFlagsCreator.createFromConfig(apiFlagsConfig)
+
+        val expected =
+            mapOf(
+                "test.pkg.flag1" to ApiFlag.KEEP_FLAGGED_API,
+                // No test.pkg.flag2 as that is disabled and ApiFlags will default to disabled.
+                "test.pkg.flag3" to ApiFlag.KEEP_FLAGGED_API,
+                "test.pkg.flag4" to ApiFlag.FINALIZE_FLAGGED_API,
+            )
+        assertEquals(expected, apiFlags!!.byQualifiedName)
+    }
+
+    @Test
+    fun `Test null config`() {
+        val apiFlags = ApiFlagsCreator.createFromConfig(null)
+        assertNull(apiFlags)
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
index 2a5ca1d60..23bdb1444 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
@@ -44,17 +44,17 @@ class ApiFromTextTest : DriverTest() {
     fun `Handle lambdas as default values`() {
         val source =
             """
-            // Signature format: 3.0
+            // Signature format: 4.0
             package androidx.collection {
               public final class LruCacheKt {
                 ctor public LruCacheKt();
-                method public static <K, V> androidx.collection.LruCache<K,V> lruCache(int maxSize, kotlin.jvm.functions.Function2<? super K,? super V,java.lang.Integer> sizeOf = { _, _ -> 1 }, kotlin.jvm.functions.Function1<? super K,? extends V> create = { null as V? }, kotlin.jvm.functions.Function4<? super java.lang.Boolean,? super K,? super V,? super V,kotlin.Unit> onEntryRemoved = { _, _, _, _ -> });
+                method public static <K, V> androidx.collection.LruCache<K,V> lruCache(int maxSize, optional kotlin.jvm.functions.Function2<? super K,? super V,java.lang.Integer> sizeOf, optional kotlin.jvm.functions.Function1<? super K,? extends V> create, optional kotlin.jvm.functions.Function4<? super java.lang.Boolean,? super K,? super V,? super V,kotlin.Unit> onEntryRemoved);
               }
             }
         """
 
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             signatureSource = source,
             api = source,
         )
@@ -64,16 +64,16 @@ class ApiFromTextTest : DriverTest() {
     fun `Invoking function with multiple parameters as parameter default value`() {
         val source =
             """
-            // Signature format: 3.0
+            // Signature format: 4.0
             package abc {
               public final class PopupKt {
-                method public static void DropdownPopup(Type ident = SomeFunc(SomeVal, SomeVal));
+                method public static void DropdownPopup(optional String ident);
               }
             }
         """
 
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             signatureSource = source,
             api = source,
         )
@@ -83,58 +83,58 @@ class ApiFromTextTest : DriverTest() {
     fun `Handle enum constants as default values`() {
         val source =
             """
-            // Signature format: 3.0
+            // Signature format: 4.0
             package test.pkg {
               public final class Foo {
                 ctor public Foo();
-                method public android.graphics.Bitmap? drawToBitmap(android.view.View, android.graphics.Bitmap.Config config = android.graphics.Bitmap.Config.ARGB_8888);
-                method public void emptyLambda(kotlin.jvm.functions.Function0<kotlin.Unit> sizeOf = {});
-                method public void method1(int p = 42, Integer? int2 = null, int p1 = 42, String str = "hello world", java.lang.String... args);
-                method public void method2(int p, int int2 = (2 * int) * some.other.pkg.Constants.Misc.SIZE);
-                method public void method3(String str, int p, int int2 = double(int) + str.length);
+                method public android.graphics.Bitmap? drawToBitmap(android.view.View, optional android.graphics.Bitmap.Config config);
+                method public void emptyLambda(optional kotlin.jvm.functions.Function0<kotlin.Unit> sizeOf);
+                method public void method1(optional int p, optional Integer? int2, optional int p1, optional String str, java.lang.String... args);
+                method public void method2(int p, optional int int2);
+                method public void method3(String str, int p, optional int int2);
                 field public static final test.pkg.Foo.Companion! Companion;
               }
               public static final class Foo.Companion {
                 method public int double(int p);
-                method public void print(test.pkg.Foo foo = test.pkg.Foo());
+                method public void print(optional test.pkg.Foo foo);
               }
               public final class LruCacheKt {
                 ctor public LruCacheKt();
-                method public static <K, V> android.util.LruCache<K,V> lruCache(int maxSize, kotlin.jvm.functions.Function2<? super K,? super V,java.lang.Integer> sizeOf = { _, _ -> 1 }, kotlin.jvm.functions.Function1<? super K,? extends V> create = { (V)null }, kotlin.jvm.functions.Function4<? super java.lang.Boolean,? super K,? super V,? super V,kotlin.Unit> onEntryRemoved = { _, _, _, _ ->  });
+                method public static <K, V> android.util.LruCache<K,V> lruCache(int maxSize, optional kotlin.jvm.functions.Function2<? super K,? super V,java.lang.Integer> sizeOf, optional kotlin.jvm.functions.Function1<? super K,? extends V> create, optional kotlin.jvm.functions.Function4<? super java.lang.Boolean,? super K,? super V,? super V,kotlin.Unit> onEntryRemoved);
               }
             }
             """
 
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
     fun `Handle complex expressions as default values`() {
         val source =
             """
-            // Signature format: 3.0
+            // Signature format: 4.0
             package androidx.paging {
               public final class PagedListConfigKt {
                 ctor public PagedListConfigKt();
-                method public static androidx.paging.PagedList.Config Config(int pageSize, int prefetchDistance = pageSize, boolean enablePlaceholders = true, int initialLoadSizeHint = pageSize * PagedList.Config.Builder.DEFAULT_INITIAL_PAGE_MULTIPLIER, int maxSize = PagedList.Config.MAX_SIZE_UNBOUNDED);
+                method public static androidx.paging.PagedList.Config Config(int pageSize, optional int prefetchDistance, optional boolean enablePlaceholders, optional int initialLoadSizeHint, optional int maxSize);
               }
               public final class PagedListKt {
                 ctor public PagedListKt();
-                method public static <Key, Value> androidx.paging.PagedList<Value> PagedList(androidx.paging.DataSource<Key,Value> dataSource, androidx.paging.PagedList.Config config, java.util.concurrent.Executor notifyExecutor, java.util.concurrent.Executor fetchExecutor, androidx.paging.PagedList.BoundaryCallback<Value>? boundaryCallback = null, Key? initialKey = null);
+                method public static <Key, Value> androidx.paging.PagedList<Value> PagedList(androidx.paging.DataSource<Key,Value> dataSource, androidx.paging.PagedList.Config config, java.util.concurrent.Executor notifyExecutor, java.util.concurrent.Executor fetchExecutor, optional androidx.paging.PagedList.BoundaryCallback<Value>? boundaryCallback, optional Key? initialKey);
               }
             }
             package test.pkg {
               public final class Foo {
                 ctor public Foo();
-                method public void method1(int p = 42, Integer? int2 = null, int p1 = 42, String str = "hello world", java.lang.String... args);
-                method public void method2(int p, int int2 = (2 * int) * some.other.pkg.Constants.Misc.SIZE);
-                method public void method3(str: String = "unbalanced), string", str2: String = ",");
+                method public void method1(optional int p, optional Integer? int2, optional int p1, optional String str, java.lang.String... args);
+                method public void method2(int p, optional int int2);
+                method public void method3(optional String str, optional String str2);
               }
             }
         """
 
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             signatureSource = source,
             api = source,
         )
@@ -240,7 +240,7 @@ class ApiFromTextTest : DriverTest() {
                 package test.pkg {
                   public final class Foo {
                     ctor public Foo();
-                    method public void error(int p = "42", Integer int2 = "null", int p1 = "42", vararg String args);
+                    method public void error(optional int p, optional Integer int2, optional int p1, vararg String args);
                   }
                 }
                 """
@@ -418,7 +418,7 @@ class ApiFromTextTest : DriverTest() {
         @Language("TEXT")
         val source =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @UiThread public class MyTest {
                     ctor public MyTest();
@@ -429,7 +429,7 @@ class ApiFromTextTest : DriverTest() {
                 }
                 """
 
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
@@ -519,27 +519,27 @@ class ApiFromTextTest : DriverTest() {
         @Language("TEXT")
         val source =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class Foo {
                     ctor public Foo();
-                    method public final void error(int p = 42, Integer? int2 = null);
+                    method public final void error(optional int p, optional Integer? int2);
                   }
                   public class Foo2 {
                     ctor public Foo2();
-                    method public void foo(String! = null, String! = "(Hello) World", int = 42);
+                    method public void foo(optional String!, optional String!, optional int);
                   }
                 }
                 """
 
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
     fun `Signatures with default annotation method values`() {
         val source =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package libcore.util {
                   public @interface NonNull {
                     method public abstract int from() default java.lang.Integer.MIN_VALUE;
@@ -550,7 +550,7 @@ class ApiFromTextTest : DriverTest() {
                 }
                 """
 
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
@@ -598,7 +598,7 @@ class ApiFromTextTest : DriverTest() {
     fun `Deprecated enum constant`() {
         val source =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.annotation {
                   @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target({java.lang.annotation.ElementType.ANNOTATION_TYPE, java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.PACKAGE}) public @interface RestrictTo {
                     method public abstract androidx.annotation.RestrictTo.Scope[] value();
@@ -613,14 +613,14 @@ class ApiFromTextTest : DriverTest() {
                 }
                 """
 
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
-    fun `Type parameters in v3 format`() {
+    fun `Type parameters in v4 format`() {
         val source =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.collection {
                   public class Constants {
                     field public static final String GOOD_IRI_CHAR = "a-zA-Z0-9\u00a0-\ud7ff\uf900-\ufdcf\ufdf0-\uffef";
@@ -654,7 +654,7 @@ class ApiFromTextTest : DriverTest() {
                   }
                 }
                 """
-        check(format = FileFormat.V3, signatureSource = source, api = source)
+        check(format = FileFormat.V4, signatureSource = source, api = source)
     }
 
     @Test
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
index d5cf672b8..99d4398c7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
@@ -16,8 +16,16 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.apilevels.GenerateApiHistoryConfig
+import com.android.tools.metalava.apilevels.VersionedApi
 import com.android.tools.metalava.cli.common.BaseOptionGroupTest
+import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.SignatureFileLoader
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.text.SignatureFile
 import com.google.common.truth.Truth.assertThat
+import org.junit.Assert.assertThrows
 import org.junit.Test
 
 val API_LEVELS_GENERATION_OPTIONS_HELP =
@@ -27,27 +35,28 @@ Api Levels Generation:
   Options controlling the API levels file, e.g. `api-versions.xml` file.
 
   --generate-api-levels <xmlfile>            Reads android.jar SDK files and generates an XML file recording the API
-                                             level for each class, method and field
+                                             level for each class, method and field. The --current-version must also be
+                                             provided and must be greater than or equal to 27.
   --remove-missing-class-references-in-api-levels
                                              Removes references to missing classes when generating the API levels XML
                                              file. This can happen when generating the XML file for the non-updatable
                                              portions of the module-lib sdk, as those non-updatable portions can
                                              reference classes that are part of an updatable apex.
-  --first-version <numeric-version>          Sets the first API level to generate an API database from. (default: 1)
-  --current-version <numeric-version>        Sets the current API level of the current source code. Must be greater than
-                                             or equal to 27.
+  --first-version <api-version>              Sets the first API version to include in the API history file. See
+                                             --current-version for acceptable `<api-version>`s. (default: 1)
+  --current-version <api-version>            Sets the current API version of the current source code. This supports a
+                                             single integer level, `major.minor`, `major.minor.patch` and
+                                             `major.minor.patch-quality` formats. Where `major`, `minor` and `patch` are
+                                             all non-negative integers and `quality` is an alphanumeric string.
   --current-codename <version-codename>      Sets the code name for the current source code.
-  --android-jar-pattern <android-jar-pattern>
-                                             Pattern to use to locate Android JAR files. Each pattern must contain a %
-                                             character that will be replaced with each API level that is being included
-                                             and if the result is an existing jar file then it will be taken as the
-                                             definition of the API at that level.
-  --sdk-extensions-root <sdk-jar-root>       Points to root of prebuilt extension SDK jars, if any. This directory is
-                                             expected to contain snapshots of historical extension SDK versions in the
-                                             form of stub jars. The paths should be on the format
-                                             \"<int>/public/<module-name>.jar\", where <int> corresponds to the
-                                             extension SDK version, and <module-name> to the name of the mainline
-                                             module.
+  --android-jar-pattern <historical-api-pattern>
+                                             Pattern to use to locate Android JAR files. Must end with `.jar`.
+
+                                             See `metalava help historical-api-patterns` for more information.
+  --api-version-signature-pattern <historical-api-pattern>
+                                             Pattern to use to locate signature files. Typically ends with `.txt`.
+
+                                             See `metalava help historical-api-patterns` for more information.
   --sdk-extensions-info <sdk-info-file>      Points to map of extension SDK APIs to include, if any. The file is a plain
                                              text file and describes, per extension SDK, what APIs from that extension
                                              to include in the file created via --generate-api-levels. The format of
@@ -62,6 +71,10 @@ Api Levels Generation:
                                              SDK). Fields are separated by whitespace. A mainline module may be listed
                                              multiple times. The special pattern \"*\" refers to all APIs in the given
                                              mainline module. Lines beginning with # are comments.
+
+                                             If specified then the --android-jar-pattern must include at least one
+                                             pattern that uses `{version:extension}` and `{module}` placeholders and
+                                             that pattern must match at least one file.
   --generate-api-version-history <output-file>
                                              Reads API signature files and generates a JSON or XML file depending on the
                                              extension, which must be one of `json` or `xml` respectively. The JSON file
@@ -74,9 +87,6 @@ Api Levels Generation:
                                              current API version, which will be parsed from the provided source files.
                                              Not required to generate API version JSON if the current version is the
                                              only version.
-  --api-version-names <api-versions>         An ordered list of strings with the names to use for the API versions from
-                                             --api-version-signature-files, and the name of the current API version.
-                                             Required for --generate-api-version-history.
     """
         .trimIndent()
 
@@ -86,21 +96,383 @@ class ApiLevelsGenerationOptionsTest :
     ) {
     override fun createOptions() = ApiLevelsGenerationOptions()
 
+    private fun fakeSignatureFileLoader() =
+        object : SignatureFileLoader {
+            override fun load(signatureFiles: List<SignatureFile>, classResolver: ClassResolver?) =
+                error("Fake signature file loader cannot load signature files")
+        }
+
+    /** Get an optional [GenerateApiHistoryConfig] for a fake set of signature files. */
+    private fun ApiLevelsGenerationOptions.fromFakeSignatureFiles() =
+        fromSignatureFilesConfig(
+            signatureFileLoader = fakeSignatureFileLoader(),
+            codebaseFragmentProvider = {
+                error("Fake CodebaseFragment provider cannot create CodebaseFragment")
+            },
+        )
+
+    /**
+     * Get an optional [GenerateApiHistoryConfig] from
+     * [ApiLevelsGenerationOptions.forAndroidConfig].
+     */
+    private fun ApiLevelsGenerationOptions.testForAndroidConfig() =
+        forAndroidConfig(fakeSignatureFileLoader()) { error("no codebase fragment") }
+
+    @Test
+    fun `Test current version supports major-minor`() {
+        runTest(ARG_CURRENT_VERSION, "1.2") {
+            assertThat(options.currentApiVersion.toString()).isEqualTo("1.2")
+        }
+    }
+
+    @Test
+    fun `Test current version supports major-minor-patch`() {
+        runTest(ARG_CURRENT_VERSION, "1.2.3") {
+            assertThat(options.currentApiVersion.toString()).isEqualTo("1.2.3")
+        }
+    }
+
+    @Test
+    fun `Test current version supports major-minor-patch-preRelease`() {
+        runTest(ARG_CURRENT_VERSION, "1.2.3-beta01") {
+            assertThat(options.currentApiVersion.toString()).isEqualTo("1.2.3-beta01")
+        }
+    }
+
+    @Test
+    fun `Test --current-version used alone with --generate-api-version-history`() {
+        val apiVersionsJson = newFile("api-versions.json")
+        runTest(
+            ARG_CURRENT_VERSION,
+            "1.2.3-beta01",
+            ARG_GENERATE_API_VERSION_HISTORY,
+            apiVersionsJson.path
+        ) {
+            val apiHistoryConfig = options.fromFakeSignatureFiles()
+            assertThat(apiHistoryConfig).isNotNull()
+            val apiVersions = apiHistoryConfig!!.versionedApis.map { it.apiVersion }.joinToString()
+            assertThat(apiVersions).isEqualTo("1.2.3-beta01")
+        }
+    }
+
+    @Test
+    fun `Test --current-version used with --generate-api-version-history and --api-version-signature-pattern`() {
+        val signatureFile = newFile("1.2.0-alpha01/api.txt")
+        val apiVersionsJson = temporaryFolder.newFile("api-versions.json")
+        runTest(
+            ARG_CURRENT_VERSION,
+            "1.2.3-beta01",
+            ARG_GENERATE_API_VERSION_HISTORY,
+            apiVersionsJson.path,
+            ARG_API_VERSION_SIGNATURE_FILES,
+            signatureFile.path,
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "${temporaryFolder.root}/{version:major.minor.patch}*/api.txt",
+        ) {
+            val apiHistoryConfig = options.fromFakeSignatureFiles()
+            assertThat(apiHistoryConfig).isNotNull()
+            val apiVersions = apiHistoryConfig!!.versionedApis.map { it.apiVersion }.joinToString()
+            assertThat(apiVersions).isEqualTo("1.2.0, 1.2.3-beta01")
+        }
+    }
+
     @Test
-    fun `sdkJarRoot without sdkInfoFile`() {
-        val file = temporaryFolder.newFolder("sdk-jar-root")
-        runTest(ARG_SDK_JAR_ROOT, file.path) {
-            assertThat(stderr)
-                .isEqualTo("--sdk-extensions-root and --sdk-extensions-info must both be supplied")
+    fun `Test --api-version-signature-pattern without --current-version`() {
+        val signatureFile = newFile("1.2.0/api.txt")
+        val apiVersionsJson = temporaryFolder.newFile("api-versions.json")
+        runTest(
+            ARG_GENERATE_API_VERSION_HISTORY,
+            apiVersionsJson.path,
+            ARG_API_VERSION_SIGNATURE_FILES,
+            signatureFile.path,
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "${temporaryFolder.root}:/{version:major.minor.patch}/api.txt",
+        ) {
+            val exception =
+                assertThrows(MetalavaCliException::class.java) { options.fromFakeSignatureFiles() }
+            assertThat(exception.message)
+                .isEqualTo("Must specify --current-version with --api-version-signature-pattern")
         }
     }
 
     @Test
-    fun `sdkInfoFile without sdkJarRoot`() {
-        val file = temporaryFolder.newFile("sdk-info-file.xml")
-        runTest(ARG_SDK_INFO_FILE, file.path) {
-            assertThat(stderr)
-                .isEqualTo("--sdk-extensions-root and --sdk-extensions-info must both be supplied")
+    fun `Test --api-version-signature-pattern with no matching pattern`() {
+        val signatureFiles =
+            listOf(
+                newFile("1.1.0/api.txt"),
+                // This will not be matched by the pattern.
+                newFile("will/not/match/api.txt"),
+            )
+        val apiVersionsJson = temporaryFolder.newFile("api-versions.json")
+        runTest(
+            ARG_CURRENT_VERSION,
+            "1.2.3-beta01",
+            ARG_GENERATE_API_VERSION_HISTORY,
+            apiVersionsJson.path,
+            ARG_API_VERSION_SIGNATURE_FILES,
+            signatureFiles.joinToString(":"),
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "${temporaryFolder.root}/{version:major.minor.patch}/api.txt",
+        ) {
+            val exception =
+                assertThrows(MetalavaCliException::class.java) { options.fromFakeSignatureFiles() }
+            assertThat(cleanupString(exception.message!!))
+                .isEqualTo(
+                    """
+                        --api-version-signature-files: The following files were unmatched by a signature pattern:
+                            TESTROOT/will/not/match/api.txt
+                    """
+                        .trimIndent()
+                )
+        }
+    }
+
+    /** Create a simple `sdk-extension-info.xml` for testing. */
+    private fun createSdkExtensionsInfoXml() =
+        temporaryFolder.newFile("sdk-extensions-info.xml").apply {
+            writeText(
+                """
+                        <?xml version="1.0" encoding="utf-8"?>
+                        <sdk-extensions-info>
+                        <sdk id="7"
+                             shortname="seven"
+                             name="Seven Extensions"
+                             reference="Seven" />
+                        <symbol jar="bar" pattern="foo" sdks="seven" />
+                        <symbol jar="baz" pattern="foo" sdks="seven" />
+                        <symbol jar="foo" pattern="foo" sdks="seven" />
+                        </sdk-extensions-info>
+                    """
+                    .trimIndent()
+            )
+        }
+
+    /** Dump the contents of this list to a string. */
+    private fun List<VersionedApi>.dump() = cleanupString(joinToString("\n"))
+
+    @Test
+    fun `Test extension jar files in forAndroidConfig`() {
+        val root = buildFileStructure {
+            dir("1") {
+                dir("public") {
+                    emptyFile("foo.jar")
+                    emptyFile("bar.jar")
+                }
+            }
+            dir("2") {
+                dir("public") {
+                    emptyFile("foo.jar")
+                    emptyFile("bar.jar")
+                    emptyFile("baz.jar")
+                }
+            }
+        }
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        val sdkExtensionsInfoXml = createSdkExtensionsInfoXml()
+        runTest(
+            ARG_CURRENT_VERSION,
+            "30",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/{version:extension}/*/{module}.jar",
+            ARG_SDK_INFO_FILE,
+            sdkExtensionsInfoXml.path,
+        ) {
+            val apiHistoryConfig = options.testForAndroidConfig()
+            assertThat(apiHistoryConfig).isNotNull()
+
+            // Compute the list of versioned files.
+            assertThat(apiHistoryConfig!!.versionedApis.dump())
+                .isEqualTo(
+                    """
+                        VersionedSourceApi(version=30)
+                        VersionedJarApi(jar=TESTROOT/1/public/bar.jar, updater=ExtensionUpdater(extVersion=1, module=bar, nextSdkVersion=30))
+                        VersionedJarApi(jar=TESTROOT/2/public/bar.jar, updater=ExtensionUpdater(extVersion=2, module=bar, nextSdkVersion=30))
+                        VersionedJarApi(jar=TESTROOT/2/public/baz.jar, updater=ExtensionUpdater(extVersion=2, module=baz, nextSdkVersion=30))
+                        VersionedJarApi(jar=TESTROOT/1/public/foo.jar, updater=ExtensionUpdater(extVersion=1, module=foo, nextSdkVersion=30))
+                        VersionedJarApi(jar=TESTROOT/2/public/foo.jar, updater=ExtensionUpdater(extVersion=2, module=foo, nextSdkVersion=30))
+                    """
+                        .trimIndent()
+                )
+        }
+    }
+
+    @Test
+    fun `Test signature files in forAndroidConfig`() {
+        val root = buildFileStructure {
+            dir("1") { dir("public") { emptyFile("api.txt") } }
+            dir("1.1") {
+                dir("public") { emptyFile("api.txt") }
+                dir("system") { emptyFile("api.txt") }
+            }
+            dir("2") {
+                dir("public") { emptyFile("api.txt") }
+                dir("system") { emptyFile("api.txt") }
+            }
+            dir("extensions") {
+                dir("1") {
+                    dir("public") {
+                        emptyFile("foo.txt")
+                        emptyFile("bar.txt")
+                    }
+                    dir("system") { emptyFile("foo.txt") }
+                }
+                dir("2") {
+                    dir("public") {
+                        emptyFile("foo.txt")
+                        emptyFile("bar.txt")
+                        emptyFile("baz.txt")
+                    }
+                    dir("system") { emptyFile("foo.txt") }
+                }
+            }
+        }
+
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface("public")
+                createSurface("system", isMain = true)
+            }
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        val sdkExtensionsInfoXml = createSdkExtensionsInfoXml()
+        runTest(
+            ARG_CURRENT_VERSION,
+            "30",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "$root/{version:major.minor?}/{surface}/api.txt",
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "$root/extensions/{version:extension}/{surface}/{module}.txt",
+            ARG_SDK_INFO_FILE,
+            sdkExtensionsInfoXml.path,
+            optionGroup = ApiLevelsGenerationOptions(apiSurfacesProvider = { apiSurfaces }),
+        ) {
+            val apiHistoryConfig = options.testForAndroidConfig()
+            assertThat(apiHistoryConfig).isNotNull()
+
+            // Compute the list of versioned files.
+            assertThat(apiHistoryConfig!!.versionedApis.dump())
+                .isEqualTo(
+                    """
+                        VersionedSignatureApi(files=TESTROOT/1/public/api.txt, updater=ApiVersionUpdater(version=1))
+                        VersionedSignatureApi(files=TESTROOT/1.1/{public,system}/api.txt, updater=ApiVersionUpdater(version=1.1))
+                        VersionedSignatureApi(files=TESTROOT/2/{public,system}/api.txt, updater=ApiVersionUpdater(version=2))
+                        VersionedSourceApi(version=30)
+                        VersionedSignatureApi(files=TESTROOT/extensions/1/public/bar.txt, updater=ExtensionUpdater(extVersion=1, module=bar, nextSdkVersion=30))
+                        VersionedSignatureApi(files=TESTROOT/extensions/2/public/bar.txt, updater=ExtensionUpdater(extVersion=2, module=bar, nextSdkVersion=30))
+                        VersionedSignatureApi(files=TESTROOT/extensions/2/public/baz.txt, updater=ExtensionUpdater(extVersion=2, module=baz, nextSdkVersion=30))
+                        VersionedSignatureApi(files=TESTROOT/extensions/1/{public,system}/foo.txt, updater=ExtensionUpdater(extVersion=1, module=foo, nextSdkVersion=30))
+                        VersionedSignatureApi(files=TESTROOT/extensions/2/{public,system}/foo.txt, updater=ExtensionUpdater(extVersion=2, module=foo, nextSdkVersion=30))
+                    """
+                        .trimIndent()
+                )
+        }
+    }
+
+    @Test
+    fun `Test no extension jar files found in forAndroidConfig`() {
+        val root = getOrCreateFolder()
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        val sdkExtensionsInfoXml = createSdkExtensionsInfoXml()
+        runTest(
+            ARG_CURRENT_VERSION,
+            "30",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/{version:extension}/*/{module}.jar",
+            ARG_SDK_INFO_FILE,
+            sdkExtensionsInfoXml.path,
+        ) {
+            val exception =
+                assertThrows(IllegalArgumentException::class.java) {
+                    options.testForAndroidConfig()
+                }
+
+            assertThat(exception.message)
+                .isEqualTo(
+                    "no extension api files found by $root/{version:extension}/*/{module}.jar"
+                )
+        }
+    }
+
+    @Test
+    fun `Test do not mix signature and android jar patterns in forAndroidConfig`() {
+        val root = getOrCreateFolder()
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        val sdkExtensionsInfoXml = createSdkExtensionsInfoXml()
+        runTest(
+            ARG_CURRENT_VERSION,
+            "30",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/{version:extension}/*/{module}.jar",
+            ARG_API_VERSION_SIGNATURE_PATTERN,
+            "$root/{version:extension}/*/{module}.txt",
+            ARG_SDK_INFO_FILE,
+            sdkExtensionsInfoXml.path,
+        ) {
+            val exception =
+                assertThrows(MetalavaCliException::class.java) { options.testForAndroidConfig() }
+
+            assertThat(exception.message)
+                .isEqualTo(
+                    "Cannot combine --api-version-signature-pattern with --android-jar-pattern"
+                )
+        }
+    }
+
+    @Test
+    fun `Test generating api versions during finalization`() {
+        val root = buildFileStructure {
+            dir("31") { dir("public") { emptyFile("android.jar") } }
+            dir("32") { dir("public") { emptyFile("android.jar") } }
+            dir("extensions") {
+                dir("1") { dir("public") { emptyFile("bar.jar") } }
+                dir("2") {
+                    dir("public") {
+                        emptyFile("bar.jar")
+                        emptyFile("foo.jar")
+                    }
+                }
+            }
+        }
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        val sdkExtensionsInfoXml = createSdkExtensionsInfoXml()
+        runTest(
+            ARG_CURRENT_VERSION,
+            "33",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/{version:level}/*/android.jar",
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/extensions/{version:extension}/*/{module}.jar",
+            ARG_SDK_INFO_FILE,
+            sdkExtensionsInfoXml.path,
+        ) {
+            val apiHistoryConfig = options.testForAndroidConfig()
+            assertThat(apiHistoryConfig).isNotNull()
+
+            assertThat(apiHistoryConfig!!.versionedApis.dump())
+                .isEqualTo(
+                    """
+                        VersionedJarApi(jar=TESTROOT/31/public/android.jar, updater=ApiVersionUpdater(version=31))
+                        VersionedJarApi(jar=TESTROOT/32/public/android.jar, updater=ApiVersionUpdater(version=32))
+                        VersionedSourceApi(version=33)
+                        VersionedJarApi(jar=TESTROOT/extensions/1/public/bar.jar, updater=ExtensionUpdater(extVersion=1, module=bar, nextSdkVersion=33))
+                        VersionedJarApi(jar=TESTROOT/extensions/2/public/bar.jar, updater=ExtensionUpdater(extVersion=2, module=bar, nextSdkVersion=33))
+                        VersionedJarApi(jar=TESTROOT/extensions/2/public/foo.jar, updater=ExtensionUpdater(extVersion=2, module=foo, nextSdkVersion=33))
+                    """
+                        .trimIndent()
+                )
         }
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiSelectionOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiSelectionOptionsTest.kt
index 502dd8d93..bae8d61a7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiSelectionOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiSelectionOptionsTest.kt
@@ -17,6 +17,13 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.BaseOptionGroupTest
+import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.config.ApiSurfaceConfig
+import com.android.tools.metalava.config.ApiSurfacesConfig
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.google.common.truth.Truth.assertThat
+import org.junit.Assert.assertThrows
+import org.junit.Test
 
 val API_SELECTION_OPTIONS_HELP =
     """
@@ -24,6 +31,10 @@ Api Selection:
 
   Options that select which parts of the source files will be part of the generated API.
 
+  --api-surface <surface>                    The API surface currently being generated. Must correspond to an
+                                             <api-surface> element in a --config-file.
+  --show-unannotated                         Include un-annotated public APIs in the signature file as well. (default:
+                                             true if no --show*-annotation options specified)
   --show-annotation <annotation-filter>      Unhide any hidden elements that are also annotated with the given
                                              annotation.
   --show-single-annotation <annotation-filter>
@@ -34,10 +45,146 @@ Api Selection:
                                              "implicitly" included in the API surface, and they'll be included in
                                              certain kinds of output such as stubs, but not in others, such as the
                                              signature file and API lint.
+  --hide-annotation <annotation-filter>      Treat any elements annotated with the given annotation as hidden.
     """
         .trimIndent()
 
 class ApiSelectionOptionsTest :
     BaseOptionGroupTest<ApiSelectionOptions>(API_SELECTION_OPTIONS_HELP) {
     override fun createOptions() = ApiSelectionOptions()
+
+    @Test
+    fun `Test no --show-unannotated no show annotations`() {
+        runTest { assertThat(options.showUnannotated).isTrue() }
+    }
+
+    @Test
+    fun `Test no --show-unannotated with --show-annotation`() {
+        runTest(ARG_SHOW_ANNOTATION, "test.pkg.Show") {
+            assertThat(options.showUnannotated).isFalse()
+        }
+    }
+
+    /**
+     * Run the test, providing an optional [ApiSelectionOptions] to
+     * [ApiSelectionOptions.apiSurfacesConfigProvider].
+     */
+    private fun runTestWithConfig(
+        vararg args: String,
+        apiSurfacesConfig: ApiSurfacesConfig? =
+            ApiSurfacesConfig(
+                apiSurfaceList =
+                    listOf(
+                        ApiSurfaceConfig(name = "public"),
+                        ApiSurfaceConfig(name = "system", extends = "public"),
+                    )
+            ),
+        test: Result<ApiSelectionOptions>.() -> Unit,
+    ) {
+        val optionGroup =
+            ApiSelectionOptions(
+                apiSurfacesConfigProvider = { apiSurfacesConfig },
+            )
+        runTest(args = args, optionGroup = optionGroup, test = test)
+    }
+
+    /**
+     * Run [body] and make sure that it throws a [MetalavaCliException] with the [expectedMessage].
+     */
+    private fun assertThrowsCliError(expectedMessage: String, body: () -> Unit) {
+        val exception = assertThrows(MetalavaCliException::class.java) { body() }
+        assertThat(exception.message).isEqualTo(expectedMessage)
+    }
+
+    @Test
+    fun `Test --api-surface option no api-surfaces configuration`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "public",
+            apiSurfacesConfig = null,
+        ) {
+            assertThrowsCliError(
+                "--api-surface requires at least one <api-surface> to have been configured in a --config-file"
+            ) {
+                options.apiSurfaces
+            }
+        }
+    }
+
+    @Test
+    fun `Test configuring API surfaces no --api-surface option`() {
+        runTestWithConfig {
+            // Configuration is ignored when no --api-surface is provided.
+            options.apiSurfaces.assertBaseWasNotCreated()
+        }
+    }
+
+    @Test
+    fun `Test configuring API surfaces invalid --api-surface option`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "unknown",
+        ) {
+            val exception = assertThrows(IllegalStateException::class.java) { options.apiSurfaces }
+            assertThat(exception.message)
+                .isEqualTo(
+                    "--api-surface (`unknown`) does not match an <api-surface> in a --config-file, expected one of `public`, `system`"
+                )
+        }
+    }
+
+    @Test
+    fun `Test configuring extending surface without --show-annotation option`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "system",
+        ) {
+            assertThrowsCliError(
+                """Configuration of `<api-surface name="system">` is inconsistent with command line options because `system` extends public which requires that it not show unannotated items but --show-unannotated is true"""
+            ) {
+                options.apiSurfaces
+            }
+        }
+    }
+
+    @Test
+    fun `Test configuring extending surface with --show-annotation option`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "system",
+            ARG_SHOW_ANNOTATION,
+            ANDROID_SYSTEM_API,
+        ) {
+            options.apiSurfaces.assertBaseWasCreated()
+            assertThat(options.apiSurfaces.main.name).isEqualTo("system")
+            assertThat(options.apiSurfaces.base?.name).isEqualTo("public")
+        }
+    }
+
+    @Test
+    fun `Test configuring non-extending surface with --show-annotation option`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "public",
+            ARG_SHOW_ANNOTATION,
+            ANDROID_SYSTEM_API,
+        ) {
+            assertThrowsCliError(
+                """Configuration of `<api-surface name="public">` is inconsistent with command line options because `public` does not extend another surface which requires that it show unannotated items but --show-unannotated is false"""
+            ) {
+                options.apiSurfaces
+            }
+        }
+    }
+
+    @Test
+    fun `Test configuring non-extending surface without --show-annotation option`() {
+        runTestWithConfig(
+            ARG_API_SURFACE,
+            "public",
+        ) {
+            options.apiSurfaces.assertBaseWasNotCreated()
+            assertThat(options.apiSurfaces.main.name).isEqualTo("public")
+        }
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt
index 2dd863c81..47fef5765 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt
@@ -62,16 +62,6 @@ class ApiSurfacesTest : DriverTest() {
         )
     }
 
-    private fun ApiSurfaces.assertBaseWasNotCreated() {
-        assertNull(base, message = "base")
-        assertNull(main.extends, message = "main.extends")
-    }
-
-    private fun ApiSurfaces.assertBaseWasCreated() {
-        assertNotNull(base, message = "base")
-        assertSame(base, main.extends, message = "main.extends")
-    }
-
     @Test
     fun `Test generating public API does not need to track the base API surface`() {
         checkApiSurfaces {
@@ -128,4 +118,37 @@ class ApiSurfacesTest : DriverTest() {
             apiSurfaces.assertBaseWasCreated()
         }
     }
+
+    @Test
+    fun `Test no show annotations with signature sources`() {
+        check(
+            signatureSource =
+                """
+                    package test.pkg {
+                        public class Foo {
+                            ctor public Foo();
+                        }
+                    }
+                """,
+            configFiles = arrayOf(KnownConfigFiles.configPublicAndSystemSurfaces),
+            extraArguments =
+                arrayOf(
+                    ARG_API_SURFACE,
+                    "system",
+                ),
+        ) {
+            val apiSurfaces = options.apiSurfaces
+            apiSurfaces.assertBaseWasCreated()
+        }
+    }
+}
+
+fun ApiSurfaces.assertBaseWasNotCreated() {
+    assertNull(base, message = "base")
+    assertNull(main.extends, message = "main.extends")
+}
+
+fun ApiSurfaces.assertBaseWasCreated() {
+    assertNotNull(base, message = "base")
+    assertSame(base, main.extends, message = "main.extends")
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
index 5b62e9f2c..59bd108b7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
@@ -22,7 +22,6 @@ import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.lint.ARG_API_LINT
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import java.io.File
 import org.junit.Test
@@ -241,8 +240,6 @@ class BaselineTest : DriverTest() {
                     ),
                     testApiSource,
                     androidxNullableSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
index 92ce1e3a0..2b70a283e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
@@ -44,7 +44,9 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
                         // Signature format: 2.0
                         package pkg {
                             public class Outer.Inner {
-                                method public TypeInFirst foobar();
+                                method public pkg.TypeInFirst foobar();
+                            }
+                            public class TypeInFirst {
                             }
                         }
                     """
@@ -57,7 +59,9 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
                             public class Outer {
                             }
                             public class Outer.Inner {
-                                method public TypeInSecond foobar();
+                                method public pkg.TypeInSecond foobar();
+                            }
+                            public class TypeInSecond {
                             }
                         }
                     """
@@ -94,7 +98,7 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
                 old,
                 new
             )
-        assertEquals("TypeInFirst", methodType)
+        assertEquals("pkg.TypeInFirst", methodType)
     }
 
     @Test
diff --git a/metalava/src/test/java/com/android/tools/metalava/ConfigFileOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ConfigFileOptionsTest.kt
new file mode 100644
index 000000000..f0314cd3a
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ConfigFileOptionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.cli.common.BaseOptionGroupTest
+
+val CONFIG_FILE_OPTIONS_HELP =
+    """
+Config Files:
+
+  Options that control the configuration files.
+
+  --config-file <file>                       A configuration file that can be consumed by Metalava. This can be
+                                             specified multiple times in which case later config files will
+                                             override/merge with earlier ones.
+    """
+        .trimIndent()
+
+class ConfigFileOptionsTest : BaseOptionGroupTest<ConfigFileOptions>(CONFIG_FILE_OPTIONS_HELP) {
+    override fun createOptions() = ConfigFileOptions()
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ConfigFilesTest.kt b/metalava/src/test/java/com/android/tools/metalava/ConfigFilesTest.kt
new file mode 100644
index 000000000..03fc80573
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ConfigFilesTest.kt
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.lint.checks.infrastructure.TestFiles.xml
+import com.android.tools.metalava.config.Config
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+/**
+ * Tests to verify that config files are read correctly by the main command and that errors are
+ * surface correctly.
+ */
+class ConfigFilesTest : DriverTest() {
+    @Test
+    fun `Empty config file`() {
+        check(
+            configFiles =
+                arrayOf(
+                    xml(
+                        "config.xml",
+                        """
+                            <config xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    ),
+                ),
+        ) {
+            assertThat(options.configFileOptions.config).isEqualTo(Config())
+        }
+    }
+
+    @Test
+    fun `Invalid config file`() {
+        check(
+            configFiles =
+                arrayOf(
+                    xml(
+                        "config.xml",
+                        """
+                            <invalid xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    ),
+                ),
+            expectedFail =
+                """
+                    Aborting: Errors found while parsing configuration file(s):
+                        file:TESTROOT/project/config.xml:1: cvc-elt.1.a: Cannot find the declaration of element 'invalid'.
+                """,
+        )
+    }
+
+    @Test
+    fun `Multiple config files`() {
+        check(
+            configFiles =
+                arrayOf(
+                    xml(
+                        "config1.xml",
+                        """
+                            <config xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    ),
+                    xml(
+                        "config2.xml",
+                        """
+                            <config xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    ),
+                ),
+        ) {
+            assertThat(options.configFileOptions.config).isEqualTo(Config())
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
index 161f51fe8..5a2062d2c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
@@ -17,10 +17,6 @@
 package com.android.tools.metalava
 
 import com.android.SdkConstants.DOT_TXT
-import com.android.ide.common.process.DefaultProcessExecutor
-import com.android.ide.common.process.LoggedProcessOutputHandler
-import com.android.ide.common.process.ProcessException
-import com.android.ide.common.process.ProcessInfoBuilder
 import com.android.tools.lint.LintCliClient
 import com.android.tools.lint.UastEnvironment
 import com.android.tools.lint.checks.ApiLookup
@@ -30,7 +26,6 @@ import com.android.tools.lint.checks.infrastructure.TestFiles.java
 import com.android.tools.lint.checks.infrastructure.TestFiles.kotlin
 import com.android.tools.lint.checks.infrastructure.stripComments
 import com.android.tools.lint.client.api.LintClient
-import com.android.tools.metalava.cli.common.ARG_COMMON_SOURCE_PATH
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.common.ARG_NO_COLOR
 import com.android.tools.metalava.cli.common.ARG_QUIET
@@ -53,7 +48,10 @@ import com.android.tools.metalava.cli.lint.ARG_BASELINE_API_LINT
 import com.android.tools.metalava.cli.lint.ARG_ERROR_MESSAGE_API_LINT
 import com.android.tools.metalava.cli.lint.ARG_UPDATE_BASELINE_API_LINT
 import com.android.tools.metalava.cli.signature.ARG_FORMAT
+import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PACKAGE
+import com.android.tools.metalava.model.ANDROID_ANNOTATION_PACKAGE
 import com.android.tools.metalava.model.Assertions
+import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.psi.PsiModelOptions
 import com.android.tools.metalava.model.source.SourceModelProvider
@@ -69,12 +67,13 @@ import com.android.tools.metalava.model.text.assertSignatureFilesMatch
 import com.android.tools.metalava.model.text.prepareSignatureFileForTest
 import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
+import com.android.tools.metalava.testing.JavacHelper
+import com.android.tools.metalava.testing.KnownJarFiles
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.TemporaryFolderOwner
 import com.android.tools.metalava.testing.findKotlinStdlibPaths
 import com.android.tools.metalava.testing.getAndroidJar
 import com.android.utils.SdkUtils
-import com.android.utils.StdLogger
 import com.google.common.io.Closeables
 import com.intellij.openapi.util.Disposer
 import java.io.ByteArrayOutputStream
@@ -251,22 +250,6 @@ abstract class DriverTest :
         }
     }
 
-    private fun getJdkPath(): String? {
-        val javaHome = System.getProperty("java.home")
-        if (javaHome != null) {
-            var javaHomeFile = File(javaHome)
-            if (File(javaHomeFile, "bin${File.separator}javac").exists()) {
-                return javaHome
-            } else if (javaHomeFile.name == "jre") {
-                javaHomeFile = javaHomeFile.parentFile
-                if (File(javaHomeFile, "bin${File.separator}javac").exists()) {
-                    return javaHomeFile.path
-                }
-            }
-        }
-        return System.getenv("JAVA_HOME")
-    }
-
     private fun <T> buildOptionalArgs(option: T?, converter: (T) -> Array<String>): Array<String> {
         return if (option != null) {
             converter(option)
@@ -480,8 +463,8 @@ abstract class DriverTest :
          * files etc
          */
         importedPackages: List<String> = emptyList(),
-        /** See [TestEnvironment.skipEmitPackages] */
-        skipEmitPackages: List<String> = listOf("java.lang", "java.util", "java.io"),
+        /** See [TestEnvironment.skipEmitPackages], defaults to [DEFAULT_SKIP_EMIT_PACKAGES]. */
+        skipEmitPackages: List<String>? = null,
         /** Whether we should include --showAnnotations=android.annotation.SystemApi */
         includeSystemApiAnnotations: Boolean = false,
         /** Whether we should warn about super classes that are stripped because they are hidden */
@@ -541,8 +524,6 @@ abstract class DriverTest :
         @Language("TEXT") apiLint: String? = null,
         /** The source files to pass to the analyzer */
         sourceFiles: Array<TestFile> = emptyArray(),
-        /** The common source files to pass to the analyzer */
-        commonSourceFiles: Array<TestFile> = emptyArray(),
         /** Lint project description */
         projectDescription: TestFile? = null,
         /** [ARG_REPEAT_ERRORS_MAX] */
@@ -571,13 +552,16 @@ abstract class DriverTest :
 
         // Verify that a test that provided kotlin code is only being run against a provider that
         // supports kotlin code.
-        val anyKotlin =
-            sourceFiles.any { it.targetPath.endsWith(DOT_KT) } ||
-                commonSourceFiles.any { it.targetPath.endsWith(DOT_KT) }
-        if (anyKotlin && Capability.KOTLIN !in codebaseCreatorConfig.creator.capabilities) {
-            error(
-                "Provider ${codebaseCreatorConfig.providerName} does not support Kotlin; please add `@RequiresCapabilities(Capability.KOTLIN)` to the test"
-            )
+        val anyKotlin = sourceFiles.any { it.targetPath.endsWith(DOT_KT) }
+        if (anyKotlin) {
+            if (Capability.KOTLIN !in codebaseCreatorConfig.creator.capabilities) {
+                error(
+                    "Provider ${codebaseCreatorConfig.providerName} does not support Kotlin; please add `@RequiresCapabilities(Capability.KOTLIN)` to the test"
+                )
+            }
+            if (format.version < FileFormat.Version.V4) {
+                error("Kotlin test must use FileFormat.V4 or higher")
+            }
         }
 
         val releasedApiCheck =
@@ -608,7 +592,7 @@ abstract class DriverTest :
         // Unit test which checks that a signature file is as expected
         val androidJar = getAndroidJar()
 
-        val project = createProject(sourceFiles + commonSourceFiles)
+        val project = createProject(sourceFiles)
 
         val sourcePathDir = File(project, "src")
         if (!sourcePathDir.isDirectory) {
@@ -616,7 +600,6 @@ abstract class DriverTest :
         }
 
         var sourcePath = sourcePathDir.path
-        var commonSourcePath: String? = null
 
         // Make it easy to configure a source path with more than one source root: src and src2
         if (sourceFiles.any { it.targetPath.startsWith("src2") }) {
@@ -625,16 +608,6 @@ abstract class DriverTest :
 
         fun pathUnderProject(path: String): String = File(project, path).path
 
-        if (commonSourceFiles.isNotEmpty()) {
-            // Assume common/source are placed in different folders, e.g., commonMain, androidMain
-            sourcePath =
-                pathUnderProject(sourceFiles.first().targetPath.substringBefore("src") + "src")
-            commonSourcePath =
-                pathUnderProject(
-                    commonSourceFiles.first().targetPath.substringBefore("src") + "src"
-                )
-        }
-
         val projectDescriptionFile = projectDescription?.createFile(project)
 
         val apiClassResolutionArgs =
@@ -668,7 +641,7 @@ abstract class DriverTest :
                 }
                 arrayOf(apiJar.path)
             } else {
-                (sourceFiles + commonSourceFiles)
+                sourceFiles
                     .asSequence()
                     .map { pathUnderProject(it.targetPath) }
                     .toList()
@@ -888,7 +861,7 @@ abstract class DriverTest :
             }
 
         // Always pass apiArgs and generate API text file in runDriver
-        val apiFile: File = newFile("public-api.txt")
+        val apiFile: File = getOrCreateFile("public-api.txt")
         val apiArgs = arrayOf(ARG_API, apiFile.path)
 
         val subtractApiFile: File?
@@ -904,7 +877,7 @@ abstract class DriverTest :
         var stubsDir: File? = null
         val stubsArgs =
             if (stubFiles.isNotEmpty() || stubPaths != null) {
-                stubsDir = newFolder("stubs")
+                stubsDir = getOrCreateFolder("stubs")
                 if (docStubs) {
                     arrayOf(ARG_DOC_STUBS, stubsDir.path)
                 } else {
@@ -1042,17 +1015,14 @@ abstract class DriverTest :
                 // test root folder such that we clean up the output strings referencing
                 // paths to the temp folder
                 "--temp-folder",
-                newFolder("temp").path,
+                getOrCreateFolder("temp").path,
 
                 // Annotation generation temporarily turned off by default while integrating with
                 // SDK builds; tests need these
                 ARG_INCLUDE_ANNOTATIONS,
                 ARG_SOURCE_PATH,
                 sourcePath,
-                ARG_CLASS_PATH,
-                androidJar.path,
-                *classpathArgs,
-                *kotlinPathArgs,
+                *sourceList,
                 *configFileArgs,
                 *removedArgs,
                 *apiArgs,
@@ -1094,23 +1064,23 @@ abstract class DriverTest :
             ) +
                 buildList {
                         if (projectDescriptionFile != null) {
+                            // Classpath isn't needed when it is specified through the project xml
                             add(ARG_PROJECT)
                             add(projectDescriptionFile.absolutePath)
                             // When project description is provided,
                             // skip listing (common) sources
                         } else {
-                            addAll(sourceList)
-                            if (commonSourcePath != null) {
-                                add(ARG_COMMON_SOURCE_PATH)
-                                add(commonSourcePath)
-                            }
+                            add(ARG_CLASS_PATH)
+                            add(androidJar.path)
+                            addAll(classpathArgs)
+                            addAll(kotlinPathArgs)
                         }
                     }
                     .toTypedArray()
 
         val testEnvironment =
             TestEnvironment(
-                skipEmitPackages = skipEmitPackages,
+                skipEmitPackages = skipEmitPackages ?: DEFAULT_SKIP_EMIT_PACKAGES,
                 sourceModelProvider = codebaseCreatorConfig.creator,
                 modelOptions = codebaseCreatorConfig.modelOptions,
                 postAnalysisChecker = postAnalysisChecker,
@@ -1267,40 +1237,14 @@ abstract class DriverTest :
 
         if (checkCompilation && stubsDir != null) {
             val generated =
-                SourceSet.createFromSourcePath(options.reporter, listOf(stubsDir))
-                    .sources
-                    .asSequence()
-                    .map { it.path }
-                    .toList()
-                    .toTypedArray()
-
-            // Also need to include on the compile path annotation classes referenced in the stubs
-            val extraAnnotationsDir = File("../stub-annotations/src/main/java")
-            if (!extraAnnotationsDir.isDirectory) {
-                fail(
-                    "Couldn't find $extraAnnotationsDir: Is the pwd set to the root of the metalava source code?"
-                )
-                fail(
-                    "Couldn't find $extraAnnotationsDir: Is the pwd set to the root of an Android source tree?"
-                )
-            }
-            val extraAnnotations =
-                SourceSet.createFromSourcePath(options.reporter, listOf(extraAnnotationsDir))
-                    .sources
-                    .asSequence()
-                    .map { it.path }
-                    .toList()
-                    .toTypedArray()
+                SourceSet.createFromSourcePath(options.reporter, listOf(stubsDir)).sources
 
-            if (
-                !runCommand(
-                    "${getJdkPath()}/bin/javac",
-                    arrayOf("-d", project.path, *generated, *extraAnnotations)
-                )
-            ) {
-                fail("Couldn't compile stub file -- compilation problems")
-                return
-            }
+            // Compile the stubs, throwing an exception if it fails.
+            JavacHelper.compile(
+                outputDirectory = project,
+                sources = generated,
+                classPath = listOf(KnownJarFiles.stubAnnotationsJar),
+            )
         }
     }
 
@@ -1363,26 +1307,6 @@ abstract class DriverTest :
         }
     }
 
-    private fun runCommand(executable: String, args: Array<String>): Boolean {
-        try {
-            val logger = StdLogger(StdLogger.Level.ERROR)
-            val processExecutor = DefaultProcessExecutor(logger)
-            val processInfo =
-                ProcessInfoBuilder().setExecutable(executable).addArgs(args).createProcess()
-
-            val processOutputHandler = LoggedProcessOutputHandler(logger)
-            val result = processExecutor.execute(processInfo, processOutputHandler)
-
-            result.rethrowFailure().assertNormalExitValue()
-        } catch (e: ProcessException) {
-            fail(
-                "Failed to run $executable (${e.message}): not verifying this API on the old doclava engine"
-            )
-            return false
-        }
-        return true
-    }
-
     companion object {
         @JvmStatic
         protected fun readFile(file: File): String {
@@ -1638,6 +1562,40 @@ val requiresApiSource: TestFile =
         )
         .indented()
 
+private fun restrictedForEnvironmentClass(packageName: String): TestFile =
+    java(
+            """
+            package $packageName;
+            import java.lang.annotation.*;
+            import static java.lang.annotation.ElementType.*;
+            import static java.lang.annotation.RetentionPolicy.SOURCE;
+            /** @hide */
+            @Retention(SOURCE)
+            @Target({TYPE})
+            public @interface RestrictedForEnvironment {
+              Environment[] environments();
+              int from();
+              enum Environment {
+                SDK_SANDBOX {
+                    @Override
+                    public String toString() {
+                        return "SDK Runtime";
+                    }
+                }
+              }
+              @Retention(RetentionPolicy.RUNTIME)
+              @Target(TYPE)
+              @interface Container {
+                  RestrictedForEnvironment[] value();
+              }
+            }
+        """
+        )
+        .indented()
+
+val androidXRestrictedForEnvironment = restrictedForEnvironmentClass(ANDROIDX_ANNOTATION_PACKAGE)
+val androidRestrictedForEnvironment = restrictedForEnvironmentClass(ANDROID_ANNOTATION_PACKAGE)
+
 val sdkConstantSource: TestFile =
     java(
             """
@@ -1737,42 +1695,6 @@ val recentlyNullableSource: TestFile =
         )
         .indented()
 
-val androidxIntRangeSource: TestFile =
-    java(
-            """
-    package androidx.annotation;
-    import java.lang.annotation.*;
-    import static java.lang.annotation.ElementType.*;
-    import static java.lang.annotation.RetentionPolicy.SOURCE;
-    @Retention(CLASS)
-    @Target({METHOD, PARAMETER, FIELD, LOCAL_VARIABLE, ANNOTATION_TYPE})
-    public @interface IntRange {
-        long from() default Long.MIN_VALUE;
-        long to() default Long.MAX_VALUE;
-    }
-    """
-        )
-        .indented()
-
-val supportParameterName = KnownSourceFiles.supportParameterName
-
-val supportDefaultValue: TestFile =
-    java(
-            """
-    package androidx.annotation;
-    import java.lang.annotation.*;
-    import static java.lang.annotation.ElementType.*;
-    import static java.lang.annotation.RetentionPolicy.SOURCE;
-    @SuppressWarnings("WeakerAccess")
-    @Retention(SOURCE)
-    @Target({METHOD, PARAMETER, FIELD})
-    public @interface DefaultValue {
-        String value();
-    }
-    """
-        )
-        .indented()
-
 val uiThreadSource: TestFile =
     java(
             """
@@ -1968,31 +1890,6 @@ val columnSource: TestFile =
         )
         .indented()
 
-val flaggedApiSource: TestFile =
-    java(
-            """
-    package android.annotation;
-
-    import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-    import static java.lang.annotation.ElementType.CONSTRUCTOR;
-    import static java.lang.annotation.ElementType.FIELD;
-    import static java.lang.annotation.ElementType.METHOD;
-    import static java.lang.annotation.ElementType.TYPE;
-
-    import java.lang.annotation.Retention;
-    import java.lang.annotation.RetentionPolicy;
-    import java.lang.annotation.Target;
-
-    /** @hide */
-    @Target({TYPE, METHOD, CONSTRUCTOR, FIELD, ANNOTATION_TYPE})
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface FlaggedApi {
-        String value();
-    }
-    """
-        )
-        .indented()
-
 val publishedApiSource: TestFile =
     kotlin(
             """
@@ -2032,3 +1929,29 @@ val deprecatedForSdkSource: TestFile =
     """
         )
         .indented()
+
+val DEFAULT_SKIP_EMIT_PACKAGES =
+    listOf(
+        // Do not emit classes in a number of java packages. While tests will
+        // use those classes they generally do not want to emit definitions of
+        // those classes as part of a signature or stubs files.
+        "java.lang",
+        "java.util",
+        "java.io",
+        // Ditto for android.annotation and androidx.annotation classes.
+        ANDROID_ANNOTATION_PACKAGE,
+        ANDROIDX_ANNOTATION_PACKAGE,
+        // Ditto for libcore.util.
+        "libcore.util",
+    )
+
+/**
+ * A special [FileFormat] used by tests that want to output type use annotations to signature files.
+ */
+val TYPE_USE_FORMAT =
+    FileFormat.V5.copy(
+        kotlinNameTypeOrder = true,
+        includeTypeUseAnnotations = true,
+        kotlinStyleNulls = false,
+        specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+    )
diff --git a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
index 3e8aec91a..0592653fa 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
@@ -19,7 +19,6 @@ package com.android.tools.metalava
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -77,8 +76,6 @@ class ExtractAnnotationsTest : DriverTest() {
                 .indented(),
             intDefAnnotationSource,
             intRangeAnnotationSource,
-            // Hide android.annotation classes.
-            KnownSourceFiles.androidAnnotationHide,
         )
 
     @Test
@@ -828,4 +825,42 @@ class ExtractAnnotationsTest : DriverTest() {
                 )
         )
     }
+
+    @Test
+    fun `Extract annotations from class`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            import androidx.annotation.UiThread;
+
+                            @UiThread
+                            public class Test {
+                                @UiThread
+                                public Test() {}
+                            }
+                        """
+                    ),
+                    uiThreadSource,
+                ),
+            extractAnnotations =
+                mapOf(
+                    "test.pkg" to
+                        """
+                            <?xml version="1.0" encoding="UTF-8"?>
+                            <root>
+                              <item name="test.pkg.Test">
+                                <annotation name="androidx.annotation.UiThread"/>
+                              </item>
+                              <item name="test.pkg.Test Test()">
+                                <annotation name="androidx.annotation.UiThread"/>
+                              </item>
+                            </root>
+                        """,
+                ),
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
index b88e34f2b..fcf4e7497 100644
--- a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
@@ -21,16 +21,17 @@ import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
-/** Edge case tests of [ANDROID_FLAGGED_API] that cannot be tested in [FlaggedApiTest]. */
+/**
+ * Edge case tests of [ANDROID_FLAGGED_API] that cannot be tested in [ParameterizedFlaggedApiTest].
+ */
 class FlaggedApiEdgeCasesTest : DriverTest() {
     @Test
     fun `Test override flagged method from source path no previously released API`() {
         check(
+            // Revert all FlaggedApi annotations.
+            configFiles = arrayOf(KnownConfigFiles.configEmptyApiFlags),
             extraArguments =
                 arrayOf(
-                    // Revert all FlaggedApi annotations.
-                    ARG_REVERT_ANNOTATION,
-                    ANDROID_FLAGGED_API,
                     // Ignore any classes other than test.pkg.
                     ARG_STUB_PACKAGES,
                     "test.pkg*"
@@ -86,11 +87,10 @@ class FlaggedApiEdgeCasesTest : DriverTest() {
     @Test
     fun `Test override flagged method from source path with previously released API`() {
         check(
+            // Revert all FlaggedApi annotations.
+            configFiles = arrayOf(KnownConfigFiles.configEmptyApiFlags),
             extraArguments =
                 arrayOf(
-                    // Revert all FlaggedApi annotations.
-                    ARG_REVERT_ANNOTATION,
-                    ANDROID_FLAGGED_API,
                     // Ignore any classes other than test.pkg.
                     ARG_STUB_PACKAGES,
                     "test.pkg*"
diff --git a/metalava/src/test/java/com/android/tools/metalava/JDiffXmlTest.kt b/metalava/src/test/java/com/android/tools/metalava/JDiffXmlTest.kt
index 64a441e57..301d21859 100644
--- a/metalava/src/test/java/com/android/tools/metalava/JDiffXmlTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/JDiffXmlTest.kt
@@ -491,7 +491,7 @@ class JDiffXmlTest : SignatureToJDiffCommandTest() {
             api =
                 """
                     package android.accounts {
-                      public class ArgbEvaluator<D, V> implements android.animation.DefaultEvaluator<D> implements android.animation.TypeEvaluator<V> {
+                      public class ArgbEvaluator<D, V> implements android.animation.DefaultEvaluator<D> android.animation.TypeEvaluator<V> {
                       }
                     }
                     """
@@ -513,8 +513,6 @@ class JDiffXmlTest : SignatureToJDiffCommandTest() {
                     </implements>
                     <implements name="android.animation.TypeEvaluator&lt;V>">
                     </implements>
-                    <implements name="java.lang.implements">
-                    </implements>
                     </class>
                     </package>
                     </api>
diff --git a/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
index 44ec7ef07..d0d20c00b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
@@ -185,10 +185,10 @@ Arguments:
             val folder = folder("jdiff")
 
             args += "jar-to-jdiff"
-            args += androidJar.path
+            args += androidJar
 
             val xmlFile = outputFile("api.xml", parentDir = folder)
-            args += xmlFile.path
+            args += xmlFile
 
             // Verify that the generate file is correct.
             verify { assertEquals(expectedXml.trimIndent(), xmlFile.readText().trim()) }
diff --git a/metalava/src/test/java/com/android/tools/metalava/KnownConfigFiles.kt b/metalava/src/test/java/com/android/tools/metalava/KnownConfigFiles.kt
new file mode 100644
index 000000000..2499caca5
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/KnownConfigFiles.kt
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.testing.xml
+
+object KnownConfigFiles {
+    val configPublicSurface =
+        xml(
+            "config-public-surface.xml",
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config"
+                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                    xsi:schemaLocation="http://www.google.com/tools/metalava/config ../../../../../resources/schemas/config.xsd">
+                    <api-surfaces>
+                        <api-surface name="public"/>
+                    </api-surfaces>
+                </config>
+            """
+        )
+
+    val configPublicAndSystemSurfaces =
+        xml(
+            "config-public-and-system-surfaces.xml",
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config"
+                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                    xsi:schemaLocation="http://www.google.com/tools/metalava/config ../../../../../resources/schemas/config.xsd">
+                    <api-surfaces>
+                        <api-surface name="public"/>
+                        <api-surface name="system" extends="public"/>
+                    </api-surfaces>
+                </config>
+            """
+        )
+
+    val configEmptyApiFlags =
+        xml(
+            "config-empty-api-flags.xml",
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config"
+                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                    xsi:schemaLocation="http://www.google.com/tools/metalava/config ../../../../../resources/schemas/config.xsd">
+                    <api-flags/>
+                </config>
+            """
+        )
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
index 68ac297a5..c0a33a19a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
@@ -31,9 +31,8 @@ class KotlinInteropChecksTest : DriverTest() {
             apiLint = "",
             expectedIssues =
                 """
-                src/test/pkg/Test.java:7: error: Avoid method names that are Kotlin hard keywords ("fun"); see https://android.github.io/kotlin-guides/interop.html#no-hard-keywords [KotlinKeyword]
-                src/test/pkg/Test.java:8: error: Avoid parameter names that are Kotlin hard keywords ("typealias"); see https://android.github.io/kotlin-guides/interop.html#no-hard-keywords [KotlinKeyword]
-                src/test/pkg/Test.java:10: error: Avoid field names that are Kotlin hard keywords ("object"); see https://android.github.io/kotlin-guides/interop.html#no-hard-keywords [KotlinKeyword]
+                    src/test/pkg/Test.java:6: error: Avoid method names that are Kotlin hard keywords ("fun"); see https://android.github.io/kotlin-guides/interop.html#no-hard-keywords [KotlinKeyword]
+                    src/test/pkg/Test.java:9: error: Avoid field names that are Kotlin hard keywords ("object"); see https://android.github.io/kotlin-guides/interop.html#no-hard-keywords [KotlinKeyword]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -43,18 +42,16 @@ class KotlinInteropChecksTest : DriverTest() {
                     package test.pkg;
 
                     import androidx.annotation.NonNull;
-                    import androidx.annotation.ParameterName;
 
                     public class Test {
                         public void fun() { }
-                        public void foo(int fun, @ParameterName("typealias") int internalName) { }
+                        public void foo(int fun) { }
                         @NonNull
                         public final Object object = null;
                     }
                     """
                     ),
-                    supportParameterName,
-                    androidxNonNullSource
+                    androidxNonNullSource,
                 )
         )
     }
@@ -154,9 +151,11 @@ class KotlinInteropChecksTest : DriverTest() {
             expectedIssues =
                 """
                 src/test/pkg/Foo.kt:8: warning: Companion object constants like BIG_INTEGER_ONE should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]
-                src/test/pkg/Foo.kt:11: warning: Companion object constants like WRONG should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]
-                src/test/pkg/Foo.kt:12: warning: Companion object constants like WRONG2 should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]
-                src/test/pkg/Foo.kt:15: warning: Companion object methods like missing should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]
+                src/test/pkg/Foo.kt:10: warning: Companion object methods like getWrongNeedsJvmStatic should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]
+                src/test/pkg/Foo.kt:10: warning: Companion object methods like setWrongNeedsJvmStatic should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]
+                src/test/pkg/Foo.kt:12: warning: Companion object constants like WRONG should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]
+                src/test/pkg/Foo.kt:13: warning: Companion object constants like WRONG2 should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]
+                src/test/pkg/Foo.kt:16: warning: Companion object methods like missing should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]
                 """,
             sourceFiles =
                 arrayOf(
@@ -171,7 +170,8 @@ class KotlinInteropChecksTest : DriverTest() {
                             const val INTEGER_ONE = 1
                             val BIG_INTEGER_ONE = BigInteger.ONE
                             private val PRIVATE_BIG_INTEGER = BigInteger.ONE
-                            var ok = 1
+                            var wrongNeedsJvmStatic = 1
+                            @JvmStatic var ok = 1.5
                             @JvmStatic val WRONG = 2
                             @JvmStatic @JvmField val WRONG2 = 2
                             @JvmField val ok3 = 3
@@ -407,4 +407,154 @@ class KotlinInteropChecksTest : DriverTest() {
                 ),
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check usage of JvmStatic on hidden property`() {
+        // Regression test for b/401569415 -- MissingJvmstatic should not apply to hidden properties
+        check(
+            apiLint = "",
+            expectedIssues = "",
+            extraArguments = arrayOf(ARG_HIDE, "StaticUtils"),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            class Foo {
+                                companion object {
+                                    /** @hide */
+                                    @JvmStatic
+                                    val hiddenProperty = 0
+                                }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check usage of JvmStatic on property of value class type`() {
+        // b/401569415 -- JvmField cannot be used on properties of value class type
+        check(
+            apiLint = "",
+            expectedIssues =
+                "src/test/pkg/IntValue.kt:8: warning: Companion object methods like getValueClassTypePropertyNoAnnotation should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]",
+            extraArguments = arrayOf(ARG_HIDE, "ValueClassDefinition"),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            @JvmInline
+                            value class IntValue(val value: Int) {
+                                companion object {
+                                    @JvmStatic
+                                    val valueClassTypePropertyJvmStatic = IntValue(0)
+
+                                    val valueClassTypePropertyNoAnnotation = IntValue(0)
+                                }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check methods and properties in a named companion object should be annotated JvmStatic`() {
+        check(
+            apiLint = "",
+            // TODO: this is inconsistent between methods and properties
+            expectedIssues =
+                "src/test/pkg/Foo.kt:9: warning: Companion object constants like missingJvmField should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants [MissingJvmstatic]",
+            extraArguments = arrayOf(ARG_HIDE, "StaticUtils"),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            class Foo {
+                                companion object FooCompanion {
+                                    fun missingJvmStatic() = Unit
+
+                                    @JvmStatic
+                                    fun ok() = Unit
+
+                                    val missingJvmField = 0
+
+                                    @JvmField
+                                    val ok = 0
+                                }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check interface companion properties`() {
+        check(
+            apiLint = "",
+            expectedIssues =
+                "src/test/pkg/Foo.kt:10: warning: Companion object methods like getUnannotatedProperty should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            interface Foo {
+                                companion object {
+                                    // Cannot use @JvmField here, causes a compiler error:
+                                    // JvmField could be applied only if all interface companion
+                                    // properties are 'public final val' with '@JvmField' annotation
+                                    @JvmStatic
+                                    val jvmStaticProperty = 0
+
+                                    val unannotatedProperty = 0
+
+                                    private val privateProperty = 0
+                                }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check companion property without backing field`() {
+        check(
+            apiLint = "",
+            expectedIssues =
+                "src/test/pkg/Foo.kt:11: warning: Companion object methods like getUnannotatedPropertyWithoutBackingField should be marked @JvmStatic for Java interoperability; see https://developer.android.com/kotlin/interop#companion_functions [MissingJvmstatic]",
+            extraArguments = arrayOf(ARG_HIDE, "StaticUtils"),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            class Foo {
+                                companion object {
+                                    // Cannot use @JvmField here: this annotation is not applicable
+                                    // to target 'member property without backing field or delegate'
+                                    @JvmStatic
+                                    val jvmStaticPropertyWithoutBackingField
+                                        get() = 0
+
+                                    val unannotatedPropertyWithoutBackingField
+                                        get() = 0
+                                }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
index 423966cbe..72981037a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
@@ -27,10 +27,7 @@ import com.android.tools.metalava.cli.lint.API_LINT_OPTIONS_HELP
 import com.android.tools.metalava.cli.signature.SIGNATURE_FORMAT_OPTIONS_HELP
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.DEFAULT_KOTLIN_LANGUAGE_LEVEL
-import com.android.tools.metalava.reporter.Issues
 import java.io.File
-import java.util.Locale
-import kotlin.test.assertEquals
 import org.junit.Assert
 import org.junit.Test
 
@@ -49,9 +46,6 @@ Usage: metalava main [options] [flags]...
   The default sub-command that is run if no sub-command is specified.
 
 Options:
-  --config-file <file>                       A configuration file that can be consumed by Metalava. This can be
-                                             specified multiple times in which case later config files will
-                                             override/merge with earlier ones.
   --api-class-resolution [api|api:classpath]
                                              Determines how class resolution is performed when loading API signature
                                              files. Any classes that cannot be found will be treated as empty.",
@@ -86,6 +80,8 @@ $COMMON_BASELINE_OPTIONS_HELP
 
 $GENERAL_REPORTING_OPTIONS_HELP
 
+$CONFIG_FILE_OPTIONS_HELP
+
 $API_SELECTION_OPTIONS_HELP
 
 $API_LINT_OPTIONS_HELP
@@ -147,10 +143,6 @@ API sources:
                                              Specifies that errors encountered during validation of nullability
                                              annotations should not be treated as errors. They will be written out to
                                              the file specified in --nullability-warnings-txt instead.
---hide-annotation <annotation class>
-                                             Treat any elements annotated with the given annotation as hidden
---show-unannotated
-                                             Include un-annotated public APIs in the signature file as well
 --java-source <level>
                                              Sets the source level for Java source files; default is ${DEFAULT_JAVA_LANGUAGE_LEVEL}.
 --kotlin-source <level>
@@ -188,9 +180,6 @@ Generating Stubs:
                                              recently marked as non null, whereas in the documentation stubs we'll just
                                              list this as @NonNull. Another difference is that @doconly elements are
                                              included in documentation stubs, but not regular stubs, etc.
---kotlin-stubs
-                                             [CURRENTLY EXPERIMENTAL] If specified, stubs generated from Kotlin source
-                                             code will be written in Kotlin rather than the Java programming language.
 --pass-through-annotation <annotation classes>
                                              A comma separated list of fully qualified names of annotation classes that
                                              must be passed through unchanged.
@@ -259,28 +248,6 @@ $EXPECTED_HELP
         }
     }
 
-    @Test
-    fun `Test deprecated lowercase matching in issue configuration options`() {
-        commandTest {
-            args +=
-                listOf(
-                    "main",
-                    "--error",
-                    Issues.DEPRECATED_OPTION.name,
-                    "--hide",
-                    Issues.ADDED_FINAL.name.lowercase(Locale.US),
-                )
-
-            expectedStderr =
-                """
-error: Case-insensitive issue matching is deprecated, use --hide AddedFinal instead of --hide addedfinal [DeprecatedOption]
-                """
-                    .trimIndent()
-
-            verify { assertEquals(-1, exitCode, message = "exitCode") }
-        }
-    }
-
     @Test
     fun `Test for @file`() {
         val dir = temporaryFolder.newFolder()
diff --git a/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
index 5e36749f1..2b6aeb5f3 100644
--- a/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -64,8 +63,6 @@ class NormalizeOutputAnnotationTest : DriverTest() {
                         )
                         .indented(),
                     requiresPermissionSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             format = FileFormat.V4,
             api =
diff --git a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
index 802e02640..1b78e2b8a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
@@ -18,7 +18,6 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -26,7 +25,7 @@ class NullnessMigrationTest : DriverTest() {
     @Test
     fun `Test Kotlin-style null signatures`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -45,12 +44,10 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class MyTest {
                         ctor public MyTest();
@@ -84,8 +81,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
@@ -138,8 +133,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
@@ -195,8 +188,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
@@ -251,7 +242,7 @@ class NullnessMigrationTest : DriverTest() {
     @Test
     fun `Comprehensive check of migration, Kotlin-style output`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -270,8 +261,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
@@ -288,7 +277,7 @@ class NullnessMigrationTest : DriverTest() {
                 """,
             api =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public class MyTest {
                         ctor public MyTest();
@@ -339,12 +328,6 @@ class NullnessMigrationTest : DriverTest() {
                 ),
             api =
                 """
-                    package libcore.util {
-                      @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public @interface NonNull {
-                        method public abstract int from() default java.lang.Integer.MIN_VALUE;
-                        method public abstract int to() default java.lang.Integer.MAX_VALUE;
-                      }
-                    }
                     package test.pkg {
                       public class Test {
                         ctor public Test();
@@ -358,7 +341,7 @@ class NullnessMigrationTest : DriverTest() {
     @Test
     fun `Check type use annotations`() {
         check(
-            format = FileFormat.V2, // compat=false, kotlin-style-nulls=false
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -382,42 +365,25 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
-                if (SUPPORT_TYPE_USE_ANNOTATIONS) {
-                    """
-                        // Signature format: 2.0
-                        package test.pkg {
-                          public class Test {
-                            ctor public Test();
-                            method @Nullable public @Nullable Integer compute1(@Nullable java.util.List<java.lang.@Nullable String>);
-                            method @Nullable public @Nullable Integer compute2(@Nullable java.util.List<java.util.@Nullable List<?>>);
-                            method public Integer compute3(@NonNull String[][]);
-                          }
-                        }
-                    """
-                } else {
-                    """
-                        // Signature format: 2.0
-                        package test.pkg {
-                          public class Test {
-                            ctor public Test();
-                            method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
-                            method @Nullable public Integer compute2(@Nullable java.util.List<java.util.List<?>>);
-                            method public Integer compute3(@NonNull String[][]);
-                          }
-                        }
-                    """
-                },
+                """
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                        method @Nullable public compute1(@Nullable _: java.util.@Nullable List<@Nullable String>): @Nullable Integer;
+                        method @Nullable public compute2(@Nullable _: java.util.@Nullable List<java.util.@Nullable List<?>>): @Nullable Integer;
+                        method public compute3(@NonNull _: @NonNull String @Nullable [] @Nullable []): Integer;
+                      }
+                    }
+                """,
         )
     }
 
     @Test
     fun `Check androidx package annotation`() {
         check(
-            format = FileFormat.V2,
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -438,38 +404,24 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
-                if (SUPPORT_TYPE_USE_ANNOTATIONS) {
-                    """
-                        package test.pkg {
-                          public class Test {
-                            ctor public Test();
-                            method @Nullable public Integer compute1(@Nullable java.util.List<@Nullable java.lang.String>);
-                            method @Nullable public Integer compute2(@NonNull java.util.List<@NonNull java.util.List<?>>);
-                          }
-                        }
-                    """
-                } else {
-                    """
-                        package test.pkg {
-                          public class Test {
-                            ctor public Test();
-                            method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
-                            method @Nullable public Integer compute2(@NonNull java.util.List<java.util.List<?>>);
-                          }
-                        }
-                    """
-                },
+                """
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                        method @Nullable public compute1(@Nullable _: java.util.@Nullable List<@Nullable String>): @Nullable Integer;
+                        method @Nullable public compute2(@NonNull _: java.util.@NonNull List<java.util.@NonNull List<?>>): @Nullable Integer;
+                      }
+                    }
+                """,
         )
     }
 
     @Test
     fun `Migrate nullness for type-use annotations`() {
         check(
-            format = FileFormat.V2,
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -488,8 +440,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             // TODO: Handle multiple nullness annotations
             migrateNullsApi =
@@ -545,7 +495,7 @@ class NullnessMigrationTest : DriverTest() {
     @Test
     fun `Do not migrate type-use annotations when not changed`() {
         check(
-            format = FileFormat.V2,
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -562,8 +512,6 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             // TODO: Handle multiple nullness annotations
             migrateNullsApi =
@@ -615,7 +563,7 @@ class NullnessMigrationTest : DriverTest() {
     @Test
     fun `Regression test for issue 111054266, type use annotations`() {
         check(
-            format = FileFormat.V2,
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -624,7 +572,7 @@ class NullnessMigrationTest : DriverTest() {
                             import androidx.annotation.NonNull;
                             import java.lang.reflect.TypeVariable;
 
-                            public class Foo {
+                            public class Foo<T> {
                                 @NonNull public java.lang.reflect.Constructor<?> @NonNull [] getConstructors() {
                                     return null;
                                 }
@@ -637,16 +585,14 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
                     package test.pkg {
-                      public class Foo {
+                      public class Foo<T> {
                         ctor public Foo();
                         method public java.lang.reflect.Constructor<?>[] getConstructors();
-                        method public synchronized java.lang.reflect.TypeVariable<@java.lang.Class<T>>[] getTypeParameters();
+                        method public synchronized java.lang.reflect.TypeVariable<java.lang.Class<T>>[] getTypeParameters();
                       }
                     }
                 """,
@@ -657,7 +603,7 @@ class NullnessMigrationTest : DriverTest() {
                             """
                                 package test.pkg;
                                 @SuppressWarnings({"unchecked", "deprecation", "all"})
-                                public class Foo {
+                                public class Foo<T> {
                                 public Foo() { throw new RuntimeException("Stub!"); }
                                 @androidx.annotation.RecentlyNonNull
                                 public java.lang.reflect.Constructor<?> @androidx.annotation.RecentlyNonNull [] getConstructors() { throw new RuntimeException("Stub!"); }
@@ -673,7 +619,7 @@ class NullnessMigrationTest : DriverTest() {
                             """
                                 package test.pkg;
                                 @SuppressWarnings({"unchecked", "deprecation", "all"})
-                                public class Foo {
+                                public class Foo<T> {
                                 public Foo() { throw new RuntimeException("Stub!"); }
                                 @androidx.annotation.RecentlyNonNull
                                 public java.lang.reflect.Constructor<?>[] getConstructors() { throw new RuntimeException("Stub!"); }
@@ -702,7 +648,7 @@ class NullnessMigrationTest : DriverTest() {
                             import androidx.annotation.Nullable;
 
                             public interface Appendable {
-                                @NonNull Appendable append(@Nullable java.lang.CharSequence csq) throws IOException;
+                                @NonNull Appendable append(@Nullable java.lang.CharSequence csq) throws java.io.IOException;
                             }
                         """
                     ),
@@ -744,7 +690,7 @@ class NullnessMigrationTest : DriverTest() {
                     """
                         package test.pkg {
                           public interface Appendable {
-                            method public Appendable append(java.lang.CharSequence csq) throws IOException;
+                            method public Appendable append(java.lang.CharSequence csq) throws java.io.IOException;
                           }
                           public class PublicClass {
                             ctor public PublicClass(String);
@@ -771,7 +717,7 @@ class NullnessMigrationTest : DriverTest() {
                             @SuppressWarnings({"unchecked", "deprecation", "all"})
                             public interface Appendable {
                             @androidx.annotation.RecentlyNonNull
-                            public test.pkg.Appendable append(@androidx.annotation.RecentlyNullable java.lang.CharSequence csq);
+                            public test.pkg.Appendable append(@androidx.annotation.RecentlyNullable java.lang.CharSequence csq) throws java.io.IOException;
                             }
                         """
                     ),
diff --git a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
index 54e949e93..cab7b83d1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
@@ -87,9 +87,10 @@ Sub-commands:
   main                                       The default sub-command that is run if no sub-command is specified.
   android-jars-to-signatures                 Rewrite the signature files in the `prebuilts/sdk` directory in the Android
                                              source tree.
-  help                                       Provides help for general metalava concepts
+  help                                       Provides help for general metalava concepts.
   jar-to-jdiff                               Convert a jar file into a file in the JDiff XML format.
   merge-signatures                           Merge multiple signature files together into a single file.
+  signature-cat                              Cats signature files.
   signature-to-dex                           Convert API signature files into a file containing a list of DEX
                                              signatures.
   signature-to-jdiff                         Convert an API signature file into a file in the JDiff XML format.
@@ -111,7 +112,7 @@ Sub-commands:
         assertEquals(
             """
 
-                metalava version: 1.0.0-alpha12
+                metalava version: 1.0.0-alpha13
 
             """
                 .trimIndent(),
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
similarity index 90%
rename from metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
rename to metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
index 0bf9e90b9..9e378db6e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
@@ -18,17 +18,24 @@ package com.android.tools.metalava
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.cli.common.ARG_HIDE
-import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.config.ApiFlagConfig
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.IMMUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Status.ENABLED
+import com.android.tools.metalava.config.ApiFlagsConfig
+import com.android.tools.metalava.config.Config
+import com.android.tools.metalava.config.writeTo
+import com.android.tools.metalava.model.ANDROID_ANNOTATION_PACKAGE
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.KnownJarFiles
 import com.android.tools.metalava.testing.java
+import java.io.File
 import java.util.Locale
 import kotlin.test.assertEquals
 import org.junit.Test
 import org.junit.runners.Parameterized
 
-private val annotationsList = listOf(systemApiSource, flaggedApiSource, nonNullSource)
+private val annotationsList = listOf(systemApiSource, nonNullSource)
 
 private const val FULLY_QUALIFIED_SYSTEM_API_SURFACE_ANNOTATION =
     "android.annotation.SystemApi(client=android.annotation.SystemApi.Client.PRIVILEGED_APPS)"
@@ -36,15 +43,27 @@ private const val FULLY_QUALIFIED_SYSTEM_API_SURFACE_ANNOTATION =
 private const val FULLY_QUALIFIED_MODULE_LIB_API_SURFACE_ANNOTATION =
     "android.annotation.SystemApi(client=android.annotation.SystemApi.Client.MODULE_LIBRARIES)"
 
-@Suppress("JavadocDeclaration")
-class FlaggedApiTest(private val config: Configuration) : DriverTest() {
+/**
+ * A parameterized test for the `android.annotation.FlaggedApi` annotation.
+ *
+ * This tests the behavior of `@FlaggedApi` for a number of different changes across multiple API
+ * surfaces. That is necessary as currently there are significant differences in the processing that
+ * is done for:
+ * 1. An API surface that does not extend another, e.g. `public`; controlled through
+ *    `showUnannotated`.
+ * 2. An API surface that extends another, e.g. `system` which extends `public`; controlled through
+ *    `showUnannotated`, and `showAnnotations`.
+ * 2. An API surface that extends another, e.g. `system` which extends `public`; controlled through
+ *    `showUnannotated`, `showAnnotations`, and `showForStubPurposesAnnotations`.
+ */
+class ParameterizedFlaggedApiTest(private val config: Configuration) : DriverTest() {
 
     /** The configuration of the test. */
     data class Configuration(
         val surface: Surface,
         val flagged: Flagged,
     ) {
-        val extraArguments = (surface.args + flagged.args)
+        fun extraArguments(dir: File) = (surface.args + flagged.extraArguments(dir))
 
         override fun toString(): String {
             val surfaceText = surface.name.lowercase(Locale.US)
@@ -72,22 +91,98 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
     }
 
     /** The different configurations of the flagged API that this test will check. */
-    enum class Flagged(val text: String, val args: List<String>) {
-        /** Represents an API with all flagged APIs. */
-        WITH("with flagged api", emptyList()),
+    enum class Flagged(
+        val text: String,
+        val apiFlagsConfig: ApiFlagsConfig? = null,
+    ) {
+        /** Represents an API that keeps all flagged APIs. */
+        KEEP_ALL("keep all") {
+            override fun synthesizeAdditionalExpectations(expectations: Expectations) =
+                listOf(
+                    expectations,
+                    // All Expectations with flagged APIs are identical to the Expectations without
+                    // flagged APIs apart from those for feature flag `foo/bar`. So, this adds
+                    // additional Expectations without flagged APIs but with flagged APIs for
+                    // feature flag `foo/bar` flagged API that are identical to the "with flagged
+                    // APIs" except for the expectedApi which does not include `@FlaggedApi`
+                    // annotations.
+                    expectations.copy(
+                        flagged = FINALIZE_FOO_BAR_APIS,
+                        // Remove any FlaggedApi annotations from the signature files
+                        expectedApi =
+                            expectations.expectedApi.replace(flaggedApiInSignatureRegex, ""),
+                        // Remove any FlaggedApi annotations from the stubs files
+                        expectedStubs =
+                            expectations.expectedStubs
+                                .map {
+                                    val copy = TestFile()
+                                    copy.contents = it.contents.replace(flaggedApiInStubsRegex, "")
+                                    copy.targetRelativePath = it.targetRelativePath
+                                    copy
+                                }
+                                .toTypedArray()
+                    ),
+                )
+        },
 
-        /** Represents an API without any flagged APIs. */
-        WITHOUT("without  flagged api", listOf(ARG_REVERT_ANNOTATION, ANDROID_FLAGGED_API)),
+        /**
+         * Represents an API that reverts all flagged APIs.
+         *
+         * Uses `--config-file` and `<api-flags>`.
+         */
+        REVERT_ALL(
+            "revert all",
+            apiFlagsConfig = ApiFlagsConfig(),
+        ),
 
         /**
          * Represents an API without flagged APIs apart from those flagged APIs that are part of
-         * feature `foo_bar`.
+         * feature `foo_bar`. They are treated as being finalized so their `@FlaggedApi` annotations
+         * are discarded.
+         *
+         * Uses `--config-file` and `<api-flags>`.
          */
-        WITHOUT_APART_FROM_FOO_BAR_APIS(
-            "without flagged api, with foo_bar",
-            WITHOUT.args +
-                listOf(ARG_REVERT_ANNOTATION, """!$ANDROID_FLAGGED_API("test.pkg.flags.foo_bar")""")
+        FINALIZE_FOO_BAR_APIS(
+            "finalize foo_bar",
+            apiFlagsConfig =
+                ApiFlagsConfig(
+                    flags =
+                        listOf(
+                            ApiFlagConfig(
+                                pkg = "test.pkg.flags",
+                                name = "foo_bar",
+                                mutability = IMMUTABLE,
+                                status = ENABLED,
+                            ),
+                        )
+                )
         ),
+        ;
+
+        /**
+         * Synthesize additional [Expectations], if any.
+         *
+         * This is called on the [Expectations.flagged] object passing in the referencing
+         * [Expectations] to allow additional [Expectations] to be created that are based on the
+         * [expectations] by applying simple transformations. It avoids having to duplicate 90% of
+         * the test.
+         */
+        open fun synthesizeAdditionalExpectations(expectations: Expectations) = listOf(expectations)
+
+        /**
+         * Get extra command line arguments to pass.
+         *
+         * @param dir a temporary directory in which configuration files can be created.
+         */
+        fun extraArguments(dir: File) =
+            if (apiFlagsConfig != null) {
+                val config = Config(apiFlags = apiFlagsConfig)
+                val configFile = dir.resolve("flags-config.xml")
+                config.writeTo(configFile)
+                listOf(ARG_CONFIG_FILE, configFile.path)
+            } else {
+                emptyList()
+            }
     }
 
     companion object {
@@ -95,8 +190,8 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
         @JvmStatic
         @Parameterized.Parameters(name = "{0}")
         fun configurations(): Iterable<Configuration> =
-            Surface.values().flatMap { surface ->
-                Flagged.values().map { flagged ->
+            Surface.entries.flatMap { surface ->
+                Flagged.entries.map { flagged ->
                     Configuration(
                         surface = surface,
                         flagged = flagged,
@@ -157,36 +252,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
         expectationsList: List<Expectations>,
     ) {
         val transformedExpectationsList =
-            expectationsList.flatMap {
-                // All Expectations with flagged APIs are identical to the Expectations without
-                // flagged APIs apart from those for feature flag `foo/bar`. So, this adds
-                // additional Expectations without flagged APIs but with flagged APIs for feature
-                // flag `foo/bar` flagged API that are identical to the "with flagged APIs" except
-                // with for the expectedApi which does not include `@FlaggedApi` annotations.
-                if (it.flagged == Flagged.WITH) {
-                    listOf(
-                        it,
-                        it.copy(
-                            flagged = Flagged.WITHOUT_APART_FROM_FOO_BAR_APIS,
-                            // Remove any FlaggedApi annotations from the signature files
-                            expectedApi = it.expectedApi.replace(flaggedApiInSignatureRegex, ""),
-                            // Remove any FlaggedApi annotations from the stubs files
-                            expectedStubs =
-                                it.expectedStubs
-                                    .map {
-                                        val copy = TestFile()
-                                        copy.contents =
-                                            it.contents.replace(flaggedApiInStubsRegex, "")
-                                        copy.targetRelativePath = it.targetRelativePath
-                                        copy
-                                    }
-                                    .toTypedArray()
-                        ),
-                    )
-                } else {
-                    listOf(it)
-                }
-            }
+            expectationsList.flatMap { it.flagged.synthesizeAdditionalExpectations(it) }
 
         val filterExpectations =
             transformedExpectationsList.filter {
@@ -238,7 +304,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 "--warning",
                 "UnflaggedApi",
                 *apiVersionsArgs,
-                *config.extraArguments.toTypedArray(),
+                *config.extraArguments(temporaryFolder.root).toTypedArray(),
                 *extraArguments,
             )
 
@@ -258,10 +324,10 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         addAll(sourceFiles)
                         addAll(annotationsList)
                         add(flagsFile)
-                        // Hide android.annotation classes.
-                        add(KnownSourceFiles.androidAnnotationHide)
                     }
                     .toTypedArray(),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             api = expectations.expectedApi,
             stubFiles = expectations.expectedStubs,
             stubPaths = expectations.expectedStubPaths,
@@ -270,7 +336,8 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
             // Do not include flags in the output but do not mark them as hide or removed.
             // This is needed to verify that the code to always inline the values of
             // FlaggedApi annotations even when not hidden or removed is working correctly.
-            skipEmitPackages = listOf("test.pkg.flags"),
+            // Do not emit android.annotation classes either.
+            skipEmitPackages = listOf("test.pkg.flags", ANDROID_ANNOTATION_PACKAGE),
             extraArguments = args,
         )
 
@@ -291,7 +358,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
      * surfaces in that order.
      */
     private fun contributingSurfaces(apiSurfaces: Map<Surface, String>) =
-        Surface.values().filter { it <= config.surface }.map { apiSurfaces[it] ?: "" }
+        Surface.entries.filter { it <= config.surface }.map { apiSurfaces[it] ?: "" }
 
     @Test
     fun `Basic test that FlaggedApi annotated items can be hidden`() {
@@ -332,7 +399,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -360,7 +427,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -385,7 +452,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -415,7 +482,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -485,7 +552,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -501,7 +568,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -514,7 +581,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -527,7 +594,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -596,7 +663,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -613,7 +680,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -629,7 +696,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -642,7 +709,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -677,7 +744,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -750,7 +817,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -758,7 +825,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -766,7 +833,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -807,7 +874,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -818,7 +885,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // Check the module lib stubs without flagged apis.
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -861,6 +928,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
             )
         checkFlaggedApis(
             java(
+                @Suppress("JavadocDeclaration")
                 """
                     package test.pkg;
 
@@ -914,7 +982,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // members.
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -930,7 +998,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         // Even without flagged APIs the class is still part of the public API
                         // because being annotated with @FlaggedApi does not cause it to be removed
                         // it was previously part of a released API. However, the new members did
@@ -950,7 +1018,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // FlaggedApi because it has moved to public and has new members.
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         // This is expected to be empty as the API has moved to public.
                         expectedApi =
                             """
@@ -963,7 +1031,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         // Even without flagged APIs the class is still part of the system API
                         // because being annotated with @FlaggedApi does not cause it to be removed
                         // it was previously part of a released API. However, the new members did
@@ -986,7 +1054,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // with FlaggedApi because it has moved to public and has new members.
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         // This is expected to be empty as the API has moved to public.
                         expectedApi =
                             """
@@ -999,7 +1067,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         // Even without flagged APIs the class is still part of the module lib API
                         // because being annotated with @FlaggedApi does not cause it to be removed
                         // it was previously part of a released API. However, the new members did
@@ -1054,6 +1122,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
             )
         checkFlaggedApis(
             java(
+                @Suppress("JavadocDeclaration")
                 """
                     package test.pkg;
 
@@ -1110,7 +1179,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // FlaggedApi because it has new members.
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1126,7 +1195,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         // Even without flagged APIs the class is still part of the system API
                         // because being annotated with @FlaggedApi does not cause it to be removed
                         // it was previously part of a released API. However, the new members did
@@ -1146,7 +1215,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     // with FlaggedApi because it has moved to system API and has new members.
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         // This is expected to be empty as the API has moved to system.
                         expectedApi =
                             """
@@ -1159,7 +1228,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         // Even without flagged APIs the class is still part of the module lib API
                         // because being annotated with @FlaggedApi does not cause it to be removed
                         // it was previously part of a released API. However, the new members did
@@ -1243,7 +1312,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1258,7 +1327,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1272,7 +1341,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1282,7 +1351,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1376,7 +1445,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1394,7 +1463,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         expectedApiVersions =
                             """
                                 <?xml version="1.0" encoding="utf-8"?>
-                                <api version="3" min="30">
+                                <api version="3" min="33">
                                   <class name="test/pkg/Foo" since="33">
                                     <method name="&lt;init>()V"/>
                                     <method name="abstractMethod()V"/>
@@ -1407,7 +1476,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1425,7 +1494,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         expectedApiVersions =
                             """
                                 <?xml version="1.0" encoding="utf-8"?>
-                                <api version="3" min="30">
+                                <api version="3" min="33">
                                   <class name="test/pkg/Foo" since="33">
                                     <method name="&lt;init>()V"/>
                                     <method name="abstractMethod()V"/>
@@ -1438,7 +1507,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1447,7 +1516,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1456,7 +1525,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1465,7 +1534,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1630,6 +1699,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 """
             ),
             java(
+                @Suppress("DeprecatedIsStillUsed")
                 """
                     package test.pkg;
 
@@ -1673,7 +1743,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1698,7 +1768,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         expectedApiVersions =
                             """
                                 <?xml version="1.0" encoding="utf-8"?>
-                                <api version="3" min="30">
+                                <api version="3" min="33">
                                   <class name="test/pkg/Bar" since="33" deprecated="33">
                                     <method name="&lt;init>()V"/>
                                     <method name="method()V"/>
@@ -1718,7 +1788,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1743,7 +1813,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         expectedApiVersions =
                             """
                                 <?xml version="1.0" encoding="utf-8"?>
-                                <api version="3" min="30">
+                                <api version="3" min="33">
                                   <class name="test/pkg/Bar" since="33">
                                     <method name="&lt;init>()V"/>
                                     <method name="method()V"/>
@@ -1763,7 +1833,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1772,7 +1842,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1781,7 +1851,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1790,7 +1860,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1897,7 +1967,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 listOf(
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1914,7 +1984,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.PUBLIC,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             // TODO(b/337840740): Foo should have method().
                             """
@@ -1931,7 +2001,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1940,7 +2010,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.SYSTEM,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1949,7 +2019,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITH,
+                        Flagged.KEEP_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
@@ -1958,7 +2028,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                     ),
                     Expectations(
                         Surface.MODULE_LIB,
-                        Flagged.WITHOUT,
+                        Flagged.REVERT_ALL,
                         expectedApi =
                             """
                                 // Signature format: 2.0
diff --git a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
index 608ffcd74..65d71603a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
@@ -18,33 +18,26 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.getAndroidJar
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
+import com.android.tools.metalava.testing.standardProjectXmlClasspath
 import com.android.tools.metalava.testing.xml
 import org.junit.Test
 
 @RequiresCapabilities(Capability.KOTLIN)
 class ProjectDescriptionTest : DriverTest() {
-
     @Test
     fun `conflict declarations`() {
         // Example from b/364480872
         // Conflict declarations in Foo.java and Foo.kt are intentional.
         // project.xml will use "androidMain" as root so that it can discard one in jvmMain.
         check(
-            commonSourceFiles =
-                arrayOf(
-                    kotlin(
-                        "commonMain/src/some/common/Bogus.kt",
-                        """
-                            // bogus file to trigger multi-folder structure
-                            package some.common
-
-                            class Bogus
-                        """
-                    )
-                ),
+            expectedIssues =
+                "jvmMain/src/some/pkg/Foo.java:3: warning: Attempted to register some.pkg.Foo twice; once from TESTROOT/androidMain/src/some/pkg/Foo.kt and this one from TESTROOT/jvmMain/src/some/pkg/Foo.java [DuplicateSourceClass]",
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -122,4 +115,142 @@ class ProjectDescriptionTest : DriverTest() {
                 """
         )
     }
+
+    @Test
+    fun `jvm annotations with invalid root dir`() {
+        check(
+            apiLint = "",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        "src/androidMain/some/pkg/Foo.kt",
+                        """
+                            package some.pkg
+
+                            class Foo {
+                                @JvmName("renamed")
+                                fun wrongName() = Unit
+
+                              companion object {
+                                @JvmStatic
+                                public fun foo(x: String): String {
+                                  return x
+                                }
+                              }
+                            }
+                        """
+                    ),
+                ),
+            projectDescription =
+                xml(
+                    "project.xml",
+                    """
+                        <project>
+                          <root dir="src/androidMain"/>
+                          <module name="androidMain" android="true">
+                            <src file="src/androidMain/some/pkg/Foo.kt" />
+                            $standardProjectXmlClasspath
+                          </module>
+                        </project>
+                    """
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package some.pkg {
+                  public final class Foo {
+                    ctor public Foo();
+                    method public static String foo(String x);
+                    method public void renamed();
+                    field public static final some.pkg.Foo.Companion Companion;
+                  }
+                  public static final class Foo.Companion {
+                    method public String foo(String x);
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `delegate property with invalid root dir`() {
+        check(
+            apiLint = "",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        "src/androidMain/some/pkg/Foo.kt",
+                        """
+                            package some.pkg
+                            class Foo {
+                                val lazyVal by lazy { 1 }
+                            }
+                        """
+                    )
+                ),
+            projectDescription =
+                xml(
+                    "project.xml",
+                    """
+                        <project>
+                          <root dir="src/androidMain"/>
+                          <module name="androidMain">
+                            <src file="src/androidMain/some/pkg/Foo.kt"/>
+                            $standardProjectXmlClasspath
+                          </module>
+                        </project>
+                    """
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package some.pkg {
+                  public final class Foo {
+                    ctor public Foo();
+                    method public int getLazyVal();
+                    property public int lazyVal;
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `public api in common`() {
+        val commonSrc =
+            kotlin(
+                "commonMain/src/test/pkg/Common.kt",
+                """
+                package test.pkg
+                class Common
+                """
+            )
+        val androidSrc =
+            kotlin(
+                "androidMain/src/test/pkg/Android.kt",
+                """
+                package test.pkg
+                class Android
+                """
+            )
+        check(
+            sourceFiles = arrayOf(androidSrc, commonSrc),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSrc)),
+                    createCommonModuleDescription(arrayOf(commonSrc)),
+                ),
+            api =
+                """
+                package test.pkg {
+                  public final class Android {
+                    ctor public Android();
+                  }
+                  public final class Common {
+                    ctor public Common();
+                  }
+                }
+                """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
index 203e690e5..2dc036ab0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
@@ -21,7 +21,6 @@ import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -70,8 +69,6 @@ class ShowAnnotationTest : DriverTest() {
                 """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -127,8 +124,6 @@ class ShowAnnotationTest : DriverTest() {
                 """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -186,8 +181,6 @@ class ShowAnnotationTest : DriverTest() {
                     """
                     ),
                     testApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -244,8 +237,6 @@ class ShowAnnotationTest : DriverTest() {
                     }
                     """
                     ),
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             stubFiles =
                 arrayOf(
@@ -326,8 +317,6 @@ class ShowAnnotationTest : DriverTest() {
                 """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -403,7 +392,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `showAnnotation with parameters`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -433,8 +422,6 @@ class ShowAnnotationTest : DriverTest() {
                     """
                     ),
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -519,7 +506,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Testing parsing an annotation whose attribute references the annotated class`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -541,7 +528,7 @@ class ShowAnnotationTest : DriverTest() {
                 """,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.room {
                   @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface OnConflictStrategy {
                     field public static final int REPLACE = 1; // 0x1
@@ -555,7 +542,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Testing that file order does not affect output`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -601,13 +588,11 @@ class ShowAnnotationTest : DriverTest() {
                     """
                     ),
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             expectedIssues = null,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package a {
                   @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class Example1<T> {
                     ctor public Example1();
@@ -655,8 +640,6 @@ class ShowAnnotationTest : DriverTest() {
                     }
                     """
                     ),
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             classpath =
                 arrayOf(
@@ -706,7 +689,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Check @PublishedApi handling`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -724,7 +707,7 @@ class ShowAnnotationTest : DriverTest() {
             extraArguments = arrayOf(ARG_SHOW_ANNOTATION, "kotlin.PublishedApi"),
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   @kotlin.PublishedApi internal final class WeAreSoCool {
                     ctor public WeAreSoCool();
@@ -870,8 +853,6 @@ class ShowAnnotationTest : DriverTest() {
                     ),
                     systemApiSource,
                     testApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
diff --git a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
index 751475f16..5d203e03e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
@@ -21,7 +21,10 @@ import com.android.tools.metalava.model.testing.FilterAction.EXCLUDE
 import com.android.tools.metalava.model.testing.FilterByProvider
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.createAndroidModuleDescription
+import com.android.tools.metalava.testing.createCommonModuleDescription
+import com.android.tools.metalava.testing.createModuleDescription
+import com.android.tools.metalava.testing.createProjectDescription
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
@@ -93,10 +96,10 @@ abstract class UastTestBase : DriverTest() {
                 """
                     )
                 ),
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.annotation.experimental {
                   @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.CONSTRUCTOR, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER, kotlin.annotation.AnnotationTarget.PROPERTY_SETTER, kotlin.annotation.AnnotationTarget.FILE, kotlin.annotation.AnnotationTarget.TYPEALIAS}) public @interface UseExperimental {
                     method public abstract $klass<? extends java.lang.annotation.Annotation>[] markerClass();
@@ -137,10 +140,10 @@ abstract class UastTestBase : DriverTest() {
                         method public boolean isInitiallyEnabled();
                         method public boolean isInterpolated();
                         method public void updateOtherColors(int[]);
-                        property public final int[] colors;
-                        property public final boolean initiallyEnabled;
-                        property public final boolean interpolated;
-                        property public final int[] otherColors;
+                        property public int[] colors;
+                        property public boolean initiallyEnabled;
+                        property public boolean interpolated;
+                        property public int[] otherColors;
                       }
                     }
                 """
@@ -155,10 +158,10 @@ abstract class UastTestBase : DriverTest() {
                         method public int[] getOtherColors();
                         method public boolean isInitiallyEnabled();
                         method public void updateOtherColors(int[]);
-                        property public final int[] colors;
-                        property public final boolean initiallyEnabled;
-                        property public final boolean interpolated;
-                        property public final int[] otherColors;
+                        property public int[] colors;
+                        property public boolean initiallyEnabled;
+                        property public boolean interpolated;
+                        property public int[] otherColors;
                       }
                     }
                 """
@@ -177,10 +180,10 @@ abstract class UastTestBase : DriverTest() {
                             val interpolated: Boolean,
                         ) {
                             @get:JvmName("isInitiallyEnabled")
-                            val initiallyEnabled: Boolean
+                            val initiallyEnabled: Boolean = false
 
                             @set:JvmName("updateOtherColors")
-                            var otherColors: IntArray
+                            var otherColors: IntArray = arrayOf()
                         }
                     """
                     )
@@ -215,8 +218,8 @@ abstract class UastTestBase : DriverTest() {
                     method public test.pkg.Foo copy(@test.pkg.MyAnnotation int p1, String p2);
                     method public int getP1();
                     method public String getP2();
-                    property @test.pkg.MyAnnotation public final int p1;
-                    property public final String p2;
+                    property @test.pkg.MyAnnotation public int p1;
+                    property public String p2;
                   }
                   @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
                   }
@@ -229,10 +232,7 @@ abstract class UastTestBase : DriverTest() {
     fun `declarations with value class in its signature`() {
         // https://youtrack.jetbrains.com/issue/KT-57546
         // https://youtrack.jetbrains.com/issue/KT-57577
-        val mod = if (isK2) "" else " final"
         // https://youtrack.jetbrains.com/issue/KT-72078
-        val horizontalType = if (isK2) "test.pkg.Alignment.Horizontal" else "int"
-        val verticalType = if (isK2) "test.pkg.Alignment.Vertical" else "int"
         check(
             sourceFiles =
                 arrayOf(
@@ -287,20 +287,20 @@ abstract class UastTestBase : DriverTest() {
                 """
                 package test.pkg {
                   public final class Alignment {
-                    ctor public Alignment($horizontalType horizontal, $verticalType vertical);
+                    ctor public Alignment(int horizontal, int vertical);
                     method public int getHorizontal();
                     method public int getVertical();
-                    property public$mod int horizontal;
-                    property public$mod int vertical;
+                    property public int horizontal;
+                    property public int vertical;
                     field public static final test.pkg.Alignment.Companion Companion;
                   }
                   public static final class Alignment.Companion {
                     method public int getStart();
                     method public int getTop();
                     method public test.pkg.Alignment getTopStart();
-                    property public$mod int Start;
-                    property public$mod int Top;
-                    property public final test.pkg.Alignment TopStart;
+                    property public int Start;
+                    property public int Top;
+                    property public test.pkg.Alignment TopStart;
                   }
                   @kotlin.jvm.JvmInline public static final value class Alignment.Horizontal {
                     field public static final test.pkg.Alignment.Horizontal.Companion Companion;
@@ -309,9 +309,9 @@ abstract class UastTestBase : DriverTest() {
                     method public int getCenterHorizontally();
                     method public int getEnd();
                     method public int getStart();
-                    property public$mod int CenterHorizontally;
-                    property public$mod int End;
-                    property public$mod int Start;
+                    property public int CenterHorizontally;
+                    property public int End;
+                    property public int Start;
                   }
                   @kotlin.jvm.JvmInline public static final value class Alignment.Vertical {
                     field public static final test.pkg.Alignment.Vertical.Companion Companion;
@@ -320,9 +320,9 @@ abstract class UastTestBase : DriverTest() {
                     method public int getBottom();
                     method public int getCenterVertically();
                     method public int getTop();
-                    property public$mod int Bottom;
-                    property public$mod int CenterVertically;
-                    property public$mod int Top;
+                    property public int Bottom;
+                    property public int CenterVertically;
+                    property public int Top;
                   }
                   @kotlin.jvm.JvmInline public final value class AnchorType {
                     field public static final test.pkg.AnchorType.Companion Companion;
@@ -331,9 +331,9 @@ abstract class UastTestBase : DriverTest() {
                     method public float getCenter();
                     method public float getEnd();
                     method public float getStart();
-                    property public final float Center;
-                    property public final float End;
-                    property public final float Start;
+                    property public float Center;
+                    property public float End;
+                    property public float Start;
                   }
                   public final class User {
                     ctor public User(float p, float q);
@@ -342,8 +342,8 @@ abstract class UastTestBase : DriverTest() {
                     method public float getP();
                     method public float getQ();
                     method public void setQ(float);
-                    property public$mod float p;
-                    property public$mod float q;
+                    property public float p;
+                    property public float q;
                   }
                 }
         """
@@ -376,8 +376,8 @@ abstract class UastTestBase : DriverTest() {
                     ctor public Test();
                     method public java.util.Set<java.lang.String> getLazyProp();
                     method public String getProp();
-                    property public final java.util.Set<java.lang.String> lazyProp;
-                    property public final String prop;
+                    property public java.util.Set<java.lang.String> lazyProp;
+                    property public String prop;
                   }
                 }
                 """
@@ -432,7 +432,7 @@ abstract class UastTestBase : DriverTest() {
                   public final class Foo {
                     ctor public Foo(int x);
                     method public int getX();
-                    property public final int x;
+                    property public int x;
                   }
                   public final class FooComparator implements java.util.Comparator<test.pkg.Foo> {
                     ctor public FooComparator();
@@ -460,8 +460,6 @@ abstract class UastTestBase : DriverTest() {
                     """
                     ),
                     requiresApiSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -525,7 +523,7 @@ abstract class UastTestBase : DriverTest() {
                   public enum State {
                     method public boolean isAtLeast(test.pkg.State state);
                     method public boolean isFinished();
-                    property public final boolean isFinished;
+                    property public boolean isFinished;
                     enum_constant public static final test.pkg.State BLOCKED;
                     enum_constant public static final test.pkg.State CANCELLED;
                     enum_constant public static final test.pkg.State ENQUEUED;
@@ -564,7 +562,7 @@ abstract class UastTestBase : DriverTest() {
                   public final class Foo {
                     ctor public Foo();
                     method public java.util.List<test.pkg.Bar> getBars();
-                    property public final java.util.List<test.pkg.Bar> bars;
+                    property public java.util.List<test.pkg.Bar> bars;
                   }
                 }
             """
@@ -983,7 +981,7 @@ abstract class UastTestBase : DriverTest() {
                 package test.pkg {
                   public final class PrepareGetCredentialResponse {
                     method public kotlin.jvm.functions.Function0<java.lang.Boolean>? getHasAuthResultsDelegate();
-                    property public final kotlin.jvm.functions.Function0<java.lang.Boolean>? hasAuthResultsDelegate;
+                    property public kotlin.jvm.functions.Function0<java.lang.Boolean>? hasAuthResultsDelegate;
                   }
                 }
             """
@@ -1039,9 +1037,9 @@ abstract class UastTestBase : DriverTest() {
                     field public static final int NO_ERROR = -1; // 0xffffffff
                   }
                   public static final class RemoteAuthClient.Companion {
-                    property public static final int ERROR_PHONE_UNAVAILABLE;
-                    property public static final int ERROR_UNSUPPORTED;
-                    property public static final int NO_ERROR;
+                    property public static int ERROR_PHONE_UNAVAILABLE;
+                    property public static int ERROR_UNSUPPORTED;
+                    property public static int NO_ERROR;
                   }
                   @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @test.pkg.MyIntDef({test.pkg.RemoteAuthClient.NO_ERROR, test.pkg.RemoteAuthClient.ERROR_UNSUPPORTED, test.pkg.RemoteAuthClient.ERROR_PHONE_UNAVAILABLE}) public static @interface RemoteAuthClient.Companion.ErrorCode {
                   }
@@ -1084,14 +1082,14 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnBoth(int);
                         method @Deprecated @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnGetter(int);
                         method @Deprecated @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnSetter(int);
-                        property @Deprecated public int pOld_deprecatedOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnBoth;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnSetter;
-                        property @Deprecated public int pOld_deprecatedOnProperty;
-                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnBoth;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnSetter;
+                        property @Deprecated public abstract int pOld_deprecatedOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnBoth;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnSetter;
+                        property @Deprecated public abstract int pOld_deprecatedOnProperty;
+                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnBoth;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnSetter;
                         property public abstract int pOld_deprecatedOnSetter;
                         property @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnSetter_myAnnoOnBoth;
                         property @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnSetter_myAnnoOnGetter;
@@ -1101,31 +1099,31 @@ abstract class UastTestBase : DriverTest() {
                         ctor public Test_accessors();
                         method public String? getPNew_accessors();
                         method @Deprecated public String? getPOld_accessors_deprecatedOnGetter();
-                        method public String? getPOld_accessors_deprecatedOnProperty();
+                        method @Deprecated public String? getPOld_accessors_deprecatedOnProperty();
                         method public String? getPOld_accessors_deprecatedOnSetter();
                         method public void setPNew_accessors(String?);
                         method public void setPOld_accessors_deprecatedOnGetter(String?);
-                        method public void setPOld_accessors_deprecatedOnProperty(String?);
+                        method @Deprecated public void setPOld_accessors_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_accessors_deprecatedOnSetter(String?);
-                        property public final String? pNew_accessors;
+                        property public String? pNew_accessors;
                         property @Deprecated public String? pOld_accessors_deprecatedOnGetter;
                         property @Deprecated public String? pOld_accessors_deprecatedOnProperty;
-                        property public final String? pOld_accessors_deprecatedOnSetter;
+                        property public String? pOld_accessors_deprecatedOnSetter;
                       }
                       public final class Test_getter {
                         ctor public Test_getter();
                         method public String? getPNew_getter();
                         method @Deprecated public String? getPOld_getter_deprecatedOnGetter();
-                        method public String? getPOld_getter_deprecatedOnProperty();
+                        method @Deprecated public String? getPOld_getter_deprecatedOnProperty();
                         method public String? getPOld_getter_deprecatedOnSetter();
                         method public void setPNew_getter(String?);
                         method public void setPOld_getter_deprecatedOnGetter(String?);
                         method @Deprecated public void setPOld_getter_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_getter_deprecatedOnSetter(String?);
-                        property public final String? pNew_getter;
+                        property public String? pNew_getter;
                         property @Deprecated public String? pOld_getter_deprecatedOnGetter;
                         property @Deprecated public String? pOld_getter_deprecatedOnProperty;
-                        property public final String? pOld_getter_deprecatedOnSetter;
+                        property public String? pOld_getter_deprecatedOnSetter;
                       }
                       public final class Test_noAccessor {
                         ctor public Test_noAccessor();
@@ -1137,10 +1135,10 @@ abstract class UastTestBase : DriverTest() {
                         method public void setPOld_noAccessor_deprecatedOnGetter(String);
                         method @Deprecated public void setPOld_noAccessor_deprecatedOnProperty(String);
                         method @Deprecated public void setPOld_noAccessor_deprecatedOnSetter(String);
-                        property public final String pNew_noAccessor;
+                        property public String pNew_noAccessor;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnGetter;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnProperty;
-                        property public final String pOld_noAccessor_deprecatedOnSetter;
+                        property public String pOld_noAccessor_deprecatedOnSetter;
                       }
                       public final class Test_setter {
                         ctor public Test_setter();
@@ -1150,12 +1148,12 @@ abstract class UastTestBase : DriverTest() {
                         method public String? getPOld_setter_deprecatedOnSetter();
                         method public void setPNew_setter(String?);
                         method public void setPOld_setter_deprecatedOnGetter(String?);
-                        method public void setPOld_setter_deprecatedOnProperty(String?);
+                        method @Deprecated public void setPOld_setter_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_setter_deprecatedOnSetter(String?);
-                        property public final String? pNew_setter;
+                        property public String? pNew_setter;
                         property @Deprecated public String? pOld_setter_deprecatedOnGetter;
                         property @Deprecated public String? pOld_setter_deprecatedOnProperty;
-                        property public final String? pOld_setter_deprecatedOnSetter;
+                        property public String? pOld_setter_deprecatedOnSetter;
                       }
                     }
                 """
@@ -1181,44 +1179,44 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnBoth(int);
                         method @Deprecated @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnGetter(int);
                         method @Deprecated @test.pkg.MyAnnotation public void setPOld_deprecatedOnSetter_myAnnoOnSetter(int);
-                        property @Deprecated public int pOld_deprecatedOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnBoth;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnGetter_myAnnoOnSetter;
-                        property @Deprecated public int pOld_deprecatedOnProperty;
-                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnBoth;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnGetter;
-                        property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnSetter;
-                        property public int pOld_deprecatedOnSetter;
-                        property public int pOld_deprecatedOnSetter_myAnnoOnBoth;
-                        property public int pOld_deprecatedOnSetter_myAnnoOnGetter;
-                        property public int pOld_deprecatedOnSetter_myAnnoOnSetter;
+                        property @Deprecated public abstract int pOld_deprecatedOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnBoth;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnGetter_myAnnoOnSetter;
+                        property @Deprecated public abstract int pOld_deprecatedOnProperty;
+                        property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnBoth;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnGetter;
+                        property @Deprecated @test.pkg.MyAnnotation public abstract int pOld_deprecatedOnProperty_myAnnoOnSetter;
+                        property public abstract int pOld_deprecatedOnSetter;
+                        property public abstract int pOld_deprecatedOnSetter_myAnnoOnBoth;
+                        property public abstract int pOld_deprecatedOnSetter_myAnnoOnGetter;
+                        property public abstract int pOld_deprecatedOnSetter_myAnnoOnSetter;
                       }
                       public final class Test_accessors {
                         ctor public Test_accessors();
                         method public String? getPNew_accessors();
                         method @Deprecated public String? getPOld_accessors_deprecatedOnGetter();
-                        method public String? getPOld_accessors_deprecatedOnProperty();
+                        method @Deprecated public String? getPOld_accessors_deprecatedOnProperty();
                         method public void setPNew_accessors(String?);
-                        method public void setPOld_accessors_deprecatedOnProperty(String?);
+                        method @Deprecated public void setPOld_accessors_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_accessors_deprecatedOnSetter(String?);
-                        property public final String? pNew_accessors;
+                        property public String? pNew_accessors;
                         property @Deprecated public String? pOld_accessors_deprecatedOnGetter;
                         property @Deprecated public String? pOld_accessors_deprecatedOnProperty;
-                        property public final String? pOld_accessors_deprecatedOnSetter;
+                        property public String? pOld_accessors_deprecatedOnSetter;
                       }
                       public final class Test_getter {
                         ctor public Test_getter();
                         method public String? getPNew_getter();
                         method @Deprecated public String? getPOld_getter_deprecatedOnGetter();
-                        method public String? getPOld_getter_deprecatedOnProperty();
+                        method @Deprecated public String? getPOld_getter_deprecatedOnProperty();
                         method public void setPNew_getter(String?);
                         method @Deprecated public void setPOld_getter_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_getter_deprecatedOnSetter(String?);
-                        property public final String? pNew_getter;
+                        property public String? pNew_getter;
                         property @Deprecated public String? pOld_getter_deprecatedOnGetter;
                         property @Deprecated public String? pOld_getter_deprecatedOnProperty;
-                        property public final String? pOld_getter_deprecatedOnSetter;
+                        property public String? pOld_getter_deprecatedOnSetter;
                       }
                       public final class Test_noAccessor {
                         ctor public Test_noAccessor();
@@ -1228,10 +1226,10 @@ abstract class UastTestBase : DriverTest() {
                         method public void setPNew_noAccessor(String);
                         method @Deprecated public void setPOld_noAccessor_deprecatedOnProperty(String);
                         method @Deprecated public void setPOld_noAccessor_deprecatedOnSetter(String);
-                        property public final String pNew_noAccessor;
+                        property public String pNew_noAccessor;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnGetter;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnProperty;
-                        property public final String pOld_noAccessor_deprecatedOnSetter;
+                        property public String pOld_noAccessor_deprecatedOnSetter;
                       }
                       public final class Test_setter {
                         ctor public Test_setter();
@@ -1239,12 +1237,12 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated public String? getPOld_setter_deprecatedOnGetter();
                         method @Deprecated public String? getPOld_setter_deprecatedOnProperty();
                         method public void setPNew_setter(String?);
-                        method public void setPOld_setter_deprecatedOnProperty(String?);
+                        method @Deprecated public void setPOld_setter_deprecatedOnProperty(String?);
                         method @Deprecated public void setPOld_setter_deprecatedOnSetter(String?);
-                        property public final String? pNew_setter;
+                        property public String? pNew_setter;
                         property @Deprecated public String? pOld_setter_deprecatedOnGetter;
                         property @Deprecated public String? pOld_setter_deprecatedOnProperty;
-                        property public final String? pOld_setter_deprecatedOnSetter;
+                        property public String? pOld_setter_deprecatedOnSetter;
                       }
                     }
                 """
@@ -1423,7 +1421,6 @@ abstract class UastTestBase : DriverTest() {
     @Test
     fun `actual typealias -- without value class`() {
         // https://youtrack.jetbrains.com/issue/KT-55085
-        val typeAliasExpanded = if (isK2) "test.pkg.NativePointerKeyboardModifiers" else "int"
         val commonSource =
             kotlin(
                 "commonMain/src/test/pkg/PointerEvent.kt",
@@ -1439,12 +1436,10 @@ abstract class UastTestBase : DriverTest() {
                         class PointerKeyboardModifiers(internal val packedValue: NativePointerKeyboardModifiers)
                         """
             )
-        check(
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        "androidMain/src/test/pkg/PointerEvent.android.kt",
-                        """
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/PointerEvent.android.kt",
+                """
                         package test.pkg
 
                         actual class PointerEvent {
@@ -1453,20 +1448,24 @@ abstract class UastTestBase : DriverTest() {
 
                         internal actual typealias NativePointerKeyboardModifiers = Int
                         """
-                    ),
-                    commonSource,
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
                 ),
-            commonSourceFiles = arrayOf(commonSource),
             api =
                 """
                 package test.pkg {
                   public final class PointerEvent {
                     ctor public PointerEvent();
                     method public test.pkg.PointerKeyboardModifiers getKeyboardModifiers();
-                    property public final test.pkg.PointerKeyboardModifiers keyboardModifiers;
+                    property public test.pkg.PointerKeyboardModifiers keyboardModifiers;
                   }
                   public final class PointerKeyboardModifiers {
-                    ctor public PointerKeyboardModifiers($typeAliasExpanded packedValue);
+                    ctor public PointerKeyboardModifiers(int packedValue);
                   }
                 }
                 """
@@ -1476,7 +1475,6 @@ abstract class UastTestBase : DriverTest() {
     @Test
     fun `actual typealias -- without common split`() {
         // https://youtrack.jetbrains.com/issue/KT-55085
-        val typeAliasExpanded = if (isK2) "test.pkg.NativePointerKeyboardModifiers" else "int"
         check(
             sourceFiles =
                 arrayOf(
@@ -1513,11 +1511,11 @@ abstract class UastTestBase : DriverTest() {
                 package test.pkg {
                   public final class PointerEvent {
                     ctor public PointerEvent();
-                    method public $typeAliasExpanded getKeyboardModifiers();
-                    property public final $typeAliasExpanded keyboardModifiers;
+                    method public int getKeyboardModifiers();
+                    property public int keyboardModifiers;
                   }
                   @kotlin.jvm.JvmInline public final value class PointerKeyboardModifiers {
-                    ctor public PointerKeyboardModifiers($typeAliasExpanded packedValue);
+                    ctor public PointerKeyboardModifiers(int packedValue);
                   }
                 }
                 """
@@ -1547,12 +1545,10 @@ abstract class UastTestBase : DriverTest() {
                         value class PointerKeyboardModifiers(internal val packedValue: NativePointerKeyboardModifiers)
                         """
             )
-        check(
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        "androidMain/src/test/pkg/PointerEvent.android.kt",
-                        """
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/PointerEvent.android.kt",
+                """
                         package test.pkg
 
                         actual class PointerEvent {
@@ -1561,17 +1557,21 @@ abstract class UastTestBase : DriverTest() {
 
                         internal actual typealias NativePointerKeyboardModifiers = Int
                         """
-                    ),
-                    commonSource,
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
                 ),
-            commonSourceFiles = arrayOf(commonSource),
             api =
                 """
                 package test.pkg {
                   public final class PointerEvent {
                     ctor public PointerEvent();
                     method public int getKeyboardModifiers();
-                    property public final int keyboardModifiers;
+                    property public int keyboardModifiers;
                   }
                   @kotlin.jvm.JvmInline public final value class PointerKeyboardModifiers {
                     ctor public PointerKeyboardModifiers($typeAliasExpanded packedValue);
@@ -1595,12 +1595,10 @@ abstract class UastTestBase : DriverTest() {
                     public expect inline fun TestClass.test2(a: Int = 0)
                 """
             )
-        check(
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        "androidMain/src/pkg/TestClass.kt",
-                        """
+        val androidSource =
+            kotlin(
+                "androidMain/src/pkg/TestClass.kt",
+                """
                             package pkg
                             public actual class TestClass {
                               public actual fun test1(a: Int) {}
@@ -1608,10 +1606,14 @@ abstract class UastTestBase : DriverTest() {
                             public actual inline fun TestClass.test2(a: Int) {
                             }
                         """
-                    ),
-                    commonSource,
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
                 ),
-            commonSourceFiles = arrayOf(commonSource),
             api =
                 """
                 package pkg {
@@ -1626,4 +1628,428 @@ abstract class UastTestBase : DriverTest() {
                 """
         )
     }
+
+    @Test
+    fun `JvmDefaultWithCompatibility as typealias actual`() {
+        val commonSources =
+            arrayOf(
+                kotlin(
+                    "commonMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                    """
+                    package pkg
+                    internal expect annotation class JvmDefaultWithCompatibility()
+                """
+                ),
+                kotlin(
+                    "commonMain/src/pkg2/TestInterface.kt",
+                    """
+                    package pkg2
+
+                    import pkg.JvmDefaultWithCompatibility
+
+                    @JvmDefaultWithCompatibility()
+                    interface TestInterface {
+                      fun foo()
+                    }
+                """
+                ),
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                """
+                            package pkg
+                            internal actual typealias JvmDefaultWithCompatibility = kotlin.jvm.JvmDefaultWithCompatibility
+                        """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, *commonSources),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(commonSources),
+                ),
+            api =
+                """
+                package pkg2 {
+                  @kotlin.jvm.JvmDefaultWithCompatibility public interface TestInterface {
+                    method public void foo();
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `JvmDefaultWithCompatibility as typealias actual using renamed import`() {
+        val commonSources =
+            arrayOf(
+                kotlin(
+                    "commonMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                    """
+                    package pkg
+                    internal expect annotation class JvmDefaultWithCompatibility()
+                """
+                ),
+                kotlin(
+                    "commonMain/src/pkg2/TestInterface.kt",
+                    """
+                    package pkg2
+
+                    import pkg.JvmDefaultWithCompatibility
+
+                    @JvmDefaultWithCompatibility
+                    interface TestInterface {
+                      fun foo()
+                    }
+                """
+                ),
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                """
+                            package pkg
+                            import kotlin.jvm.JvmDefaultWithCompatibility as Compat
+                            internal actual typealias JvmDefaultWithCompatibility = Compat
+                        """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, *commonSources),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(commonSources),
+                ),
+            api =
+                """
+                package pkg2 {
+                  @kotlin.jvm.JvmDefaultWithCompatibility public interface TestInterface {
+                    method public void foo();
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `JvmDefaultWithCompatibility as typealias actual using chained typealiases`() {
+        val commonSources =
+            arrayOf(
+                kotlin(
+                    "commonMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                    """
+                    package pkg
+                    internal expect annotation class JvmDefaultWithCompatibility()
+                """
+                ),
+                kotlin(
+                    "commonMain/src/pkg2/TestInterface.kt",
+                    """
+                    package pkg2
+
+                    import pkg.JvmDefaultWithCompatibility
+
+                    @JvmDefaultWithCompatibility
+                    interface TestInterface {
+                      fun foo()
+                    }
+                """
+                ),
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/pkg/JvmDefaultWithCompatibility.kt",
+                """
+                            package pkg
+                            private typealias Compat = kotlin.jvm.JvmDefaultWithCompatibility
+                            internal actual typealias JvmDefaultWithCompatibility = Compat
+                        """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, *commonSources),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(commonSources),
+                ),
+            api =
+                """
+                package pkg2 {
+                  @kotlin.jvm.JvmDefaultWithCompatibility public interface TestInterface {
+                    method public void foo();
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `internal value class extension property`() {
+        // b/385148821
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            @JvmInline
+                            value class IntValue(val value: Int)
+                            internal var IntValue.isValid
+                                get() = this.value != 0
+                                set(newValue) = Unit
+                        """
+                    )
+                ),
+            api =
+                """
+            package test.pkg {
+              @kotlin.jvm.JvmInline public final value class IntValue {
+                ctor public IntValue(int value);
+                method public int getValue();
+                property public int value;
+              }
+            }
+            """
+        )
+    }
+
+    @Test
+    fun `default parameter value from common, with android=false for common`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    expect class Foo {
+                        expect fun foo(i: Int = 0): Int
+                    }
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/JvmDefaultWithCompatibility.kt",
+                """
+                    package test.pkg
+                    actual class Foo {
+                        actual fun foo(i: Int) = i
+                    }
+                """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public int foo(optional int i);
+                      }
+                    }
+                """
+        )
+    }
+
+    @Test
+    fun `default parameter value from common, with android=true for common`() {
+        // b/322156458
+        val modifier =
+            if (isK2) {
+                ""
+            } else {
+                "optional "
+            }
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                    package test.pkg
+                    expect class Foo {
+                        expect fun foo(i: Int = 0): Int
+                    }
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/JvmDefaultWithCompatibility.kt",
+                """
+                    package test.pkg
+                    actual class Foo {
+                        actual fun foo(i: Int) = i
+                    }
+                """
+            )
+        check(
+            sourceFiles = arrayOf(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createModuleDescription(
+                        moduleName = "commonMain",
+                        android = true,
+                        sourceFiles = arrayOf(commonSource),
+                        dependsOn = emptyList()
+                    ),
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public int foo(${modifier}int i);
+                      }
+                    }
+                """
+        )
+    }
+
+    @Test
+    fun `Vararg parameter followed by value class type parameter`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        fun foo(vararg varargParam: String, valueParam: IntValue) = Unit
+                        @JvmInline
+                        value class IntValue(val value: Int)
+                    """
+                    )
+                ),
+            api =
+                """
+                package test.pkg {
+                  @kotlin.jvm.JvmInline public final value class IntValue {
+                    ctor public IntValue(int value);
+                    method public int getValue();
+                    property public int value;
+                  }
+                  public final class IntValueKt {
+                    method public static void foo(String[] varargParam, int valueParam);
+                  }
+                }
+            """
+        )
+    }
+
+    @Test
+    fun `Data class with value class type`() {
+        // b/388244267
+        val copySuffix =
+            if (isK2) {
+                ""
+            } else {
+                "-Vxmw0xk"
+            }
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val value: Int)
+                        data class IntValueData(private val intValue: IntValue)
+                    """
+                    )
+                ),
+            api =
+                """
+                package test.pkg {
+                  @kotlin.jvm.JvmInline public final value class IntValue {
+                    ctor public IntValue(int value);
+                    method public int getValue();
+                    property public int value;
+                  }
+                  public final class IntValueData {
+                    ctor public IntValueData(int intValue);
+                    method public test.pkg.IntValueData copy$copySuffix(int intValue);
+                  }
+                }
+            """
+        )
+    }
+
+    @Test
+    fun `Private property with defined getter of value class type`() {
+        // b/388494377
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg.main
+                        class Foo {
+                            private var privateVar: IntValue
+                                get() = IntValue(0)
+                                set(newValue) = Unit
+                        }
+                        @JvmInline
+                        internal value class IntValue(val value: Int)
+                    """
+                    ),
+                ),
+            api =
+                """
+                package test.pkg.main {
+                  public final class Foo {
+                    ctor public Foo();
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `Repeatable annotation with expect actual`() {
+        // b/399105459
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/AnnotationCanRepeat.kt",
+                """
+                    package test.pkg
+                    @Repeatable
+                    expect annotation class AnnotationCanRepeat(val value: Int)
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/AnnotationCanRepeat.android.kt",
+                """
+                    package test.pkg
+                    @JvmRepeatable(AnnotationCanRepeat.Entries::class)
+                    actual annotation class AnnotationCanRepeat
+                    actual constructor(actual val value: Int) {
+                        annotation class Entries(vararg val value: AnnotationCanRepeat)
+                    }
+                """
+            )
+        check(
+            sourceFiles = arrayOf(commonSource, androidSource),
+            projectDescription =
+                createProjectDescription(
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                    createAndroidModuleDescription(arrayOf(androidSource))
+                ),
+            api =
+                """
+                package test.pkg {
+                  @java.lang.annotation.Repeatable(AnnotationCanRepeat.Entries::class) public @interface AnnotationCanRepeat {
+                    method public abstract int value();
+                    property public abstract int value;
+                  }
+                  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public static @interface AnnotationCanRepeat.Entries {
+                    method public abstract test.pkg.AnnotationCanRepeat[] value();
+                    property public abstract test.pkg.AnnotationCanRepeat[] value;
+                  }
+                }
+                """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/VisibleForTestingTest.kt b/metalava/src/test/java/com/android/tools/metalava/VisibleForTestingTest.kt
new file mode 100644
index 000000000..86fd92fd1
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/VisibleForTestingTest.kt
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.VisibleForTesting
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import org.junit.Test
+
+/**
+ * Test that the `VisibleForTesting` annotation works correctly.
+ *
+ * e.g. if it has an `otherwise` attribute that is used as the actual visibility of the annotated
+ * item.
+ */
+class VisibleForTestingTest : DriverTest() {
+    /** Check the behavior of `VisibleForTesting` annotations. */
+    private fun checkVisibleForTesting(
+        format: FileFormat,
+        testFile: TestFile,
+        api: String,
+    ) {
+        check(
+            format = format,
+            sourceFiles =
+                arrayOf(
+                    testFile,
+                    visibleForTestingSource,
+                ),
+            api = api,
+        )
+    }
+
+    @Test
+    fun `Test VisibleForTesting constants - java`() {
+        // Regression test for issue b/118763806.
+        checkVisibleForTesting(
+            testFile =
+                java(
+                    """
+                        package test.pkg;
+                        import androidx.annotation.VisibleForTesting;
+
+                        @SuppressWarnings({"ClassNameDiffersFromFileName", "WeakerAccess"})
+                        public class ProductionCodeJava {
+                            private ProductionCodeJava() { }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+                            public void shouldBeProtected() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+                            protected void shouldBePrivate1() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+                            public void shouldBePrivate2() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+                            public void shouldBePackagePrivate() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+                            public void shouldBeHidden() {
+                            }
+                        }
+                    """
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public class ProductionCodeJava {
+                        method @VisibleForTesting(otherwise=androidx.annotation.VisibleForTesting.PROTECTED) protected void shouldBeProtected();
+                      }
+                    }
+                """,
+            format = FileFormat.V2,
+        )
+    }
+
+    @Test
+    fun `Test VisibleForTesting numbers - java`() {
+        // Test what happens when numbers are used for the otherwise value instead of symbols.
+        checkVisibleForTesting(
+            testFile =
+                java(
+                    """
+                        package test.pkg;
+                        import androidx.annotation.VisibleForTesting;
+
+                        @SuppressWarnings({"ClassNameDiffersFromFileName", "WeakerAccess"})
+                        public class ProductionCodeJava {
+                            private ProductionCodeJava() { }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PROTECTED})
+                            public void shouldBeProtected() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PRIVATE})
+                            protected void shouldBePrivate1() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PRIVATE})
+                            public void shouldBePrivate2() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PACKAGE_PRIVATE})
+                            public void shouldBePackagePrivate() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.NONE})
+                            public void shouldBeHidden() {
+                            }
+                        }
+                    """
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public class ProductionCodeJava {
+                        method @VisibleForTesting(otherwise=${VisibleForTesting.PROTECTED}) protected void shouldBeProtected();
+                      }
+                    }
+                """,
+            format = FileFormat.V2,
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test VisibleForTesting constants - kotlin`() {
+        // Regression test for issue b/118763806.
+        checkVisibleForTesting(
+            testFile =
+                kotlin(
+                    """
+                        package test.pkg
+                        import androidx.annotation.VisibleForTesting
+
+                        open class ProductionCodeKotlin private constructor() {
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)
+                            fun shouldBeProtected() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+                            protected fun shouldBePrivate1() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+                            fun shouldBePrivate2() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+                            fun shouldBePackagePrivate() {
+                            }
+
+                            @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+                            fun shouldBeHidden() {
+                            }
+                        }
+                    """
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public class ProductionCodeKotlin {
+                        method @VisibleForTesting(otherwise=androidx.annotation.VisibleForTesting.PROTECTED) protected final void shouldBeProtected();
+                      }
+                    }
+                """,
+            format = FileFormat.V4,
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test VisibleForTesting numbers - kotlin`() {
+        // Test what happens when numbers are used for the otherwise value instead of symbols.
+        checkVisibleForTesting(
+            testFile =
+                kotlin(
+                    """
+                        package test.pkg
+                        import androidx.annotation.VisibleForTesting
+
+                        open class ProductionCodeKotlin private constructor() {
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PROTECTED})
+                            fun shouldBeProtected() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PRIVATE})
+                            protected fun shouldBePrivate1() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PRIVATE})
+                            fun shouldBePrivate2() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.PACKAGE_PRIVATE})
+                            fun shouldBePackagePrivate() {
+                            }
+
+                            @VisibleForTesting(otherwise = ${VisibleForTesting.NONE})
+                            fun shouldBeHidden() {
+                            }
+                        }
+                    """
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public class ProductionCodeKotlin {
+                        method @VisibleForTesting(otherwise=${VisibleForTesting.PROTECTED}) protected final void shouldBeProtected();
+                      }
+                    }
+                """,
+            format = FileFormat.V4,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
index b21f4bdbd..147b790d4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
@@ -29,7 +29,7 @@ import org.junit.BeforeClass
 
 abstract class ApiGeneratorIntegrationTestBase : DriverTest() {
 
-    val androidPublicJarsPattern = "${platformJars.path}/%/public/android.jar"
+    val androidPublicJarsPattern = "${platformJars.path}/{version:level}/public/android.jar"
 
     protected fun createSdkExtensionInfoFile(): File {
         val file = File.createTempFile("filter", "txt")
@@ -106,15 +106,6 @@ abstract class ApiGeneratorIntegrationTestBase : DriverTest() {
             assert(ABOVE_HIGHEST_API.includes(MAGIC_VERSION_INT))
         }
 
-        internal val oldSdkJars by
-            lazy(LazyThreadSafetyMode.NONE) {
-                File("../../../prebuilts/tools/common/api-versions").apply {
-                    if (!isDirectory) {
-                        Assert.fail("prebuilts for old sdk jars not found: $this")
-                    }
-                }
-            }
-
         internal val platformJars by
             lazy(LazyThreadSafetyMode.NONE) {
                 File("../../../prebuilts/sdk").apply {
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
index 9b4a885bb..f109e91ff 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
@@ -16,9 +16,11 @@
 
 package com.android.tools.metalava.apilevels
 
+import com.android.tools.lint.checks.infrastructure.TestFiles
 import com.android.tools.metalava.ARG_ANDROID_JAR_PATTERN
-import com.android.tools.metalava.ARG_API_VERSION_NAMES
+import com.android.tools.metalava.ARG_API_SURFACE
 import com.android.tools.metalava.ARG_API_VERSION_SIGNATURE_FILES
+import com.android.tools.metalava.ARG_API_VERSION_SIGNATURE_PATTERN
 import com.android.tools.metalava.ARG_CURRENT_CODENAME
 import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_FIRST_VERSION
@@ -26,11 +28,12 @@ import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.ARG_GENERATE_API_VERSION_HISTORY
 import com.android.tools.metalava.ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS
 import com.android.tools.metalava.ARG_SDK_INFO_FILE
-import com.android.tools.metalava.ARG_SDK_JAR_ROOT
 import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.KnownConfigFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.android.tools.metalava.testing.signature
+import com.android.tools.metalava.testing.xml
 import com.google.common.truth.Truth.assertThat
 import com.google.gson.GsonBuilder
 import com.google.gson.JsonElement
@@ -72,35 +75,30 @@ class ApiGeneratorTest : DriverTest() {
         assertEquals(expectedContent.trimIndent(), prettyOutput)
     }
 
-    // TODO(b/378479241): Fix this test to make it more realistic by including definitions of the
-    //  current API or stopping it from including the current API.
-    @Test
-    fun `Generate API for test prebuilts`() {
-        val testPrebuiltsRoot = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
-        if (!testPrebuiltsRoot.isDirectory) {
-            fail("test prebuilts not found: $testPrebuiltsRoot")
-        }
-
+    /** Check `--generate-api-levels` from test files in the metalava directory. */
+    private fun checkGenerateFromTestFiles(
+        sdkExtensionsInfo: String,
+        extraArguments: Array<String>,
+    ) {
         val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
 
         check(
+            configFiles = arrayOf(KnownConfigFiles.configPublicSurface),
             extraArguments =
                 arrayOf(
+                    ARG_API_SURFACE,
+                    "public",
                     ARG_GENERATE_API_LEVELS,
                     apiVersionsXml.path,
-                    ARG_ANDROID_JAR_PATTERN,
-                    "${testPrebuiltsRoot.path}/%/public/android.jar",
-                    ARG_SDK_JAR_ROOT,
-                    "${testPrebuiltsRoot.path}/extensions",
                     ARG_SDK_INFO_FILE,
-                    "${testPrebuiltsRoot.path}/sdk-extensions-info.xml",
+                    sdkExtensionsInfo,
                     ARG_FIRST_VERSION,
                     "30",
                     ARG_CURRENT_VERSION,
                     "32",
                     ARG_CURRENT_CODENAME,
                     "Foo"
-                ),
+                ) + extraArguments,
             // Apply the api-versions.xml file that is being generated by this.
             applyApiLevelsXml = apiVersionsXml.path,
             // Do not prevent java.lang.Object from being included in the API.
@@ -109,16 +107,16 @@ class ApiGeneratorTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package android.test;
-                    public class ClassAddedInApi31AndExt2 {
-                        private ClassAddedInApi31AndExt2() {}
-                        public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
-                        public static final int FIELD_ADDED_IN_EXT_3 = 2;
-                        public void methodAddedInApi31AndExt2() { throw new RuntimeException("Stub!"); }
-                        public void methodAddedInExt3() { throw new RuntimeException("Stub!"); }
-                        public void methodNotFinalized() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
+                            package android.test;
+                            public class ClassAddedInApi31AndExt2 {
+                                private ClassAddedInApi31AndExt2() {}
+                                public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
+                                public static final int FIELD_ADDED_IN_EXT_3 = 2;
+                                public void methodAddedInApi31AndExt2() { throw new RuntimeException("Stub!"); }
+                                public void methodAddedInExt3() { throw new RuntimeException("Stub!"); }
+                                public void methodNotFinalized() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
                     ),
                     java(
                         """
@@ -223,6 +221,49 @@ class ApiGeneratorTest : DriverTest() {
         apiVersionsXml.checkApiVersionsXmlContent(expected)
     }
 
+    // TODO(b/378479241): Fix this test to make it more realistic by including definitions of the
+    //  current API or stopping it from including the current API.
+    @Test
+    fun `Generate API for test prebuilts`() {
+        val testPrebuiltsRoot = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
+        if (!testPrebuiltsRoot.isDirectory) {
+            fail("test prebuilts not found: $testPrebuiltsRoot")
+        }
+
+        checkGenerateFromTestFiles(
+            sdkExtensionsInfo = "${testPrebuiltsRoot.path}/sdk-extensions-info.xml",
+            extraArguments =
+                arrayOf(
+                    ARG_ANDROID_JAR_PATTERN,
+                    "${testPrebuiltsRoot.path}/{version:level}/public/android.jar",
+                    ARG_ANDROID_JAR_PATTERN,
+                    "${testPrebuiltsRoot.path}/extensions/{version:extension}/*/{module}.jar",
+                ),
+        )
+    }
+
+    @Test
+    fun `Generate API from signature files using --generate-api-levels`() {
+        val testdataDir = File(System.getenv("METALAVA_TESTDATA_DIR"))
+        if (!testdataDir.isDirectory) {
+            fail("testdata directory not found: $testdataDir")
+        }
+
+        val prebuiltsSdkDir = testdataDir.resolve("prebuilts/sdk")
+
+        checkGenerateFromTestFiles(
+            sdkExtensionsInfo =
+                testdataDir.resolve("prebuilts-sdk-test/sdk-extensions-info.xml").path,
+            extraArguments =
+                arrayOf(
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "$prebuiltsSdkDir/{version:level}/{surface}/api.txt",
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "$prebuiltsSdkDir/extensions/{version:extension}/{surface}/{module}.txt",
+                ),
+        )
+    }
+
     @Test
     fun `Generate API while removing missing class references`() {
         val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
@@ -255,7 +296,7 @@ class ApiGeneratorTest : DriverTest() {
         val expected =
             """
             <?xml version="1.0" encoding="utf-8"?>
-            <api version="3" min="30">
+            <api version="3" min="33">
                 <class name="android/test/ClassThatImplementsMethodFromApex" since="33">
                     <method name="&lt;init>()V"/>
                 </class>
@@ -265,6 +306,41 @@ class ApiGeneratorTest : DriverTest() {
         apiVersionsXml.checkApiVersionsXmlContent(expected)
     }
 
+    @Test
+    fun `Generate API for system surface from jar`() {
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+
+        check(
+            configFiles = arrayOf(KnownConfigFiles.configPublicAndSystemSurfaces),
+            extraArguments =
+                arrayOf(
+                    ARG_API_SURFACE,
+                    "system",
+                    ARG_GENERATE_API_LEVELS,
+                    apiVersionsXml.path,
+                    ARG_FIRST_VERSION,
+                    "30",
+                    ARG_CURRENT_VERSION,
+                    "32",
+                    ARG_CURRENT_CODENAME,
+                    "Foo"
+                ),
+            sourceFiles =
+                arrayOf(
+                    TestFiles.jar("test.jar"),
+                ),
+        )
+
+        val expected =
+            """
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="3" min="33">
+                </api>
+            """
+
+        apiVersionsXml.checkApiVersionsXmlContent(expected)
+    }
+
     @Test
     fun `Generate API finds missing class references`() {
         val testPrebuiltsRoot = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
@@ -394,8 +470,10 @@ class ApiGeneratorTest : DriverTest() {
                 output.path,
                 ARG_API_VERSION_SIGNATURE_FILES,
                 pastVersions.joinToString(":") { it.absolutePath },
-                ARG_API_VERSION_NAMES,
-                listOf("1.1.0", "1.2.0", "1.3.0", "1.4.0").joinToString(" "),
+                ARG_API_VERSION_SIGNATURE_PATTERN,
+                "${temporaryFolder.root}/{version:major.minor.patch}",
+                ARG_CURRENT_VERSION,
+                "1.4.0",
             )
 
         check(
@@ -441,13 +519,13 @@ class ApiGeneratorTest : DriverTest() {
                       }
                     ],
                     "fields": [
-                      {
-                        "field": "fieldV2",
-                        "addedIn": "1.2.0"
-                      },
                       {
                         "field": "fieldV1",
                         "addedIn": "1.1.0"
+                      },
+                      {
+                        "field": "fieldV2",
+                        "addedIn": "1.2.0"
                       }
                     ]
                   }
@@ -465,7 +543,7 @@ class ApiGeneratorTest : DriverTest() {
         apiVersionsXml.checkApiVersionsXmlContent(
             """
                 <?xml version="1.0" encoding="utf-8"?>
-                <api version="3">
+                <api version="4" min="1.1.0">
                     <class name="test.pkg.Foo" since="1.1.0">
                         <extends name="java.lang.Object"/>
                         <method name="methodV1&lt;T extends java.lang.String>(T)" deprecated="1.3.0"/>
@@ -522,15 +600,17 @@ class ApiGeneratorTest : DriverTest() {
                     apiVersionsXml.path,
                     ARG_API_VERSION_SIGNATURE_FILES,
                     pastVersions.joinToString(":") { it.absolutePath },
-                    ARG_API_VERSION_NAMES,
-                    listOf("1.1.0", "1.2.0").joinToString(" "),
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "${temporaryFolder.root}/{version:major.minor.patch}",
+                    ARG_CURRENT_VERSION,
+                    "1.2.0",
                 ),
         )
 
         apiVersionsXml.checkApiVersionsXmlContent(
             """
                 <?xml version="1.0" encoding="utf-8"?>
-                <api version="3">
+                <api version="4" min="1.1.0">
                     <class name="test.pkg.Bar" since="1.1.0" removed="1.2.0">
                         <extends name="java.lang.Object"/>
                         <field name="barField"/>
@@ -546,37 +626,42 @@ class ApiGeneratorTest : DriverTest() {
     }
 
     @Test
-    fun `Correct error with different number of API signature files and API version names`() {
+    fun `API levels can be generated from just the current codebase`() {
         val output = temporaryFolder.newFile("api-info.json")
 
-        val filePaths =
-            listOf("1.1.0", "1.2.0", "1.3.0").map { name ->
-                val file = createTextFile("$name.txt", "")
-                file.path
-            }
+        val api =
+            """
+                // Signature format: 4.0
+                package test.pkg {
+                  public class Foo {
+                    method public void foo(String?);
+                  }
+                }
+            """
 
         check(
+            signatureSource = api,
             extraArguments =
                 arrayOf(
                     ARG_GENERATE_API_VERSION_HISTORY,
                     output.path,
-                    ARG_API_VERSION_SIGNATURE_FILES,
-                    filePaths.joinToString(":"),
-                    ARG_API_VERSION_NAMES,
-                    listOf("1.1.0", "1.2.0").joinToString(" ")
-                ),
-            expectedFail =
-                "Aborting: --api-version-names must have one more version than --api-version-signature-files to include the current version name"
+                    ARG_CURRENT_VERSION,
+                    "0.0.0-alpha01"
+                )
         )
+
+        val expectedJson =
+            "[{\"class\":\"test.pkg.Foo\",\"addedIn\":\"0.0.0-alpha01\",\"methods\":[{\"method\":\"foo(java.lang.String)\",\"addedIn\":\"0.0.0-alpha01\"}],\"fields\":[]}]"
+        assertEquals(expectedJson, output.readText())
     }
 
     @Test
-    fun `API levels can be generated from just the current codebase`() {
+    fun `API levels can be generated from just the current codebase using --current-version`() {
         val output = temporaryFolder.newFile("api-info.json")
 
         val api =
             """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public class Foo {
                     method public void foo(String?);
@@ -590,7 +675,7 @@ class ApiGeneratorTest : DriverTest() {
                 arrayOf(
                     ARG_GENERATE_API_VERSION_HISTORY,
                     output.path,
-                    ARG_API_VERSION_NAMES,
+                    ARG_CURRENT_VERSION,
                     "0.0.0-alpha01"
                 )
         )
@@ -653,8 +738,10 @@ class ApiGeneratorTest : DriverTest() {
                     apiVersionsJson.path,
                     ARG_API_VERSION_SIGNATURE_FILES,
                     pastVersions.joinToString(":") { it.absolutePath },
-                    ARG_API_VERSION_NAMES,
-                    listOf("1.1.0", "1.2.0").joinToString(" ")
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "${temporaryFolder.root}/{version:major.minor.patch}",
+                    ARG_CURRENT_VERSION,
+                    "1.2.0",
                 )
         )
 
@@ -735,8 +822,10 @@ class ApiGeneratorTest : DriverTest() {
                     apiVersionsJson.path,
                     ARG_API_VERSION_SIGNATURE_FILES,
                     pastVersions.joinToString(":") { it.absolutePath },
-                    ARG_API_VERSION_NAMES,
-                    listOf("1.1.0", "1.2.0").joinToString(" ")
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "${temporaryFolder.root}/{version:major.minor.patch}.txt",
+                    ARG_CURRENT_VERSION,
+                    "1.2.0",
                 )
         )
 
@@ -748,11 +837,11 @@ class ApiGeneratorTest : DriverTest() {
                     "addedIn": "1.1.0",
                     "methods": [
                       {
-                        "method": "experimentalFunction()",
+                        "method": "Foo()",
                         "addedIn": "1.1.0"
                       },
                       {
-                        "method": "Foo()",
+                        "method": "experimentalFunction()",
                         "addedIn": "1.1.0"
                       },
                       {
@@ -772,5 +861,77 @@ class ApiGeneratorTest : DriverTest() {
     }
 
     private fun createTextFile(name: String, contents: String) =
-        signature(name, contents).createFile(temporaryFolder.newFolder())
+        signature(name, contents).createFile(temporaryFolder.root)
+
+    @Test
+    fun `Support major minor versions in generated api-versions xml file`() {
+        val pastVersions =
+            listOf(
+                createTextFile(
+                    "1.2",
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Bar {
+                          }
+                        }
+                    """
+                ),
+                createTextFile(
+                    "1.3",
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Bar {
+                          }
+                          public class Foo extends test.pkg.Bar {
+                          }
+                        }
+                    """
+                ),
+            )
+        val currentVersion =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Bar {
+                  }
+                  public class Foo extends test.pkg.Bar {
+                    field public int field;
+                  }
+                }
+            """
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+
+        check(
+            signatureSource = currentVersion,
+            extraArguments =
+                arrayOf(
+                    ARG_GENERATE_API_VERSION_HISTORY,
+                    apiVersionsXml.path,
+                    ARG_API_VERSION_SIGNATURE_FILES,
+                    pastVersions.joinToString(":") { it.absolutePath },
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "${temporaryFolder.root}/{version:major.minor?}",
+                    ARG_CURRENT_VERSION,
+                    "2.0",
+                ),
+        )
+
+        apiVersionsXml.checkApiVersionsXmlContent(
+            """
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="4" min="1.2">
+                    <class name="test.pkg.Bar" since="1.2">
+                        <extends name="java.lang.Object"/>
+                    </class>
+                    <class name="test.pkg.Foo" since="1.3">
+                        <extends name="test.pkg.Bar"/>
+                        <field name="field" since="2.0"/>
+                    </class>
+                </api>
+            """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
index 8139504aa..540146f69 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
@@ -24,6 +24,10 @@ import org.junit.Assert
 
 class ApiToExtensionsMapTest {
 
+    /** Get the [ApiToExtensionsMap] instance for [jar] from [xml]. */
+    private fun fromXml(jar: String, xml: String) =
+        SdkExtensionInfo.fromXml(xml).extensionsMapForJarOrEmpty(jar)
+
     /** Get an SDK version for [level]. */
     private fun sdkVersion(level: Int) = ApiVersion.fromLevel(level)
 
@@ -43,7 +47,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("no-module", xml)
+        val map = fromXml("no-module", xml)
 
         assertTrue(map.getExtensions("com.foo.Bar").isEmpty())
     }
@@ -60,7 +64,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("mod", xml)
+        val map = fromXml("mod", xml)
 
         assertEquals(map.getExtensions("com.foo.Bar"), listOf("A"))
         assertEquals(map.getExtensions("com.foo.SomeOtherBar"), listOf("A"))
@@ -79,7 +83,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("mod", xml)
+        val map = fromXml("mod", xml)
 
         assertEquals(map.getExtensions("com.foo.Bar"), listOf("A"))
         assertEquals(map.getExtensions("com.foo.Bar#FIELD"), listOf("A"))
@@ -113,7 +117,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("mod", xml)
+        val map = fromXml("mod", xml)
 
         assertEquals(listOf("A", "B", "FOO", "BAR"), map.getExtensions("com.foo.Bar"))
     }
@@ -136,7 +140,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("mod", xml)
+        val map = fromXml("mod", xml)
 
         assertEquals(map.getExtensions("anything"), listOf("A"))
 
@@ -164,9 +168,9 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val allowListA = ApiToExtensionsMap.fromXml("foo", xml)
-        val allowListB = ApiToExtensionsMap.fromXml("bar", xml)
-        val allowListC = ApiToExtensionsMap.fromXml("baz", xml)
+        val allowListA = fromXml("foo", xml)
+        val allowListB = fromXml("bar", xml)
+        val allowListC = fromXml("baz", xml)
 
         assertEquals(allowListA.getExtensions("anything"), listOf("A"))
         assertEquals(allowListB.getExtensions("anything"), listOf("B"))
@@ -186,7 +190,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val map = ApiToExtensionsMap.fromXml("foo", xml)
+        val map = fromXml("foo", xml)
 
         assertEquals(map.getExtensions("com.foo.Bar"), listOf("A", "B"))
     }
@@ -194,7 +198,7 @@ class ApiToExtensionsMapTest {
     @Test
     fun `bad input`() {
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -207,7 +211,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -224,7 +228,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -239,7 +243,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -254,7 +258,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -270,7 +274,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -285,7 +289,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -301,7 +305,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -317,7 +321,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -333,7 +337,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -349,7 +353,7 @@ class ApiToExtensionsMapTest {
         }
 
         assertFailsWith<IllegalArgumentException> {
-            ApiToExtensionsMap.fromXml(
+            fromXml(
                 "mod",
                 """
                     <?xml version="1.0" encoding="utf-8"?>
@@ -380,7 +384,7 @@ class ApiToExtensionsMapTest {
             </sdk-extensions-info>
         """
                 .trimIndent()
-        val filter = ApiToExtensionsMap.fromXml("mod", xml)
+        val filter = fromXml("mod", xml)
 
         val sdk21 = sdkVersion(21)
         val sdk30 = sdkVersion(30)
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt
new file mode 100644
index 000000000..a4f2de0a2
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.snapshot.EmittableDelegatingVisitor
+import com.android.tools.metalava.model.source.EnvironmentManager
+import com.android.tools.metalava.model.source.SourceSet
+import com.android.tools.metalava.reporter.ThrowingReporter
+import com.android.tools.metalava.testing.getAndroidJar
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.signature
+import java.io.PrintWriter
+import java.io.StringWriter
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TestRule
+import org.junit.runners.model.Statement
+
+/**
+ * Factory for creating an [VersionedApi] instance for a specific [ApiVersion].
+ *
+ * Separates the selection of the [ApiVersion] from the creation of [VersionedApi]. A single factory
+ * can be used to create multiple [VersionedApi]s with different [ApiVersion]s.
+ */
+typealias VersionedApiFactory = (ApiVersion) -> VersionedApi
+
+/**
+ * Verifies the consistency of updating APIs loaded from signature files, sources and jar files.
+ *
+ * This uses classes from `prebuilts/sdk/30/public/android.jar` to avoid having to create custom
+ * classes and compiling them into a jar file. Longer term, reading historical APIs from jars will
+ * be removed so this is a temporary measure.
+ */
+class ApiUpdateConsistencyTest : DriverTest() {
+
+    /** A rule that will run tests within the lifespan of an [EnvironmentManager]. */
+    @get:Rule
+    val sourceModelProviderRule = TestRule { base, _ ->
+        object : Statement() {
+            override fun evaluate() {
+                val sourceModelProvider = codebaseCreatorConfig.creator
+                sourceModelProvider.createEnvironmentManager(forTesting = true).use {
+                    environmentManager = it
+                    base.evaluate()
+                }
+            }
+        }
+    }
+
+    /**
+     * The [EnvironmentManager] used by [versionedSourceApi].
+     *
+     * Initialized and closed by [sourceModelProviderRule].
+     */
+    private lateinit var environmentManager: EnvironmentManager
+
+    /** Return a [VersionedApiFactory] that will create a [VersionedSignatureApi] for [contents]. */
+    private fun versionedSignatureApi(contents: String): VersionedApiFactory {
+        return { version ->
+            val testFile = signature("$version.txt", contents)
+            val file = testFile.createFile(temporaryFolder.root)
+            VersionedSignatureApi(
+                DefaultSignatureFileLoader(Codebase.Config.NOOP),
+                listOf(file),
+                ApiHistoryUpdater.forApiVersion(version)
+            )
+        }
+    }
+
+    /**
+     * Return a [VersionedApiFactory] that will create a [VersionedSourceApi] for a [Codebase]
+     * created from [sourceFiles].
+     */
+    private fun versionedSourceApi(vararg sourceFiles: TestFile): VersionedApiFactory {
+        return { version ->
+            val parser = environmentManager.createSourceParser(Codebase.Config.NOOP)
+            val sourceSet =
+                SourceSet.createFromSourcePath(
+                    ThrowingReporter.INSTANCE,
+                    sourceFiles.map { it.createFile(temporaryFolder.newFolder()) },
+                )
+            val classPath =
+                listOf(
+                    getAndroidJar(30),
+                )
+            val codebase =
+                parser.parseSources(
+                    sourceSet,
+                    "version $version",
+                    classPath,
+                    apiPackages = null,
+                    projectDescription = null,
+                )
+
+            val codebaseFragment = CodebaseFragment.create(codebase, ::EmittableDelegatingVisitor)
+            VersionedSourceApi({ codebaseFragment }, version)
+        }
+    }
+
+    /**
+     * Return a [VersionedApiFactory] that will create a [VersionedJarApi] that will update the
+     * [Api] from classes in [classFiles] within `prebuilts/sdk/30/public/android.jar`.
+     */
+    private fun versionedJarApi(classFiles: Set<String>): VersionedApiFactory = { version ->
+        VersionedJarApi(
+            // `prebuilts/sdk/30/public/android.jar`
+            getAndroidJar(30),
+            ApiHistoryUpdater.forApiVersion(version),
+            filter = { it in classFiles },
+        )
+    }
+
+    /**
+     * Create an [Api] from a list of [VersionedApi]s, print it using [ApiXmlPrinter] and then
+     * verify that the result matches [expectedXmlContents].
+     */
+    private fun checkVersionedApis(
+        versionedApis: List<VersionedApi>,
+        expectedXmlContents: String,
+        message: String,
+    ) {
+        val api = createApiFromVersionedApis(useInternalNames = true, versionedApis)
+        val writer = StringWriter()
+        val printer = ApiXmlPrinter(null, versionedApis)
+        PrintWriter(writer).use { printWriter -> printer.print(api, printWriter) }
+        assertEquals(
+            expectedXmlContents.trimIndent(),
+            writer.toString().trimIndent().replace("\t", "    "),
+            message = message
+        )
+    }
+
+    /**
+     * Use a list of [VersionedApiFactory]s to produce lists of [VersionedApi]s with different
+     * [ApiVersion] and check that they behave correctly when used to update [Api].
+     *
+     * Each [VersionedApi] should be identical in terms of the effect on the [Api] and so the order
+     * should not matter. However, there are some inconsistencies between the [VersionedApi]s. There
+     * is some logic in [addApisFromCodebase] to compensate for those inconsistencies, but it
+     * depends on the contents of the [ApiClass.superClasses] list and so is affected by order.
+     *
+     * So, this test will check the effect of the [VersionedApi]s created by the
+     * [versionedApiFactories] on [Api] in three different ways:
+     * 1. It will create [VersionedApi]s in order with the version equal to 1 more than the index of
+     *    the [VersionedApiFactory] in [versionedApiFactories]. They will then be applied in version
+     *    order, e.g. from 1 to `N`. The resulting XML will be compared with [expectedForward].
+     * 2. The list of [VersionedApi]s created in step #1 will be reversed. So, version `N` will be
+     *    applied before version `N-1`. The resulting XML will be compared with
+     *    [expectedBackwardSameVersions].
+     * 3. The list of [versionedApiFactories] will be reversed and then used as in step #1. The
+     *    resulting XML will be compared with [expectedBackwardIncludeVersions].
+     *
+     * Irrespective of which way the [Api] is constructed it should produce XML output that matches
+     * [expected].
+     */
+    private fun checkVersionedApiFactories(
+        vararg versionedApiFactories: VersionedApiFactory,
+        expected: String,
+    ) {
+        val versionedApis =
+            versionedApiFactories.mapIndexed { index, factory ->
+                factory(ApiVersion.fromLevel(index + 1))
+            }
+
+        checkVersionedApis(versionedApis, expected, "forward")
+        checkVersionedApis(versionedApis.reversed(), expected, "reversed versions")
+
+        checkVersionedApis(
+            versionedApiFactories.reversed().mapIndexed { index, factory ->
+                factory(ApiVersion.fromLevel(index + 1))
+            },
+            expected,
+            "reversed factories"
+        )
+    }
+
+    @Test
+    fun `Test normal class`() {
+        checkVersionedApiFactories(
+            versionedJarApi(
+                classFiles = setOf("java/lang/ArithmeticException.class"),
+            ),
+            versionedSignatureApi(
+                """
+                        // Signature format: 2.0
+                        package java.lang {
+                          public class ArithmeticException extends RuntimeException {
+                            ctor public ArithmeticException();
+                            ctor public ArithmeticException(String);
+                          }
+                        }
+                    """,
+            ),
+            versionedSourceApi(
+                java(
+                    """
+                        package java.lang;
+                        public class ArithmeticException extends RuntimeException {
+                            public ArithmeticException() {}
+                            public ArithmeticException(String message) {super(message);}
+                        }
+                    """
+                ),
+            ),
+            expected =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="3">
+                        <class name="java/lang/ArithmeticException" since="1">
+                            <extends name="java/lang/RuntimeException"/>
+                            <method name="&lt;init>()V"/>
+                            <method name="&lt;init>(Ljava/lang/String;)V"/>
+                        </class>
+                    </api>
+                """,
+        )
+    }
+
+    @Test
+    fun `Test simple interface super classes`() {
+        checkVersionedApiFactories(
+            versionedJarApi(
+                classFiles = setOf("java/lang/AutoCloseable.class"),
+            ),
+            versionedSignatureApi(
+                """
+                        // Signature format: 2.0
+                        package java.lang {
+                          public interface AutoCloseable {
+                            method public void close() throws Exception;
+                          }
+                        }
+                    """,
+            ),
+            versionedSourceApi(
+                java(
+                    """
+                        package java.lang;
+                        public interface AutoCloseable {
+                            void close() throws Exception;
+                        }
+                    """
+                ),
+            ),
+            expected =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="3">
+                        <class name="java/lang/AutoCloseable" since="1">
+                            <extends name="java/lang/Object"/>
+                            <method name="close()V"/>
+                        </class>
+                    </api>
+                """,
+        )
+    }
+
+    @Test
+    fun `Test annotations super classes`() {
+        checkVersionedApiFactories(
+            versionedJarApi(classFiles = setOf("java/lang/FunctionalInterface.class")),
+            versionedSignatureApi(
+                """
+                        // Signature format: 2.0
+                        package java.lang {
+                          public @interface FunctionalInterface {
+                          }
+                        }
+                    """
+            ),
+            versionedSourceApi(
+                java(
+                    """
+                        package java.lang;
+                        public @interface FunctionalInterface {
+                        }
+                    """
+                )
+            ),
+            expected =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="3">
+                        <class name="java/lang/FunctionalInterface" since="1">
+                            <extends name="java/lang/Object"/>
+                            <implements name="java/lang/annotation/Annotation"/>
+                        </class>
+                    </api>
+                """,
+        )
+    }
+
+    @Test
+    fun `Test enums`() {
+        checkVersionedApiFactories(
+            versionedJarApi(classFiles = setOf("java/lang/annotation/RetentionPolicy.class")),
+            versionedSignatureApi(
+                """
+                        // Signature format: 2.0
+                        package java.lang.annotation {
+                          public enum RetentionPolicy {
+                            enum_constant public java.lang.annotation.RetentionPolicy CLASS;
+                            enum_constant public java.lang.annotation.RetentionPolicy SOURCE;
+                            enum_constant public java.lang.annotation.RetentionPolicy RUNTIME;
+                          }
+                        }
+                    """
+            ),
+            versionedSourceApi(
+                java(
+                    """
+                        package java.lang.annotation;
+                        public enum RetentionPolicy {
+                            SOURCE,
+                            CLASS,
+                            RUNTIME
+                        }
+                    """
+                )
+            ),
+            expected =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="3">
+                        <class name="java/lang/annotation/RetentionPolicy" since="1">
+                            <extends name="java/lang/Enum"/>
+                            <method name="valueOf(Ljava/lang/String;)Ljava/lang/annotation/RetentionPolicy;"/>
+                            <method name="values()[Ljava/lang/annotation/RetentionPolicy;"/>
+                            <field name="CLASS"/>
+                            <field name="RUNTIME"/>
+                            <field name="SOURCE"/>
+                        </class>
+                    </api>
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
index 9863b2fbd..6c09099a8 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
@@ -36,8 +36,6 @@ class CorrectApiLevelForNonReleaseTest : ApiGeneratorIntegrationTestBase() {
                     ARG_GENERATE_API_LEVELS,
                     outputPath,
                     ARG_ANDROID_JAR_PATTERN,
-                    "${oldSdkJars.path}/android-%/android.jar",
-                    ARG_ANDROID_JAR_PATTERN,
                     androidPublicJarsPattern,
                     ARG_CURRENT_CODENAME,
                     "ZZZ", // not just Z, but very ZZZ
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
index c37495bd4..48fb1b002 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
@@ -36,8 +36,6 @@ class CorrectApiLevelForReleaseTest : ApiGeneratorIntegrationTestBase() {
                     ARG_GENERATE_API_LEVELS,
                     outputPath,
                     ARG_ANDROID_JAR_PATTERN,
-                    "${oldSdkJars.path}/android-%/android.jar",
-                    ARG_ANDROID_JAR_PATTERN,
                     androidPublicJarsPattern,
                     ARG_CURRENT_CODENAME,
                     "REL",
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt
deleted file mode 100644
index 490a09c6a..000000000
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.apilevels
-
-import com.android.tools.metalava.testing.TemporaryFolderOwner
-import java.io.File
-import kotlin.test.Test
-import org.junit.Assert.assertEquals
-import org.junit.Rule
-import org.junit.rules.TemporaryFolder
-
-class ExtensionSdkJarReaderTest : TemporaryFolderOwner {
-
-    /** Provides access to temporary files. */
-    @get:Rule override val temporaryFolder = TemporaryFolder()
-
-    private fun createDirectoryHierarchy(vararg paths: String): File {
-        val root = temporaryFolder.newFolder("metalava")
-        for (path in paths) {
-            val file = root.resolve(path)
-            file.parentFile.mkdirs()
-            file.createNewFile()
-        }
-        return root
-    }
-
-    @Test
-    fun `Verify findExtensionSdkJarFiles`() {
-        val root =
-            createDirectoryHierarchy(
-                "1/public/foo.jar",
-                "1/public/bar.jar",
-                "2/public/foo.jar",
-                "2/public/bar.jar",
-                "2/public/baz.jar",
-            )
-
-        val expected =
-            mapOf(
-                "foo" to
-                    listOf(
-                        VersionAndPath(1, File(root, "1/public/foo.jar")),
-                        VersionAndPath(2, File(root, "2/public/foo.jar"))
-                    ),
-                "bar" to
-                    listOf(
-                        VersionAndPath(1, File(root, "1/public/bar.jar")),
-                        VersionAndPath(2, File(root, "2/public/bar.jar"))
-                    ),
-                "baz" to listOf(VersionAndPath(2, File(root, "2/public/baz.jar"))),
-            )
-        val actual = ExtensionSdkJarReader.findExtensionSdkJarFiles(root)
-        assertEquals(expected, actual)
-    }
-}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
index 613eab221..efc934c33 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
@@ -21,7 +21,6 @@ import com.android.tools.metalava.ARG_CURRENT_CODENAME
 import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.ARG_SDK_INFO_FILE
-import com.android.tools.metalava.ARG_SDK_JAR_ROOT
 import com.android.tools.metalava.doc.getApiLookup
 import com.android.tools.metalava.testing.java
 import org.junit.Assert.assertEquals
@@ -42,11 +41,9 @@ class ExtractPublicApiLevelsTest : ApiGeneratorIntegrationTestBase() {
                     ARG_GENERATE_API_LEVELS,
                     outputPath,
                     ARG_ANDROID_JAR_PATTERN,
-                    "${oldSdkJars.path}/android-%/android.jar",
-                    ARG_ANDROID_JAR_PATTERN,
                     androidPublicJarsPattern,
-                    ARG_SDK_JAR_ROOT,
-                    extensionSdkJars.path,
+                    ARG_ANDROID_JAR_PATTERN,
+                    "${extensionSdkJars.path}/{version:extension}/*/{module}.jar",
                     ARG_SDK_INFO_FILE,
                     createSdkExtensionInfoFile().path,
                     ARG_CURRENT_CODENAME,
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
index 22aa6cf55..f2c007cc9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
@@ -21,7 +21,6 @@ import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_FIRST_VERSION
 import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.ARG_SDK_INFO_FILE
-import com.android.tools.metalava.ARG_SDK_JAR_ROOT
 import com.android.tools.metalava.doc.getApiLookup
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
@@ -30,7 +29,7 @@ import org.junit.Test
 class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
     @Test
     fun `Extract System API`() {
-        val androidJarPattern = "${platformJars.path}/%/system/android.jar"
+        val androidJarPattern = "${platformJars.path}/{version:level}/system/android.jar"
 
         check(
             extraArguments =
@@ -39,8 +38,9 @@ class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
                     outputPath,
                     ARG_ANDROID_JAR_PATTERN,
                     androidJarPattern,
-                    ARG_SDK_JAR_ROOT,
-                    extensionSdkJars.path,
+                    ARG_ANDROID_JAR_PATTERN,
+                    // Make sure to only use system extension jars.
+                    "${extensionSdkJars.path}/{version:extension}/system/{module}.jar",
                     ARG_SDK_INFO_FILE,
                     createSdkExtensionInfoFile().path,
                     ARG_FIRST_VERSION,
@@ -86,7 +86,7 @@ class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
         // method with different sdks attribute than containing class
         assertTrue(
             xml.contains(
-                "<method name=\"setBrowserRoleHolder(Ljava/lang/String;I)Z\" since=\"34\" sdks=\"30:1\"/>"
+                "<method name=\"isBypassingRoleQualification()Z\" since=\"31\" sdks=\"30:1,0:31\"/>"
             )
         )
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt
new file mode 100644
index 000000000..2537d682e
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt
@@ -0,0 +1,610 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.testing.DirectoryBuilder
+import com.android.tools.metalava.testing.TemporaryFolderOwner
+import com.android.tools.metalava.testing.getAndroidDir
+import java.io.File
+import kotlin.test.assertEquals
+import org.junit.Assert.assertThrows
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class PatternNodeTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    private fun PatternNode.assertStructure(expected: String) {
+        assertEquals(expected.trimIndent(), dump().trimIndent())
+    }
+
+    /** Assert that the [MatchedPatternFile]s */
+    private fun List<MatchedPatternFile>.assertMatchedPatternFiles(expected: String) {
+        val actual = joinToString("\n")
+        val cleaned =
+            replaceFileWithSymbol(
+                actual,
+                mapOf(
+                    getAndroidDir() to "ANDROID_ROOT",
+                )
+            )
+        assertEquals(expected.trimIndent(), cleaned)
+    }
+
+    @Test
+    fun `Invalid no API placeholder`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/3/public/android.jar",
+            )
+
+        val exception =
+            assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
+        assertEquals(
+            "Pattern 'prebuilts/sdk/3/public/android.jar' does not contain placeholder for version",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Invalid multiple version placeholders`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/public/android-{version:major.minor?}.jar",
+            )
+
+        val exception =
+            assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
+        assertEquals(
+            "Pattern 'prebuilts/sdk/{version:level}/public/android-{version:major.minor?}.jar' contains multiple placeholders for version; found {version:level}, {version:major.minor?}",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Invalid multiple module placeholders`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/{module}/{module}.jar",
+            )
+
+        val exception =
+            assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
+        assertEquals(
+            "Pattern 'prebuilts/sdk/{version:level}/{module}/{module}.jar' contains multiple placeholders for module; found {module}, {module}",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Unknown placeholder`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{unknown}/public/android-{version:level}.jar",
+            )
+
+        val exception =
+            assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
+        assertEquals(
+            "Pattern 'prebuilts/sdk/{unknown}/public/android-{version:level}.jar' contains an unknown placeholder '{unknown}', expected one of '{version:level}', '{version:major.minor?}', '{version:major.minor.patch}', '{version:extension}', '{module}', '{surface}'",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Parse common Android public patterns`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+
+        val patternNode = PatternNode.parsePatterns(patterns)
+        patternNode.assertStructure(
+            """
+                <root>
+                  prebuilts/
+                    sdk/
+                      (\d+)/
+                        public/
+                          android.jar
+            """
+        )
+    }
+
+    @Test
+    fun `Parse common Android system patterns`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/system/android.jar",
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+
+        val patternNode = PatternNode.parsePatterns(patterns)
+        patternNode.assertStructure(
+            """
+                <root>
+                  prebuilts/
+                    sdk/
+                      (\d+)/
+                        system/
+                          android.jar
+                        public/
+                          android.jar
+            """
+        )
+    }
+
+    @Test
+    fun `Parse common Android module-lib patterns`() {
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/module-lib/android.jar",
+                "prebuilts/sdk/{version:level}/system/android.jar",
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+
+        val patternNode = PatternNode.parsePatterns(patterns)
+        patternNode.assertStructure(
+            """
+                <root>
+                  prebuilts/
+                    sdk/
+                      (\d+)/
+                        module-lib/
+                          android.jar
+                        system/
+                          android.jar
+                        public/
+                          android.jar
+            """
+        )
+    }
+
+    @Test
+    fun `Parse pattern with absolute path`() {
+        val patterns =
+            listOf(
+                "/absolute/path/{version:level}.txt",
+            )
+
+        val patternNode = PatternNode.parsePatterns(patterns)
+        patternNode.assertStructure(
+            """
+                <root>
+                  /
+                    absolute/
+                      path/
+                        (\d+)\Q.txt\E
+            """
+        )
+    }
+
+    @Test
+    fun `Scan public prebuilts`() {
+        val androidDir = getAndroidDir()
+
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val range = ApiVersion.fromLevel(1).rangeTo(ApiVersion.fromLevel(5))
+        val files = node.scan(PatternNode.ScanConfig(androidDir, range::contains))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/1/public/android.jar, version=1)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/2/public/android.jar, version=2)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/3/public/android.jar, version=3)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/4/public/android.jar, version=4)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/5/public/android.jar, version=5)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan system prebuilts`() {
+        val androidDir = getAndroidDir()
+
+        val patterns =
+            listOf(
+                // Check system first and then fall back to public. As there are both public and
+                // system for versions 21 onwards these patterns will match both the public and
+                // system versions but only the system one will be used as it would be found first.
+                "prebuilts/sdk/{version:level}/system/android.jar",
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val range = ApiVersion.fromLevel(20).rangeTo(ApiVersion.fromLevel(22))
+        val files = node.scan(PatternNode.ScanConfig(androidDir, range::contains))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/20/public/android.jar, version=20)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/21/system/android.jar, version=21)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/22/system/android.jar, version=22)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan public prebuilts with unnecessary system pattern`() {
+        val androidDir = getAndroidDir()
+
+        val patterns =
+            listOf(
+                // Check the public first, this should never fall back to system as it will always
+                // find a public jar.
+                "prebuilts/sdk/{version:level}/public/android.jar",
+                "prebuilts/sdk/{version:level}/system/android.jar",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val range = ApiVersion.fromLevel(20).rangeTo(ApiVersion.fromLevel(22))
+        val files = node.scan(PatternNode.ScanConfig(androidDir, range::contains))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/20/public/android.jar, version=20)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/21/public/android.jar, version=21)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/22/public/android.jar, version=22)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan version specific prebuilt directories`() {
+        val androidDir = getAndroidDir()
+
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val range = ApiVersion.fromLevel(21).rangeTo(ApiVersion.fromLevel(23))
+        val files = node.scan(PatternNode.ScanConfig(androidDir, range::contains))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/21, version=21)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/22, version=22)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/23, version=23)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan explicit list of version specific jars`() {
+        val androidDir = getAndroidDir()
+
+        val patterns =
+            listOf(
+                "prebuilts/sdk/{version:level}/public/android.jar",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+
+        val limitedFileProvider =
+            PatternNode.LimitedFileSystemProvider(
+                listOf(
+                        "prebuilts/sdk/19/public/android.jar",
+                        "prebuilts/sdk/22/public/android.jar",
+                        "prebuilts/sdk/32/public/android.jar",
+                    )
+                    .map { androidDir.resolve(it) }
+            )
+
+        val scanConfig =
+            PatternNode.ScanConfig(
+                dir = androidDir,
+                fileProvider = limitedFileProvider,
+            )
+        val files = node.scan(scanConfig)
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/19/public/android.jar, version=19)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/22/public/android.jar, version=22)
+                MatchedPatternFile(file=ANDROID_ROOT/prebuilts/sdk/32/public/android.jar, version=32)
+            """
+        )
+    }
+
+    /** Create an API file, e.g. [name]`.txt` file in the [DirectoryBuilder]. */
+    private fun DirectoryBuilder.apiFile(name: String = "api") = emptyFile("$name.txt")
+
+    /** Create a structure of versioned API files for testing. */
+    private fun createApiFileStructure(): File {
+        val rootDir = buildFileStructure {
+            dir("1") { apiFile() }
+            dir("1.1") { apiFile() }
+            dir("1.1.1") { apiFile() }
+            dir("1.1.2-beta01") { apiFile() }
+            dir("2") { apiFile() }
+            dir("2.2") { apiFile() }
+            dir("2.2.3") { apiFile() }
+        }
+        return rootDir
+    }
+
+    @Test
+    fun `Scan with empty patterns`() {
+        val rootDir = createApiFileStructure()
+        val node = PatternNode.parsePatterns(emptyList())
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiVersionFilter = null))
+        assertEquals(emptyList(), files)
+    }
+
+    @Test
+    fun `Scan for major minor`() {
+        val rootDir = createApiFileStructure()
+
+        val patterns =
+            listOf(
+                "{version:major.minor?}/api.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiVersionFilter = null))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/1/api.txt, version=1)
+                MatchedPatternFile(file=TESTROOT/1.1/api.txt, version=1.1)
+                MatchedPatternFile(file=TESTROOT/2/api.txt, version=2)
+                MatchedPatternFile(file=TESTROOT/2.2/api.txt, version=2.2)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan for major minor patch`() {
+        val rootDir = createApiFileStructure()
+
+        val patterns =
+            listOf(
+                "{version:major.minor.patch}/api.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiVersionFilter = null))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/1.1.1/api.txt, version=1.1.1)
+                MatchedPatternFile(file=TESTROOT/2.2.3/api.txt, version=2.2.3)
+            """
+        )
+    }
+
+    @Test
+    fun `Scan for major minor patch plus wildcard`() {
+        val rootDir = createApiFileStructure()
+
+        val patterns =
+            listOf(
+                // Use a wildcard to allow (and ignore) additional text after the patch, e.g. a
+                // pre-release quality tag like -beta01.
+                "{version:major.minor.patch}*/api.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiVersionFilter = null))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/1.1.1/api.txt, version=1.1.1)
+                MatchedPatternFile(file=TESTROOT/1.1.2-beta01/api.txt, version=1.1.2)
+                MatchedPatternFile(file=TESTROOT/2.2.3/api.txt, version=2.2.3)
+            """
+        )
+    }
+
+    @Test
+    fun `Check pattern with version extension includes module`() {
+        val patterns =
+            listOf(
+                "extensions/{version:extension}/api.txt",
+            )
+        val exception =
+            assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
+        assertEquals(
+            "Pattern 'extensions/{version:extension}/api.txt' contains `{version:extension}` but does not contain `{module}`",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Scan for extension version`() {
+        val rootDir = createApiFileStructure()
+
+        val patterns =
+            listOf(
+                "{version:extension}/{module}.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        // This range should have no effect on extension versions.
+        val range = ApiVersion.fromLevel(20).rangeTo(ApiVersion.fromLevel(22))
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiVersionFilter = range::contains))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/1/api.txt, version=1, extension=true, module='api')
+                MatchedPatternFile(file=TESTROOT/2/api.txt, version=2, extension=true, module='api')
+            """
+        )
+    }
+
+    @Test
+    fun `Scan for module`() {
+        val rootDir = buildFileStructure {
+            dir("extensions") {
+                dir("1") { apiFile("module-one") }
+                dir("2") {
+                    apiFile("module-two")
+                    apiFile("module.three")
+                }
+                dir("3") {
+                    apiFile("module-one")
+                    apiFile("module-two")
+                }
+            }
+        }
+
+        val patterns =
+            listOf(
+                "extensions/{version:extension}/{module}.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files = node.scan(PatternNode.ScanConfig(rootDir))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/extensions/1/module-one.txt, version=1, extension=true, module='module-one')
+                MatchedPatternFile(file=TESTROOT/extensions/3/module-one.txt, version=3, extension=true, module='module-one')
+                MatchedPatternFile(file=TESTROOT/extensions/2/module-two.txt, version=2, extension=true, module='module-two')
+                MatchedPatternFile(file=TESTROOT/extensions/3/module-two.txt, version=3, extension=true, module='module-two')
+                MatchedPatternFile(file=TESTROOT/extensions/2/module.three.txt, version=2, extension=true, module='module.three')
+            """
+        )
+    }
+
+    @Test
+    fun `Scan for extension and non-extension versions`() {
+        val rootDir = buildFileStructure {
+            dir("1.7") { apiFile("module.txt") }
+            dir("extensions") { dir("1") { apiFile("module.txt") } }
+        }
+
+        val patterns =
+            listOf(
+                "extensions/{version:extension}/{module}.txt",
+                "{version:major.minor?}/{module}.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files =
+            node.scan(
+                PatternNode.ScanConfig(rootDir),
+            )
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/1.7/module.txt.txt, version=1.7, module='module.txt')
+                MatchedPatternFile(file=TESTROOT/extensions/1/module.txt.txt, version=1, extension=true, module='module.txt')
+            """
+        )
+    }
+
+    @Test
+    fun `Test use surface placeholder without surfaces`() {
+        val rootDir = buildFileStructure { dir("1") { dir("public") { apiFile() } } }
+
+        val patterns =
+            listOf(
+                "{version:level}/{surface}/api.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                node.scan(PatternNode.ScanConfig(rootDir))
+            }
+        assertEquals(
+            "Must provide ScanConfig.apiSurfaceByName when {surface} is used",
+            exception.message
+        )
+    }
+
+    /**
+     * Check scanning for files that contain surfaces.
+     *
+     * @param apiSurfaces the set of allowable [ApiSurface]s.
+     * @param expectedFiles the expected set of matching files.
+     */
+    private fun checkScanningForSurfaces(apiSurfaces: ApiSurfaces, expectedFiles: String) {
+        val rootDir = buildFileStructure {
+            dir("1") { dir("public") { apiFile() } }
+            dir("2") {
+                dir("public") { apiFile() }
+                dir("system") { apiFile() }
+                // 'test' should not appear in the scanned files as it is not a supported surface.
+                dir("test") { apiFile() }
+            }
+            dir("3") {
+                dir("public") { apiFile() }
+                dir("system") { apiFile() }
+                dir("module-lib") { apiFile() }
+                // 'test' should not appear in the scanned files as it is not a supported surface.
+                dir("test") { apiFile() }
+            }
+        }
+
+        val patterns =
+            listOf(
+                "{version:level}/{surface}/api.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val apiSurfaceByName = apiSurfaces.byName
+        val files = node.scan(PatternNode.ScanConfig(rootDir, apiSurfaceByName = apiSurfaceByName))
+        files.assertMatchedPatternFiles(expectedFiles)
+    }
+
+    @Test
+    fun `Scan for surface - public`() {
+        val apiSurfaces = ApiSurfaces.build { createSurface(name = "public", isMain = true) }
+
+        checkScanningForSurfaces(
+            apiSurfaces,
+            expectedFiles =
+                """
+                    MatchedPatternFile(file=TESTROOT/1/public/api.txt, version=1, surface='public')
+                    MatchedPatternFile(file=TESTROOT/2/public/api.txt, version=2, surface='public')
+                    MatchedPatternFile(file=TESTROOT/3/public/api.txt, version=3, surface='public')
+                """,
+        )
+    }
+
+    @Test
+    fun `Scan for surface - system`() {
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface(name = "public")
+                createSurface(name = "system", extends = "public", isMain = true)
+            }
+
+        checkScanningForSurfaces(
+            apiSurfaces,
+            expectedFiles =
+                """
+                    MatchedPatternFile(file=TESTROOT/1/public/api.txt, version=1, surface='public')
+                    MatchedPatternFile(file=TESTROOT/2/public/api.txt, version=2, surface='public')
+                    MatchedPatternFile(file=TESTROOT/2/system/api.txt, version=2, surface='system')
+                    MatchedPatternFile(file=TESTROOT/3/public/api.txt, version=3, surface='public')
+                    MatchedPatternFile(file=TESTROOT/3/system/api.txt, version=3, surface='system')
+                """,
+        )
+    }
+
+    @Test
+    fun `Scan for surface - module-lib`() {
+        val apiSurfaces =
+            ApiSurfaces.build {
+                createSurface(name = "public")
+                createSurface(name = "system", extends = "public")
+                createSurface(name = "module-lib", extends = "public", isMain = true)
+            }
+
+        checkScanningForSurfaces(
+            apiSurfaces,
+            expectedFiles =
+                """
+                    MatchedPatternFile(file=TESTROOT/1/public/api.txt, version=1, surface='public')
+                    MatchedPatternFile(file=TESTROOT/2/public/api.txt, version=2, surface='public')
+                    MatchedPatternFile(file=TESTROOT/2/system/api.txt, version=2, surface='system')
+                    MatchedPatternFile(file=TESTROOT/3/public/api.txt, version=3, surface='public')
+                    MatchedPatternFile(file=TESTROOT/3/system/api.txt, version=3, surface='system')
+                    MatchedPatternFile(file=TESTROOT/3/module-lib/api.txt, version=3, surface='module-lib')
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/VersionedSignatureApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/VersionedSignatureApiTest.kt
new file mode 100644
index 000000000..8d678970b
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/VersionedSignatureApiTest.kt
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.cli.common.SignatureFileLoader
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.text.SignatureFile
+import kotlin.test.assertEquals
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+class VersionedSignatureApiTest {
+    companion object {}
+
+    @Test
+    fun `Empty files`() {
+        val fakeSignatureFileLoader =
+            object : SignatureFileLoader {
+                override fun load(
+                    signatureFiles: List<SignatureFile>,
+                    classResolver: ClassResolver?
+                ): Codebase {
+                    error("fake")
+                }
+            }
+
+        val versionOne = ApiVersion.fromLevel(1)
+        val updater = ApiHistoryUpdater.forApiVersion(versionOne)
+
+        val exception =
+            assertThrows(IllegalArgumentException::class.java) {
+                VersionedSignatureApi(fakeSignatureFileLoader, emptyList(), updater)
+            }
+        assertEquals("files must contain at least one file", exception.message)
+    }
+
+    private fun checkStringsToBraceExpansion(
+        strings: List<String>,
+        expectedBraceExpansion: String
+    ) {
+        val braceExpansion = VersionedSignatureApi.stringsToBashBraceExpansion(strings)
+        assertEquals(expectedBraceExpansion, braceExpansion)
+    }
+
+    @Test
+    fun `Single file - toString`() {
+        val strings = listOf("single-path")
+        checkStringsToBraceExpansion(strings, "single-path")
+    }
+
+    @Test
+    fun `Common suffix but no common prefix`() {
+        val strings = listOf("alpha/common", "beta/common")
+        checkStringsToBraceExpansion(strings, "{alph,bet}a/common")
+    }
+
+    @Test
+    fun `Common prefix but no common suffix`() {
+        val strings = listOf("common/alpha", "common/epsilon")
+        checkStringsToBraceExpansion(strings, "common/{alpha,epsilon}")
+    }
+
+    @Test
+    fun `No common prefix or suffix`() {
+        val strings = listOf("alpha/beta", "gamma/epsilon")
+        checkStringsToBraceExpansion(strings, "{alpha/beta,gamma/epsilon}")
+    }
+
+    @Test
+    fun `Common prefix and common suffix`() {
+        val strings =
+            listOf(
+                "prebuilts/sdk/28/public/api/android.txt",
+                "prebuilts/sdk/28/system/api/android.txt",
+            )
+        checkStringsToBraceExpansion(strings, "prebuilts/sdk/28/{public,system}/api/android.txt")
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
index 30ed7092d..06ee01663 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
@@ -25,13 +25,13 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(Int) [RemovedMethod]
+                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
             """,
             signatureSource =
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void baz(Int);
+                    method public void baz(int);
                   }
                 }
             """,
@@ -39,7 +39,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -51,7 +51,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(Int) [RemovedMethod]
+                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -65,7 +65,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -77,7 +77,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(Int) [RemovedMethod]
+                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -91,7 +91,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -103,14 +103,13 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed return type from void to java.lang.Int [ChangedType]
-                load-api.txt:4: error: Attempted to remove nullability from java.lang.Int (was NONNULL) in method test.pkg.Foo.bar(Int) [InvalidNullConversion]
+                load-api.txt:4: error: Method test.pkg.Foo.bar has changed return type from void to int [ChangedType]
             """,
             signatureSource =
                 """
                 package test.pkg {
                   public class Foo {
-                    method public Int bar(Int);
+                    method public int bar(int);
                   }
                 }
             """,
@@ -118,7 +117,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -136,7 +135,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int) throws java.lang.Throwable;
+                    method public void bar(int) throws java.lang.Throwable;
                   }
                 }
             """,
@@ -144,7 +143,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -162,7 +161,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -170,7 +169,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int) throws java.lang.Throwable;
+                    method public void bar(int) throws java.lang.Throwable;
                   }
                 }
             """
@@ -184,7 +183,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int) throws java.lang.Exception, java.lang.Throwable;
+                    method public void bar(int) throws java.lang.Exception, java.lang.Throwable;
                   }
                 }
             """,
@@ -192,7 +191,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int) throws java.lang.Throwable, java.lang.Exception;
+                    method public void bar(int) throws java.lang.Throwable, java.lang.Exception;
                   }
                 }
             """
@@ -213,7 +212,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method protected void bar(Int);
+                    method protected void bar(int);
                   }
                 }
             """,
@@ -221,7 +220,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -235,7 +234,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -243,7 +242,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method protected void bar(Int);
+                    method protected void bar(int);
                   }
                 }
             """
@@ -257,7 +256,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   abstract class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -265,7 +264,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   abstract class Foo {
-                    method abstract public void bar(Int);
+                    method abstract public void bar(int);
                   }
                 }
             """
@@ -283,7 +282,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public abstract class Foo {
-                    method abstract public void bar(Int);
+                    method abstract public void bar(int);
                   }
                 }
             """,
@@ -291,7 +290,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public abstract class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -309,7 +308,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -317,7 +316,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method final public void bar(Int);
+                    method final public void bar(int);
                   }
                 }
             """
@@ -331,7 +330,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   sealed class Foo {
-                    method final public void bar(Int);
+                    method final public void bar(int);
                   }
                 }
             """,
@@ -339,7 +338,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   sealed class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -358,7 +357,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 package test.pkg {
                   public class Foo {
                     ctor public Foo();
-                    method final public void bar(Int);
+                    method final public void bar(int);
                   }
                 }
             """,
@@ -367,7 +366,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 package test.pkg {
                   public class Foo {
                     ctor public Foo();
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -385,7 +384,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -393,7 +392,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method static public void bar(Int);
+                    method static public void bar(int);
                   }
                 }
             """
@@ -411,7 +410,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method static public void bar(Int);
+                    method static public void bar(int);
                   }
                 }
             """,
@@ -419,7 +418,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -433,7 +432,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method native public void bar(Int);
+                    method native public void bar(int);
                   }
                 }
             """,
@@ -441,7 +440,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -455,7 +454,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -463,7 +462,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method native public void bar(Int);
+                    method native public void bar(int);
                   }
                 }
             """
@@ -477,7 +476,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
@@ -485,7 +484,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method synchronized public void bar(Int);
+                    method synchronized public void bar(int);
                   }
                 }
             """
@@ -499,7 +498,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method synchronized public void bar(Int);
+                    method synchronized public void bar(int);
                   }
                 }
             """,
@@ -507,7 +506,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -542,14 +541,14 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             signatureSource = """
                 package test.pkg {
                   public class Foo {
-                    method public <T> void bar(Int);
+                    method public <T> void bar(int);
                   }
                 }
             """,
             checkCompatibilityApiReleased = """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -561,14 +560,14 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             signatureSource = """
                 package test.pkg {
                   public class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """,
             checkCompatibilityApiReleased = """
                 package test.pkg {
                   public class Foo {
-                    method public <T> void bar(Int);
+                    method public <T> void bar(int);
                   }
                 }
             """
@@ -580,14 +579,14 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             signatureSource = """
                 package test.pkg {
                   public class Foo {
-                    method public <T, K> void bar(Int);
+                    method public <T, K> void bar(int);
                   }
                 }
             """,
             checkCompatibilityApiReleased = """
                 package test.pkg {
                   public class Foo {
-                    method public <K, T> void bar(Int);
+                    method public <K, T> void bar(int);
                   }
                 }
             """
@@ -599,14 +598,14 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             signatureSource = """
                 package test.pkg {
                   public class Foo {
-                    method public <T> void bar(Int);
+                    method public <T> void bar(int);
                   }
                 }
             """,
             checkCompatibilityApiReleased = """
                 package test.pkg {
                   public class Foo {
-                    method public <K> void bar(Int);
+                    method public <K> void bar(int);
                   }
                 }
             """
@@ -618,14 +617,14 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             signatureSource = """
                 package test.pkg {
                   public class Foo {
-                    method public <T extends Foo> void bar(Int);
+                    method public <T extends Foo> void bar(int);
                   }
                 }
             """,
             checkCompatibilityApiReleased = """
                 package test.pkg {
                   public class Foo {
-                    method public <T> void bar(Int);
+                    method public <T> void bar(int);
                   }
                 }
             """
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
index 149233fd1..1c612209f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.cli.common
 
+import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.OptionsDelegate
 import com.android.tools.metalava.ProgressTracker
 import com.android.tools.metalava.run
@@ -98,6 +99,38 @@ class CommandTestConfig<C : CliktCommand>(private val test: BaseCommandTest<C>)
      */
     val args = mutableListOf<String>()
 
+    /** Add a [TestFile] to [args] by creating a [File] and adding its [File.path]. */
+    operator fun MutableList<String>.plusAssign(testFile: TestFile) {
+        this += testFile.createFile(test.temporaryFolder.root)
+    }
+
+    /**
+     * Make it easy to add anything to the [args] list by automatically calling [toString] on it.
+     *
+     * If the [toString] value is wrong then it will quickly be found by the test.
+     */
+    operator fun MutableList<String>.plusAssign(arg: Any) {
+        add(arg.toString())
+    }
+
+    /**
+     * Make it easy to add anything to the [args] list by automatically calling [toString] on it.
+     *
+     * If the [toString] value is wrong then it will quickly be found by the test.
+     */
+    operator fun MutableList<String>.plusAssign(args: Iterable<Any>) {
+        args.mapTo(this) { it.toString() }
+    }
+
+    /**
+     * Make it easy to add anything to the [args] list by automatically calling [toString] on it.
+     *
+     * If the [toString] value is wrong then it will quickly be found by the test.
+     */
+    operator fun MutableList<String>.plusAssign(args: Array<Any>) {
+        args.mapTo(this) { it.toString() }
+    }
+
     /**
      * The expected output, defaults to an empty string.
      *
@@ -112,6 +145,8 @@ class CommandTestConfig<C : CliktCommand>(private val test: BaseCommandTest<C>)
      */
     var expectedStderr: String = ""
 
+    var stdin: String = ""
+
     /**
      * The command that is being tested.
      *
@@ -144,6 +179,15 @@ class CommandTestConfig<C : CliktCommand>(private val test: BaseCommandTest<C>)
         return f
     }
 
+    /**
+     * Create a file that can be passed as an input to a command.
+     *
+     * @param contents the contents of the file, will have [String.trimIndent] called before passing
+     *   to [inputFile].
+     */
+    fun unindentedInputFile(name: String, contents: String, parentDir: File? = null) =
+        inputFile(name, contents.trimIndent(), parentDir)
+
     /**
      * Get the path to a file that can be passed as an output from a command.
      *
@@ -201,7 +245,7 @@ class CommandTestConfig<C : CliktCommand>(private val test: BaseCommandTest<C>)
 
     /** Run the test defined by the configuration. */
     internal fun runTest() {
-        val (executionEnvironment, stdout, stderr) = ExecutionEnvironment.forTest()
+        val (executionEnvironment, stdout, stderr) = ExecutionEnvironment.forTest(stdin)
 
         // Runs the command
         command = test.commandFactory(executionEnvironment)
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseOptionGroupTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseOptionGroupTest.kt
index 0f6f8a711..51bdb83c5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseOptionGroupTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseOptionGroupTest.kt
@@ -23,6 +23,8 @@ import com.github.ajalt.clikt.core.context
 import com.github.ajalt.clikt.core.subcommands
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.groups.provideDelegate
+import kotlin.properties.PropertyDelegateProvider
+import kotlin.reflect.KProperty
 import org.junit.Assert
 import org.junit.Rule
 import org.junit.Test
@@ -42,14 +44,24 @@ abstract class BaseOptionGroupTest<O : OptionGroup>(
      *
      * Generally this will use the [OptionGroup] created by [createOptions] but that can be
      * overridden for a test by providing an [optionGroup] parameter directly.
+     *
+     * @param args the arguments to pass to Clikt to parse.
+     * @param optionGroup the [OptionGroup] implementation to use, if `null` then this will use
+     *   [createOptions] to create a new one.
+     * @param includeDependentGroups `true` if dependent [OptionGroup]s, i.e. [OptionGroup]s whose
+     *   option properties are referenced from [optionGroup], need to be included in the test so
+     *   that they are initialized properly. If this is `true` and [optionGroup] implements
+     *   [RequiresOtherGroups] then [OptionGroup]s in [RequiresOtherGroups.requiredGroups] are added
+     *   to the [CliktCommand] used for testing.
      */
     protected fun runTest(
         vararg args: String,
         optionGroup: O? = null,
+        includeDependentGroups: Boolean = true,
         test: Result<O>.() -> Unit,
     ) {
         val testFactory = { optionGroup ?: createOptions() }
-        val command = MockCommand(testFactory)
+        val command = MockCommand(testFactory, includeDependentGroups)
         val (executionEnvironment, stdout, stderr) = ExecutionEnvironment.forTest()
         val rootCommand = MetalavaCommand(executionEnvironment, null, ProgressTracker())
         rootCommand.subcommands(command)
@@ -79,18 +91,89 @@ abstract class BaseOptionGroupTest<O : OptionGroup>(
 
     @Test
     fun `Test help`() {
-        runTest { Assert.assertEquals(expectedHelp, stdout) }
+        runTest(
+            "--help",
+            // Do not include dependent groups when generating the help.
+            includeDependentGroups = false,
+        ) {
+            val trimmedOut =
+                stdout.removePrefix(
+                    """
+                        Options:
+                          --help                                     Show this message and exit
+
+
+                    """
+                        .trimIndent()
+                )
+            Assert.assertEquals(expectedHelp, trimmedOut)
+        }
+    }
+}
+
+/**
+ * A [PropertyDelegateProvider] that will retrieve any [RequiresOtherGroups.requiredGroups] from
+ * [optionGroup] and treat them as if they were property delegated of the [CliktCommand] to which
+ * this belongs.
+ */
+private class DependentGroupsProvider(
+    private val optionGroup: OptionGroup,
+    private val includeDependentGroups: Boolean
+) : PropertyDelegateProvider<CliktCommand, DependentGroupsProvider> {
+    /**
+     * If [includeDependentGroups] is `true` and [optionGroup] is a [RequiresOtherGroups] then this
+     * will invoke [OptionGroup.provideDelegate] on each [OptionGroup] in
+     * [RequiresOtherGroups.requiredGroups].
+     */
+    override fun provideDelegate(
+        thisRef: CliktCommand,
+        property: KProperty<*>
+    ): DependentGroupsProvider {
+        if (includeDependentGroups) {
+            if (optionGroup is RequiresOtherGroups) {
+                for (dependentGroup in optionGroup.requiredGroups) {
+                    dependentGroup.provideDelegate(thisRef, property)
+                }
+            }
+        }
+
+        return this
+    }
+
+    /** Needed to be a property delegate; simply returns this. */
+    operator fun getValue(command: CliktCommand, property: KProperty<*>): DependentGroupsProvider {
+        return this
     }
 }
 
-private class MockCommand<O : OptionGroup>(factory: () -> O) :
-    CliktCommand(printHelpOnEmptyArgs = true) {
+/**
+ * A [CliktCommand] that is used to parse test arguments and initialize the [OptionGroup] being
+ * tested.
+ *
+ * @param O the type of [OptionGroup] being tested.
+ * @param factory a factory for creating the [OptionGroup] to be tested.
+ * @param includeDependentGroups if dependent [OptionGroup]s need to be included in the test. See
+ *   [BaseOptionGroupTest.runTest] for more details.
+ */
+private class MockCommand<O : OptionGroup>(factory: () -> O, includeDependentGroups: Boolean) :
+    CliktCommand() {
     val options by factory()
 
+    /**
+     * Register the [DependentGroupsProvider] as a property delegate of this instance so that it can
+     * register any dependent [OptionGroup]s, if required.
+     *
+     * This is unused as it is here only for its side effect of registering dependent
+     * [OptionGroup]s.
+     */
+    @Suppress("unused")
+    private val dependentGroups by DependentGroupsProvider(options, includeDependentGroups)
+
     init {
         context {
             localization = MetalavaLocalization()
             helpFormatter = MetalavaHelpFormatter(::plainTerminal, localization)
+            helpOptionNames = setOf("--help")
         }
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
index 8b3bd90f7..5959df503 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
@@ -18,15 +18,9 @@ package com.android.tools.metalava.cli.common
 
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
-import java.io.File
 import org.junit.Assert.assertEquals
-import org.junit.Rule
 import org.junit.Test
-import org.junit.rules.TestRule
-import org.junit.runner.Description
-import org.junit.runners.model.Statement
 
 val ISSUE_REPORTING_OPTIONS_HELP =
     """
@@ -55,72 +49,12 @@ Issue Reporting:
     """
         .trimIndent()
 
-/**
- * JUnit [TestRule] that will intercept calls to [ReporterEnvironment.printReport], save them into a
- * couple of buffers and then allow the test to verify them. If there are any unverified errors then
- * the test will fail. The other issues will only be verified when requested.
- */
-class ReportCollectorRule(
-    private val cleaner: (String) -> String,
-    private val rootFolderSupplier: () -> File,
-) : TestRule {
-    private val allReportedIssues = StringBuilder()
-    private val errorSeverityReportedIssues = StringBuilder()
-
-    internal var reporterEnvironment: ReporterEnvironment? = null
-
-    override fun apply(base: Statement, description: Description): Statement {
-        return object : Statement() {
-            override fun evaluate() {
-                try {
-                    reporterEnvironment = InterceptingReporterEnvironment()
-                    // Evaluate the test.
-                    base.evaluate()
-                } finally {
-                    reporterEnvironment = null
-                }
-
-                assertEquals("", errorSeverityReportedIssues.toString())
-            }
-        }
-    }
-
-    fun verifyAll(expected: String) {
-        assertEquals(expected.trim(), allReportedIssues.toString().trim())
-        allReportedIssues.clear()
-    }
-
-    fun verifyErrors(expected: String) {
-        assertEquals(expected.trim(), errorSeverityReportedIssues.toString().trim())
-        errorSeverityReportedIssues.clear()
-    }
-
-    /** Intercepts calls to the [ReporterEnvironment] and collates the reports. */
-    private inner class InterceptingReporterEnvironment : ReporterEnvironment {
-
-        override val rootFolder: File
-            get() = rootFolderSupplier()
-
-        override fun printReport(message: String, severity: Severity) {
-            val cleanedMessage = cleaner(message)
-            if (severity == Severity.ERROR) {
-                errorSeverityReportedIssues.append(cleanedMessage).append('\n')
-            }
-            allReportedIssues.append(cleanedMessage).append('\n')
-        }
-    }
-}
-
 class IssueReportingOptionsTest :
     BaseOptionGroupTest<IssueReportingOptions>(
         ISSUE_REPORTING_OPTIONS_HELP,
     ) {
 
-    @get:Rule
-    val reportCollector = ReportCollectorRule(this::cleanupString, { temporaryFolder.root })
-
-    override fun createOptions(): IssueReportingOptions =
-        IssueReportingOptions(reporterEnvironment = reportCollector.reporterEnvironment!!)
+    override fun createOptions() = IssueReportingOptions()
 
     @Test
     fun `Test issue severity options`() {
@@ -166,15 +100,14 @@ class IssueReportingOptionsTest :
     @Test
     fun `Test issue severity options with case insensitive names`() {
         runTest("--hide", "arrayreturn") {
-            // Write any saved reports.
-            options.bootstrapReporter.writeSavedReports()
-
-            reportCollector.verifyAll(
-                "warning: Case-insensitive issue matching is deprecated, use --hide ArrayReturn instead of --hide arrayreturn [DeprecatedOption]"
-            )
+            assertEquals("Unknown issue id: '--hide' 'arrayreturn'", stderr)
 
+            // Make sure that the ARRAY_RETURN severity was not changed.
             val issueConfiguration = options.issueConfiguration
-            assertEquals(Severity.HIDDEN, issueConfiguration.getSeverity(Issues.ARRAY_RETURN))
+            assertEquals(
+                Issues.ARRAY_RETURN.defaultLevel,
+                issueConfiguration.getSeverity(Issues.ARRAY_RETURN)
+            )
         }
     }
 
@@ -213,18 +146,32 @@ class IssueReportingOptionsTest :
     }
 
     @Test
-    fun `Test issue severity options can affect issues related to processing the options`() {
-        runTest("--error", "DeprecatedOption", "--hide", "arrayreturn") {
-            // Write any saved reports.
-            options.bootstrapReporter.writeSavedReports()
+    fun `Test issue category`() {
+        runTest(ARG_HIDE_CATEGORY, "Compatibility") {
+            assertEquals("", stdout)
+            assertEquals("", stderr)
 
-            reportCollector.verifyErrors(
-                "error: Case-insensitive issue matching is deprecated, use --hide ArrayReturn instead of --hide arrayreturn [DeprecatedOption]\n"
-            )
+            // Make sure the two issues both default to warning.
+            val defaults = IssueConfiguration()
+            assertEquals(Severity.ERROR, defaults.getSeverity(Issues.ADD_SEALED))
+            assertEquals(Severity.ERROR, defaults.getSeverity(Issues.CHANGED_CLASS))
 
+            // Now make sure the issues are hidden.
             val issueConfiguration = options.issueConfiguration
-            assertEquals(Severity.HIDDEN, issueConfiguration.getSeverity(Issues.ARRAY_RETURN))
-            assertEquals(Severity.ERROR, issueConfiguration.getSeverity(Issues.DEPRECATED_OPTION))
+            assertEquals(Severity.HIDDEN, issueConfiguration.getSeverity(Issues.ADD_SEALED))
+            assertEquals(Severity.HIDDEN, issueConfiguration.getSeverity(Issues.CHANGED_CLASS))
+        }
+    }
+
+    @Test
+    fun `Test invalid category`() {
+        // Category names should start with an upper case letter.
+        runTest(ARG_HIDE_CATEGORY, "compatibility") {
+            assertEquals("", stdout)
+            assertEquals(
+                "Option --hide-category is invalid: Unknown category: 'compatibility', expected one of Compatibility, Documentation, ApiLint, Unknown",
+                stderr
+            )
         }
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/MetalavaCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/MetalavaCommandTest.kt
index 0ec68d235..44477cfac 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/MetalavaCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/MetalavaCommandTest.kt
@@ -136,6 +136,7 @@ class MetalavaCommandTest : TemporaryFolderOwner {
 
         val pattern =
             """\Qcom.android.tools.metalava.cli.common.MetalavaCliException: fail
+            |	at com.android.tools.metalava.cli.common.MetalavaCliExceptionKt.cliError\E\([^)]+\)\Q
             |	at com.android.tools.metalava.cli.common.MetalavaCommandTest${"$"}FailCommand.run\E\([^)]+\)
             |	at .*
             |	at .*
@@ -163,7 +164,7 @@ $separator
 
     private class FailCommand : CliktCommand() {
         override fun run() {
-            throw MetalavaCliException("fail")
+            cliError("fail")
         }
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
index 8f8deaed4..7c4444dac 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
@@ -22,10 +22,6 @@ Sources:
 
   Options that control which source files will be processed.
 
-  --common-source-path <path>                A : separated list of directories containing common source files (organized
-                                             in a standard Java package hierarchy). Common source files are where
-                                             platform-agnostic `expect` declarations for Kotlin multi-platform code as
-                                             well as common business logic are defined.
   --source-path <path>                       A : separated list of directories containing source files (organized in a
                                              standard Java package hierarchy).
   --stub-packages <package-list>             List of packages (separated by :) which will be used to filter out
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
index 299849fed..154ee5ed0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
@@ -30,13 +30,15 @@ class HelpCommandTest : BaseCommandTest<HelpCommand>({ HelpCommand() }) {
                 """
 Usage: metalava help <concept>...
 
-  Provides help for general metalava concepts
+  Provides help for general metalava concepts.
 
 Concepts
   issues                                     Provides help related to issues and issue reporting
   package-filters                            Explains the syntax and behavior of package filters used in options like
                                              --stub-packages.
   signature-file-formats                     Describes the different signature file formats.
+  historical-api-patterns                    Explains the syntax and behavior of historical API patterns used in options
+                                             like --android-jar-pattern.
                 """
                     .trimIndent()
         }
@@ -92,19 +94,22 @@ Usage: metalava help signature-file-formats
 
   The supported properties are:
 
-  * `kotlin-style-nulls = yes|no` - if `no` then the signature file will use `@Nullable` and `@NonNull` annotations to
+  * `include-default-parameter-values = yes|no` - If `no` then the signature file will not include any information about
+  default parameter values. If `yes` then it will use the pseudo modifier `optional` to indicate a parameter that has a
+  default value.
+
+  * `kotlin-style-nulls = yes|no` - If `no` then the signature file will use `@Nullable` and `@NonNull` annotations to
   indicate that the annotated item accepts `null` and does not accept `null` respectively and neither indicates that
   it's not defined.
 
   If `yes` then the signature file will use a type suffix of `?`, no type suffix and a type suffix of `!` to indicate
   the that the type accepts `null`, does not accept `null` or it's not defined respectively.
 
-  * `concise-default-values = yes|no` - if `no` then Kotlin parameters that have a default value will include that value
-  in the signature file. If `yes` then those parameters will simply be prefixed with `optional`, as if it was a keyword
-  and no value will be included.
-
   Plus the following properties which can have their default changed using the `--format-defaults` option.
 
+  * `normalize-final-modifier = yes|no` - Specifies how the `final` modifier is handled on `final` methods. If this is
+  `yes` and the method's containing class is `final` then the `final` modifier is not written out, otherwise it is.
+
   * `overloaded-method-order = source|signature` - Specifies the order of overloaded methods in signature files. Applies
   to the contents of the files specified on `--api` and `--removed-api`.
 
@@ -114,23 +119,105 @@ Usage: metalava help signature-file-formats
   `signature` (default) - sorts overloaded methods by their signature. This means that refactorings of the source files
   which change the order but not the API will have no effect on the API signature files.
 
+  * `type-argument-spacing = legacy|none|space` - Specifies the spacing between the type arguments of a generic type.
+  e.g. `Map<String, Integer>`. The default is `legacy`.
+
+  `legacy` - adds no spaces between type arguments except those used in the bounds of a type parameter. e.g.
+  `Map<String,Integer>` will have no space except in `class Foo<M extends Map<String, Integer>`.
+
+  `none` - adds no spaces between any type arguments.
+
+  `space` - adds a single space between every type argument.
+
+  Note: This does not affect the spacing of type parameters in a type parameter list, e.g. `interface Map<K, V>`. They
+  always have a space separator.
+
   Currently, metalava supports the following versions:
 
-  * `2.0` (--format=v2) - this is the base version (more details in `FORMAT.md`) on which all the others are based. It
+  * `2.0` (--format=v2) - This is the base version (more details in `FORMAT.md`) on which all the others are based. It
   sets the properties as follows:
 
   + kotlin-style-nulls = no
-  + concise-default-values = no
+  + include-default-parameter-values = no
 
-  * `3.0` (--format=v3) - this is `2.0` plus `kotlin-style-nulls = yes` giving the following properties:
+  * `4.0` (--format=v4) - This is `2.0` plus `kotlin-style-nulls = yes` and `include-default-parameter-values = yes`
+  giving the following properties:
 
   + kotlin-style-nulls = yes
-  + concise-default-values = no
+  + include-default-parameter-values = yes
+
+  * `5.0` - This is the first version that has full support for properties in the signature header. As such it does not
+  add any new defaults to `4.0`. The intent is that properties will be explicitly defined in the signature file avoiding
+  reliance on version specific defaults.
+                """
+                    .trimIndent()
+        }
+    }
+
+    @Test
+    fun `Test help historical-api-patterns`() {
+        commandTest {
+            args += listOf("help", "historical-api-patterns")
 
-  * `4.0` (--format=v4) - this is 3.0` plus `concise-default-values = yes` giving the following properties:
+            expectedStdout =
+                """
+Usage: metalava help historical-api-patterns
 
-  + kotlin-style-nulls = yes
-  + concise-default-values = yes
+  Explains the syntax and behavior of historical API patterns used in options like --android-jar-pattern.
+
+  A historical API pattern is used to find historical versioned API files that are used to construct a history of an API
+  surface, e.g. when items were added, removed, deprecated, etc.. It allows for efficiently scanning a directory for
+  matching files, or matching a given file. In both cases information is extracted from the file path, e.g. version,
+  that is used when constructing the API history.
+
+  Each pattern contains placeholders which match part of a file name, extracts the value, possibly filters it and then
+  stores it in a property. Each property can have at most a single associated placeholder in each pattern.
+
+  A `version` placeholder is mandatory but the other options are optional. Files that match a pattern are assumed to
+  provide the definition of that version of the API. e.g. given a pattern of
+  `prebuilts/sdk/{version:level}/public/android.jar` then it will match a file like `prebuilts/sdk/1/public/android.jar`
+  and that file is assumed to define version 1 of the API.
+
+  Patterns can also include any number of wildcards:
+
+  * `*` - matches any characters within a file name, but not into sub-directories. e.g. `foo/b*h/bar` will match
+  `foo/blah/bar` but not `foo/blah/blah/bar`.
+
+  The supported properties are:
+
+  * `version` - Mandatory property that stores the version of a matched file.
+
+  Apart from the {version:extension} all placeholders for this will ignore versions that fall outside the range
+  --first-version and --current-version, if provided.
+
+  * `module` - Optional property that stores the name of the SDK extension module.
+
+  Patterns that use a placeholder for this are assumed to be matching files for SDK extensions.
+
+  * `surface` - Optional property that stores the API surface.
+
+  The supported placeholders are:
+
+  * `{version:level}` - Placeholder for property `version`. Matches a single non-negative integer and treats it as an
+  API version.
+
+  * `{version:major.minor?}` - Placeholder for property `version`. Matches a single non-negative integer or two such
+  integers separated by a `.`.
+
+  * `{version:major.minor.patch}` - Placeholder for property `version`. Matches three non-negative integers separated by
+  `.`s.
+
+  * `{version:extension}` - Placeholder for property `version`. Matches a single non-negative integer and treats it as
+  an extension version.
+
+  A pattern that includes this must also include `{module}` as SDK extension APIs are stored in a file per extension
+  module.
+
+  * `{module}` - Placeholder for property `module`. Matches a module name which must consist of lower case letters,
+  hyphens and `.`s.
+
+  * `{surface}` - Placeholder for property `surface`. Matches a surface name which must consist of lower case letters
+  and hyphens.
                 """
                     .trimIndent()
         }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
index 025b64e1a..f21e7517c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
@@ -25,7 +25,6 @@ class IssuesCommandTest : BaseCommandTest<HelpCommand>({ HelpCommand() }) {
     fun `Test help`() {
         commandTest {
             args += listOf("help", "issues")
-
             expectedStdout =
                 """
 Usage: metalava help issues <issue>?
@@ -59,7 +58,6 @@ Available Issues                             |  Category                |   Defa
   BecameUnchecked                            |  compatibility           |   error
   BothPackageInfoAndHtml                     |  documentation           |   warning
   BroadcastBehavior                          |  documentation           |   error
-  BrokenArtifactFile                         |  documentation           |   error
   BuilderSetStyle                            |  api_lint                |   warning
   CallbackInterface                          |  api_lint                |   hidden
   CallbackMethodName                         |  api_lint                |   error
@@ -72,9 +70,7 @@ Available Issues                             |  Category                |   Defa
   ChangedScope                               |  compatibility           |   error
   ChangedStatic                              |  compatibility           |   error
   ChangedSuperclass                          |  compatibility           |   error
-  ChangedSynchronized                        |  compatibility           |   hidden
   ChangedThrows                              |  compatibility           |   error
-  ChangedTransient                           |  compatibility           |   error
   ChangedType                                |  compatibility           |   error
   ChangedValue                               |  compatibility           |   error
   ChangedVolatile                            |  compatibility           |   error
@@ -82,13 +78,11 @@ Available Issues                             |  Category                |   Defa
   ConcreteCollection                         |  api_lint                |   error
   ConditionalRequiresPermissionNotExplained  |  api_lint                |   hidden
   ConfigFieldName                            |  api_lint                |   error
-  ConfigFileProblem                          |  unknown                 |   error
-  ConflictingShowAnnotations                 |  unknown                 |   error
   ContextFirst                               |  api_lint                |   error
   ContextNameSuffix                          |  api_lint                |   error
+  DataClassDefinition                        |  api_lint                |   hidden
   DefaultValueChange                         |  compatibility           |   error
   Deprecated                                 |  documentation           |   hidden
-  DeprecatedOption                           |  unknown                 |   warning
   DeprecationMismatch                        |  documentation           |   error
   DocumentExceptions                         |  api_lint                |   error
   DuplicateSourceClass                       |  unknown                 |   warning
@@ -115,9 +109,9 @@ Available Issues                             |  Category                |   Defa
   HiddenTypeParameter                        |  documentation           |   warning
   HiddenTypedefConstant                      |  unknown                 |   error
   IgnoringSymlink                            |  unknown                 |   info
-  IllegalStateException                      |  api_lint                |   warning
   InconsistentMergeAnnotation                |  api_lint                |   warning_error_when_new
   InfixRemoval                               |  compatibility           |   error
+  InheritChangesSignature                    |  unknown                 |   warning_error_when_new
   IntDef                                     |  documentation           |   hidden
   IntentBuilderName                          |  api_lint                |   warning
   IntentName                                 |  api_lint                |   error
@@ -125,6 +119,8 @@ Available Issues                             |  Category                |   Defa
   InternalClasses                            |  api_lint                |   error
   InternalError                              |  unknown                 |   error
   InternalField                              |  api_lint                |   error
+  InvalidEnvironmentInRestrictedForEnvironment
+                                             |  api_lint                |   error
   InvalidFeatureEnforcement                  |  documentation           |   error
   InvalidNullConversion                      |  compatibility           |   error
   InvalidNullabilityAnnotation               |  unknown                 |   error
@@ -146,6 +142,7 @@ Available Issues                             |  Category                |   Defa
   MinMaxConstant                             |  api_lint                |   warning
   MissingBuildMethod                         |  api_lint                |   warning
   MissingColumn                              |  documentation           |   warning
+  MissingFromValue                           |  api_lint                |   error
   MissingGetterMatchingBuilder               |  api_lint                |   warning
   MissingInnerNullability                    |  api_lint                |   hidden
   MissingJvmstatic                           |  api_lint                |   warning
@@ -153,7 +150,6 @@ Available Issues                             |  Category                |   Defa
   MissingPermission                          |  documentation           |   error
   MultipleThreadAnnotations                  |  documentation           |   error
   MutableBareField                           |  api_lint                |   error
-  NoArtifactData                             |  documentation           |   hidden
   NoByteOrShort                              |  api_lint                |   warning
   NoClone                                    |  api_lint                |   error
   NoSettingsProvider                         |  api_lint                |   hidden
@@ -180,7 +176,6 @@ Available Issues                             |  Category                |   Defa
   RawAidl                                    |  api_lint                |   error
   ReferencesDeprecated                       |  api_lint                |   hidden
   ReferencesHidden                           |  api_lint                |   error
-  RegistrationName                           |  api_lint                |   error
   RemovedAnnotation                          |  compatibility           |   error
   RemovedClass                               |  compatibility           |   error
   RemovedDeprecatedClass                     |  compatibility           |   inherit
@@ -204,6 +199,7 @@ Available Issues                             |  Category                |   Defa
   ServiceName                                |  api_lint                |   error
   SetterReturnsThis                          |  api_lint                |   warning
   ShowingMemberInHiddenClass                 |  api_lint                |   error
+  SignatureFileError                         |  unknown                 |   error
   SingleMethodInterface                      |  api_lint                |   error
   SingletonConstructor                       |  api_lint                |   error
   SingularCallback                           |  api_lint                |   error
@@ -220,7 +216,7 @@ Available Issues                             |  Category                |   Defa
   UnhiddenSystemApi                          |  api_lint                |   error
   UniqueKotlinOperator                       |  api_lint                |   error
   UnmatchedMergeAnnotation                   |  api_lint                |   error
-  UnresolvedClass                            |  documentation           |   error
+  UnqualifiedTypeError                       |  unknown                 |   hidden
   UnresolvedImport                           |  unknown                 |   info
   UnresolvedLink                             |  documentation           |   error
   UseIcu                                     |  api_lint                |   warning
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommandTest.kt
new file mode 100644
index 000000000..e1bb01c5f
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/historical/AndroidJarsToSignaturesCommandTest.kt
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.historical
+
+import com.android.tools.metalava.ARG_CONFIG_FILE
+import com.android.tools.metalava.CONFIG_FILE_OPTIONS_HELP
+import com.android.tools.metalava.KnownConfigFiles
+import com.android.tools.metalava.cli.common.BaseCommandTest
+import com.android.tools.metalava.cli.signature.SIGNATURE_FORMAT_OPTIONS_HELP
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.assertSignatureContents
+import com.android.tools.metalava.testing.java
+import java.io.File
+import org.junit.Assert
+import org.junit.Test
+
+class AndroidJarsToSignaturesCommandTest :
+    BaseCommandTest<AndroidJarsToSignaturesCommand>({ AndroidJarsToSignaturesCommand() }) {
+
+    @Test
+    fun `Test help`() {
+        commandTest {
+            args += listOf("android-jars-to-signatures")
+
+            expectedStdout =
+                """
+Aborting: Usage: metalava android-jars-to-signatures [options] <android-root-dir>
+
+  Rewrite the signature files in the `prebuilts/sdk` directory in the Android source tree.
+
+  It does this by reading the API defined in the corresponding `android.jar` files.
+
+Options:
+  --api-versions <api-version-list>          Comma separated list of api versions to convert. If unspecified then all
+                                             versions will be converted.
+  --api-surfaces <api-surface-list>          Comma separated list of api surfaces to convert. If unspecified then only
+                                             `public` will be converted.
+  -h, -?, --help                             Show this message and exit
+
+$CONFIG_FILE_OPTIONS_HELP
+
+$SIGNATURE_FORMAT_OPTIONS_HELP
+
+Arguments:
+  <android-root-dir>                         The root directory of the Android source tree. The new signature files will
+                                             be generated in the `prebuilts/sdk/<api>/<surface>/api/android.txt`
+                                             sub-directories.
+            """
+                    .trimIndent()
+        }
+    }
+
+    @Test
+    fun `Test not Android dir`() {
+        commandTest {
+            val notAndroidRoot = folder("not-android-root")
+
+            args += "android-jars-to-signatures"
+            args += notAndroidRoot
+
+            expectedStderr =
+                """
+                    Aborting: <android-root-dir> does not point to an Android source tree
+                """
+                    .trimIndent()
+        }
+    }
+
+    private fun currentVersionDir(apiVersion: Int, surface: String): String {
+        return "prebuilts/sdk/$apiVersion/$surface"
+    }
+
+    private fun currentApiDir(apiVersion: Int, surface: String = "public"): String {
+        return "${currentVersionDir(apiVersion, surface)}/api"
+    }
+
+    private fun currentAndroidJarFile(apiVersion: Int, surface: String = "public"): String {
+        return "${currentVersionDir(apiVersion, surface)}/android.jar"
+    }
+
+    private fun currentApiTxtFile(apiVersion: Int, surface: String = "public"): String {
+        return "${currentApiDir(apiVersion, surface)}/android.txt"
+    }
+
+    @Test
+    fun `Test convert jars`() {
+        // Get the location of an android.jar in the prebuilts/sdk files generated by the build.
+        val prebuiltsSdkDir = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
+        if (!prebuiltsSdkDir.isDirectory) {
+            Assert.fail("test prebuilts not found: $prebuiltsSdkDir")
+        }
+        val androidJar = prebuiltsSdkDir.resolve("30/public/android.jar")
+
+        commandTest {
+            // Copy the android.jar into a temporary folder structure.
+            val androidRootDir = folder("android-root-dir")
+
+            data class ApiVersionInfo(
+                val version: Int,
+                val inputAndroidJarFile: File,
+                val inputAndroidTxtFile: File? = null,
+            )
+            val apiVersionsInfo = mutableListOf<ApiVersionInfo>()
+
+            // All android.jars are in prebuilts/sdk/<N>/public/android.jar.
+            for (apiVersion in 1..5) {
+                val versionJar = androidRootDir.resolve(currentAndroidJarFile(apiVersion))
+
+                // All android.jar files already have a corresponding android.txt file.
+                val androidTxtFile = androidRootDir.resolve(currentApiTxtFile(apiVersion))
+
+                // Add to the list of api versions.
+                apiVersionsInfo.add(ApiVersionInfo(apiVersion, versionJar, androidTxtFile))
+            }
+
+            // Set up the input file structure.
+            for (apiVersionInfo in apiVersionsInfo) {
+                // Copy the android.jar created in the build.gradle.kts file.
+                androidJar.copyTo(apiVersionInfo.inputAndroidJarFile, overwrite = true)
+
+                // Create an android.txt file, if provided.
+                apiVersionInfo.inputAndroidTxtFile?.apply {
+                    parentFile.mkdirs()
+                    writeText(FileFormat.V2.header())
+                }
+
+                // Make sure the directory for the android.txt file exists.
+                androidRootDir.resolve(currentApiDir(apiVersionInfo.version)).mkdirs()
+            }
+
+            args += "android-jars-to-signatures"
+            args += androidRootDir
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            // Verify that all generated android.txt files have the correct content. They are
+            // currently all the same.
+            for (apiVersionInfo in apiVersionsInfo) {
+                verify {
+                    val apiVersion = apiVersionInfo.version
+                    val file = androidRootDir.resolve(currentApiTxtFile(apiVersion))
+                    file.assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package android.test {
+                              @Deprecated public class ClassAddedAndDeprecatedInApi30 {
+                                ctor @Deprecated public ClassAddedAndDeprecatedInApi30(float);
+                                ctor @Deprecated public ClassAddedAndDeprecatedInApi30(int);
+                                method @Deprecated public void methodExplicitlyDeprecated();
+                                method @Deprecated public void methodImplicitlyDeprecated();
+                                field @Deprecated public static final int FIELD_EXPLICITLY_DEPRECATED = 1; // 0x1
+                                field @Deprecated public static final int FIELD_IMPLICITLY_DEPRECATED = 2; // 0x2
+                              }
+                              public class ClassAddedInApi30 {
+                                method public void methodAddedInApi30();
+                              }
+                            }
+                            package java.lang {
+                              public class Object {
+                                ctor public Object();
+                              }
+                            }
+                        """,
+                        message = "incorrect output for $apiVersionInfo",
+                    )
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `Test simple jar`() {
+        val root = buildFileStructure {
+            dir("prebuilts/sdk/3/public") {
+                jar(
+                    "android.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {}
+                        """
+                    ),
+                )
+                dir("api") { emptyFile("android.txt") }
+            }
+        }
+
+        commandTest {
+            args += "android-jars-to-signatures"
+            args += root
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            verify {
+                root
+                    .resolve(currentApiTxtFile(3))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Foo {
+                                ctor public Foo();
+                              }
+                            }
+                        """
+                    )
+            }
+        }
+    }
+
+    @Test
+    fun `Test system extends`() {
+        val root = buildFileStructure {
+            dir("prebuilts/sdk/3/public") {
+                jar(
+                    "android.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Public {
+                                public void publicMethod() {}
+                            }
+                        """
+                    ),
+                )
+                dir("api") { emptyFile("android.txt") }
+            }
+            dir("prebuilts/sdk/3/system") {
+                jar(
+                    "android.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Public {
+                                public void publicMethod() {}
+                                public void systemMethod() {}
+                            }
+                        """
+                    ),
+                )
+                dir("api") { emptyFile("android.txt") }
+            }
+        }
+
+        commandTest {
+            args += "android-jars-to-signatures"
+            args += root
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            args += ARG_API_SURFACES
+            args += "public,system"
+
+            verify {
+                root
+                    .resolve(currentApiTxtFile(3))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Public {
+                                ctor public Public();
+                                method public void publicMethod();
+                              }
+                            }
+                        """
+                    )
+
+                root
+                    .resolve(currentApiTxtFile(3, "system"))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Public {
+                                method public void systemMethod();
+                              }
+                            }
+                        """
+                    )
+            }
+        }
+    }
+
+    @Test
+    fun `Test copy deprecated from existing signature file`() {
+        lateinit var jarFile: File
+        val root = buildFileStructure {
+            dir("prebuilts/sdk/3/public") {
+                jarFile =
+                    jar(
+                        "android.jar",
+                        java(
+                            """
+                                package test.pkg;
+                                public class Foo {}
+                            """
+                        ),
+                    )
+                dir("api") {
+                    signature(
+                        "android.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              @Deprecated public class Foo {
+                              }
+                            }
+                        """
+                    )
+                }
+            }
+            dir("prebuilts/sdk/3/system") {
+                // Use the same jar file as for public.
+                jarFile.copyTo(dir.resolve("android.jar"))
+
+                dir("api") { emptyFile("android.txt") }
+            }
+        }
+
+        commandTest {
+            args += "android-jars-to-signatures"
+            args += root
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            args += ARG_API_SURFACES
+            args += "public,system"
+
+            verify {
+                root
+                    .resolve(currentApiTxtFile(3))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              @Deprecated public class Foo {
+                                ctor @Deprecated public Foo();
+                              }
+                            }
+                        """
+                    )
+
+                root
+                    .resolve(currentApiTxtFile(3, "system"))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                        """
+                    )
+            }
+        }
+    }
+
+    @Test
+    fun `Test add-additional-overrides=yes`() {
+        val root = buildFileStructure {
+            dir("prebuilts/sdk/3/public") {
+                jar(
+                    "android.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public abstract class Bar<T> {
+                                public T method(T t) {return t;}
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo<T extends CharSequence> extends Bar<T> {
+                                public T method(T t) {return t;}
+                            }
+                        """
+                    ),
+                )
+                dir("api") { emptyFile("android.txt") }
+            }
+        }
+
+        commandTest {
+            args += "android-jars-to-signatures"
+            args += root
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            args += ARG_API_SURFACES
+            args += "public,system"
+
+            args += "--format-defaults"
+            args += "add-additional-overrides=yes"
+
+            verify {
+                root
+                    .resolve(currentApiTxtFile(3))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public abstract class Bar<T> {
+                                ctor public Bar();
+                                method public T method(T);
+                              }
+                              public class Foo<T extends java.lang.CharSequence> extends test.pkg.Bar<T> {
+                                ctor public Foo();
+                                method public T method(T);
+                              }
+                            }
+                        """
+                    )
+            }
+        }
+    }
+
+    @Test
+    fun `Test computing delta for annotations with attributes`() {
+        lateinit var jarFile: File
+        val root = buildFileStructure {
+            dir("prebuilts/sdk/3/public") {
+                jarFile =
+                    jar(
+                        "android.jar",
+                        java(
+                            """
+                                package test.pkg;
+                                public @interface Anno {
+                                    AnnoValue value();
+                                    enum AnnoValue {VALUE}
+                                }
+                            """
+                        ),
+                        java(
+                            """
+                                package test.pkg;
+                                @Anno(Anno.AnnoValue.VALUE)
+                                public class Foo {
+                                    private Foo() {}
+                                }
+                            """
+                        ),
+                    )
+                dir("api") { emptyFile("android.txt") }
+            }
+            dir("prebuilts/sdk/3/system") {
+                // Use the same jar file as for public.
+                jarFile.copyTo(dir.resolve("android.jar"))
+
+                dir("api") { emptyFile("android.txt") }
+            }
+        }
+
+        commandTest {
+            args += "android-jars-to-signatures"
+            args += root
+
+            args += ARG_CONFIG_FILE
+            args += KnownConfigFiles.configPublicAndSystemSurfaces
+
+            args += ARG_API_SURFACES
+            args += "public,system"
+
+            verify {
+                root
+                    .resolve(currentApiTxtFile(3))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Anno {
+                                method public abstract test.pkg.Anno.AnnoValue value();
+                              }
+                              public enum Anno.AnnoValue {
+                                enum_constant public static final test.pkg.Anno.AnnoValue VALUE;
+                              }
+                              @test.pkg.Anno(test.pkg.Anno.AnnoValue.VALUE) public class Foo {
+                              }
+                            }
+                        """
+                    )
+
+                root
+                    .resolve(currentApiTxtFile(3, "system"))
+                    .assertSignatureContents(
+                        """
+                            // Signature format: 2.0
+                        """
+                    )
+            }
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfoTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfoTest.kt
new file mode 100644
index 000000000..cfabba327
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/historical/HistoricalApiVersionInfoTest.kt
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.historical
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.KnownConfigFiles
+import com.android.tools.metalava.apiSurfacesFromConfig
+import com.android.tools.metalava.apilevels.ApiVersion
+import com.android.tools.metalava.apilevels.PatternNode
+import com.android.tools.metalava.config.ConfigParser
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.reporter.ThrowingReporter
+import com.android.tools.metalava.testing.TemporaryFolderOwner
+import java.io.File
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class HistoricalApiVersionInfoTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    private fun List<HistoricalApiVersionInfo>.dump() =
+        buildString {
+                for (versionInfo in this@dump) {
+                    append("HistoricalApiVersionInfo(\n")
+                    append("  version=").append(versionInfo.version).append(",\n")
+                    append("  infoBySurface={\n")
+                    for (surfaceInfo in versionInfo.infoBySurface.values) {
+                        append("    SurfaceInfo(\n")
+                        append("      jarFile=").append(surfaceInfo.jarFile).append(",\n")
+                        append("      signatureFile=")
+                            .append(surfaceInfo.signatureFile)
+                            .append(",\n")
+                        val extendsInfo = surfaceInfo.extends
+                        if (extendsInfo != null) {
+                            append("      extends=${extendsInfo.surface.name},\n")
+                        }
+                        append("    )\n")
+                    }
+                    append("  },\n")
+                    append(")\n")
+                }
+            }
+            .let { replaceFileWithSymbol(it) }
+
+    private fun buildApiSurfacesFromConfig(configFile: TestFile): ApiSurfaces {
+        val config = ConfigParser.parse(listOf(configFile.createFile(temporaryFolder.newFolder())))
+        val surfaceConfigs =
+            config.apiSurfaces ?: error("No <api-surface/>s specified in config file")
+        return apiSurfacesFromConfig(surfaceConfigs.apiSurfaceList, "public")
+    }
+
+    private fun scanForHistoricalApiVersionInfo(root: File): List<HistoricalApiVersionInfo> {
+        val apiSurfaces = buildApiSurfacesFromConfig(KnownConfigFiles.configPublicAndSystemSurfaces)
+        val scanConfig =
+            PatternNode.ScanConfig(
+                dir = root,
+                apiSurfaceByName = apiSurfaces.byName,
+            )
+
+        val list =
+            HistoricalApiVersionInfo.scan(
+                ThrowingReporter.INSTANCE,
+                jarFilePattern = "{version:major.minor?}/{surface}/api.jar",
+                signatureFilePattern = "{version:major.minor?}/{surface}/api/api.txt",
+                scanConfig
+            )
+        return list
+    }
+
+    @Test
+    fun `Test simple`() {
+        val root = buildFileStructure {
+            // Create the version directories in non-version order to verify that the list returned
+            // by scanning will be sorted by version.
+            dir("2") {
+                dir("public") {
+                    emptyFile("api.jar")
+                    dir("api") { emptyFile("api.txt") }
+                }
+                dir("system") {
+                    emptyFile("api.jar")
+                    dir("api") { emptyFile("api.txt") }
+                }
+            }
+            dir("1") {
+                dir("public") {
+                    emptyFile("api.jar")
+                    dir("api") { emptyFile("api.txt") }
+                }
+            }
+        }
+
+        val list = scanForHistoricalApiVersionInfo(root)
+        assertEquals(
+            """
+                HistoricalApiVersionInfo(
+                  version=1,
+                  infoBySurface={
+                    SurfaceInfo(
+                      jarFile=TESTROOT/1/public/api.jar,
+                      signatureFile=TESTROOT/1/public/api/api.txt,
+                    )
+                  },
+                )
+                HistoricalApiVersionInfo(
+                  version=2,
+                  infoBySurface={
+                    SurfaceInfo(
+                      jarFile=TESTROOT/2/public/api.jar,
+                      signatureFile=TESTROOT/2/public/api/api.txt,
+                    )
+                    SurfaceInfo(
+                      jarFile=TESTROOT/2/system/api.jar,
+                      signatureFile=TESTROOT/2/system/api/api.txt,
+                      extends=public,
+                    )
+                  },
+                )
+            """
+                .trimIndent(),
+            list.dump()
+        )
+
+        val last = list.last()
+        assertEquals(ApiVersion.fromLevel(2), last.version, "last version")
+        val contributingFiles = buildString {
+            for (surfaceInfo in last.infoBySurface.values) {
+                append(surfaceInfo.surface.name)
+                append("\n")
+                for (file in surfaceInfo.contributingSignatureFiles()) {
+                    append("  ")
+                    append(file)
+                    append("\n")
+                }
+            }
+        }
+
+        val expected =
+            """
+                public
+                  SignatureFileFromFile(file=TESTROOT/2/public/api/api.txt, forMainApiSurface=true, apiVariantType=CORE)
+                system
+                  SignatureFileFromFile(file=TESTROOT/2/public/api/api.txt, forMainApiSurface=true, apiVariantType=CORE)
+                  SignatureFileFromFile(file=TESTROOT/2/system/api/api.txt, forMainApiSurface=true, apiVariantType=CORE)
+            """
+                .trimIndent()
+        assertEquals(expected, replaceFileWithSymbol(contributingFiles), "contributing files")
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommandTest.kt
index a73a0a94c..e5911206e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/internal/MakeAnnotationsPackagePrivateCommandTest.kt
@@ -70,8 +70,8 @@ Arguments:
                     source.path,
                 )
 
-            val target = newFolder("private-annotations")
-            args += target.path
+            val target = getOrCreateFolder("private-annotations")
+            args += target
 
             verify {
                 // Source retention explicitly listed: Shouldn't exist
@@ -146,10 +146,10 @@ Arguments:
 
         commandTest {
             // Copy the stub-annotations sources and add a new file.
-            val source = newFolder("annotations-copy")
+            val source = getOrCreateFolder("annotations-copy")
             stubAnnotationsDir.copyRecursively(source)
             assertTrue(source.path, source.isDirectory)
-            inputFile("android/annotation/Unknown.java", fooSource, source)
+            unindentedInputFile("android/annotation/Unknown.java", fooSource, source)
 
             args +=
                 listOf(
@@ -157,8 +157,7 @@ Arguments:
                     source.path,
                 )
 
-            val target = newFolder("private-annotations")
-            args += target.path
+            args += getOrCreateFolder("private-annotations")
 
             expectedStderr =
                 "Aborting: TESTROOT/annotations-copy/android/annotation/Unknown.java: Found annotation with unknown desired retention: android.annotation.Unknown"
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/lint/ApiLintOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/lint/ApiLintOptionsTest.kt
index a1cabb872..0c00e365f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/lint/ApiLintOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/lint/ApiLintOptionsTest.kt
@@ -38,6 +38,8 @@ Api Lint:
 
                                              API Lint issues found in the previously released API will be ignored.
   --error-message:api-lint <message>         If set, this is output when errors are detected in --api-lint.
+  --api-lint-allowed-acronym <acronym>       An acronym that should be allowed by API lint. Can be specified multiple
+                                             times.
   --baseline:api-lint <file>                 An optional baseline file that contains a list of known API lint issues
                                              which should be ignored. If this does not exist and
                                              --update-baseline:api-lint is not specified then it will be created and
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
index 54534a1d9..06a9192f0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
@@ -35,17 +35,16 @@ class MergeSignaturesCommandTest :
         commandTest {
             args += "merge-signatures"
             files.forEachIndexed { i, contents ->
-                val input =
+                args +=
                     inputFile(
                         "api${i + 1}.txt",
-                        prepareSignatureFileForTest(contents.trimIndent(), FileFormat.V2)
+                        prepareSignatureFileForTest(contents, FileFormat.V2)
                     )
-                args += input.path
             }
 
             val output = outputFile("out.txt")
             args += "--out"
-            args += output.path
+            args += output
 
             args += "--format"
             args += format.specifier()
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureCatCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureCatCommandTest.kt
new file mode 100644
index 000000000..94cf1de10
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureCatCommandTest.kt
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.signature
+
+import com.android.tools.metalava.cli.common.BaseCommandTest
+import com.android.tools.metalava.model.text.assertSignatureContents
+import org.junit.Test
+
+private val signatureCatHelp =
+    """
+Usage: metalava signature-cat [options] [<files>]...
+
+  Cats signature files.
+
+  Reads signature files either provided on the command line, or in stdin into a combined API surface and then writes it
+  out to either the output file provided on the command line or to stdout according to the format options. The resulting
+  output will be different to the input if the input does not already conform to the selected format.
+
+Options:
+  --output-file <file>                       File to write the signature output to. If not specified stdout will be
+                                             used.
+  -h, -?, --help                             Show this message and exit
+
+$SIGNATURE_FORMAT_OPTIONS_HELP
+
+Arguments:
+  <files>                                    Signature files to read, if not specified then they stdin is read instead.
+    """
+        .trimIndent()
+
+class SignatureCatCommandTest : BaseCommandTest<SignatureCatCommand>({ SignatureCatCommand() }) {
+
+    @Test
+    fun `Test help`() {
+        commandTest {
+            args += listOf("signature-cat", "--help")
+
+            expectedStdout = signatureCatHelp
+        }
+    }
+
+    @Test
+    fun `Cat from stdin to stdout`() {
+        commandTest {
+            args +=
+                listOf(
+                    "signature-cat",
+                    "--format",
+                    "2.0",
+                    "--format-defaults",
+                    // Strip java.lang. prefixes just to show that it does transform the input.
+                    "strip-java-lang-prefix=always",
+                )
+
+            stdin =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Foo extends java.lang.Comparable<test.pkg.Foo> {
+                      }
+                    }
+                """
+                    .trimIndent()
+
+            expectedStdout =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+
+                      public interface Foo extends Comparable<test.pkg.Foo> {
+                      }
+
+                    }
+                """
+                    .trimIndent()
+        }
+    }
+
+    @Test
+    fun `Cat from files to stdout`() {
+        commandTest {
+            args +=
+                listOf(
+                    "signature-cat",
+                    unindentedInputFile(
+                        "foo.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public interface Foo {
+                              }
+                            }
+                        """
+                    ),
+                    unindentedInputFile(
+                        "bar.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public interface Bar {
+                              }
+                            }
+                        """
+                    ),
+                )
+
+            // Stdin should be ignored when files are provided on the command line.
+            stdin = "Stdin should be ignored when files are provided on the command line."
+
+            expectedStdout =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+
+                      public interface Bar {
+                      }
+
+                      public interface Foo {
+                      }
+
+                    }
+                """
+                    .trimIndent()
+        }
+    }
+
+    @Test
+    fun `Cat signature file with missing type parameters`() {
+        commandTest {
+            args +=
+                listOf(
+                    "signature-cat",
+                    "--format-defaults",
+                    // Do not strip java.lang. prefixes to show whether unknown type parameters are
+                    // currently prefixed with "java.lang." or not.
+                    "strip-java-lang-prefix=never",
+                )
+
+            stdin =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Foo {
+                        method public void foo(T t);
+                      }
+                    }
+                """
+                    .trimIndent()
+
+            expectedStderr =
+                """
+                    <stdin>:4: hidden: Unqualified type 'T' is not in 'java.lang' and is not a type parameter in scope [UnqualifiedTypeError]
+                """
+                    .trimIndent()
+
+            expectedStdout =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+
+                      public interface Foo {
+                        method public void foo(T t);
+                      }
+
+                    }
+                """
+                    .trimIndent()
+        }
+    }
+
+    @Test
+    fun `Cat from file to file`() {
+        val signature =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo {
+                  }
+                }
+            """
+
+        commandTest {
+            val outputFile = outputFile("cat.txt")
+            args +=
+                listOf(
+                    "signature-cat",
+                    unindentedInputFile("current.txt", signature),
+                    "--output-file",
+                    outputFile,
+                )
+
+            verify { outputFile.assertSignatureContents(signature) }
+        }
+    }
+
+    @Test
+    fun `Cat from empty file to file`() {
+        val signature = "// Signature format: 2.0"
+
+        commandTest {
+            val outputFile = outputFile("cat.txt")
+            args +=
+                listOf(
+                    "signature-cat",
+                    unindentedInputFile("current.txt", signature),
+                    "--output-file",
+                    outputFile,
+                )
+
+            verify { outputFile.assertSignatureContents(signature) }
+        }
+    }
+
+    @Test
+    fun `Cat merge surfaces`() {
+        val surface1 =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo {
+                    method public void betaMethod();
+                    property public int betaProperty;
+                    field public static final int betaField;
+                  }
+                }
+            """
+
+        val surface2 =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public interface Foo {
+                    method public void alphaMethod();
+                    property public int alphaProperty;
+                    field public static final int alphaField;
+                  }
+                }
+            """
+
+        commandTest {
+            val outputFile = outputFile("cat.txt")
+            args +=
+                listOf(
+                    "signature-cat",
+                    unindentedInputFile("surface1.txt", surface1),
+                    unindentedInputFile("surface2.txt", surface2),
+                    "--output-file",
+                    outputFile,
+                )
+
+            verify {
+                outputFile.assertSignatureContents(
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public interface Foo {
+                            method public void alphaMethod();
+                            method public void betaMethod();
+                            property public int alphaProperty;
+                            property public int betaProperty;
+                            field public static final int alphaField;
+                            field public static final int betaField;
+                          }
+                        }
+                    """
+                )
+            }
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
index d7d305f1a..f51d2b9dd 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
@@ -39,12 +39,13 @@ Signature Format Output:
 
                                              A comma separated list of `<property>=<value>` assignments where
                                              `<property>` is one of the following: 'add-additional-overrides',
-                                             'overloaded-method-order', 'sort-whole-extends-list',
-                                             'strip-java-lang-prefix'.
+                                             'normalize-final-modifier', 'overloaded-method-order',
+                                             'sort-whole-extends-list', 'strip-java-lang-prefix',
+                                             'type-argument-spacing'.
 
                                              See `metalava help signature-file-formats` for more information on the
                                              properties.
-  --format [v2|v3|v4|latest|recommended|<specifier>]
+  --format [v2|v4|latest|recommended|<specifier>]
                                              Specifies the output signature file format.
 
                                              The preferred way of specifying the format is to use one of the following
@@ -69,13 +70,11 @@ Signature Format Output:
 
                                              v2 - The main version used in Android.
 
-                                             v3 - Adds support for using kotlin style syntax to embed nullability
+                                             v4 - Adds support for using kotlin style syntax to embed nullability
                                              information instead of using explicit and verbose @NonNull and @Nullable
-                                             annotations. This can be used for Java files and Kotlin files alike.
-
-                                             v4 - Adds support for using concise default values in parameters. Instead
-                                             of specifying the actual default values it just uses the `default` keyword.
-                                             (default: recommended)
+                                             annotations. This can be used for Java files and Kotlin files alike. Also,
+                                             adds support for recording that a parameter has a default value by using
+                                             the pseudo-modifier `optional`. (default: recommended)
   --use-same-format-as <file>                Specifies that the output format should be the same as the format used in
                                              the specified file. It is an error if the file does not exist. If the file
                                              is empty then this will behave as if it was not specified. If the file is
@@ -105,16 +104,16 @@ class SignatureFormatOptionsTest :
         runTest("--format=v1") {
             assertThat(stderr)
                 .startsWith(
-                    """Invalid value for "--format": invalid version, found 'v1', expected one of '2.0', '3.0', '4.0', '5.0', 'v2', 'v3', 'v4', 'latest', 'recommended'"""
+                    """Invalid value for "--format": invalid version, found 'v1', expected one of '2.0', '4.0', '5.0', 'v2', 'v4', 'latest', 'recommended'"""
                 )
         }
     }
 
     @Test
     fun `--use-same-format-as reads from a valid file and ignores --format`() {
-        val path = source("api.txt", "// Signature format: 3.0\n").createFile(temporaryFolder.root)
+        val path = source("api.txt", "// Signature format: 4.0\n").createFile(temporaryFolder.root)
         runTest("--use-same-format-as", path.path, "--format", "v4") {
-            assertThat(options.fileFormat).isEqualTo(FileFormat.V3)
+            assertThat(options.fileFormat).isEqualTo(FileFormat.V4)
         }
     }
 
@@ -221,13 +220,13 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with all the supported properties`() {
         runTest(
             "--format",
-            "2.0:kotlin-style-nulls=yes,concise-default-values=yes,overloaded-method-order=source",
+            "2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes,overloaded-method-order=source",
         ) {
             assertEquals(
                 FileFormat.V2.copy(
                     specifiedOverloadedMethodOrder = FileFormat.OverloadedMethodOrder.SOURCE,
                     kotlinStyleNulls = true,
-                    conciseDefaultValues = true,
+                    includeDefaultParameterValues = true,
                 ),
                 options.fileFormat
             )
@@ -270,10 +269,10 @@ class SignatureFormatOptionsTest :
     }
 
     @Test
-    fun `--format specifier unknown value (concise-default-values)`() {
-        runTest("--format", "2.0:concise-default-values=barf") {
+    fun `--format specifier unknown value (include-default-parameter-values)`() {
+        runTest("--format", "2.0:include-default-parameter-values=barf") {
             assertEquals(
-                """Invalid value for "--format": unexpected value for concise-default-values, found 'barf', expected one of 'yes' or 'no'""",
+                """Invalid value for "--format": unexpected value for include-default-parameter-values, found 'barf', expected one of 'yes' or 'no'""",
                 stderr
             )
         }
@@ -303,11 +302,11 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v2 some properties, excluding 'migrating' when migratingAllowed=true`() {
         runTest(
             "--format",
-            "2.0:kotlin-style-nulls=yes,concise-default-values=yes",
+            "2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes",
             optionGroup = SignatureFormatOptions(migratingAllowed = true),
         ) {
             assertEquals(
-                """Invalid value for "--format": invalid format specifier: '2.0:kotlin-style-nulls=yes,concise-default-values=yes' - must provide a 'migrating' property when customizing version 2.0""",
+                """Invalid value for "--format": invalid format specifier: '2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes' - must provide a 'migrating' property when customizing version 2.0""",
                 stderr
             )
         }
@@ -317,13 +316,13 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v2 some properties, including 'migrating' when migratingAllowed=true`() {
         runTest(
             "--format",
-            "2.0:kotlin-style-nulls=yes,concise-default-values=yes,migrating=See b/295577788",
+            "2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes,migrating=See b/295577788",
             optionGroup = SignatureFormatOptions(migratingAllowed = true),
         ) {
             assertEquals(
                 FileFormat.V2.copy(
                     kotlinStyleNulls = true,
-                    conciseDefaultValues = true,
+                    includeDefaultParameterValues = true,
                     migrating = "See b/295577788"
                 ),
                 options.fileFormat
@@ -335,11 +334,11 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v2 some properties, including 'migrating' when migratingAllowed=false`() {
         runTest(
             "--format",
-            "2.0:kotlin-style-nulls=yes,concise-default-values=yes,migrating=See b/295577788",
+            "2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes,migrating=See b/295577788",
             optionGroup = SignatureFormatOptions(migratingAllowed = false),
         ) {
             assertEquals(
-                """Invalid value for "--format": invalid format specifier: '2.0:kotlin-style-nulls=yes,concise-default-values=yes,migrating=See b/295577788' - must not contain a 'migrating' property""",
+                """Invalid value for "--format": invalid format specifier: '2.0:kotlin-style-nulls=yes,include-default-parameter-values=yes,migrating=See b/295577788' - must not contain a 'migrating' property""",
                 stderr
             )
         }
@@ -349,13 +348,13 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v5, some properties, excluding 'migrating' when migratingAllowed=true`() {
         runTest(
             "--format",
-            "5.0:kotlin-style-nulls=no,concise-default-values=no",
+            "5.0:kotlin-style-nulls=no,include-default-parameter-values=no",
             optionGroup = SignatureFormatOptions(migratingAllowed = true),
         ) {
             assertEquals(
                 FileFormat.V5.copy(
                     kotlinStyleNulls = false,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                 ),
                 options.fileFormat
             )
@@ -366,13 +365,13 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v5, some properties, including 'migrating' when migratingAllowed=true`() {
         runTest(
             "--format",
-            "5.0:kotlin-style-nulls=no,concise-default-values=no,migrating=See b/295577788",
+            "5.0:kotlin-style-nulls=no,include-default-parameter-values=no,migrating=See b/295577788",
             optionGroup = SignatureFormatOptions(migratingAllowed = true),
         ) {
             assertEquals(
                 FileFormat.V5.copy(
                     kotlinStyleNulls = false,
-                    conciseDefaultValues = false,
+                    includeDefaultParameterValues = false,
                     migrating = "See b/295577788",
                 ),
                 options.fileFormat
@@ -384,11 +383,11 @@ class SignatureFormatOptionsTest :
     fun `--format specifier with v5, some properties, including 'migrating' when migratingAllowed=false`() {
         runTest(
             "--format",
-            "5.0:kotlin-style-nulls=no,concise-default-values=no,migrating=See b/295577788",
+            "5.0:kotlin-style-nulls=no,include-default-parameter-values=no,migrating=See b/295577788",
             optionGroup = SignatureFormatOptions(migratingAllowed = false),
         ) {
             assertEquals(
-                """Invalid value for "--format": invalid format specifier: '5.0:kotlin-style-nulls=no,concise-default-values=no,migrating=See b/295577788' - must not contain a 'migrating' property""",
+                """Invalid value for "--format": invalid format specifier: '5.0:kotlin-style-nulls=no,include-default-parameter-values=no,migrating=See b/295577788' - must not contain a 'migrating' property""",
                 stderr
             )
         }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
index 98f82c521..e72d3dbe6 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
@@ -52,13 +52,12 @@ class SignatureToDexCommandTest :
             args += listOf("signature-to-dex")
 
             for ((index, signature) in signatures.withIndex()) {
-                val apiFile = inputFile("api$index.txt", signature.trimIndent())
-                args += apiFile.path
+                args += unindentedInputFile("api$index.txt", signature)
             }
 
             val outFile = outputFile("out.dex")
             args += ARG_OUT
-            args += outFile.path
+            args += outFile
 
             verify { assertEquals(expectedDex.trimIndent(), outFile.readText().trim()) }
         }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
index a207d1704..8c21982ef 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
@@ -75,8 +75,8 @@ open class SignatureToJDiffCommandTest :
         commandTest {
             args += listOf("signature-to-jdiff", "--trip")
 
-            args += inputFile("input.txt", "").path
-            args += outputFile("output.xml").path
+            args += inputFile("input.txt", "")
+            args += outputFile("output.xml")
 
             expectedStderr =
                 """
@@ -617,7 +617,7 @@ $signatureToJdiffHelp
             api =
                 """
                     package test.pkg {
-                      public class Test extends Number implements Comparable<Test> {
+                      public class Test extends Number implements Comparable<test.pkg.Test> {
                         field public static final int FIELD = 1;
                       }
                     }
@@ -636,7 +636,7 @@ $signatureToJdiffHelp
                      deprecated="not deprecated"
                      visibility="public"
                     >
-                    <implements name="java.lang.Comparable&lt;java.lang.Test>">
+                    <implements name="java.lang.Comparable&lt;test.pkg.Test>">
                     </implements>
                     <field name="FIELD"
                      type="int"
@@ -663,7 +663,7 @@ $signatureToJdiffHelp
                 """
                     // Signature format: 2.0
                     package test.pkg {
-                      public class Test extends Number implements Comparable<Test> {
+                      public class Test extends Number implements Comparable<test.pkg.Test> {
                         field public static final int FIELD = 1;
                       }
                     }
@@ -673,7 +673,7 @@ $signatureToJdiffHelp
                 """
                     // Signature format: 2.0
                     package test.pkg {
-                      public class Test extends Number implements Comparable<Test> {
+                      public class Test extends Number implements Comparable<test.pkg.Test> {
                       }
                     }
                 """
@@ -691,7 +691,7 @@ $signatureToJdiffHelp
                      deprecated="not deprecated"
                      visibility="public"
                     >
-                    <implements name="java.lang.Comparable&lt;java.lang.Test>">
+                    <implements name="java.lang.Comparable&lt;test.pkg.Test>">
                     </implements>
                     <field name="FIELD"
                      type="int"
@@ -824,6 +824,55 @@ $signatureToJdiffHelp
                 """
         }
     }
+
+    @Test
+    fun `Test conversion unknown type parameter`() {
+        jdiffConversionTest {
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Test {
+                        method public T method();
+                      }
+                    }
+                """
+
+            expectedStderr =
+                """
+                    TESTROOT/jdiff-conversion/api.txt:4: hidden: Unqualified type 'T' is not in 'java.lang' and is not a type parameter in scope [UnqualifiedTypeError]
+                """
+                    .trimIndent()
+
+            expectedXml =
+                """
+                    <api name="api" xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <interface name="Test"
+                     abstract="true"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <method name="method"
+                     return="T"
+                     abstract="true"
+                     native="false"
+                     synchronized="false"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    </method>
+                    </interface>
+                    </package>
+                    </api>
+                """
+        }
+    }
 }
 
 fun BaseCommandTest<SignatureToJDiffCommand>.jdiffConversionTest(body: JDiffTestConfig.() -> Unit) {
@@ -864,17 +913,15 @@ class JDiffTestConfig(val commandTestConfig: CommandTestConfig<SignatureToJDiffC
             // Create a unique folder to allow multiple configs to be run in the same test.
             val folder = commandTestConfig.folder("jdiff-conversion")
 
-            val apiFile = inputFile("api.txt", api.trimIndent(), parentDir = folder)
-            args += apiFile.path
+            args += unindentedInputFile("api.txt", api, parentDir = folder)
 
             baseApi?.let {
-                val baseApiFile = inputFile("base-api.txt", it.trimIndent(), parentDir = folder)
                 args += "--base-api"
-                args += baseApiFile.path
+                args += unindentedInputFile("base-api.txt", it, parentDir = folder)
             }
 
             val xmlFile = outputFile("api.xml", parentDir = folder)
-            args += xmlFile.path
+            args += xmlFile
 
             verify {
                 val expectedXml = this@JDiffTestConfig.expectedXml
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
index 36e7912dc..3e53a129a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
@@ -37,13 +37,14 @@ class UpdateSignatureHeaderCommandTest :
             args += "--format"
             args += format.specifier()
 
-            val input = inputFile("api.txt", contents.trimIndent())
-            args += input.path
+            val trimmedContents = contents.trimIndent()
+            val input = inputFile("api.txt", trimmedContents)
+            args += input
 
             if (expectedOutput == null) {
                 verify {
                     // Make sure that the input file has not changed.
-                    assertEquals(contents.trimIndent(), input.readText())
+                    assertEquals(trimmedContents, input.readText())
                 }
             } else {
                 verify {
@@ -128,7 +129,7 @@ Arguments:
     }
 
     @Test
-    fun `Update signature (v2 to v3)`() {
+    fun `Update signature (v2 to v4)`() {
         checkUpdateSignatures(
             contents =
                 """
@@ -136,10 +137,10 @@ Arguments:
                     package test.pkg {
                     }
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             expectedOutput =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                     }
                 """,
@@ -152,7 +153,7 @@ Arguments:
             contents = """
                     Wrong file
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             expectedStderr =
                 "Could not update header for TESTROOT/api.txt: TESTROOT/api.txt:1: Signature format error - invalid prefix, found 'Wrong file', expected '// Signature format: '",
         )
@@ -199,7 +200,7 @@ Arguments:
     }
 
     @Test
-    fun `Update signature (v2 to v3 + kotlin-style-nulls=false,migrating=test)`() {
+    fun `Update signature (v2 to v4 + kotlin-style-nulls=false,migrating=test)`() {
         checkUpdateSignatures(
             contents =
                 """
@@ -207,10 +208,10 @@ Arguments:
                     package pkg {
                     }
                 """,
-            format = FileFormat.V3.copy(kotlinStyleNulls = false, migrating = "test"),
+            format = FileFormat.V4.copy(kotlinStyleNulls = false, migrating = "test"),
             expectedOutput =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     // - kotlin-style-nulls=no
                     // - migrating=test
                     package pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
index 3d0841d6f..c289821c1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
@@ -144,11 +144,11 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     18,
                     """
-                        load-api.txt:6911: error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
-                        load-api.txt:29748: error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
-                        released-api.txt:16415: error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
-                        released-api.txt:19682: error: Removed class android.renderscript.Program [RemovedClass]
-                        released-api.txt:19764: error: Removed class android.renderscript.ProgramStore [RemovedClass]
+                        load-api.txt:6910: error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
+                        load-api.txt:29746: error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
+                        released-api.txt:16414: error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
+                        released-api.txt:19681: error: Removed class android.renderscript.Program [RemovedClass]
+                        released-api.txt:19763: error: Removed class android.renderscript.ProgramStore [RemovedClass]
                     """,
                     hide(
                         "AddedClass",
@@ -167,19 +167,19 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     19,
                     """
-                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
-                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
-                        load-api.txt:29413: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29413: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
-                        load-api.txt:29414: warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29414: warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
-                        load-api.txt:37262: warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
-                        released-api.txt:16987: error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
-                        released-api.txt:16988: error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
-                        released-api.txt:16989: error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
-                        released-api.txt:16990: error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
+                        load-api.txt:29409: warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29409: warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
+                        load-api.txt:29410: warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29410: warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
+                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
+                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
+                        load-api.txt:37259: warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
+                        released-api.txt:16986: error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
+                        released-api.txt:16987: error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
+                        released-api.txt:16988: error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
+                        released-api.txt:16989: error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
                     """,
                     // The last warning above is not right; seems to be a PSI jar loading bug. It
                     // returns the wrong return type!
@@ -196,9 +196,9 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     20,
                     """
-                        load-api.txt:51013: warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
-                        load-api.txt:52005: warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
-                        released-api.txt:26150: error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
+                        load-api.txt:51010: warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
+                        load-api.txt:52002: warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
+                        released-api.txt:26148: error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
                     """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -212,7 +212,7 @@ abstract class CompatibilityCheckAndroidApisTest(
                     26,
                     """
                         load-api.txt:3941: warning: Field android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE has changed value from 130 to 230 [ChangedValue]
-                        load-api.txt:10849: warning: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
+                        load-api.txt:10848: warning: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
                     """,
                     hide(
                         "AddedAbstractMethod",
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
index 75cfa2e7d..5ab5badd3 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
@@ -35,7 +35,6 @@ import com.android.tools.metalava.restrictToSource
 import com.android.tools.metalava.suppressLintSource
 import com.android.tools.metalava.systemApiSource
 import com.android.tools.metalava.testApiSource
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -160,7 +159,7 @@ class CompatibilityCheckTest : DriverTest() {
             format = FileFormat.V2,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class TestKt {
                     ctor public TestKt();
@@ -170,7 +169,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             signatureSource =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class TestKt {
                     ctor public TestKt();
@@ -866,14 +865,14 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class Foo {
-                    ctor public Foo(String? s1 = null);
+                    ctor public Foo(optional String? s1);
                     method public final void method1(boolean b, String? s1);
                     method public final void method2(boolean b, String? s1);
-                    method public final void method3(boolean b, String? s1 = "null");
-                    method public final void method4(boolean b, String? s1 = "null");
+                    method public final void method3(boolean b, optional String? s1);
+                    method public final void method4(boolean b, optional String? s1);
                   }
                 }
                 """,
@@ -907,7 +906,7 @@ class CompatibilityCheckTest : DriverTest() {
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class Foo {
                     ctor public Foo(optional String? s1);
@@ -1048,8 +1047,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     suppressLintSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
         )
     }
@@ -1065,7 +1062,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public @interface ExportedProperty {
                     method public abstract boolean resolveId() default false;
@@ -1790,11 +1787,11 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Test Kotlin extensions`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             expectedIssues = "",
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.content {
                   public final class ContentValuesKt {
                     method public static android.content.ContentValues contentValuesOf(kotlin.Pair<String,Object?>... pairs);
@@ -1840,11 +1837,11 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Test Kotlin type bounds`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             expectedIssues = "",
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.navigation {
                   public final class NavDestination {
                     ctor public NavDestination();
@@ -2029,8 +2026,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -2077,8 +2072,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -2136,8 +2129,6 @@ class CompatibilityCheckTest : DriverTest() {
                         )
                         .indented(),
                     testApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -2314,7 +2305,9 @@ class CompatibilityCheckTest : DriverTest() {
                   }
                 }
                 """,
-            sourceFiles = arrayOf(restrictToSource)
+            sourceFiles = arrayOf(restrictToSource),
+            // Override default to emit androidx.annotation classes.
+            skipEmitPackages = emptyList(),
         )
     }
 
@@ -2379,7 +2372,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.collection {
                   public class MyMap<Key, Value> {
                     ctor public MyMap();
@@ -2442,7 +2435,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public final class TestKt {
                     method public static inline <T> void add(T t);
@@ -2507,8 +2500,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -2564,8 +2555,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -2817,8 +2806,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -2906,8 +2893,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -3179,7 +3164,7 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues = "",
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package com.android.location.provider {
                   public class LocationProviderBase1 {
                     ctor public LocationProviderBase1();
@@ -3242,7 +3227,7 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues = "",
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.coordinatorlayout.widget {
                   public class CoordinatorLayout {
                     ctor public CoordinatorLayout();
@@ -3269,8 +3254,6 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     ),
                     androidxNonNullSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
         )
     }
@@ -3285,7 +3268,7 @@ class CompatibilityCheckTest : DriverTest() {
             """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg.sample {
                   public abstract class SampleClass {
                     method public <Number> Number! convert(Number);
@@ -3295,7 +3278,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             signatureSource =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg.sample {
                   public abstract class SampleClass {
                     // Here the generic type parameter applies to both the function argument and the function return type
@@ -3316,7 +3299,7 @@ class CompatibilityCheckTest : DriverTest() {
             """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.versionedparcelable {
                   public abstract class VersionedParcel {
                     method public <T> T![]! readArray();
@@ -3345,7 +3328,7 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Check using parameterized arrays as type parameters`() {
         check(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -3364,7 +3347,7 @@ class CompatibilityCheckTest : DriverTest() {
                 ),
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public class SampleArray<D extends java.util.ArrayList> extends java.util.ArrayList<D[]> {
                     ctor public SampleArray();
@@ -3385,7 +3368,7 @@ class CompatibilityCheckTest : DriverTest() {
             """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package androidx.room {
                   public @interface Relation {
                   }
@@ -3555,7 +3538,7 @@ class CompatibilityCheckTest : DriverTest() {
             """,
             checkCompatibilityApiReleased =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public interface JavaInterface {
                   }
@@ -3882,7 +3865,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """
                 package test.pkg {
                   public interface Foo {
-                    method abstract public void bar(Int);
+                    method abstract public void bar(int);
                   }
                 }
             """,
@@ -3890,7 +3873,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """
                 package test.pkg {
                   public interface Foo {
-                    method default public void bar(Int);
+                    method default public void bar(int);
                     }
                   }
               """
@@ -3904,7 +3887,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """
                 package test.pkg {
                   sealed class Foo {
-                    method final public void bar(Int);
+                    method final public void bar(int);
                   }
                 }
             """,
@@ -3913,7 +3896,7 @@ class CompatibilityCheckTest : DriverTest() {
                 """
                 package test.pkg {
                   sealed class Foo {
-                    method public void bar(Int);
+                    method public void bar(int);
                   }
                 }
             """
@@ -4201,19 +4184,19 @@ class CompatibilityCheckTest : DriverTest() {
                 package test.pkg {
                   public class MyCollection<E> implements java.util.Collection<E> {
                     ctor public MyCollection();
-                    method public boolean add(E! e);
-                    method public boolean addAll(java.util.Collection<? extends E> c);
+                    method public boolean add(E!);
+                    method public boolean addAll(java.util.Collection<? extends E>);
                     method public void clear();
-                    method public boolean contains(Object! o);
-                    method public boolean containsAll(java.util.Collection<?> c);
+                    method public boolean contains(Object!);
+                    method public boolean containsAll(java.util.Collection<?>);
                     method public boolean isEmpty();
                     method public java.util.Iterator<E> iterator();
-                    method public boolean remove(Object! o);
-                    method public boolean removeAll(java.util.Collection<?> c);
-                    method public boolean retainAll(java.util.Collection<?> c);
+                    method public boolean remove(Object!);
+                    method public boolean removeAll(java.util.Collection<?>);
+                    method public boolean retainAll(java.util.Collection<?>);
                     method public int size();
                     method public Object![] toArray();
-                    method public <T> T![] toArray(T[] a);
+                    method public <T> T![] toArray(T[]);
                   }
                 }
             """,
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
index 1db2cf40b..350e1dc52 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
@@ -36,29 +36,29 @@ class NullnessCompatibilityTest : DriverTest() {
                     load-api.txt:5: error: Attempted to remove nullability from java.lang.String (was NONNULL) in parameter str in test.pkg.Foo.method1(int p, Integer int2, int p1, String str, java.lang.String... args) [InvalidNullConversion]
                     load-api.txt:7: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str in test.pkg.Foo.method3(String str, int p, int int2) [InvalidNullConversion]
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             checkCompatibilityApiReleased =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public final class Foo {
                         ctor public Foo();
-                        method public void method1(int p = 42, Integer? int2 = null, int p1 = 42, String str = "hello world", java.lang.String... args);
-                        method public void method2(int p, int int2 = (2 * int) * some.other.pkg.Constants.Misc.SIZE);
-                        method public void method3(String? str, int p, int int2 = double(int) + str.length);
+                        method public void method1(optional int p, optional Integer? int2, optional int p1, optional String str, java.lang.String... args);
+                        method public void method2(int p, optional int int2);
+                        method public void method3(String? str, int p, optional int int2);
                         field public static final test.pkg.Foo.Companion! Companion;
                       }
                     }
                 """,
             signatureSource =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public final class Foo {
                         ctor public Foo();
-                        method public void method1(int p = 42, Integer? int2 = null, int p1 = 42, String! str = "hello world", java.lang.String... args);
-                        method public void method2(int p, int int2 = (2 * int) * some.other.pkg.Constants.Misc.SIZE);
-                        method public void method3(String str, int p, int int2 = double(int) + str.length);
+                        method public void method1(optional int p, optional Integer? int2, optional int p1, optional String! str, java.lang.String... args);
+                        method public void method2(int p, optional int int2);
+                        method public void method3(String str, int p, optional int int2);
                         field public static final test.pkg.Foo.Companion! Companion;
                       }
                     }
@@ -74,10 +74,10 @@ class NullnessCompatibilityTest : DriverTest() {
                 """
                     src/test/pkg/test.kt:2: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str1 in test.pkg.TestKt.fun1(String str1, String str2, java.util.List<java.lang.String> list) [InvalidNullConversion]
                 """,
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             checkCompatibilityApiReleased =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public final class TestKt {
                         method public static void fun1(String? str1, String str2, java.util.List<java.lang.String!> list);
@@ -158,10 +158,10 @@ class NullnessCompatibilityTest : DriverTest() {
                     src/test/pkg/Outer.kt:8: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method2(String string, String maybeString) [InvalidNullConversion]
                     src/test/pkg/Outer.kt:9: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method3(String maybeString, String string) [InvalidNullConversion]
                 """,
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             checkCompatibilityApiReleased =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public final class Outer {
                         ctor public Outer();
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
index ae2fa2841..57c9e1069 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
@@ -19,11 +19,7 @@ package com.android.tools.metalava.compatibility
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
-import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.supportParameterName
-import com.android.tools.metalava.testing.KnownSourceFiles
-import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
@@ -40,7 +36,7 @@ class ParameterNameChangeTest : DriverTest() {
                 """
                     package test.pkg {
                       public class Foo {
-                        method public void bar(Int toast);
+                        method public void bar(int toast);
                       }
                     }
                 """,
@@ -48,7 +44,7 @@ class ParameterNameChangeTest : DriverTest() {
                 """
                     package test.pkg {
                       public class Foo {
-                        method public void bar(Int bread);
+                        method public void bar(int bread);
                       }
                     }
                 """,
@@ -81,76 +77,6 @@ class ParameterNameChangeTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Flag renaming a parameter from the classpath`() {
-        check(
-            apiClassResolution = ApiClassResolution.API_CLASSPATH,
-            expectedIssues =
-                """
-                    error: Attempted to change parameter name from prefix to suffix in method test.pkg.MyString.endsWith [ParameterNameChange]
-                    load-api.txt:4: error: Attempted to change parameter name from prefix to suffix in method test.pkg.MyString.startsWith [ParameterNameChange]
-                """
-                    .trimIndent(),
-            checkCompatibilityApiReleased =
-                """
-                    // Signature format: 4.0
-                    package test.pkg {
-                        public class MyString extends java.lang.String {
-                            method public boolean endsWith(String prefix);
-                        }
-                    }
-                """,
-            signatureSource =
-                """
-                    // Signature format: 4.0
-                    package test.pkg {
-                        public class MyString extends java.lang.String {
-                            method public boolean startsWith(String suffix);
-                        }
-                    }
-                """,
-        )
-    }
-
-    @Test
-    fun `Java Parameter Name Change`() {
-        check(
-            expectedIssues =
-                """
-                    src/test/pkg/JavaClass.java:6: error: Attempted to remove parameter name from parameter newName in test.pkg.JavaClass.method1 [ParameterNameChange]
-                    src/test/pkg/JavaClass.java:7: error: Attempted to change parameter name from secondParameter to newName in method test.pkg.JavaClass.method2 [ParameterNameChange]
-                """,
-            checkCompatibilityApiReleased =
-                """
-                    package test.pkg {
-                      public class JavaClass {
-                        ctor public JavaClass();
-                        method public String method1(String parameterName);
-                        method public String method2(String firstParameter, String secondParameter);
-                      }
-                    }
-                """,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                            @Suppress("all")
-                            package test.pkg;
-                            import androidx.annotation.ParameterName;
-
-                            public class JavaClass {
-                                public String method1(String newName) { return null; }
-                                public String method2(@ParameterName("firstParameter") String s, @ParameterName("newName") String prevName) { return null; }
-                            }
-                        """
-                    ),
-                    supportParameterName,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
-                ),
-        )
-    }
-
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Kotlin Parameter Name Change`() {
@@ -159,10 +85,10 @@ class ParameterNameChangeTest : DriverTest() {
                 """
                     src/test/pkg/KotlinClass.kt:4: error: Attempted to change parameter name from prevName to newName in method test.pkg.KotlinClass.method1 [ParameterNameChange]
                 """,
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             checkCompatibilityApiReleased =
                 """
-                    // Signature format: 3.0
+                    // Signature format: 4.0
                     package test.pkg {
                       public final class KotlinClass {
                         ctor public KotlinClass();
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
index abf81c5f4..97e61935d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
@@ -21,7 +21,6 @@ import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.systemApiSource
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -214,8 +213,6 @@ class ThrowsCompatibilityTest : DriverTest() {
                         """
                     ),
                     systemApiSource,
-                    // Hide android.annotation classes.
-                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ApiFlagsConfigTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/ApiFlagsConfigTest.kt
new file mode 100644
index 000000000..b6a48f0cb
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/ApiFlagsConfigTest.kt
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.IMMUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Mutability.MUTABLE
+import com.android.tools.metalava.config.ApiFlagConfig.Status.DISABLED
+import com.android.tools.metalava.config.ApiFlagConfig.Status.ENABLED
+import com.android.tools.metalava.testing.xml
+import org.junit.Test
+
+class ApiFlagsConfigTest : BaseConfigParserTest() {
+    @Test
+    fun `Test simple`() {
+        roundTrip(
+            Config(
+                apiFlags =
+                    ApiFlagsConfig(
+                        flags =
+                            listOf(
+                                ApiFlagConfig(
+                                    pkg = "test.pkg",
+                                    name = "flag_name",
+                                    mutability = IMMUTABLE,
+                                    status = ENABLED,
+                                ),
+                                ApiFlagConfig(
+                                    pkg = "test.pkg",
+                                    name = "other_flag_name",
+                                    mutability = MUTABLE,
+                                    status = DISABLED,
+                                ),
+                            )
+                    )
+            ),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config">
+                  <api-flags>
+                    <api-flag package="test.pkg" name="flag_name" mutability="immutable" status="enabled"/>
+                    <api-flag package="test.pkg" name="other_flag_name" mutability="mutable" status="disabled"/>
+                  </api-flags>
+                </config>
+            """
+        )
+    }
+
+    @Test
+    fun `Test duplicate`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-flags>
+                        <api-flag package="test.pkg" name="flag_name" mutability="immutable" status="enabled"/>
+                        <api-flag package="test.pkg" name="flag_name" mutability="mutable" status="disabled"/>
+                      </api-flags>
+                    </config>
+                """
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:4: cvc-identity-constraint.4.2.2: Duplicate key value [test.pkg,flag_name] declared for identity constraint "ApiFlagByQualifiedName" of element "config".
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ApiSurfacesConfigTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/ApiSurfacesConfigTest.kt
new file mode 100644
index 000000000..a9545aa63
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/ApiSurfacesConfigTest.kt
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.lint.checks.infrastructure.TestFiles.xml
+import kotlin.test.assertEquals
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+class ApiSurfacesConfigTest : BaseConfigParserTest() {
+    @Test
+    fun `Empty api-surfaces config`() {
+        roundTrip(
+            Config(apiSurfaces = ApiSurfacesConfig()),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config">
+                  <api-surfaces/>
+                </config>
+            """,
+        )
+    }
+
+    @Test
+    fun `Simple api-surfaces config`() {
+        roundTrip(
+            Config(
+                apiSurfaces =
+                    ApiSurfacesConfig(
+                        apiSurfaceList =
+                            listOf(
+                                ApiSurfaceConfig(
+                                    name = "public",
+                                ),
+                                ApiSurfaceConfig(
+                                    name = "system",
+                                    extends = "public",
+                                ),
+                            ),
+                    )
+            ),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config">
+                  <api-surfaces>
+                    <api-surface name="public"/>
+                    <api-surface name="system" extends="public"/>
+                  </api-surfaces>
+                </config>
+            """
+        )
+    }
+
+    @Test
+    fun `Invalid api-surfaces config - invalid name`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                        <api-surfaces>
+                            <api-surface name="public2"/>
+                        </api-surfaces>
+                    </config>
+                """,
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:3: cvc-pattern-valid: Value 'public2' is not facet-valid with respect to pattern '[a-z-]+' for type 'ApiSurfaceNameType'.
+                        file:TESTROOT/config.xml:3: cvc-attribute.3: The value 'public2' of attribute 'name' on element 'api-surface' is not valid with respect to its type, 'ApiSurfaceNameType'.
+                """,
+        )
+    }
+
+    @Test
+    fun `Invalid api-surfaces config - extends non-existent surface`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                        <api-surfaces>
+                            <api-surface name="system" extends="missing"/>
+                        </api-surfaces>
+                    </config>
+                """,
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:5: cvc-identity-constraint.4.3: Key 'ApiSurfaceExtendsKeyRef' with value 'missing' not found for identity constraint of element 'config'.
+                """,
+        )
+    }
+
+    @Test
+    fun `Invalid api-surfaces config - duplicate surface names`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                        <api-surfaces>
+                            <api-surface name="duplicate"/>
+                            <api-surface name="duplicate"/>
+                        </api-surfaces>
+                    </config>
+                """,
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:4: cvc-identity-constraint.4.2.2: Duplicate key value [duplicate] declared for identity constraint "ApiSurfaceByName" of element "config".
+                """,
+        )
+    }
+
+    @Test
+    fun `Multiple api-surfaces config files`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="public"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+            xml(
+                "config2.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="other"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+        ) {
+            assertEquals(
+                Config(
+                    apiSurfaces =
+                        ApiSurfacesConfig(
+                            apiSurfaceList =
+                                listOf(
+                                    ApiSurfaceConfig(
+                                        name = "public",
+                                    ),
+                                    ApiSurfaceConfig(
+                                        name = "other",
+                                    ),
+                                ),
+                        ),
+                ),
+                config
+            )
+        }
+    }
+
+    @Test
+    fun `Duplicate api-surfaces across config files`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="public"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+            xml(
+                "config2.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="public"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+            expectedFail = "Found duplicate surfaces called `public`"
+        )
+    }
+
+    @Test
+    fun `Cycle in api-surfaces`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="public" extends="module-lib"/>
+                        <api-surface name="system" extends="public"/>
+                        <api-surface name="module-lib" extends="system"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+            expectedFail =
+                "Cycle detected in extends relationship: `public` -> `module-lib` -> `system` -> `public`.",
+        )
+    }
+
+    @Test
+    fun `Dag in api-surfaces, module-lib first`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="system" extends="public"/>
+                        <api-surface name="module-lib" extends="system"/>
+                        <api-surface name="test" extends="system"/>
+                        <api-surface name="public"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+        ) {
+            // The extends property defines a partial order to those surfaces that have an
+            // extends relationship but configuration order is preserved otherwise. So, as
+            // `module-lib` comes before `test` in the configuration it comes first in the ordered
+            // set.
+            assertEquals(
+                listOf("public", "system", "module-lib", "test"),
+                config.apiSurfaces?.orderedSurfaces?.map { it.name }
+            )
+        }
+    }
+
+    @Test
+    fun `Dag in api-surfaces, test first`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <api-surfaces>
+                        <api-surface name="system" extends="public"/>
+                        <api-surface name="test" extends="system"/>
+                        <api-surface name="module-lib" extends="system"/>
+                        <api-surface name="public"/>
+                      </api-surfaces>
+                    </config>
+                """,
+            ),
+        ) {
+            // The extends property defines a partial order to those surfaces that have an
+            // extends relationship but configuration order is preserved otherwise. So, as `test`
+            // comes before `module-lib` in the configuration it comes first in the ordered set.
+            assertEquals(
+                listOf("public", "system", "test", "module-lib"),
+                config.apiSurfaces?.orderedSurfaces?.map { it.name }
+            )
+        }
+    }
+
+    @Test
+    fun `Test invalid extends`() {
+        val apiSurfacesConfig =
+            ApiSurfacesConfig(
+                apiSurfaceList =
+                    listOf(
+                        ApiSurfaceConfig(name = "public"),
+                        ApiSurfaceConfig(name = "system", extends = "other")
+                    ),
+            )
+
+        val exception =
+            assertThrows(IllegalStateException::class.java) { apiSurfacesConfig.orderedSurfaces }
+        assertEquals(
+            "Surface `system` extends an unknown surface `other`, expected one of `public`, `system`",
+            exception.message
+        )
+    }
+
+    /**
+     * Check that [ApiSurfacesConfig.contributesTo] returns the expected result.
+     *
+     * @param name The name of the surface whose contributes are to be checked.
+     * @param expectedSurfaces The list of expected surface names.
+     */
+    private fun ApiSurfacesConfig.assertContributesTo(
+        name: String,
+        expectedSurfaces: List<String>
+    ) {
+        val surfaceConfig = getByNameOrError(name) { "unknown `$it`" }
+        assertEquals(
+            expectedSurfaces,
+            contributesTo(surfaceConfig).map { it.name },
+            "contributions to $name"
+        )
+    }
+
+    @Test
+    fun `Test contributesTo`() {
+        val apiSurfacesConfig =
+            ApiSurfacesConfig(
+                apiSurfaceList =
+                    listOf(
+                        ApiSurfaceConfig(name = "test", extends = "system"),
+                        ApiSurfaceConfig(name = "module-lib", extends = "system"),
+                        ApiSurfaceConfig(name = "public"),
+                        ApiSurfaceConfig(name = "system", extends = "public"),
+                    ),
+            )
+
+        apiSurfacesConfig.assertContributesTo(
+            "public",
+            listOf(
+                "public",
+            )
+        )
+
+        apiSurfacesConfig.assertContributesTo(
+            "system",
+            listOf(
+                "public",
+                "system",
+            )
+        )
+
+        apiSurfacesConfig.assertContributesTo(
+            "test",
+            listOf(
+                "public",
+                "system",
+                "test",
+            )
+        )
+
+        apiSurfacesConfig.assertContributesTo(
+            "module-lib",
+            listOf(
+                "public",
+                "system",
+                "module-lib",
+            )
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/BaseConfigParserTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/BaseConfigParserTest.kt
new file mode 100644
index 000000000..26a2d6fcf
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/BaseConfigParserTest.kt
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.testing.TemporaryFolderOwner
+import com.google.common.truth.Truth.assertThat
+import org.intellij.lang.annotations.Language
+import org.junit.Rule
+import org.junit.rules.TemporaryFolder
+
+/** Base for tests for objects that are loaded from a configuration file. */
+open class BaseConfigParserTest : TemporaryFolderOwner {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
+
+    /** Context for the tests. */
+    data class TestContext(
+        /** The created [Config] being tested. */
+        val config: Config,
+    )
+
+    /**
+     * Run the test.
+     *
+     * @param configFiles The config files to parse.
+     * @param expectedFail The expected failure.
+     * @param body the body of the test which checks the state of the [Config] object which is made
+     *   available as [TestContext.config].
+     */
+    protected fun runTest(
+        vararg configFiles: TestFile,
+        expectedFail: String = "",
+        body: (TestContext.() -> Unit)? = null,
+    ) {
+        val dir = temporaryFolder.newFolder()
+        val expectingFailure = expectedFail != ""
+        val hasBody = body != null
+
+        // If expecting a failure then it should not provide a body and if it is not expecting a
+        // failure then it must provide a body.
+        if (expectingFailure == hasBody) {
+            if (expectingFailure) error("Should not provide a body when expecting a failure")
+            else error("Must provide a body when not expecting a failure")
+        }
+
+        var errors = ""
+        try {
+            val files = configFiles.map { it.indented().createFile(dir) }.toList()
+            val config = ConfigParser.parse(files)
+            val context = TestContext(config = config)
+            if (body != null) context.body()
+        } catch (e: Exception) {
+            errors = cleanupString(e.message ?: "", project = dir)
+        }
+        assertThat(errors.trimIndent()).isEqualTo(expectedFail.trimIndent())
+    }
+
+    /**
+     * Round trip [config], i.e. write it to XML, check it matches [xml], read it back in, check
+     * that it matches [config].
+     *
+     * Writing configuration to XML is not something that Metalava needs at runtime, but it is
+     * useful to test what is written to a file as that is what can be read from the file.
+     */
+    protected fun roundTrip(config: Config, @Language("xml") xml: String) {
+        val configFile = temporaryFolder.newFile("round-trip-config.xml")
+
+        config.writeTo(configFile)
+        assertThat(configFile.readText().trimEnd()).isEqualTo(xml.trimIndent())
+
+        val readConfig = ConfigParser.parse(listOf(configFile))
+        assertThat(readConfig).isEqualTo(config)
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ConfigParserTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/ConfigParserTest.kt
new file mode 100644
index 000000000..c195fcbcb
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/ConfigParserTest.kt
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.lint.checks.infrastructure.TestFiles.xml
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+/** Tests of the [ConfigParser]. */
+class ConfigParserTest : BaseConfigParserTest() {
+    @Test
+    fun `Empty config file`() {
+        roundTrip(
+            Config(),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config"/>
+            """
+        )
+    }
+
+    @Test
+    fun `Config file with xsi schemaLocation`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config"
+                            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                            xsi:schemaLocation="http://www.google.com/tools/metalava/config ../../../../../../resources/schemas/config.xsd"/>
+                """,
+            ),
+        ) {
+            assertThat(config).isEqualTo(Config())
+        }
+    }
+
+    @Test
+    fun `Invalid config file`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <invalid xmlns="http://www.google.com/tools/metalava/config"/>
+                """,
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:1: cvc-elt.1.a: Cannot find the declaration of element 'invalid'.
+                """,
+        )
+    }
+
+    @Test
+    fun `Syntactically incorrect config file`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <!-- Comment -->
+                    <config xmlns="http://www.google.com/tools/metalava/config"></other>
+                """,
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:2: The element type "config" must be terminated by the matching end-tag "</config>".
+                """,
+        )
+    }
+
+    @Test
+    fun `Multiple config files`() {
+        runTest(
+            xml(
+                "config1.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config"/>
+                """,
+            ),
+            xml(
+                "config2.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config"/>
+                """,
+            ),
+        ) {
+            assertThat(config).isEqualTo(Config())
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt
deleted file mode 100644
index cc535f3b0..000000000
--- a/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.config
-
-import com.android.tools.lint.checks.infrastructure.TestFiles
-import com.android.tools.metalava.DriverTest
-import org.junit.Test
-
-class ConfigTest : DriverTest() {
-    @Test
-    fun `Empty config file`() {
-        check(
-            configFiles =
-                arrayOf(
-                    TestFiles.xml(
-                        "config.xml",
-                        """
-                            <config xmlns="http://www.google.com/tools/metalava/config"/>
-                        """,
-                    )
-                ),
-        )
-    }
-
-    @Test
-    fun `Invalid config file`() {
-        check(
-            configFiles =
-                arrayOf(
-                    TestFiles.xml(
-                        "config.xml",
-                        """
-                            <invalid xmlns="http://www.google.com/tools/metalava/config"/>
-                        """,
-                    )
-                ),
-            expectedIssues =
-                "config.xml:1: error: Problem parsing configuration file: cvc-elt.1.a: Cannot find the declaration of element 'invalid'. [ConfigFileProblem]",
-        )
-    }
-}
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ConfigTesting.kt b/metalava/src/test/java/com/android/tools/metalava/config/ConfigTesting.kt
new file mode 100644
index 000000000..48ed33fea
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/ConfigTesting.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import java.io.File
+
+/** Write [this] to [file] in the same format as [ConfigParser] reads. */
+fun Config.writeTo(file: File) {
+    val xmlMapper = ConfigParser.configXmlMapper()
+    xmlMapper.writeValue(file, this)
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
index 575dcd017..070168df3 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
@@ -162,6 +162,55 @@ class DocAnalyzerTest : DriverTest() {
         )
     }
 
+    @Test
+    fun `Check construct ApiLookup works correctly for major-minor`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Foo {
+                                public Foo() {}
+                                public Foo(int i) { this.i = i; }
+
+                                private int i;
+                            }
+                        """
+                    ),
+                ),
+            checkCompilation = true,
+            docStubs = true,
+            applyApiLevelsXml =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="4">
+                        <class name="test/pkg/Foo" since="17">
+                            <method name="&lt;init>()V" since="18.0"/>
+                            <method name="&lt;init>(I)V" since="19.3"/>
+                        </class>
+                    </api>
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /** @apiSince 17 */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            /** @apiSince 18 */
+                            public Foo() { throw new RuntimeException("Stub!"); }
+                            /** @apiSince 19.3 */
+                            public Foo(int i) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
     @Test
     fun `Fix first sentence handling`() {
         check(
@@ -187,6 +236,8 @@ class DocAnalyzerTest : DriverTest() {
                     """
                     )
                 ),
+            // Override default to emit android.annotation classes.
+            skipEmitPackages = emptyList(),
             checkCompilation = true,
             docStubs = true,
             stubFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt
new file mode 100644
index 000000000..c361f4a00
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tools.metalava.doc
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.androidRestrictedForEnvironment
+import com.android.tools.metalava.androidXRestrictedForEnvironment
+import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PACKAGE
+import com.android.tools.metalava.model.ANDROID_ANNOTATION_PACKAGE
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+/** Tests for the handling the @RestrictedForEnvironment in [DocAnalyzer] */
+class RestrictedForEnvironmentTest : DriverTest() {
+    private fun checkRestrictedForEnvironmentHandling(
+        import: String,
+        envArgument: String,
+        packageName: String = ANDROIDX_ANNOTATION_PACKAGE,
+        restrictedForEnvironmentClass: TestFile = androidXRestrictedForEnvironment,
+    ) {
+        val packageDir = packageName.replace(".", "/")
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            import $packageName.RestrictedForEnvironment;
+                            import static $import;
+                            /**
+                            * Javadoc for MyClass1
+                            */
+                            @RestrictedForEnvironment(environments = $envArgument, from = 14)
+                            public class MyClass1 {
+                            }
+                        """
+                    ),
+                    restrictedForEnvironmentClass,
+                ),
+            api =
+                """
+                    package test.pkg {
+                      @RestrictedForEnvironment(environments=$packageName.RestrictedForEnvironment.Environment.SDK_SANDBOX, from=14) public class MyClass1 {
+                        ctor public MyClass1();
+                      }
+                    }
+                """,
+            docStubs = true,
+            skipEmitPackages = listOf(packageName),
+            // TODO(b/396346859): Resolve hidden environments field
+            expectedIssues =
+                "src/$packageDir/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]",
+            extractAnnotations =
+                mapOf(
+                    "test.pkg" to
+                        """
+                            <?xml version="1.0" encoding="UTF-8"?>
+                            <root>
+                              <item name="test.pkg.MyClass1">
+                                <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="from" val="14" />
+                                </annotation>
+                              </item>
+                            </root>
+                        """
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /**
+                             * Javadoc for MyClass1
+                             * <br>
+                             * Restricted for SDK Runtime environment in API level 14.
+                             */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class MyClass1 {
+                            public MyClass1() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                )
+        )
+    }
+
+    @Test
+    fun `Check RestrictedForEnvironment handling for SDK_SANDBOX env - android`() {
+        checkRestrictedForEnvironmentHandling(
+            "android.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX",
+            "SDK_SANDBOX",
+            packageName = ANDROID_ANNOTATION_PACKAGE,
+            restrictedForEnvironmentClass = androidRestrictedForEnvironment
+        )
+    }
+
+    @Test
+    fun `Check RestrictedForEnvironment handling for SDK_SANDBOX env - androidx`() {
+        checkRestrictedForEnvironmentHandling(
+            "androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX",
+            "SDK_SANDBOX"
+        )
+    }
+
+    @Test
+    fun `Check RestrictedForEnvironment handling for partial nested SDK_SANDBOX env - androidx`() {
+        checkRestrictedForEnvironmentHandling(
+            "androidx.annotation.RestrictedForEnvironment",
+            "RestrictedForEnvironment.Environment.SDK_SANDBOX"
+        )
+    }
+
+    @Test
+    fun `Check RestrictedForEnvironment handling for fully nested SDK_SANDBOX env - androidx`() {
+        checkRestrictedForEnvironmentHandling(
+            "androidx",
+            "androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX"
+        )
+    }
+
+    @Test
+    fun `Check RestrictedForEnvironment handling for multiple annotations - androidx`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            import androidx.annotation.RestrictedForEnvironment;
+                            import static androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX;
+                            /**
+                            * Javadoc for MyClass1
+                            */
+                            @RestrictedForEnvironment(environments = SDK_SANDBOX, from = 14)
+                            @RestrictedForEnvironment(environments = SDK_SANDBOX, from = 16)
+                            public class MyClass1 {
+                            }
+                        """
+                    ),
+                    androidXRestrictedForEnvironment,
+                ),
+            docStubs = true,
+            skipEmitPackages = listOf("androidx.annotation"),
+            // TODO(b/396346859): Resolve hidden environments field
+            expectedIssues =
+                "src/androidx/annotation/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]\nsrc/androidx/annotation/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]",
+            extractAnnotations =
+                mapOf(
+                    "test.pkg" to
+                        """
+                            <?xml version="1.0" encoding="UTF-8"?>
+                            <root>
+                              <item name="test.pkg.MyClass1">
+                                <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="from" val="14" />
+                                </annotation>
+                                <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="from" val="16" />
+                                </annotation>
+                              </item>
+                            </root>
+                        """
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /**
+                             * Javadoc for MyClass1
+                             * <br>
+                             * Restricted for SDK Runtime environment in API level 14.
+                             * <br>
+                             * Restricted for SDK Runtime environment in API level 16.
+                             */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class MyClass1 {
+                            public MyClass1() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/jar/StandaloneJarCodebaseLoaderTest.kt b/metalava/src/test/java/com/android/tools/metalava/jar/StandaloneJarCodebaseLoaderTest.kt
new file mode 100644
index 000000000..a6774d78a
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/jar/StandaloneJarCodebaseLoaderTest.kt
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.jar
+
+import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.ProgressTracker
+import com.android.tools.metalava.reporter.ThrowingReporter
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.toTestFile
+import java.io.File
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertNull
+import kotlin.test.assertTrue
+import org.junit.Assert.assertThrows
+import org.junit.Assert.fail
+import org.junit.Test
+
+class StandaloneJarCodebaseLoaderTest : DriverTest() {
+    private val jarCodebaseLoader by lazy {
+        StandaloneJarCodebaseLoader.create(
+            disableStderrDumping = false,
+            ProgressTracker(),
+            ThrowingReporter.INSTANCE,
+            sourceModelProvider = codebaseCreatorConfig.creator,
+        )
+    }
+
+    @Test
+    fun `Test jar loader freezes codebase`() {
+        lateinit var jarFile: File
+        buildFileStructure {
+            jarFile =
+                jar(
+                    "test.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {}
+                        """
+                    )
+                )
+        }
+
+        val codebase = jarCodebaseLoader.loadFromJarFile(jarFile)
+        val fooClass = codebase.assertClass("test.pkg.Foo")
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                fooClass.mutateModifiers { fail("should not reach here") }
+            }
+        assertEquals("Cannot modify frozen class test.pkg.Foo", exception.message)
+    }
+
+    @Test
+    fun `Test jar loader does not freeze codebase`() {
+        lateinit var jarFile: File
+        buildFileStructure {
+            jarFile =
+                jar(
+                    "test.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {}
+                        """
+                    )
+                )
+        }
+
+        val codebase = jarCodebaseLoader.loadFromJarFile(jarFile, freezeCodebase = false)
+        val fooClass = codebase.assertClass("test.pkg.Foo")
+        assertFalse(fooClass.modifiers.isFinal(), message = "isFinal before mutation")
+        fooClass.mutateModifiers { setFinal(true) }
+        assertTrue(fooClass.modifiers.isFinal(), message = "isFinal after mutation")
+    }
+
+    @Test
+    fun `Test loaded jar depends on class path`() {
+        lateinit var classPathJarFile: File
+        lateinit var jarFile: File
+        buildFileStructure {
+            classPathJarFile =
+                jar(
+                    "classpath.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Bar {}
+                        """
+                    ),
+                )
+
+            // This will fail to compile if the class path is not provided.
+            jarFile =
+                jar(
+                    "test.jar",
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo extends Bar {}
+                        """
+                    ),
+                    classPath = listOf(classPathJarFile.toTestFile()),
+                )
+        }
+
+        jarCodebaseLoader.loadFromJarFile(jarFile).let { codebase ->
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            assertEquals(
+                "test.pkg.Bar",
+                fooClass.superClassType().toString(),
+                message = "no classpath, super class type"
+            )
+            assertNull(fooClass.superClass(), message = "no classpath, no super class")
+        }
+
+        jarCodebaseLoader.loadFromJarFile(jarFile, classPath = listOf(classPathJarFile)).let {
+            codebase ->
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            assertEquals(
+                "test.pkg.Bar",
+                fooClass.superClassType().toString(),
+                message = "classpath, super class type"
+            )
+            codebase.assertResolvedClass("test.pkg.Bar")
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/AcronymNamesTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/AcronymNamesTest.kt
new file mode 100644
index 000000000..76d5f31fd
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/AcronymNamesTest.kt
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.lint
+
+import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.androidxNullableSource
+import com.android.tools.metalava.cli.lint.ARG_ALLOWED_ACRONYM
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import org.junit.Test
+
+class AcronymNamesTest : DriverTest() {
+    @Test
+    fun `Test two letter acronyms`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                "src/android/pkg/Foo.java:7: warning: Acronyms should not be capitalized in method names: was `getID`, should this be `getId`? [AcronymName]",
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+
+                            import androidx.annotation.Nullable;
+
+                            public class Foo {
+                                @Nullable
+                                public String getID() { return null; }
+                                public void setZOrderOnTop() { } // OK
+                            }
+                        """
+                    ),
+                    androidxNullableSource
+                )
+        )
+    }
+
+    @Test
+    fun `Test longer acronyms`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                """
+                src/android/pkg/HTMLWriter.java:3: warning: Acronyms should not be capitalized in class names: was `HTMLWriter`, should this be `HtmlWriter`? [AcronymName]
+                src/android/pkg/HTMLWriter.java:4: warning: Acronyms should not be capitalized in method names: was `fromHTMLToHTML`, should this be `fromHtmlToHtml`? [AcronymName]
+                src/android/pkg/HTMLWriter.java:5: warning: Acronyms should not be capitalized in method names: was `toXML`, should this be `toXml`? [AcronymName]
+                """,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+
+                            public class HTMLWriter {
+                                public void fromHTMLToHTML() { }
+                                public void toXML() { }
+                            }
+                        """
+                    ),
+                )
+        )
+    }
+
+    @Test
+    fun `Test all caps class name`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                "src/android/pkg/ALL_CAPS.java:3: warning: Acronyms should not be capitalized in class names: was `ALL_CAPS`, should this be `AllCaps`? [AcronymName]",
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+
+                            public class ALL_CAPS { // like android.os.Build.VERSION_CODES
+                            }
+                        """
+                    ),
+                )
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test acronyms in top level kotlin function`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                "src/Dp.kt:3: warning: Acronyms should not be capitalized in method names: was `badCALL`, should this be `badCall`? [AcronymName]",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            inline class Dp(val value: Float)
+                            fun greatCall(width: Dp)
+                            fun badCALL(width: Dp)
+                        """
+                    ),
+                )
+        )
+    }
+
+    @Test
+    fun `Test names against previous API`() {
+        check(
+            apiLint =
+                """
+                package android.pkg {
+                  public class badlyNamedClass {
+                    ctor public badlyNamedClass();
+                    method public void BadlyNamedMethod1();
+                    method public void fromHTMLToHTML();
+                    method public String getID();
+                    method public void toXML();
+                    field public static final int BadlyNamedField = 1; // 0x1
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                src/android/pkg/badlyNamedClass.java:8: warning: Acronyms should not be capitalized in method names: was `toXML2`, should this be `toXml2`? [AcronymName]
+                src/android/pkg2/HTMLWriter.java:3: warning: Acronyms should not be capitalized in class names: was `HTMLWriter`, should this be `HtmlWriter`? [AcronymName]
+                src/android/pkg2/HTMLWriter.java:4: warning: Acronyms should not be capitalized in method names: was `fromHTMLToHTML`, should this be `fromHtmlToHtml`? [AcronymName]
+                """,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+
+                            public class badlyNamedClass {
+                                public static final int BadlyNamedField = 1;
+
+                                public void fromHTMLToHTML() { }
+                                public void toXML() { }
+                                public void toXML2() { }
+                                public String getID() { return null; }
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package android.pkg2;
+
+                            public class HTMLWriter {
+                                public void fromHTMLToHTML() { }
+                            }
+                        """
+                    )
+                )
+        )
+    }
+
+    @Test
+    fun `Test long acronym following two letter acronym`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                "src/test/pkg/IHaveTwoThenFOUR.java:2: warning: Acronyms should not be capitalized in class names: was `IHaveTwoThenFOUR`, should this be `IHaveTwoThenFour`? [AcronymName]",
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class IHaveTwoThenFOUR {} // IH is okay, FOUR is not
+                        """
+                    )
+                )
+        )
+    }
+
+    @Test
+    fun `Test acronyms followed by non-letters`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                """
+                src/test/pkg/Foo.java:3: warning: Acronyms should not be capitalized in method names: was `usingNUMBER123`, should this be `usingNumber123`? [AcronymName]
+                src/test/pkg/Foo.java:4: warning: Acronyms should not be capitalized in method names: was `usingUNDERSCORE_`, should this be `usingUnderscore_`? [AcronymName]
+                src/test/pkg/Foo.java:5: warning: Acronyms should not be capitalized in method names: was `usingDOLLAR${'$'}`, should this be `usingDollar${'$'}`? [AcronymName]
+                """,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public void usingNUMBER123() {}
+                                public void usingUNDERSCORE_() {}
+                                public void usingDOLLAR$() {}
+                            }
+                        """
+                    )
+                )
+        )
+    }
+
+    @Test
+    fun `Test allowed acronyms`() {
+        check(
+            apiLint = "", // enabled
+            expectedIssues =
+                "src/test/pkg/NOTSQL.java:2: warning: Acronyms should not be capitalized in class names: was `NOTSQL`, should this be `Notsql`? [AcronymName]",
+            extraArguments = arrayOf(ARG_ALLOWED_ACRONYM, "SQL", ARG_ALLOWED_ACRONYM, "SQ"),
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class SQLException {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public class SupportSQLiteProgram {
+                                public void execSQL() {}
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public class NOTSQL {}
+                        """
+                    )
+                )
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
index 43d9b2b11..81e976395 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
@@ -22,9 +22,10 @@ import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.restrictToSource
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
+import kotlin.arrayOf
 import org.junit.Test
 
 /** Test for [ApiLint] specifically with baseline arguments. */
@@ -229,7 +230,9 @@ class ApiLintBaselineTest : DriverTest() {
                     ARG_HIDE,
                     "ProtectedMember",
                     ARG_HIDE,
-                    "GetterOnBuilder"
+                    "GetterOnBuilder",
+                    ARG_HIDE,
+                    Issues.INHERIT_CHANGES_SIGNATURE.name,
                 ),
             sourceFiles =
                 arrayOf(
@@ -286,8 +289,6 @@ class ApiLintBaselineTest : DriverTest() {
                     androidxNonNullSource,
                     androidxNullableSource,
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
index 84d7a1c35..748d6ab7f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
@@ -35,7 +35,7 @@ class ApiLintFilteringTest(private val previouslyReleasedApiUse: PreviouslyRelea
         /** Run each test with and without the previously released API. */
         @JvmStatic
         @Parameterized.Parameters(name = "{0}")
-        fun testParameters() = PreviouslyReleasedApiUse.values()
+        fun testParameters() = PreviouslyReleasedApiUse.entries
     }
 
     private fun checkFiltering(
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
index ab8d870d0..79ffb3806 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
@@ -33,25 +33,17 @@ import org.junit.Test
 
 class ApiLintTest : DriverTest() {
 
-    @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Test names`() {
         // Make sure we only flag issues in new API
         check(
             apiLint = "", // enabled
-            extraArguments = arrayOf(ARG_HIDE, "MissingNullability"),
             expectedIssues =
                 """
-                src/Dp.kt:3: warning: Acronyms should not be capitalized in method names: was `badCALL`, should this be `badCall`? [AcronymName]
-                src/android/pkg/ALL_CAPS.java:3: warning: Acronyms should not be capitalized in class names: was `ALL_CAPS`, should this be `AllCaps`? [AcronymName]
-                src/android/pkg/HTMLWriter.java:3: warning: Acronyms should not be capitalized in class names: was `HTMLWriter`, should this be `HtmlWriter`? [AcronymName]
                 src/android/pkg/MyStringImpl.java:3: error: Don't expose your implementation details: `MyStringImpl` ends with `Impl` [EndsWithImpl]
-                src/android/pkg/badlyNamedClass.java:5: error: Class must start with uppercase char: badlyNamedClass [StartWithUpper]
-                src/android/pkg/badlyNamedClass.java:6: error: Constant field names must be named with only upper case characters: `android.pkg.badlyNamedClass#BadlyNamedField`, should be `BADLY_NAMED_FIELD`? [AllUpper]
-                src/android/pkg/badlyNamedClass.java:7: error: Method name must start with lowercase char: BadlyNamedMethod1 [StartWithLower]
-                src/android/pkg/badlyNamedClass.java:9: warning: Acronyms should not be capitalized in method names: was `fromHTMLToHTML`, should this be `fromHtmlToHtml`? [AcronymName]
-                src/android/pkg/badlyNamedClass.java:10: warning: Acronyms should not be capitalized in method names: was `toXML`, should this be `toXml`? [AcronymName]
-                src/android/pkg/badlyNamedClass.java:12: warning: Acronyms should not be capitalized in method names: was `getID`, should this be `getId`? [AcronymName]
+                src/android/pkg/badlyNamedClass.java:3: error: Class must start with uppercase char: badlyNamedClass [StartWithUpper]
+                src/android/pkg/badlyNamedClass.java:4: error: Constant field names must be named with only upper case characters: `android.pkg.badlyNamedClass#BadlyNamedField`, should be `BADLY_NAMED_FIELD`? [AllUpper]
+                src/android/pkg/badlyNamedClass.java:5: error: Method name must start with lowercase char: BadlyNamedMethod1 [StartWithLower]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -60,33 +52,9 @@ class ApiLintTest : DriverTest() {
                         """
                     package android.pkg;
 
-                    import androidx.annotation.Nullable;
-
                     public class badlyNamedClass {
                         public static final int BadlyNamedField = 1;
                         public void BadlyNamedMethod1() { }
-
-                        public void fromHTMLToHTML() { }
-                        public void toXML() { }
-                        @Nullable
-                        public String getID() { return null; }
-                        public void setZOrderOnTop() { } // OK
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.pkg;
-
-                    public class ALL_CAPS { // like android.os.Build.VERSION_CODES
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.pkg;
-
-                    public class HTMLWriter {
                     }
                     """
                     ),
@@ -98,66 +66,6 @@ class ApiLintTest : DriverTest() {
                     }
                     """
                     ),
-                    kotlin(
-                        """
-                    inline class Dp(val value: Float)
-                    fun greatCall(width: Dp)
-                    fun badCALL(width: Dp)
-                """
-                    ),
-                    androidxNullableSource
-                )
-        )
-    }
-
-    @Test
-    fun `Test names against previous API`() {
-        check(
-            apiLint =
-                """
-                package android.pkg {
-                  public class badlyNamedClass {
-                    ctor public badlyNamedClass();
-                    method public void BadlyNamedMethod1();
-                    method public void fromHTMLToHTML();
-                    method public String getID();
-                    method public void toXML();
-                    field public static final int BadlyNamedField = 1; // 0x1
-                  }
-                }
-            """
-                    .trimIndent(),
-            expectedIssues =
-                """
-                src/android/pkg/badlyNamedClass.java:8: warning: Acronyms should not be capitalized in method names: was `toXML2`, should this be `toXmL2`? [AcronymName]
-                src/android/pkg2/HTMLWriter.java:3: warning: Acronyms should not be capitalized in class names: was `HTMLWriter`, should this be `HtmlWriter`? [AcronymName]
-                src/android/pkg2/HTMLWriter.java:4: warning: Acronyms should not be capitalized in method names: was `fromHTMLToHTML`, should this be `fromHtmlToHtml`? [AcronymName]
-                """,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package android.pkg;
-
-                    public class badlyNamedClass {
-                        public static final int BadlyNamedField = 1;
-
-                        public void fromHTMLToHTML() { }
-                        public void toXML() { }
-                        public void toXML2() { }
-                        public String getID() { return null; }
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.pkg2;
-
-                    public class HTMLWriter {
-                        public void fromHTMLToHTML() { }
-                    }
-                    """
-                    )
                 )
         )
     }
@@ -3304,4 +3212,25 @@ src/android/pkg/Interface.kt:158: error: Parameter `default` has a default value
                 )
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `data class definition`() {
+        check(
+            apiLint = "",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            data class Foo(val v: Int)
+                        """
+                    )
+                ),
+            extraArguments = arrayOf(ARG_ERROR, "DataClassDefinition"),
+            expectedFail = DefaultLintErrorMessage,
+            expectedIssues =
+                "src/test/pkg/Foo.kt:2: error: Exposing data classes as public API is discouraged because they are difficult to update while maintaining binary compatibility. [DataClassDefinition]"
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/DeprecatedLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/DeprecatedLintTest.kt
index 45be7d38a..c9178bd27 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/DeprecatedLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/DeprecatedLintTest.kt
@@ -48,7 +48,7 @@ class DeprecatedLintTest(private val deprecatedState: DeprecatedState) : DriverT
     companion object {
         @JvmStatic
         @Parameterized.Parameters(name = "{0}")
-        fun testParameters() = DeprecatedState.values()
+        fun testParameters() = DeprecatedState.entries
     }
 
     data class Context(val deprecatedClass: String, val deprecatedMember: String)
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
index 0c5c19ea5..985504c12 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
@@ -19,8 +19,8 @@ package com.android.tools.metalava.lint
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.common.ARG_WARNING
-import com.android.tools.metalava.flaggedApiSource
 import com.android.tools.metalava.systemApiSource
+import com.android.tools.metalava.testing.KnownJarFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -95,9 +95,10 @@ class FlaggedApiLintTest : DriverTest() {
                             }
                         """
                     ),
-                    flaggedApiSource,
                     systemApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf("--warning", "UnflaggedApi")
         )
     }
@@ -232,9 +233,10 @@ class FlaggedApiLintTest : DriverTest() {
                             }
                         """
                     ),
-                    flaggedApiSource,
                     flagsFile,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi", ARG_HIDE, "HiddenSuperclass")
         )
     }
@@ -269,9 +271,10 @@ class FlaggedApiLintTest : DriverTest() {
                             }
                         """
                     ),
-                    flaggedApiSource,
                     systemApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf("--warning", "UnflaggedApi")
         )
     }
@@ -418,9 +421,10 @@ class FlaggedApiLintTest : DriverTest() {
                             }
                         """
                     ),
-                    flaggedApiSource,
                     systemApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi", ARG_HIDE, "HiddenSuperclass"),
             checkCompilation = true
         )
@@ -489,8 +493,9 @@ class FlaggedApiLintTest : DriverTest() {
                         """
                     ),
                     flagsFile,
-                    flaggedApiSource
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
         )
     }
 
@@ -526,8 +531,9 @@ class FlaggedApiLintTest : DriverTest() {
                         """
                     ),
                     flagsFile,
-                    flaggedApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi"),
         )
     }
@@ -569,8 +575,9 @@ class FlaggedApiLintTest : DriverTest() {
                         """
                     ),
                     flagsFile,
-                    flaggedApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi"),
         )
     }
@@ -606,8 +613,9 @@ class FlaggedApiLintTest : DriverTest() {
                         """
                     ),
                     flagsFile,
-                    flaggedApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi"),
         )
     }
@@ -639,8 +647,9 @@ class FlaggedApiLintTest : DriverTest() {
                         """
                     ),
                     flagsFile,
-                    flaggedApiSource,
                 ),
+            // Access android.annotation.FlaggedApi
+            classpath = arrayOf(KnownJarFiles.stubAnnotationsTestFile),
             extraArguments = arrayOf(ARG_WARNING, "UnflaggedApi"),
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
index 3ef1329f0..28ba9a083 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
@@ -26,6 +26,7 @@ import com.android.tools.metalava.libcoreNonNullSource
 import com.android.tools.metalava.libcoreNullableSource
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -256,7 +257,8 @@ class NullabilityLintTest : DriverTest() {
                     ),
                     androidxNullableSource,
                     androidxNonNullSource
-                )
+                ),
+            extraArguments = arrayOf(ARG_HIDE, Issues.INHERIT_CHANGES_SIGNATURE.name),
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
index a3035bbe8..f23d34846 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
@@ -35,7 +35,7 @@ abstract class AbstractStubsTest : DriverTest() {
         extraArguments: Array<String> = emptyArray(),
         docStubs: Boolean = false,
         showAnnotations: Array<String> = emptyArray(),
-        skipEmitPackages: List<String> = listOf("java.lang", "java.util", "java.io"),
+        skipEmitPackages: List<String>? = null,
         format: FileFormat = FileFormat.LATEST,
         sourceFiles: Array<TestFile> = emptyArray(),
         signatureSources: Array<String> = emptyArray(),
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
index 3f21f413c..6f46602d3 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
@@ -19,13 +19,12 @@ package com.android.tools.metalava.stub
 import com.android.tools.metalava.ARG_EXCLUDE_ALL_ANNOTATIONS
 import com.android.tools.metalava.ARG_EXCLUDE_ANNOTATION
 import com.android.tools.metalava.ARG_PASS_THROUGH_ANNOTATION
+import com.android.tools.metalava.TYPE_USE_FORMAT
 import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.libcoreNonNullSource
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.requiresApiSource
-import com.android.tools.metalava.supportParameterName
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -67,11 +66,10 @@ class StubsAnnotationTest : AbstractStubsTest() {
 
     @Test
     fun `Remove Hidden Annotations`() {
-        // When APIs reference annotations that are hidden, make sure the're excluded from the stubs
-        // and
-        // signature files
+        // When APIs reference annotations that are hidden, make sure they're excluded from the
+        // stubs and signature files
         checkStubs(
-            format = FileFormat.V2,
+            format = TYPE_USE_FORMAT,
             sourceFiles =
                 arrayOf(
                     java(
@@ -101,25 +99,14 @@ class StubsAnnotationTest : AbstractStubsTest() {
                     )
                 ),
             api =
-                if (SUPPORT_TYPE_USE_ANNOTATIONS) {
-                    """
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public void foo(int, java.util.Map<java.lang.String!,java.lang.String!>!);
-                  }
-                }
                 """
-                } else {
-                    """
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public void foo(int, java.util.Map<java.lang.String,java.lang.String>);
-                  }
-                }
-                """
-                },
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public foo(_: int, _: java.util.Map<String,String>): void;
+                      }
+                    }
+                """,
             source =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     """
@@ -223,25 +210,29 @@ class StubsAnnotationTest : AbstractStubsTest() {
     @Test
     fun `Rewrite libcore annotations`() {
         check(
+            format = TYPE_USE_FORMAT,
             checkCompilation = true,
             sourceFiles =
                 arrayOf(
                     java(
-                        "package my.pkg;\n" +
-                            "public class String {\n" +
-                            "public String(char @libcore.util.NonNull [] value) { throw new RuntimeException(\"Stub!\"); }\n" +
-                            "}\n"
-                    )
+                        """
+                            package my.pkg;
+                            public class String {
+                            public String(char @libcore.util.NonNull [] value) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
+                    libcoreNonNullSource,
                 ),
             expectedIssues = "",
             api =
                 """
                     package my.pkg {
                       public class String {
-                        ctor public String(char[]);
+                        ctor public String(_: char @NonNull []);
                       }
                     }
-                    """,
+                """,
             stubFiles =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     arrayOf(
@@ -289,6 +280,8 @@ class StubsAnnotationTest : AbstractStubsTest() {
                     ),
                     libcoreNonNullSource
                 ),
+            // Override default to emit libcore.util classes.
+            skipEmitPackages = emptyList(),
             expectedIssues = "",
             api =
                 """
@@ -338,11 +331,8 @@ class StubsAnnotationTest : AbstractStubsTest() {
                     }
                     """
                     ),
-                    supportParameterName,
                     requiresApiSource,
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             source =
                 """
@@ -379,12 +369,6 @@ class StubsAnnotationTest : AbstractStubsTest() {
             expectedIssues = "",
             api =
                 """
-                    package androidx.annotation {
-                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.CONSTRUCTOR}) public @interface RequiresApi {
-                        method public abstract int api() default 1;
-                        method public abstract int value() default 1;
-                      }
-                    }
                     package my.pkg {
                       public class MyClass {
                         ctor public MyClass();
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
index a1088ab4e..3350bb0d1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
@@ -931,7 +931,7 @@ class StubsConstructorTest : AbstractStubsTest() {
     @Test
     fun `File facade constructor`() {
         check(
-            format = FileFormat.V2,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     kotlin(
@@ -945,11 +945,10 @@ class StubsConstructorTest : AbstractStubsTest() {
                 ),
             api =
                 """
-                    // Signature format: 2.0
                     package test.pkg {
                       public final class ConstantsKt {
-                        property public static final String CONSTANT;
-                        field @NonNull public static final String CONSTANT = "CONSTANT";
+                        property public static String CONSTANT;
+                        field public static final String CONSTANT = "CONSTANT";
                       }
                     }
                 """,
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
index 202a81fa9..c9eb8aff2 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
@@ -22,7 +22,6 @@ import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.restrictToSource
-import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.html
 import com.android.tools.metalava.testing.java
 import org.junit.Test
@@ -51,8 +50,6 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                     """
                     ),
                     androidxNullableSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             warnings = "",
             api =
@@ -183,8 +180,6 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                         .indented(),
                     java("""package test.pkg; public abstract class Class1 { }"""),
                     restrictToSource,
-                    // Hide androidx.annotation classes.
-                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
index 9a6f9aeff..fb211dc23 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
@@ -23,7 +23,6 @@ import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.supportParameterName
 import com.android.tools.metalava.systemApiSource
 import com.android.tools.metalava.testApiSource
 import com.android.tools.metalava.testing.java
@@ -400,38 +399,6 @@ class StubsTest : AbstractStubsTest() {
         )
     }
 
-    @Test
-    fun `Parameter Names in Java`() {
-        // Java code which explicitly specifies parameter names: make sure stub uses
-        // parameter name
-        checkStubs(
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import androidx.annotation.ParameterName;
-
-                    public class Foo {
-                        public void foo(int javaParameter1, @ParameterName("publicParameterName") int javaParameter2) {
-                        }
-                    }
-                    """
-                    ),
-                    supportParameterName
-                ),
-            source =
-                """
-                package test.pkg;
-                @SuppressWarnings({"unchecked", "deprecation", "all"})
-                public class Foo {
-                public Foo() { throw new RuntimeException("Stub!"); }
-                public void foo(int javaParameter1, int publicParameterName) { throw new RuntimeException("Stub!"); }
-                }
-                 """
-        )
-    }
-
     @Test
     fun `DocOnly members should be omitted`() {
         // When marked @doconly don't include in stubs or signature files
@@ -547,7 +514,7 @@ class StubsTest : AbstractStubsTest() {
         // Like previous test, but without compatibility mode: ensures that we
         // use super classes of filtered throwables
         checkStubs(
-            format = FileFormat.V3,
+            format = FileFormat.V4,
             sourceFiles =
                 arrayOf(
                     java(
@@ -593,7 +560,7 @@ class StubsTest : AbstractStubsTest() {
             warnings = "",
             api =
                 """
-                // Signature format: 3.0
+                // Signature format: 4.0
                 package test.pkg {
                   public class Generics {
                     ctor public Generics();
diff --git a/metalava/src/test/resources/source-model-provider-baseline.txt b/metalava/src/test/resources/source-model-provider-baseline.txt
index 2648e1287..62b916023 100644
--- a/metalava/src/test/resources/source-model-provider-baseline.txt
+++ b/metalava/src/test/resources/source-model-provider-baseline.txt
@@ -19,7 +19,7 @@ com.android.tools.metalava.ApiFileTest
   Check generic type signature insertion[turbine]
   Check skipping implicit final or deprecated override[turbine]
   Check various generics signature subtleties[turbine]
-  Kotlin expect-actual with JvmOverloads[psi,k2]
+  Kotlin expect-actual with JvmOverloads constructors[psi,k2]
 
 com.android.tools.metalava.CoreApiTest
   Hidden with --hide-annotation[turbine]
@@ -31,6 +31,7 @@ com.android.tools.metalava.DuplicateClassTest
 com.android.tools.metalava.ExtractAnnotationsTest
   Check java typedef extraction and warning about non-source retention of typedefs[turbine]
   Check warning about unexpected returns from typedef method[turbine]
+  Extract annotations from class[turbine]
   Extract permission annotations[turbine]
   Include merged annotations in exported source annotations[turbine]
   Inlining typedef signatures in api files[turbine]
@@ -39,30 +40,6 @@ com.android.tools.metalava.ExtractAnnotationsTest
   Test generics in XML attributes are encoded[turbine]
   Test string literal encoding[turbine]
 
-com.android.tools.metalava.FlaggedApiTest
-  Basic test that FlaggedApi annotated items can be hidden[turbine,public with flagged api]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,public without flagged api, with foo_bar]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,system with flagged api]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,system without flagged api, with foo_bar]
-  Test interface fields behave correctly when flagged[turbine,public with flagged api]
-  Test interface fields behave correctly when flagged[turbine,public without flagged api, with foo_bar]
-  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system with flagged api]
-  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system without flagged api, with foo_bar]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public with flagged api]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public without flagged api, with foo_bar]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system with flagged api]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system without flagged api, with foo_bar]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public with flagged api]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public without flagged api, with foo_bar]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system with flagged api]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system without flagged api, with foo_bar]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib with flagged api]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib without flagged api, with foo_bar]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,system with flagged api]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,system without flagged api, with foo_bar]
-  Test that pulling method up into super class can be reverted[turbine,public with flagged api]
-  Test that pulling method up into super class can be reverted[turbine,public without flagged api, with foo_bar]
-
 com.android.tools.metalava.Java9LanguageFeaturesTest
   Basic class signature extraction[turbine]
   Using JDK APIs[turbine]
@@ -90,8 +67,29 @@ com.android.tools.metalava.NormalizeOutputAnnotationTest
 com.android.tools.metalava.NullabilityAnnotationsValidatorTest
   Using class list[turbine]
 
-com.android.tools.metalava.NullnessMigrationTest
-  Convert libcore nullness annotations to support[turbine]
+com.android.tools.metalava.ParameterizedFlaggedApiTest
+  Basic test that FlaggedApi annotated items can be hidden[turbine,public finalize foo_bar]
+  Basic test that FlaggedApi annotated items can be hidden[turbine,public keep all]
+  Basic test that FlaggedApi annotated items can be hidden[turbine,system finalize foo_bar]
+  Basic test that FlaggedApi annotated items can be hidden[turbine,system keep all]
+  Test interface fields behave correctly when flagged[turbine,public finalize foo_bar]
+  Test interface fields behave correctly when flagged[turbine,public keep all]
+  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
+  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system keep all]
+  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public finalize foo_bar]
+  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public keep all]
+  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
+  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system keep all]
+  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public finalize foo_bar]
+  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public keep all]
+  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
+  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system keep all]
+  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib finalize foo_bar]
+  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib keep all]
+  Test that previously released APIs which are now system and flagged are not removed[turbine,system finalize foo_bar]
+  Test that previously released APIs which are now system and flagged are not removed[turbine,system keep all]
+  Test that pulling method up into super class can be reverted[turbine,public finalize foo_bar]
+  Test that pulling method up into super class can be reverted[turbine,public keep all]
 
 com.android.tools.metalava.PolymorphicMethodsTest
   Test MethodHandle[turbine]
@@ -134,8 +132,12 @@ com.android.tools.metalava.TypeUseAnnotationFilteringTest
 com.android.tools.metalava.UnhideApisTest
   Including private interfaces from types[turbine]
 
+com.android.tools.metalava.VisibleForTestingTest
+  Test VisibleForTesting constants - java[turbine]
+
 com.android.tools.metalava.apilevels.ApiGeneratorTest
   APIs annotated with suppress-compatibility-meta-annotations appear in output[turbine]
+  Generate API for system surface from jar[turbine]
 
 com.android.tools.metalava.compatibility.CompatibilityCheckTest
   Conversion from AutoCloseable to Closeable is not API-breaking[turbine]
@@ -146,9 +148,6 @@ com.android.tools.metalava.compatibility.CompatibilityCheckTest
   No issues using the same classpath class twice[turbine]
   Removed method from classpath[turbine]
 
-com.android.tools.metalava.compatibility.ParameterNameChangeTest
-  Flag renaming a parameter from the classpath[turbine]
-
 com.android.tools.metalava.doc.DocAnalyzerRangeTest
   Add new parameter when doc exists but no param doc[turbine]
   Add new parameter when no doc exists[turbine]
@@ -179,6 +178,18 @@ com.android.tools.metalava.doc.DocAnalyzerTest
   Warn about multiple threading annotations[turbine]
   memberDoc crash[turbine]
 
+com.android.tools.metalava.doc.RestrictedForEnvironmentTest
+  Check RestrictedForEnvironment handling for SDK_SANDBOX env - android[turbine]
+  Check RestrictedForEnvironment handling for SDK_SANDBOX env - androidx[turbine]
+  Check RestrictedForEnvironment handling for fully nested SDK_SANDBOX env - androidx[turbine]
+  Check RestrictedForEnvironment handling for multiple annotations - androidx[turbine]
+  Check RestrictedForEnvironment handling for partial nested SDK_SANDBOX env - androidx[turbine]
+
+com.android.tools.metalava.jar.StandaloneJarCodebaseLoaderTest
+  Test jar loader does not freeze codebase[turbine]
+  Test jar loader freezes codebase[turbine]
+  Test loaded jar depends on class path[turbine]
+
 com.android.tools.metalava.lint.ApiLintTest
   CompletableFuture and plain Future not allowed[turbine]
   Listener replaceable with OutcomeReceiver or ListenableFuture[turbine]
diff --git a/metalava/src/testdata/prebuilts/sdk/30/public/api.txt b/metalava/src/testdata/prebuilts/sdk/30/public/api.txt
new file mode 100644
index 000000000..79ed59941
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/30/public/api.txt
@@ -0,0 +1,30 @@
+// Signature format: 2.0
+package android.test {
+  @Deprecated public class ClassAddedAndDeprecatedInApi30 {
+    ctor @Deprecated public ClassAddedAndDeprecatedInApi30(float);
+
+    // Do not explicitly deprecate this in API 30 as earlier releases did not consistent explicitly deprecate members of
+    // deprecated classes.
+    ctor public ClassAddedAndDeprecatedInApi30(int);
+
+    method @Deprecated public void methodExplicitlyDeprecated();
+
+    // Do not explicitly deprecate this in API 30 as earlier releases did not consistent explicitly deprecate members of
+    // deprecated classes.
+    method public void methodImplicitlyDeprecated();
+
+    field @Deprecated public static final int FIELD_EXPLICITLY_DEPRECATED = 1;
+
+    // Do not explicitly deprecate this in API 30 as earlier releases did not consistent explicitly deprecate members of
+    // deprecated classes.
+    field public static final int FIELD_IMPLICITLY_DEPRECATED = 2;
+  }
+  public class ClassAddedInApi30 {
+    method public void methodAddedInApi30();
+  }
+}
+package java.lang {
+  public class Object {
+    ctor public Object();
+  }
+}
diff --git a/metalava/src/testdata/prebuilts/sdk/31/public/api.txt b/metalava/src/testdata/prebuilts/sdk/31/public/api.txt
new file mode 100644
index 000000000..a7830b054
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/31/public/api.txt
@@ -0,0 +1,41 @@
+// Signature format: 2.0
+package android.test {
+  @Deprecated public class ClassAddedAndDeprecatedInApi30 {
+    ctor @Deprecated public ClassAddedAndDeprecatedInApi30(float);
+
+    // Explicitly deprecate this in API 31 to show the impact inconsistent handling of inherited deprecation status
+    // across releases has on api-versions.xml output.
+    ctor @Deprecated public ClassAddedAndDeprecatedInApi30(int);
+
+    method @Deprecated public void methodExplicitlyDeprecated();
+
+    // Explicitly deprecate this in API 31 to show the impact inconsistent handling of inherited deprecation status
+    // across releases has on api-versions.xml output.
+    method @Deprecated public void methodImplicitlyDeprecated();
+
+    field @Deprecated public static final int FIELD_EXPLICITLY_DEPRECATED = 1;
+
+    // Explicitly deprecate this in API 31 to show the impact inconsistent handling of inherited deprecation status
+    // across releases has on api-versions.xml output.
+    field @Deprecated public static final int FIELD_IMPLICITLY_DEPRECATED = 2;
+  }
+  public class ClassAddedInApi30 {
+    method public void methodAddedInApi30();
+    method public void methodAddedInApi31();
+  }
+  public class ClassAddedInApi31AndExt2 {
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
+    method public void methodAddedInApi31AndExt2();
+  }
+  public class ClassAddedInExt1 {
+    field public static final int FIELD_ADDED_IN_EXT_1 = 1;
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 2;
+    method public void methodAddedInExt1();
+    method public void methodAddedInApi31AndExt2();
+  }
+}
+package java.lang {
+  public class Object {
+    ctor public Object();
+  }
+}
diff --git a/metalava/src/testdata/prebuilts/sdk/README.md b/metalava/src/testdata/prebuilts/sdk/README.md
new file mode 100644
index 000000000..8e51046dc
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/README.md
@@ -0,0 +1,8 @@
+A prebuilts/sdk tree containing signature files for metalava use in unit tests.
+
+The project emulates the following history, in order of earliest to latest event:
+
+- finalized Android API 30 "Android R" (android-30)
+- finalized SDK extensions "R-ext" version 1 (android-30-ext1)
+- finalized Android API 31 "Android S" and SDK extensions "S-ext", version 2, at the same time (android-31-ext2)
+- finalized SDK extensions "S-ext", version 3 (android-31-ext3)
diff --git a/metalava/src/testdata/prebuilts/sdk/extensions/1/public/framework-ext.txt b/metalava/src/testdata/prebuilts/sdk/extensions/1/public/framework-ext.txt
new file mode 100644
index 000000000..f864de775
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/extensions/1/public/framework-ext.txt
@@ -0,0 +1,7 @@
+// Signature format: 2.0
+package android.test {
+  public class ClassAddedInExt1 {
+    field public static final int FIELD_ADDED_IN_EXT_1 = 1;
+    method public void methodAddedInExt1();
+  }
+}
diff --git a/metalava/src/testdata/prebuilts/sdk/extensions/2/public/framework-ext.txt b/metalava/src/testdata/prebuilts/sdk/extensions/2/public/framework-ext.txt
new file mode 100644
index 000000000..f3390850a
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/extensions/2/public/framework-ext.txt
@@ -0,0 +1,22 @@
+// Signature format: 2.0
+package android.test {
+  public class ClassAddedInApi30 extends android.test.MarkerSuperClass implements android.test.MarkerInterface {
+    method public void methodAddedInApi30();
+    method public void methodAddedInApi31();
+  }
+  public class ClassAddedInApi31AndExt2 {
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
+    method public void methodAddedInApi31AndExt2();
+  }
+  public class ClassAddedInExt1 {
+    field public static final int FIELD_ADDED_IN_EXT_1 = 1;
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 2;
+    method public void methodAddedInExt1();
+    method public void methodAddedInApi31AndExt2();
+  }
+  public interface MarkerInterface {
+  }
+  public class MarkerSuperClass {
+    ctor public MarkerSuperClass();
+  }
+}
diff --git a/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt b/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt
new file mode 100644
index 000000000..ed69a935f
--- /dev/null
+++ b/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt
@@ -0,0 +1,26 @@
+// Signature format: 2.0
+package android.test {
+  public class ClassAddedInApi31AndExt2 {
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
+    field public static final int FIELD_ADDED_IN_EXT_3 = 2;
+    method public void methodAddedInApi31AndExt2();
+    method public void methodAddedInExt3();
+  }
+  public class ClassAddedInExt1 {
+    field public static final int FIELD_ADDED_IN_EXT_1 = 1;
+    field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 2;
+    field public static final int FIELD_ADDED_IN_EXT_3 = 2;
+    method public void methodAddedInExt1();
+    method public void methodAddedInApi31AndExt2();
+    method public void methodAddedInExt3();
+  }
+  public class ClassAddedInExt3 {
+    field public static final int FIELD_ADDED_IN_EXT_3 = 1;
+    method public void methodAddedInExt3();
+  }
+  public interface MarkerInterface {
+  }
+  public class MarkerSuperClass {
+    ctor public MarkerSuperClass();
+  }
+}
diff --git a/scripts/gather-android-metalava-artifacts.py b/scripts/gather-android-metalava-artifacts.py
index ee3d9b234..dfd573754 100755
--- a/scripts/gather-android-metalava-artifacts.py
+++ b/scripts/gather-android-metalava-artifacts.py
@@ -14,6 +14,7 @@
 #  limitations under the License.
 
 import argparse
+import dataclasses
 import os
 from pathlib import Path
 import shutil
@@ -56,25 +57,59 @@ def parse_command_line_args(args):
     return args_parser.parse_args(args)
 
 
+@dataclasses.dataclass()
+class Target:
+    """A build target.
+
+    This consists of a file to build and an optional output file name to use to
+    differentiate build files that have the same base name.
+    """
+
+    # File to build and copy into the output directory.
+    buildFile: str
+
+    # Output file.
+    outputFile: str = ""
+
+
+def create_targets(files):
+    """Create Target instances from a list of build files.
+
+    :param files: The list of build files. :return: A list of Target instances.
+    """
+    return [x if isinstance(x, Target) else Target(x) for x in files]
+
+
 def default_stub_files():
     """:return: A representative sample list of stub source jars generated by the Android build using Metalava"""
-    return [
-        f"out/target/common/docs/{x}-stubs.srcjar"
+    return create_targets([
+        f"out/soong/.intermediates/frameworks/base/api/{x}/android_common/everything/{x}-stubs.srcjar"
         for x in [
             "api-stubs-docs-non-updatable",
             "system-api-stubs-docs-non-updatable",
             "test-api-stubs-docs-non-updatable",
             "module-lib-api-stubs-docs-non-updatable",
         ]
-    ]
+    ])
 
 
 def default_doc_stub_files():
     """:return: A representative sample list of doc stub source jars generated by the Android build using Metalava"""
-    return [
-        "out/target/common/docs/framework-doc-stubs-stubs.srcjar",
-        "out/target/common/docs/framework-doc-system-stubs-stubs.srcjar",
-    ]
+    return create_targets([
+        f"out/soong/.intermediates/frameworks/base/api/{x}/android_common/exportable/{x}-stubs.srcjar"
+        for x in [
+            "framework-doc-stubs",
+            "framework-doc-system-stubs",
+        ]
+    ])
+
+
+def default_annotation_zip_files():
+    """:return: A representative sample list of annotation zip files generated by the Android build using Metalava"""
+    return create_targets([
+        "out/soong/.intermediates/frameworks/base/api/framework-doc-stubs/android_common/exportable/framework-doc-stubs_annotations.zip",
+        "out/soong/.intermediates/frameworks/base/api/sdk-annotations.zip/android_common/gen/annotations.zip",
+    ])
 
 
 def default_api_version_files():
@@ -82,30 +117,36 @@ def default_api_version_files():
 
     Metalava.
     """
-    return [
+    return create_targets([
         "out/soong/lint/api_versions_public.xml",
         "out/soong/lint/api_versions_system.xml",
         "out/soong/lint/api_versions_module_lib.xml",
         "out/soong/lint/api_versions_system_server.xml",
-        "out/target/common/obj/PACKAGING/api_versions_module_lib_complete_generated-api-versions.xml",
-        "out/target/common/obj/PACKAGING/api_versions_system_server_complete_generated-api-versions.xml",
-    ]
+        Target(
+            buildFile="out/soong/.intermediates/frameworks/base/api/api_versions_module_lib_complete/android_common/everything/api-versions.xml",
+            outputFile="api_versions_module_lib_complete.xml",
+        ),
+        Target(
+            buildFile="out/soong/.intermediates/frameworks/base/api/api_versions_system_server_complete/android_common/everything/api-versions.xml",
+            outputFile="api_versions_system_server_complete.xml",
+        ),
+    ])
 
 
 def default_jdiff_files():
     """:return: A representative sample list of JDiff files created by the Android build using Metalava."""
-    return [
+    return create_targets([
         # JDiff files generated from jar files.
-        "out/target/common/obj/api.xml",
-        "out/target/common/obj/system-api.xml",
-        "out/target/common/obj/module-lib-api.xml",
-        "out/target/common/obj/system-server-api.xml",
-        "out/target/common/obj/test-api.xml",
+        "out/soong/.intermediates/frameworks/base/api/android_stubs_current/android_common/api.xml",
+        "out/soong/.intermediates/frameworks/base/api/android_system_stubs_current/android_common/system-api.xml",
+        "out/soong/.intermediates/frameworks/base/api/android_module_lib_stubs_current/android_common/module-lib-api.xml",
+        "out/soong/.intermediates/frameworks/base/api/android_system_server_stubs_current/android_common/system-server-api.xml",
+        "out/soong/.intermediates/frameworks/base/api/android_test_stubs_current/android_common/test-api.xml",
         # JDiff files generated from txt files.
         "out/soong/.intermediates/packages/services/Car/car-lib/android.car-test-stubs-jdiff/gen/car-test-api.xml",
         "out/soong/.intermediates/packages/services/Car/car-lib/android.car-stubs-jdiff/gen/car-api.xml",
         "out/soong/.intermediates/packages/services/Car/car-lib/android.car-system-stubs-jdiff/gen/car-system-api.xml",
-        ""# JDiff files generated from txt files and then compressed using gzip..
+        ""  # JDiff files generated from txt files and then compressed using gzip..
         "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-base-current-api-gz/gen/android-test-base-current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-mock-current-api-gz/gen/android-test-mock-current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-runner-current-api-gz/gen/android-test-runner-current.api.gz",
@@ -114,17 +155,16 @@ def default_jdiff_files():
         "out/soong/.intermediates/cts/tests/signature/api/cts-current-api-gz/android_common/gen/current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-system-current-api-gz/android_common/gen/system-current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-system-removed-api-gz/android_common/gen/system-removed.api.gz",
-
-    ]
+    ])
 
 
 def default_dex_writer_files():
     """:return: A representative sample list of dex writer related files created by the Android build using Metalava."""
-    return [
+    return create_targets([
         # This is not actually a dex writer file but it contains information derived from lots of dex writer files so
         # any differences in the dex writer files will affect this file.
         "out/soong/hiddenapi/hiddenapi-flags.csv",
-    ]
+    ])
 
 
 def default_custom_files(top):
@@ -133,32 +173,32 @@ def default_custom_files(top):
     least in part, on Metalava.
     :return: A list of custom files.
     """
-    product_out = Path(os.environ.get("ANDROID_PRODUCT_OUT")).relative_to(top)
-    return [
-        f"{product_out}/obj/ETC/flag-api-mapping-{surface}_intermediates/flag-api-mapping-{surface}"
-        for surface in [
-            "PublicApi",
-            "SystemApi",
-            "ModuleLibApi",
-            "SystemServerApi",
+    return create_targets([
+        f"out/soong/.intermediates/frameworks/base/api/flag-api-mapping-{surface}/android_common/gen/{textproto}"
+        for surface, textproto in [
+            ("PublicApi", "flag_api_map.textproto"),
+            ("SystemApi", "system_flag_api_map.textproto"),
+            ("ModuleLibApi", "module_lib_flag_api_map.textproto"),
+            ("SystemServerApi", "system_server_flag_api_map.textproto"),
         ]
-    ]
+    ])
 
 
 def construct_target_list(args, top):
     """Generate a list of targets from the supplied arguments
 
     :param args: the command line arguments.
-    :return: a non-empty list of targets to build.
+    :return: a non-empty list of Target instances to build.
     """
     targets = []
     # If any custom options have been provided then build them.
     if args.stub_src_jar:
-        targets += args.stub_src_jar
+        targets += create_targets(args.stub_src_jar)
     # If no custom targets have been provided then use the default targets.
     if not targets:
         targets += default_stub_files()
         targets += default_doc_stub_files()
+        targets += default_annotation_zip_files()
         targets += default_jdiff_files()
         targets += default_api_version_files()
         targets += default_dex_writer_files()
@@ -184,7 +224,7 @@ def main(args):
     targets = construct_target_list(args, top)
 
     # Build the targets.
-    build_targets(targets)
+    build_targets([x.buildFile for x in targets])
 
     # Create the output directory and copy the targets into it.
     copy_targets(output_dir, targets)
@@ -196,8 +236,15 @@ def copy_targets(output_dir, targets):
     print()
     print(f"Copying the following targets into '{output_dir}':")
     for t in targets:
-        print(f"    {t}")
-        shutil.copy(t, output_dir)
+        source = t.buildFile
+        output_file = t.outputFile
+        if output_file == "":
+            print(f"    {source}")
+            shutil.copy(source, output_dir)
+        else:
+            destination = f"{output_dir}/{output_file}"
+            print(f"    {source} -> {output_file}")
+            shutil.copy(source, destination)
     print()
 
 
diff --git a/version.properties b/version.properties
index 69621fcf4..77e4b2c6f 100644
--- a/version.properties
+++ b/version.properties
@@ -2,4 +2,4 @@
 # Version definition
 # This file is read by gradle build scripts, but also packaged with metalava
 # as a resource for the Version classes to read.
-metalavaVersion=1.0.0-alpha12
+metalavaVersion=1.0.0-alpha13
```

