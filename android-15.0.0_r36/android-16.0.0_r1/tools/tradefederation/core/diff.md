```diff
diff --git a/.classpath b/.classpath
index a7c1ebc54..74bf0f716 100644
--- a/.classpath
+++ b/.classpath
@@ -28,13 +28,13 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/devtools-annotations/devtools-annotations-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/kxml2/kxml2-2.3.0.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/sdklib/sdklib-prebuilt.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.23.0.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.36.0.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/protobuf/libprotobuf-java-full/linux_glibc_common/javac/libprotobuf-java-full.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/junit-params/junit-params/linux_glibc_common/combined/junit-params.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/junit/junit/linux_glibc_common/combined/junit.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/tools/common/google-api-services-compute/google-api-services-compute/linux_glibc_common/combined/google-api-services-compute.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/frameworks/platformprotos-prebuilt.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jacoco/jacoco-cli/linux_glibc_common/combined/jacoco-cli.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jacoco/jacoco-cli/linux_glibc_common/withres/jacoco-cli.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/tools/common/google-api-services-storage/1.24.1/google-api-services-storage-v1-rev155-1.24.1.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-protos/linux_glibc_common/combined/tradefed-protos.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/gson/gson/linux_glibc_common/javac/gson.jar"/>
@@ -43,11 +43,11 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/perfetto/perfetto_metrics-full/linux_glibc_common/combined/perfetto_metrics-full.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/snakeyaml/snakeyaml/linux_glibc_common/javac/snakeyaml.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/tools/common/m2/diffutils-prebuilt-jar/linux_glibc_common/combined/diffutils-prebuilt-jar.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/misc/common/commons-cli/commons-cli-1.2/linux_glibc_common/combined/commons-cli-1.2.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/commons-cli/commons-cli-1.2.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/grpc-grpc-java/grpc-java/linux_glibc_common/combined/grpc-java.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/tools/common/google-api-java-client/1.33.2/google-api-java-client-assembly/linux_glibc_common/combined/google-api-java-client-assembly.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/asuite/asuite_proto_java/linux_glibc_common/combined/asuite_proto_java.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-service-grpc-lib/linux_glibc_common/combined/tradefed-service-grpc-lib.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-service-grpc-lib/linux_glibc_common/withres/tradefed-service-grpc-lib.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jline/jline/linux_glibc_common/combined/jline.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/aoa_helper/aoa-helper/linux_glibc_common/combined/aoa-helper.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-invocation-grpc/linux_glibc_common/javac/tradefed-invocation-grpc.jar"/>
diff --git a/Android.bp b/Android.bp
index d141c952a..f4d8b1369 100644
--- a/Android.bp
+++ b/Android.bp
@@ -102,6 +102,27 @@ java_library_host {
     java_version: "11",
 }
 
+java_library_host {
+    name: "resultdb-grpc",
+    srcs: ["proto/resultdb/recorder.proto"],
+    libs: [
+        "resultdb-protos",
+        "grpc-java",
+        "guava",
+        "javax-annotation-api-prebuilt-host-jar",
+        "googleapis-field-behavior-java-proto",
+    ],
+    proto: {
+        include_dirs: [
+            "external/protobuf/src",
+            "external/googleapis",
+        ],
+        plugin: "grpc-java-plugin",
+    },
+    // b/267831518: Pin tradefed and dependencies to Java 11.
+    java_version: "11",
+}
+
 java_library_host {
     name: "tradefed-invocation-grpc",
     srcs: [
@@ -221,7 +242,6 @@ tradefed_java_library_host {
     static_libs: [
         "tradefed-lib-core",
         "tradefed-test-framework",
-        "resultdb-protos",
     ],
     required: [
         "loganalysis",
@@ -274,9 +294,12 @@ java_library_host {
         "tradefed-invocation-grpc",
         "tradefed-device-manager-grpc",
         "tradefed-dynamic-sharding-grpc",
+        "resultdb-grpc",
+        "resultdb-protos",
         "aoa-helper",
         "error_prone_annotations",
         "google-api-java-client-assembly",
+        "googleapis-field-behavior-java-proto",
         "auto_value_annotations",
         "google-api-services-compute",
         "google-api-services-storage",
@@ -386,6 +409,7 @@ sh_binary_host {
 sh_binary_host {
     name: "tradefed_win",
     src: "tradefed_win.bat",
+    filename_from_src: true,
 }
 
 sh_binary_host {
diff --git a/COVERAGE_OWNERS b/COVERAGE_OWNERS
new file mode 100644
index 000000000..685192968
--- /dev/null
+++ b/COVERAGE_OWNERS
@@ -0,0 +1,6 @@
+allenhair@google.com
+qingshen@google.com
+sophiez@google.com
+yifengzeng@google.com
+yimingpan@google.com
+zhoudiqiu@google.com
diff --git a/OWNERS b/OWNERS
index 94a1e2dfa..5bc167261 100644
--- a/OWNERS
+++ b/OWNERS
@@ -2,10 +2,10 @@
 dshi@google.com
 frankfeng@google.com
 guangzhu@google.com
+jahinimtiaz@google.com
 jdesprez@google.com
-murj@google.com
 tsu@google.com
 
 # Restrict build related changes to core harness team
 per-file Android.bp,Android.mk=set noparent
-per-file Android.bp,Android.mk=jdesprez@google.com,guangzhu@google.com,frankfeng@google.com,murj@google.com
+per-file Android.bp,Android.mk=jdesprez@google.com,guangzhu@google.com,frankfeng@google.com,jahinimtiaz@google.com
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
index 5d188ea3c..895c908fe 100644
--- a/PREUPLOAD.cfg
+++ b/PREUPLOAD.cfg
@@ -5,8 +5,3 @@ pylint = true
 [Tool Paths]
 google-java-format = ${REPO_ROOT}/prebuilts/tools/common/google-java-format/google-java-format
 google-java-format-diff = ${REPO_ROOT}/prebuilts/tools/common/google-java-format/google-java-format-diff.py
-
-[Hook Scripts]
-# `^.` is a RegExr that matches any character at the beginning, so this hook
-# is basically applied to ALL files in a git commit.
-aospcheck_hook = ${REPO_ROOT}/tools/tradefederation/core/aosp_sha.sh ${PREUPLOAD_COMMIT} "^."
diff --git a/aoa_helper/src/com/android/helper/aoa/AoaHID.java b/aoa_helper/src/com/android/helper/aoa/AoaHID.java
index b420a6c0f..ccc51ac22 100644
--- a/aoa_helper/src/com/android/helper/aoa/AoaHID.java
+++ b/aoa_helper/src/com/android/helper/aoa/AoaHID.java
@@ -29,7 +29,7 @@ enum AoaHID {
             new Integer[] {
                 0x05, 0x0D, //      Usage Page (Digitizer)
                 0x09, 0x04, //      Usage (Touch Screen)
-                0xA1, 0x01, //      Collection (Application)
+                0xA1, 0x00, //      Collection (Physical)
                 0x09, 0x32, //          Usage (In Range) - proximity to screen
                 0x09, 0x33, //          Usage (Touch) - contact with screen
                 0x15, 0x00, //          Logical Minimum (0)
diff --git a/aosp_sha.sh b/aosp_sha.sh
deleted file mode 100755
index f25fcdcb7..000000000
--- a/aosp_sha.sh
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/bash
-LOCAL_DIR="$( dirname "${BASH_SOURCE}" )"
-
-if git branch -vv | grep -q -P "^\*[^\[]+\[aosp/"; then
-    # Change appears to be in AOSP
-    exit 0
-else
-    # Change appears to be non-AOSP; search for files
-    count=0
-    while read -r file ; do
-        if (( count == 0 )); then
-            echo
-        fi
-        echo -e "\033[0;31mThe source of truth for '$file' is in AOSP.\033[0m"
-        (( count++ ))
-    done < <(git show --name-only --pretty=format: $1 | grep -- "$2")
-    if (( count != 0 )); then
-        echo
-        echo "If your change contains no confidential details (such as security fixes), please"
-        echo "upload and merge this change at https://android-review.googlesource.com/."
-        echo
-        exit 1
-    fi
-fi
diff --git a/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java b/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
index 236d40854..2f42856a5 100644
--- a/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
+++ b/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
@@ -15,6 +15,8 @@
  */
 package com.android.tradefed.util.avd;
 
+import com.android.tradefed.log.LogUtil.CLog;
+
 import com.google.gson.Gson;
 
 import java.io.IOException;
@@ -23,6 +25,8 @@ import java.net.http.HttpClient;
 import java.net.http.HttpRequest;
 import java.net.http.HttpResponse;
 import java.net.http.HttpResponse.BodyHandlers;
+import java.nio.file.Path;
+import java.util.List;
 
 /**
  * Java implementation of Cuttlefish Host Orchestator API.
@@ -40,6 +44,20 @@ public class HostOrchestratorClient {
         public boolean done;
     }
 
+    public static final class Cvd {
+        public String group;
+        public String name;
+        public String status;
+    }
+
+    public static final class ListCvdsResponse {
+        public List<Cvd> cvds;
+    }
+
+    public static HttpRequest buildListCvdsRequest(String baseURL) {
+        return HttpRequest.newBuilder().uri(URI.create(String.format("%s/cvds", baseURL))).build();
+    }
+
     // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L78
     public static HttpRequest buildGetOperationRequest(String baseURL, String name) {
         return HttpRequest.newBuilder()
@@ -47,16 +65,51 @@ public class HostOrchestratorClient {
                 .build();
     }
 
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L82
+    public static HttpRequest buildGetOperationResultRequest(String baseURL, String name) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/operations/%s/result", baseURL, name)))
+                .build();
+    }
+
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L69
+    public static HttpRequest buildCreateBugreportRequest(String baseURL, String group) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/:bugreport", baseURL, group)))
+                .POST(java.net.http.HttpRequest.BodyPublishers.noBody())
+                .build();
+    }
+
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L75
+    public static HttpRequest buildPowerwashRequest(String baseURL, String group, String name) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/%s/:powerwash", baseURL, group, name)))
+                .POST(java.net.http.HttpRequest.BodyPublishers.noBody())
+                .build();
+    }
+
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L71
+    public static HttpRequest buildRemoveInstanceRequest(
+            String baseURL, String group, String name) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/%s", baseURL, group, name)))
+                .DELETE()
+                .build();
+    }
+
     public static interface IHoHttpClient {
         HttpResponse<String> send(HttpRequest request)
                 throws IOException, InterruptedException, ErrorResponseException;
+
+        HttpResponse<Path> send(HttpRequest request, Path dst)
+                throws IOException, InterruptedException, ErrorResponseException;
     }
 
     public static final class HoHttpClient implements IHoHttpClient {
         private final HttpClient mClient;
 
         public HoHttpClient() {
-            mClient = HttpClient.newBuilder().build();
+            mClient = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.NORMAL).build();
         }
 
         @Override
@@ -64,6 +117,12 @@ public class HostOrchestratorClient {
                 throws IOException, InterruptedException, ErrorResponseException {
             return mClient.send(request, BodyHandlers.ofString());
         }
+
+        @Override
+        public HttpResponse<Path> send(HttpRequest request, Path dst)
+                throws IOException, InterruptedException, ErrorResponseException {
+            return mClient.send(request, BodyHandlers.ofFile(dst));
+        }
     }
 
     public static final class ErrorResponseException extends Exception {
@@ -97,4 +156,13 @@ public class HostOrchestratorClient {
         }
         return new Gson().fromJson(res.body(), responseClass);
     }
+
+    public static void saveToFile(IHoHttpClient client, HttpRequest request, Path dst)
+            throws IOException, InterruptedException, ErrorResponseException {
+        HttpResponse<Path> res = client.send(request, dst);
+        if (res.statusCode() != 200) {
+            throw new ErrorResponseException(res.statusCode(), "");
+        }
+        CLog.i("Response body for \"%s\" successfully saved to \"%s\"", request.uri(), dst);
+    }
 }
diff --git a/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
index 5b68dea9e..756b13ac4 100644
--- a/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
+++ b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
@@ -15,14 +15,23 @@
  */
 package com.android.tradefed.util.avd;
 
+import static com.android.tradefed.util.avd.HostOrchestratorClient.Cvd;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.ErrorResponseException;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.HoHttpClient;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.IHoHttpClient;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.ListCvdsResponse;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.Operation;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateBugreportRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationResultRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildListCvdsRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildPowerwashRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildRemoveInstanceRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.saveToFile;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.sendRequest;
 
 import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
@@ -34,19 +43,20 @@ import com.android.tradefed.util.avd.OxygenClient.LHPTunnelMode;
 
 import com.google.common.annotations.VisibleForTesting;
 
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import org.json.JSONTokener;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.net.URI;
 import java.net.http.HttpRequest;
 import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeoutException;
 
 /** Utility to execute commands via Host Orchestrator on remote instances. */
 public class HostOrchestratorUtil {
@@ -58,11 +68,7 @@ public class HostOrchestratorUtil {
     private static final long WAIT_FOR_OPERATION_MS = 5 * 1000; // 5 sec
     private static final long WAIT_FOR_OPERATION_TIMEOUT_MS = 5 * 6 * 1000 * 10; // 5 min
     private static final String CVD_HOST_LOGZ = "cvd_hostlog_zip";
-    private static final String URL_CVD_DEVICE_LOG = "cvds/%s/:bugreport";
     private static final String URL_CVD_BUGREPORTS = "cvdbugreports/%s";
-    private static final String URL_HO_POWERWASH = "cvds/%s/%s/:powerwash";
-    private static final String URL_HO_STOP = "cvds/%s/%s";
-    private static final String URL_QUERY_OPERATION_RESULT = "operations/%s/result";
     private static final String UNSUPPORTED_API_RESPONSE = "404 page not found";
 
     private File mTunnelLog;
@@ -84,6 +90,8 @@ public class HostOrchestratorUtil {
     private Map<String, String> mExtraOxygenArgs;
     private OxygenClient mOxygenClient;
     private IHoHttpClient mHttpClient;
+    private String mHOPortNumber = "2080";
+    private Process mHOTunnel;
 
     public HostOrchestratorUtil(
             boolean useOxygenation,
@@ -94,15 +102,16 @@ public class HostOrchestratorUtil {
             String targetRegion,
             String accountingUser,
             OxygenClient oxygenClient) {
-        mUseOxygenation = useOxygenation;
-        mExtraOxygenArgs = extraOxygenArgs;
-        mInstanceName = instanceName;
-        mHost = host;
-        mOxygenationDeviceId = oxygenationDeviceId;
-        mTargetRegion = targetRegion;
-        mAccountingUser = accountingUser;
-        mOxygenClient = oxygenClient;
-        mHttpClient = new HoHttpClient();
+        this(
+                useOxygenation,
+                extraOxygenArgs,
+                instanceName,
+                host,
+                oxygenationDeviceId,
+                targetRegion,
+                accountingUser,
+                oxygenClient,
+                new HoHttpClient());
     }
 
     public HostOrchestratorUtil(
@@ -124,52 +133,37 @@ public class HostOrchestratorUtil {
         mAccountingUser = accountingUser;
         mOxygenClient = oxygenClient;
         mHttpClient = httpClient;
+        if (mUseOxygenation) {
+            mHOTunnel = createHostOrchestratorTunnel();
+        }
     }
 
     /**
-     * Execute a command via Host Orchestrator and log its output
+     * Download log files.
      *
      * @param logName the log name to use when reporting to the {@link ITestLogger}
-     * @param url the Host Orchestrator API to be executed.
+     * @param urlPath url path indicating the log to download.
      */
-    public File collectLogByCommand(String logName, String url) {
-        String portNumber = "2080";
-        Process tunnel = null;
+    public File downloadLogFile(String logName, String urlPath) {
         File tempFile = null;
         try {
             tempFile = Files.createTempFile(logName, ".txt").toFile();
             if (mUseOxygenation) {
-                portNumber = Integer.toString(mOxygenClient.createServerSocket());
-                tunnel = createHostOrchestratorTunnel(portNumber);
-                if (tunnel == null || !tunnel.isAlive()) {
+                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
                     CLog.e("Failed portforwarding Host Orchestrator tunnel.");
                     FileUtil.deleteFile(tempFile);
                     return null;
                 }
             }
-            CommandResult commandRes =
-                    curlCommandExecution(
-                            portNumber,
-                            "GET",
-                            url,
-                            false,
-                            "--compressed",
-                            "-o",
-                            tempFile.getAbsolutePath());
-            if (!CommandStatus.SUCCESS.equals(commandRes.getStatus())) {
-                CLog.e("Failed logging cvd logs via Host Orchestrator: %s", commandRes.getStdout());
-                FileUtil.deleteFile(tempFile);
-                return null;
-            }
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest request =
+                    HttpRequest.newBuilder().uri(URI.create(baseUrl + "/" + urlPath)).build();
+            saveToFile(mHttpClient, request, Paths.get(tempFile.getAbsolutePath()));
             return tempFile;
-        } catch (IOException e) {
-            CLog.e("Failed logging cvd logs via Host Orchestrator: %s", e);
+        } catch (IOException | InterruptedException | ErrorResponseException e) {
+            CLog.e("Failed downloading logs with url path %s: %s", urlPath, e);
             FileUtil.deleteFile(tempFile);
             return null;
-        } finally {
-            if (mUseOxygenation) {
-                mOxygenClient.closeLHPConnection(tunnel);
-            }
         }
     }
 
@@ -182,45 +176,33 @@ public class HostOrchestratorUtil {
         // 4. Periodically run /operations/${OPERATION_ID}, parse the json util get "done":true.
         // 5. Run /operations/${OPERATION_ID}/result to get the ${UUID}.
         // 6. Run /cvdbugreports/${UUID} to download the artifact.
-        String portNumber = "2080";
-        Process tunnel = null;
         File cvdLogsDir = null;
         File cvdLogsZip = null;
         try {
             cvdLogsZip = Files.createTempFile(CVD_HOST_LOGZ, ".zip").toFile();
             if (mUseOxygenation) {
-                portNumber = Integer.toString(mOxygenClient.createServerSocket());
-                tunnel = createHostOrchestratorTunnel(portNumber);
-                if (tunnel == null || !tunnel.isAlive()) {
+                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
                     CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
                     return null;
                 }
             }
-            CommandResult curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
-                return null;
-            }
-            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
-            curlRes =
-                    cvdOperationExecution(
-                            mHttpClient,
-                            portNumber,
-                            "POST",
-                            String.format(URL_CVD_DEVICE_LOG, cvdGroup),
-                            WAIT_FOR_OPERATION_TIMEOUT_MS);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e(
-                        "Failed running cvd operation via Host Orchestrator: %s",
-                        curlRes.getStdout());
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
                 return null;
             }
-            String operationId = curlRes.getStdout().strip().replaceAll("\"", "");
-            curlRes =
+            String cvdGroup = listCvdsRes.cvds.get(0).group;
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest = buildCreateBugreportRequest(baseUrl, cvdGroup);
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+            httpRequest = buildGetOperationResultRequest(baseUrl, operation.name);
+            String bugreportId = sendRequest(mHttpClient, httpRequest, String.class);
+            CommandResult curlRes =
                     curlCommandExecution(
-                            portNumber,
+                            mHOPortNumber,
                             "GET",
-                            String.format(URL_CVD_BUGREPORTS, operationId),
+                            String.format(URL_CVD_BUGREPORTS, bugreportId),
                             true,
                             "--output",
                             cvdLogsZip.getAbsolutePath());
@@ -231,12 +213,9 @@ public class HostOrchestratorUtil {
                 return null;
             }
             cvdLogsDir = ZipUtil2.extractZipToTemp(cvdLogsZip, "cvd_logs");
-        } catch (IOException | InterruptedException | ErrorResponseException e) {
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
             CLog.e("Failed pulling cvd host logs via Host Orchestrator: %s", e);
         } finally {
-            if (mUseOxygenation) {
-                mOxygenClient.closeLHPConnection(tunnel);
-            }
             cvdLogsZip.delete();
         }
         return cvdLogsDir;
@@ -249,36 +228,40 @@ public class HostOrchestratorUtil {
      * @return True if device boot complete, false otherwise.
      */
     public boolean deviceBootCompleted(long maxWaitTime) {
-        String portNumber = "2080";
-        Process tunnel = null;
-        try {
-            if (mUseOxygenation) {
-                portNumber = Integer.toString(mOxygenClient.createServerSocket());
-                tunnel = createHostOrchestratorTunnel(portNumber);
-                if (tunnel == null || !tunnel.isAlive()) {
-                    CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
-                    return false;
-                }
+        if (mUseOxygenation) {
+            if (mHOTunnel == null || !mHOTunnel.isAlive()) {
+                CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
+                return false;
             }
-            long maxEndTime = System.currentTimeMillis() + maxWaitTime;
-            while (System.currentTimeMillis() < maxEndTime) {
-                CommandResult curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
-                if (CommandStatus.SUCCESS.equals(curlRes.getStatus())
-                        && parseListCvdOutput(curlRes.getStdout(), "status").equals("Running")) {
-                    return true;
-                }
-                getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
+        }
+        long maxEndTime = System.currentTimeMillis() + maxWaitTime;
+        while (System.currentTimeMillis() < maxEndTime) {
+            ListCvdsResponse listCvdsRes = null;
+            try {
+                listCvdsRes = listCvds();
+            } catch (IOException | InterruptedException | ErrorResponseException e) {
+                CLog.e("Failed listing cvds: %s", e);
+                return false;
             }
-        } catch (IOException e) {
-            CLog.e("Failed getting gce status via Host Orchestrator: %s", e);
-        } finally {
-            if (mUseOxygenation) {
-                mOxygenClient.closeLHPConnection(tunnel);
+            if (listCvdsRes.cvds.size() > 0 && listCvdsRes.cvds.get(0).status.equals("Running")) {
+                return true;
             }
+            getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
         }
         return false;
     }
 
+    /**
+     * Performs list cvds request against HO.
+     *
+     * @return A {@link ListCvdsResponse} response of list cvds request.
+     */
+    ListCvdsResponse listCvds() throws InterruptedException, IOException, ErrorResponseException {
+        String baseUrl = getHOBaseUrl(mHOPortNumber);
+        HttpRequest httpRequest = buildListCvdsRequest(baseUrl);
+        return sendRequest(mHttpClient, httpRequest, ListCvdsResponse.class);
+    }
+
     /**
      * Attempt to powerwash a GCE instance via Host Orchestrator.
      *
@@ -290,102 +273,64 @@ public class HostOrchestratorUtil {
         // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
         // 3. Attempt to powerwash a GCE instance via Host Orchestrator.
         // TODO(easoncylee): Flesh out this section when it's ready.
-        String portNumber = "2080";
-        Process tunnel = null;
-        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
         try {
             if (mUseOxygenation) {
-                portNumber = Integer.toString(mOxygenClient.createServerSocket());
-                tunnel = createHostOrchestratorTunnel(portNumber);
-                if (tunnel == null || !tunnel.isAlive()) {
+                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
+                    CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
                     String msg = "Failed portforwarding Host Orchestrator tunnel.";
                     CLog.e(msg);
                     curlRes.setStderr(msg);
                     return curlRes;
                 }
             }
-            curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
-                return curlRes;
-            }
-            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
-            String cvdName = parseListCvdOutput(curlRes.getStdout(), "name");
-            if (cvdGroup == null || cvdGroup.isEmpty() || cvdName == null || cvdName.isEmpty()) {
-                CLog.e("Failed parsing cvd group and cvd name.");
-                curlRes.setStatus(CommandStatus.FAILED);
-                return curlRes;
-            }
-            curlRes =
-                    cvdOperationExecution(
-                            mHttpClient,
-                            portNumber,
-                            "POST",
-                            String.format(URL_HO_POWERWASH, cvdGroup, cvdName),
-                            WAIT_FOR_OPERATION_TIMEOUT_MS);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed powerwashing cvd via Host Orchestrator: %s", curlRes.getStdout());
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
+                return null;
             }
-        } catch (IOException | InterruptedException | ErrorResponseException e) {
+            Cvd cvd = listCvdsRes.cvds.get(0);
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest = buildPowerwashRequest(baseUrl, cvd.group, cvd.name);
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
             CLog.e("Failed powerwashing gce via Host Orchestrator: %s", e);
-        } finally {
-            if (mUseOxygenation) {
-                mOxygenClient.closeLHPConnection(tunnel);
-            }
+            return new CommandResult(CommandStatus.EXCEPTION);
         }
-        return curlRes;
+        return new CommandResult(CommandStatus.SUCCESS);
     }
 
-    /** Attempt to stop a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult stopGce() {
-        // Basically, the rough processes to powerwash a GCE instance are
+    /** Remove Cuttlefish instance via Host Orchestrator. */
+    public CommandResult removeInstance() {
+        // Basically, the rough processes to remove an instance are
         // 1. Portforward CURL tunnel
-        // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
-        // 3. Attempt to stop a GCE instance via Host Orchestrator.
-        String portNumber = "2080";
-        Process tunnel = null;
-        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
+        // 2. Obtain the group and instance name.
+        // 3. Attempt to remove the Instance via Host Orchestrator.
         try {
             if (mUseOxygenation) {
-                portNumber = Integer.toString(mOxygenClient.createServerSocket());
-                tunnel = createHostOrchestratorTunnel(portNumber);
-                if (tunnel == null || !tunnel.isAlive()) {
+                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
+                    CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
                     String msg = "Failed portforwarding Host Orchestrator tunnel.";
                     CLog.e(msg);
                     curlRes.setStderr(msg);
                     return curlRes;
                 }
             }
-            curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
-                return curlRes;
-            }
-            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
-            String cvdName = parseListCvdOutput(curlRes.getStdout(), "name");
-            if (cvdGroup == null || cvdGroup.isEmpty() || cvdName == null || cvdName.isEmpty()) {
-                CLog.e("Failed parsing cvd group and cvd name.");
-                curlRes.setStatus(CommandStatus.FAILED);
-                return curlRes;
-            }
-            curlRes =
-                    cvdOperationExecution(
-                            mHttpClient,
-                            portNumber,
-                            "DELETE",
-                            String.format(URL_HO_STOP, cvdGroup, cvdName),
-                            WAIT_FOR_OPERATION_TIMEOUT_MS);
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed stopping gce via Host Orchestrator: %s", curlRes.getStdout());
-            }
-        } catch (IOException | InterruptedException | ErrorResponseException e) {
-            CLog.e("Failed stopping gce via Host Orchestrator: %s", e);
-        } finally {
-            if (mUseOxygenation) {
-                mOxygenClient.closeLHPConnection(tunnel);
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
+                return null;
             }
+            Cvd cvd = listCvdsRes.cvds.get(0);
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest = buildRemoveInstanceRequest(baseUrl, cvd.group, cvd.name);
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
+            CLog.e("Failed removing instance via Host Orchestrator: %s", e);
+            return new CommandResult(CommandStatus.EXCEPTION);
         }
-        return curlRes;
+        return new CommandResult(CommandStatus.SUCCESS);
     }
 
     /** Attempt to snapshot a Cuttlefish instance via Host Orchestrator. */
@@ -407,13 +352,13 @@ public class HostOrchestratorUtil {
     }
 
     /**
-     * Create Host Orchestrator Tunnel with a given port number.
+     * Create Host Orchestrator Tunnel with an automatically created port number.
      *
-     * @param portNumber The port number that Host Orchestrator communicates with.
      * @return A {@link Process} of the Host Orchestrator connection between CuttleFish and TF.
      */
     @VisibleForTesting
-    Process createHostOrchestratorTunnel(String portNumber) throws IOException {
+    Process createHostOrchestratorTunnel() {
+        mHOPortNumber = Integer.toString(mOxygenClient.createServerSocket());
         if (mTunnelLog == null || !mTunnelLog.exists()) {
             try {
                 mTunnelLog = FileUtil.createTempFile("host-orchestrator-connection", ".txt");
@@ -426,7 +371,7 @@ public class HostOrchestratorUtil {
         CLog.i("Portforwarding host orchestrator for oxygenation CF.");
         return mOxygenClient.createTunnelViaLHP(
                 LHPTunnelMode.CURL,
-                portNumber,
+                mHOPortNumber,
                 mInstanceName,
                 mHost,
                 mTargetRegion,
@@ -467,44 +412,22 @@ public class HostOrchestratorUtil {
         if (shouldDisplay) {
             CLog.logAndDisplay(
                     LogLevel.INFO,
-                    "Executing Host Orchestrator curl command: %s, Output: %s, Status: %s",
+                    "Executing Host Orchestrator curl command: %s, Stdout: %s, Stderr: %s, Status:"
+                            + " %s",
                     cmd,
                     commandRes.getStdout(),
+                    commandRes.getStderr(),
                     commandRes.getStatus());
         }
         if (commandRes.getStdout().contains(UNSUPPORTED_API_RESPONSE)) {
             commandRes.setStatus(CommandStatus.FAILED);
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricLogger.InvocationMetricKey.UNSUPPORTED_HOST_ORCHESTRATOR_API,
+                    api);
         }
         return commandRes;
     }
 
-    /** Return the value by parsing the output of list cvds with a given keyword. */
-    @VisibleForTesting
-    String parseListCvdOutput(String content, String keyword) {
-        // An example output of the given content is:
-        // {"cvds":
-        //      [{
-        //          "group":"cvd_1",
-        //          "name":"ins-1",
-        //          "build_source":{},
-        //          "status":"Running",
-        //          "displays":["720 x 1280 ( 320 )"],
-        //          "webrtc_device_id":"cvd-1",
-        //          "adb_serial":"0.0.0.0:6520"
-        //      }]
-        // }
-        JSONTokener tokener = new JSONTokener(content);
-        String output = "";
-        try {
-            JSONObject root = new JSONObject(tokener);
-            JSONArray array = root.getJSONArray("cvds");
-            output = parseCvdContent(array.getJSONObject(0).toString(), keyword);
-        } catch (JSONException e) {
-            CLog.e(e);
-        }
-        return output;
-    }
-
     /** Return the value by parsing the simple JSON content with a given keyword. */
     private String parseCvdContent(String content, String keyword) {
         String output = "";
@@ -549,17 +472,41 @@ public class HostOrchestratorUtil {
                 buildGetOperationRequest(getHOBaseUrl(portNumber), operationId);
             Operation op = sendRequest(client, httpRequest, Operation.class);
             if (op.done) {
-                request = String.format(URL_QUERY_OPERATION_RESULT, operationId);
-                return curlCommandExecution(portNumber, "GET", request, true);
+                return commandRes;
             }
             getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
         }
         CLog.e("Running long operation cvd request timedout!");
         // Return the last command result and change the status to TIMED_OUT.
         commandRes.setStatus(CommandStatus.TIMED_OUT);
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricLogger.InvocationMetricKey.CVD_LONG_OPERATION_TIMEOUT_API, request);
         return commandRes;
     }
 
+    /**
+     * Wait for operation to finish or timeout.
+     *
+     * @param client http client to perm
+     * @param name Operation name.
+     * @param maxWaitTime waiting time, if reached out, an execption will be thrown.
+     */
+    public void waitForOperation(
+            IHoHttpClient client, String baseUrl, String name, long maxWaitTimeMs)
+            throws IOException, InterruptedException, TimeoutException, ErrorResponseException {
+        long maxEndTime = System.currentTimeMillis() + maxWaitTimeMs;
+        while (System.currentTimeMillis() < maxEndTime) {
+            HttpRequest httpRequest = buildGetOperationRequest(baseUrl, name);
+            Operation op = sendRequest(client, httpRequest, Operation.class);
+            if (op.done) {
+                return;
+            }
+            getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
+        }
+        CLog.e("Timeout waiting for operation: " + name);
+        throw new TimeoutException("Operation wait timeout, operation name: " + name);
+    }
+
     /** Get {@link IRunUtil} to use. Exposed for unit testing. */
     // TODO(dshi): Restore VisibleForTesting after the unittest is moved to the same package
     // (tradefed-avd-util)
@@ -578,8 +525,16 @@ public class HostOrchestratorUtil {
         return mTunnelLog;
     }
 
+    /** Return the host orchestrator URL. */
     String getHOBaseUrl(String port) {
         String host = mUseOxygenation ? "127.0.0.1" : mHost;
         return String.format("http://%s:%s", host, port);
     }
+
+    /** Close the connection to the remote oxygenation device with a given {@link Process}. */
+    public void closeTunnelConnection() {
+        if (mUseOxygenation) {
+            mOxygenClient.closeLHPConnection(mHOTunnel);
+        }
+    }
 }
diff --git a/avd_util/com/android/tradefed/util/avd/InspectionUtil.java b/avd_util/com/android/tradefed/util/avd/InspectionUtil.java
new file mode 100644
index 000000000..a22ebeed7
--- /dev/null
+++ b/avd_util/com/android/tradefed/util/avd/InspectionUtil.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import com.android.tradefed.result.error.ErrorIdentifier;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+
+import com.google.common.base.Strings;
+
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/** A utility for inspecting AVD and host VM */
+public class InspectionUtil {
+    public static final Integer DISK_USAGE_MAX = 95;
+
+    // A map of expected process names and the corresponding error identifier if they are missing.
+    // The name string should be a substring of a process list.
+    public static final LinkedHashMap<String, ErrorIdentifier> EXPECTED_PROCESSES =
+            Stream.of(
+                            new AbstractMap.SimpleEntry<>(
+                                    "run_cvd",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_RUN_CVD_MISSING),
+                            new AbstractMap.SimpleEntry<>(
+                                    "netsimd",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_BLUETOOTH),
+                            new AbstractMap.SimpleEntry<>(
+                                    "openwrt_control_server",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_OPENWRT),
+                            new AbstractMap.SimpleEntry<>(
+                                    "webRTC",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_WEBRTC_CRASH),
+                            new AbstractMap.SimpleEntry<>(
+                                    "crosvm",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_CROSVM),
+                            new AbstractMap.SimpleEntry<>(
+                                    "nginx", InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_NGINX))
+                    .collect(
+                            Collectors.toMap(
+                                    Map.Entry::getKey,
+                                    Map.Entry::getValue,
+                                    (x, y) -> y,
+                                    LinkedHashMap::new));
+
+    // A map of unexpected process names and the corresponding error identifier if they are found.
+    // The name string should be a substring of a process list.
+    public static final Map<String, ErrorIdentifier> UNEXPECTED_PROCESSES =
+            Stream.of(
+                            new AbstractMap.SimpleEntry<>(
+                                    "cvd fetch",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_CVD_FETCH_HANG))
+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+
+    // Map between error signature to ErrorIdentifier. Note that the signatures are sorted. More
+    // specific error signature should be ranked first.
+    private static final LinkedHashMap<String, ErrorIdentifier> ERROR_SIGNATURE_TO_IDENTIFIER_MAP =
+            Stream.of(
+                            new AbstractMap.SimpleEntry<>(
+                                    "bluetooth_failed",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_BLUETOOTH),
+                            new AbstractMap.SimpleEntry<>(
+                                    "fetch_cvd_failure_resolve_host",
+                                    InfraErrorIdentifier
+                                            .CUTTLEFISH_LAUNCH_FAILURE_CVD_RESOLVE_HOST),
+                            new AbstractMap.SimpleEntry<>(
+                                    "fetch_cvd_failure_connect_server",
+                                    InfraErrorIdentifier
+                                            .CUTTLEFISH_LAUNCH_FAILURE_CVD_SERVER_CONNECTION),
+                            new AbstractMap.SimpleEntry<>(
+                                    "launch_cvd_port_collision",
+                                    InfraErrorIdentifier
+                                            .CUTTLEFISH_LAUNCH_FAILURE_CVD_PORT_COLLISION),
+                            new AbstractMap.SimpleEntry<>(
+                                    "fetch_cvd_failure_general",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_CVD_FETCH),
+                            new AbstractMap.SimpleEntry<>(
+                                    "cf_webrtc_crash",
+                                    InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_WEBRTC_CRASH),
+                            new AbstractMap.SimpleEntry<>(
+                                    "fetch_cvd_failure_artifact_not_found",
+                                    InfraErrorIdentifier.ARTIFACT_NOT_FOUND))
+                    .collect(
+                            Collectors.toMap(
+                                    Map.Entry::getKey,
+                                    Map.Entry::getValue,
+                                    (x, y) -> y,
+                                    LinkedHashMap::new));
+
+    /**
+     * Convert error signature to ErrorIdentifier if possible
+     *
+     * @param errorSignatures a string of comma separated error signatures
+     * @return {@link ErrorIdentifier}
+     */
+    public static ErrorIdentifier convertErrorSignatureToIdentifier(String errorSignatures) {
+        if (errorSignatures == null) {
+            return null;
+        }
+        Set<String> signatures = new HashSet<>(Arrays.asList(errorSignatures.split(",")));
+        for (String signature : ERROR_SIGNATURE_TO_IDENTIFIER_MAP.keySet()) {
+            if (signatures.contains(signature)) {
+                return ERROR_SIGNATURE_TO_IDENTIFIER_MAP.get(signature);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Parse the df command output to return the disk usage percentage
+     *
+     * @param diskspaceInfo output of command `df -P \`
+     * @return An Optional<Integer> containing the percentage of used disk space if found, or an
+     *     empty Optional if not found or an error occurred.
+     */
+    public static Optional<Integer> getDiskspaceUsage(String diskspaceInfo) {
+        Pattern pattern = Pattern.compile("\\s(\\d+)%\\s", Pattern.DOTALL);
+        Matcher matcher = pattern.matcher(diskspaceInfo);
+
+        if (matcher.find()) {
+            String percentageString = matcher.group(1);
+            return Optional.of(Integer.parseInt(percentageString));
+        }
+        return Optional.empty();
+    }
+
+    /**
+     * Search for a process matching with the substring
+     *
+     * @param allProcesses string of a list of processes generated from top or ps command
+     * @param process substring of the process to search for
+     * @return true if the process is found, false otherwise
+     */
+    public static boolean searchProcess(String allProcesses, String process) {
+        if (Strings.isNullOrEmpty(allProcesses)) {
+            return false;
+        }
+        for (String line : allProcesses.split("\\n")) {
+            if (line.indexOf(process) != -1) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/avd_util/com/android/tradefed/util/avd/LogCollector.java b/avd_util/com/android/tradefed/util/avd/LogCollector.java
index 08067271f..2f6f706d7 100644
--- a/avd_util/com/android/tradefed/util/avd/LogCollector.java
+++ b/avd_util/com/android/tradefed/util/avd/LogCollector.java
@@ -40,6 +40,16 @@ public class LogCollector {
     // Maximum size of tailing part of a file to search for error signature.
     private static final long MAX_FILE_SIZE_FOR_ERROR = 10 * 1024 * 1024;
 
+    // A map of log file name pattern to log content that the log must have.
+    private static final Map<Pattern, AbstractMap.SimpleEntry<String, String>>
+            REMOTE_LOG_NAME_PATTERN_TO_LOG_MUST_HAVE_SIGNATURE_MAP =
+                    Stream.of(
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*fetch.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Completed all fetches",
+                                                    "fetch_cvd_failure_general")))
+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
     private static final Map<Pattern, AbstractMap.SimpleEntry<String, String>>
             REMOTE_LOG_NAME_PATTERN_TO_ERROR_SIGNATURE_MAP =
                     Stream.of(
@@ -53,30 +63,32 @@ public class LogCollector {
                                             new AbstractMap.SimpleEntry<>(
                                                     "vcpu hw run failure: 0x7",
                                                     "crosvm_vcpu_hw_run_failure_7")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "Unable to connect to vsock server",
-                                                    "unable_to_connect_to_vsock_server")),
                                     new AbstractMap.SimpleEntry<>(
                                             Pattern.compile(".*(launcher|vdl_stdout).*"),
                                             new AbstractMap.SimpleEntry<>(
                                                     "failed to initialize fetch system images",
                                                     "fetch_cvd_failure")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*(vdl_stdout|fetch).*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Could not resolve host: ",
+                                                    "fetch_cvd_failure_resolve_host")),
                                     new AbstractMap.SimpleEntry<>(
                                             Pattern.compile(".*vdl_stdout.*"),
                                             new AbstractMap.SimpleEntry<>(
-                                                    "E fetch_cvd:", "fetch_cvd_failure_general")),
+                                                    "Could not connect to server",
+                                                    "fetch_cvd_failure_connect_server")),
                                     new AbstractMap.SimpleEntry<>(
                                             Pattern.compile(".*vdl_stdout.*"),
                                             new AbstractMap.SimpleEntry<>(
-                                                    "E cvd     : fetch_cvd",
-                                                    "fetch_cvd_failure_general")),
+                                                    // TODO(b/395472945): remove by 4/1/2025
+                                                    "Unable to download",
+                                                    "fetch_cvd_failure_artifact_not_found")),
                                     new AbstractMap.SimpleEntry<>(
                                             Pattern.compile(".*vdl_stdout.*"),
                                             new AbstractMap.SimpleEntry<>(
-                                                    "Could not resolve host: ",
-                                                    "fetch_cvd_failure_resolve_host")),
+                                                    "Failed to download file: File Not Found",
+                                                    "fetch_cvd_failure_artifact_not_found")),
                                     new AbstractMap.SimpleEntry<>(
                                             Pattern.compile(".*launcher.*"),
                                             new AbstractMap.SimpleEntry<>(
@@ -126,7 +138,12 @@ public class LogCollector {
                                                     "BluetoothShellCommand:"
                                                         + " wait-for-state:STATE_OFF: Failed with"
                                                         + " status=-1",
-                                                    "bluetooth_failed_to_stop")))
+                                                    "bluetooth_failed_to_stop")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Assertion `mutex->__data.__owner == 0' failed",
+                                                    "cf_webrtc_crash")))
                             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
 
     /**
@@ -189,14 +206,20 @@ public class LogCollector {
     /**
      * Collect error signatures from logs.
      *
-     * @param logDir directory of logs pulled from remote host.
+     * @param logPath directory of logs pulled from remote host, or a single file to search for
+     *     error signatures.
      * @return a list of error signatures.
      */
-    public static List<String> collectErrorSignatures(File logDir) {
-        CLog.d("Collect error signature from logs under: %s.", logDir);
+    public static List<String> collectErrorSignatures(File logPath) {
+        CLog.d("Collect error signature from logs under: %s.", logPath);
         List<String> signatures = new ArrayList<>();
         try {
-            Set<String> files = FileUtil.findFiles(logDir, ".*");
+            Set<String> files;
+            if (logPath.isDirectory()) {
+                files = FileUtil.findFiles(logPath, ".*");
+            } else {
+                files = Set.of(logPath.getAbsolutePath());
+            }
             for (String f : files) {
                 File file = new File(f);
                 if (file.isDirectory()) {
@@ -211,7 +234,15 @@ public class LogCollector {
                         pairs.add(entry.getValue());
                     }
                 }
-                if (pairs.size() == 0) {
+                List<AbstractMap.SimpleEntry<String, String>> pairsMustHave = new ArrayList<>();
+                for (Map.Entry<Pattern, AbstractMap.SimpleEntry<String, String>> entry :
+                        REMOTE_LOG_NAME_PATTERN_TO_LOG_MUST_HAVE_SIGNATURE_MAP.entrySet()) {
+                    Matcher matcher = entry.getKey().matcher(fileName);
+                    if (matcher.find()) {
+                        pairsMustHave.add(entry.getValue());
+                    }
+                }
+                if (pairs.size() == 0 && pairsMustHave.size() == 0) {
                     continue;
                 }
                 try (FileInputStream stream = new FileInputStream(file)) {
@@ -222,6 +253,8 @@ public class LogCollector {
                     try (Scanner scanner = new Scanner(stream)) {
                         List<AbstractMap.SimpleEntry<String, String>> pairsToRemove =
                                 new ArrayList<>();
+                        List<AbstractMap.SimpleEntry<String, String>> pairsMustHaveToRemove =
+                                new ArrayList<>();
                         while (scanner.hasNextLine()) {
                             String line = scanner.nextLine();
                             for (AbstractMap.SimpleEntry<String, String> pair : pairs) {
@@ -230,11 +263,24 @@ public class LogCollector {
                                     signatures.add(pair.getValue());
                                 }
                             }
+                            for (AbstractMap.SimpleEntry<String, String> pair : pairsMustHave) {
+                                if (line.indexOf(pair.getKey()) != -1) {
+                                    pairsMustHaveToRemove.add(pair);
+                                }
+                            }
                             if (pairsToRemove.size() > 0) {
                                 pairs.removeAll(pairsToRemove);
-                                if (pairs.size() == 0) {
-                                    break;
-                                }
+                            }
+                            if (pairsMustHaveToRemove.size() > 0) {
+                                pairsMustHave.removeAll(pairsMustHaveToRemove);
+                            }
+                            if (pairs.size() == 0 && pairsMustHave.size() == 0) {
+                                break;
+                            }
+                        }
+                        if (pairsMustHave.size() > 0) {
+                            for (AbstractMap.SimpleEntry<String, String> pair : pairsMustHave) {
+                                signatures.add(pair.getValue());
                             }
                         }
                     }
diff --git a/avd_util/com/android/tradefed/util/avd/OxygenClient.java b/avd_util/com/android/tradefed/util/avd/OxygenClient.java
index 7d435c395..227316ede 100644
--- a/avd_util/com/android/tradefed/util/avd/OxygenClient.java
+++ b/avd_util/com/android/tradefed/util/avd/OxygenClient.java
@@ -16,6 +16,7 @@
 
 package com.android.tradefed.util.avd;
 
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
@@ -264,6 +265,7 @@ public class OxygenClient {
      * @param extraOxygenArgs {@link Map<String, String>} of extra Oxygen lease args
      * @param attributes attributes associated with current invocation
      * @param gceCmdTimeout number of ms for the command line timeout
+     * @param useOxygenation whether the device is leased from OmniLab Infra or not.
      * @return {@link CommandResult} that Oxygen binary returned.
      */
     public CommandResult leaseMultipleDevices(
@@ -275,7 +277,8 @@ public class OxygenClient {
             long leaseLength,
             Map<String, String> extraOxygenArgs,
             MultiMap<String, String> attributes,
-            long gceCmdTimeout) {
+            long gceCmdTimeout,
+            boolean useOxygenation) {
         List<String> oxygenClientArgs = Lists.newArrayList(mCmdArgs);
         oxygenClientArgs.add("-lease");
 
@@ -310,6 +313,10 @@ public class OxygenClient {
 
         addInvocationAttributes(oxygenClientArgs, attributes);
 
+        if (useOxygenation) {
+            oxygenClientArgs.add("-use_omnilab");
+        }
+
         CLog.i("Leasing multiple devices from oxygen client with %s", oxygenClientArgs.toString());
         return runOxygenTimedCmd(
                 oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]), gceCmdTimeout);
@@ -437,10 +444,11 @@ public class OxygenClient {
                     mode, oxygenClientArgs.toString());
             tunnelLog.write(
                     String.format(
-                                    "\n===[%s]Session id: %s, Server URL: %s===\n",
+                                    "\n===[%s]Session id: %s, Server URL: %s, Port: %s===\n",
                                     dateFormat.format(System.currentTimeMillis()),
                                     sessionId,
-                                    serverUrl)
+                                    serverUrl,
+                                    portNumber)
                             .getBytes());
             lhpTunnel = getRunUtil().runCmdInBackground(oxygenClientArgs, tunnelLog);
             // TODO(b/363861223): reduce the waiting time when LHP is stable.
@@ -450,8 +458,12 @@ public class OxygenClient {
         }
         if (lhpTunnel == null || !lhpTunnel.isAlive()) {
             closeLHPConnection(lhpTunnel);
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricLogger.InvocationMetricKey.PORTFORWARD_LHP_FAIL_COUNT, 1);
             return null;
         }
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricLogger.InvocationMetricKey.PORTFORWARD_LHP_SUCCESS_COUNT, 1);
         return lhpTunnel;
     }
 
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
index 8d68f57d7..1b2d15f45 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
@@ -18,7 +18,12 @@ package com.android.tradefed.util.avd;
 
 import static com.android.tradefed.util.avd.HostOrchestratorClient.ErrorResponseException;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.Operation;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateBugreportRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationResultRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildPowerwashRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildRemoveInstanceRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.saveToFile;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.sendRequest;
 
 import org.junit.After;
@@ -36,6 +41,8 @@ import java.net.http.HttpClient;
 import java.net.http.HttpHeaders;
 import java.net.http.HttpRequest;
 import java.net.http.HttpResponse;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.Map;
 import java.util.Optional;
 
@@ -62,6 +69,34 @@ public class HostOrchestratorClientTest {
         Assert.assertEquals("https://ho.test/operations/opfoo", r.uri().toString());
     }
 
+    @Test
+    public void testBuildGetOperationResultRequest() throws Exception {
+        HttpRequest r = buildGetOperationResultRequest("https://ho.test", "opfoo");
+
+        Assert.assertEquals("https://ho.test/operations/opfoo/result", r.uri().toString());
+    }
+
+    @Test
+    public void testBuildCreateBugreportRequest() throws Exception {
+        HttpRequest r = buildCreateBugreportRequest("https://ho.test", "foo");
+
+        Assert.assertEquals("https://ho.test/cvds/foo/:bugreport", r.uri().toString());
+    }
+
+    @Test
+    public void testBuildPowerwashRequest() throws Exception {
+        HttpRequest r = buildPowerwashRequest("https://ho.test", "foo", "1");
+
+        Assert.assertEquals("https://ho.test/cvds/foo/1/:powerwash", r.uri().toString());
+    }
+
+    @Test
+    public void testBuildRemoveInstanceRequest() throws Exception {
+        HttpRequest r = buildRemoveInstanceRequest("https://ho.test", "foo", "1");
+
+        Assert.assertEquals("https://ho.test/cvds/foo/1", r.uri().toString());
+    }
+
     @Test
     public void testSendRequestSucceeds() throws Exception {
         String body = "{ \"name\":\"foo\", \"done\": \"true\" }";
@@ -93,7 +128,37 @@ public class HostOrchestratorClientTest {
         Assert.assertEquals(mE.getBody(), body);
     }
 
-    private static HttpResponse<String> buildFakeResponse(int statusCode, String body) {
+    @Test
+    public void testSendSaveToFileRequestSucceeds() throws Exception {
+        Path dst = Paths.get("foo.txt");
+        HttpRequest request =
+                HttpRequest.newBuilder().uri(URI.create("http://ho.test/foo.txt")).build();
+        HttpResponse<Path> response = buildFakeResponse(200, dst);
+        Mockito.when(mFakeHttpClient.send(Mockito.any(), Mockito.any())).thenReturn(response);
+
+        saveToFile(mFakeHttpClient, request, dst);
+    }
+
+    @Test
+    public void testSendSaveToFileRequestFails() throws Exception {
+        Path dst = Paths.get("foo.txt");
+        HttpRequest request =
+                HttpRequest.newBuilder().uri(URI.create("http://ho.test/foo.txt")).build();
+        HttpResponse<Path> response = buildFakeResponse(500, dst);
+        Mockito.when(mFakeHttpClient.send(Mockito.any(), Mockito.any())).thenReturn(response);
+
+        ErrorResponseException mE = new ErrorResponseException(0, "");
+        try {
+            saveToFile(mFakeHttpClient, request, dst);
+        } catch (ErrorResponseException e) {
+            mE = e;
+        }
+
+        Assert.assertEquals(mE.getStatusCode(), 500);
+        Assert.assertEquals(mE.getBody(), "");
+    }
+
+    private static <T> HttpResponse<T> buildFakeResponse(int statusCode, T body) {
         return new HttpResponse<>() {
             @Override
             public int statusCode() {
@@ -106,12 +171,12 @@ public class HostOrchestratorClientTest {
             }
 
             @Override
-            public String body() {
+            public T body() {
                 return body;
             }
 
             @Override
-            public Optional<HttpResponse<String>> previousResponse() {
+            public Optional<HttpResponse<T>> previousResponse() {
                 return Optional.empty();
             }
 
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
index c70b1f179..b3c0a0fa2 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
@@ -16,8 +16,6 @@
 
 package com.android.tradefed.util.avd;
 
-import static com.android.tradefed.util.avd.HostOrchestratorClient.IHoHttpClient;
-
 import static org.mockito.Mockito.times;
 
 import com.android.tradefed.util.CommandResult;
@@ -43,9 +41,11 @@ import java.net.http.HttpClient;
 import java.net.http.HttpHeaders;
 import java.net.http.HttpRequest;
 import java.net.http.HttpResponse;
+import java.nio.file.Paths;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
+import java.util.concurrent.TimeoutException;
 
 import javax.net.ssl.SSLSession;
 
@@ -77,10 +77,7 @@ public class HostOrchestratorUtilTest {
     private static final String OPERATION_RES = "{\"name\":\"some_id\"}";
     private static final String OPERATION_TIMEOUT_RES = "{\"name\":\"some_id\", \"done\":false}";
     private static final String OPERATION_DONE_RES = "{\"name\":\"some_id\", \"done\":true}";
-    private static final String LIST_CVD_BADRES =
-            "{\"cvds\":[{\"build_source\":{},"
-                    + "\"status\":\"Running\",\"displays\":[\"720 x 1280 ( 320 )\"],"
-                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
+    private static final String LIST_CVD_EMPTY = "{ \"cvds\": [] }";
     private HashMap<String, String> mExtraOxygenArgs;
 
     @Before
@@ -99,20 +96,11 @@ public class HostOrchestratorUtilTest {
     }
 
     @Test
-    public void testCreateHostOrchestratorTunnel_Oxygenation() throws Exception {
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient);
-        mHOUtil.createHostOrchestratorTunnel("1111");
-        Mockito.verify(mMockClient, times(1))
+    public void testCollectLogByCommand_Success() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
                 .createTunnelViaLHP(
                         Mockito.eq(LHPTunnelMode.CURL),
                         Mockito.eq("1111"),
@@ -123,13 +111,6 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq(OXYGENATION_DEVICE_ID),
                         Mockito.eq(mExtraOxygenArgs),
                         Mockito.any());
-    }
-
-
-    @Test
-    public void testCollectLogByCommand_Success() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -141,11 +122,6 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
@@ -161,34 +137,28 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq((OutputStream) null),
                         Mockito.eq((OutputStream) null),
                         (String[]) Mockito.any());
-        File tempFile =
-                mHOUtil.collectLogByCommand("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+        Mockito.when(mMockHttpClient.send(Mockito.any(), Mockito.any()))
+                .thenReturn(mockHttpResponse(200, Paths.get("logs.txt")));
+        File tempFile = mHOUtil.downloadLogFile("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
         FileUtil.deleteFile(tempFile);
-
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq(
-                                String.format(
-                                        "http://127.0.0.1:1111/%s",
-                                        HostOrchestratorUtil.URL_HOST_KERNEL_LOG)),
-                        Mockito.eq("--compressed"),
-                        Mockito.eq("-o"),
-                        Mockito.any());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
     }
 
     @Test
     public void testCollectLogByCommand_Fail() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -200,11 +170,6 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
@@ -220,33 +185,28 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq((OutputStream) null),
                         Mockito.eq((OutputStream) null),
                         (String[]) Mockito.any());
-        File tempFile =
-                mHOUtil.collectLogByCommand("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq(
-                                String.format(
-                                        "http://127.0.0.1:1111/%s",
-                                        HostOrchestratorUtil.URL_HOST_KERNEL_LOG)),
-                        Mockito.eq("--compressed"),
-                        Mockito.eq("-o"),
-                        Mockito.any());
+        Mockito.when(mMockHttpClient.send(Mockito.any(), Mockito.any()))
+                .thenReturn(mockHttpResponse(200, Paths.get("logs.txt")));
+        File tempFile = mHOUtil.downloadLogFile("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
         FileUtil.deleteFile(tempFile);
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
     }
 
     @Test
     public void testPullCvdHostLogs_Oxygenation_Success() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -258,42 +218,17 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    public CommandResult cvdOperationExecution(
-                            IHoHttpClient client,
-                            String portNumber,
-                            String method,
-                            String request,
-                            long maxWaitTime) {
-                        CommandResult res = new CommandResult(CommandStatus.SUCCESS);
-                        res.setStdout("operation_id");
-                        return res;
-                    }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStdout(LIST_CVD_RES);
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES),
+                        mockHttpResponse(200, "fakeuuid-215c1602-db24"));
         CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
         commandRes.setStdout("some output");
         Mockito.doReturn(commandRes)
@@ -307,22 +242,10 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq("-v"),
                         Mockito.eq("-X"),
                         Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/fakeuuid-215c1602-db24"),
                         Mockito.eq("--output"),
                         Mockito.any());
         mHOUtil.pullCvdHostLogs();
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
         Mockito.verify(mMockRunUtil, times(1))
                 .runTimedCmd(
                         Mockito.anyLong(),
@@ -333,15 +256,27 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq("-v"),
                         Mockito.eq("-X"),
                         Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/fakeuuid-215c1602-db24"),
                         Mockito.eq("--output"),
                         Mockito.any());
     }
 
     @Test
-    public void testPullCvdHostLogs_Oxygenation_CurlFailedGetCvd() throws Exception {
+    public void testPullCvdHostLogs_Oxygenation_ListCvdsFails() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -353,39 +288,14 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
-        cvdCommandRes.setStderr("some error");
-        cvdCommandRes.setStdout("some output");
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        (String[]) Mockito.any());
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
         Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
         Mockito.verify(mMockRunUtil, times(0))
                 .runTimedCmd(
                         Mockito.anyLong(),
@@ -405,6 +315,18 @@ public class HostOrchestratorUtilTest {
     public void testPullCvdHostLogs_Oxygenation_CreateHOFailed() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -416,18 +338,12 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
         Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
         Mockito.verify(mMockRunUtil, times(0))
                 .runTimedCmd(
                         Mockito.anyLong(),
@@ -458,6 +374,18 @@ public class HostOrchestratorUtilTest {
     public void testPullCvdHostLogs_Oxygenation_FailedDownload() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -469,42 +397,17 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    public CommandResult cvdOperationExecution(
-                            IHoHttpClient client,
-                            String portNumber,
-                            String method,
-                            String request,
-                            long maxWaitTime) {
-                        CommandResult res = new CommandResult(CommandStatus.SUCCESS);
-                        res.setStdout("operation_id");
-                        return res;
-                    }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStdout(LIST_CVD_RES);
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES),
+                        mockHttpResponse(200, "fakeuuid-215c1602-db24"));
         CommandResult commandRes = new CommandResult(CommandStatus.FAILED);
         commandRes.setStdout("some output");
         commandRes.setStderr("some error");
@@ -519,17 +422,29 @@ public class HostOrchestratorUtilTest {
                         Mockito.eq("-v"),
                         Mockito.eq("-X"),
                         Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/fakeuuid-215c1602-db24"),
                         Mockito.eq("--output"),
                         Mockito.any());
         Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
     }
 
+
     @Test
-    public void testPullCvdHostLogs_Oxygenation_404() throws Exception {
+    public void testPowerwashGce() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -541,58 +456,35 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStderr("some error");
-        cvdCommandRes.setStdout(mHOUtil.getUnsupportedHoResponse());
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        (String[]) Mockito.any());
-        Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
-                        Mockito.eq("--output"),
-                        Mockito.any());
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES));
+        Assert.assertEquals(CommandStatus.SUCCESS, mHOUtil.powerwashGce().getStatus());
     }
 
     @Test
-    public void testPowerwashGce() throws Exception {
+    public void testPowerwashGce_CreateHOFailed() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -604,548 +496,30 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_RES);
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        CommandResult powerwashRes = new CommandResult(CommandStatus.SUCCESS);
-        powerwashRes.setStdout(OPERATION_RES);
-        Mockito.doReturn(powerwashRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-        Mockito.when(mMockHttpClient.send(Mockito.any()))
-                .thenReturn(mockHttpResponse(200, OPERATION_DONE_RES));
-        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
-        successRes.setStdout("operation_id");
-        Mockito.doReturn(successRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
-        Assert.assertNotNull(mHOUtil.powerwashGce());
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_CreateHOFailed() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
-                    @Override
-                    protected IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_ListCvdFailed() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    protected IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.FAILED);
-        cvdRes.setStdout("output");
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_ListCvd404() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    protected IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(mHOUtil.getUnsupportedHoResponse());
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_NoCvdOutput() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    protected IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_BADRES);
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testStopGce() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    public IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_RES);
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        CommandResult stopRes = new CommandResult(CommandStatus.SUCCESS);
-        stopRes.setStdout(OPERATION_RES);
-        Mockito.doReturn(stopRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
-        Mockito.when(mMockHttpClient.send(Mockito.any()))
-                .thenReturn(mockHttpResponse(200, OPERATION_DONE_RES));
-        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
-        successRes.setStdout("operation_id");
-        Mockito.doReturn(successRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
-        Assert.assertNotNull(mHOUtil.stopGce());
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
-    }
-
-    @Test
-    public void testStopGce_CreateHOFailed() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
-                    @Override
-                    public IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
-    }
-
-    @Test
-    public void testStopGce_ListCvdFailed() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    public IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.FAILED);
-        cvdRes.setStdout("output");
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
-    }
-
-    @Test
-    public void testStopGce_ListCvd404() throws Exception {
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        mHOUtil =
-                new HostOrchestratorUtil(
-                        true,
-                        mExtraOxygenArgs,
-                        INSTANCE_NAME,
-                        HOST,
-                        OXYGENATION_DEVICE_ID,
-                        TARGET_REGION,
-                        ACCOUNTING_USER,
-                        mMockClient,
-                        mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    public IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(mHOUtil.getUnsupportedHoResponse());
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
     }
 
     @Test
-    public void testStopGce_NoCvdOutput() throws Exception {
+    public void testPowerwashGce_ListCvdFailed() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1158,45 +532,31 @@ public class HostOrchestratorUtilTest {
                         mMockClient,
                         mMockHttpClient) {
                     @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    public IRunUtil getRunUtil() {
+                    protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_BADRES);
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("DELETE"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
     }
 
     @Test
-    public void testCvdOperationExecution_Failed() throws Exception {
+    public void testPowerwashGce_EmptyList() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1213,28 +573,27 @@ public class HostOrchestratorUtilTest {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
-        cvdCommandRes.setStdout("some output");
-        cvdCommandRes.setStderr("some error");
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/request"));
-        Assert.assertEquals(
-                CommandStatus.FAILED,
-                mHOUtil.cvdOperationExecution(null, "1111", "POST", "request", 5).getStatus());
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_EMPTY));
+        Assert.assertNull(mHOUtil.powerwashGce());
     }
 
     @Test
-    public void testCvdOperationExecution_FailedOperation() throws Exception {
+    public void testRemoveInstance() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1251,44 +610,30 @@ public class HostOrchestratorUtilTest {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
-        commandRes.setStdout(OPERATION_RES);
-        Mockito.doReturn(commandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/request"));
         Mockito.when(mMockHttpClient.send(Mockito.any()))
-                .thenReturn(mockHttpResponse(200, OPERATION_DONE_RES));
-        CommandResult failedRes = new CommandResult(CommandStatus.FAILED);
-        failedRes.setStdout("some output");
-        Mockito.doReturn(failedRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
-        Assert.assertEquals(
-                CommandStatus.FAILED,
-                mHOUtil.cvdOperationExecution(mMockHttpClient, "1111", "POST", "request", 5)
-                        .getStatus());
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES));
+        Assert.assertEquals(CommandStatus.SUCCESS, mHOUtil.removeInstance().getStatus());
     }
 
     @Test
-    public void testCvdOperationExecution_Success() throws Exception {
+    public void testRemoveInstance_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1305,44 +650,25 @@ public class HostOrchestratorUtilTest {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
-        commandRes.setStdout(OPERATION_RES);
-        Mockito.doReturn(commandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/request"));
-        Mockito.when(mMockHttpClient.send(Mockito.any()))
-                .thenReturn(mockHttpResponse(200, OPERATION_DONE_RES));
-        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
-        successRes.setStdout("operation_id");
-        Mockito.doReturn(successRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
-        Assert.assertEquals(
-                "operation_id",
-                mHOUtil.cvdOperationExecution(mMockHttpClient, "1111", "POST", "request", 5)
-                        .getStdout());
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
     }
 
     @Test
-    public void testCvdOperationExecution_Timedout() throws Exception {
+    public void testRemoveInstance_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1359,30 +685,27 @@ public class HostOrchestratorUtilTest {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
-        commandRes.setStdout(OPERATION_RES);
-        Mockito.doReturn(commandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://127.0.0.1:1111/request"));
         Mockito.when(mMockHttpClient.send(Mockito.any()))
-                .thenReturn(mockHttpResponse(200, OPERATION_TIMEOUT_RES));
-        Assert.assertEquals(
-                CommandStatus.TIMED_OUT,
-                mHOUtil.cvdOperationExecution(mMockHttpClient, "1111", "POST", "request", 5)
-                        .getStatus());
+                .thenReturn(mockHttpResponse(500, "server error"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.removeInstance().getStatus());
     }
 
     @Test
-    public void testParseListCvdOutput_success() throws Exception {
+    public void testRemoveInstance_EmptyList() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1393,12 +716,19 @@ public class HostOrchestratorUtilTest {
                         TARGET_REGION,
                         ACCOUNTING_USER,
                         mMockClient,
-                        mMockHttpClient);
-        Assert.assertEquals("cvd_1", mHOUtil.parseListCvdOutput(LIST_CVD_RES, "group"));
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_EMPTY));
+        Assert.assertNull(mHOUtil.removeInstance());
     }
 
     @Test
-    public void testParseListCvdOutput_failed() throws Exception {
+    public void testWaitForOperation_Timedout() throws Exception {
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1409,14 +739,39 @@ public class HostOrchestratorUtilTest {
                         TARGET_REGION,
                         ACCOUNTING_USER,
                         mMockClient,
-                        null);
-        Assert.assertEquals("", mHOUtil.parseListCvdOutput(LIST_CVD_BADRES, "group"));
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, OPERATION_TIMEOUT_RES));
+        TimeoutException caught = null;
+        try {
+            mHOUtil.waitForOperation(mMockHttpClient, "http://ho.test", "foo", 1000);
+        } catch (TimeoutException e) {
+            caught = e;
+        }
+        Assert.assertNotNull(caught);
     }
 
     @Test
     public void testDeviceBootCompleted_success() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1428,38 +783,32 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStdout(LIST_CVD_RES);
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_RES));
         Assert.assertTrue(mHOUtil.deviceBootCompleted(10));
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
     }
 
     @Test
     public void testDeviceBootCompleted_failed() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1471,39 +820,32 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStdout(LIST_CVD_STARTING_RES);
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
         Assert.assertFalse(mHOUtil.deviceBootCompleted(10));
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-        // Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
     }
 
     @Test
     public void testDeviceBootCompleted_CreateHOFailed() throws Exception {
         Mockito.doReturn(1111).when(mMockClient).createServerSocket();
         Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
         mHOUtil =
                 new HostOrchestratorUtil(
                         true,
@@ -1515,21 +857,15 @@ public class HostOrchestratorUtilTest {
                         ACCOUNTING_USER,
                         mMockClient,
                         mMockHttpClient) {
-                    @Override
-                    public Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
                 };
         Assert.assertFalse(mHOUtil.deviceBootCompleted(10));
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
     }
 
-    private static HttpResponse<String> mockHttpResponse(int statusCode, String body) {
+    private static <T> HttpResponse<T> mockHttpResponse(int statusCode, T body) {
         return new HttpResponse<>() {
             @Override
             public int statusCode() {
@@ -1542,12 +878,12 @@ public class HostOrchestratorUtilTest {
             }
 
             @Override
-            public String body() {
+            public T body() {
                 return body;
             }
 
             @Override
-            public Optional<HttpResponse<String>> previousResponse() {
+            public Optional<HttpResponse<T>> previousResponse() {
                 return Optional.empty();
             }
 
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/InspectionUtilTest.java b/avd_util/javatests/com/android/tradefed/util/avd/InspectionUtilTest.java
new file mode 100644
index 000000000..326d73e04
--- /dev/null
+++ b/avd_util/javatests/com/android/tradefed/util/avd/InspectionUtilTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Optional;
+
+/** Unit tests for {@link InspectionUtil} */
+@RunWith(JUnit4.class)
+public class InspectionUtilTest {
+    // Sample output of `top bn1`
+    private static final String PROCESSES =
+            "Tasks: 51 total,   1 running,  50 sleeping,   0 stopped,   0 zombie\n"
+                + "Mem:    15984M total,    15640M used,      343M free,      102M buffers\n"
+                + "Swap:        0M total,        0M used,        0M free,    14051M cached\n"
+                + "400%cpu 288%user   0%nice   8%sys  96%idle   8%iow   0%irq   0%sirq   0%host\n"
+                + "PID USER         PR  NI VIRT  RES  SHR S[%CPU] %MEM     TIME+ ARGS\n"
+                + "915 root         20   0 6.1G 2.8G 2.8G S  280  18.3  25:06.81 run_cvd \n"
+                + "925 root         20   0 6.1G 2.8G 2.8G S  280  18.3  25:06.81 crosvm"
+                + " --extended-status run\n"
+                + "510 root         20   0 1.1G  50M  29M S  4.0   0.3   0:30.08 webRTC -group_id="
+                + " -touch_fds=89\n"
+                + "395 root         20   0  15M 2.9M 1.8M S  0.0   0.0   0:00.00 nginx: worker"
+                + " process\n"
+                + "525 root         20   0 816M  14M  13M S  0.0   0.0   0:01.46"
+                + " openwrt_control_server --grpc_uds_path=/tmp/cf_avd_0/cvd-1\n"
+                + "529 root         20   0 1.7G  22M  21M S  0.0   0.1   1:50.47 netsimd -s \n"
+                + "923 root         20   0 6.1G 2.8G 2.8G S  280  18.3  25:06.81 crosvm"
+                + " --extended-status run\n";
+
+    // Sample output of `df -P /`
+    private static final String DISKSPACE_INFO =
+            "Filesystem     1024-blocks     Used Available Capacity Mounted on\n"
+                    + "overlay           50620216 15385508  35218324      31% /";
+
+    /** Test getDiskspaceUsag. */
+    @Test
+    public void testGetDiskspaceUsage() throws Exception {
+        Optional<Integer> usedPercentage = InspectionUtil.getDiskspaceUsage(DISKSPACE_INFO);
+        assertEquals((Integer) 31, usedPercentage.get());
+
+        usedPercentage = InspectionUtil.getDiskspaceUsage("");
+        assertFalse(usedPercentage.isPresent());
+    }
+
+    /** Test searchProcess. */
+    @Test
+    public void testSearchProcess() throws Exception {
+        for (String p : InspectionUtil.EXPECTED_PROCESSES.keySet()) {
+            assertTrue(InspectionUtil.searchProcess(PROCESSES, p));
+        }
+        assertFalse(InspectionUtil.searchProcess(PROCESSES, "non-existing"));
+    }
+
+    /** Test convertErrorSignatureToIdentifier. */
+    @Test
+    public void testConvertErrorSignatureToIdentifier() throws Exception {
+        final String s1 = "fetch_cvd_failure_general,fetch_cvd_failure_resolve_host";
+        assertEquals(
+                InspectionUtil.convertErrorSignatureToIdentifier(s1),
+                InfraErrorIdentifier.CUTTLEFISH_LAUNCH_FAILURE_CVD_RESOLVE_HOST);
+    }
+}
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java b/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java
index f0f9b0f18..dc4d8d28f 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java
@@ -433,7 +433,64 @@ public class OxygenClientTest {
                         LEASE_LENGTH,
                         mExtraOxygenArgs,
                         attributes,
-                        GCE_CMD_TIMEOUT);
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /** Test leasing multiple devices with Oxygen client binary from OmniLab's infra. */
+    @Test
+    public void testLeaseMultipleDeviceOnOmniLab() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease"
+                                                + " -build_target target,target"
+                                                + " -build_branch testBranch,testBranch"
+                                                + " -build_id P1234567,P1234567"
+                                                + " -multidevice_size 2"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseMultipleDevices(
+                        Arrays.asList(BUILD_TARGET, BUILD_TARGET),
+                        Arrays.asList(BUILD_BRANCH, BUILD_BRANCH),
+                        Arrays.asList(BUILD_ID, BUILD_ID),
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
         assertEquals(res.getStatus(), CommandStatus.SUCCESS);
         assertEquals(res.getStderr(), EXPECTED_OUTPUT);
     }
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
index 345e38507..f084fed8c 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
@@ -27,7 +27,12 @@ import org.junit.runners.Suite.SuiteClasses;
  * dependencies.
  */
 @RunWith(Suite.class)
-@SuiteClasses({AcloudUtilTest.class, HostOrchestratorUtilTest.class, OxygenClientTest.class})
+@SuiteClasses({
+    AcloudUtilTest.class,
+    HostOrchestratorUtilTest.class,
+    OxygenClientTest.class,
+    InspectionUtilTest.class
+})
 public class UnitTests {
     // empty of purpose
 }
diff --git a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
index dae741783..296d67c90 100644
--- a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
+++ b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
@@ -209,6 +209,7 @@ public class InvocationMetricLogger {
         OXYGEN_DEVICE_DIRECT_RELEASE_COUNT("oxygen_device_direct_release_count", true),
         OXYGEN_DEVICE_RELEASE_FAILURE_COUNT("oxygen_device_release_failure_count", true),
         OXYGEN_DEVICE_RELEASE_FAILURE_MESSAGE("oxygen_device_release_failure_message", true),
+        ACLOUD_DEVICE_RELEASE_FAILURE_COUNT("acloud_device_release_failure_count", true),
 
         DYNAMIC_FILE_RESOLVER_PAIR("tf_dynamic_resolver_pair_timestamp", true),
         ARTIFACTS_DOWNLOAD_SIZE("tf_artifacts_download_size_bytes", true),
@@ -314,6 +315,8 @@ public class InvocationMetricLogger {
         ANTS_MODULE_END_TIME("ants_module_end_time", true),
         ANTS_RUN_START_TIME("ants_run_start_time", true),
         ANTS_RUN_END_TIME("ants_run_end_time", true),
+        // Count of modules with missing testIdentifier
+        ANTS_KNOWN_FAILURE_MODULE_ERROR_COUNT("ants_known_failure_module_error_count", true),
 
         DUPLICATE_MAPPING_DIFFERENT_OPTIONS("duplicate_mapping_different_options", true),
 
@@ -374,6 +377,7 @@ public class InvocationMetricLogger {
         SKIP_NO_CHANGES("skip_no_changes", true),
         NO_CHANGES_POSTSUBMIT("no_changes_postsubmit", true),
         SILENT_INVOCATION_SKIP_COUNT("silent_invocation_skip_count", true),
+        ERROR_INVOCATION_SKIP("error_invocation_skip", true),
         DEMOTION_FILTERS_RECEIVED_COUNT("demotion_filters_received_count", true),
         DEMOTION_ERROR_RESPONSE("demotion_error_response", true),
         SEARCH_ARTIFACT_FAILURE_COUNT("search_artifact_failure_count", true),
@@ -418,6 +422,17 @@ public class InvocationMetricLogger {
         MODULE_CACHE_MISS_ID("module_cache_miss_id", true),
         MODULE_CACHE_NO_DIR("module_cache_no_dir", true),
         MODULE_RESULTS_CACHE_DEVICE_MISMATCH("module_results_cache_device_mismatch", true),
+        // Invocation level caching
+        INVOCATION_RESULTS_CHECKING_CACHE("invocation_results_checking_cache", true),
+        INVOCATION_CACHE_HIT("invocation_cache_hit", true),
+
+        // Oxygenation metrics
+        PORTFORWARD_LHP_SUCCESS_COUNT("portfoward_lhp_success_count", true),
+        PORTFORWARD_LHP_FAIL_COUNT("portfoward_lhp_fail_count", true),
+
+        // Host orchestrator metrics
+        CVD_LONG_OPERATION_TIMEOUT_API("cvd_long_operation_timeout_api", true),
+        UNSUPPORTED_HOST_ORCHESTRATOR_API("unsupported_host_orchestrator_api", true),
         ;
 
         private final String mKeyName;
diff --git a/common_util/com/android/tradefed/result/LogDataType.java b/common_util/com/android/tradefed/result/LogDataType.java
index 2ea41bc04..a60fb7606 100644
--- a/common_util/com/android/tradefed/result/LogDataType.java
+++ b/common_util/com/android/tradefed/result/LogDataType.java
@@ -101,6 +101,7 @@ public enum LogDataType {
     CUTTLEFISH_LOG("txt", "text/plain", true, true), // Log from cuttlefish instance
     TOMBSTONEZ("zip", "application/zip", true, false),
     BT_SNOOP_LOG("log", "application/octet-stream", false, false), // Bluetooth HCI snoop logs
+    WINSCOPE("winscope.zip", "application/zip", true, false),
     /* Unknown file type */
     UNKNOWN("dat", "text/plain", false, false);
 
diff --git a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
index 7290b8277..55c5b6dd5 100644
--- a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
+++ b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
@@ -98,7 +98,7 @@ public enum InfraErrorIdentifier implements ErrorIdentifier {
     OXYGEN_CLIENT_BINARY_ERROR(505_019, FailureStatus.INFRA_FAILURE),
     OXYGEN_CLIENT_LEASE_ERROR(505_020, FailureStatus.INFRA_FAILURE),
     OXYGEN_NOT_ENOUGH_RESOURCE(505_021, FailureStatus.INFRA_FAILURE),
-    OXYGEN_DEVICE_LAUNCHER_TIMEOUT(505_022, FailureStatus.INFRA_FAILURE),
+    OXYGEN_DEVICE_LAUNCHER_TIMEOUT(505_022, FailureStatus.LOST_SYSTEM_UNDER_TEST),
     OXYGEN_SERVER_LB_CONNECTION_ERROR(505_023, FailureStatus.INFRA_FAILURE),
     ACLOUD_INVALID_SERVICE_ACCOUNT_KEY(505_024, FailureStatus.DEPENDENCY_ISSUE),
     ACLOUD_QUOTA_EXCEED_GPU(505_025, FailureStatus.DEPENDENCY_ISSUE),
@@ -113,6 +113,25 @@ public enum InfraErrorIdentifier implements ErrorIdentifier {
     TEST_MAPPING_FILE_FORMAT_ISSUE(505_257, FailureStatus.CUSTOMER_ISSUE),
     TEST_MAPPING_FILE_NOT_EXIST(505_258, FailureStatus.CUSTOMER_ISSUE),
 
+    // 505_301 - 505_400: Cuttlefish launch failure
+    // Cuttlefish boot failure signature: bluetooth_failed
+    CUTTLEFISH_LAUNCH_FAILURE_BLUETOOTH(505_301, FailureStatus.DEPENDENCY_ISSUE),
+    // Cuttlefish boot failure signature: fetch_cvd_failure_resolve_host
+    CUTTLEFISH_LAUNCH_FAILURE_CVD_RESOLVE_HOST(505_302, FailureStatus.DEPENDENCY_ISSUE),
+    // Cuttlefish boot failure signature: fetch_cvd_failure_connect_server
+    CUTTLEFISH_LAUNCH_FAILURE_CVD_SERVER_CONNECTION(505_303, FailureStatus.DEPENDENCY_ISSUE),
+    // Cuttlefish boot failure signature: launch_cvd_port_collision
+    CUTTLEFISH_LAUNCH_FAILURE_CVD_PORT_COLLISION(505_304, FailureStatus.DEPENDENCY_ISSUE),
+    // Cuttlefish boot failure signature: fetch_cvd_failure_general
+    CUTTLEFISH_LAUNCH_FAILURE_CVD_FETCH(505_305, FailureStatus.DEPENDENCY_ISSUE),
+    // Cuttlefish boot failure signature: cf_webrtc_crash
+    CUTTLEFISH_LAUNCH_FAILURE_WEBRTC_CRASH(505_306, FailureStatus.DEPENDENCY_ISSUE),
+    CUTTLEFISH_LAUNCH_FAILURE_OPENWRT(505_307, FailureStatus.DEPENDENCY_ISSUE),
+    CUTTLEFISH_LAUNCH_FAILURE_CROSVM(505_308, FailureStatus.DEPENDENCY_ISSUE),
+    CUTTLEFISH_LAUNCH_FAILURE_NGINX(505_309, FailureStatus.DEPENDENCY_ISSUE),
+    CUTTLEFISH_LAUNCH_FAILURE_CVD_FETCH_HANG(505_310, FailureStatus.DEPENDENCY_ISSUE),
+    CUTTLEFISH_LAUNCH_FAILURE_RUN_CVD_MISSING(505_311, FailureStatus.DEPENDENCY_ISSUE),
+
     UNDETERMINED(510_000, FailureStatus.UNSET);
 
     private final long code;
diff --git a/common_util/com/android/tradefed/util/DeviceInspectionResult.java b/common_util/com/android/tradefed/util/DeviceInspectionResult.java
new file mode 100644
index 000000000..918cbf79f
--- /dev/null
+++ b/common_util/com/android/tradefed/util/DeviceInspectionResult.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.result.error.ErrorIdentifier;
+
+/** A class contains the device inspection result when a device becomes unavailable. */
+public class DeviceInspectionResult {
+
+    // Explicit device error based on inspection.
+    private ErrorIdentifier mErrorIdentifier = null;
+
+    // Details about the inspection result.
+    private String mDetails = null;
+
+    public DeviceInspectionResult(ErrorIdentifier identifier, String details) {
+        mErrorIdentifier = identifier;
+        mDetails = details;
+    }
+
+    public ErrorIdentifier getErrorIdentifier() {
+        return mErrorIdentifier;
+    }
+
+    public String getDetails() {
+        return mDetails;
+    }
+}
diff --git a/common_util/com/android/tradefed/util/FileUtil.java b/common_util/com/android/tradefed/util/FileUtil.java
index 47843a661..7d9aca22e 100644
--- a/common_util/com/android/tradefed/util/FileUtil.java
+++ b/common_util/com/android/tradefed/util/FileUtil.java
@@ -483,6 +483,29 @@ public class FileUtil {
                 CLog.d("Hardlink failed: '%s', falling back to copy.", e.getMessage());
                 copyFile(origFile, destFile);
                 return;
+            } else if (e.getMessage().contains(" Too many links")) {
+                String filePath = origFile.getAbsolutePath();
+                Path path = Paths.get(filePath);
+
+                try {
+                    // Get file attributes - link count
+                    long linkCount = ((Integer) Files.getAttribute(path, "unix:nlink")).intValue();
+                    CLog.d(
+                            "Too many links for file: %s, Hard link count: %d",
+                            origFile.getAbsolutePath(), linkCount);
+                    String destDir = destFile.getParent();
+                    // All hosts are on Linux, so we can use df to get the filesystem stats.
+                    CommandResult result =
+                            RunUtil.getDefault()
+                                    .runTimedCmd(
+                                            10 * 1000, "df", destDir);
+                    if (result.getExitCode() == 0) {
+                        CLog.d("df output for %s: %s", destFile, result.getStdout());
+                    }
+                } catch (IOException ioe) {
+                    CLog.e("Error retrieving file or filesystem stats: " + ioe.getMessage());
+                }
+                throw e;
             }
             throw e;
         }
diff --git a/copy.bara.sky b/copy.bara.sky
new file mode 100644
index 000000000..b9438a26b
--- /dev/null
+++ b/copy.bara.sky
@@ -0,0 +1,70 @@
+git_files = glob(
+  include = ["resultdb/proto/v1/*.proto"]
+)
+
+dest_files = glob(
+  include = ["proto/resultdb/*"]
+)
+
+# Generate a CL that copy ResultDB proto to the current codebase under proto/resultdb/*.
+# Require mannully run this command in the current directory: copybara copy.bara.sky resultdb.
+core.workflow(
+   name = "resultdb",
+   origin =  git.origin(
+        url = "rpc://chromium/infra/luci/luci-go",
+        ref = "main",
+    ),
+   authoring = authoring.pass_thru("Android Tradefed <android-tradefed@google.com>"),
+   origin_files = git_files,
+   destination_files = dest_files,
+   transformations = [
+    core.move("resultdb/proto/v1", "proto/resultdb/"),
+    core.replace(
+      before = '''// Copyright ${year} The LUCI Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.''',
+      after = '''/*
+* Copyright (C) ${year} The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/''',
+      multiline = True,
+      regex_groups = {'year' : '[0-9]{4}'}
+    ),
+    core.replace(
+      before = "option java_package = \"com.google.luci.resultdb.v1\";",
+      after = "option java_package = \"com.android.resultdb.proto\";"
+    ),
+    core.replace(
+      before = "import \"go.chromium.org/luci/resultdb/proto/v1/",
+      after = "import public \"tools/tradefederation/core/proto/resultdb/"
+    )
+   ],
+   ask_for_confirmation = True,
+
+   destination =  git.gerrit_destination(
+        url = "rpc://googleplex-android/platform/tools/tradefederation",
+        fetch = "main",
+        push_to_refs_for = "main",
+    )
+)
diff --git a/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java b/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
index 82b5ac68f..a6cbb1cb2 100644
--- a/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
@@ -16,6 +16,7 @@
 package com.android.tradefed.device;
 
 import com.android.ddmlib.IDevice;
+import com.android.tradefed.util.DeviceInspectionResult;
 
 /**
  * A ITestDevice whose lifecycle is managed.
@@ -132,4 +133,7 @@ public interface IManagedTestDevice extends ITestDevice {
 
     /** Return the SIM card operator or null if not available or if device is not available. */
     public String getSimOperator();
+
+    /** Inspect a device and return detailed info when a device becomes unavailable. */
+    public DeviceInspectionResult debugDeviceNotAvailable();
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
index 5904a975f..33972d5e3 100644
--- a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
@@ -1728,4 +1728,19 @@ public interface INativeDevice {
      * @throws DeviceNotAvailableException
      */
     public void unmountDebugfs() throws DeviceNotAvailableException;
+
+    /**
+     * Enable testing trade-in mode. The device will be wiped and will reboot.
+     *
+     * @throws DeviceNotAvailableException
+     * @return True if we were successful, false otherwise
+     */
+    public boolean startTradeInModeTesting(final int timeoutMs) throws DeviceNotAvailableException;
+
+    /**
+     * Stop testing trade-in mode. The device will reboot.
+     *
+     * @throws DeviceNotAvailableException
+     */
+    public void stopTradeInModeTesting() throws DeviceNotAvailableException;
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
index ffc185e51..2e64ca7a4 100644
--- a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
+++ b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
@@ -420,6 +420,9 @@ public class TestDeviceOptions {
                             + " tests against an oxygenation device.")
     private boolean mUseOxygenationDevice = false;
 
+    @Option(name = "force-evaluate-connection")
+    private boolean mForceEvaluateDeviceConnection = false;
+
     // END ====================== Options Related to Virtual Devices ======================
 
     // Option related to Remote Device only
@@ -1048,5 +1051,9 @@ public class TestDeviceOptions {
         }
         return false;
     }
+
+    public boolean evaluateDeviceConnection() {
+        return mForceEvaluateDeviceConnection;
+    }
 }
 
diff --git a/global_configuration/OWNERS b/global_configuration/OWNERS
index 680267320..a229f7fb2 100644
--- a/global_configuration/OWNERS
+++ b/global_configuration/OWNERS
@@ -1,4 +1,3 @@
 # host/ drives host related setup or configuration: base OWNERS +
 fangk@google.com
 jeffreylu@google.com
-xingdai@google.com
diff --git a/global_configuration/com/android/tradefed/host/HostOptions.java b/global_configuration/com/android/tradefed/host/HostOptions.java
index 8b52b6572..502398d53 100644
--- a/global_configuration/com/android/tradefed/host/HostOptions.java
+++ b/global_configuration/com/android/tradefed/host/HostOptions.java
@@ -127,6 +127,11 @@ public class HostOptions implements IHostOptions {
             description = "Preconfigured virtual device pool. (Value format: $hostname:$user.)")
     private List<String> mPreconfiguredVirtualDevicePool = new ArrayList<>();
 
+    @Option(
+            name = "preconfigured-native-device-pool",
+            description = "Preconfigured Native virtual device pool. (Value format: $hostname.)")
+    private List<String> mPreconfiguredNativeDevicePool = new ArrayList<>();
+
     @Option(
             name = "flash-with-fuse-zip",
             description = "Use `fastboot flashall` on a folder of fuse mounted device image zip "
@@ -258,6 +263,12 @@ public class HostOptions implements IHostOptions {
         return new ArrayList<>(mPreconfiguredVirtualDevicePool);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public List<String> getKnownPreconfigureNativeDevicePool() {
+        return new ArrayList<>(mPreconfiguredNativeDevicePool);
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean getUseZip64InPartialDownload() {
diff --git a/global_configuration/com/android/tradefed/host/IHostOptions.java b/global_configuration/com/android/tradefed/host/IHostOptions.java
index fd66657dc..97f0876d9 100644
--- a/global_configuration/com/android/tradefed/host/IHostOptions.java
+++ b/global_configuration/com/android/tradefed/host/IHostOptions.java
@@ -96,6 +96,9 @@ public interface IHostOptions {
     /** Known preconfigured virtual device pool. */
     List<String> getKnownPreconfigureVirtualDevicePool();
 
+    /** Known preconfigured native device ip pool. */
+    List<String> getKnownPreconfigureNativeDevicePool();
+
     /** Check if it should use the zip64 format in partial download or not. */
     boolean getUseZip64InPartialDownload();
 
diff --git a/invocation_interfaces/com/android/tradefed/result/TestRunResult.java b/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
index cbf9de621..0baccf6aa 100644
--- a/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
+++ b/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.result;
 
+import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.skipped.SkipReason;
@@ -24,6 +25,7 @@ import com.android.tradefed.util.proto.TfMetricProtoUtil;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -130,6 +132,18 @@ public class TestRunResult {
         return tests;
     }
 
+    /** Gets the set of tests in given statuses. */
+    public Map<TestDescription, TestResult> getTestEntriesInState(Collection<TestStatus> statuses) {
+        Map<TestDescription, TestResult> tests = new LinkedHashMap<>();
+        for (Map.Entry<TestDescription, TestResult> testEntry : getTestResults().entrySet()) {
+            TestStatus status = testEntry.getValue().getResultStatus();
+            if (statuses.contains(status)) {
+                tests.put(testEntry.getKey(), testEntry.getValue());
+            }
+        }
+        return tests;
+    }
+
     /** @return <code>true</code> if test run failed. */
     public boolean isRunFailure() {
         return mRunFailureError != null;
@@ -301,7 +315,8 @@ public class TestRunResult {
         addTestResult(test, mCurrentTestResult);
     }
 
-    private void addTestResult(TestDescription test, TestResult testResult) {
+    @VisibleForTesting
+    public void addTestResult(TestDescription test, TestResult testResult) {
         mIsCountDirty = true;
         mTestResults.put(test, testResult);
     }
diff --git a/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
index a4510ea2a..db2fd4e95 100644
--- a/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
+++ b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
@@ -118,6 +118,7 @@ public class SearchArtifactUtil {
      * @param altDirs Alternative search paths, in addition to the default search paths.
      * @param altDirBehavior how alternative search paths should be used against default paths: as
      *     fallback, or as override; if unspecified, fallback will be used
+     * @param testInfo The {@link TestInformation} of the current test when available.
      * @return The found artifact file or null if none.
      */
     public static File searchFile(
@@ -127,13 +128,41 @@ public class SearchArtifactUtil {
             List<File> altDirs,
             AltDirBehavior altDirBehavior,
             TestInformation testInfo) {
+        return searchFile(fileName, targetFirst, abi, altDirs, altDirBehavior, testInfo, false);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param abi The {@link IAbi} to match the file.
+     * @param altDirs Alternative search paths, in addition to the default search paths.
+     * @param altDirBehavior how alternative search paths should be used against default paths: as
+     *     fallback, or as override; if unspecified, fallback will be used
+     * @param testInfo The {@link TestInformation} of the current test when available.
+     * @param includeDirectory whether to include directories in the search result.
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(
+            String fileName,
+            boolean targetFirst,
+            IAbi abi,
+            List<File> altDirs,
+            AltDirBehavior altDirBehavior,
+            TestInformation testInfo,
+            boolean includeDirectory) {
         List<File> searchDirectories =
                 singleton.getSearchDirectories(targetFirst, altDirs, altDirBehavior, testInfo);
-
+        CLog.d("Searching for file %s. Search directories: %s", fileName, searchDirectories);
         // Search in the test directories
         for (File dir : searchDirectories) {
-            File file = findFile(fileName, abi, dir);
+            File file = findFile(fileName, abi, dir, includeDirectory);
             if (fileExists(file)) {
+                CLog.d(
+                        "Found file %s in search directory %s.",
+                        file.getAbsolutePath(), dir.getAbsolutePath());
                 return file;
             }
         }
@@ -142,6 +171,7 @@ public class SearchArtifactUtil {
         if (executionFiles != null) {
             File file = executionFiles.get(fileName);
             if (fileExists(file)) {
+                CLog.d("Found file %s in execution files object.", file.getAbsolutePath());
                 return file;
             }
         }
@@ -151,6 +181,7 @@ public class SearchArtifactUtil {
         if (buildInfo != null) {
             File file = buildInfo.getFile(fileName);
             if (fileExists(file)) {
+                CLog.d("Found file %s in build info.", file.getAbsolutePath());
                 return file;
             } else {
                 // fallback to staging from remote zip files.
@@ -162,10 +193,11 @@ public class SearchArtifactUtil {
                     buildInfo.stageRemoteFile(fileName, stagingDir);
                     // multiple matching files can be staged. So do a search with module name and
                     // abi in consideration.
-                    file = findFile(fileName, abi, stagingDir);
+                    file = findFile(fileName, abi, stagingDir, includeDirectory);
                     if (fileExists(file)) {
                         InvocationMetricLogger.addInvocationMetrics(
                                 InvocationMetricKey.STAGE_UNDEFINED_DEPENDENCY, fileName);
+                        CLog.d("Found file %s after staging remote file.", file.getAbsolutePath());
                         return file;
                     }
                 }
@@ -260,7 +292,8 @@ public class SearchArtifactUtil {
     }
 
     /** Searches for the file in the given search directory and possibly matching the abi. */
-    private static File findFile(String filename, IAbi abi, File searchDirectory) {
+    private static File findFile(
+            String filename, IAbi abi, File searchDirectory, boolean includeDirectory) {
         if (filename == null || searchDirectory == null || !searchDirectory.exists()) {
             return null;
         }
@@ -275,16 +308,39 @@ public class SearchArtifactUtil {
             try {
                 File moduleDir = FileUtil.findDirectory(moduleName, searchDirectory);
                 if (moduleDir != null) {
-                    CLog.d("Searching the module dir: %s", moduleDir);
-                    // search with abi filtering on first
-                    retFile = FileUtil.findFile(filename, abi, moduleDir);
-                    if (fileExists(retFile)) {
-                        return retFile;
+                    // return the entire module directory if it matches the search file name
+                    if (includeDirectory && moduleName.equals(filename)) {
+                        return moduleDir;
                     }
-                    // search without the abi filter
-                    retFile = FileUtil.findFile(filename, null, moduleDir);
-                    if (fileExists(retFile)) {
-                        return retFile;
+                    CLog.d("Searching the module dir: %s", moduleDir);
+                    Set<File> allMatch =
+                            FileUtil.findFiles(filename, abi, includeDirectory, moduleDir);
+                    if (!allMatch.isEmpty()) {
+                        if (allMatch.size() != 1) {
+                            // when directories are included in the search, return any top
+                            // level directory if present, otherwise return any file.
+                            if (includeDirectory) {
+                                List<File> directoriesMatched = new LinkedList<>();
+                                for (File f : allMatch) {
+                                    if (f.isDirectory()) {
+                                        directoriesMatched.add(f);
+                                    }
+                                }
+                                if (!directoriesMatched.isEmpty()) {
+                                    for (File directory : directoriesMatched) {
+                                        if (isTopLevelDirectory(directory, allMatch)) {
+                                            return directory;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        // when only one file is found, OR
+                        // when only files were searched (no dir) and multiple files matched, OR
+                        // when directory and files both were searched, but no directory is present
+                        // or no directory is top level
+                        // return any file/directory since we do not know which to return.
+                        return allMatch.iterator().next();
                     }
                 } else {
                     CLog.w(
@@ -301,7 +357,8 @@ public class SearchArtifactUtil {
 
         // if module subdirectory not present or file not found, search under the entire directory
         try {
-            Set<File> allMatch = FileUtil.findFilesObject(searchDirectory, filename, false);
+            Set<File> allMatch =
+                    FileUtil.findFilesObject(searchDirectory, filename, includeDirectory);
             if (allMatch.size() == 1) {
                 // if only one file found, return this one since we can not filter anymore.
                 return allMatch.iterator().next();
@@ -312,18 +369,28 @@ public class SearchArtifactUtil {
                         return f;
                     }
                 }
-                // if top level not found, prioritize the one with the correct abi
-                if (abi != null) {
-                    for (File f : allMatch) {
-                        if (f.getParentFile()
-                                .getName()
-                                .equals(AbiUtils.getArchForAbi(abi.getName()))) {
-                            return f;
-                        }
+            }
+            // Fall-back to searching everything
+            if (!includeDirectory) {
+                allMatch = FileUtil.findFiles(filename, abi, false, searchDirectory);
+                if (!allMatch.isEmpty()) {
+                    return allMatch.iterator().next();
+                }
+            } else {
+                retFile = FileUtil.findFile(filename, null, searchDirectory);
+                if (retFile != null) {
+                    // Search again with filtering on ABI
+                    File fileWithAbi = FileUtil.findFile(filename, abi, searchDirectory);
+                    if (fileWithAbi != null
+                            && !fileWithAbi
+                                    .getAbsolutePath()
+                                    .startsWith(retFile.getAbsolutePath())) {
+                        // When multiple matches are found, return the one with matching
+                        // ABI unless src is its parent directory.
+                        return fileWithAbi;
                     }
+                    return retFile;
                 }
-                // if abi not matches, return any of them
-                return allMatch.iterator().next();
             }
         } catch (IOException e) {
             CLog.w(
@@ -337,10 +404,15 @@ public class SearchArtifactUtil {
 
     public static File getModuleDirFromConfig(IInvocationContext moduleContext) {
         if (moduleContext != null) {
+            return getModuleDirFromConfig(moduleContext.getConfigurationDescriptor());
+        }
+        return null;
+    }
+
+    public static File getModuleDirFromConfig(ConfigurationDescriptor descriptor) {
+        if (descriptor != null) {
             List<String> moduleDirPath =
-                    moduleContext
-                            .getConfigurationDescriptor()
-                            .getMetaData(ConfigurationDescriptor.MODULE_DIR_PATH_KEY);
+                    descriptor.getMetaData(ConfigurationDescriptor.MODULE_DIR_PATH_KEY);
             if (moduleDirPath != null && !moduleDirPath.isEmpty()) {
                 File moduleDir = new File(moduleDirPath.get(0));
                 if (moduleDir.exists()) {
@@ -439,4 +511,17 @@ public class SearchArtifactUtil {
     private static boolean fileExists(File file) {
         return file != null && file.exists();
     }
+
+    /**
+     * Checks whether a directory can be considered a top level directory. A top level directory
+     * will contain all the files that are given in the list.
+     */
+    private static boolean isTopLevelDirectory(File directoryToCheck, Set<File> files) {
+        for (File f : files) {
+            if (!f.getAbsolutePath().startsWith(directoryToCheck.getAbsolutePath())) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
diff --git a/isolation/Android.bp b/isolation/Android.bp
index 4e746f620..d63556bc5 100644
--- a/isolation/Android.bp
+++ b/isolation/Android.bp
@@ -20,6 +20,7 @@ java_library_host {
     name: "tradefed-isolation",
     visibility: [
         "//tools/tradefederation/core/test_framework",
+        "//vendor:__subpackages__",
     ],
     defaults: ["tradefed_defaults"],
     srcs: [
diff --git a/javatests/.classpath b/javatests/.classpath
index eacebd764..60e6a97f4 100644
--- a/javatests/.classpath
+++ b/javatests/.classpath
@@ -23,7 +23,7 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/tools-common/tools-common-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/tools/common/m2/repository/org/mockito/mockito-core/4.6.1/mockito-core-4.6.1.jar" sourcepath="/TRADEFED_ROOT/prebuilts/tools/common/m2/repository/org/mockito/mockito-core/4.6.1/mockito-core-4.6.1-sources.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/truth/truth/linux_glibc_common/combined/truth.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jacoco/jacoco-cli/linux_glibc_common/combined/jacoco-cli.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jacoco/jacoco-cli/linux_glibc_common/withres/jacoco-cli.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-protos/linux_glibc_common/combined/tradefed-protos.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/tools/common/google-api-services-storage/1.24.1/google-api-services-storage-v1-rev155-1.24.1.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/perfetto/perfetto_metrics-full/linux_glibc_common/combined/perfetto_metrics-full.jar"/>
diff --git a/javatests/com/android/tradefed/UnitTests.java b/javatests/com/android/tradefed/UnitTests.java
index 51b89eafb..3e009a0d1 100644
--- a/javatests/com/android/tradefed/UnitTests.java
+++ b/javatests/com/android/tradefed/UnitTests.java
@@ -102,7 +102,6 @@ import com.android.tradefed.device.cloud.CommonLogRemoteFileUtilTest;
 import com.android.tradefed.device.cloud.GceAvdInfoTest;
 import com.android.tradefed.device.cloud.GceManagerTest;
 import com.android.tradefed.device.cloud.GceSshTunnelMonitorTest;
-import com.android.tradefed.device.cloud.ManagedRemoteDeviceTest;
 import com.android.tradefed.device.cloud.NestedRemoteDeviceTest;
 import com.android.tradefed.device.cloud.OxygenUtilTest;
 import com.android.tradefed.device.cloud.RemoteAndroidVirtualDeviceTest;
@@ -125,6 +124,7 @@ import com.android.tradefed.device.metric.BluetoothHciSnoopLogCollectorTest;
 import com.android.tradefed.device.metric.BugreportzOnFailureCollectorTest;
 import com.android.tradefed.device.metric.BugreportzOnTestCaseFailureCollectorTest;
 import com.android.tradefed.device.metric.ClangCodeCoverageCollectorTest;
+import com.android.tradefed.device.metric.CodeCoverageCollectorTest;
 import com.android.tradefed.device.metric.DebugHostLogOnFailureCollectorTest;
 import com.android.tradefed.device.metric.DeviceMetricDataTest;
 import com.android.tradefed.device.metric.EmulatorMemoryCpuCapturerTest;
@@ -189,6 +189,7 @@ import com.android.tradefed.monitoring.collector.DeviceWifiResourceMetricCollect
 import com.android.tradefed.monitoring.collector.ResourceMetricUtilTest;
 import com.android.tradefed.observatory.TestDiscoveryExecutorTest;
 import com.android.tradefed.observatory.TestDiscoveryInvokerTest;
+import com.android.tradefed.observatory.TestMappingDiscoveryAgentTest;
 import com.android.tradefed.postprocessor.AggregatePostProcessorTest;
 import com.android.tradefed.postprocessor.AveragePostProcessorTest;
 import com.android.tradefed.postprocessor.BasePostProcessorTest;
@@ -227,10 +228,13 @@ import com.android.tradefed.result.XmlResultReporterTest;
 import com.android.tradefed.result.ddmlib.TestRunToTestInvocationForwarderTest;
 import com.android.tradefed.result.error.ErrorIdentifierTest;
 import com.android.tradefed.result.proto.FileProtoResultReporterTest;
+import com.android.tradefed.result.proto.InvocationProtoResultReporterTest;
 import com.android.tradefed.result.proto.ModuleProtoResultReporterTest;
 import com.android.tradefed.result.proto.ProtoResultParserTest;
 import com.android.tradefed.result.proto.ProtoResultReporterTest;
 import com.android.tradefed.result.proto.StreamProtoResultReporterTest;
+import com.android.tradefed.result.resultdb.ResultDBReporterTest;
+import com.android.tradefed.result.resultdb.ResultDBUtilTest;
 import com.android.tradefed.result.skipped.SkipFeatureTest;
 import com.android.tradefed.result.skipped.SkipManagerTest;
 import com.android.tradefed.result.skipped.SkipReasonTest;
@@ -638,7 +642,6 @@ import org.junit.runners.Suite.SuiteClasses;
     GceAvdInfoTest.class,
     GceManagerTest.class,
     GceSshTunnelMonitorTest.class,
-    ManagedRemoteDeviceTest.class,
     NestedRemoteDeviceTest.class,
     OxygenUtilTest.class,
     RemoteAndroidVirtualDeviceTest.class,
@@ -671,6 +674,7 @@ import org.junit.runners.Suite.SuiteClasses;
     BugreportzOnTestCaseFailureCollectorTest.class,
     BugreportzOnFailureCollectorTest.class,
     ClangCodeCoverageCollectorTest.class,
+    CodeCoverageCollectorTest.class,
     DebugHostLogOnFailureCollectorTest.class,
     DeviceMetricDataTest.class,
     EmulatorMemoryCpuCapturerTest.class,
@@ -756,6 +760,7 @@ import org.junit.runners.Suite.SuiteClasses;
     // observatory
     TestDiscoveryExecutorTest.class,
     TestDiscoveryInvokerTest.class,
+    TestMappingDiscoveryAgentTest.class,
 
     // postprocessor
     AggregatePostProcessorTest.class,
@@ -804,11 +809,16 @@ import org.junit.runners.Suite.SuiteClasses;
 
     // result.proto
     FileProtoResultReporterTest.class,
+    InvocationProtoResultReporterTest.class,
     ModuleProtoResultReporterTest.class,
     ProtoResultParserTest.class,
     ProtoResultReporterTest.class,
     StreamProtoResultReporterTest.class,
 
+    // result.resultdb
+    ResultDBReporterTest.class,
+    ResultDBUtilTest.class,
+
     // result.skipped
     SkipFeatureTest.class,
     SkipManagerTest.class,
@@ -1107,6 +1117,7 @@ import org.junit.runners.Suite.SuiteClasses;
     TableFormatterTest.class,
     TarUtilTest.class,
     TestRunnerUtilTest.class,
+    TfTestLauncherTest.class,
     TimeUtilTest.class,
     TimeValTest.class,
     VersionParserTest.class,
diff --git a/javatests/com/android/tradefed/device/cloud/ManagedRemoteDeviceTest.java b/javatests/com/android/tradefed/device/cloud/ManagedRemoteDeviceTest.java
deleted file mode 100644
index e9858a24f..000000000
--- a/javatests/com/android/tradefed/device/cloud/ManagedRemoteDeviceTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.tradefed.device.cloud;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-
-import com.android.ddmlib.IDevice;
-import com.android.tradefed.config.GlobalConfiguration;
-import com.android.tradefed.device.DeviceNotAvailableException;
-import com.android.tradefed.device.IDeviceMonitor;
-import com.android.tradefed.device.IDeviceStateMonitor;
-import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.log.ITestLogger;
-
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
-
-/** Unit tests for {@link ManagedRemoteDevice}. */
-@RunWith(JUnit4.class)
-public class ManagedRemoteDeviceTest {
-    private ManagedRemoteDevice mDevice;
-    private IDevice mIDevice;
-    private IDeviceStateMonitor mStateMonitor;
-    private IDeviceMonitor mDeviceMonitor;
-    private ITestLogger mMockLogger;
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-        try {
-            GlobalConfiguration.createGlobalConfiguration(new String[] {"empty"});
-        } catch (IllegalStateException e) {
-            // Ignore
-        }
-    }
-
-    @Before
-    public void setUp() {
-        mIDevice = Mockito.mock(IDevice.class);
-        mStateMonitor = Mockito.mock(IDeviceStateMonitor.class);
-        mDeviceMonitor = Mockito.mock(IDeviceMonitor.class);
-        mMockLogger = Mockito.mock(ITestLogger.class);
-        mDevice =
-                new ManagedRemoteDevice(mIDevice, mStateMonitor, mDeviceMonitor) {
-                    @Override
-                    public int getApiLevel() throws DeviceNotAvailableException {
-                        return 29;
-                    }
-                };
-        mDevice.setTestLogger(mMockLogger);
-    }
-
-    @Test
-    public void testGetOptions() {
-        TestDeviceOptions originalOptions = new TestDeviceOptions();
-        mDevice.setOptions(originalOptions);
-        TestDeviceOptions get = mDevice.getOptions();
-        assertFalse(get.equals(originalOptions));
-        TestDeviceOptions get2 = mDevice.getOptions();
-        // Same during the same session
-        assertEquals(get2, get);
-
-        mDevice.postInvocationTearDown(null);
-        TestDeviceOptions get3 = mDevice.getOptions();
-        assertNotEquals(get2, get3);
-    }
-}
diff --git a/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java b/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
index 5af450c87..8b611b98e 100644
--- a/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
+++ b/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
@@ -107,6 +107,7 @@ public class OxygenUtilTest {
                             + "tailing string";
             FileUtil.writeToFile(content, file1);
             List<String> signatures = LogCollector.collectErrorSignatures(tmpDir);
+            assertEquals(2, signatures.size());
             assertEquals("crosvm_vcpu_hw_run_failure_7", signatures.get(0));
             assertEquals("launch_cvd_port_collision", signatures.get(1));
         } finally {
@@ -114,6 +115,39 @@ public class OxygenUtilTest {
         }
     }
 
+    /** Test collectErrorSignatures for log file that must contain certain log. */
+    @Test
+    public void testCollectErrorSignatures_mustHaveLogSuccess() throws Exception {
+        File tmpDir = null;
+        try {
+            tmpDir = FileUtil.createTempDir("logs");
+            File file1 = FileUtil.createTempFile("fetch.txt", ".randomstring", tmpDir);
+            String content = "some content\nsome content\nsome content\nCompleted all fetches";
+            FileUtil.writeToFile(content, file1);
+            List<String> signatures = LogCollector.collectErrorSignatures(tmpDir);
+            assertEquals(0, signatures.size());
+        } finally {
+            FileUtil.recursiveDelete(tmpDir);
+        }
+    }
+
+    /** Test collectErrorSignatures for log file that must contain certain log. */
+    @Test
+    public void testCollectErrorSignatures_mustHaveLogFail() throws Exception {
+        File tmpDir = null;
+        try {
+            tmpDir = FileUtil.createTempDir("logs");
+            File file1 = FileUtil.createTempFile("fetch.txt", ".randomstring", tmpDir);
+            String content = "some content\nsome content\nsome content";
+            FileUtil.writeToFile(content, file1);
+            List<String> signatures = LogCollector.collectErrorSignatures(tmpDir);
+            assertEquals(1, signatures.size());
+            assertEquals("fetch_cvd_failure_general", signatures.get(0));
+        } finally {
+            FileUtil.recursiveDelete(tmpDir);
+        }
+    }
+
     /**
      * Test collectDeviceLaunchMetrics before introducing cuttlefish-host-resources and
      * cuttlefish-operator replacing cuttlefish-common.
diff --git a/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java b/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
index 6f04c4ae6..d4eb62dda 100644
--- a/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
+++ b/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
@@ -16,7 +16,6 @@
 package com.android.tradefed.device.connection;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -52,6 +51,7 @@ import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.avd.HostOrchestratorUtil;
+import com.android.tradefed.util.avd.OxygenClient;
 
 import com.google.common.net.HostAndPort;
 
@@ -92,7 +92,10 @@ public class AdbSshConnectionTest {
     @Mock ITestDevice mMockTestDevice;
     @Mock GceAvdInfo mMockAvdInfo;
     @Mock File mMockFile;
+    @Mock File mMockBugReport;
     @Mock HostOrchestratorUtil mMockHOUtil;
+    @Mock OxygenClient mMockClient;
+    @Mock Process mMockProcess;
 
     public static interface TestableConfigurableVirtualDevice
             extends IDevice, IConfigurableVirtualDevice {}
@@ -109,6 +112,7 @@ public class AdbSshConnectionTest {
     @Before
     public void setUp() throws Exception {
         mMockFile = Mockito.mock(File.class);
+        mMockBugReport = Mockito.mock(File.class);
         MockitoAnnotations.initMocks(this);
         mOptions = new TestDeviceOptions();
         OptionSetter setter = new OptionSetter(mOptions);
@@ -224,7 +228,7 @@ public class AdbSshConnectionTest {
                     }
 
                     @Override
-                    HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
+                    public HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
                         return mMockHOUtil;
                     }
                 };
@@ -829,9 +833,9 @@ public class AdbSshConnectionTest {
         assertTrue(mConnection.getGceTunnelMonitor() instanceof GceSshTunnelMonitor);
     }
 
-    /** Test host orchestrator will be initialized when use-oxygenation-device is True. */
+    /** Test host orchestrator will not be initialized for neither Oxygenation nor Oxygen. */
     @Test
-    public void testCreateHOForOxygenation() throws Exception {
+    public void testNoHOCreated() throws Exception {
         mConnection =
                 new AdbSshConnection(
                         new ConnectionBuilder(
@@ -854,11 +858,10 @@ public class AdbSshConnectionTest {
         mOptions.setAvdDriverBinary(mMockFile);
         OptionSetter setter = new OptionSetter(mOptions);
         setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
-        setter.setOptionValue("use-oxygenation-device", "true");
+        setter.setOptionValue("use-oxygenation-device", "false");
         when(mMockDevice.getOptions()).thenReturn(mOptions);
         when(mMockFile.exists()).thenReturn(true);
         when(mMockFile.canExecute()).thenReturn(true);
-        when(mMockFile.getAbsolutePath()).thenReturn("somepath");
         GceAvdInfo gceAvd =
                 new GceAvdInfo(
                         "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
@@ -873,12 +876,15 @@ public class AdbSshConnectionTest {
         when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
         when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
         mConnection.initializeConnection();
-        assertNotNull(mConnection.getHostOrchestratorUtil());
+        assertNull(mConnection.createHostOrchestratorUtil(gceAvd));
     }
 
-    /** Test host orchestrator will be initialized when use_cvd is specified. */
+    /**
+     * Test closeTunnelConnection should not be executed when HostOrchestratorUtil isn't
+     * initialized.
+     */
     @Test
-    public void testCreateHOForOxygen() throws Exception {
+    public void testCloseTunnelConnectionNoHOCreated() throws Exception {
         mConnection =
                 new AdbSshConnection(
                         new ConnectionBuilder(
@@ -887,46 +893,17 @@ public class AdbSshConnectionTest {
                     GceManager getGceHandler() {
                         return mGceHandler;
                     }
-
-                    @Override
-                    void createGceTunnelMonitor(
-                            ITestDevice device,
-                            IBuildInfo buildInfo,
-                            GceAvdInfo gceAvdInfo,
-                            TestDeviceOptions deviceOptions) {
-                        // Ignore
-                    }
                 };
         mOptions = new TestDeviceOptions();
-        mOptions.setAvdDriverBinary(mMockFile);
         OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
-        setter.setOptionValue("use-oxygenation-device", "false");
-        setter.setOptionValue("extra-oxygen-args", "use_cvd", "");
+        setter.setOptionValue("use-oxygenation-device", "true");
         when(mMockDevice.getOptions()).thenReturn(mOptions);
-        when(mMockFile.exists()).thenReturn(true);
-        when(mMockFile.canExecute()).thenReturn(true);
-        when(mMockFile.getAbsolutePath()).thenReturn("somepath");
-        GceAvdInfo gceAvd =
-                new GceAvdInfo(
-                        "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
-        doReturn(gceAvd)
-                .when(mGceHandler)
-                .startGce(
-                        Mockito.isNull(),
-                        Mockito.isNull(),
-                        Mockito.eq(0),
-                        Mockito.any(),
-                        Mockito.eq(mMockLogger));
-        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
-        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
-        mConnection.initializeConnection();
-        assertNotNull(mConnection.getHostOrchestratorUtil());
+        mConnection.tearDownConnection();
     }
 
-    /** Test host orchestrator will not be initialized for neither Oxygenation nor Oxygen. */
+    /** Test device inspection when device fails to boot. */
     @Test
-    public void testNoHOCreated() throws Exception {
+    public void testDeviceInspectionOxygenation() throws Exception {
         mConnection =
                 new AdbSshConnection(
                         new ConnectionBuilder(
@@ -937,25 +914,44 @@ public class AdbSshConnectionTest {
                     }
 
                     @Override
-                    void createGceTunnelMonitor(
-                            ITestDevice device,
-                            IBuildInfo buildInfo,
-                            GceAvdInfo gceAvdInfo,
-                            TestDeviceOptions deviceOptions) {
-                        // Ignore
+                    public AbstractTunnelMonitor getGceTunnelMonitor() {
+                        return mGceSshMonitor;
+                    }
+
+                    @Override
+                    OxygenClient createOxygenClient() {
+                        return mMockClient;
                     }
                 };
-        mOptions = new TestDeviceOptions();
+        String instanceUser = "user1";
         mOptions.setAvdDriverBinary(mMockFile);
         OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
-        setter.setOptionValue("use-oxygenation-device", "false");
-        when(mMockDevice.getOptions()).thenReturn(mOptions);
+        setter.setOptionValue("use-oxygenation-device", "true");
+        setter.setOptionValue("instance-user", instanceUser);
         when(mMockFile.exists()).thenReturn(true);
         when(mMockFile.canExecute()).thenReturn(true);
+        when(mMockFile.getAbsolutePath()).thenReturn("test.jar");
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(OxygenClient.LHPTunnelMode.SSH),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any(),
+                        Mockito.any());
         GceAvdInfo gceAvd =
                 new GceAvdInfo(
-                        "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
+                        instanceUser,
+                        HostAndPort.fromHost("127.0.0.1"),
+                        null,
+                        "acloud error",
+                        GceStatus.BOOT_FAIL);
         doReturn(gceAvd)
                 .when(mGceHandler)
                 .startGce(
@@ -964,9 +960,132 @@ public class AdbSshConnectionTest {
                         Mockito.eq(0),
                         Mockito.any(),
                         Mockito.eq(mMockLogger));
-        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
-        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
-        mConnection.initializeConnection();
-        assertNull(mConnection.getHostOrchestratorUtil());
+        OutputStream stdout = null;
+        OutputStream stderr = null;
+        CommandResult cmdResult = new CommandResult(CommandStatus.SUCCESS);
+        when(mMockRunUtil.runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq(stdout),
+                        Mockito.eq(stderr),
+                        Mockito.eq("ssh"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("LogLevel=ERROR"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("UserKnownHostsFile=/dev/null"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("StrictHostKeyChecking=no"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("ServerAliveInterval=10"),
+                        Mockito.eq("-i"),
+                        Mockito.any(),
+                        Mockito.eq("user1@localhost"),
+                        Mockito.eq("-p"),
+                        Mockito.eq("1111"),
+                        Mockito.eq("exit")))
+                .thenReturn(cmdResult);
+        CommandResult diskSpaceRes = new CommandResult(CommandStatus.SUCCESS);
+        diskSpaceRes.setStdout(
+                "Filesystem 1024-blocks Used Available Capacity Mounted on\n "
+                        + "/dev/sda1 61679704 16567560 41956596 29% /\n");
+        when(mMockRunUtil.runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq(stdout),
+                        Mockito.eq(stderr),
+                        Mockito.eq("ssh"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("LogLevel=ERROR"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("UserKnownHostsFile=/dev/null"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("StrictHostKeyChecking=no"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("ServerAliveInterval=10"),
+                        Mockito.eq("-i"),
+                        Mockito.any(),
+                        Mockito.eq("user1@localhost"),
+                        Mockito.eq("-p"),
+                        Mockito.eq("1111"),
+                        Mockito.eq("df"),
+                        Mockito.eq("-P"),
+                        Mockito.eq("/")))
+                .thenReturn(diskSpaceRes);
+
+        CommandResult processes = new CommandResult(CommandStatus.SUCCESS);
+        processes.setStdout(
+                "PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND \n"
+                    + "1 root 20 0 168240 12880 9196 S 0.0 0.1 0:13.64 /sbin/init\n"
+                    + "40 _cvd-ex+ 20 0 168 60 48 S 0.0 0.0 0:00.00 /run_cvd --image_dir=/path/\n"
+                    + "40 _cvd-ex+ 20 0 199 26 20 S 0.0 0.2 4:09.24 /netsimd -s"
+                    + " {\"dev\":[{\"name\":145+\n"
+                    + "40 _cvd-ex+ 20 0 330 14 13 S 0.0 0.1 0:04.34 /openwrt_control_server"
+                    + " --grpc_uds_path=/path\n"
+                    + "40 _cvd-ex+ 20 0 330 14 13 S 0.0 0.1 0:04.34 /webRTC -group_id=cvd_1\n"
+                    + "40 _cvd-ex+ 20 0 330 14 13 S 0.0 0.1 0:04.34 /crosvm --extended-status run\n"
+                    + "10 root 20 0 105 1324 0 S 0.0 0.0 0:00.00 nginx: master process"
+                    + " /usr/sbin/nginx -g\n");
+
+        when(mMockRunUtil.runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq(stdout),
+                        Mockito.eq(stderr),
+                        Mockito.eq("ssh"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("LogLevel=ERROR"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("UserKnownHostsFile=/dev/null"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("StrictHostKeyChecking=no"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("ServerAliveInterval=10"),
+                        Mockito.eq("-i"),
+                        Mockito.any(),
+                        Mockito.eq("user1@localhost"),
+                        Mockito.eq("-p"),
+                        Mockito.eq("1111"),
+                        Mockito.eq("top"),
+                        Mockito.eq("-bcn1"),
+                        Mockito.eq("-w"),
+                        Mockito.eq("512")))
+                .thenReturn(processes);
+
+        CommandResult adbRes = new CommandResult(CommandStatus.SUCCESS);
+        adbRes.setStdout(
+                "List of devices attached\n"
+                        + "127.0.0.1:42115 device\n"
+                        + "127.0.0.1:42116 device\n"
+                        + "127.0.0.1:42117 device\n");
+        when(mMockRunUtil.runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq(stdout),
+                        Mockito.eq(stderr),
+                        Mockito.eq("ssh"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("LogLevel=ERROR"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("UserKnownHostsFile=/dev/null"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("StrictHostKeyChecking=no"),
+                        Mockito.eq("-o"),
+                        Mockito.eq("ServerAliveInterval=10"),
+                        Mockito.eq("-i"),
+                        Mockito.any(),
+                        Mockito.eq("user1@localhost"),
+                        Mockito.eq("-p"),
+                        Mockito.eq("1111"),
+                        Mockito.eq("adb"),
+                        Mockito.eq("start-server"),
+                        Mockito.eq("&&"),
+                        Mockito.eq("sleep"),
+                        Mockito.eq("5"),
+                        Mockito.eq("&&"),
+                        Mockito.eq("adb"),
+                        Mockito.eq("devices")))
+                .thenReturn(adbRes);
+        try {
+            mConnection.initializeConnection();
+            fail("Should have thrown an exception");
+        } catch (TargetSetupError expected) {
+            // expected
+        }
     }
 }
diff --git a/javatests/com/android/tradefed/device/metric/ClangCodeCoverageCollectorTest.java b/javatests/com/android/tradefed/device/metric/ClangCodeCoverageCollectorTest.java
index c53bc1a0e..16c80d377 100644
--- a/javatests/com/android/tradefed/device/metric/ClangCodeCoverageCollectorTest.java
+++ b/javatests/com/android/tradefed/device/metric/ClangCodeCoverageCollectorTest.java
@@ -33,7 +33,6 @@ import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.IBuildInfo;
-import com.android.tradefed.build.IBuildProvider;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceNotAvailableException;
@@ -109,7 +108,6 @@ public class ClangCodeCoverageCollectorTest {
     @Mock IBuildInfo mMockBuildInfo;
 
     @Mock IConfiguration mMockConfiguration;
-    @Mock IBuildProvider mMockBuildProvider;
     @Mock ITestDevice mMockDevice;
     @Mock IInvocationContext mMockContext;
     @Spy CommandArgumentCaptor mCommandArgumentCaptor;
@@ -134,13 +132,12 @@ public class ClangCodeCoverageCollectorTest {
         mCoverageOptionsSetter = new OptionSetter(mCoverageOptions);
 
         doReturn(mCoverageOptions).when(mMockConfiguration).getCoverageOptions();
-        doReturn(mMockBuildProvider).when(mMockConfiguration).getBuildProvider();
-        doReturn(mMockBuildInfo).when(mMockBuildProvider).getBuild();
 
         doReturn(ImmutableList.of(mMockDevice)).when(mMockContext).getDevices();
         when(mMockContext.getAttributes())
                 .thenReturn(
                         new MultiMap(ImmutableMap.of(ModuleDefinition.MODULE_NAME, "myModule")));
+        when(mMockContext.getBuildInfos()).thenReturn(ImmutableList.of(mMockBuildInfo));
 
         doReturn(PS_OUTPUT).when(mMockDevice).executeShellCommand("ps -e");
 
diff --git a/javatests/com/android/tradefed/device/metric/CodeCoverageCollectorTest.java b/javatests/com/android/tradefed/device/metric/CodeCoverageCollectorTest.java
new file mode 100644
index 000000000..6992c57ad
--- /dev/null
+++ b/javatests/com/android/tradefed/device/metric/CodeCoverageCollectorTest.java
@@ -0,0 +1,961 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.metric;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.contains;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.testtype.coverage.CoverageOptions;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.JavaCodeCoverageFlusher;
+import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.TarUtil;
+import com.android.tradefed.util.proto.TfMetricProtoUtil;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.protobuf.ByteString;
+
+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
+import org.jacoco.core.data.ExecutionData;
+import org.jacoco.core.data.ExecutionDataStore;
+import org.jacoco.core.data.ExecutionDataWriter;
+import org.jacoco.core.internal.data.CRC64;
+import org.jacoco.core.tools.ExecFileLoader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.Spy;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/** Unit tests for {@link CodeCoverageCollector}. */
+@RunWith(JUnit4.class)
+public class CodeCoverageCollectorTest {
+
+    private static final int PROBE_COUNT = 10;
+
+    private static final String RUN_NAME = "SomeTest";
+    private static final int TEST_COUNT = 5;
+    private static final long ELAPSED_TIME = 1000;
+
+    private static final String DEVICE_PATH = "/some/path/on/the/device.ec";
+    private static final ByteString COVERAGE_MEASUREMENT =
+            ByteString.copyFromUtf8("Mi estas kovrado mezurado");
+
+    private static final String PS_OUTPUT =
+            "USER       PID   PPID  VSZ   RSS   WCHAN       PC  S NAME\n"
+                    + "shell       123  1366  123    456   SyS_epoll+   0  S adbd\n";
+
+    @Rule public TemporaryFolder folder = new TemporaryFolder();
+
+    @Mock IConfiguration mMockConfiguration;
+    @Mock IInvocationContext mMockContext;
+    @Mock ITestDevice mMockDevice;
+    @Mock JavaCodeCoverageFlusher mMockFlusher;
+
+    @Mock IBuildInfo mMockBuildInfo;
+
+    @Spy LogFileReader mFakeListener = new LogFileReader();
+
+    @Spy CommandArgumentCaptor mCommandArgumentCaptor;
+
+    /** Object under test. */
+    CodeCoverageCollector mCodeCoverageCollector;
+
+    CoverageOptions mCoverageOptions = null;
+    OptionSetter mCoverageOptionsSetter = null;
+    List<File> mFilesToClean;
+
+    abstract static class CommandArgumentCaptor implements IRunUtil {
+        private List<String> mCommand = new ArrayList<>();
+        private CommandResult mResult = new CommandResult(CommandStatus.SUCCESS);
+
+        /** Stores the command for retrieval later. */
+        @Override
+        public CommandResult runTimedCmd(long timeout, String... cmd) {
+            mCommand = Arrays.asList(cmd);
+            return mResult;
+        }
+
+        void setResult(CommandStatus status) {
+            mResult = new CommandResult(status);
+        }
+
+        List<String> getCommand() {
+            return mCommand;
+        }
+
+        /** Ignores sleep calls. */
+        @Override
+        public void sleep(long ms) {}
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mCoverageOptions = new CoverageOptions();
+        mCoverageOptionsSetter = new OptionSetter(mCoverageOptions);
+
+        when(mMockConfiguration.getCoverageOptions()).thenReturn(mCoverageOptions);
+        when(mMockContext.getDevices()).thenReturn(ImmutableList.of(mMockDevice));
+        when(mMockContext.getAttributes())
+                .thenReturn(
+                        new MultiMap(ImmutableMap.of(ModuleDefinition.MODULE_NAME, "myModule")));
+
+        // Mock an unrooted device that has no issues enabling or disabling root.
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        when(mMockDevice.enableAdbRoot()).thenReturn(true);
+        when(mMockDevice.disableAdbRoot()).thenReturn(true);
+
+        mCodeCoverageCollector = new CodeCoverageCollector();
+        mCodeCoverageCollector.setConfiguration(mMockConfiguration);
+
+        mFilesToClean = new ArrayList<>();
+
+        // Native specific setup
+        mCodeCoverageCollector.setClangFlusherRunUtil(mCommandArgumentCaptor);
+        when(mMockContext.getBuildInfos()).thenReturn(ImmutableList.of(mMockBuildInfo));
+
+        doReturn(PS_OUTPUT).when(mMockDevice).executeShellCommand("ps -e");
+        CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+        result.setStdout("ffffffffff\n");
+        result.setExitCode(0);
+        when(mMockDevice.executeShellV2Command(anyString())).thenReturn(result);
+    }
+
+    @After
+    public void cleanUp() throws IOException {
+        for (File file : mFilesToClean) {
+            file.delete();
+        }
+    }
+
+    @Test
+    public void testRunEnded_noCoverageEnabled_noop() throws Exception {
+        // Setup mocks.
+        HashMap<String, Metric> runMetrics = new HashMap<>();
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        // Verify testLog(..) was not called.
+        verify(mFakeListener, never())
+                .testLog(anyString(), eq(LogDataType.COVERAGE), eq(COVERAGE_MEASUREMENT));
+    }
+
+    @Test
+    public void testJavaCollector_pullCrossProcessCoverageFilesWithUserDefinedTimeout()
+            throws Exception {
+        enableJavaCoverage();
+        mCoverageOptionsSetter.setOptionValue("pull-timeout", "314159");
+
+        // Setup mocks.
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        // Verify timeout is set.
+        verify(mMockDevice, times(1))
+                .executeShellV2Command(
+                        eq("find /data/misc/trace -name '*.ec' | tar -czf - -T - 2>/dev/null"),
+                        any(),
+                        any(),
+                        eq(314159L),
+                        eq(TimeUnit.MILLISECONDS),
+                        eq(1));
+
+        // Verify coverage file was logged if file pulling didn't timeout.
+        verify(mFakeListener)
+                .testLog(anyString(), eq(LogDataType.COVERAGE), eq(COVERAGE_MEASUREMENT));
+    }
+
+    @Test
+    public void testJavaCollector_crossProcessCoveragePullingTimeout_noLog() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createEmptyMetrics();
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+        when(mMockDevice.executeShellV2Command(
+                        anyString(),
+                        any(),
+                        any(OutputStream.class),
+                        anyLong(),
+                        any(TimeUnit.class),
+                        anyInt()))
+                .thenThrow(
+                        new DeviceNotAvailableException(
+                                "msg", "device serial", DeviceErrorIdentifier.DEVICE_UNRESPONSIVE));
+
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        verify(mFakeListener, never())
+                .testLog(anyString(), eq(LogDataType.COVERAGE), eq(COVERAGE_MEASUREMENT));
+    }
+
+    @Test
+    public void testJavaCollector_logCoverageWithModuleName() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        verify(mFakeListener)
+                .testLog(
+                        eq("myModule_MODULE_SomeTest_device_runtime_coverage"),
+                        eq(LogDataType.COVERAGE),
+                        eq(COVERAGE_MEASUREMENT));
+    }
+
+    @Test
+    public void testJavaCollector_logCoverageWithoutModuleName() throws Exception {
+        enableJavaCoverage();
+
+        // Setup mocks.
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockContext.getAttributes()).thenReturn(new MultiMap(ImmutableMap.of()));
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        // Verify testLog(..) was called with the coverage file.
+        verify(mFakeListener)
+                .testLog(
+                        eq("SomeTest_device_runtime_coverage"),
+                        eq(LogDataType.COVERAGE),
+                        eq(COVERAGE_MEASUREMENT));
+    }
+
+    @Test
+    public void testFailure_unableToPullFile() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        doReturn(null).when(mMockDevice).pullFile(DEVICE_PATH);
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        verify(mFakeListener, never())
+                .testLog(anyString(), eq(LogDataType.COVERAGE), any(InputStreamSource.class));
+    }
+
+    @Test
+    public void testRunEnded_rootDisabled_enablesRootBeforePullingFiles() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        InOrder inOrder = inOrder(mMockDevice);
+        inOrder.verify(mMockDevice).enableAdbRoot();
+        inOrder.verify(mMockDevice).pullFile(anyString());
+    }
+
+    @Test
+    public void testRunEnded_rootDisabled_noLogIfCannotEnableRoot() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        when(mMockDevice.enableAdbRoot()).thenReturn(false);
+
+        // Simulate a test run.
+        try {
+            mCodeCoverageCollector.init(mMockContext, mFakeListener);
+            fail("An exception should have been thrown.");
+        } catch (RuntimeException e) {
+            // Expected.
+        }
+
+        verify(mFakeListener, never())
+                .testLog(anyString(), eq(LogDataType.COVERAGE), any(InputStreamSource.class));
+    }
+
+    @Test
+    public void testRunEnded_rootDisabled_disablesRootAfterPullingFiles() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        InOrder inOrder = inOrder(mMockDevice);
+        inOrder.verify(mMockDevice).pullFile(anyString());
+        inOrder.verify(mMockDevice).disableAdbRoot();
+    }
+
+    @Test
+    public void testCoverageFlush_producesMultipleMeasurements() throws Exception {
+        enableJavaCoverage();
+
+        Map<String, ByteString> coverageData =
+                ImmutableMap.of(
+                        "/data/misc/trace/com.android.test1.ec",
+                        ByteString.copyFromUtf8("com.android.test1.ec"),
+                        "/data/misc/trace/com.android.test2.ec",
+                        ByteString.copyFromUtf8("com.android.test2.ec"),
+                        "/data/misc/trace/com.google.test3.ec",
+                        ByteString.copyFromUtf8("com.google.test3.ec"));
+
+        mCoverageOptionsSetter.setOptionValue("coverage-flush", "true");
+
+        // Setup mocks.
+        mockCoverageFileOnDevice(DEVICE_PATH);
+
+        doReturn("").when(mMockDevice).executeShellCommand("ps -e");
+        doReturn("")
+                .when(mMockDevice)
+                .executeShellCommand(CodeCoverageCollector.FIND_COVERAGE_FILES);
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(coverageData));
+
+        mCodeCoverageCollector.setJavaCoverageFlusher(mMockFlusher);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        Map<String, String> metric = new HashMap<>();
+        metric.put("coverageFilePath", DEVICE_PATH);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, TfMetricProtoUtil.upgradeConvert(metric));
+
+        // Verify the coverage data was logged.
+        for (ByteString contents : coverageData.values()) {
+            verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), eq(contents));
+        }
+    }
+
+    @Test
+    public void testRunningProcess_coverageFileNotDeleted() throws Exception {
+        enableJavaCoverage();
+
+        List<String> coverageFileList =
+                ImmutableList.of(
+                        "/data/misc/trace/coverage1.ec",
+                        "/data/misc/trace/coverage2.ec",
+                        "/data/misc/trace/jacoco-123.mm.ec",
+                        "/data/misc/trace/jacoco-456.mm.ec");
+        String psOutput =
+                "USER       PID   PPID  VSZ   RSS   WCHAN       PC  S NAME\n"
+                    + "bluetooth   123  1366  123    456   SyS_epoll+   0  S"
+                    + " com.android.bluetooth\n"
+                    + "radio       890     1 7890   123   binder_io+   0  S com.android.phone\n"
+                    + "root         11  1234  567   890   binder_io+   0  S not.a.java.package\n";
+
+        // Setup mocks.
+        mockCoverageFileOnDevice(DEVICE_PATH);
+
+        for (String additionalFile : coverageFileList) {
+            mockCoverageFileOnDevice(additionalFile);
+        }
+
+        doReturn("").when(mMockDevice).executeShellCommand("pm list packages -a");
+        doReturn(psOutput).when(mMockDevice).executeShellCommand("ps -e");
+        doReturn(String.join("\n", coverageFileList))
+                .when(mMockDevice)
+                .executeShellCommand("find /data/misc/trace -name '*.ec'");
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        Map<String, String> metric = new HashMap<>();
+        metric.put("coverageFilePath", DEVICE_PATH);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, TfMetricProtoUtil.upgradeConvert(metric));
+
+        // Verify the correct files were deleted and some files were not deleted.
+        verify(mMockDevice).deleteFile(coverageFileList.get(0));
+        verify(mMockDevice).deleteFile(coverageFileList.get(1));
+        verify(mMockDevice, never()).deleteFile(coverageFileList.get(2));
+        verify(mMockDevice).deleteFile(coverageFileList.get(3));
+    }
+
+    @Test
+    public void testStreamingCoverage_logsReceived() throws Exception {
+        enableJavaCoverage();
+
+        String path1 = "path/to/coverage1.ec";
+        ByteString contents1 = ByteString.copyFromUtf8("File contents 1");
+        String path2 = "path/to/coverage2.ec";
+        ByteString contents2 = ByteString.copyFromUtf8("File contents 2");
+        File tarGz =
+                createTarGz(
+                        ImmutableMap.of(
+                                path1, contents1,
+                                path2, contents2));
+
+        // Return the tar.gz file when running the stream-compress command.
+        returnFileContentsOnShellCommand(mMockDevice, tarGz);
+
+        // Return no data for the `ps -e` command.
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, new HashMap<String, Metric>());
+
+        // Verify that the coverage data was logged.
+        verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), eq(contents1));
+        verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), eq(contents2));
+    }
+
+    @Test
+    public void testInitNoResetCoverage_noop() throws Exception {
+        enableJavaCoverage();
+        mCoverageOptionsSetter.setOptionValue("reset-coverage-before-test", "false");
+
+        // Run init(...).
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+
+        // Verify that nothing was run on the device.
+        verifyNoMoreInteractions(mMockDevice);
+    }
+
+    @Test
+    public void testMergeSingleMeasurement_logReceived() throws Exception {
+        enableJavaCoverage();
+        mCoverageOptionsSetter.setOptionValue("merge-coverage", "true");
+
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+
+        ByteString measurement = measurement(firstHalfCovered(CodeCoverageCollector.class));
+        File tarGz = createTarGz(ImmutableMap.of("path/to/coverage.ec", measurement));
+        returnFileContentsOnShellCommand(mMockDevice, tarGz);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, new HashMap<String, Metric>());
+
+        // Validate the logged coverage data.
+        ArgumentCaptor<ByteString> stream = ArgumentCaptor.forClass(ByteString.class);
+        verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), stream.capture());
+
+        ExecFileLoader execFileLoader = new ExecFileLoader();
+        execFileLoader.load(stream.getValue().newInput());
+
+        ExecutionDataStore execData = execFileLoader.getExecutionDataStore();
+        boolean[] firstHalf = new boolean[PROBE_COUNT];
+        for (int i = 0; i < PROBE_COUNT / 2; i++) {
+            firstHalf[i] = true;
+        }
+
+        assertThat(execData.contains(vmName(CodeCoverageCollector.class))).isTrue();
+        assertThat(getProbes(CodeCoverageCollector.class, execData)).isEqualTo(firstHalf);
+    }
+
+    @Test
+    public void testMergeMultipleMeasurements_logContainsAllData() throws Exception {
+        enableJavaCoverage();
+        mCoverageOptionsSetter.setOptionValue("merge-coverage", "true");
+
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+
+        ByteString firstHalfCollector = measurement(firstHalfCovered(CodeCoverageCollector.class));
+        ByteString secondHalfCollector =
+                measurement(secondHalfCovered(CodeCoverageCollector.class));
+        ByteString partialCollectorTest =
+                measurement(partiallyCovered(CodeCoverageCollectorTest.class));
+        File tarGz =
+                createTarGz(
+                        ImmutableMap.of(
+                                "CodeCoverageCollector1.ec", firstHalfCollector,
+                                "CodeCoverageCollector2.ec", secondHalfCollector,
+                                "CodeCoverageCollectorTest.ec", partialCollectorTest));
+        returnFileContentsOnShellCommand(mMockDevice, tarGz);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, new HashMap<String, Metric>());
+
+        // Validate the logged coverage data.
+        ArgumentCaptor<ByteString> stream = ArgumentCaptor.forClass(ByteString.class);
+        verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), stream.capture());
+
+        ExecFileLoader execFileLoader = new ExecFileLoader();
+        execFileLoader.load(stream.getValue().newInput());
+
+        ExecutionDataStore execData = execFileLoader.getExecutionDataStore();
+
+        // Check coverage data for CodeCoverageCollector. All probes should be true if the data
+        // merged successfully.
+        boolean[] fullyCovered = new boolean[PROBE_COUNT];
+        Arrays.fill(fullyCovered, Boolean.TRUE);
+
+        assertThat(execData.contains(vmName(CodeCoverageCollector.class))).isTrue();
+        assertThat(getProbes(CodeCoverageCollector.class, execData)).isEqualTo(fullyCovered);
+
+        // Check coverage data for CodeCoverageCollectorTest. Only the first probe should be
+        // true.
+        boolean[] partiallyCovered = new boolean[PROBE_COUNT];
+        partiallyCovered[0] = true;
+
+        assertThat(execData.contains(vmName(CodeCoverageCollectorTest.class))).isTrue();
+        assertThat(getProbes(CodeCoverageCollectorTest.class, execData))
+                .isEqualTo(partiallyCovered);
+    }
+
+    @Test
+    public void codeCoverageCollector_rootAndUnrootDeviceTwice() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        verify(mMockDevice, times(2)).enableAdbRoot();
+        verify(mMockDevice, times(2)).disableAdbRoot();
+    }
+
+    @Test
+    public void testClangCollector_whenClangCoverageDisabled_noCoverageLog() throws Exception {
+        mCoverageOptionsSetter.setOptionValue("coverage", "true");
+        Map<String, String> metric = new HashMap<>();
+
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, TfMetricProtoUtil.upgradeConvert(metric));
+        mCodeCoverageCollector.invocationEnded(ELAPSED_TIME);
+
+        assertThat(mFakeListener.getLogs()).isEmpty();
+    }
+
+    @Test
+    public void testClangCollector_whenCoverageFlushEnabled_flushCalled() throws Exception {
+        mCoverageOptionsSetter.setOptionValue("coverage", "true");
+        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "CLANG");
+        mCoverageOptionsSetter.setOptionValue("coverage-flush", "true");
+        Map<String, String> metric = new HashMap<>();
+
+        // Setup mocks.
+        doReturn(true).when(mMockDevice).isAdbRoot();
+        File emptyTarGz = createTarGz(ImmutableMap.of());
+        returnFileContentsOnShellCommand(mMockDevice, "/data/misc/trace", emptyTarGz);
+        returnFileContentsOnShellCommand(mMockDevice, "/data/local/tmp", emptyTarGz);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, TfMetricProtoUtil.upgradeConvert(metric));
+        mCodeCoverageCollector.invocationEnded(ELAPSED_TIME);
+
+        // Verify flush-coverage command was called at the end of the test run.
+        verify(mMockDevice).executeShellCommand("kill -37 123");
+    }
+
+    @Test
+    public void testClangCollector_logsCoverageFileFromMiscTrace() throws Exception {
+        mCoverageOptionsSetter.setOptionValue("coverage", "true");
+        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "CLANG");
+        mCoverageOptionsSetter.setOptionValue("pull-timeout", "314159");
+
+        // Setup mocks.
+        doReturn(true).when(mMockDevice).isAdbRoot();
+        File tarGz =
+                createTarGz(
+                        ImmutableMap.of(
+                                "path/to/coverage.profraw",
+                                ByteString.copyFromUtf8("coverage.profraw"),
+                                "path/to/.hidden/coverage2.profraw",
+                                ByteString.copyFromUtf8("coverage2.profraw")));
+        returnFileContentsOnShellCommand(mMockDevice, "/data/misc/trace", tarGz);
+        File emptyTarGz = createTarGz(ImmutableMap.of());
+        returnFileContentsOnShellCommand(mMockDevice, "/data/local/tmp", emptyTarGz);
+        doReturn(createProfileToolZip()).when(mMockBuildInfo).getFile(anyString());
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, createEmptyMetrics());
+        mCodeCoverageCollector.invocationEnded(ELAPSED_TIME);
+
+        // Verify the timeout is set.
+        verify(mMockDevice, times(1))
+                .executeShellV2Command(
+                        eq("find /data/misc/trace -name '*.profraw' | tar -czf - -T - 2>/dev/null"),
+                        any(),
+                        any(),
+                        eq(314159L),
+                        eq(TimeUnit.MILLISECONDS),
+                        eq(1));
+        verify(mMockDevice, times(1))
+                .executeShellV2Command(
+                        eq("find /data/local/tmp -name '*.profraw' | tar -czf - -T - 2>/dev/null"),
+                        any(),
+                        any(),
+                        anyLong(),
+                        eq(TimeUnit.MILLISECONDS),
+                        eq(1));
+        // Verify that the command line contains the files above.
+        List<String> command = mCommandArgumentCaptor.getCommand();
+        checkListContainsSuffixes(
+                command,
+                ImmutableList.of(
+                        "llvm-profdata",
+                        "path/to/coverage.profraw",
+                        "path/to/.hidden/coverage2.profraw"));
+
+        // Verify testLog(..) was called with a single indexed profile data.
+        List<ByteString> logs = mFakeListener.getLogs();
+        assertThat(logs).hasSize(1);
+    }
+
+    @Test
+    public void testClangCollector_logsCoverageFileFromLocalTmp() throws Exception {
+        mCoverageOptionsSetter.setOptionValue("coverage", "true");
+        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "CLANG");
+
+        // Set up mocks.
+        doReturn(true).when(mMockDevice).isAdbRoot();
+        File tarGz =
+                createTarGz(
+                        ImmutableMap.of(
+                                "path/to/coverage.profraw",
+                                ByteString.copyFromUtf8("coverage.profraw"),
+                                "path/to/.hidden/coverage2.profraw",
+                                ByteString.copyFromUtf8("coverage2.profraw")));
+        File emptyTarGz = createTarGz(ImmutableMap.of());
+        returnFileContentsOnShellCommand(mMockDevice, "/data/misc/trace", emptyTarGz);
+        returnFileContentsOnShellCommand(mMockDevice, "/data/local/tmp", tarGz);
+        doReturn(createProfileToolZip()).when(mMockBuildInfo).getFile(anyString());
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, createEmptyMetrics());
+        mCodeCoverageCollector.invocationEnded(ELAPSED_TIME);
+
+        // Verify coverage was pulled.
+        verify(mMockDevice, times(2))
+                .executeShellV2Command(
+                        contains("tar -czf"),
+                        any(),
+                        any(),
+                        anyLong(),
+                        eq(TimeUnit.MILLISECONDS),
+                        eq(1));
+
+        // Verify that the command line contains the files above.
+        List<String> command = mCommandArgumentCaptor.getCommand();
+        checkListContainsSuffixes(
+                command,
+                ImmutableList.of(
+                        "llvm-profdata",
+                        "path/to/coverage.profraw",
+                        "path/to/.hidden/coverage2.profraw"));
+
+        // Verify testLog(...) was called with a single indexed profile data file.
+        List<ByteString> logs = mFakeListener.getLogs();
+        assertThat(logs).hasSize(1);
+    }
+
+    private void mockCoverageFileOnDevice(String devicePath)
+            throws IOException, DeviceNotAvailableException {
+        File coverageFile = folder.newFile(new File(devicePath).getName());
+
+        try (OutputStream out = new FileOutputStream(coverageFile)) {
+            COVERAGE_MEASUREMENT.writeTo(out);
+        }
+
+        doReturn(coverageFile).when(mMockDevice).pullFile(devicePath);
+    }
+
+    private static <T> String vmName(Class<T> clazz) {
+        return clazz.getName().replace('.', '/');
+    }
+
+    private static <T> ExecutionData fullyCovered(Class<T> clazz) throws IOException {
+        boolean[] probes = new boolean[PROBE_COUNT];
+        Arrays.fill(probes, Boolean.TRUE);
+        return new ExecutionData(classId(clazz), vmName(clazz), probes);
+    }
+
+    private static <T> ExecutionData partiallyCovered(Class<T> clazz) throws IOException {
+        boolean[] probes = new boolean[PROBE_COUNT];
+        probes[0] = true;
+        return new ExecutionData(classId(clazz), vmName(clazz), probes);
+    }
+
+    private static <T> ExecutionData firstHalfCovered(Class<T> clazz) throws IOException {
+        boolean[] probes = new boolean[PROBE_COUNT];
+        for (int i = 0; i < PROBE_COUNT / 2; i++) {
+            probes[i] = true;
+        }
+        return new ExecutionData(classId(clazz), vmName(clazz), probes);
+    }
+
+    private static <T> ExecutionData secondHalfCovered(Class<T> clazz) throws IOException {
+        boolean[] probes = new boolean[PROBE_COUNT];
+        for (int i = PROBE_COUNT / 2; i < PROBE_COUNT; i++) {
+            probes[i] = true;
+        }
+        return new ExecutionData(classId(clazz), vmName(clazz), probes);
+    }
+
+    private static <T> long classId(Class<T> clazz) throws IOException {
+        return Long.valueOf(CRC64.classId(classBytes(clazz).toByteArray()));
+    }
+
+    private static <T> ByteString classBytes(Class<T> clazz) throws IOException {
+        return ByteString.readFrom(
+                clazz.getClassLoader().getResourceAsStream(vmName(clazz) + ".class"));
+    }
+
+    private static ByteString measurement(ExecutionData... data) throws IOException {
+        ExecutionDataStore dataStore = new ExecutionDataStore();
+        Arrays.stream(data).forEach(dataStore::put);
+
+        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream()) {
+            dataStore.accept(new ExecutionDataWriter(bytes));
+            return ByteString.copyFrom(bytes.toByteArray());
+        }
+    }
+
+    private static <T> boolean[] getProbes(Class<T> clazz, ExecutionDataStore execData)
+            throws IOException {
+        return execData.get(classId(clazz), vmName(clazz), PROBE_COUNT).getProbesCopy();
+    }
+
+    private static HashMap<String, Metric> createEmptyMetrics() {
+        Map<String, String> metric = new HashMap<>();
+        return TfMetricProtoUtil.upgradeConvert(metric);
+    }
+
+    private static HashMap<String, Metric> createMetricsWithCoverageMeasurement(String devicePath) {
+        return TfMetricProtoUtil.upgradeConvert(ImmutableMap.of("coverageFilePath", devicePath));
+    }
+
+    private static void returnFileContentsOnShellCommand(ITestDevice device, File file)
+            throws DeviceNotAvailableException, IOException {
+        doAnswer(
+                        invocation -> {
+                            OutputStream out = (OutputStream) invocation.getArgument(2);
+                            try (InputStream in = new FileInputStream(file)) {
+                                in.transferTo(out);
+                            }
+                            return new CommandResult(CommandStatus.SUCCESS);
+                        })
+                .when(device)
+                .executeShellV2Command(
+                        eq(CodeCoverageCollector.COMPRESS_COVERAGE_FILES),
+                        any(),
+                        any(OutputStream.class),
+                        anyLong(),
+                        any(TimeUnit.class),
+                        anyInt());
+    }
+
+    private void returnFileContentsOnShellCommand(ITestDevice device, String path, File file)
+            throws DeviceNotAvailableException, IOException {
+        doAnswer(
+                        invocation -> {
+                            OutputStream out = (OutputStream) invocation.getArgument(2);
+                            try (InputStream in = new FileInputStream(file)) {
+                                in.transferTo(out);
+                            }
+                            return new CommandResult(CommandStatus.SUCCESS);
+                        })
+                .when(device)
+                .executeShellV2Command(
+                        contains(path),
+                        (File) any(),
+                        any(OutputStream.class),
+                        anyLong(),
+                        any(),
+                        anyInt());
+    }
+
+    private File createTarGz(Map<String, ByteString> fileContents) throws IOException {
+        File tarFile = folder.newFile();
+        try (TarArchiveOutputStream out =
+                new TarArchiveOutputStream(new FileOutputStream(tarFile))) {
+            for (Map.Entry<String, ByteString> file : fileContents.entrySet()) {
+                TarArchiveEntry entry = new TarArchiveEntry(file.getKey());
+                entry.setSize(file.getValue().size());
+
+                out.putArchiveEntry(entry);
+                file.getValue().writeTo(out);
+                out.closeArchiveEntry();
+            }
+            File tarGz = TarUtil.gzip(tarFile);
+            mFilesToClean.add(tarGz);
+            return tarGz;
+        } finally {
+            tarFile.delete();
+        }
+    }
+
+    private void enableJavaCoverage() throws ConfigurationException {
+        mCoverageOptionsSetter.setOptionValue("coverage", "true");
+        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "JACOCO");
+    }
+
+    /** An {@link ITestInvocationListener} which reads test log data streams for verification. */
+    private static class LogFileReader implements ITestInvocationListener {
+        private List<ByteString> mLogs = new ArrayList<>();
+
+        /**
+         * Reads the contents of the {@code dataStream} and forwards it to the {@link
+         * #testLog(String, LogDataType, ByteString)} method.
+         */
+        @Override
+        public void testLog(String dataName, LogDataType dataType, InputStreamSource dataStream) {
+            try (InputStream input = dataStream.createInputStream()) {
+                testLog(dataName, dataType, ByteString.readFrom(input));
+                mLogs.add(ByteString.readFrom(input));
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        /** No-op method for {@link Spy} verification. */
+        public void testLog(String dataName, LogDataType dataType, ByteString data) {}
+
+        List<ByteString> getLogs() {
+            return new ArrayList<>(mLogs);
+        }
+    }
+
+    private File createProfileToolZip() throws IOException {
+        File profileToolZip = folder.newFile("llvm-profdata.zip");
+        try (FileOutputStream stream = new FileOutputStream(profileToolZip);
+                ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(stream))) {
+            // Add bin/llvm-profdata.
+            ZipEntry entry = new ZipEntry("bin/llvm-profdata");
+            out.putNextEntry(entry);
+            out.closeEntry();
+        }
+        return profileToolZip;
+    }
+
+    /** Verifies that certain suffixes are contained in the List. */
+    void checkListContainsSuffixes(List<String> list, List<String> suffixes) {
+        for (String suffix : suffixes) {
+            boolean found = false;
+            for (String item : list) {
+                if (item.endsWith(suffix)) {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found) {
+                fail("List " + list.toString() + " does not contain suffix '" + suffix + "'");
+            }
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java b/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
index 77546bcec..935c841af 100644
--- a/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
+++ b/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
@@ -58,11 +58,11 @@ import com.google.protobuf.ByteString;
 
 import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
 import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
-import org.jacoco.core.tools.ExecFileLoader;
 import org.jacoco.core.data.ExecutionData;
 import org.jacoco.core.data.ExecutionDataStore;
 import org.jacoco.core.data.ExecutionDataWriter;
 import org.jacoco.core.internal.data.CRC64;
+import org.jacoco.core.tools.ExecFileLoader;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -83,8 +83,8 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -507,6 +507,24 @@ public class JavaCodeCoverageCollectorTest {
                 .isEqualTo(partiallyCovered);
     }
 
+    @Test
+    public void javaCodeCoverageCollector_rootAndUnrootDeviceTwice() throws Exception {
+        enableJavaCoverage();
+        HashMap<String, Metric> runMetrics = createMetricsWithCoverageMeasurement(DEVICE_PATH);
+        mockCoverageFileOnDevice(DEVICE_PATH);
+        when(mMockDevice.isAdbRoot()).thenReturn(false);
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+        returnFileContentsOnShellCommand(mMockDevice, createTarGz(ImmutableMap.of()));
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, runMetrics);
+
+        verify(mMockDevice, times(2)).enableAdbRoot();
+        verify(mMockDevice, times(2)).disableAdbRoot();
+    }
+
     private void mockCoverageFileOnDevice(String devicePath)
             throws IOException, DeviceNotAvailableException {
         File coverageFile = folder.newFile(new File(devicePath).getName());
diff --git a/javatests/com/android/tradefed/device/metric/PerfettoPullerMetricCollectorTest.java b/javatests/com/android/tradefed/device/metric/PerfettoPullerMetricCollectorTest.java
index 16eb314c5..42e23d9b0 100644
--- a/javatests/com/android/tradefed/device/metric/PerfettoPullerMetricCollectorTest.java
+++ b/javatests/com/android/tradefed/device/metric/PerfettoPullerMetricCollectorTest.java
@@ -323,12 +323,14 @@ public class PerfettoPullerMetricCollectorTest {
         Assert.assertTrue(args.contains(path));
         Assert.assertTrue(args.contains("--run-metrics"));
         Assert.assertTrue(args.contains("--metrics-output=text"));
-
+        Assert.assertFalse(args.contains("--summary"));
+        Assert.assertFalse(args.contains("--summary-metrics-v2"));
+        Assert.assertFalse(args.contains("--summary-spec"));
     }
 
     /**
-     * Test that trace processor run metrics are used when running the trace
-     * processor shell command.
+     * Test that trace processor run metrics are used when running the trace processor shell
+     * command.
      *
      * @throws Exception
      */
@@ -352,8 +354,9 @@ public class PerfettoPullerMetricCollectorTest {
         cr.setStatus(CommandStatus.SUCCESS);
         cr.setStdout("abc:efg");
 
-        Mockito.doReturn(cr).when(mPerfettoMetricCollector).runHostCommand(Mockito.anyLong(),
-                Mockito.any(), Mockito.any(), Mockito.any());
+        Mockito.doReturn(cr)
+                .when(mPerfettoMetricCollector)
+                .runHostCommand(Mockito.anyLong(), Mockito.any(), Mockito.any(), Mockito.any());
 
         mPerfettoMetricCollector.testRunStarted("runName", 1);
         mPerfettoMetricCollector.testStarted(testDesc);
@@ -362,8 +365,8 @@ public class PerfettoPullerMetricCollectorTest {
         tmpFile.delete();
 
         ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
-        Mockito.verify(mPerfettoMetricCollector).runHostCommand(Mockito.anyLong(),
-                captor.capture(), Mockito.any(), Mockito.any());
+        Mockito.verify(mPerfettoMetricCollector)
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
         Mockito.verify(mPerfettoMetricCollector).getCompressedFile(Mockito.any());
         List<String> args = Arrays.asList(captor.getValue());
         // Verifies all the overridden values are taken into account and trace processor
@@ -373,6 +376,136 @@ public class PerfettoPullerMetricCollectorTest {
         Assert.assertTrue(args.contains("--metrics-output=text"));
     }
 
+    /**
+     * Test that trace processor run metrics V2 only are used when running the trace processor shell
+     * command.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorMetricV2Args() throws Exception {
+        OptionSetter setter = new OptionSetter(mPerfettoMetricCollector);
+        setter.setOptionValue("pull-pattern-keys", "perfettofile");
+        setter.setOptionValue("perfetto-v1-metrics", "false");
+        setter.setOptionValue("perfetto-v2-metrics", "true");
+        HashMap<String, Metric> currentMetrics = new HashMap<>();
+
+        currentMetrics.put("perfettofile", TfMetricProtoUtil.stringToMetric("/data/trace.pb"));
+        Mockito.when(mMockDevice.pullFile(Mockito.eq("/data/trace.pb"), Mockito.eq(0)))
+                .thenReturn(new File("trace"));
+
+        TestDescription testDesc = new TestDescription("xyz", "abc");
+        CommandResult cr = new CommandResult();
+        cr.setStatus(CommandStatus.SUCCESS);
+        cr.setStdout("sometext");
+
+        File tmpFile = File.createTempFile("trace_processor_shell", "");
+        File tmpSummarySpecFile =
+                File.createTempFile("memory_per_process-avg_rss_and_swap.textproto", "");
+
+        // Verifies the trace processor shell lookup in test artifacts file path map.
+        Mockito.doReturn(tmpFile)
+                .when(mPerfettoMetricCollector)
+                .getFileFromTestArtifacts("trace_processor_shell");
+        Mockito.doReturn(tmpSummarySpecFile)
+                .when(mPerfettoMetricCollector)
+                .getFileFromTestArtifacts("memory_per_process-avg_rss_and_swap.textproto");
+        Mockito.doReturn(cr)
+                .when(mPerfettoMetricCollector)
+                .runHostCommand(Mockito.anyLong(), Mockito.any(), Mockito.any(), Mockito.any());
+
+        mPerfettoMetricCollector.testRunStarted("runName", 1);
+        mPerfettoMetricCollector.testStarted(testDesc);
+        mPerfettoMetricCollector.testEnded(testDesc, currentMetrics);
+        mPerfettoMetricCollector.testRunEnded(100L, new HashMap<String, Metric>());
+
+        String path = tmpFile.getAbsolutePath();
+        tmpFile.delete();
+        String summarySpecPath = tmpSummarySpecFile.getAbsolutePath();
+        tmpSummarySpecFile.delete();
+
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mPerfettoMetricCollector)
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+        List<String> args = Arrays.asList(captor.getValue());
+
+        Assert.assertTrue(args.contains(path));
+        Assert.assertTrue(args.contains("--summary"));
+        Assert.assertTrue(args.contains("--summary-metrics-v2"));
+        Assert.assertTrue(args.contains("memory_per_process-avg_rss_and_swap"));
+        Assert.assertTrue(args.contains("--summary-spec"));
+        Assert.assertTrue(args.contains(summarySpecPath));
+        Assert.assertFalse(args.contains("--run-metrics"));
+    }
+
+    /**
+     * Test that trace processor run metrics V1 and V2 are used when running the trace processor
+     * shell command.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorMetricV1andV2Args() throws Exception {
+        OptionSetter setter = new OptionSetter(mPerfettoMetricCollector);
+        setter.setOptionValue("pull-pattern-keys", "perfettofile");
+        setter.setOptionValue("perfetto-v1-metrics", "true");
+        setter.setOptionValue("perfetto-v2-metrics", "true");
+        HashMap<String, Metric> currentMetrics = new HashMap<>();
+
+        currentMetrics.put("perfettofile", TfMetricProtoUtil.stringToMetric("/data/trace.pb"));
+        Mockito.when(mMockDevice.pullFile(Mockito.eq("/data/trace.pb"), Mockito.eq(0)))
+                .thenReturn(new File("trace"));
+
+        TestDescription testDesc = new TestDescription("xyz", "abc");
+        CommandResult cr = new CommandResult();
+        cr.setStatus(CommandStatus.SUCCESS);
+        cr.setStdout("sometext");
+
+        File tmpFile = File.createTempFile("trace_processor_shell", "");
+        File tmpSummarySpecFile =
+                File.createTempFile("memory_per_process-avg_rss_and_swap.textproto", "");
+
+        // Verifies the trace processor shell lookup in test artifacts file path map.
+        Mockito.doReturn(tmpFile)
+                .when(mPerfettoMetricCollector)
+                .getFileFromTestArtifacts("trace_processor_shell");
+        Mockito.doReturn(tmpSummarySpecFile)
+                .when(mPerfettoMetricCollector)
+                .getFileFromTestArtifacts("memory_per_process-avg_rss_and_swap.textproto");
+        Mockito.doReturn(cr)
+                .when(mPerfettoMetricCollector)
+                .runHostCommand(Mockito.anyLong(), Mockito.any(), Mockito.any(), Mockito.any());
+
+        mPerfettoMetricCollector.testRunStarted("runName", 1);
+        mPerfettoMetricCollector.testStarted(testDesc);
+        mPerfettoMetricCollector.testEnded(testDesc, currentMetrics);
+        mPerfettoMetricCollector.testRunEnded(100L, new HashMap<String, Metric>());
+
+        String path = tmpFile.getAbsolutePath();
+        tmpFile.delete();
+        String summarySpecPath = tmpSummarySpecFile.getAbsolutePath();
+        tmpSummarySpecFile.delete();
+
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mPerfettoMetricCollector, times(2))
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+        List<String[]> args = captor.getAllValues();
+
+        // Verify metric v1 args.
+        Assert.assertEquals(args.get(0)[0], path);
+        Assert.assertEquals(args.get(0)[1], "--run-metrics");
+        Assert.assertEquals(args.get(0)[2], "android_mem");
+        Assert.assertEquals(args.get(0)[3], "--metrics-output=text");
+
+        // Verify metric v2 args.
+        Assert.assertEquals(args.get(1)[0], path);
+        Assert.assertEquals(args.get(1)[1], "--summary");
+        Assert.assertEquals(args.get(1)[2], "--summary-metrics-v2");
+        Assert.assertEquals(args.get(1)[3], "memory_per_process-avg_rss_and_swap");
+        Assert.assertEquals(args.get(1)[4], "--summary-spec");
+        Assert.assertEquals(args.get(1)[5], summarySpecPath);
+    }
+
     /** Test that the trace processor shell outputs run time and status. */
     @Test
     public void testTraceProcessorRunTimeAndStatus_success() throws Exception {
@@ -526,6 +659,4 @@ public class PerfettoPullerMetricCollectorTest {
                 PerfettoPullerMetricCollector.splitKeyValue("a:b:c:xyz"),
                 new Pair<>("a:b:c", "xyz"));
     }
-
 }
-
diff --git a/javatests/com/android/tradefed/observatory/TestDiscoveryExecutorTest.java b/javatests/com/android/tradefed/observatory/TestDiscoveryExecutorTest.java
index 66c5ac8c5..5af266d93 100644
--- a/javatests/com/android/tradefed/observatory/TestDiscoveryExecutorTest.java
+++ b/javatests/com/android/tradefed/observatory/TestDiscoveryExecutorTest.java
@@ -25,6 +25,7 @@ import static org.mockito.Mockito.when;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationFactory;
 import com.android.tradefed.config.IConfigurationFactory;
+import com.android.tradefed.config.filter.GlobalTestFilter;
 import com.android.tradefed.targetprep.BaseTargetPreparer;
 import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.suite.BaseTestSuite;
@@ -101,6 +102,7 @@ public class TestDiscoveryExecutorTest {
                                     ;
                                 }),
                         Mockito.isNull());
+        when(mMockedConfiguration.getGlobalFilters()).thenReturn(new GlobalTestFilter());
     }
 
     public static class DiscoverablePreparer extends BaseTargetPreparer
diff --git a/javatests/com/android/tradefed/observatory/TestMappingDiscoveryAgentTest.java b/javatests/com/android/tradefed/observatory/TestMappingDiscoveryAgentTest.java
new file mode 100644
index 000000000..d578fb326
--- /dev/null
+++ b/javatests/com/android/tradefed/observatory/TestMappingDiscoveryAgentTest.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.observatory;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.testtype.IRemoteTest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/** Unit tests for {@link TestMappingDiscoveryAgent}. */
+@RunWith(JUnit4.class)
+public class TestMappingDiscoveryAgentTest {
+    private IConfiguration mConfiguration;
+    private TestDiscoveryInvoker mTestDiscoveryInvoker;
+    private TestDiscoveryUtil mTestDiscoveryUtil;
+
+    private List<IRemoteTest> mTestList = new ArrayList<>();
+
+    private FakeDiscoverableTestClassesTest mFakeValidationTest =
+            new FakeDiscoverableTestClassesTest(
+                    TestMappingDiscoveryAgent.getValidationTestClassNames());
+
+    private FakeDiscoverableTestClassesTest mFakeTestMappingValidationTest =
+            new FakeDiscoverableTestClassesTest(
+                    TestMappingDiscoveryAgent.getTestMappingValidationTestClassNames());
+
+    private FakeDiscoverableTestClassesTest mFakeOtherDiscoverableTestClassesTest =
+            new FakeDiscoverableTestClassesTest(
+                    new HashSet<String>(Arrays.asList("some.test.class")));
+
+    private FakeRemoteTest mFakeNonValidationTest = new FakeRemoteTest();
+
+    private String[] mArgs = {};
+
+    private static Map<String, List<String>> mFakeTestDiscoveryResult = new HashMap<>();
+
+    @Before
+    public void setUp() throws Exception {
+        mConfiguration = Mockito.mock(IConfiguration.class);
+        mTestDiscoveryInvoker = Mockito.mock(TestDiscoveryInvoker.class);
+        mTestDiscoveryUtil = Mockito.mock(TestDiscoveryUtil.class);
+        mFakeTestDiscoveryResult.put(TestDiscoveryInvoker.TEST_MODULES_LIST_KEY, new ArrayList<>());
+        mFakeTestDiscoveryResult.put(
+                TestDiscoveryInvoker.TEST_DEPENDENCIES_LIST_KEY, new ArrayList<>());
+        when(mTestDiscoveryUtil.getConfiguration(Mockito.any())).thenReturn(mConfiguration);
+        when(mConfiguration.getTests()).thenReturn(mTestList);
+        when(mTestDiscoveryInvoker.discoverTestMappingDependencies())
+                .thenReturn(mFakeTestDiscoveryResult);
+    }
+
+    /** Test the case of test config that has a device&general validation test entry. */
+    @Test
+    public void testValidationTestDiscovery() throws Exception {
+        mTestList.add(mFakeValidationTest);
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should discover validation test.
+        assertTrue(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should not go to discover test mapping test modules logic.
+        Mockito.verify(mTestDiscoveryInvoker, never()).discoverTestMappingDependencies();
+    }
+
+    /** Test the case of test config that has a test mapping validation test entry. */
+    @Test
+    public void testTestMappingValidationTestDiscovery() throws Exception {
+        mTestList.add(mFakeTestMappingValidationTest);
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should discover test mapping validation test.
+        assertTrue(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should not go to discover test mapping test modules logic.
+        Mockito.verify(mTestDiscoveryInvoker, never()).discoverTestMappingDependencies();
+    }
+
+    /** Test the case of test config that normal test entries that has discoverable test classes. */
+    @Test
+    public void testOtherDiscoverableTestClassTestDiscovery() throws Exception {
+        mTestList.add(mFakeOtherDiscoverableTestClassesTest);
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should not discover as validation test.
+        assertFalse(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should go to test mapping test discovery logic.
+        Mockito.verify(mTestDiscoveryInvoker, atLeastOnce()).discoverTestMappingDependencies();
+    }
+
+    /** Test the case of test config that has single non-validation test entries. */
+    @Test
+    public void testNonValidationTestDiscovery_SingleTest() throws Exception {
+        mTestList.add(mFakeNonValidationTest);
+        when(mTestDiscoveryInvoker.discoverTestDependencies()).thenReturn(new HashMap<>());
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should not discover as validation test.
+        assertFalse(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should go to test mapping test discovery logic.
+        Mockito.verify(mTestDiscoveryInvoker, atLeastOnce()).discoverTestMappingDependencies();
+    }
+
+    /** Test the case of test config that has multiple non-validation test entries. */
+    @Test
+    public void testNonValidationTestDiscovery_MultipleTests() throws Exception {
+        mTestList.add(mFakeNonValidationTest);
+        mTestList.add(mFakeNonValidationTest);
+        when(mTestDiscoveryInvoker.discoverTestDependencies()).thenReturn(new HashMap<>());
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should not discover as validation test.
+        assertFalse(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should go to test mapping test discovery logic.
+        Mockito.verify(mTestDiscoveryInvoker, atLeastOnce()).discoverTestMappingDependencies();
+    }
+
+    /** Test the case of test config that has multiple test entries of discoverable test class. */
+    @Test
+    public void testMultipleValidationTestDiscovery() throws Exception {
+        mTestList.add(mFakeValidationTest);
+        mTestList.add(mFakeOtherDiscoverableTestClassesTest);
+        TestMappingDiscoveryAgent testMappingDiscoveryAgent =
+                new TestMappingDiscoveryAgent(mTestDiscoveryInvoker, mTestDiscoveryUtil);
+        testMappingDiscoveryAgent.discoverTestMapping(mArgs);
+        // Should not discover as validation test when there's multiple tests in the config.
+        assertFalse(testMappingDiscoveryAgent.isValidationTestDiscovered());
+        // Should go to test mapping test discovery logic.
+        Mockito.verify(mTestDiscoveryInvoker, atLeastOnce()).discoverTestMappingDependencies();
+    }
+
+    static class FakeDiscoverableTestClassesTest implements IRemoteTest, IDiscoverTestClasses {
+        Set<String> mClassNames;
+
+        public FakeDiscoverableTestClassesTest(Set<String> classNames) {
+            mClassNames = classNames;
+        }
+
+        @Override
+        public Set<String> getClassNames() {
+            return mClassNames;
+        }
+    }
+
+    static class FakeRemoteTest implements IRemoteTest {}
+}
diff --git a/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
index 6f3d89766..906b3f0e3 100644
--- a/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
+++ b/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
@@ -890,7 +890,9 @@ public class BasePostProcessorTest {
         listener.testEnded(TEST_DESCRIPTION, new HashMap<String, Metric>());
         listener.testRunEnded(0L, new HashMap<String, Metric>());
 
-        verify(mMockListener, times(3))
+        // test logs that are saved inside postprocessor should not be forwarded to avoid logging
+        // the file again.
+        verify(mMockListener, times(0))
                 .testLog(
                         Mockito.startsWith(TestablePostProcessor.DATA_NAME_PREFIX),
                         Mockito.any(),
diff --git a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
index 3de8501b9..11d9a1f18 100644
--- a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
+++ b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
@@ -75,6 +75,7 @@ public class PerfettoGenericPostProcessorTest {
             "perfetto-alternative-parse-format";
 
     File perfettoMetricProtoFile = null;
+    File perfettoV2MetricProtoFile = null;
 
     private static final Boolean DEBUG = false;
 
@@ -584,6 +585,52 @@ public class PerfettoGenericPostProcessorTest {
         assertTrue(mProcessor.getMetricType().equals(DataType.RAW));
     }
 
+    /** Test v2 metrics are filtered correctly */
+    @Test
+    public void testParsingRunV2Metrics() throws ConfigurationException, IOException {
+        setupPerfettoV2MetricFile(METRIC_FILE_FORMAT.text, true);
+
+        mOptionSetter.setOptionValue(PREFIX_OPTION, PREFIX_OPTION_VALUE);
+        mOptionSetter.setOptionValue(ALL_METRICS_OPTION, "true");
+        Map<String, LogFile> testLogs = new HashMap<>();
+        testLogs.put(
+                PREFIX_OPTION_VALUE,
+                new LogFile(
+                        perfettoV2MetricProtoFile.getAbsolutePath(),
+                        "some.url",
+                        LogDataType.TEXTPB));
+        Map<String, Metric.Builder> parsedV2Metrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
+
+        assertMetricsContain(
+                parsedV2Metrics,
+                "memory_per_process-avg_rss_and_swap-.ShannonImsService",
+                String.format("%f", 121380864.000000));
+        assertMetricsContain(
+                parsedV2Metrics,
+                "memory_per_process-avg_rss_and_swap-.adservices",
+                String.format("%f", 123408384.000000));
+        assertMetricsContain(
+                parsedV2Metrics,
+                "memory_per_process-avg_rss_and_swap-/apex/com.android.adbd/bin/adbd",
+                String.format("%f", 10464441.000000));
+
+        assertMetricsContain(
+                parsedV2Metrics,
+                "total_runtime_per_thread_for_systemui_process-(Paused)KernelPreparation-Signal"
+                        + " Catcher-com.android.systemui",
+                String.format("%f", 260051.000000));
+        assertMetricsContain(
+                parsedV2Metrics,
+                "total_runtime_per_thread_for_systemui_process-(Paused)KernelPreparation-binder:12907_9-com.android.systemui",
+                String.format("%f", 158854.000000));
+        assertMetricsContain(
+                parsedV2Metrics,
+                "total_runtime_per_thread_for_systemui_process-(Paused)MarkingPause-Signal"
+                        + " Catcher-com.android.systemui",
+                String.format("%f", 548624.000000));
+    }
+
     /**
      * Creates sample perfetto metric proto file used for testing.
      *
@@ -882,6 +929,157 @@ public class PerfettoGenericPostProcessorTest {
         return perfettoMetricProtoFile;
     }
 
+    /**
+     * Creates sample perfetto metric proto file used for testing.
+     *
+     * @param hasProto TODO
+     */
+    private File setupPerfettoV2MetricFile(METRIC_FILE_FORMAT format, boolean isCompressed)
+            throws IOException {
+        String perfettoTextContent =
+                "metric {\n"
+                        + "  spec {\n"
+                        + "    id: \"memory_per_process-avg_rss_and_swap\"\n"
+                        + "    dimensions: \"process_name\"\n"
+                        + "    value: \"avg_rss_and_swap\"\n"
+                        + "    query {\n"
+                        + "      table {\n"
+                        + "        table_name: \"memory_rss_and_swap_per_process\"\n"
+                        + "        module_name: \"linux.memory.process\"\n"
+                        + "      }\n"
+                        + "      filters {\n"
+                        + "        column_name: \"process_name\"\n"
+                        + "        op: GLOB\n"
+                        + "        string_rhs: \"*\"\n"
+                        + "      }\n"
+                        + "      group_by {\n"
+                        + "        column_names: \"process_name\"\n"
+                        + "        aggregates {\n"
+                        + "          column_name: \"rss_and_swap\"\n"
+                        + "          op: DURATION_WEIGHTED_MEAN\n"
+                        + "          result_column_name: \"avg_rss_and_swap\"\n"
+                        + "        }\n"
+                        + "      }\n"
+                        + "    }\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \".ShannonImsService\"\n"
+                        + "    }\n"
+                        + "    value: 121380864.000000\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \".adservices\"\n"
+                        + "    }\n"
+                        + "    value: 123408384.000000\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"/apex/com.android.adbd/bin/adbd\"\n"
+                        + "    }\n"
+                        + "    value: 10464441.000000\n"
+                        + "  }\n"
+                        + "}\n"
+                        + "metric {\n"
+                        + "  spec {\n"
+                        + "    id: \"total_runtime_per_thread_for_systemui_process\"\n"
+                        + "    dimensions: \"slice_name\"\n"
+                        + "    dimensions: \"thread_name\"\n"
+                        + "    dimensions: \"process_name\"\n"
+                        + "    value: \"total_runtime\"\n"
+                        + "    query {\n"
+                        + "      id: \"group_by_simple_slices_source\"\n"
+                        + "      simple_slices {\n"
+                        + "        process_name_glob: \"com.android.systemui\"\n"
+                        + "      }\n"
+                        + "      group_by {\n"
+                        + "        column_names: \"slice_name\"\n"
+                        + "        column_names: \"thread_name\"\n"
+                        + "        column_names: \"process_name\"\n"
+                        + "        aggregates {\n"
+                        + "          column_name: \"dur\"\n"
+                        + "          op: SUM\n"
+                        + "          result_column_name: \"total_time\"\n"
+                        + "        }\n"
+                        + "      }\n"
+                        + "    }\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"(Paused)KernelPreparation\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"Signal Catcher\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"com.android.systemui\"\n"
+                        + "    }\n"
+                        + "    value: 260051.000000\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"(Paused)KernelPreparation\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"binder:12907_9\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"com.android.systemui\"\n"
+                        + "    }\n"
+                        + "    value: 158854.000000\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"(Paused)MarkingPause\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"Signal Catcher\"\n"
+                        + "    }\n"
+                        + "    dimension {\n"
+                        + "      string_value: \"com.android.systemui\"\n"
+                        + "    }\n"
+                        + "    value: 548624.000000\n"
+                        + "  }\n"
+                        + "}\n";
+
+        FileWriter fileWriter = null;
+        try {
+            perfettoV2MetricProtoFile = FileUtil.createTempFile("metric_v2_perfetto", "");
+            fileWriter = new FileWriter(perfettoV2MetricProtoFile);
+            fileWriter.write(perfettoTextContent);
+        } finally {
+            if (fileWriter != null) {
+                fileWriter.close();
+            }
+        }
+
+        if (format.equals(METRIC_FILE_FORMAT.binary)) {
+            File perfettoBinaryFile = FileUtil.createTempFile("metric_v2_perfetto_binary", ".pb");
+            try (BufferedReader bufferedReader =
+                    new BufferedReader(new FileReader(perfettoV2MetricProtoFile))) {
+                TraceMetrics.Builder builder = TraceMetrics.newBuilder();
+                TextFormat.merge(bufferedReader, builder);
+                builder.build().writeTo(new FileOutputStream(perfettoBinaryFile));
+            } catch (ParseException e) {
+                CLog.e("Failed to merge the perfetto v2 metric file." + e.getMessage());
+            } catch (IOException ioe) {
+                CLog.e(
+                        "IOException happened when reading the perfetto v2 metric file."
+                                + ioe.getMessage());
+            } finally {
+                perfettoV2MetricProtoFile.delete();
+                perfettoV2MetricProtoFile = perfettoBinaryFile;
+            }
+            return perfettoV2MetricProtoFile;
+        }
+
+        if (isCompressed) {
+            perfettoV2MetricProtoFile = compressFile(perfettoV2MetricProtoFile);
+        }
+        return perfettoV2MetricProtoFile;
+    }
+
     /** Create a zip file with perfetto metric proto file */
     private File compressFile(File decompressedFile) throws IOException {
         File compressedFile = FileUtil.createTempFile("compressed_temp", ".zip");
@@ -900,6 +1098,9 @@ public class PerfettoGenericPostProcessorTest {
         if (perfettoMetricProtoFile != null) {
             perfettoMetricProtoFile.delete();
         }
+        if (perfettoV2MetricProtoFile != null) {
+            perfettoV2MetricProtoFile.delete();
+        }
     }
 
     /** Assert that metrics contain a key and a corresponding value. */
diff --git a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
index 6ad3000ac..3869b63b9 100644
--- a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
+++ b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
@@ -328,7 +328,10 @@ public class GeneralTestsConfigValidation implements IBuildReceiver {
                             "PtsCoreGetclientTestCases.config",
                             "PtsKmsGetfbTestCases.config",
                             "PtsKmsFlipTestCases.config",
-                            "s2-geometry-library-java-tests.config"));
+                            "s2-geometry-library-java-tests.config",
+                            // TODO(b/404996613): Confirm that this test should be in
+                            //  general-tests and exempted for validation.
+                            "DesktopChromeStableTestCases.config"));
 
     @Override
     public void setBuild(IBuildInfo buildInfo) {
@@ -430,7 +433,8 @@ public class GeneralTestsConfigValidation implements IBuildReceiver {
                             URI uri = new URI(apk.getPath());
                             if (uri.getScheme() != null
                                     && (uri.getScheme().contains("gs")
-                                            || uri.getScheme().contains("http"))) {
+                                            || uri.getScheme().contains("http")
+                                            || uri.getScheme().contains("pstash"))) {
                                 continue;
                             }
                         }
diff --git a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
index fff96b47d..b5f5e6d32 100644
--- a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
+++ b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
@@ -177,6 +177,7 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "CtsDevicePolicyManagerTestCases_Permissions",
                     "CtsDevicePolicyManagerTestCases_LockSettingsTest",
                     "CtsMediaAudioTestCases",
+                    "CtsMediaAudioTestCases_Presubmit_NoDevice",
                     "CtsScopedStoragePublicVolumeHostTest",
                     "CtsContentTestCases",
                     "CtsHostsideNetworkTests",
@@ -186,9 +187,12 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "CtsStatsdAtomHostTestCases",
                     "CtsStatsdAtomHostTestCases_statsdatom_voiceinteraction",
                     "CtsMediaPlayerTestCases",
+                    "CtsMediaPlayerTestCases_Presubmit_NoDevice",
                     "CtsMediaDecoderTestCases",
+                    "CtsMediaDecoderTestCases_Presubmit_NoDevice",
                     "CtsQuickAccessWalletTestCases",
                     "CtsMediaMiscTestCases",
+                    "CtsMediaMiscTestCases_Presubmit_NoDevice",
                     "NetworkStagedRollbackTest",
                     "CtsUsesNativeLibraryTest",
                     "RollbackTest",
@@ -198,17 +202,22 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "sdkextensions_e2e_tests",
                     "StagedRollbackTest",
                     "CtsMediaEncoderTestCases",
+                    "CtsMediaEncoderTestCases_Presubmit_NoDevice",
                     "CtsRootRollbackManagerHostTestCases",
                     "StagedInstallInternalTest",
                     "FrameworksWifiTests",
                     "MultiUserRollbackTest",
                     "binderRpcTest",
                     "CtsMediaCodecTestCases",
+                    "CtsMediaCodecTestCases_PresubmitNoDevice",
+                    "CtsMediaCodecTestCases_cts_encodedecodetest",
+                    "CtsMediaCodecTestCases_cts_decodeeditencodetest",
                     "CtsRollbackManagerHostTestCases",
                     "CtsAutoFillServiceTestCases",
                     "CtsAutoFillServiceTestCases_cts_inline",
                     "CtsAutoFillServiceTestCases_android_server_autofill_Presubmit",
                     "CtsOsTestCases",
+                    "CtsOsTestCases_presubmit_NoLarge",
                     "CtsDynamicMimeHostTestCases",
                     "VtsHalNeuralnetworksTargetTest",
                     "CtsWifiTestCases",
diff --git a/javatests/com/android/tradefed/result/CollectingTestListenerTest.java b/javatests/com/android/tradefed/result/CollectingTestListenerTest.java
index daae8dfbc..a2c58eb05 100644
--- a/javatests/com/android/tradefed/result/CollectingTestListenerTest.java
+++ b/javatests/com/android/tradefed/result/CollectingTestListenerTest.java
@@ -362,6 +362,20 @@ public final class CollectingTestListenerTest {
         assertThat(mCollectingTestListener.getExpectedTests()).isEqualTo(3);
     }
 
+    @Test
+    public void testClearTestRunResults() {
+        final TestDescription test1 = injectTestRun("run1", "testFoo1", METRIC_VALUE, 0);
+        final TestDescription test2 = injectTestRun("run2", "testFoo2", METRIC_VALUE2, 0);
+        assertThat(mCollectingTestListener.getTestRunNames()).containsExactly("run1", "run2");
+        assertThat(mCollectingTestListener.getMergedTestRunResults().size()).isEqualTo(2);
+        assertThat(mCollectingTestListener.getCurrentRunResults().getNumTests()).isEqualTo(1);
+
+        mCollectingTestListener.clearTestRunResults();
+        assertThat(mCollectingTestListener.getTestRunNames()).isEmpty();
+        assertThat(mCollectingTestListener.getMergedTestRunResults()).isEmpty();
+        assertThat(mCollectingTestListener.getCurrentRunResults().getNumTests()).isEqualTo(0);
+    }
+
     /**
      * Injects a single test run with 1 passed test into the {@link CollectingTestListener} under
      * test
diff --git a/javatests/com/android/tradefed/result/TestResultListenerTest.java b/javatests/com/android/tradefed/result/TestResultListenerTest.java
index 819fd82c9..abd8e9264 100644
--- a/javatests/com/android/tradefed/result/TestResultListenerTest.java
+++ b/javatests/com/android/tradefed/result/TestResultListenerTest.java
@@ -54,7 +54,8 @@ public class TestResultListenerTest {
     public void testPassed() {
         mResultListener.testStarted(mTest);
         mResultListener.testEnded(mTest, Collections.emptyMap());
-        Truth.assertThat(mResults).containsEntry(mTest, createTestResult(TestStatus.PASSED));
+        Truth.assertThat(mResults).containsEntry(mTest,
+            createTestResult(TestStatus.PASSED, null));
         Truth.assertThat(mResults).hasSize(1);
     }
 
@@ -63,8 +64,7 @@ public class TestResultListenerTest {
         mResultListener.testStarted(mTest);
         mResultListener.testFailed(mTest, "foo");
         mResultListener.testEnded(mTest, Collections.emptyMap());
-        TestResult result = createTestResult(TestStatus.FAILURE);
-        result.setStackTrace("foo");
+        TestResult result = createTestResult(TestStatus.FAILURE, "foo");
         Truth.assertThat(mResults).containsEntry(mTest, result);
         Truth.assertThat(mResults).hasSize(1);
     }
@@ -75,9 +75,10 @@ public class TestResultListenerTest {
         mResultListener.testStarted(incompleteTest);
         mResultListener.testStarted(mTest);
         mResultListener.testEnded(mTest, Collections.emptyMap());
-        Truth.assertThat(mResults).containsEntry(mTest, createTestResult(TestStatus.PASSED));
+        Truth.assertThat(mResults).containsEntry(mTest, createTestResult(TestStatus.PASSED, null));
         Truth.assertThat(mResults)
-                .containsEntry(incompleteTest, createTestResult(TestStatus.INCOMPLETE));
+                .containsEntry(incompleteTest,
+                    createTestResult(TestStatus.FAILURE, "did not complete"));
         Truth.assertThat(mResults).hasSize(2);
     }
 
@@ -87,13 +88,17 @@ public class TestResultListenerTest {
         mResultListener.testStarted(incompleteTest);
         mResultListener.testRunEnded(0, Collections.emptyMap());
         Truth.assertThat(mResults)
-                .containsEntry(incompleteTest, createTestResult(TestStatus.INCOMPLETE));
+                .containsEntry(incompleteTest,
+                    createTestResult(TestStatus.FAILURE, "did not complete"));
         Truth.assertThat(mResults).hasSize(1);
     }
 
-    private TestResult createTestResult(TestStatus status) {
+    private TestResult createTestResult(TestStatus status, String trace) {
         TestResult result = new TestResult();
         result.setStatus(status);
+        if (trace != null) {
+            result.setStackTrace(trace);
+        }
         return result;
     }
 }
diff --git a/javatests/com/android/tradefed/result/proto/FileProtoResultReporterTest.java b/javatests/com/android/tradefed/result/proto/FileProtoResultReporterTest.java
index 2f8240fcd..9b15186bc 100644
--- a/javatests/com/android/tradefed/result/proto/FileProtoResultReporterTest.java
+++ b/javatests/com/android/tradefed/result/proto/FileProtoResultReporterTest.java
@@ -68,7 +68,7 @@ public class FileProtoResultReporterTest {
 
         mOutput = FileUtil.createTempFile("proto-file-reporter-test", ".pb");
         mReporter = new FileProtoResultReporter();
-        mReporter.setFileOutput(mOutput);
+        mReporter.setOutputFile(mOutput);
     }
 
     @After
diff --git a/javatests/com/android/tradefed/result/proto/InvocationProtoResultReporterTest.java b/javatests/com/android/tradefed/result/proto/InvocationProtoResultReporterTest.java
new file mode 100644
index 000000000..f43bcfd5c
--- /dev/null
+++ b/javatests/com/android/tradefed/result/proto/InvocationProtoResultReporterTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.proto;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.verify;
+
+import com.android.tradefed.config.ConfigurationDescriptor;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.testtype.suite.ITestSuite;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.proto.TestRecordProtoUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/** Unit tests for {@link InvocationProtoResultReporter}. */
+@RunWith(JUnit4.class)
+public class InvocationProtoResultReporterTest {
+
+    private InvocationProtoResultReporter mReporter;
+    private File mOutput;
+    @Mock ITestInvocationListener mMockListener;
+
+    @Before
+    public void setUp() throws IOException {
+        MockitoAnnotations.initMocks(this);
+
+        mOutput = FileUtil.createTempFile("proto-file-reporter-test", ".pb");
+    }
+
+    @After
+    public void tearDown() {
+        FileUtil.deleteFile(mOutput);
+    }
+
+    @Test
+    public void testInvocationReporting() throws Exception {
+        IInvocationContext context = new InvocationContext();
+        context.addInvocationAttribute("invocation_id", "I9999");
+        mReporter = new InvocationProtoResultReporter(context, false);
+        mReporter.setOutputFile(mOutput);
+        TestDescription test1 = new TestDescription("class1", "test1");
+
+        mReporter.invocationStarted(context);
+        IInvocationContext module1Context = createModuleContext("module1");
+        mReporter.testModuleStarted(module1Context);
+        mReporter.testRunStarted("run1", 1);
+        mReporter.testStarted(test1);
+        mReporter.testEnded(test1, new HashMap<String, Metric>());
+        mReporter.testRunEnded(200L, new HashMap<String, Metric>());
+        module1Context.addInvocationAttribute(ITestSuite.MODULE_END_TIME, "endTime");
+        mReporter.testModuleEnded();
+        mReporter.invocationEnded(0L);
+
+        ProtoResultParser parser = new ProtoResultParser(mMockListener, context, true);
+        parser.processFinalizedProto(TestRecordProtoUtil.readFromFile(mOutput, false));
+
+        verify(mMockListener).invocationStarted(Mockito.any());
+        verify(mMockListener).testModuleStarted(Mockito.any());
+        verify(mMockListener)
+                .testRunStarted(
+                        Mockito.eq("run1"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
+        verify(mMockListener).testStarted(Mockito.eq(test1), Mockito.anyLong());
+        verify(mMockListener)
+                .testEnded(
+                        Mockito.eq(test1),
+                        Mockito.anyLong(),
+                        Mockito.<HashMap<String, Metric>>any());
+        verify(mMockListener).testRunEnded(200L, new HashMap<String, Metric>());
+        verify(mMockListener).testModuleEnded();
+        verify(mMockListener).invocationEnded(anyLong());
+        assertFalse(mReporter.stopCaching());
+        Map<String, String> metadata = ModuleProtoResultReporter.parseResultsMetadata(mOutput);
+        assertTrue(metadata.containsKey(ModuleProtoResultReporter.INVOCATION_ID_KEY));
+    }
+
+    @Test
+    public void testInvocationReporting_failure() throws Exception {
+        IInvocationContext context = new InvocationContext();
+        mReporter = new InvocationProtoResultReporter(context, false);
+        mReporter.setOutputFile(mOutput);
+
+        mReporter.invocationStarted(context);
+        mReporter.invocationFailed(new RuntimeException("failure"));
+        mReporter.invocationEnded(0L);
+
+        assertTrue(mReporter.stopCaching());
+    }
+
+    private IInvocationContext createModuleContext(String moduleId) {
+        IInvocationContext context = new InvocationContext();
+        context.addInvocationAttribute(ModuleDefinition.MODULE_ID, moduleId);
+        context.setConfigurationDescriptor(new ConfigurationDescriptor());
+        context.addInvocationAttribute(ITestSuite.MODULE_START_TIME, "startTime");
+        return context;
+    }
+}
diff --git a/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java b/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java
index 3cbb3fbc5..6079be1f6 100644
--- a/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java
+++ b/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java
@@ -57,7 +57,7 @@ public class ModuleProtoResultReporterTest {
 
         mOutput = FileUtil.createTempFile("proto-file-reporter-test", ".pb");
         mReporter = new ModuleProtoResultReporter();
-        mReporter.setFileOutput(mOutput);
+        mReporter.setOutputFile(mOutput);
     }
 
     @After
@@ -103,7 +103,7 @@ public class ModuleProtoResultReporterTest {
         IInvocationContext context = new InvocationContext();
         context.addInvocationAttribute(ModuleProtoResultReporter.INVOCATION_ID_KEY, "I8888");
         mReporter = new ModuleProtoResultReporter(context, false);
-        mReporter.setFileOutput(mOutput);
+        mReporter.setOutputFile(mOutput);
         TestDescription test1 = new TestDescription("class1", "test1");
 
         IInvocationContext module1Context = createModuleContext("module1");
diff --git a/javatests/com/android/tradefed/result/resultdb/InvocationSimulator.java b/javatests/com/android/tradefed/result/resultdb/InvocationSimulator.java
new file mode 100644
index 000000000..6398ed06a
--- /dev/null
+++ b/javatests/com/android/tradefed/result/resultdb/InvocationSimulator.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.ConfigurationDescriptor;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.ILogSaverListener;
+import com.android.tradefed.result.ITestSummaryListener;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.TestSummary;
+import com.android.tradefed.result.skipped.SkipReason;
+import com.android.tradefed.util.MultiMap;
+
+import java.time.LocalDateTime;
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/** Invocation simulator for testing. */
+public class InvocationSimulator {
+
+    public enum TestStatus {
+        PASS("pass"),
+        FAIL("fail"),
+        IGNORED("ignored"),
+        ASSUMPTION_FAILURE("assumptionFailure"),
+        TEST_ERROR("testError"),
+        TEST_SKIPPED("testSkipped");
+
+        private final String value;
+
+        private TestStatus(String value) {
+            this.value = value;
+        }
+
+        @Override
+        public String toString() {
+            return value;
+        }
+    }
+
+    private String mModuleName = "example-module";
+    private MultiMap<String, String> mModuleMetadata = new MultiMap<>();
+    private Map<String, String> mModuleAttributes = new HashMap<>();
+    private List<TestDescription> mTests;
+    private List<TestStatus> mTestOutcomes;
+    private List<HashMap<String, MetricMeasurement.Metric>> mTestMetricsList;
+    private Map<TestDescription, FailureDescription> mFailureDescriptions;
+    private String mSummary = "";
+    private String mTestRunError = "";
+    private FailureDescription mTestRunDescription;
+    private HashMap<String, MetricMeasurement.Metric> mTestRunMetrics;
+    private String mInvocationId;
+    private String mWorkUnitId;
+    private String mLegacyResultId;
+    private Map<String, String> mInvocationAttributes;
+    private List<IBuildInfo> mBuildInfos;
+    private List<LogFile> mTestLogs;
+    private List<LogFile> mTestRunLogs;
+    private List<LogFile> mInvocationLogs;
+    private boolean mIgnoreExceptions = false;
+    private boolean mSkipTestRuns = false;
+
+    public static InvocationSimulator create() {
+        return new InvocationSimulator();
+    }
+
+    private InvocationSimulator() {
+        mTests = new ArrayList<>();
+        mTestOutcomes = new ArrayList<>();
+        mTestMetricsList = new ArrayList<>();
+        mFailureDescriptions = new HashMap<>();
+        mTestRunMetrics = new HashMap<>();
+        mBuildInfos = new ArrayList<>();
+        mTestLogs = new ArrayList<>();
+        mTestRunLogs = new ArrayList<>();
+        mInvocationLogs = new ArrayList<>();
+        mInvocationAttributes = new HashMap<>();
+    }
+
+    public InvocationSimulator setInvocationId(String invocationId) {
+        mInvocationId = invocationId;
+        return this;
+    }
+
+    public InvocationSimulator setWorkUnitId(String workUnitId) {
+        mWorkUnitId = workUnitId;
+        return this;
+    }
+
+    public InvocationSimulator setLegacyResultId(String id) {
+        mLegacyResultId = id;
+        return this;
+    }
+
+    public InvocationSimulator withBuildInfo(IBuildInfo info) {
+        mBuildInfos.add(info);
+        return this;
+    }
+
+    public InvocationSimulator withInvocationAttribute(String name, String value) {
+        mInvocationAttributes.put(name, value);
+        return this;
+    }
+
+    private IInvocationContext getModule() {
+        ConfigurationDescriptor module = new ConfigurationDescriptor();
+        module.setModuleName(mModuleName);
+        if (!mModuleMetadata.isEmpty()) {
+            module.setMetaData(mModuleMetadata);
+        }
+        InvocationContext moduleContext = createInvocation();
+        moduleContext.setConfigurationDescriptor(module);
+        for (Map.Entry<String, String> attribute : mModuleAttributes.entrySet()) {
+            moduleContext.addInvocationAttribute(attribute.getKey(), attribute.getValue());
+        }
+        return moduleContext;
+    }
+
+    private long getStartTime() {
+        String in = "2018-09-07 15:23:45";
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
+        ZonedDateTime date = formatter.parse(in, LocalDateTime::from).atZone(ZoneId.of("UTC"));
+        return date.toInstant().toEpochMilli();
+    }
+
+    public InvocationSimulator withTest(String clazz, String method) {
+        return withTest(clazz, method, TestStatus.PASS);
+    }
+
+    public InvocationSimulator withTest(String clazz, String method, TestStatus outcome) {
+        return withTest(clazz, method, outcome, new HashMap<String, MetricMeasurement.Metric>());
+    }
+
+    public InvocationSimulator withTestFailure(
+            String clazz, String method, FailureDescription failure) {
+        mFailureDescriptions.put(new TestDescription(clazz, method), failure);
+        return this;
+    }
+
+    public InvocationSimulator withTest(
+            String clazz,
+            String method,
+            TestStatus outcome,
+            HashMap<String, MetricMeasurement.Metric> metrics) {
+        mTests.add(new TestDescription(clazz, method));
+        mTestOutcomes.add(outcome);
+        mTestMetricsList.add(metrics);
+        return this;
+    }
+
+    public InvocationSimulator withModule(String module) {
+        mModuleName = module;
+        return this;
+    }
+
+    public InvocationSimulator withModuleMetadata(String name, String value) {
+        mModuleMetadata.put(name, value);
+        return this;
+    }
+
+    public InvocationSimulator withModuleAttribute(String name, String value) {
+        mModuleAttributes.put(name, value);
+        return this;
+    }
+
+    public InvocationSimulator withoutModules() {
+        mModuleName = "";
+        return this;
+    }
+
+    public InvocationSimulator withSummary(String summary) {
+        mSummary = summary;
+        return this;
+    }
+
+    public InvocationSimulator withTestRunMetrics(
+            HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        mTestRunMetrics = runMetrics;
+        return this;
+    }
+
+    public InvocationSimulator withTestRunFailure(String message) {
+        mTestRunError = message;
+        return this;
+    }
+
+    public InvocationSimulator withTestRunFailure(FailureDescription failure) {
+        mTestRunDescription = failure;
+        return this;
+    }
+
+    public InvocationSimulator withTestLog(LogFile log) {
+        mTestLogs.add(log);
+        return this;
+    }
+
+    public InvocationSimulator withTestRunLog(LogFile log) {
+        mTestRunLogs.add(log);
+        return this;
+    }
+
+    public InvocationSimulator withInvocationLog(LogFile log) {
+        mInvocationLogs.add(log);
+        return this;
+    }
+
+    public InvocationSimulator ignoreExceptions() {
+        mIgnoreExceptions = true;
+        return this;
+    }
+
+    public InvocationSimulator skipTestRuns() {
+        mSkipTestRuns = true;
+        return this;
+    }
+
+    public <T extends ILogSaverListener & ITestSummaryListener> void simulateInvocation(
+            T reporter) {
+        if (!mSummary.isEmpty()) {
+            reporter.putEarlySummary(Arrays.asList(new TestSummary(mSummary)));
+        }
+        try {
+            reporter.invocationStarted(createInvocation());
+        } catch (Exception e) {
+            if (!mIgnoreExceptions) {
+                throw e;
+            }
+        }
+        try {
+            if (!mModuleName.isEmpty()) {
+                reporter.testModuleStarted(getModule());
+            }
+        } catch (Exception e) {
+            if (!mIgnoreExceptions) {
+                throw e;
+            }
+        }
+        try {
+            if (!mSkipTestRuns) {
+                reporter.testRunStarted("TestRun1", 1, 1);
+            }
+        } catch (Exception e) {
+            if (!mIgnoreExceptions) {
+                throw e;
+            }
+        }
+
+        simulateTests(reporter);
+        if (!mTestRunError.isEmpty()) {
+            reporter.testRunFailed(mTestRunError);
+        }
+        if (mTestRunDescription != null) {
+            reporter.testRunFailed(mTestRunDescription);
+        }
+        simulateLogs("test-run-", mTestRunLogs, reporter);
+        if (!mSkipTestRuns) {
+            reporter.testRunEnded(1000L, mTestRunMetrics);
+        }
+        if (!mModuleName.isEmpty()) {
+            reporter.testModuleEnded();
+        }
+        simulateLogs("invocation-log-", mInvocationLogs, reporter);
+        reporter.invocationEnded(100);
+    }
+
+    private InvocationContext createInvocation() {
+        InvocationContext context = new InvocationContext();
+        context.setTestTag("test tag");
+        context.addInvocationAttribute("invocation_id", mInvocationId);
+        context.addInvocationAttribute("work_unit_id", mWorkUnitId);
+        context.addInvocationAttribute("test_result_id", mLegacyResultId);
+        for (int i = 0; i < mBuildInfos.size(); i++) {
+            context.addDeviceBuildInfo(String.format("device_%d", i), mBuildInfos.get(i));
+        }
+        for (Map.Entry<String, String> attr : mInvocationAttributes.entrySet()) {
+            context.addInvocationAttribute(attr.getKey(), attr.getValue());
+        }
+        return context;
+    }
+
+    private <T extends ILogSaverListener & ITestSummaryListener> void simulateTests(T reporter) {
+        long startTime = getStartTime();
+        for (int i = 0; i < mTests.size(); i++) {
+            reporter.testStarted(mTests.get(i), startTime);
+            startTime += 100;
+            switch (mTestOutcomes.get(i)) {
+                case FAIL:
+                    reporter.testFailed(mTests.get(i), "Fail Trace");
+                    break;
+                case ASSUMPTION_FAILURE:
+                    reporter.testAssumptionFailure(mTests.get(i), "Assumption Fail Trace");
+                    break;
+                case IGNORED:
+                    reporter.testIgnored(mTests.get(i));
+                    break;
+                case TEST_SKIPPED:
+                    reporter.testSkipped(
+                            mTests.get(i),
+                            new SkipReason("skip reason message", "skip trigger", "bugId"));
+                    break;
+                default:
+                    break;
+            }
+            simulateLogs("test-log-", mTestLogs, reporter);
+            reporter.testEnded(mTests.get(i), startTime, mTestMetricsList.get(i));
+            startTime += 100;
+        }
+        for (Map.Entry<TestDescription, FailureDescription> entry :
+                mFailureDescriptions.entrySet()) {
+            reporter.testStarted(entry.getKey(), startTime);
+            startTime += 100;
+            reporter.testFailed(entry.getKey(), entry.getValue());
+            reporter.testEnded(entry.getKey(), startTime, Collections.emptyMap());
+            startTime += 100;
+        }
+    }
+
+    private void simulateLogs(String prefix, List<LogFile> logs, ILogSaverListener reporter) {
+        for (int i = 0; i < logs.size(); i++) {
+            String dataName = String.format("%s%d", prefix, i);
+            reporter.logAssociation(dataName, logs.get(i));
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java b/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java
new file mode 100644
index 000000000..a6840d922
--- /dev/null
+++ b/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.android.resultdb.proto.CreateInvocationRequest;
+import com.android.resultdb.proto.FailureReason;
+import com.android.resultdb.proto.TestResult;
+import com.android.resultdb.proto.TestStatus;
+import com.android.resultdb.proto.Variant;
+import com.android.tradefed.build.BuildInfo;
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.proto.TestRecordProto;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+
+import com.google.protobuf.util.Durations;
+import com.google.protobuf.util.Timestamps;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ResultDBReporterTest {
+
+    private InvocationSimulator mSimulator;
+    private ResultDBReporterTester mReporter;
+    private OptionSetter mOption;
+
+    private class ResultDBReporterTester extends ResultDBReporter {
+
+        public StubClient mRecorder = StubClient.create();
+
+        public ResultDBReporterTester() {
+            super();
+        }
+
+        @Override
+        IRecorderClient createRecorderClient(String invocationId, String updateToken) {
+            return mRecorder;
+        }
+
+        @Override
+        IRecorderClient createRecorderClient(CreateInvocationRequest request) {
+            return mRecorder;
+        }
+
+        @Override
+        long currentTimestamp() {
+            return 1000000000L;
+        }
+
+        @Override
+        String randomUUIDString() {
+            return "result_id";
+        }
+
+        @Override
+        String randomHexString() {
+            return "1234abcd";
+        }
+    }
+
+    private TestResult.Builder newTestResult(String method) {
+        return TestResult.newBuilder()
+                .setTestId(
+                        String.format(
+                                "ants://%s/%s/%s",
+                                "example-module", "com.google.ExampleClass", method))
+                .setResultId("1234abcd-00001")
+                .setStartTime(Timestamps.fromSeconds(1536333825L))
+                .setDuration(Durations.fromMillis(100))
+                .setStatus(TestStatus.PASS)
+                .setExpected(true)
+                .setVariant(
+                        Variant.newBuilder()
+                                .putDef("name", "test tag")
+                                .putDef("scheduler", "ATP")
+                                .build());
+    }
+
+    @Before
+    public void setUp() throws ConfigurationException {
+        mReporter = new ResultDBReporterTester();
+        mSimulator = InvocationSimulator.create().withModule("example-module");
+        mOption = new OptionSetter(mReporter);
+    }
+
+    @Test
+    public void noInvocationIdInInvocationContext_reporterDisabled() {
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTest("com.google.ExampleClass", "testExampleMethod")
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults()).isEmpty();
+    }
+
+    @Test
+    public void createLocalInvocation_invocationCreated() throws Exception {
+        mOption.setOptionValue("create-local-invocation", "true");
+        mSimulator
+                .withTest("com.google.ExampleClass", "testExampleMethod")
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(newTestResult("testExampleMethod").build());
+    }
+
+    @Test
+    public void uploadFunctionalResults() {
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTest("com.google.ExampleClass", "testExampleMethod")
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(newTestResult("testExampleMethod").build());
+    }
+
+    @Test
+    public void uploadResultWithVariant() {
+        BuildInfo info = new BuildInfo("1", "target_1");
+        info.setBuildBranch("test-branch");
+        info.setBuildFlavor("test-flavor");
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTest("com.google.ExampleClass", "testExampleMethod")
+                .withModuleAttribute("should-ignore", "ignore")
+                .withModuleAttribute(ModuleDefinition.MODULE_ABI, "test-abi")
+                .withModuleAttribute(
+                        ModuleDefinition.MODULE_PARAMETERIZATION, "test-parameterization")
+                .withBuildInfo(info)
+                .simulateInvocation(mReporter);
+
+        Variant variant =
+                Variant.newBuilder()
+                        .putDef("branch", "test-branch")
+                        .putDef("build_provider", "androidbuild")
+                        .putDef("module_abi", "test-abi")
+                        .putDef("module_param", "test-parameterization")
+                        .putDef("name", "test tag")
+                        .putDef("scheduler", "ATP")
+                        .putDef("target", "test-flavor")
+                        .build();
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(newTestResult("testExampleMethod").setVariant(variant).build());
+    }
+
+    @Test
+    public void uploadVariantResultStatus() {
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTest(
+                        "com.google.ExampleClass",
+                        "testMethodPassed",
+                        InvocationSimulator.TestStatus.PASS)
+                .withTest(
+                        "com.google.ExampleClass",
+                        "testMethodFailed",
+                        InvocationSimulator.TestStatus.FAIL)
+                .withTest(
+                        "com.google.ExampleClass",
+                        "testMethodAssumption",
+                        InvocationSimulator.TestStatus.ASSUMPTION_FAILURE)
+                .withTest(
+                        "com.google.ExampleClass",
+                        "testMethodIgnored",
+                        InvocationSimulator.TestStatus.IGNORED)
+                .withTest(
+                        "com.google.ExampleClass",
+                        "testMethodSkip",
+                        InvocationSimulator.TestStatus.TEST_SKIPPED)
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(
+                        newTestResult("testMethodPassed")
+                                .setResultId("1234abcd-00001")
+                                .setStatus(TestStatus.PASS)
+                                .setExpected(true)
+                                .build(),
+                        newTestResult("testMethodFailed")
+                                .setResultId("1234abcd-00002")
+                                .setStatus(TestStatus.FAIL)
+                                .setStartTime(Timestamps.fromMillis(1536333825200L))
+                                .setExpected(false)
+                                .setFailureReason(
+                                        FailureReason.newBuilder()
+                                                .setPrimaryErrorMessage("Fail Trace"))
+                                .build(),
+                        newTestResult("testMethodAssumption")
+                                .setResultId("1234abcd-00003")
+                                .setStatus(TestStatus.SKIP)
+                                .setStartTime(Timestamps.fromMillis(1536333825400L))
+                                .setSummaryHtml("Assumption Fail Trace")
+                                .setExpected(true)
+                                .build(),
+                        newTestResult("testMethodIgnored")
+                                .setResultId("1234abcd-00004")
+                                .setStatus(TestStatus.SKIP)
+                                .setStartTime(Timestamps.fromMillis(1536333825600L))
+                                .setExpected(true)
+                                .build(),
+                        newTestResult("testMethodSkip")
+                                .setResultId("1234abcd-00005")
+                                .setStatus(TestStatus.SKIP)
+                                .setStartTime(Timestamps.fromMillis(1536333825800L))
+                                .setSummaryHtml("bug_id: bugId<br>trigger: skip trigger<br>")
+                                .setExpected(true)
+                                .build());
+    }
+
+    @Test
+    public void testWithFailureDescription() {
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTestFailure(
+                        "com.google.ExampleClass",
+                        "testMethodFailed",
+                        FailureDescription.create(
+                                "Failure Message", TestRecordProto.FailureStatus.TEST_FAILURE))
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(
+                        newTestResult("testMethodFailed")
+                                .setStatus(TestStatus.FAIL)
+                                .setExpected(false)
+                                .setFailureReason(
+                                        FailureReason.newBuilder()
+                                                .setPrimaryErrorMessage("Failure Message"))
+                                .setSummaryHtml("TF error type: TEST_FAILURE")
+                                .build());
+    }
+
+    @Test
+    public void testWithFailureDescription_crashFailureStatus() {
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTestFailure(
+                        "com.google.ExampleClass",
+                        "testMethodFailed",
+                        FailureDescription.create(
+                                "Failure Message\n java.lang.RuntimeException: Failure Message",
+                                TestRecordProto.FailureStatus.TIMED_OUT))
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(
+                        newTestResult("testMethodFailed")
+                                .setStatus(TestStatus.CRASH)
+                                .setExpected(false)
+                                .setFailureReason(
+                                        FailureReason.newBuilder()
+                                                .setPrimaryErrorMessage("Failure Message"))
+                                .setSummaryHtml("TF error type: TIMED_OUT")
+                                .build());
+    }
+}
diff --git a/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java b/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java
new file mode 100644
index 000000000..b1f3c42c4
--- /dev/null
+++ b/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ResultDBUtilTest {
+
+    @Test
+    public void convertBytesToHex() {
+        assertThat(
+                        ResultDBUtil.bytesToHex(
+                                new byte[] {
+                                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+                                    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
+                                    0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
+                                    0x1c, 0x1d, 0x1e, 0x1f
+                                }))
+                .isEqualTo("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f");
+    }
+
+    @Test
+    public void truncateString() {
+        // Test cases for BMP characters.
+        assertThat(ResultDBUtil.truncateString("abc", 3)).isEqualTo("abc");
+        assertThat(ResultDBUtil.truncateString("abc", 2)).isEqualTo("ab");
+        assertThat(ResultDBUtil.truncateString("abc", 1)).isEqualTo("a");
+        // Test cases for surrogate pairs.  is a 4-byte in UTF-8.
+        assertThat(ResultDBUtil.truncateString("Hello !", 8)).isEqualTo("Hello ");
+        assertThat(ResultDBUtil.truncateString("Hello !", 10)).isEqualTo("Hello ");
+        assertThat(ResultDBUtil.truncateString("Hello !", 11)).isEqualTo("Hello !");
+    }
+
+    @Test
+    public void makeValidKey() {
+        assertThat(ResultDBUtil.makeValidKey("a-b")).isEqualTo("a_b");
+        assertThat(ResultDBUtil.makeValidKey("a/b")).isEqualTo("a_b");
+        assertThat(ResultDBUtil.makeValidKey("ABc")).isEqualTo("abc");
+        assertThat(ResultDBUtil.makeValidKey("")).isEqualTo("empty_key");
+        assertThat(ResultDBUtil.makeValidKey("0key")).isEqualTo("num_0key");
+    }
+}
diff --git a/javatests/com/android/tradefed/result/skipped/SkipManagerTest.java b/javatests/com/android/tradefed/result/skipped/SkipManagerTest.java
index 08fa57535..76882d71d 100644
--- a/javatests/com/android/tradefed/result/skipped/SkipManagerTest.java
+++ b/javatests/com/android/tradefed/result/skipped/SkipManagerTest.java
@@ -50,9 +50,9 @@ public class SkipManagerTest {
 
     @Test
     public void testSkipInvocation() {
-        Truth.assertThat(mManager.shouldSkipInvocation(mTestInformation)).isFalse();
+        Truth.assertThat(mManager.shouldSkipInvocation(mTestInformation, null)).isFalse();
         mManager.reportDiscoveryWithNoTests();
-        Truth.assertThat(mManager.shouldSkipInvocation(mTestInformation)).isTrue();
+        Truth.assertThat(mManager.shouldSkipInvocation(mTestInformation, null)).isTrue();
     }
 
     @Test
diff --git a/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java b/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
index 5801462a8..14a809b55 100644
--- a/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
+++ b/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
@@ -39,6 +39,7 @@ import com.android.tradefed.testtype.ITestFilterReceiver;
 import com.android.tradefed.testtype.InstalledInstrumentationsTest;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.truth.Truth;
 
 import org.junit.Before;
@@ -48,6 +49,7 @@ import org.junit.runners.JUnit4;
 import org.mockito.Mockito;
 
 import java.util.Arrays;
+import java.util.List;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
@@ -128,6 +130,40 @@ public class BaseRetryDecisionTest {
         setter.setOptionValue("retry-strategy", "RETRY_ANY_FAILURE");
     }
 
+    @Test
+    public void testGetCommandLineArgs() throws Exception {
+        OptionSetter setter = new OptionSetter(mRetryDecision);
+        setter.setOptionValue("max-testcase-run-count", "module:1");
+        setter.setOptionValue("max-testrun-run-count", "module:2");
+        setter.setOptionValue("reboot-at-last-retry", "true");
+        setter.setOptionValue("retry-isolation-grade", "FULLY_ISOLATED");
+        setter.setOptionValue("skip-retrying-list", "module1");
+        setter.setOptionValue("skip-retrying-list", "module2");
+        setter.setOptionValue("skip-retry-in-presubmit", "true");
+
+        List<String> args = mRetryDecision.getCommandLineArgs();
+        Truth.assertThat(args)
+                .containsExactlyElementsIn(
+                        ImmutableList.of(
+                                "--max-testcase-run-count",
+                                "module:1",
+                                "--max-testcase-run-count",
+                                "3",
+                                "--max-testrun-run-count",
+                                "module:2",
+                                "--retry-strategy",
+                                "RETRY_ANY_FAILURE",
+                                "--reboot-at-last-retry",
+                                "--retry-isolation-grade",
+                                "FULLY_ISOLATED",
+                                "--skip-retrying-list",
+                                "module1",
+                                "--skip-retrying-list",
+                                "module2",
+                                "--skip-retry-in-presubmit"))
+                .inOrder();
+    }
+
     @Test
     public void testShouldRetry() throws Exception {
         TestRunResult result = createResult(null, null);
@@ -204,8 +240,6 @@ public class BaseRetryDecisionTest {
 
         boolean res = mRetryDecision.shouldRetry(mTestClass, 0, Arrays.asList(result, result2));
         assertFalse(res);
-        assertEquals(0, mTestClass.getIncludeFilters().size());
-        assertEquals(0, mTestClass.getExcludeFilters().size());
     }
 
     @Test
diff --git a/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java b/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
index 4aecb532e..a8098703a 100644
--- a/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
+++ b/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
@@ -47,6 +47,7 @@ public final class LockSettingsBaselineSetterTest {
     private static final String GET_LOCK_SCREEN_COMMAND = "locksettings get-disabled";
     private static final String LOCK_SCREEN_OFF_COMMAND = "locksettings set-disabled true";
     private static final String CLEAR_PWD_COMMAND = "locksettings clear --old %s";
+    private static final String KEYCODE_WAKEUP_COMMAND = "input keyevent KEYCODE_WAKEUP";
     private static final String KEYCODE_MENU_COMMAND = "input keyevent KEYCODE_MENU";
     private static final String KEYCODE_HOME_COMMAND = "input keyevent KEYCODE_HOME";
 
@@ -71,6 +72,8 @@ public final class LockSettingsBaselineSetterTest {
     public void setBaseline_lockScreenOff_skipRemovingPasswords() throws Exception {
         when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
@@ -90,6 +93,8 @@ public final class LockSettingsBaselineSetterTest {
                 .thenReturn(
                         getMockCommandResult(CommandStatus.SUCCESS, "false"),
                         getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
@@ -100,11 +105,27 @@ public final class LockSettingsBaselineSetterTest {
         verify(mMockDevice).executeShellV2Command(String.format(CLEAR_PWD_COMMAND, "1234"));
     }
 
-    /** Test that the setter returns false when the baseline is failed to remove lock screen. */
+    /** Test that the setter returns false when the lockscreen is disabled and so not removed. */
     @Test
     public void setBaseline_removeLockScreenFails_returnFalse() throws Exception {
         when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "false"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
+        when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
+        when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
+        assertFalse(mSetter.setBaseline(mMockDevice));
+    }
+
+    /** Test that the setter returns false when the baseline is failed to input KEYCODE_WAKEUP. */
+    @Test
+    public void setBaseline_inputKeycodeWakeupFails_returnFalse() throws Exception {
+        when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.FAILED, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
@@ -117,6 +138,8 @@ public final class LockSettingsBaselineSetterTest {
     public void setBaseline_inputKeycodeMenuFails_returnFalse() throws Exception {
         when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.FAILED, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
@@ -129,6 +152,8 @@ public final class LockSettingsBaselineSetterTest {
     public void setBaseline_inputKeycodeHomeFails_returnFalse() throws Exception {
         when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
                 .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         when(mMockDevice.executeShellV2Command(KEYCODE_HOME_COMMAND))
diff --git a/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java b/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
index a3a37e511..3f6341701 100644
--- a/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
@@ -388,7 +388,6 @@ public class GkiDeviceFlashPreparerTest {
         FileUtil.writeToFile("ddd", bootImg);
         mBuildInfo.setFile("gki_boot.img", bootImg, "0");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "flash", "boot", mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mSuccessResult);
@@ -418,7 +417,6 @@ public class GkiDeviceFlashPreparerTest {
         mBuildInfo.setFile("gki_boot.img", bootImg, "0");
         mOptionSetter.setOptionValue("fastboot-flash-option", "--disable-verity");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "--disable-verity",
                         "flash",
@@ -442,6 +440,37 @@ public class GkiDeviceFlashPreparerTest {
         verify(mMockDevice).postBootSetup();
     }
 
+    /* Verifies that preparer can flash GKI boot image with device wipe option */
+    @Test
+    public void testSetup_Success_with_device_wipe() throws Exception {
+        File bootImg = FileUtil.createTempFile("boot", ".img", mTmpDir);
+        bootImg.renameTo(new File(mTmpDir, "boot.img"));
+        FileUtil.writeToFile("ddd", bootImg);
+        mBuildInfo.setFile("gki_boot.img", bootImg, "0");
+        mOptionSetter.setOptionValue("wipe-device-before-gki-flash", "true");
+
+        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
+        when(mMockDevice.executeLongFastbootCommand(
+                        "flash",
+                        "boot",
+                        mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
+                .thenReturn(mSuccessResult);
+        when(mMockDevice.enableAdbRoot()).thenReturn(Boolean.TRUE);
+
+        mPreparer.setUp(mTestInfo);
+        mPreparer.tearDown(mTestInfo, null);
+
+        verify(mMockDevice).rebootIntoBootloader();
+        verify(mMockRunUtil).allowInterrupt(false);
+        verify(mMockRunUtil).allowInterrupt(true);
+        verify(mMockRunUtil).sleep(anyLong());
+        verify(mMockDevice).rebootUntilOnline();
+        verify(mMockDevice).setDate(null);
+        verify(mMockDevice).waitForDeviceAvailable(anyLong());
+        verify(mMockDevice).setRecoveryMode(RecoveryMode.AVAILABLE);
+        verify(mMockDevice).postBootSetup();
+    }
+
     /* Verifies that preparer can flash GKI boot image with additional fastboot commands */
     @Test
     public void testSetup_Success_with_additional_fastboot_commands() throws Exception {
@@ -452,7 +481,6 @@ public class GkiDeviceFlashPreparerTest {
         mOptionSetter.setOptionValue("additional-fastboot-command", "erase misc");
         mOptionSetter.setOptionValue("additional-fastboot-command", "erase devinfo");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "flash", "boot", mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mSuccessResult);
@@ -493,7 +521,6 @@ public class GkiDeviceFlashPreparerTest {
                         "boot",
                         mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mSuccessResult);
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
 
         when(mMockDevice.enableAdbRoot()).thenReturn(Boolean.TRUE);
 
@@ -533,7 +560,6 @@ public class GkiDeviceFlashPreparerTest {
         mBuildInfo.setFile("vendor_dlkm.img", vendorDlkmImg, "0");
         mBuildInfo.setFile("dtbo.img", dtboImg, "0");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "flash", "boot", mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mSuccessResult);
@@ -591,7 +617,6 @@ public class GkiDeviceFlashPreparerTest {
         mBuildInfo.setFile("vendor_boot.img", imgZip, "0");
         mBuildInfo.setFile("dtbo.img", imgZip, "0");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         eq("flash"), eq("boot"), matches(".*boot-5.4.img")))
                 .thenReturn(mSuccessResult);
@@ -631,7 +656,6 @@ public class GkiDeviceFlashPreparerTest {
         FileUtil.writeToFile("not an empty file", deviceImg);
         mBuildInfo.setDeviceImageFile(deviceImg, "0");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "flash", "boot", mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mFailureResult);
@@ -659,7 +683,6 @@ public class GkiDeviceFlashPreparerTest {
         FileUtil.writeToFile("not an empty file", deviceImg);
         mBuildInfo.setDeviceImageFile(deviceImg, "0");
 
-        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
         when(mMockDevice.executeLongFastbootCommand(
                         "flash", "boot", mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
                 .thenReturn(mSuccessResult);
diff --git a/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java b/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java
index 2c76fda56..57adf56ad 100644
--- a/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java
@@ -157,9 +157,9 @@ public class InstallKernelModulePreparerTest {
                 .thenReturn(mSuccessResult);
         mPreparer.setUp(mTestInfo);
         InOrder inOrder = Mockito.inOrder(mMockDevice);
-        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit_test"));
-        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod time_test"));
-        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit"));
+        inOrder.verify(mMockDevice).executeShellV2Command(matches("rmmod kunit_test"));
+        inOrder.verify(mMockDevice).executeShellV2Command(matches("rmmod time_test"));
+        inOrder.verify(mMockDevice).executeShellV2Command(matches("rmmod kunit"));
     }
 
     /** Test {@link InstallKernelModulePreparer#setUp()} by successfully installing 1 ko file */
@@ -203,7 +203,8 @@ public class InstallKernelModulePreparerTest {
         when(mMockDevice.executeShellV2Command(
                         matches(KUNIT_MODULE_INSTALLATION_COMMAND), anyLong(), any()))
                 .thenReturn(mSuccessResult);
-        when(mMockDevice.executeShellCommand(matches("rmmod kunit_test"))).thenReturn("");
+        when(mMockDevice.executeShellV2Command(matches("rmmod kunit_test")))
+                .thenReturn(mSuccessResult);
         when(mMockDevice.executeShellV2Command(
                         matches("insmod /data/kunit/kunit-test.ko enable=1"), anyLong(), any()))
                 .thenReturn(mSuccessResult);
@@ -246,7 +247,7 @@ public class InstallKernelModulePreparerTest {
                     ConfigurationException {
         when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
                 .thenReturn(PREEXISTING_MODULE_OUTPUT);
-        when(mMockDevice.executeShellCommand(matches("rmmod kunit"))).thenReturn("");
+        when(mMockDevice.executeShellV2Command(matches("rmmod kunit"))).thenReturn(mSuccessResult);
         mPreparer.tearDown(mTestInfo, null);
     }
 
@@ -267,7 +268,7 @@ public class InstallKernelModulePreparerTest {
         when(mMockDevice.executeShellCommand(matches("rmmod kunit"))).thenReturn("");
         mPreparer.tearDown(mTestInfo, null);
         InOrder inOrder = Mockito.inOrder(mMockDevice);
-        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit_test"));
-        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit"));
+        inOrder.verify(mMockDevice).executeShellV2Command(matches("rmmod kunit_test"));
+        inOrder.verify(mMockDevice).executeShellV2Command(matches("rmmod kunit"));
     }
 }
diff --git a/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
index 157bd8fe4..534578bbe 100644
--- a/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
+++ b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
@@ -176,9 +176,9 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("stop");
-        mInOrder.verify(mMockDevice).executeShellCommand("rm -rf /data/*");
-        mInOrder.verify(mMockDevice).reboot();
+        mInOrder.verify(mMockDevice).executeShellCommand("start");
+        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
+        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
         mInOrder.verify(mMockDevice).waitForDeviceAvailable();
         mInOrder.verify(mMockDevice).enableAdbRoot();
         mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
@@ -208,9 +208,9 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("stop");
-        mInOrder.verify(mMockDevice).executeShellCommand("rm -rf /data/*");
-        mInOrder.verify(mMockDevice).reboot();
+        mInOrder.verify(mMockDevice).executeShellCommand("start");
+        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
+        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
         mInOrder.verify(mMockDevice).waitForDeviceAvailable();
         mInOrder.verify(mMockDevice).enableAdbRoot();
         mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
@@ -240,9 +240,9 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("stop");
-        mInOrder.verify(mMockDevice).executeShellCommand("rm -rf /data/*");
-        mInOrder.verify(mMockDevice).reboot();
+        mInOrder.verify(mMockDevice).executeShellCommand("start");
+        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
+        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
         mInOrder.verify(mMockDevice).waitForDeviceAvailable();
         mInOrder.verify(mMockDevice).enableAdbRoot();
         mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
diff --git a/javatests/com/android/tradefed/targetprep/RunHostCommandTargetPreparerTest.java b/javatests/com/android/tradefed/targetprep/RunHostCommandTargetPreparerTest.java
index 002b881b4..ddd8973c2 100644
--- a/javatests/com/android/tradefed/targetprep/RunHostCommandTargetPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/RunHostCommandTargetPreparerTest.java
@@ -239,4 +239,25 @@ public final class RunHostCommandTargetPreparerTest {
                         eq(test1.getAbsolutePath()),
                         eq("$EXTRA_FILE(test2)"));
     }
+
+    @Test
+    public void testSetUp_multiExtraFile() throws Exception {
+        BuildInfo stubBuild = new BuildInfo("stub", "stub");
+        File test1 = tmpDir.newFile("test1");
+        stubBuild.setFile("test1", test1, "0");
+        when(mTestInfo.getBuildInfo()).thenReturn(stubBuild);
+
+        OptionSetter optionSetter = new OptionSetter(mPreparer);
+        optionSetter.setOptionValue(
+                "host-setup-command", "command $EXTRA_FILE(foo:test1:bar) $EXTRA_FILE(foo:test2)");
+
+        // Absolute paths are used for existing files and $EXTRA_FILE for missing files.
+        mPreparer.setUp(mTestInfo);
+        verify(mRunUtil)
+                .runTimedCmd(
+                        anyLong(),
+                        eq("command"),
+                        eq(test1.getAbsolutePath()),
+                        eq("$EXTRA_FILE(foo:test2)"));
+    }
 }
diff --git a/javatests/com/android/tradefed/targetprep/incremental/ApkChangeDetectorTest.java b/javatests/com/android/tradefed/targetprep/incremental/ApkChangeDetectorTest.java
index 5e00f4eb4..213978ce6 100644
--- a/javatests/com/android/tradefed/targetprep/incremental/ApkChangeDetectorTest.java
+++ b/javatests/com/android/tradefed/targetprep/incremental/ApkChangeDetectorTest.java
@@ -16,13 +16,16 @@
 package com.android.tradefed.targetprep.incremental;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 import com.android.tradefed.device.ITestDevice;
+import com.google.common.collect.Sets;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -40,7 +43,10 @@ public final class ApkChangeDetectorTest {
     private ApkChangeDetector mApkChangeDetector;
     private ApkChangeDetector mApkChangeDetectorLessDiskSpace;
     private ApkChangeDetector mApkChangeDetectorDiskSpaceNotObtained;
+    private ApkChangeDetector mApkChangeDetectorFileNotAccessible;
+    private ApkChangeDetector mApkChangeDetectorFileUninstallFailed;
     private ITestDevice mMockDevice;
+    private ITestDevice mMockDeviceFileUninstallFailed;
     private File mMockFile1;
     private File mMockFile2;
     private File mMockFile3;
@@ -48,10 +54,27 @@ public final class ApkChangeDetectorTest {
 
     @Before
     public void setUp() throws Exception {
-        mApkChangeDetector = spy(new ApkChangeDetector());
+        mApkChangeDetector = spy(new ApkChangeDetector(new HashSet<>()));
         mApkChangeDetectorLessDiskSpace = spy(new ApkChangeDetector());
-        mApkChangeDetectorDiskSpaceNotObtained = spy(new ApkChangeDetector());
+        mApkChangeDetectorDiskSpaceNotObtained =
+            spy(
+                new ApkChangeDetector(
+                    Sets.newHashSet(
+                        "prev.handled1", "prev.handled2", "prev.handled3", "a.b.c.package")));
+        mApkChangeDetectorFileNotAccessible = spy(new ApkChangeDetector());
+        mApkChangeDetectorFileUninstallFailed =
+            spy(
+                new ApkChangeDetector(
+                    Sets.newHashSet(
+                        "prev.handled1", "prev.handled2", "prev.handled3", "a.b.c.package")));
         mMockDevice = mock(ITestDevice.class);
+        mMockDeviceFileUninstallFailed = mock(ITestDevice.class);
+        doReturn(null).when(mMockDevice).uninstallPackage(Mockito.any());
+        doReturn("Pseudo error code").when(mMockDeviceFileUninstallFailed)
+            .uninstallPackage(Mockito.any());
+        doNothing().when(mMockDevice).deleteFile(Mockito.any());
+        doReturn(true).when(mMockDevice).pushString(Mockito.any(), Mockito.any());
+
         mMockFile1 = mock(File.class);
         mMockFile2 = mock(File.class);
         mMockFile3 = mock(File.class);
@@ -78,15 +101,36 @@ public final class ApkChangeDetectorTest {
         doReturn(apkInstallPaths)
             .when(mApkChangeDetectorDiskSpaceNotObtained)
             .getApkInstallPaths(Mockito.any(), Mockito.any());
+        doReturn(apkInstallPaths)
+            .when(mApkChangeDetectorFileNotAccessible)
+            .getApkInstallPaths(Mockito.any(), Mockito.any());
         doReturn(2000000000L)
             .when(mApkChangeDetector)
             .getFreeDiskSpaceForAppInstallation(Mockito.any());
         doReturn(15000000L)
             .when(mApkChangeDetectorLessDiskSpace)
             .getFreeDiskSpaceForAppInstallation(Mockito.any());
+        doReturn(15000000L)
+            .when(mApkChangeDetectorFileUninstallFailed)
+            .getFreeDiskSpaceForAppInstallation(Mockito.any());
         doThrow(IllegalArgumentException.class)
             .when(mApkChangeDetectorDiskSpaceNotObtained)
             .getFreeDiskSpaceForAppInstallation(Mockito.any());
+        doReturn(true)
+            .when(mApkChangeDetector)
+            .ensureIncrementalSetupSupported(Mockito.any());
+        doReturn(true)
+            .when(mApkChangeDetectorLessDiskSpace)
+            .ensureIncrementalSetupSupported(Mockito.any());
+        doReturn(true)
+            .when(mApkChangeDetectorFileUninstallFailed)
+            .ensureIncrementalSetupSupported(Mockito.any());
+        doReturn(true)
+            .when(mApkChangeDetectorDiskSpaceNotObtained)
+            .ensureIncrementalSetupSupported(Mockito.any());
+        doReturn(false)
+            .when(mApkChangeDetectorFileNotAccessible)
+            .ensureIncrementalSetupSupported(Mockito.any());
         Set<String> sha256SumsOnDevice = new HashSet<>();
         sha256SumsOnDevice.add("sha256sum1");
         sha256SumsOnDevice.add("sha256sum2");
@@ -97,22 +141,46 @@ public final class ApkChangeDetectorTest {
         doReturn(sha256SumsOnDevice)
             .when(mApkChangeDetectorLessDiskSpace)
             .getSha256SumsOnDevice(Mockito.any(), Mockito.any());
+        doReturn(sha256SumsOnDevice)
+            .when(mApkChangeDetectorFileUninstallFailed)
+            .getSha256SumsOnDevice(Mockito.any(), Mockito.any());
         doReturn(sha256SumsOnDevice)
             .when(mApkChangeDetectorDiskSpaceNotObtained)
             .getSha256SumsOnDevice(Mockito.any(), Mockito.any());
+        doNothing()
+            .when(mApkChangeDetector)
+            .loadPackagesHandledInPreviousTestRuns(mMockDevice);
+        doNothing()
+            .when(mApkChangeDetectorLessDiskSpace)
+            .loadPackagesHandledInPreviousTestRuns(mMockDevice);
+        doNothing()
+            .when(mApkChangeDetectorDiskSpaceNotObtained)
+            .loadPackagesHandledInPreviousTestRuns(mMockDevice);
+        doNothing()
+            .when(mApkChangeDetectorFileNotAccessible)
+            .loadPackagesHandledInPreviousTestRuns(mMockDevice);
+        doNothing()
+            .when(mApkChangeDetectorFileUninstallFailed)
+            .loadPackagesHandledInPreviousTestRuns(mMockDevice);
     }
 
     @Test
     public void handleTestAppsPreinstall_doInstallation_noApkInstallPathFound() throws Exception {
-        ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector());
+    ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector(new HashSet<>()));
         doReturn(new ArrayList<>()).when(apkChangeDetector)
             .getApkInstallPaths(Mockito.any(), Mockito.any());
         doReturn(2000000000L)
             .when(apkChangeDetector)
             .getFreeDiskSpaceForAppInstallation(Mockito.any());
+        doReturn(true)
+            .when(apkChangeDetector)
+            .ensureIncrementalSetupSupported(Mockito.any());
+        doNothing().when(apkChangeDetector).loadPackagesHandledInPreviousTestRuns(mMockDevice);
 
         boolean shouldSkipInstallation =
-            apkChangeDetector.handleTestAppsPreinstall("a.b.c.package", mMockTestApps, mMockDevice);
+            apkChangeDetector.handleTestAppsPreinstall(
+                "a.b.c.package", mMockTestApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
 
         assertThat(shouldSkipInstallation).isFalse();
     }
@@ -127,7 +195,9 @@ public final class ApkChangeDetectorTest {
         testApps.add(mMockFile2);
 
         boolean shouldSkipInstallation =
-            mApkChangeDetector.handleTestAppsPreinstall("a.b.c.package", testApps, mMockDevice);
+            mApkChangeDetector.handleTestAppsPreinstall(
+                "a.b.c.package", testApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
 
         assertThat(shouldSkipInstallation).isFalse();
     }
@@ -142,7 +212,24 @@ public final class ApkChangeDetectorTest {
         testApps.add(mMockFile2);
 
         boolean shouldSkipInstallation =
-            mApkChangeDetector.handleTestAppsPreinstall("a.b.c.package", testApps, mMockDevice);
+            mApkChangeDetector.handleTestAppsPreinstall(
+                "a.b.c.package", testApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
+
+        assertThat(shouldSkipInstallation).isFalse();
+    }
+
+    @Test
+    public void handleTestAppsPreinstall_doInstallation_userNotOwner()
+        throws Exception {
+        doReturn("sha256sum1").when(mApkChangeDetector).calculateSHA256OnHost(mMockFile1);
+        doReturn("sha256sum2").when(mApkChangeDetector).calculateSHA256OnHost(mMockFile2);
+        doReturn("sha256sum3").when(mApkChangeDetector).calculateSHA256OnHost(mMockFile3);
+
+        boolean shouldSkipInstallation =
+            mApkChangeDetector.handleTestAppsPreinstall(
+                "a.b.c.package", mMockTestApps, mMockDevice, /* userId= */ 12345,
+                /* forAllUsers= */ false);
 
         assertThat(shouldSkipInstallation).isFalse();
     }
@@ -156,15 +243,29 @@ public final class ApkChangeDetectorTest {
 
         boolean shouldSkipInstallation =
             mApkChangeDetector.handleTestAppsPreinstall(
-                "a.b.c.package", mMockTestApps, mMockDevice);
+                "a.b.c.package", mMockTestApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
 
         assertThat(shouldSkipInstallation).isTrue();
     }
 
+    @Test
+    public void handlePackageCleanup_forSingleUser_doAppUninstallation() throws Exception {
+        doReturn("Pseudo success message")
+            .when(mMockDevice).executeShellCommand("am force-stop a.b.c.package");
+
+        boolean shouldSkipAppUninstallation =
+            mApkChangeDetector.handlePackageCleanup(
+                "a.b.c.package", mMockDevice, /* userId= */ 12345, /* forAllUsers= */ false);
+
+        assertThat(shouldSkipAppUninstallation).isFalse();
+    }
+
     @Test
     public void handlePackageCleanup_forSingleUser_skipAppUninstallation() throws Exception {
         doReturn("Pseudo success message")
             .when(mMockDevice).executeShellCommand("am force-stop a.b.c.package");
+        mApkChangeDetector.mPackagesHandledInCurrentTestRun.add("a.b.c.package");
 
         boolean shouldSkipAppUninstallation =
             mApkChangeDetector.handlePackageCleanup(
@@ -177,6 +278,7 @@ public final class ApkChangeDetectorTest {
     public void handlePackageCleanup_forAllUsers_skipAppUninstallation() throws Exception {
         doReturn("Pseudo success message")
             .when(mMockDevice).executeShellCommand("am force-stop a.b.c.package");
+        mApkChangeDetector.mPackagesHandledInCurrentTestRun.add("a.b.c.package");
 
         boolean shouldSkipAppUninstallation =
             mApkChangeDetector.handlePackageCleanup(
@@ -185,8 +287,6 @@ public final class ApkChangeDetectorTest {
         assertThat(shouldSkipAppUninstallation).isTrue();
     }
 
-    // TODO: ihcinihsdk - Change the behavior of this test when we have the logic to handle
-    // app cleanups.
     @Test
     public void handleTestAppsPreinstall_doAppCleanup_appNeedsInstallationAndDiskSpaceNotEnough()
         throws Exception {
@@ -194,6 +294,13 @@ public final class ApkChangeDetectorTest {
             .calculateSHA256OnHost(mMockFile1);
         doReturn("sha256sum3").when(mApkChangeDetectorLessDiskSpace)
             .calculateSHA256OnHost(mMockFile3);
+        doReturn(
+                Sets.newHashSet("prev.handled1", "prev.handled2", "prev.handled3", "a.b.c.package"),
+                new HashSet<String>())
+            .when(mApkChangeDetectorLessDiskSpace)
+            .getPackagesHandledInPreviousTestRuns(mMockDevice);
+        mApkChangeDetectorLessDiskSpace.mPackagesHandledInCurrentTestRun.addAll(
+            Sets.newHashSet("prev.handled1", "cur.handled1", "cur.handled2"));
         List<File> testApps = new ArrayList<>();
         testApps.add(mMockFile1);
         testApps.add(mMockFile3);
@@ -202,24 +309,151 @@ public final class ApkChangeDetectorTest {
         // are 1,000,000 bytes and 3,000,000 bytes, respectively. Thus the estimated free space
         // after installation is 15,000,000 - 1.5 * (1,000,000 + 3,000,000) = 9,000,000, which is
         // less than the threshold 10,000,000 bytes.
-        assertThrows(UnsupportedOperationException.class, () ->
+        boolean shouldSkipAppUninstallation =
             mApkChangeDetectorLessDiskSpace.handleTestAppsPreinstall(
-                "a.b.c.package", testApps, mMockDevice));
+                "a.b.c.package", testApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
+
+        assertThat(shouldSkipAppUninstallation).isFalse();
+        verify(mMockDevice, times(0)).uninstallPackage("prev.handled1");
+        verify(mMockDevice).uninstallPackage("prev.handled2");
+        verify(mMockDevice).uninstallPackage("prev.handled3");
+        verify(mMockDevice).uninstallPackage("a.b.c.package");
+        verify(mMockDevice).deleteFile(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+    }
+
+    @Test
+    public void handleTestAppsPreinstall_doInstallation_diskSpaceNotEnoughAndFileUninstallFailed()
+        throws Exception {
+        doReturn("sha256sum1").when(mApkChangeDetectorFileUninstallFailed)
+            .calculateSHA256OnHost(mMockFile1);
+        doReturn("sha256sum3")
+            .when(mApkChangeDetectorFileUninstallFailed)
+            .calculateSHA256OnHost(mMockFile3);
+        mApkChangeDetectorFileUninstallFailed.mPackagesHandledInCurrentTestRun.addAll(
+            Sets.newHashSet("prev.handled1", "cur.handled1", "cur.handled2"));
+        List<File> testApps = new ArrayList<>();
+        testApps.add(mMockFile1);
+        testApps.add(mMockFile3);
+
+        // The free disk space before installation is 15,000,000 bytes while the two APKs' sizes
+        // are 1,000,000 bytes and 3,000,000 bytes, respectively. Thus the estimated free space
+        // after installation is 15,000,000 - 1.5 * (1,000,000 + 3,000,000) = 9,000,000, which is
+        // less than the threshold 10,000,000 bytes.
+        boolean shouldSkipAppUninstallation =
+            mApkChangeDetectorFileUninstallFailed.handleTestAppsPreinstall(
+                "a.b.c.package", testApps, mMockDeviceFileUninstallFailed, /* userId= */ null,
+                /* forAllUsers= */ true);
+
+        assertThat(shouldSkipAppUninstallation).isFalse();
+        verify(mMockDeviceFileUninstallFailed, times(0)).uninstallPackage("prev.handled1");
+        verify(mMockDeviceFileUninstallFailed).uninstallPackage("prev.handled2");
+        verify(mMockDeviceFileUninstallFailed).uninstallPackage("prev.handled3");
+        verify(mMockDeviceFileUninstallFailed).uninstallPackage("a.b.c.package");
+        // The file is not deleted because the deletion of the previous three files failed.
+        verify(mMockDeviceFileUninstallFailed, times(0))
+            .deleteFile(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+    }
+
+    @Test
+    public void handleTestAppsPreinstall_incrementalSetupNotSupported()
+        throws Exception {
+        List<File> testApps = new ArrayList<>();
+        testApps.add(mMockFile1);
+
+        boolean incrementalSetupSupported =
+            mApkChangeDetectorFileNotAccessible.handleTestAppsPreinstall(
+                "a.b.c.package", testApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
+
+        assertThat(incrementalSetupSupported).isFalse();
     }
 
     @Test
     public void handleTestAppsPreinstall_incrementalSetupNotSupported_diskSpaceNotObtained()
         throws Exception {
-        doReturn("sha256sum1").when(mApkChangeDetectorDiskSpaceNotObtained)
+        doReturn("sha256sum1")
+            .when(mApkChangeDetectorDiskSpaceNotObtained)
             .calculateSHA256OnHost(mMockFile1);
+        mApkChangeDetectorDiskSpaceNotObtained.mPackagesHandledInCurrentTestRun.addAll(
+            Sets.newHashSet("prev.handled1", "cur.handled1", "cur.handled2"));
         List<File> testApps = new ArrayList<>();
         testApps.add(mMockFile1);
 
         boolean incrementalSetupSupported =
             mApkChangeDetectorDiskSpaceNotObtained.handleTestAppsPreinstall(
-                "a.b.c.package", testApps, mMockDevice);
+                "a.b.c.package", testApps, mMockDevice, /* userId= */ null,
+                /* forAllUsers= */ true);
+
+        assertThat(incrementalSetupSupported).isFalse();
+        verify(mMockDevice, times(0)).uninstallPackage("prev.handled1");
+        verify(mMockDevice, times(0)).uninstallPackage("prev.handled2");
+        verify(mMockDevice, times(0)).uninstallPackage("prev.handled3");
+        verify(mMockDevice, times(0)).uninstallPackage("a.b.c.package");
+        verify(mMockDevice, times(0))
+            .deleteFile(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+    }
+
+    @Test
+    public void ensureIncrementalSetupSupported_returnsFalse_sha256NotInstalled()
+        throws Exception {
+        ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector());
+        doReturn("sh: sha256sum: inaccessible or not found").when(mMockDevice)
+            .executeShellCommand("sha256sum --help");
+        doNothing().when(apkChangeDetector).loadPackagesHandledInPreviousTestRuns(mMockDevice);
+
+        boolean incrementalSetupSupported =
+            apkChangeDetector.ensureIncrementalSetupSupported(mMockDevice);
 
         assertThat(incrementalSetupSupported).isFalse();
     }
-}
 
+    @Test
+    public void ensureIncrementalSetupSupported_returnsFalse_noAccessToSdCardDirectory()
+        throws Exception {
+        ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector());
+        doReturn("").when(mMockDevice).executeShellCommand("sha256sum --help");
+        doReturn(false).when(mMockDevice)
+            .doesFileExist(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+        doReturn(false).when(mMockDevice)
+            .pushString("", ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+        doNothing().when(apkChangeDetector).loadPackagesHandledInPreviousTestRuns(mMockDevice);
+
+        boolean incrementalSetupSupported =
+            apkChangeDetector.ensureIncrementalSetupSupported(mMockDevice);
+
+        assertThat(incrementalSetupSupported).isFalse();
+    }
+
+    @Test
+    public void ensureIncrementalSetupSupported_returnsTrue_installCacheFileExists()
+        throws Exception {
+        ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector());
+        doReturn("").when(mMockDevice).executeShellCommand("sha256sum --help");
+        doReturn(true).when(mMockDevice)
+            .doesFileExist(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+        doNothing().when(apkChangeDetector).loadPackagesHandledInPreviousTestRuns(mMockDevice);
+
+        boolean incrementalSetupSupported =
+            apkChangeDetector.ensureIncrementalSetupSupported(mMockDevice);
+
+        assertThat(incrementalSetupSupported).isTrue();
+    }
+
+    @Test
+    public void ensureIncrementalSetupSupported_returnsTrue_canCreateInstallCacheFile()
+        throws Exception {
+        ApkChangeDetector apkChangeDetector = spy(new ApkChangeDetector());
+        doReturn("").when(mMockDevice).executeShellCommand("sha256sum --help");
+        doReturn(false).when(mMockDevice)
+            .doesFileExist(ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+        doReturn(true).when(mMockDevice)
+            .pushString("", ApkChangeDetector.PACKAGE_INSTALLED_FILE_PATH);
+        doNothing().when(apkChangeDetector).loadPackagesHandledInPreviousTestRuns(mMockDevice);
+
+        boolean incrementalSetupSupported =
+            apkChangeDetector.ensureIncrementalSetupSupported(mMockDevice);
+
+        assertThat(incrementalSetupSupported).isTrue();
+    }
+}
diff --git a/javatests/com/android/tradefed/targetprep/multi/MixImageZipPreparerTest.java b/javatests/com/android/tradefed/targetprep/multi/MixImageZipPreparerTest.java
index 7be00a9fd..e3cacd28d 100644
--- a/javatests/com/android/tradefed/targetprep/multi/MixImageZipPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/multi/MixImageZipPreparerTest.java
@@ -224,9 +224,14 @@ public class MixImageZipPreparerTest {
     }
 
     private void setUpDevice() throws IOException {
+        setUpDevice(false);
+    }
+
+    private void setUpDevice(boolean imageZipUncompressed) throws IOException {
         ITestDevice mockDevice = Mockito.mock(ITestDevice.class);
         mDeviceImageZip =
                 createImageZip(
+                        imageZipUncompressed,
                         DEVICE_CONTENT,
                         BOOT_IMAGE_NAME,
                         VENDOR_IMAGE_NAME,
@@ -316,7 +321,7 @@ public class MixImageZipPreparerTest {
         if (mResourceBuild != null) {
             mResourceBuild.cleanUp();
         }
-        FileUtil.deleteFile(mDeviceImageZip);
+        FileUtil.recursiveDelete(mDeviceImageZip);
         FileUtil.deleteFile(mSystemImageZip);
         FileUtil.deleteFile(mMiscInfoFile);
         FileUtil.deleteFile(mOtaToolsZip);
@@ -350,6 +355,10 @@ public class MixImageZipPreparerTest {
     }
 
     private File createImageZip(String content, String... fileNames) throws IOException {
+      return createImageZip(false, content, fileNames);
+    }
+
+    private File createImageZip(boolean uncompressed, String content, String... fileNames) throws IOException {
         // = new ArrayList<File>(fileNames.length);
         File tempDir = null;
         try {
@@ -360,9 +369,14 @@ public class MixImageZipPreparerTest {
                 tempFiles.add(new File(tempDir, fileName));
             }
 
+            if (uncompressed) {
+                return tempDir;
+            }
             return ZipUtil.createZip(tempFiles);
         } finally {
-            FileUtil.recursiveDelete(tempDir);
+            if (!uncompressed) {
+                FileUtil.recursiveDelete(tempDir);
+            }
         }
     }
 
@@ -470,6 +484,17 @@ public class MixImageZipPreparerTest {
         runPreparerTest();
     }
 
+    /**
+     * Test that the mixing works with an uncompressed device image zip.
+     */
+    @Test
+    public void testSetUpWithSystemUsingUncompressedImage()
+            throws TargetSetupError, BuildError, DeviceNotAvailableException, IOException {
+        setUpPreparerAndSystem();
+        setUpDevice(true);
+        runPreparerTest();
+    }
+
     /** Test that the mixed {@link IDeviceBuildInfo} contains the system image file mapping. */
     @Test
     public void testSetUpWithSystemFileMapping()
diff --git a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
index 667216314..72c677252 100644
--- a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
+++ b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
@@ -104,16 +104,12 @@ public class IncrementalImageFuncTest extends BaseHostJUnit4Test {
         IncrementalImageUtil updateUtil =
                 new IncrementalImageUtil(
                         getDevice(),
-                        getBuild().getFile("src-image"),
-                        null,
-                        null,
                         getBuild().getFile("target-image"),
                         getBuild().getFile("create_snapshot.zip"),
-                        mApplySnapshot,
                         false,
                         false,
-                        false,
-                        SnapuserdWaitPhase.BLOCK_AFTER_UPDATE);
+                        SnapuserdWaitPhase.BLOCK_AFTER_UPDATE,
+                        null);
         try {
             updateUtil.updateDevice(null, null);
 
diff --git a/javatests/com/android/tradefed/testtype/DeviceJUnit4ClassRunnerTest.java b/javatests/com/android/tradefed/testtype/DeviceJUnit4ClassRunnerTest.java
index 2f9feefc3..7981956cc 100644
--- a/javatests/com/android/tradefed/testtype/DeviceJUnit4ClassRunnerTest.java
+++ b/javatests/com/android/tradefed/testtype/DeviceJUnit4ClassRunnerTest.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.testtype;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Mockito.doReturn;
@@ -39,9 +40,13 @@ import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.testtype.junit4.BeforeClassWithInfo;
+import com.android.tradefed.testtype.junit4.AfterClassWithInfo;
 
 import com.google.common.collect.ImmutableMap;
 
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -103,6 +108,40 @@ public class DeviceJUnit4ClassRunnerTest {
             assertNotNull(mOption);
             assertNotEquals(FAKE_REMOTE_FILE_PATH, mOption);
         }
+
+        public static int mBeforeClassRunCount;
+
+        @BeforeClass
+        public static void beforeClass() {
+            CLog.d("beforeClass");
+            mBeforeClassRunCount++;
+        }
+
+        public static int mBeforeClassWithInfoRunCount;
+
+        @BeforeClassWithInfo
+        public static void beforeClassWithInfo(TestInformation testInfo) {
+            CLog.d("beforeClassWithInfo");
+            mBeforeClassWithInfoRunCount++;
+            assertNotNull(testInfo);
+        }
+
+        public static int mAfterClassRunCount;
+
+        @AfterClass
+        public static void afterClass() {
+            CLog.d("afterClass");
+            mAfterClassRunCount++;
+        }
+
+        public static int mAfterClassWithInfoRunCount;
+
+        @AfterClassWithInfo
+        public static void afterClassWithInfo(TestInformation testInfo) {
+            CLog.d("afterClassWithInfo");
+            mAfterClassWithInfoRunCount++;
+            assertNotNull(testInfo);
+        }
     }
 
     @Mock ITestInvocationListener mListener;
@@ -136,5 +175,10 @@ public class DeviceJUnit4ClassRunnerTest {
         verify(mListener).testStarted(Mockito.eq(test1));
         verify(mListener).testEnded(Mockito.eq(test1), Mockito.<HashMap<String, Metric>>any());
         verify(mListener).testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+
+        assertEquals(1, Junit4TestClass.mBeforeClassRunCount);
+        assertEquals(1, Junit4TestClass.mBeforeClassWithInfoRunCount);
+        assertEquals(1, Junit4TestClass.mAfterClassRunCount);
+        assertEquals(1, Junit4TestClass.mAfterClassWithInfoRunCount);
     }
 }
diff --git a/javatests/com/android/tradefed/testtype/GTestFuncTest.java b/javatests/com/android/tradefed/testtype/GTestFuncTest.java
index 187ef82d3..db7d0c7c0 100644
--- a/javatests/com/android/tradefed/testtype/GTestFuncTest.java
+++ b/javatests/com/android/tradefed/testtype/GTestFuncTest.java
@@ -134,9 +134,9 @@ public class GTestFuncTest implements IDeviceTest {
         verify(mMockListener).testStarted(Mockito.eq(testId));
         verify(mMockListener).testFailed(Mockito.eq(testId), Mockito.isA(String.class));
         verify(mMockListener).testEnded(Mockito.eq(testId), Mockito.eq(emptyMap));
-        verify(mMockListener).testRunFailed(Mockito.<String>anyObject());
+        verify(mMockListener).testRunFailed(Mockito.<String>any());
         verify(mMockListener)
-                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>anyObject());
+                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
 
     /** Test run scenario where test process crashes while trying to access NULL ptr. */
diff --git a/javatests/com/android/tradefed/testtype/TfTestLauncherTest.java b/javatests/com/android/tradefed/testtype/TfTestLauncherTest.java
index b774db363..32c28e577 100644
--- a/javatests/com/android/tradefed/testtype/TfTestLauncherTest.java
+++ b/javatests/com/android/tradefed/testtype/TfTestLauncherTest.java
@@ -140,7 +140,7 @@ public class TfTestLauncherTest {
         when(mMockBuildInfo.getBuildId()).thenReturn(BUILD_ID);
 
         mTfTestLauncher.run(mTestInfo, mMockListener);
-        verify(mMockListener, times(4))
+        verify(mMockListener, times(3))
                 .testLog(
                         (String) Mockito.any(),
                         (LogDataType) Mockito.any(),
diff --git a/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java b/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
index a63500b0b..5ce7d713b 100644
--- a/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
@@ -136,8 +136,7 @@ public class KUnitModuleTestTest {
         setter.setOptionValue("ktap-result-parser-resolution", "AGGREGATED_SUITE");
 
         // For 2 modules: first rmmod call expect fail, second rmmod call expect pass
-        when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.RMMOD_COMMAND_FMT, ""))))
+        when(mMockDevice.executeShellV2Command(startsWith("rmmod")))
                 .thenReturn(mFailedResult)
                 .thenReturn(mSuccessResult)
                 .thenReturn(mFailedResult)
@@ -150,10 +149,7 @@ public class KUnitModuleTestTest {
                 .thenReturn(new String[0]) // module 2, call 1
                 .thenReturn(new String[] {MODULE_NAME_02}); // module 2, call 2
 
-        when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, "")),
-                        anyLong(),
-                        any()))
+        when(mMockDevice.executeShellV2Command(startsWith("insmod"), anyLong(), any()))
                 .thenReturn(mSuccessResult);
 
         when(mMockDevice.pullFileContents(
@@ -197,15 +193,11 @@ public class KUnitModuleTestTest {
 
         // First module loads successfully
         when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_01_KO)),
-                        anyLong(),
-                        any()))
+                        startsWith(String.format("insmod %s", MODULE_01_KO)), anyLong(), any()))
                 .thenReturn(mSuccessResult);
         // Second module set fail on load
         when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_02_KO)),
-                        anyLong(),
-                        any()))
+                        startsWith(String.format("insmod %s", MODULE_02_KO)), anyLong(), any()))
                 .thenReturn(mFailedResult);
 
         // Run test
diff --git a/javatests/com/android/tradefed/testtype/junit4/DeviceParameterizedRunnerTest.java b/javatests/com/android/tradefed/testtype/junit4/DeviceParameterizedRunnerTest.java
index c118fea44..7ec506d3f 100644
--- a/javatests/com/android/tradefed/testtype/junit4/DeviceParameterizedRunnerTest.java
+++ b/javatests/com/android/tradefed/testtype/junit4/DeviceParameterizedRunnerTest.java
@@ -30,8 +30,12 @@ import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.testtype.HostTest;
+import com.android.tradefed.testtype.junit4.BeforeClassWithInfo;
+import com.android.tradefed.testtype.junit4.AfterClassWithInfo;
 
+import org.junit.AfterClass;
 import org.junit.Before;
+import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -100,6 +104,45 @@ public class DeviceParameterizedRunnerTest {
         }
     }
 
+    @RunWith(DeviceParameterizedRunner.class)
+    public static class TestJUnitParamsClassWithClassMethods extends BaseHostJUnit4Test {
+        public static int mBeforeClassRunCount;
+
+        @BeforeClass
+        public static void beforeClass() {
+            mBeforeClassRunCount++;
+        }
+
+        public static int mBeforeClassWithInfoRunCount;
+
+        @BeforeClassWithInfo
+        public static void beforeClassWithInfo(TestInformation testInfo) {
+            mBeforeClassWithInfoRunCount++;
+            assertNotNull(testInfo);
+        }
+
+        public static int mAfterClassRunCount;
+
+        @AfterClass
+        public static void afterClass() {
+            mAfterClassRunCount++;
+        }
+
+        public static int mAfterClassWithInfoRunCount;
+
+        @AfterClassWithInfo
+        public static void afterClassWithInfo(TestInformation testInfo) {
+            mAfterClassWithInfoRunCount++;
+            assertNotNull(testInfo);
+        }
+
+        @Test
+        public void testEmpty() {}
+
+        @Test
+        public void testEmpty2() {}
+    }
+
     private HostTest mTest;
     @Mock ITestDevice mDevice;
     @Mock IBuildInfo mBuild;
@@ -262,4 +305,18 @@ public class DeviceParameterizedRunnerTest {
         verify(mListener).testEnded(test2_p1, new HashMap<String, Metric>());
         verify(mListener).testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
+
+    /** Test running before/after class methods. */
+    @Test
+    public void testRunClassMethods() throws Exception {
+        OptionSetter setter = new OptionSetter(mTest);
+        setter.setOptionValue("class", TestJUnitParamsClassWithClassMethods.class.getName());
+
+        mTest.run(mTestInfo, mListener);
+
+        assertEquals(1, TestJUnitParamsClassWithClassMethods.mBeforeClassRunCount);
+        assertEquals(1, TestJUnitParamsClassWithClassMethods.mBeforeClassWithInfoRunCount);
+        assertEquals(1, TestJUnitParamsClassWithClassMethods.mAfterClassRunCount);
+        assertEquals(1, TestJUnitParamsClassWithClassMethods.mAfterClassWithInfoRunCount);
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java b/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
index 01ffb0c41..ad3865ecc 100644
--- a/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
+++ b/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
@@ -46,6 +46,7 @@ import org.mockito.Mockito;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -58,7 +59,6 @@ public class MoblyYamlResultParserTest {
     private static final String DEFAULT_END_TIME = "1571681520407";
     private static final String DEFAULT_TEST_CLASS = "DefaultTestClass";
     private static final String DEFAULT_TEST_NAME = "test_default_name";
-    private static final String TEST_ERROR_YAML = "/testtype/test_summary_error.yaml";
     private static final String SAMPLE_STACK_TRACE =
             "\"Traceback (most recent call last):\\n"
                 + "  File"
@@ -168,7 +168,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersPassRecord() {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         IMoblyYamlResultHandler.ITestResult passRecord =
                 new Record.Builder()
                         .setTestName(DEFAULT_TEST_NAME)
@@ -191,7 +191,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersFailRecord() {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         IMoblyYamlResultHandler.ITestResult failRecord =
                 new Record.Builder()
                         .setTestName(DEFAULT_TEST_NAME)
@@ -226,7 +226,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersUserData() {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         List<IMoblyYamlResultHandler.ITestResult> resultCache =
                 ImmutableList.of(new UserData.Builder().setTimestamp(DEFAULT_BEGIN_TIME).build());
         mParser.reportToListeners(mListeners, resultCache);
@@ -237,7 +237,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersControllerInfo() {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         List<IMoblyYamlResultHandler.ITestResult> resultCache =
                 ImmutableList.of(
                         new ControllerInfo.Builder().setTimestamp("1571681322.791003").build());
@@ -249,7 +249,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapRecordPass() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> detailMap = new HashMap<>();
         detailMap.put("Result", "PASS");
         detailMap.put("Stacktrace", "null");
@@ -265,7 +265,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapRecordFail() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> detailMap = new HashMap<>();
         detailMap.put("Stacktrace", SAMPLE_STACK_TRACE);
         detailMap.put("Result", "FAIL");
@@ -282,7 +282,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapSummary() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "Summary");
         docMap.put("Executed", "10");
@@ -295,7 +295,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapControllerInfo() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "ControllerInfo");
         docMap.put("Timestamp", "1571681322.791003");
@@ -307,7 +307,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapUserData() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "UserData");
         docMap.put("timestamp", DEFAULT_BEGIN_TIME);
@@ -318,16 +318,17 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapTestNameList() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "TestNameList");
+        docMap.put("Requested Tests", Arrays.asList("test1", "test2"));
         IMoblyYamlResultHandler.ITestResult result = mParser.parseDocumentMap(docMap);
         assertTrue(result instanceof MoblyYamlResultTestNameListHandler.TestNameList);
     }
 
     @Test
     public void testParse() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
         MoblyYamlResultParser spyParser = Mockito.spy(mParser);
 
         String passRecord = buildTestRecordString(new HashMap<>());
diff --git a/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java b/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java
index 9e14aa50d..871ff59db 100644
--- a/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java
+++ b/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java
@@ -25,6 +25,7 @@ import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.util.FileUtil;
 
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,7 +42,7 @@ public class PtsBotTestTest {
     private ITestDevice mMockDevice;
     private TestInformation mTestInfo;
     private File mPandoraTestDir;
-    private File mConfigFlagsFile;
+    private File mConfigFile;
 
     @Before
     public void setup() throws Exception {
@@ -50,8 +51,7 @@ public class PtsBotTestTest {
         IInvocationContext context = new InvocationContext();
         context.addAllocatedDevice("device", mMockDevice);
         mPandoraTestDir = FileUtil.createTempDir("pandora_tests");
-        mConfigFlagsFile =
-                FileUtil.createTempFile("pts_bot_tests_config", ".json", mPandoraTestDir);
+        mConfigFile = FileUtil.createTempFile("pts_bot_tests_config", ".json", mPandoraTestDir);
     }
 
     @After
@@ -65,9 +65,9 @@ public class PtsBotTestTest {
         String jsonString =
                 String.format(
                         "{\"flags\":[{\"flags\":[\"%s\"],\"tests\":[\"test1\",\"test2\"]}]}", flag);
-        FileUtil.writeToFile(jsonString, mConfigFlagsFile);
+        FileUtil.writeToFile(jsonString, mConfigFile);
 
-        mSpyTest.initFlagsConfig(mMockDevice, mConfigFlagsFile);
+        mSpyTest.initFlagsConfig(mMockDevice, mConfigFile);
         PtsBotTest.TestFlagConfiguration config = mSpyTest.getTestFlagConfiguration();
 
         assertThat(config.flags).isNotEmpty();
@@ -80,10 +80,42 @@ public class PtsBotTestTest {
     @Test
     public void testParse_emptyConfigFlagsFile() throws Exception {
         String json_string = String.format("{\"flags\": []}");
-        FileUtil.writeToFile(json_string, mConfigFlagsFile);
+        FileUtil.writeToFile(json_string, mConfigFile);
 
-        mSpyTest.initFlagsConfig(mMockDevice, mConfigFlagsFile);
+        mSpyTest.initFlagsConfig(mMockDevice, mConfigFile);
 
         assertThat(mSpyTest.getTestFlagConfiguration().flags).isEmpty();
     }
+
+    @Test
+    public void testParse_configSystemPropertiesFile() throws Exception {
+        String jsonString =
+                String.format(
+                        "{\"system_properties\":[{\"system_properties\":"
+                            + " {\"prop1\":\"true\",\"prop2\":\"false\",\"prop3\":null},\"tests\":[\"test1\",\"test2\"]}]}");
+
+        FileUtil.writeToFile(jsonString, mConfigFile);
+
+        mSpyTest.initSystemPropertiesConfig(mConfigFile);
+        PtsBotTest.TestSyspropConfiguration config = mSpyTest.getSyspropConfiguration();
+
+        assertThat(config.system_properties).isNotEmpty();
+        Assert.assertEquals(config.system_properties.get(0).system_properties.get("prop1"), "true");
+        Assert.assertEquals(
+                config.system_properties.get(0).system_properties.get("prop2"), "false");
+        Assert.assertEquals(config.system_properties.get(0).system_properties.get("prop3"), null);
+        assertThat(config.system_properties.get(0).tests).containsExactly("test1", "test2");
+
+        mSpyTest.getSyspropConfiguration().system_properties.clear();
+    }
+
+    @Test
+    public void testParse_emptyConfigSystemPropertiesFile() throws Exception {
+        String json_string = String.format("{\"system_properties\": []}");
+        FileUtil.writeToFile(json_string, mConfigFile);
+
+        mSpyTest.initSystemPropertiesConfig(mConfigFile);
+
+        assertThat(mSpyTest.getSyspropConfiguration().system_properties).isEmpty();
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/rust/RustBinaryTestTest.java b/javatests/com/android/tradefed/testtype/rust/RustBinaryTestTest.java
index 94a3c8514..71773eaf1 100644
--- a/javatests/com/android/tradefed/testtype/rust/RustBinaryTestTest.java
+++ b/javatests/com/android/tradefed/testtype/rust/RustBinaryTestTest.java
@@ -333,7 +333,7 @@ public class RustBinaryTestTest {
     @Test
     public void testGcovCoverage_GcovPrefixSet() throws Exception {
         mCoverageOptionsSetter.setOptionValue("coverage", "true");
-        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "GCOV");
+        mCoverageOptionsSetter.setOptionValue("coverage-toolchain", "CLANG");
 
         final String testPath = RustBinaryTest.DEFAULT_TEST_PATH;
         final String test1 = "test1";
@@ -350,7 +350,7 @@ public class RustBinaryTestTest {
 
         mockCountTests(testPath1, runListOutput(3));
         mockTestRunStarted("test1", 3);
-        mockShellCommand("GCOV_PREFIX=/data/misc/trace");
+        mockShellCommand("LLVM_PROFILE_FILE=/data/local/tmp/clang-%m.profraw ");
         mockTestRunEnded();
         callReplayRunVerify();
     }
diff --git a/javatests/com/android/tradefed/testtype/suite/AtestRunnerTest.java b/javatests/com/android/tradefed/testtype/suite/AtestRunnerTest.java
index a1d18f60a..d003413d8 100644
--- a/javatests/com/android/tradefed/testtype/suite/AtestRunnerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/AtestRunnerTest.java
@@ -27,6 +27,7 @@ import static org.mockito.Mockito.verify;
 
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IDeviceConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
@@ -79,6 +80,8 @@ public class AtestRunnerTest {
     private AbiAtestRunner mRunner;
     private OptionSetter setter;
     private IConfiguration mConfig;
+    private IDeviceConfiguration mDeviceConfig;
+    private IDeviceConfiguration mDeviceConfig2;
     private IDeviceBuildInfo mBuildInfo;
     private ITestDevice mMockDevice;
     private String classA = "fully.qualified.classA";
@@ -106,6 +109,7 @@ public class AtestRunnerTest {
         mRunner.setBuild(mBuildInfo);
         mRunner.setDevice(mMockDevice);
         mConfig = mock(IConfiguration.class);
+        mDeviceConfig = mock(IDeviceConfiguration.class);
 
         when(mBuildInfo.getTestsDir()).thenReturn(mTempFolder.newFolder());
 
@@ -305,8 +309,18 @@ public class AtestRunnerTest {
         List<ITargetPreparer> targetPreparers = new ArrayList<>();
         PseudoTargetPreparer preparer = spy(new PseudoTargetPreparer());
         targetPreparers.add(preparer);
+        List<ITargetPreparer> targetPreparers2 = new ArrayList<>();
+        PseudoTargetPreparer preparer2 = spy(new PseudoTargetPreparer());
+        targetPreparers2.add(preparer2);
+        List<IDeviceConfiguration> deviceConfigs = new ArrayList<>();
+        IDeviceConfiguration deviceConfig = mock(IDeviceConfiguration.class);
+        when(deviceConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        deviceConfigs.add(deviceConfig);
+        when(mDeviceConfig.getTargetPreparers()).thenReturn(targetPreparers2);
+        deviceConfigs.add(mDeviceConfig);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
         when(mConfig.getName()).thenReturn("custom-configuration");
-        when(mConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
 
         LinkedHashMap<String, IConfiguration> pseudoConfigMap = new LinkedHashMap<>();
         pseudoConfigMap.put("pseudo-config", mConfig);
@@ -332,8 +346,18 @@ public class AtestRunnerTest {
         List<ITargetPreparer> targetPreparers = new ArrayList<>();
         PseudoTargetPreparer preparer = spy(new PseudoTargetPreparer());
         targetPreparers.add(preparer);
+        List<ITargetPreparer> targetPreparers2 = new ArrayList<>();
+        PseudoTargetPreparer preparer2 = spy(new PseudoTargetPreparer());
+        targetPreparers2.add(preparer2);
+        List<IDeviceConfiguration> deviceConfigs = new ArrayList<>();
+        IDeviceConfiguration deviceConfig = mock(IDeviceConfiguration.class);
+        when(deviceConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        deviceConfigs.add(deviceConfig);
+        when(mDeviceConfig.getTargetPreparers()).thenReturn(targetPreparers2);
+        deviceConfigs.add(mDeviceConfig);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
         when(mConfig.getName()).thenReturn("custom-configuration");
-        when(mConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
 
         LinkedHashMap<String, IConfiguration> pseudoConfigMap = new LinkedHashMap<>();
         pseudoConfigMap.put("pseudo-config", mConfig);
@@ -359,8 +383,18 @@ public class AtestRunnerTest {
         List<ITargetPreparer> targetPreparers = new ArrayList<>();
         PseudoTargetPreparer preparer = spy(new PseudoTargetPreparer());
         targetPreparers.add(preparer);
+        List<ITargetPreparer> targetPreparers2 = new ArrayList<>();
+        PseudoTargetPreparer preparer2 = spy(new PseudoTargetPreparer());
+        targetPreparers2.add(preparer2);
+        List<IDeviceConfiguration> deviceConfigs = new ArrayList<>();
+        IDeviceConfiguration deviceConfig = mock(IDeviceConfiguration.class);
+        when(deviceConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        deviceConfigs.add(deviceConfig);
+        when(mDeviceConfig.getTargetPreparers()).thenReturn(targetPreparers2);
+        deviceConfigs.add(mDeviceConfig);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
         when(mConfig.getName()).thenReturn("custom-configuration");
-        when(mConfig.getTargetPreparers()).thenReturn(targetPreparers);
+        when(mConfig.getDeviceConfig()).thenReturn(deviceConfigs);
 
         LinkedHashMap<String, IConfiguration> pseudoConfigMap = new LinkedHashMap<>();
         pseudoConfigMap.put("pseudo-config", mConfig);
diff --git a/javatests/com/android/tradefed/testtype/suite/GranularRetriableTestWrapperTest.java b/javatests/com/android/tradefed/testtype/suite/GranularRetriableTestWrapperTest.java
index 05cd6a489..78d4d29dc 100644
--- a/javatests/com/android/tradefed/testtype/suite/GranularRetriableTestWrapperTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/GranularRetriableTestWrapperTest.java
@@ -26,7 +26,6 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.ddmlib.IDevice;
-import com.android.ddmlib.testrunner.TestResult.TestStatus;
 import com.android.tradefed.command.CommandOptions;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationDescriptor;
@@ -51,7 +50,9 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestResult;
 import com.android.tradefed.result.TestRunResult;
+import com.android.tradefed.result.TestStatus;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.retry.BaseRetryDecision;
 import com.android.tradefed.retry.IRetryDecision;
 import com.android.tradefed.retry.RetryStatistics;
@@ -59,6 +60,8 @@ import com.android.tradefed.testtype.IDeviceTest;
 import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.ITestFilterReceiver;
 
+import com.google.common.truth.Truth;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -91,6 +94,8 @@ public class GranularRetriableTestWrapperTest {
         protected ArrayList<TestDescription> mTestCases;
         protected Map<TestDescription, Integer> mBecomePass = new HashMap<>();
         protected Map<TestDescription, Boolean> mShouldFail;
+        private Map<TestDescription, Set<Integer>> mSkippedAttempts = new HashMap<>();
+        private Map<Integer, String> mRunFailureAttempts = new HashMap<>();
         private String mRunFailure = null;
         private Integer mClearRunFailureAttempt = null;
         protected int mAttempts = 0;
@@ -120,6 +125,15 @@ public class GranularRetriableTestWrapperTest {
             mBecomePass.put(testCase, attempt);
         }
 
+        public void addSkippedTestCase(TestDescription testCase, int attempt) {
+            mSkippedAttempts.putIfAbsent(testCase, new HashSet<>());
+            mSkippedAttempts.get(testCase).add(attempt);
+        }
+
+        public void addRunFailure(String message, int attempt) {
+            mRunFailureAttempts.put(attempt, message);
+        }
+
         public void setRunFailure(String message) {
             mRunFailure = message;
         }
@@ -132,25 +146,31 @@ public class GranularRetriableTestWrapperTest {
             return true;
         }
 
+        protected void runTest(TestDescription td, ITestInvocationListener listener) throws DeviceUnresponsiveException {
+            listener.testStarted(td);
+            int passAttempt = -1;
+            if (mBecomePass.get(td) != null) {
+                passAttempt = mBecomePass.get(td);
+            }
+            Set<Integer> skippedAttempts = mSkippedAttempts.get(td);
+            if (skippedAttempts != null && skippedAttempts.contains(mAttempts)) {
+                listener.testSkipped(td, new SkipReason("reason", "reason"));
+            } else if (mShouldFail.get(td)) {
+                if (passAttempt == -1 || mAttempts < passAttempt) {
+                    listener.testFailed(td, String.format("Fake failure %s", td.toString()));
+                }
+            }
+            listener.testEnded(td, new HashMap<String, Metric>());
+        }
+
         @Override
         public void run(TestInformation testInfo, ITestInvocationListener listener)
                 throws DeviceUnresponsiveException {
             listener.testRunStarted(RUN_NAME, mTestCases.size());
             for (TestDescription td : mTestCases) {
-                if (!shouldRun(td)) {
-                    continue;
-                }
-                listener.testStarted(td);
-                int passAttempt = -1;
-                if (mBecomePass.get(td) != null) {
-                    passAttempt = mBecomePass.get(td);
+                if (shouldRun(td)) {
+                    runTest(td, listener);
                 }
-                if (mShouldFail.get(td)) {
-                    if (passAttempt == -1 || mAttempts < passAttempt) {
-                        listener.testFailed(td, String.format("Fake failure %s", td.toString()));
-                    }
-                }
-                listener.testEnded(td, new HashMap<String, Metric>());
             }
             if (mRunFailure != null) {
                 listener.testRunFailed(mRunFailure);
@@ -158,6 +178,10 @@ public class GranularRetriableTestWrapperTest {
                     mRunFailure = null;
                 }
             }
+            if (mRunFailureAttempts.containsKey(mAttempts)) {
+                listener.testRunFailed(mRunFailureAttempts.get(mAttempts));
+            }
+
             listener.testRunEnded(100000, new HashMap<String, Metric>());
             mAttempts++;
         }
@@ -276,18 +300,7 @@ public class GranularRetriableTestWrapperTest {
                         continue;
                     }
                     listener.testRunStarted(runName, testCases.size());
-                    listener.testStarted(td);
-                    int passAttempt = -1;
-                    if (mBecomePass.get(td) != null) {
-                        passAttempt = mBecomePass.get(td);
-                    }
-                    if (mShouldFail.get(td)) {
-                        if (passAttempt == -1 || mAttempts < passAttempt) {
-                            listener.testFailed(
-                                    td, String.format("Fake failure %s", td.toString()));
-                        }
-                    }
-                    listener.testEnded(td, new HashMap<String, Metric>());
+                    runTest(td, listener);
                     listener.testRunEnded(0, new HashMap<String, Metric>());
                 }
             }
@@ -312,7 +325,7 @@ public class GranularRetriableTestWrapperTest {
             ModuleDefinition module)
             throws Exception {
         GranularRetriableTestWrapper granularTestWrapper =
-                new GranularRetriableTestWrapper(test, module, null, null, maxRunCount);
+                new GranularRetriableTestWrapper(test, module, null, maxRunCount);
         granularTestWrapper.setModuleId("test module");
         granularTestWrapper.setMarkTestsSkipped(false);
         granularTestWrapper.setMetricCollectors(collectors);
@@ -332,6 +345,14 @@ public class GranularRetriableTestWrapperTest {
         return granularTestWrapper;
     }
 
+    /** Asserts that the test result has the given status. */
+    private void assertTestStatus(
+            Map<TestDescription, TestResult> testResults,
+            TestDescription test,
+            TestStatus status) {
+        Truth.assertThat(testResults.get(test).getResultStatus()).isEqualTo(status);
+    }
+
     @Before
     public void setUp() {
         mModuleInvocationContext = new InvocationContext();
@@ -388,6 +409,70 @@ public class GranularRetriableTestWrapperTest {
         assertTrue(attempResults.isRunFailure());
     }
 
+    @Test
+    public void testIntraModuleRun_simple_emptyModuleRetry() throws Exception {
+        // Set up the test cases.
+        var testCases = new ArrayList<TestDescription>();
+        TestDescription fakeTestCase = new TestDescription("Class", "Test");
+        TestDescription fakeTestCase2 = new TestDescription("Class", "Test2");
+        testCases.add(fakeTestCase);
+        testCases.add(fakeTestCase2);
+        FakeTest test = new FakeTest(testCases);
+        test.addFailedTestCase(fakeTestCase);
+        test.addFailedTestCase(fakeTestCase2);
+        test.addTestBecomePass(fakeTestCase, 1);
+        test.addTestBecomePass(fakeTestCase2, 1);
+        test.setRunFailure("always crash");
+
+        // Create the test wrapper.
+        var granularTestWrapper = createGranularTestWrapper(test, 4);
+
+        // Run the test.
+        granularTestWrapper.run(mModuleInfo, new CollectingTestListener());
+
+        // Verify the first attempt.
+        var allTestResults = granularTestWrapper.getTestRunResultCollected().get(RUN_NAME);
+        var testResults = allTestResults.get(0).getTestResults();
+        Truth.assertThat(testResults.keySet()).containsExactly(fakeTestCase, fakeTestCase2);
+        assertTestStatus(testResults, fakeTestCase, TestStatus.FAILURE);
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.FAILURE);
+        Truth.assertThat(allTestResults.get(0).isRunFailure()).isTrue();
+
+        // Verify the second attempt.
+        testResults = allTestResults.get(1).getTestResults();
+        Truth.assertThat(testResults.keySet()).containsExactly(fakeTestCase, fakeTestCase2);
+        assertTestStatus(testResults, fakeTestCase, TestStatus.PASSED);
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.PASSED);
+        Truth.assertThat(allTestResults.get(1).isRunFailure()).isTrue();
+
+        // Verify the third attempt.
+        testResults = allTestResults.get(2).getTestResults();
+        Truth.assertThat(testResults.keySet()).isEmpty();
+        Truth.assertThat(allTestResults.get(2).isRunFailure()).isTrue();
+
+        // Verify the fourth attempt.
+        testResults = allTestResults.get(3).getTestResults();
+        Truth.assertThat(testResults.keySet()).isEmpty();
+        Truth.assertThat(allTestResults.get(3).isRunFailure()).isTrue();
+
+        // Verify no more retries.
+        Truth.assertThat(allTestResults).hasSize(4);
+
+        // Verify merging.
+        var finalTestResults = granularTestWrapper.getFinalTestRunResults();
+        Truth.assertThat(finalTestResults).hasSize(1);
+        testResults = finalTestResults.get(0).getTestResults();
+        Truth.assertThat(testResults.keySet()).containsExactly(fakeTestCase, fakeTestCase2);
+        assertTestStatus(testResults, fakeTestCase, TestStatus.PASSED);
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.PASSED);
+        Truth.assertThat(finalTestResults.get(0).isRunFailure()).isTrue();
+
+        // Verify correct retry statistics. Both tests recovered.
+        RetryStatistics stats = mDecision.getRetryStatistics();
+        Truth.assertThat(stats.mRetryFailure).isEqualTo(0);
+        Truth.assertThat(stats.mRetrySuccess).isEqualTo(2);
+    }
+
     /**
      * Test that the "run" method has built-in retry logic and each run has an individual
      * ModuleListener and TestRunResult.
@@ -420,9 +505,9 @@ public class GranularRetriableTestWrapperTest {
         assertTrue(testResults.containsKey(fakeTestCase2));
         assertTrue(testResults.containsKey(fakeTestCase3));
         // Verify the final TestRunResult is a merged value of every retried TestRunResults.
-        assertEquals(TestStatus.FAILURE, testResults.get(fakeTestCase).getStatus());
-        assertEquals(TestStatus.FAILURE, testResults.get(fakeTestCase2).getStatus());
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase3).getStatus());
+        assertTestStatus(testResults, fakeTestCase, TestStatus.FAILURE);
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.FAILURE);
+        assertTestStatus(testResults, fakeTestCase3, TestStatus.PASSED);
 
         // Ensure that the PASSED test was only run the first time.
         assertTrue(
@@ -479,9 +564,9 @@ public class GranularRetriableTestWrapperTest {
         assertTrue(testResults.containsKey(fakeTestCase2));
         assertTrue(testResults.containsKey(fakeTestCase3));
         // Verify the final TestRunResult is a merged value of every retried TestRunResults.
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase).getStatus()); // became pass
-        assertEquals(TestStatus.FAILURE, testResults.get(fakeTestCase2).getStatus());
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase3).getStatus());
+        assertTestStatus(testResults, fakeTestCase, TestStatus.PASSED); // became pass
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.FAILURE);
+        assertTestStatus(testResults, fakeTestCase3, TestStatus.PASSED);
 
         // Ensure that the PASSED test was only run the first time.
         assertTrue(
@@ -538,9 +623,9 @@ public class GranularRetriableTestWrapperTest {
         assertTrue(testResults.containsKey(fakeTestCase2));
         assertTrue(testResults.containsKey(fakeTestCase3));
         // Verify the final TestRunResult is a merged value of every retried TestRunResults.
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase).getStatus()); // became pass
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase2).getStatus());
-        assertEquals(TestStatus.PASSED, testResults.get(fakeTestCase3).getStatus());
+        assertTestStatus(testResults, fakeTestCase, TestStatus.PASSED); // became pass
+        assertTestStatus(testResults, fakeTestCase2, TestStatus.PASSED);
+        assertTestStatus(testResults, fakeTestCase3, TestStatus.PASSED);
 
         // Ensure that the PASSED test was only run the first time.
         assertTrue(
@@ -623,10 +708,8 @@ public class GranularRetriableTestWrapperTest {
         // Check that all test cases where rerun
         for (TestRunResult runResult : resultCollector) {
             assertEquals(2, runResult.getNumTests());
-            assertEquals(
-                    TestStatus.FAILURE, runResult.getTestResults().get(fakeTestCase1).getStatus());
-            assertEquals(
-                    TestStatus.PASSED, runResult.getTestResults().get(fakeTestCase2).getStatus());
+            assertTestStatus(runResult.getTestResults(), fakeTestCase1, TestStatus.FAILURE);
+            assertTestStatus(runResult.getTestResults(), fakeTestCase2, TestStatus.PASSED);
         }
     }
 
@@ -670,15 +753,17 @@ public class GranularRetriableTestWrapperTest {
         TestRunResult runResult2 = finalResult.get(1);
 
         // Verify the final result includes two completed test runs. The failed test in the 1st run
-        // passes after one retry, and the second test run retried maxRunCount times and stil has
+        // passes after one retry, and the second test run retried maxRunCount times and still has
         // failed test cases.
         assertEquals(RUN_NAME, runResult1.getName());
         assertEquals(RUN_NAME_2, runResult2.getName());
-        assertEquals(TestStatus.PASSED, runResult1.getTestResults().get(fakeTestCase1).getStatus());
-        assertEquals(TestStatus.PASSED, runResult1.getTestResults().get(fakeTestCase2).getStatus());
-        assertEquals(
-                TestStatus.FAILURE, runResult2.getTestResults().get(fakeTestCase3).getStatus());
-        assertEquals(TestStatus.PASSED, runResult2.getTestResults().get(fakeTestCase4).getStatus());
+        assertTestStatus(runResult1.getTestResults(), fakeTestCase1, TestStatus.PASSED);
+        assertTestStatus(runResult1.getTestResults(), fakeTestCase2, TestStatus.PASSED);
+        assertTestStatus(runResult2.getTestResults(), fakeTestCase3, TestStatus.FAILURE);
+        assertTestStatus(runResult2.getTestResults(), fakeTestCase4, TestStatus.PASSED);
+        RetryStatistics stats = mDecision.getRetryStatistics();
+        Truth.assertThat(stats.mRetryFailure).isEqualTo(1);
+        Truth.assertThat(stats.mRetrySuccess).isEqualTo(1);
     }
 
     /** Test the retry for Run level. */
diff --git a/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java b/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
index 0ed88c756..cd076b825 100644
--- a/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
@@ -19,6 +19,7 @@ import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -67,6 +68,7 @@ import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.LogSaverResultForwarder;
 import com.android.tradefed.result.MultiFailureDescription;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
@@ -485,13 +487,18 @@ public class ITestSuiteTest {
         StatusCheckerResult result = new StatusCheckerResult(CheckStatus.FAILED);
         result.setErrorMessage("some failures.");
         result.setBugreportNeeded(true);
+        LogSaverResultForwarder allListeners =
+                new LogSaverResultForwarder(
+                        mMockLogSaver, Arrays.asList(mMockListener), mStubMainConfiguration);
         when(mMockSysChecker.preExecutionCheck(Mockito.eq(mMockDevice))).thenReturn(result);
-        when(mMockDevice.logBugreport(Mockito.any(), Mockito.same(mMockListener))).thenReturn(true);
+        when(mMockDevice.logBugreport(Mockito.any(), Mockito.any(LogSaverResultForwarder.class)))
+                .thenReturn(true);
         when(mMockSysChecker.postExecutionCheck(Mockito.eq(mMockDevice))).thenReturn(result);
-        expectTestRun(mMockListener);
+        expectTestRun(allListeners);
 
-        mTestSuite.run(mTestInfo, mMockListener);
-        verify(mMockDevice, times(2)).logBugreport(Mockito.any(), Mockito.same(mMockListener));
+        mTestSuite.run(mTestInfo, allListeners);
+        verify(mMockDevice, times(2))
+                .logBugreport(Mockito.any(), Mockito.any(LogSaverResultForwarder.class));
     }
 
     /**
@@ -507,14 +514,19 @@ public class ITestSuiteTest {
 
         when(mMockSysChecker.preExecutionCheck(Mockito.eq(mMockDevice)))
                 .thenThrow(new RuntimeException("I failed."));
-        when(mMockDevice.logBugreport(Mockito.any(), Mockito.same(mMockListener))).thenReturn(true);
+        LogSaverResultForwarder allListeners =
+                new LogSaverResultForwarder(
+                        mMockLogSaver, Arrays.asList(mMockListener), mStubMainConfiguration);
+        when(mMockDevice.logBugreport(Mockito.any(), Mockito.any(LogSaverResultForwarder.class)))
+                .thenReturn(true);
 
         when(mMockSysChecker.postExecutionCheck(Mockito.eq(mMockDevice)))
                 .thenThrow(new RuntimeException("I failed post."));
-        expectTestRun(mMockListener);
+        expectTestRun(allListeners);
 
-        mTestSuite.run(mTestInfo, mMockListener);
-        verify(mMockDevice, times(2)).logBugreport(Mockito.any(), Mockito.same(mMockListener));
+        mTestSuite.run(mTestInfo, allListeners);
+        verify(mMockDevice, times(2))
+                .logBugreport(Mockito.any(), Mockito.any(LogSaverResultForwarder.class));
     }
 
     /**
@@ -571,17 +583,21 @@ public class ITestSuiteTest {
         mTestSuite.setSystemStatusChecker(sysChecker);
         when(mMockSysChecker.preExecutionCheck(Mockito.eq(mMockDevice)))
                 .thenReturn(new StatusCheckerResult(CheckStatus.SUCCESS));
-        when(mMockDevice.logBugreport(Mockito.any(), Mockito.same(mMockListener))).thenReturn(true);
+        LogSaverResultForwarder allListeners =
+                new LogSaverResultForwarder(
+                        mMockLogSaver, Arrays.asList(mMockListener), mStubMainConfiguration);
+        when(mMockDevice.logBugreport(Mockito.any(), Mockito.any())).thenReturn(true);
 
         // No bugreport is captured if not explicitly requested
         StatusCheckerResult result = new StatusCheckerResult(CheckStatus.FAILED);
         result.setErrorMessage("some failures.");
         result.setBugreportNeeded(true);
         when(mMockSysChecker.postExecutionCheck(Mockito.eq(mMockDevice))).thenReturn(result);
-        expectTestRun(mMockListener);
+        expectTestRun(allListeners);
 
-        mTestSuite.run(mTestInfo, mMockListener);
-        verify(mMockDevice, times(1)).logBugreport(Mockito.any(), Mockito.same(mMockListener));
+        mTestSuite.run(mTestInfo, allListeners);
+        verify(mMockDevice, times(1))
+                .logBugreport(Mockito.any(), Mockito.any(LogSaverResultForwarder.class));
         verify(mMockListener)
                 .testRunStarted(
                         Mockito.eq(ITestSuite.MODULE_CHECKER_PRE + "_test"),
@@ -652,7 +668,7 @@ public class ITestSuiteTest {
         doReturn(decision)
                 .when(mMockDecision)
                 .shouldRetryPreparation(Mockito.any(), Mockito.anyInt(), Mockito.anyInt());
-        doReturn(2).when(mMockDecision).getMaxRetryCount();
+        doReturn(2).when(mMockDecision).getMaxTestRunAttempts(Mockito.any());
         when(mMockSysChecker.preExecutionCheck(Mockito.eq(mMockDevice)))
                 .thenReturn(new StatusCheckerResult(CheckStatus.SUCCESS));
         when(mMockSysChecker.postExecutionCheck(Mockito.eq(mMockDevice)))
@@ -1864,7 +1880,7 @@ public class ITestSuiteTest {
     public void testReportNotExecuted() {
         mTestSuite.reportNotExecuted(mMockListener, "Injected message");
 
-        verify(mMockListener).testModuleStarted(Mockito.any());
+        verify(mMockListener, times(1)).testModuleStarted(Mockito.any());
         verify(mMockListener)
                 .testRunStarted(
                         Mockito.eq(TEST_CONFIG_NAME),
@@ -1888,62 +1904,102 @@ public class ITestSuiteTest {
      * in progress.
      */
     @Test
-    public void testReportNotExecuted_moduleInProgress() {
-        ModuleDefinition m =
-                new ModuleDefinition(
-                        "in-progress",
-                        new ArrayList<>(),
-                        new HashMap<>(),
-                        new ArrayList<>(),
-                        new Configuration("", ""));
-        mTestSuite.setModuleInProgress(m);
-
-        FailureDescription error =
-                FailureDescription.create(
-                                "Module in-progress was interrupted after starting. Results might"
-                                        + " not be accurate or complete.")
-                        .setFailureStatus(FailureStatus.NOT_EXECUTED);
+    public void testReportNotExecuted_moduleInProgress() throws Exception {
+        List<ISystemStatusChecker> sysChecker = new ArrayList<>();
+        sysChecker.add(mMockSysChecker);
+        mTestSuite =
+                new TestSuiteImpl() {
+                    @Override
+                    public LinkedHashMap<String, IConfiguration> loadTests() {
+                        LinkedHashMap<String, IConfiguration> testConfig = new LinkedHashMap<>();
+                        try {
+                            IConfiguration moduleOne =
+                                    ConfigurationFactory.getInstance()
+                                            .createConfigurationFromArgs(
+                                                    new String[] {EMPTY_CONFIG});
+                            moduleOne.setTest(
+                                    new StubCollectingTest(
+                                            new DeviceNotAvailableException(
+                                                    "unavailable",
+                                                    "serial",
+                                                    DeviceErrorIdentifier.DEVICE_UNAVAILABLE)));
+                            testConfig.put("in-progress", moduleOne);
 
-        mTestSuite.reportNotExecuted(mMockListener, "Injected message");
+                            IConfiguration extraConfig =
+                                    ConfigurationFactory.getInstance()
+                                            .createConfigurationFromArgs(
+                                                    new String[] {EMPTY_CONFIG});
+                            extraConfig.setTest(new StubCollectingTest());
+                            testConfig.put("not-executed", extraConfig);
+                        } catch (ConfigurationException e) {
+                            CLog.e(e);
+                            throw new RuntimeException(e);
+                        }
+                        return testConfig;
+                    }
+                };
+        mTestSuite.setDevice(mMockDevice);
+        mTestSuite.setBuild(mMockBuildInfo);
+        mTestSuite.setInvocationContext(mContext);
+        mTestSuite.setSystemStatusChecker(sysChecker);
+        mTestSuite.setConfiguration(mStubMainConfiguration);
+        OptionSetter setter = new OptionSetter(mTestSuite);
+        setter.setOptionValue("skip-all-system-status-check", "true");
+        setter.setOptionValue("reboot-per-module", "true");
+        when(mMockDevice.getProperty("ro.build.type")).thenReturn("user");
+        when(mMockDevice.logBugreport(
+                        Mockito.eq("module-test-failure-SERIAL-bugreport"), Mockito.any()))
+                .thenReturn(true);
+        try {
+            mTestSuite.run(mTestInfo, mMockListener);
+            fail("Should have thrown an exception.");
+        } catch (DeviceNotAvailableException expected) {
+            assertEquals("unavailable", expected.getMessage());
+        }
 
         verify(mMockListener, times(2)).testModuleStarted(Mockito.any());
-        verify(mMockListener)
+        verify(mMockListener, times(1))
                 .testRunStarted(
-                        Mockito.eq("in-progress"), Mockito.eq(0), Mockito.eq(0), Mockito.anyLong());
+                        Mockito.eq("in-progress"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
         ArgumentCaptor<FailureDescription> captureRunFailure =
                 ArgumentCaptor.forClass(FailureDescription.class);
         verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
         verify(mMockListener, times(2))
                 .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener, times(2)).testModuleEnded();
-        verify(mMockListener)
+        verify(mMockListener, times(1))
                 .testRunStarted(
-                        Mockito.eq(TEST_CONFIG_NAME),
+                        Mockito.eq("not-executed"),
                         Mockito.eq(0),
                         Mockito.eq(0),
                         Mockito.anyLong());
-
         List<FailureDescription> failures = captureRunFailure.getAllValues();
+        assertTrue(failures.get(0).getErrorMessage().equals("unavailable"));
+        assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failures.get(0).getFailureStatus());
         assertTrue(
-                failures.get(0)
+                failures.get(1)
                         .getErrorMessage()
-                        .equals(
-                                "Module in-progress was interrupted after starting. Results might"
-                                        + " not be accurate or complete."));
-        assertEquals(FailureStatus.NOT_EXECUTED, failures.get(0).getFailureStatus());
-        assertTrue(failures.get(1).getErrorMessage().equals("Injected message"));
+                        .equals("Module did not run due to device not available."));
         assertEquals(FailureStatus.NOT_EXECUTED, failures.get(1).getFailureStatus());
     }
 
     public static class FakePostProcessor extends BasePostProcessor {
-        public static final String FAKE_KEY = "FAKE_KEY";
+        private final String mKey;
+
+        public FakePostProcessor() {
+            this(TEST_CONFIG_NAME);
+        }
+
+        public FakePostProcessor(String key) {
+            mKey = key;
+        }
 
         @Override
         public Map<String, Builder> processRunMetricsAndLogs(
                 HashMap<String, Metric> rawMetrics, Map<String, LogFile> runLogs) {
             Map<String, Builder> newMetrics = new HashMap<>();
             newMetrics.put(
-                    FAKE_KEY,
+                    mKey,
                     Metric.newBuilder()
                             .setType(DataType.RAW)
                             .setMeasurements(Measurements.newBuilder().setSingleString("")));
@@ -1954,33 +2010,41 @@ public class ITestSuiteTest {
     /** Test for module-level post-processor for perf module. */
     @Test
     public void testPostProcessorAddsMetricsForPerfModule() throws Exception {
+        final String secondTestConfigName = "test2";
+
         mTestSuite =
                 new TestSuiteImpl() {
                     @Override
                     public LinkedHashMap<String, IConfiguration> loadTests() {
                         LinkedHashMap<String, IConfiguration> testConfig = new LinkedHashMap<>();
                         try {
-                            IConfiguration config =
-                                    ConfigurationFactory.getInstance()
-                                            .createConfigurationFromArgs(
-                                                    new String[] {EMPTY_CONFIG});
-                            config.setTest(new StubCollectingTest());
-                            config.getConfigurationDescription().setModuleName(TEST_CONFIG_NAME);
-                            testConfig.put(TEST_CONFIG_NAME, config);
-
-                            // Mark module as perf module.
-                            config.getConfigurationDescription()
-                                    .addMetadata(
-                                            ITestSuite.TEST_TYPE_KEY,
-                                            ITestSuite.TEST_TYPE_VALUE_PERFORMANCE);
-                            // Add module-level post processor for perf module.
-                            config.setPostProcessors(Arrays.asList(new FakePostProcessor()));
+                            testConfig.put(TEST_CONFIG_NAME, createTestConfig(TEST_CONFIG_NAME));
+                            testConfig.put(
+                                    secondTestConfigName, createTestConfig(secondTestConfigName));
                         } catch (ConfigurationException e) {
                             CLog.e(e);
                             throw new RuntimeException(e);
                         }
                         return testConfig;
                     }
+
+                    private IConfiguration createTestConfig(String name)
+                            throws ConfigurationException {
+                        IConfiguration config =
+                                ConfigurationFactory.getInstance()
+                                        .createConfigurationFromArgs(new String[] {EMPTY_CONFIG});
+                        config.setTest(new StubCollectingTest());
+                        config.getConfigurationDescription().setModuleName(name);
+
+                        // Mark module as perf module.
+                        config.getConfigurationDescription()
+                                .addMetadata(
+                                        ITestSuite.TEST_TYPE_KEY,
+                                        ITestSuite.TEST_TYPE_VALUE_PERFORMANCE);
+                        // Add module-level post processor for perf module.
+                        config.setPostProcessors(Arrays.asList(new FakePostProcessor(name)));
+                        return config;
+                    }
                 };
         mTestSuite.setDevice(mMockDevice);
         mTestSuite.setBuild(mMockBuildInfo);
@@ -1996,9 +2060,10 @@ public class ITestSuiteTest {
 
         mTestSuite.run(mTestInfo, mMockListener);
 
-        // Verify the post processor has added metric.
+        // Verify only the post processor for the most recent module has added a metric.
         ArgumentCaptor<HashMap<String, Metric>> captured = ArgumentCaptor.forClass(HashMap.class);
-        verify(mMockListener).testRunEnded(Mockito.anyLong(), captured.capture());
-        assertNotNull(captured.getValue().get(FakePostProcessor.FAKE_KEY));
+        verify(mMockListener, times(2)).testRunEnded(Mockito.anyLong(), captured.capture());
+        assertNull(captured.getValue().get(TEST_CONFIG_NAME));
+        assertNotNull(captured.getValue().get(secondTestConfigName));
     }
 }
diff --git a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionMultiTest.java b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionMultiTest.java
index 280c0ebcd..34c90fa3a 100644
--- a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionMultiTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionMultiTest.java
@@ -126,7 +126,7 @@ public class ModuleDefinitionMultiTest {
         when(mMockTargetPrep.isDisabled()).thenReturn(false);
 
         when(mMockTargetPrep.isTearDownDisabled()).thenReturn(true);
-        mModule.run(moduleInfo, mListener, null, 1);
+        mModule.run(moduleInfo, mListener, 1);
         verify(mMockTargetPrep, times(2)).isDisabled();
         verify(mListener)
                 .testRunStarted(
@@ -167,7 +167,7 @@ public class ModuleDefinitionMultiTest {
         when(mMockTargetPrep.isDisabled()).thenReturn(false);
 
         when(mMockTargetPrep.isTearDownDisabled()).thenReturn(true);
-        mModule.run(moduleInfo, mListener, null, 1);
+        mModule.run(moduleInfo, mListener, 1);
         verify(mMockTargetPrep, times(2)).isDisabled();
         verify(mListener)
                 .testRunStarted(
diff --git a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
index 1a8e7283a..0efa1277e 100644
--- a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
@@ -59,6 +59,7 @@ import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.LogFile;
 import com.android.tradefed.result.LogSaverResultForwarder;
 import com.android.tradefed.result.MultiFailureDescription;
+import com.android.tradefed.result.ResultAndLogForwarder;
 import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestRunResult;
@@ -534,9 +535,6 @@ public class ModuleDefinitionTest {
         CollectingTestListener errorChecker = new CollectingTestListener();
         // DeviceUnresponsive should not throw since it indicates that the device was recovered.
         mModule.run(mModuleInfo, new ResultForwarder(mMockListener, errorChecker));
-        // Only one module
-        assertEquals(1, mModule.getTestsResults().size());
-        assertEquals(0, mModule.getTestsResults().get(0).getNumCompleteTests());
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockListener)
@@ -810,7 +808,8 @@ public class ModuleDefinitionTest {
                         .setInvocationContext(mModule.getModuleInvocationContext())
                         .build();
         mModule.setRetryDecision(mDecision);
-        mModule.run(mModuleInfo, mMockListener, Arrays.asList(mockModuleListener));
+
+        mModule.run(mModuleInfo, new ResultAndLogForwarder(mMockListener, mockModuleListener));
         verify(mMockListener)
                 .testRunStarted(
                         Mockito.eq(MODULE_NAME), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
@@ -978,7 +977,7 @@ public class ModuleDefinitionTest {
                 .shouldRetryPreparation(Mockito.any(), Mockito.anyInt(), Mockito.anyInt());
         when(mMockDecision.getRetryStrategy()).thenReturn(RetryStrategy.ITERATIONS);
         mModule.setRetryDecision(mMockDecision);
-        mModule.run(mModuleInfo, mMockListener, null, 3);
+        mModule.run(mModuleInfo, mMockListener, 3);
         verify(mMockListener)
                 .testRunStarted(
                         Mockito.eq(MODULE_NAME), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
@@ -1089,9 +1088,6 @@ public class ModuleDefinitionTest {
         } catch (DeviceNotAvailableException expected) {
             // expected
         }
-        // Only one module
-        assertEquals(1, mModule.getTestsResults().size());
-        assertEquals(2, mModule.getTestsResults().get(0).getNumCompleteTests());
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockPrep)
@@ -1144,11 +1140,6 @@ public class ModuleDefinitionTest {
         when(mMockPrep.isTearDownDisabled()).thenReturn(false);
 
         mModule.run(mModuleInfo, mMockListener);
-        // Only one module
-        assertEquals(1, mModule.getTestsResults().size());
-        assertEquals(2, mModule.getTestsResults().get(0).getNumCompleteTests());
-        assertTrue(
-                mModule.getTestsResults().get(0).getRunFailureMessage().contains("assert error"));
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockPrep).tearDown(Mockito.eq(mModuleInfo), Mockito.isNull());
@@ -1166,7 +1157,11 @@ public class ModuleDefinitionTest {
                         Mockito.anyLong(),
                         Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener).testFailed(Mockito.any(), (FailureDescription) Mockito.any());
-        verify(mMockListener).testRunFailed((FailureDescription) Mockito.any());
+        ArgumentCaptor<FailureDescription> captureRunFailure =
+                ArgumentCaptor.forClass(FailureDescription.class);
+        verify(mMockListener).testRunFailed(captureRunFailure.capture());
+        FailureDescription failure = captureRunFailure.getValue();
+        assertTrue(failure.getErrorMessage().contains("assert error"));
         verify(mMockListener)
                 .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
@@ -1250,7 +1245,7 @@ public class ModuleDefinitionTest {
                         .setInvocationContext(mModule.getModuleInvocationContext())
                         .build();
         // module is completely skipped, no tests is recorded.
-        mModule.run(mModuleInfo, mMockListener, null);
+        mModule.run(mModuleInfo, mMockListener);
     }
 
     /**
@@ -1302,7 +1297,7 @@ public class ModuleDefinitionTest {
                         .build();
 
         // expect the module to run but tests to be ignored
-        mModule.run(mModuleInfo, mMockListener, null);
+        mModule.run(mModuleInfo, mMockListener);
         verify(mMockListener)
                 .testRunStarted(Mockito.any(), Mockito.anyInt(), Mockito.eq(0), Mockito.anyLong());
         verify(mMockListener).testStarted(Mockito.any(), Mockito.anyLong());
@@ -1382,9 +1377,13 @@ public class ModuleDefinitionTest {
                 .thenReturn(loggedFile);
 
         // Simulate how the invoker actually put the log saver
-        LogSaverResultForwarder forwarder =
+        // logSaver wrapped at the invocation level
+        LogSaverResultForwarder logSaverResultForwarder =
                 new LogSaverResultForwarder(
                         mMockLogSaver, Arrays.asList(mMockLogSaverListener), moduleConfig);
+        // invocation level logSaver removed at the module level
+        List<ITestInvocationListener> listeners = logSaverResultForwarder.getListeners();
+        ResultAndLogForwarder forwarder = new ResultAndLogForwarder(listeners);
         mModule.run(mModuleInfo, forwarder);
         InOrder inOrder = Mockito.inOrder(mMockLogSaverListener);
         inOrder.verify(mMockLogSaverListener).setLogSaver(mMockLogSaver);
@@ -1459,9 +1458,6 @@ public class ModuleDefinitionTest {
 
         // DeviceUnresponsive should not throw since it indicates that the device was recovered.
         mModule.run(mModuleInfo, mMockListener);
-        // Only one module
-        assertEquals(1, mModule.getTestsResults().size());
-        assertEquals(0, mModule.getTestsResults().get(0).getNumCompleteTests());
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockPrep).tearDown(Mockito.eq(mModuleInfo), Mockito.isNull());
@@ -1489,8 +1485,8 @@ public class ModuleDefinitionTest {
     }
 
     /**
-     * Test that when a module level listener is specified it receives the events before the
-     * buffering and replay.
+     * Test that when a module level listener is specified it receives the events with buffering and
+     * replay.
      */
     @Test
     public void testRun_moduleLevelListeners() throws Exception {
@@ -1526,25 +1522,17 @@ public class ModuleDefinitionTest {
         LogSaverResultForwarder forwarder =
                 new LogSaverResultForwarder(
                         mMockLogSaver, Arrays.asList(mMockLogSaverListener), moduleConfig);
-        mModule.run(mModuleInfo, forwarder, Arrays.asList(mMockListener));
+        ResultAndLogForwarder allListeners = new ResultAndLogForwarder(forwarder, mMockListener);
+        mModule.run(mModuleInfo, allListeners);
         InOrder inOrder = Mockito.inOrder(mMockLogSaverListener, mMockListener);
         inOrder.verify(mMockLogSaverListener).setLogSaver(mMockLogSaver);
-        inOrder.verify(mMockListener)
+        inOrder.verify(mMockLogSaverListener)
                 .testRunStarted(
-                        Mockito.eq("run1"),
+                        Mockito.eq(MODULE_NAME),
                         Mockito.eq(testCount),
                         Mockito.eq(0),
                         Mockito.anyLong());
         inOrder.verify(mMockListener)
-                .testStarted((TestDescription) Mockito.any(), Mockito.anyLong());
-        inOrder.verify(mMockListener)
-                .testEnded(
-                        (TestDescription) Mockito.any(),
-                        Mockito.anyLong(),
-                        Mockito.<HashMap<String, Metric>>any());
-        inOrder.verify(mMockListener)
-                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
-        inOrder.verify(mMockLogSaverListener)
                 .testRunStarted(
                         Mockito.eq(MODULE_NAME),
                         Mockito.eq(testCount),
@@ -1552,20 +1540,29 @@ public class ModuleDefinitionTest {
                         Mockito.anyLong());
         inOrder.verify(mMockLogSaverListener)
                 .testStarted((TestDescription) Mockito.any(), Mockito.anyLong());
+        inOrder.verify(mMockListener)
+                .testStarted((TestDescription) Mockito.any(), Mockito.anyLong());
         inOrder.verify(mMockLogSaverListener)
                 .testEnded(
                         (TestDescription) Mockito.any(),
                         Mockito.anyLong(),
                         Mockito.<HashMap<String, Metric>>any());
+        inOrder.verify(mMockListener)
+                .testEnded(
+                        (TestDescription) Mockito.any(),
+                        Mockito.anyLong(),
+                        Mockito.<HashMap<String, Metric>>any());
         inOrder.verify(mMockLogSaverListener)
                 .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+        inOrder.verify(mMockListener)
+                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockPrep).tearDown(Mockito.eq(mModuleInfo), Mockito.isNull());
         verify(mMockLogSaverListener).setLogSaver(mMockLogSaver);
         verify(mMockListener)
                 .testRunStarted(
-                        Mockito.eq("run1"),
+                        Mockito.eq(MODULE_NAME),
                         Mockito.eq(testCount),
                         Mockito.eq(0),
                         Mockito.anyLong());
@@ -1734,7 +1731,7 @@ public class ModuleDefinitionTest {
         when(mMockPrep.isDisabled()).thenReturn(false);
         when(mMockPrep.isTearDownDisabled()).thenReturn(false);
 
-        mModule.run(mModuleInfo, mMockListener, null, 3);
+        mModule.run(mModuleInfo, mMockListener, 3);
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
         verify(mMockPrep).tearDown(Mockito.eq(mModuleInfo), Mockito.isNull());
@@ -1835,7 +1832,7 @@ public class ModuleDefinitionTest {
         when(mMockPrep.isTearDownDisabled()).thenReturn(false);
         when(mMockDevice.getIDevice()).thenReturn(mock(IDevice.class));
 
-        mModule.run(mModuleInfo, mMockListener, null, 3);
+        mModule.run(mModuleInfo, mMockListener, 3);
         verify(mMockPrep, times(2)).isDisabled();
         verify(mMockDevice, times(3)).getIDevice();
         verify(mMockPrep).setUp(Mockito.eq(mModuleInfo));
diff --git a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandlerTest.java b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandlerTest.java
index 4c7833f33..c68c0936e 100644
--- a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandlerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandlerTest.java
@@ -40,6 +40,8 @@ public class RunOnCloneProfileParameterHandlerTest {
 
     private static final String REQUIRE_RUN_ON_CLONE_PROFILE_NAME =
             "com.android.bedstead.multiuser.annotations.RequireRunOnCloneProfile";
+    private static final String REQUIRE_RUN_ON_CLONE_PROFILE_LEGACY_NAME =
+            "com.android.bedstead.harrier.annotations.RequireRunOnCloneProfile";
     private static final String EXISTING_ANNOTATION_FILTER = "existing.annotation.filter";
 
     private RunOnCloneProfileParameterHandler mHandler;
@@ -63,16 +65,19 @@ public class RunOnCloneProfileParameterHandlerTest {
 
         mHandler.applySetup(mModuleConfig);
 
-        assertEquals(1, test.getIncludeAnnotations().size());
-        assertEquals(
-                REQUIRE_RUN_ON_CLONE_PROFILE_NAME, test.getIncludeAnnotations().iterator().next());
+        assertEquals(2, test.getIncludeAnnotations().size());
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_CLONE_PROFILE_NAME));
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_CLONE_PROFILE_LEGACY_NAME));
     }
 
     @Test
     public void applySetup_removesRequireRunOnCloneProfileFromExcludeFilters() {
         TestFilterable test = new TestFilterable();
-        test.addAllExcludeAnnotation(
-                Set.of(EXISTING_ANNOTATION_FILTER, REQUIRE_RUN_ON_CLONE_PROFILE_NAME));
+        test.addAllExcludeAnnotation(Set.of(
+                EXISTING_ANNOTATION_FILTER,
+                REQUIRE_RUN_ON_CLONE_PROFILE_NAME,
+                REQUIRE_RUN_ON_CLONE_PROFILE_LEGACY_NAME
+        ));
         mModuleConfig.setTest(test);
 
         mHandler.applySetup(mModuleConfig);
diff --git a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandlerTest.java b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandlerTest.java
index 30aa0e6e4..14c78bafa 100644
--- a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandlerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandlerTest.java
@@ -40,6 +40,8 @@ public class RunOnPrivateProfileParameterHandlerTest {
 
     private static final String REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME =
             "com.android.bedstead.multiuser.annotations.RequireRunOnPrivateProfile";
+    private static final String REQUIRE_RUN_ON_PRIVATE_PROFILE_LEGACY_NAME =
+            "com.android.bedstead.harrier.annotations.RequireRunOnPrivateProfile";
     private static final String EXISTING_ANNOTATION_FILTER = "existing.annotation.filter";
 
     private RunOnPrivateProfileParameterHandler mHandler;
@@ -63,16 +65,21 @@ public class RunOnPrivateProfileParameterHandlerTest {
 
         mHandler.applySetup(mModuleConfig);
 
-        assertEquals(1, test.getIncludeAnnotations().size());
-        assertEquals(REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME,
-                test.getIncludeAnnotations().iterator().next());
+        assertEquals(2, test.getIncludeAnnotations().size());
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME));
+        assertTrue(
+                test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_PRIVATE_PROFILE_LEGACY_NAME)
+        );
     }
 
     @Test
     public void applySetup_removesRequireRunOnPrivateProfileFromExcludeFilters() {
         TestFilterable test = new TestFilterable();
-        test.addAllExcludeAnnotation(
-                Set.of(EXISTING_ANNOTATION_FILTER, REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME));
+        test.addAllExcludeAnnotation(Set.of(
+                EXISTING_ANNOTATION_FILTER,
+                REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME,
+                REQUIRE_RUN_ON_PRIVATE_PROFILE_LEGACY_NAME
+        ));
         mModuleConfig.setTest(test);
 
         mHandler.applySetup(mModuleConfig);
diff --git a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandlerTest.java b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandlerTest.java
index 3533875dc..41e125d72 100644
--- a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandlerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandlerTest.java
@@ -40,6 +40,8 @@ public class RunOnSecondaryUserParameterHandlerTest {
 
     private static final String REQUIRE_RUN_ON_SECONDARY_USER_NAME =
             "com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser";
+    private static final String REQUIRE_RUN_ON_SECONDARY_USER_LEGACY_NAME =
+            "com.android.bedstead.harrier.annotations.RequireRunOnSecondaryUser";
     private static final String EXISTING_ANNOTATION_FILTER = "existing.annotation.filter";
 
     private RunOnSecondaryUserParameterHandler mHandler;
@@ -63,16 +65,21 @@ public class RunOnSecondaryUserParameterHandlerTest {
 
         mHandler.applySetup(mModuleConfig);
 
-        assertEquals(1, test.getIncludeAnnotations().size());
-        assertEquals(
-                REQUIRE_RUN_ON_SECONDARY_USER_NAME, test.getIncludeAnnotations().iterator().next());
+        assertEquals(2, test.getIncludeAnnotations().size());
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_SECONDARY_USER_NAME));
+        assertTrue(
+                test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_SECONDARY_USER_LEGACY_NAME)
+        );
     }
 
     @Test
     public void applySetup_removesRequireRunOnSecondaryUserFromExcludeFilters() {
         TestFilterable test = new TestFilterable();
-        test.addAllExcludeAnnotation(
-                Set.of(EXISTING_ANNOTATION_FILTER, REQUIRE_RUN_ON_SECONDARY_USER_NAME));
+        test.addAllExcludeAnnotation(Set.of(
+                EXISTING_ANNOTATION_FILTER,
+                REQUIRE_RUN_ON_SECONDARY_USER_NAME,
+                REQUIRE_RUN_ON_SECONDARY_USER_LEGACY_NAME
+        ));
         mModuleConfig.setTest(test);
 
         mHandler.applySetup(mModuleConfig);
diff --git a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandlerTest.java b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandlerTest.java
index 12482146d..a2d84365a 100644
--- a/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandlerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandlerTest.java
@@ -40,6 +40,8 @@ public class RunOnWorkProfileParameterHandlerTest {
 
     private static final String REQUIRE_RUN_ON_WORK_PROFILE_NAME =
             "com.android.bedstead.enterprise.annotations.RequireRunOnWorkProfile";
+    private static final String REQUIRE_RUN_ON_WORK_PROFILE_LEGACY_NAME =
+            "com.android.bedstead.harrier.annotations.RequireRunOnWorkProfile";
     private static final String EXISTING_ANNOTATION_FILTER = "existing.annotation.filter";
 
     private RunOnWorkProfileParameterHandler mHandler;
@@ -63,16 +65,19 @@ public class RunOnWorkProfileParameterHandlerTest {
 
         mHandler.applySetup(mModuleConfig);
 
-        assertEquals(1, test.getIncludeAnnotations().size());
-        assertEquals(
-                REQUIRE_RUN_ON_WORK_PROFILE_NAME, test.getIncludeAnnotations().iterator().next());
+        assertEquals(2, test.getIncludeAnnotations().size());
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_WORK_PROFILE_NAME));
+        assertTrue(test.getIncludeAnnotations().contains(REQUIRE_RUN_ON_WORK_PROFILE_LEGACY_NAME));
     }
 
     @Test
     public void applySetup_removesRequireRunOnWorkProfileFromExcludeFilters() {
         TestFilterable test = new TestFilterable();
-        test.addAllExcludeAnnotation(
-                Set.of(EXISTING_ANNOTATION_FILTER, REQUIRE_RUN_ON_WORK_PROFILE_NAME));
+        test.addAllExcludeAnnotation(Set.of(
+                EXISTING_ANNOTATION_FILTER,
+                REQUIRE_RUN_ON_WORK_PROFILE_NAME,
+                REQUIRE_RUN_ON_WORK_PROFILE_LEGACY_NAME)
+        );
         mModuleConfig.setTest(test);
 
         mHandler.applySetup(mModuleConfig);
diff --git a/javatests/com/android/tradefed/util/JUnitXmlParserTest.java b/javatests/com/android/tradefed/util/JUnitXmlParserTest.java
index 4fb68bb9c..cf07f9a92 100644
--- a/javatests/com/android/tradefed/util/JUnitXmlParserTest.java
+++ b/javatests/com/android/tradefed/util/JUnitXmlParserTest.java
@@ -48,6 +48,7 @@ public class JUnitXmlParserTest {
     private static final String TEST_PARSE_FILE = "JUnitXmlParserTest_testParse.xml";
     private static final String TEST_PARSE_FILE2 = "JUnitXmlParserTest_error.xml";
     private static final String TEST_PARSE_FILE3 = "JUnitXmlParserTest_error2.xml";
+    private static final String TEST_PARSE_FILE4 = "JUnitXmlParserTest_error3.xml";
     private static final String BAZEL_SH_TEST_XML = "JUnitXmlParserTest_bazelShTest.xml";
 
     @Mock ITestInvocationListener mMockListener;
@@ -117,6 +118,32 @@ public class JUnitXmlParserTest {
         verify(mMockListener).testRunEnded(918686L, new HashMap<String, Metric>());
     }
 
+    /** Test parsing the <error> and <skipped> tag with assumption failure in the junit xml. */
+    @Test
+    public void testParseErrorAndSkippedWithAssumptionFailure() throws ParseException {
+        TestDescription test1 = new TestDescription("PassTest", "testPass");
+        TestDescription test2 = new TestDescription("SkippedTest", "testSkip");
+        TestDescription test3 = new TestDescription("ErrorTest", "testFail");
+
+        new JUnitXmlParser(mMockListener).parse(extractTestXml(TEST_PARSE_FILE4));
+        FailureDescription failure =
+                FailureDescription.create(
+                        "java.lang.NullPointerException\n    "
+                                + "at FailTest.testFail:65\n        ",
+                        FailureStatus.TEST_FAILURE);
+
+        verify(mMockListener).testRunStarted("suiteName", 3);
+        verify(mMockListener).testStarted(test1);
+        verify(mMockListener).testEnded(test1, new HashMap<String, Metric>());
+        verify(mMockListener).testStarted(test2);
+        verify(mMockListener).testAssumptionFailure(test2, "org.junit.AssumptionViolatedException");
+        verify(mMockListener).testEnded(test2, new HashMap<String, Metric>());
+        verify(mMockListener).testStarted(test3);
+        verify(mMockListener).testFailed(Mockito.eq(test3), Mockito.eq(failure));
+        verify(mMockListener).testEnded(test3, new HashMap<String, Metric>());
+        verify(mMockListener).testRunEnded(918686L, new HashMap<String, Metric>());
+    }
+
     @Test
     public void testParseError_format() throws ParseException {
         TestDescription test1 = new TestDescription("JUnitXmlParser", "normal_integration_tests");
diff --git a/javatests/com/android/tradefed/util/RunUtilTest.java b/javatests/com/android/tradefed/util/RunUtilTest.java
index dd06517aa..9105689e9 100644
--- a/javatests/com/android/tradefed/util/RunUtilTest.java
+++ b/javatests/com/android/tradefed/util/RunUtilTest.java
@@ -24,7 +24,6 @@ import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -355,10 +354,10 @@ public class RunUtilTest {
         // expect a call 4 times, at sleep time 0, 1, 4 and 10 ms
         when(mockRunnable.run()).thenReturn(Boolean.FALSE);
 
-        long maxTime = 10;
+        long maxTime = 12;
         assertFalse(runUtil.runEscalatingTimedRetry(1, 1, 512, maxTime, mockRunnable));
         assertEquals(maxTime, mSleepTime);
-        verify(mockRunnable, times(4)).run();
+        verify(mockRunnable, Mockito.atLeast(3)).run();
     }
 
     /** Test a success case for {@link RunUtil#interrupt}. */
diff --git a/javatests/com/android/tradefed/util/TfInternalOptionsFetcherTest.java b/javatests/com/android/tradefed/util/TfInternalOptionsFetcherTest.java
new file mode 100644
index 000000000..35fcfd3d8
--- /dev/null
+++ b/javatests/com/android/tradefed/util/TfInternalOptionsFetcherTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import static org.junit.Assert.assertEquals;
+
+import com.android.tradefed.config.Option;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(JUnit4.class)
+public class TfInternalOptionsFetcherTest {
+    static class TestObject {
+        public static int intVariable;
+        public static boolean boolVariable;
+        public static String stringVariable;
+        public static List<String> listVariable = new ArrayList<>();
+        public static Map<String, String> mapStringVariable = new HashMap<>();
+        public static Map<Integer, String> mapIntStringVariable = new HashMap<>();
+
+        @Option(name = "option-string")
+        public static String optionStringField;
+
+        static {
+            TfInternalOptionsFetcher.setResourcePath("/util/TfInternalOptions_test.properties");
+            TfInternalOptionsFetcher.fetchOption(TestObject.class);
+        }
+    }
+
+    @Test
+    public void testFetchOptions() {
+        assertEquals(5, TestObject.intVariable);
+        assertEquals("test", TestObject.stringVariable);
+        assertEquals(true, TestObject.boolVariable);
+        assertEquals(3, TestObject.listVariable.size());
+        assertEquals("string_two", TestObject.listVariable.get(1));
+        assertEquals(2, TestObject.mapStringVariable.size());
+        assertEquals("mapVal1", TestObject.mapStringVariable.get("mapKey1"));
+        assertEquals("mapVal2", TestObject.mapStringVariable.get("mapKey2"));
+        assertEquals(2, TestObject.mapIntStringVariable.size());
+        assertEquals("mapIntVal1", TestObject.mapIntStringVariable.get(1));
+        assertEquals("mapIntVal2", TestObject.mapIntStringVariable.get(2));
+        assertEquals("optionString", TestObject.optionStringField);
+    }
+}
diff --git a/javatests/com/android/tradefed/util/image/DeviceImageTrackerTest.java b/javatests/com/android/tradefed/util/image/DeviceImageTrackerTest.java
index 892c1805d..9c9a10a4b 100644
--- a/javatests/com/android/tradefed/util/image/DeviceImageTrackerTest.java
+++ b/javatests/com/android/tradefed/util/image/DeviceImageTrackerTest.java
@@ -19,7 +19,6 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
-import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.image.DeviceImageTracker.FileCacheTracker;
 
 import org.junit.After;
@@ -28,8 +27,6 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 /** Unit tests for {@link DeviceImageTracker}. */
 @RunWith(JUnit4.class)
 public class DeviceImageTrackerTest {
@@ -51,22 +48,9 @@ public class DeviceImageTrackerTest {
         assertNull(mTestableCache.getBaselineDeviceImage("not_cached"));
         // No lingering state after a query
         assertNull(mTestableCache.getBaselineDeviceImage("not_cached"));
-
-        File deviceImage = FileUtil.createTempFile("cache-image", ".zip");
-        FileUtil.writeToFile("content", deviceImage);
-        File bootloader = FileUtil.createTempFile("cache-bootloader", ".zip");
-        File baseband = FileUtil.createTempFile("cache-baseband", ".zip");
-        try {
-            mTestableCache.trackUpdatedDeviceImage(
-                    "serial", deviceImage, bootloader, baseband, "8888", "branch", "flavor");
-            FileCacheTracker tracker = mTestableCache.getBaselineDeviceImage("serial");
-            assertNotNull(tracker);
-            assertEquals("8888", tracker.buildId);
-            assertEquals("content", FileUtil.readStringFromFile(tracker.zippedDeviceImage));
-        } finally {
-            FileUtil.deleteFile(deviceImage);
-            FileUtil.deleteFile(bootloader);
-            FileUtil.deleteFile(baseband);
-        }
+        mTestableCache.trackUpdatedDeviceImage("serial", "8888", "branch", "flavor");
+        FileCacheTracker tracker = mTestableCache.getBaselineDeviceImage("serial");
+        assertNotNull(tracker);
+        assertEquals("8888", tracker.buildId);
     }
 }
diff --git a/javatests/res/util/JUnitXmlParserTest_error3.xml b/javatests/res/util/JUnitXmlParserTest_error3.xml
new file mode 100644
index 000000000..da8c5a7bb
--- /dev/null
+++ b/javatests/res/util/JUnitXmlParserTest_error3.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<testsuite skipped="1" errors="1" failures="0" hostname="foo" name="suiteName" tests="3" time="918.686">
+    <testcase classname="PassTest" name="testPass" time="0.021"/>
+    <testcase classname="SkippedTest" name="testSkip" time="0.021">
+        <skipped>org.junit.AssumptionViolatedException</skipped>
+    </testcase>
+    <testcase classname="ErrorTest" name="testFail" time="0.025">
+        <error message="error message" type="java.lang.NullPointerException">java.lang.NullPointerException
+    at FailTest.testFail:65
+        </error>
+    </testcase>
+</testsuite>
diff --git a/javatests/res/util/TfInternalOptions_test.properties b/javatests/res/util/TfInternalOptions_test.properties
new file mode 100644
index 000000000..90e13ae2f
--- /dev/null
+++ b/javatests/res/util/TfInternalOptions_test.properties
@@ -0,0 +1,7 @@
+intVariable=5
+boolVariable=true
+stringVariable=test
+listVariable=string_one,string_two,string_three
+mapStringVariable=mapKey1\=mapVal1,mapKey2\=mapVal2
+mapIntStringVariable=1=mapIntVal1,2=mapIntVal2
+optionStringField=optionString
\ No newline at end of file
diff --git a/remote/.classpath b/remote/.classpath
index 6911b97eb..b61747f1f 100644
--- a/remote/.classpath
+++ b/remote/.classpath
@@ -10,7 +10,7 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/json/json-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/sdklib/sdklib-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/tools-common/tools-common-prebuilt.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/guava/guava-jre/linux_glibc_common/combined/guava-jre.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.23.0.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/guava/guava/linux_glibc_common/javac-header/guava.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.36.0.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/src/OWNERS b/src/OWNERS
index 3fe98e786..91e5fde17 100644
--- a/src/OWNERS
+++ b/src/OWNERS
@@ -1 +1,2 @@
 per-file com/android/tradefed/targetprep/*User* = file:/MULTIUSER_OWNERS
+per-file com/android/tradefed/device/metric/CodeCoverageCollector.java = file:/COVERAGE_OWNERS
diff --git a/src/com/android/tradefed/build/content/ContentAnalysisResults.java b/src/com/android/tradefed/build/content/ContentAnalysisResults.java
index cc38fe58f..56c1d7635 100644
--- a/src/com/android/tradefed/build/content/ContentAnalysisResults.java
+++ b/src/com/android/tradefed/build/content/ContentAnalysisResults.java
@@ -35,6 +35,7 @@ public class ContentAnalysisResults {
     private Set<String> unchangedModules = new HashSet<>();
     private Set<String> modifiedModuleNames = new HashSet<>();
     private Map<String, Digest> imageToDigest = new LinkedHashMap<>();
+    private Map<String, Digest> artifactToDigest = new LinkedHashMap<>();
 
     public ContentAnalysisResults() {}
 
@@ -69,6 +70,11 @@ public class ContentAnalysisResults {
         return this;
     }
 
+    public ContentAnalysisResults addArtifactDigestMapping(String artifactFileName, Digest digest) {
+        artifactToDigest.put(artifactFileName, digest);
+        return this;
+    }
+
     public ContentAnalysisResults addChangedBuildKey(long count) {
         buildKeyChanges += count;
         return this;
@@ -110,6 +116,10 @@ public class ContentAnalysisResults {
         return imageToDigest;
     }
 
+    public Map<String, Digest> getArtifactToDigest() {
+        return artifactToDigest;
+    }
+
     @Override
     public String toString() {
         return "ContentAnalysisResults [unchangedFiles="
@@ -143,6 +153,7 @@ public class ContentAnalysisResults {
             mergedResults.modifiedModuleNames.addAll(res.modifiedModuleNames);
             mergedResults.deviceImageChanges += res.deviceImageChanges;
             mergedResults.imageToDigest.putAll(res.imageToDigest);
+            mergedResults.artifactToDigest.putAll(res.artifactToDigest);
         }
         // Re-align what didn't change across analysis.
         mergedResults.unchangedModules.removeAll(mergedResults.modifiedModuleNames);
diff --git a/src/com/android/tradefed/build/content/ContentMerkleTree.java b/src/com/android/tradefed/build/content/ContentMerkleTree.java
index 115e4a4a4..2a9e003d6 100644
--- a/src/com/android/tradefed/build/content/ContentMerkleTree.java
+++ b/src/com/android/tradefed/build/content/ContentMerkleTree.java
@@ -17,6 +17,7 @@ package com.android.tradefed.build.content;
 
 import com.android.tradefed.build.content.ArtifactDetails.ArtifactFileDescriptor;
 import com.android.tradefed.cache.DigestCalculator;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 
 import build.bazel.remote.execution.v2.Digest;
@@ -24,6 +25,7 @@ import build.bazel.remote.execution.v2.Directory;
 import build.bazel.remote.execution.v2.FileNode;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -34,7 +36,8 @@ public class ContentMerkleTree {
 
     /** Builds a merkle tree and returns the root digest from the common location information */
     public static Digest buildCommonLocationFromContext(ContentAnalysisContext context) {
-        try {
+        try (CloseableTraceScope commonLoc =
+                new CloseableTraceScope("buildCommonLocationFromContext")) {
             ArtifactDetails currentContent =
                     ArtifactDetails.parseFile(
                             context.contentInformation().currentContent, context.contentEntry());
@@ -80,4 +83,79 @@ public class ContentMerkleTree {
             return null;
         }
     }
+
+    public static Digest buildTestsDirFromContext(
+            ContentAnalysisContext context, List<String> discoveredModule) {
+        try (CloseableTraceScope testLoc = new CloseableTraceScope("buildTestsDirFromContext")) {
+            ArtifactDetails currentContent =
+                    ArtifactDetails.parseFile(
+                            context.contentInformation().currentContent, context.contentEntry());
+            Directory.Builder rootBuilder = Directory.newBuilder();
+            List<ArtifactFileDescriptor> allFiles = currentContent.details;
+            allFiles.removeIf(d -> context.ignoredChanges().contains(d.path));
+            // Remove xTS style version
+            String rootPackage = context.contentEntry().replaceAll(".zip", "");
+            allFiles.removeIf(d -> d.path.equals(rootPackage + "/tools/version.txt"));
+            // Don't consider common locations
+            allFiles.removeIf(
+                    d -> {
+                        for (String common : context.commonLocations()) {
+                            if (d.path.startsWith(common)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    });
+
+            List<ArtifactFileDescriptor> relevantArtifacts = new ArrayList<>();
+            if (!discoveredModule.isEmpty()) {
+                for (String module : discoveredModule) {
+                    relevantArtifacts.addAll(
+                            allFiles.parallelStream()
+                                    .filter(
+                                            d -> {
+                                                if (d.path.contains("/" + module + "/")) {
+                                                    return true;
+                                                }
+                                                return false;
+                                            })
+                                    .collect(Collectors.toList()));
+                }
+                CLog.d("Considering for testsdir key the following paths:");
+                for (ArtifactFileDescriptor afd : relevantArtifacts) {
+                    CLog.d("%s", afd.path);
+                }
+
+            } else {
+                relevantArtifacts.addAll(allFiles);
+            }
+
+            // Sort to ensure final messages are identical
+            Collections.sort(
+                    relevantArtifacts,
+                    new Comparator<ArtifactFileDescriptor>() {
+                        @Override
+                        public int compare(
+                                ArtifactFileDescriptor arg0, ArtifactFileDescriptor arg1) {
+                            return arg0.path.compareTo(arg1.path);
+                        }
+                    });
+            for (ArtifactFileDescriptor afd : relevantArtifacts) {
+                Digest digest =
+                        Digest.newBuilder().setHash(afd.digest).setSizeBytes(afd.size).build();
+                rootBuilder.addFiles(
+                        FileNode.newBuilder()
+                                .setDigest(digest)
+                                .setName(afd.path)
+                                .setIsExecutable(false));
+            }
+            Directory root = rootBuilder.build();
+            Digest d = DigestCalculator.compute(root);
+            CLog.d("Digest for testsdir location of '%s' is '%s'", context.contentEntry(), d);
+            return d;
+        } catch (IOException | RuntimeException e) {
+            CLog.e(e);
+            return null;
+        }
+    }
 }
diff --git a/src/com/android/tradefed/build/content/ContentModuleLister.java b/src/com/android/tradefed/build/content/ContentModuleLister.java
index 3cbb8b9ab..d73b33c89 100644
--- a/src/com/android/tradefed/build/content/ContentModuleLister.java
+++ b/src/com/android/tradefed/build/content/ContentModuleLister.java
@@ -27,7 +27,7 @@ import java.util.Set;
 /** Compute a module list from the context. */
 public class ContentModuleLister {
 
-    /** Builds the list of existing modules from the context */
+    /** Builds the list of existing modules from the context or null in case of error */
     public static Set<String> buildModuleList(ContentAnalysisContext context) {
         try {
             ArtifactDetails currentContent =
@@ -54,7 +54,7 @@ public class ContentModuleLister {
             return moduleNames;
         } catch (IOException | RuntimeException e) {
             CLog.e(e);
-            return new HashSet<>();
+            return null;
         }
     }
 }
diff --git a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
index 89271c6c8..0996a7fa1 100644
--- a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
@@ -29,6 +29,7 @@ import build.bazel.remote.execution.v2.Digest;
 import com.google.api.client.util.Joiner;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -67,13 +68,12 @@ public class ImageContentAnalyzer {
 
         if (analysisLevel.ordinal() >= AnalysisHeuristic.REMOVE_EXEMPTION.ordinal()) {
             boolean removed = false;
-            // b/335722003
-            boolean ota4k =
-                    allDescriptors.removeIf(d -> d.path.endsWith("/boot_otas/boot_ota_4k.zip"));
-            boolean ota16k =
-                    allDescriptors.removeIf(d -> d.path.endsWith("/boot_otas/boot_ota_16k.zip"));
-            if (ota4k || ota16k) {
-                removed = true;
+            for (String path :
+                    Arrays.asList(
+                            // b/335722003
+                            "/boot_otas/boot_ota_4k.zip",
+                            "/boot_otas/boot_ota_16k.zip")) {
+                removed = allDescriptors.removeIf(d -> d.path.endsWith(path)) || removed;
             }
             if (removed) {
                 InvocationMetricLogger.addInvocationMetrics(
diff --git a/src/com/android/tradefed/build/content/TestContentAnalyzer.java b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
index 44e611240..691678415 100644
--- a/src/com/android/tradefed/build/content/TestContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
@@ -42,6 +42,8 @@ import java.util.stream.Stream;
 /** The analyzer takes context for the analysis and determine what is interesting. */
 public class TestContentAnalyzer {
 
+    public static final String TESTS_DIR_KEY = "testsdir";
+
     private final TestInformation information;
     private final boolean presubmitMode;
     private final List<ContentAnalysisContext> contexts;
@@ -133,10 +135,16 @@ public class TestContentAnalyzer {
                     InvocationMetricLogger.addInvocationMetrics(
                             InvocationMetricKey.ABORT_CONTENT_ANALYSIS, 1);
                     // Continue with an invalidated analysis
-                    results = new ContentAnalysisResults().addModifiedSharedFolder(1);
+                    results =
+                            new ContentAnalysisResults()
+                                    .addModifiedSharedFolder(1)
+                                    .addArtifactDigestMapping(TESTS_DIR_KEY, null);
                     CLog.d("Content analysis results for %s: invalid", ac.contentEntry());
                 } else {
                     CLog.d("content analysis results for %s: %s", ac.contentEntry(), results);
+                    results.addArtifactDigestMapping(
+                            TESTS_DIR_KEY + "_" + ac.contentEntry(),
+                            ContentMerkleTree.buildTestsDirFromContext(ac, discoveredModules));
                 }
                 allResults.add(results);
             }
diff --git a/src/com/android/tradefed/command/CommandOptions.java b/src/com/android/tradefed/command/CommandOptions.java
index a4445609d..b5f654546 100644
--- a/src/com/android/tradefed/command/CommandOptions.java
+++ b/src/com/android/tradefed/command/CommandOptions.java
@@ -370,6 +370,17 @@ public class CommandOptions implements ICommandOptions {
             description = "Actually enable the reporting of caching status in presubmit.")
     private boolean mEnableCachingResultsInPresubmit = false;
 
+    @Option(
+            name = "upload-cached-invocation-results",
+            description = "Whether or not to upload the results of a test invocation to the cache")
+    private boolean mUploadInvocationCachedResults = false;
+
+    @Option(
+            name = "report-cache-invocation-results-presubmit",
+            description =
+                    "Actually enable the reporting of invocation caching status in presubmit.")
+    private boolean mEnableCachingInvocationResultsInPresubmit = false;
+
     /**
      * Set the help mode for the config.
      * <p/>
@@ -906,4 +917,16 @@ public class CommandOptions implements ICommandOptions {
     public boolean reportCacheResultsInPresubmit() {
         return mEnableCachingResultsInPresubmit;
     }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean shouldUploadInvocationCacheResults() {
+        return mUploadInvocationCachedResults;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean reportInvocationCacheResultsInPresubmit() {
+        return mEnableCachingInvocationResultsInPresubmit;
+    }
 }
diff --git a/src/com/android/tradefed/command/ICommandOptions.java b/src/com/android/tradefed/command/ICommandOptions.java
index 63d89ad93..94045eda2 100644
--- a/src/com/android/tradefed/command/ICommandOptions.java
+++ b/src/com/android/tradefed/command/ICommandOptions.java
@@ -311,4 +311,10 @@ public interface ICommandOptions {
 
     /** Returns true if we should report cache results when available in presubmit. */
     public boolean reportCacheResultsInPresubmit();
+
+    /** Returns true if we should capture the invocation results in the cache. */
+    public boolean shouldUploadInvocationCacheResults();
+
+    /** Returns true if we should report invocation cache results when available in presubmit. */
+    public boolean reportInvocationCacheResultsInPresubmit();
 }
diff --git a/src/com/android/tradefed/config/Configuration.java b/src/com/android/tradefed/config/Configuration.java
index 8b8a369da..7a051ac58 100644
--- a/src/com/android/tradefed/config/Configuration.java
+++ b/src/com/android/tradefed/config/Configuration.java
@@ -1358,7 +1358,8 @@ public class Configuration implements IConfiguration {
             } else if (options.getShardCount() != null
                     && options.getShardCount() > 1
                     && options.getShardIndex() == null
-                    && !getCommandOptions().shouldUseSandboxing()) {
+                    && !getCommandOptions().shouldUseSandboxing()
+                    && !getCommandOptions().shouldUseRemoteSandboxMode()) {
                 CLog.w("Skipping dynamic download due to local sharding detected.");
                 return;
             }
diff --git a/src/com/android/tradefed/config/OptionSetter.java b/src/com/android/tradefed/config/OptionSetter.java
index b93432809..e83ec7488 100644
--- a/src/com/android/tradefed/config/OptionSetter.java
+++ b/src/com/android/tradefed/config/OptionSetter.java
@@ -135,8 +135,7 @@ public class OptionSetter {
         }
     }
 
-
-    private static Handler getHandler(Type type) throws ConfigurationException {
+    public static Handler getHandler(Type type) throws ConfigurationException {
         if (type instanceof ParameterizedType) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
             Class<?> rawClass = (Class<?>) parameterizedType.getRawType();
@@ -451,6 +450,30 @@ public class OptionSetter {
     @SuppressWarnings("unchecked")
     static boolean setFieldValue(String optionName, Object optionSource, Field field, Object key,
             Object value) throws ConfigurationException {
+        return setFieldValue(optionName, optionSource, field, key, value, true);
+    }
+
+    /**
+     * Sets the given {@link Option} field's value.
+     *
+     * @param optionName the name specified in {@link Option}
+     * @param optionSource the {@link Object} to set
+     * @param field the {@link Field}
+     * @param key the key to an entry in a {@link Map} or {@link MultiMap} field or null.
+     * @param value the value to set
+     * @return Whether the field was set.
+     * @throws ConfigurationException
+     * @see OptionUpdateRule
+     */
+    @SuppressWarnings("unchecked")
+    public static boolean setFieldValue(
+            String optionName,
+            Object optionSource,
+            Field field,
+            Object key,
+            Object value,
+            boolean checkOption)
+            throws ConfigurationException {
 
         boolean fieldWasSet = true;
 
@@ -534,25 +557,35 @@ public class OptionSetter {
                     throw new ConfigurationException(String.format(
                             "Key not applicable when setting non-map field '%s'", field.getName()));
                 }
-                final Option option = field.getAnnotation(Option.class);
-                if (option == null) {
-                    // By virtue of us having gotten here, this should never happen.  But better
-                    // safe than sorry
-                    throw new ConfigurationException(String.format(
-                            "internal error: @Option annotation for field %s in class %s was " +
-                            "unexpectedly null",
-                            field.getName(), optionSource.getClass().getName()));
-                }
-                OptionUpdateRule rule = option.updateRule();
-                if (rule.shouldUpdate(optionName, optionSource, field, value)) {
+                if (checkOption) {
+                    final Option option = field.getAnnotation(Option.class);
+                    if (option == null) {
+                        // By virtue of us having gotten here, this should never happen.  But better
+                        // safe than sorry
+                        throw new ConfigurationException(
+                                String.format(
+                                        "internal error: @Option annotation for field %s in class"
+                                                + " %s was unexpectedly null",
+                                        field.getName(), optionSource.getClass().getName()));
+                    }
+                    OptionUpdateRule rule = option.updateRule();
+                    if (rule.shouldUpdate(optionName, optionSource, field, value)) {
+                        Object curValue = field.get(optionSource);
+                        if (value == null || value.equals(curValue)) {
+                            fieldWasSet = false;
+                        } else {
+                            field.set(optionSource, value);
+                        }
+                    } else {
+                        fieldWasSet = false;
+                    }
+                } else {
                     Object curValue = field.get(optionSource);
                     if (value == null || value.equals(curValue)) {
                         fieldWasSet = false;
                     } else {
                         field.set(optionSource, value);
                     }
-                } else {
-                    fieldWasSet = false;
                 }
             }
         } catch (IllegalAccessException | IllegalArgumentException e) {
@@ -1008,14 +1041,14 @@ public class OptionSetter {
         }
     }
 
-    private abstract static class Handler<T> {
+    public abstract static class Handler<T> {
         // Only BooleanHandler should ever override this.
-        boolean isBoolean() {
+        public boolean isBoolean() {
             return false;
         }
 
         // Only MapHandler should ever override this.
-        boolean isMap() {
+        public boolean isMap() {
             return false;
         }
 
@@ -1023,16 +1056,17 @@ public class OptionSetter {
          * Returns an object of appropriate type for the given Handle, corresponding to 'valueText'.
          * Returns null on failure.
          */
-        abstract T translate(String valueText);
+        public abstract T translate(String valueText);
     }
 
     private static class BooleanHandler extends Handler<Boolean> {
-        @Override boolean isBoolean() {
+        @Override
+        public boolean isBoolean() {
             return true;
         }
 
         @Override
-        Boolean translate(String valueText) {
+        public Boolean translate(String valueText) {
             if (valueText.equalsIgnoreCase("true") || valueText.equalsIgnoreCase("yes")) {
                 return Boolean.TRUE;
             } else if (valueText.equalsIgnoreCase("false") || valueText.equalsIgnoreCase("no")) {
@@ -1044,7 +1078,7 @@ public class OptionSetter {
 
     private static class ByteHandler extends Handler<Byte> {
         @Override
-        Byte translate(String valueText) {
+        public Byte translate(String valueText) {
             try {
                 return Byte.parseByte(valueText);
             } catch (NumberFormatException ex) {
@@ -1055,7 +1089,7 @@ public class OptionSetter {
 
     private static class ShortHandler extends Handler<Short> {
         @Override
-        Short translate(String valueText) {
+        public Short translate(String valueText) {
             try {
                 return Short.parseShort(valueText);
             } catch (NumberFormatException ex) {
@@ -1066,7 +1100,7 @@ public class OptionSetter {
 
     private static class IntegerHandler extends Handler<Integer> {
         @Override
-        Integer translate(String valueText) {
+        public Integer translate(String valueText) {
             try {
                 return Integer.parseInt(valueText);
             } catch (NumberFormatException ex) {
@@ -1077,7 +1111,7 @@ public class OptionSetter {
 
     private static class LongHandler extends Handler<Long> {
         @Override
-        Long translate(String valueText) {
+        public Long translate(String valueText) {
             try {
                 return Long.parseLong(valueText);
             } catch (NumberFormatException ex) {
@@ -1089,7 +1123,7 @@ public class OptionSetter {
     private static class TimeValLongHandler extends Handler<Long> {
         /** We parse the string as a time value, and return a {@code long} */
         @Override
-        Long translate(String valueText) {
+        public Long translate(String valueText) {
             try {
                 return TimeVal.fromString(valueText);
 
@@ -1102,7 +1136,7 @@ public class OptionSetter {
     private static class TimeValHandler extends Handler<TimeVal> {
         /** We parse the string as a time value, and return a {@code TimeVal} */
         @Override
-        TimeVal translate(String valueText) {
+        public TimeVal translate(String valueText) {
             try {
                 return new TimeVal(valueText);
 
@@ -1120,7 +1154,7 @@ public class OptionSetter {
          * supported.
          */
         @Override
-        Duration translate(String valueText) {
+        public Duration translate(String valueText) {
             try {
                 return Duration.ofMillis(TimeVal.fromString(valueText));
             } catch (NumberFormatException e) {
@@ -1133,7 +1167,7 @@ public class OptionSetter {
     private static class PatternHandler extends Handler<Pattern> {
         /** We parse the string as a regex pattern, and return a {@code Pattern} */
         @Override
-        Pattern translate(String valueText) {
+        public Pattern translate(String valueText) {
             try {
                 return Pattern.compile(valueText);
             } catch (PatternSyntaxException ex) {
@@ -1144,7 +1178,7 @@ public class OptionSetter {
 
     private static class FloatHandler extends Handler<Float> {
         @Override
-        Float translate(String valueText) {
+        public Float translate(String valueText) {
             try {
                 return Float.parseFloat(valueText);
             } catch (NumberFormatException ex) {
@@ -1155,7 +1189,7 @@ public class OptionSetter {
 
     private static class DoubleHandler extends Handler<Double> {
         @Override
-        Double translate(String valueText) {
+        public Double translate(String valueText) {
             try {
                 return Double.parseDouble(valueText);
             } catch (NumberFormatException ex) {
@@ -1166,23 +1200,22 @@ public class OptionSetter {
 
     private static class StringHandler extends Handler<String> {
         @Override
-        String translate(String valueText) {
+        public String translate(String valueText) {
             return valueText;
         }
     }
 
     private static class FileHandler extends Handler<File> {
         @Override
-        File translate(String valueText) {
+        public File translate(String valueText) {
             return new File(valueText);
         }
     }
 
     /**
-     * A {@link Handler} to handle values for Map fields.  The {@code Object} returned is a
-     * MapEntry
+     * A {@link Handler} to handle values for Map fields. The {@code Object} returned is a MapEntry
      */
-    private static class MapHandler extends Handler {
+    public static class MapHandler extends Handler {
         private Handler mKeyHandler;
         private Handler mValueHandler;
 
@@ -1203,11 +1236,9 @@ public class OptionSetter {
             return mValueHandler;
         }
 
-        /**
-         * {@inheritDoc}
-         */
+        /** {@inheritDoc} */
         @Override
-        boolean isMap() {
+        public boolean isMap() {
             return true;
         }
 
@@ -1239,15 +1270,13 @@ public class OptionSetter {
             return false;
         }
 
-        /**
-         * {@inheritDoc}
-         */
+        /** {@inheritDoc} */
         @Override
-        Object translate(String valueText) {
+        public Object translate(String valueText) {
             return mValueHandler.translate(valueText);
         }
 
-        Object translateKey(String keyText) {
+        public Object translateKey(String keyText) {
             return mKeyHandler.translate(keyText);
         }
     }
@@ -1293,11 +1322,9 @@ public class OptionSetter {
             return false;
         }
 
-        /**
-         * {@inheritDoc}
-         */
+        /** {@inheritDoc} */
         @Override
-        Object translate(String valueText) {
+        public Object translate(String valueText) {
             return translate(valueText, true);
         }
 
diff --git a/src/com/android/tradefed/config/filter/GlobalTestFilter.java b/src/com/android/tradefed/config/filter/GlobalTestFilter.java
index 2eaf2ccf2..b8f6f7c84 100644
--- a/src/com/android/tradefed/config/filter/GlobalTestFilter.java
+++ b/src/com/android/tradefed/config/filter/GlobalTestFilter.java
@@ -143,12 +143,7 @@ public final class GlobalTestFilter {
             CLog.d("Strict include filters specified: %s", mStrictIncludeFilters);
             for (IRemoteTest test : config.getTests()) {
                 if (test instanceof BaseTestSuite) {
-                    ((BaseTestSuite) test).clearExcludeFilter();
-                    ((BaseTestSuite) test).clearIncludeFilter();
-                    ((BaseTestSuite) test).setIncludeFilter(mStrictIncludeFilters);
-                    if (test instanceof TestMappingSuiteRunner) {
-                        ((TestMappingSuiteRunner) test).clearTestGroup();
-                    }
+                    applyGlobalStrictFilters((BaseTestSuite) test, mStrictIncludeFilters);
                 } else if (test instanceof ITestFilterReceiver) {
                     ITestFilterReceiver filterableTest = (ITestFilterReceiver) test;
                     applyFiltersToTest(filterableTest);
@@ -158,6 +153,17 @@ public final class GlobalTestFilter {
         mSetupDone = true;
     }
 
+    public static void applyGlobalStrictFilters(BaseTestSuite test, Set<String> strictFilters) {
+        ((BaseTestSuite) test).clearExcludeFilter();
+        ((BaseTestSuite) test).clearIncludeFilter();
+        ((BaseTestSuite) test).setIncludeFilter(strictFilters);
+        if (test instanceof TestMappingSuiteRunner) {
+            ((TestMappingSuiteRunner) test).clearTestGroup();
+            ((TestMappingSuiteRunner) test).clearKeywords();
+            ((TestMappingSuiteRunner) test).clearTestMappingPaths();
+        }
+    }
+
     /** Apply the global filters to the test. */
     public void applyFiltersToTest(ITestFilterReceiver filterableTest) {
         if (mStrictIncludeFilters.isEmpty()) {
@@ -189,6 +195,8 @@ public final class GlobalTestFilter {
             suite.setIncludeFilter(mStrictIncludeFilters);
             if (suite instanceof TestMappingSuiteRunner) {
                 ((TestMappingSuiteRunner) suite).clearTestGroup();
+                ((TestMappingSuiteRunner) suite).clearKeywords();
+                ((TestMappingSuiteRunner) suite).clearTestMappingPaths();
             }
         }
         suite.reevaluateFilters();
diff --git a/src/com/android/tradefed/config/proxy/TradefedDelegator.java b/src/com/android/tradefed/config/proxy/TradefedDelegator.java
index 0e3f47839..15e772fb1 100644
--- a/src/com/android/tradefed/config/proxy/TradefedDelegator.java
+++ b/src/com/android/tradefed/config/proxy/TradefedDelegator.java
@@ -105,7 +105,7 @@ public class TradefedDelegator {
     }
 
     /** Remove a given option from the command line. */
-    private static String[] clearCommandlineFromOneArg(String[] originalCommand, String optionName)
+    public static String[] clearCommandlineFromOneArg(String[] originalCommand, String optionName)
             throws ConfigurationException {
         List<String> argsList = new ArrayList<>(Arrays.asList(originalCommand));
         try {
diff --git a/src/com/android/tradefed/device/DeviceManager.java b/src/com/android/tradefed/device/DeviceManager.java
index 9f01ac82a..9e3624b2e 100644
--- a/src/com/android/tradefed/device/DeviceManager.java
+++ b/src/com/android/tradefed/device/DeviceManager.java
@@ -537,6 +537,12 @@ public class DeviceManager implements IDeviceManager {
                             String.format("%s-%s", GCE_DEVICE_SERIAL_PREFIX, ip), ip));
         }
 
+        for (String ip :
+                getGlobalConfig().getHostOptions().getKnownPreconfigureNativeDevicePool()) {
+            addAvailableNativeDevice(
+                    new RemoteAvdIDevice(String.format("%s-%s", GCE_DEVICE_SERIAL_PREFIX, ip), ip));
+        }
+
         Map<String, List<String>> preconfigureHostUsers = new HashMap<>();
         for (String preconfigureDevice :
                 getGlobalConfig().getHostOptions().getKnownPreconfigureVirtualDevicePool()) {
@@ -591,6 +597,15 @@ public class DeviceManager implements IDeviceManager {
         }
     }
 
+    public void addAvailableNativeDevice(IDevice stubDevice) {
+        IManagedTestDevice d = mManagedDeviceList.findOrCreate(stubDevice, true);
+        if (d != null) {
+            mManagedDeviceList.handleDeviceEvent(d, DeviceEvent.FORCE_AVAILABLE);
+        } else {
+            CLog.e("Could not create native stub device");
+        }
+    }
+
     /** Representation of a device in Fastboot mode. */
     public static class FastbootDevice extends StubDevice {
 
diff --git a/src/com/android/tradefed/device/ManagedDeviceList.java b/src/com/android/tradefed/device/ManagedDeviceList.java
index 197b78ddd..0367e9b70 100644
--- a/src/com/android/tradefed/device/ManagedDeviceList.java
+++ b/src/com/android/tradefed/device/ManagedDeviceList.java
@@ -18,6 +18,7 @@ package com.android.tradefed.device;
 
 import com.android.ddmlib.IDevice;
 import com.android.tradefed.device.DeviceManager.FastbootDevice;
+import com.android.tradefed.device.IDeviceSelection.BaseDeviceType;
 import com.android.tradefed.device.IManagedTestDevice.DeviceEventResponse;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.ConditionPriorityBlockingQueue.IMatcher;
@@ -289,6 +290,17 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
      * @return the {@link IManagedTestDevice}.
      */
     public IManagedTestDevice findOrCreate(IDevice idevice) {
+        return findOrCreate(idevice, false);
+    }
+
+    /**
+     * Find the {@link IManagedTestDevice} corresponding to the {@link IDevice}. If it does not
+     * exist, create a new one.
+     *
+     * @param idevice
+     * @return the {@link IManagedTestDevice}.
+     */
+    public IManagedTestDevice findOrCreate(IDevice idevice, boolean nativeDevice) {
         String serial = idevice.getSerialNumber();
         if (!isValidDeviceSerial(serial)) {
             return null;
@@ -320,7 +332,13 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
             IManagedTestDevice d = find(serial);
             if (d == null || DeviceAllocationState.Unavailable.equals(d.getAllocationState())) {
                 mList.remove(d);
-                d = mDeviceFactory.createDevice(idevice);
+                if (nativeDevice) {
+                    DeviceSelectionOptions creationOptions = new DeviceSelectionOptions();
+                    creationOptions.setBaseDeviceTypeRequested(BaseDeviceType.NATIVE_DEVICE);
+                    d = mDeviceFactory.createRequestedDevice(idevice, creationOptions);
+                } else {
+                    d = mDeviceFactory.createDevice(idevice);
+                }
                 if (setTracking) {
                     d.setTrackingSerial(serial);
                 }
diff --git a/src/com/android/tradefed/device/NativeDevice.java b/src/com/android/tradefed/device/NativeDevice.java
index 5c21fb74d..3f4c8d4ba 100644
--- a/src/com/android/tradefed/device/NativeDevice.java
+++ b/src/com/android/tradefed/device/NativeDevice.java
@@ -37,6 +37,7 @@ import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.IWifiHelper.WifiConnectionResult;
+import com.android.tradefed.device.TestDeviceOptions.InstanceType;
 import com.android.tradefed.device.cloud.GceAvdInfo;
 import com.android.tradefed.device.connection.AbstractConnection;
 import com.android.tradefed.device.connection.DefaultConnection;
@@ -61,6 +62,7 @@ import com.android.tradefed.result.StubTestRunListener;
 import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.result.ddmlib.TestRunToTestInvocationForwarder;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.result.error.ErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain;
@@ -68,6 +70,7 @@ import com.android.tradefed.util.ArrayUtil;
 import com.android.tradefed.util.Bugreport;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.DeviceInspectionResult;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.KeyguardControllerState;
@@ -208,7 +211,8 @@ public class NativeDevice
     /** The time in ms to wait for a 'long' command to complete. */
     private long mLongCmdTimeout = 25 * 60 * 1000L;
 
-
+    /** The time in ms to pause after a trade-in mode reboot. */
+    private long mTradeInModePause = 6000;
 
     /**
      * The delimiter that separates the actual shell output and the exit status.
@@ -645,17 +649,13 @@ public class NativeDevice
                     recoverDevice();
                 } else {
                     if (mStateMonitor.waitForDeviceOnline() == null) {
-                        CLog.w(
-                                "Waited for device %s to be online but it is in state '%s', cannot "
-                                        + "get property %s.",
-                                getSerialNumber(), getDeviceState(), name);
-                        CLog.w(
-                                new RuntimeException(
-                                        "This is not an actual exception but to help"
-                                                + " debugging. If this happens deterministically, "
-                                                + " it means the caller has wrong assumption of "
-                                                + " device state and is wasting time in waiting."));
-                        return null;
+                        String message =
+                                String.format(
+                                        "Waited for device %s to be online but it is in state '%s',"
+                                                + " cannot get property %s.",
+                                        getSerialNumber(), getDeviceState(), name);
+                        CLog.w(message);
+                        throw new DeviceNotAvailableException(message, getSerialNumber());
                     }
                 }
             }
@@ -2801,6 +2801,15 @@ public class NativeDevice
             try {
                 mRecovery.recoverDevice(mStateMonitor, mRecoveryMode.equals(RecoveryMode.ONLINE));
             } catch (DeviceUnresponsiveException due) {
+                // Default error identifier to DEVICE_UNAVAILABLE
+                ErrorIdentifier errorIdentifier = DeviceErrorIdentifier.DEVICE_UNAVAILABLE;
+                DeviceInspectionResult inspectionResult = debugDeviceNotAvailable();
+                String extraErrorMessage = "";
+                if (inspectionResult != null && inspectionResult.getErrorIdentifier() != null) {
+                    errorIdentifier = inspectionResult.getErrorIdentifier();
+                    extraErrorMessage =
+                            String.format(" Extra details: %s", inspectionResult.getDetails());
+                }
                 RecoveryMode previousRecoveryMode = mRecoveryMode;
                 mRecoveryMode = RecoveryMode.NONE;
                 try {
@@ -2820,14 +2829,21 @@ public class NativeDevice
                                 || adbException.wasErrorDuringDeviceSelection()) {
                             // Upgrade exception to DNAE to reflect gravity
                             throw new DeviceNotAvailableException(
-                                    cause.getMessage(),
+                                    String.format("%s%s", cause.getMessage(), extraErrorMessage),
                                     adbException,
                                     getSerialNumber(),
-                                    DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
+                                    errorIdentifier);
                         }
                     }
                 }
                 mRecoveryMode = previousRecoveryMode;
+                if (inspectionResult != null && inspectionResult.getErrorIdentifier() != null) {
+                    throw new DeviceNotAvailableException(
+                            String.format("%s%s", due.getMessage(), extraErrorMessage),
+                            due,
+                            getSerialNumber(),
+                            errorIdentifier);
+                }
                 throw due;
             }
             if (mRecoveryMode.equals(RecoveryMode.AVAILABLE)) {
@@ -3649,8 +3665,12 @@ public class NativeDevice
 
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope("reboot_in_" + mode.toString())) {
+            String fastbootSerial = getFastbootSerialNumber();
             // Update fastboot serial number before entering fastboot mode
-            mStateMonitor.setFastbootSerialNumber(getFastbootSerialNumber());
+            mStateMonitor.setFastbootSerialNumber(fastbootSerial);
+            if (!fastbootSerial.equals(getSerialNumber())) {
+                CLog.d("Using serial '%s' for fastboot detection.", fastbootSerial);
+            }
 
             // If we go to bootloader, it's probably for flashing so ensure we re-check the provider
             mShouldSkipContentProviderSetup = false;
@@ -3815,6 +3835,8 @@ public class NativeDevice
             throws DeviceNotAvailableException {
         long rebootStart = System.currentTimeMillis();
         try (CloseableTraceScope ignored = new CloseableTraceScope("rebootUntilOnline")) {
+            // Force wait to commit the image before the reboot
+            waitForSnapuserd(SnapuserdWaitPhase.BLOCK_BEFORE_RELEASING);
             // Invalidate cache before reboots
             mPropertiesCache.invalidateAll();
             doReboot(RebootMode.REBOOT_FULL, reason);
@@ -4538,11 +4560,22 @@ public class NativeDevice
 
         mFastbootSerialNumber = getLinkLocalIpv6FastbootSerial();
         if (mFastbootSerialNumber != null) {
+            CLog.i(
+                    "Device %s's fastboot serial number is %s",
+                    getSerialNumber(), mFastbootSerialNumber);
             return mFastbootSerialNumber;
         }
 
         // Fallback to the same serial over TCP. Used for emulator cases (i.e Cuttlefish).
-        mFastbootSerialNumber = "tcp:" + getSerialNumber();
+        if (getOptions().getInstanceType().equals(InstanceType.CUTTLEFISH)
+                || getOptions().getInstanceType().equals(InstanceType.REMOTE_AVD)) {
+            CLog.d("Maintaining port for cuttlefish.");
+            mFastbootSerialNumber = "tcp:" + getSerialNumber();
+        } else {
+            // 5554 is the default fastboot port
+            String hostname = getSerialNumber().split(":")[0];
+            mFastbootSerialNumber = "tcp:" + hostname + ":5554";
+        }
 
         CLog.i(
                 "Device %s's fastboot serial number is %s",
@@ -5072,6 +5105,8 @@ public class NativeDevice
      */
     @Override
     public void remountSystemWritable() throws DeviceNotAvailableException {
+        // Need to ensure snapuserd is finished before remounting
+        waitForSnapuserd(SnapuserdWaitPhase.BLOCK_BEFORE_RELEASING);
         String verity = getProperty("partition.system.verified");
         // have the property set (regardless state) implies verity is enabled, so we send adb
         // command to disable verity
@@ -5088,6 +5123,8 @@ public class NativeDevice
     /** {@inheritDoc} */
     @Override
     public void remountVendorWritable() throws DeviceNotAvailableException {
+        // Need to ensure snapuserd is finished before remounting
+        waitForSnapuserd(SnapuserdWaitPhase.BLOCK_BEFORE_RELEASING);
         String verity = getProperty("partition.vendor.verified");
         // have the property set (regardless state) implies verity is enabled, so we send adb
         // command to disable verity
@@ -5355,10 +5392,17 @@ public class NativeDevice
                     getDeviceDescriptor(),
                     InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
         }
-        initializeConnection(info, attributes);
+        if (getOptions().shouldUseConnection()) {
+            initializeConnection(info, attributes);
+        }
     }
 
-    protected void initializeConnection(IBuildInfo info, MultiMap<String, String> attributes)
+    /**
+     * Initialize the connection to the device. This is called by
+     * preInvocationSetup but in rare cases might need to be called separately
+     * when creating the connection during device setup.
+     */
+    public void initializeConnection(IBuildInfo info, MultiMap<String, String> attributes)
             throws DeviceNotAvailableException, TargetSetupError {
         try (CloseableTraceScope ignored = new CloseableTraceScope("initializeConnection")) {
             ConnectionBuilder builder =
@@ -5395,6 +5439,7 @@ public class NativeDevice
         getConnection().tearDownConnection();
         mConnectionAvd = null;
         mDeviceActionReceivers.clear();
+        mFastbootSerialNumber = null;
         // Default implementation
         if (getIDevice() instanceof StubDevice) {
             return;
@@ -6241,6 +6286,77 @@ public class NativeDevice
         }
     }
 
+    /**
+     * Enable testing trade-in mode. The device will be wiped and will reboot.
+     *
+     * @throws DeviceNotAvailableException
+     */
+    @Override
+    public boolean startTradeInModeTesting(final int timeoutMs) throws DeviceNotAvailableException {
+        if (!enableAdbRoot()) {
+            CLog.w("Trade in mode requires root.");
+            return false;
+        }
+
+        final CommandResult result =
+                executeShellV2Command(
+                        "tradeinmode wait-until-ready testing start",
+                        timeoutMs,
+                        TimeUnit.MILLISECONDS);
+        if (!checkTradeInModeStartResult(result)) {
+            CLog.w("tradeinmode start didn't succeed");
+            return false;
+        }
+        // Wait a few seconds before issuing more commands.
+        getRunUtil().sleep(mTradeInModePause);
+        RecoveryMode mode = getRecoveryMode();
+        try {
+            setRecoveryMode(RecoveryMode.NONE);
+            // TIM does not support normal ADB commands so we must not accidentally go into the
+            // recovery flow.
+            IDevice online = mStateMonitor.waitForDeviceOnline(timeoutMs);
+            if (online != null) {
+                return true;
+            }
+            CLog.w("Device did not come online after tradeinmode start request");
+            return false;
+        } finally {
+            setRecoveryMode(mode);
+        }
+    }
+
+    private boolean checkTradeInModeStartResult(CommandResult result) {
+        if (CommandStatus.SUCCESS.equals(result.getStatus())) {
+            return true;
+        }
+        if (CommandStatus.FAILED.equals(result.getStatus())) {
+            // If adb manages to disconnect fast enough, we'll get 255 as an exit code.
+            final int exitCode = result.getExitCode().intValue();
+            return exitCode == 0 || exitCode == 255;
+        }
+        return false;
+    }
+
+    /** Stop trade-in mode testing. */
+    @Override
+    public void stopTradeInModeTesting() throws DeviceNotAvailableException {
+        // Either: we're still in trade-in mode, or we just factory reset and we're still in
+        // SUW.
+        CommandResult evaluateResult =
+                executeShellV2Command("tradeinmode wait-until-ready evaluate");
+        if (!CommandStatus.SUCCESS.equals(evaluateResult.getStatus())) {
+            CLog.w("tradeinmode evaluate didn't succeed");
+        }
+        getRunUtil().sleep(mTradeInModePause);
+        CommandResult stopResult =
+                executeShellV2Command("tradeinmode wait-until-ready testing stop");
+        if (!CommandStatus.SUCCESS.equals(stopResult.getStatus())) {
+            CLog.w("tradeinmode stop didn't succeed");
+        }
+        getRunUtil().sleep(mTradeInModePause);
+        waitForDeviceAvailable();
+    }
+
     /**
      * Notifies all {@link IDeviceActionReceiver} about reboot start event.
      *
@@ -6335,4 +6451,9 @@ public class NativeDevice
     public void invalidatePropertyCache() {
         mPropertiesCache.invalidateAll();
     }
+
+    @Override
+    public DeviceInspectionResult debugDeviceNotAvailable() {
+        return null;
+    }
 }
diff --git a/src/com/android/tradefed/device/TestDevice.java b/src/com/android/tradefed/device/TestDevice.java
index d784ec998..460979b79 100644
--- a/src/com/android/tradefed/device/TestDevice.java
+++ b/src/com/android/tradefed/device/TestDevice.java
@@ -3016,7 +3016,19 @@ public class TestDevice extends NativeDevice {
                 TestDeviceOptions.INSTANCE_TYPE_OPTION, getOptions().getInstanceType().toString());
         microdroid.setTestDeviceOptions(builder.mTestDeviceOptions);
         ((IManagedTestDevice) microdroid).setIDevice(new RemoteAvdIDevice(microdroidSerial));
-        adbConnectToMicrodroid(cid, microdroidSerial, vmAdbPort, builder.mAdbConnectTimeoutMs);
+
+        try {
+            adbConnectToMicrodroid(cid, microdroidSerial, vmAdbPort, builder.mAdbConnectTimeoutMs);
+        } catch (DeviceRuntimeException e) {
+            // Before passing the exception, try to pull logs to see what went wrong
+            try {
+                executor.shutdownNow();
+                executor.awaitTermination(2L, TimeUnit.MINUTES);
+            } catch (InterruptedException ex) {
+            }
+            throw e;
+        }
+
         microdroid.setMicrodroidProcess(process);
         try {
             // TODO: Pass the build info
diff --git a/src/com/android/tradefed/device/cloud/CommonLogRemoteFileUtil.java b/src/com/android/tradefed/device/cloud/CommonLogRemoteFileUtil.java
index 712f624eb..2a519182d 100644
--- a/src/com/android/tradefed/device/cloud/CommonLogRemoteFileUtil.java
+++ b/src/com/android/tradefed/device/cloud/CommonLogRemoteFileUtil.java
@@ -277,8 +277,29 @@ public class CommonLogRemoteFileUtil {
      */
     public static boolean isRemoteGceReachableBySsh(
             GceAvdInfo gceAvd, TestDeviceOptions options, IRunUtil runUtil) {
+        return isRemoteGceReachableBySsh(gceAvd, options, runUtil, "");
+    }
+
+    /**
+     * Execute a command to validate the ssh connection to the remote GCE instance.
+     *
+     * @param gceAvd The {@link GceAvdInfo} that describe the device.
+     * @param options a {@link TestDeviceOptions} describing the device options to be used for the
+     *     GCE device.
+     * @param runUtil a {@link IRunUtil} to execute commands.
+     * @param command The command to be executed.
+     * @return A boolean which indicate whether the remote GCE is reachable by ssh.
+     */
+    public static boolean isRemoteGceReachableBySsh(
+            GceAvdInfo gceAvd, TestDeviceOptions options, IRunUtil runUtil, String... command) {
+        List<String> cmd = new ArrayList<>();
+        for (String cmdOption : command) {
+            cmd.add(cmdOption);
+        }
+        cmd.add("exit");
         CommandStatus sshAttemptStatus =
-                RemoteSshUtil.remoteSshCommandExec(gceAvd, options, runUtil, 10000, "exit")
+                RemoteSshUtil.remoteSshCommandExec(
+                                gceAvd, options, runUtil, 10000, cmd.toArray(new String[0]))
                         .getStatus();
         if (!CommandStatus.SUCCESS.equals(sshAttemptStatus)) {
             CLog.e(
@@ -392,7 +413,23 @@ public class CommonLogRemoteFileUtil {
      * @param logger The {@link ITestLogger} where to log the file.
      */
     public static void pullCommonCvdLogs(
-            GceAvdInfo gceAvdInfo, HostOrchestratorUtil hOUtil, ITestLogger logger) {
+            GceAvdInfo gceAvdInfo, HostOrchestratorUtil hoUtil, ITestLogger logger) {
+        pullCommonCvdLogs(gceAvdInfo, hoUtil, logger, null);
+    }
+
+    /**
+     * Pull CF logs via Host Orchestrator.
+     *
+     * @param gceAvdInfo The descriptor of the remote instance.
+     * @param hOUtil The {@link HostOrchestratorUtil} used to pull CF logs.
+     * @param logger The {@link ITestLogger} where to log the file.
+     * @param options The {@link TestDeviceOptions} describing the device options
+     */
+    public static void pullCommonCvdLogs(
+            GceAvdInfo gceAvdInfo,
+            HostOrchestratorUtil hOUtil,
+            ITestLogger logger,
+            TestDeviceOptions options) {
         if (hOUtil == null || gceAvdInfo == null || gceAvdInfo.hostAndPort() == null) {
             CLog.e(
                     "HostOrchestratorUtil, GceAvdInfo or its host setting was null, cannot collect"
@@ -406,17 +443,22 @@ public class CommonLogRemoteFileUtil {
         } else {
             CLog.i("CVD Logs is null, no logs collected from host orchestrator.");
         }
+
         File tempFile =
-                hOUtil.collectLogByCommand("host_kernel", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
-        GceManager.logAndDeleteFile(tempFile, "host_kernel", logger);
-        tempFile = hOUtil.collectLogByCommand("host_orchestrator", HostOrchestratorUtil.URL_HO_LOG);
+                hOUtil.downloadLogFile("host_orchestrator", HostOrchestratorUtil.URL_HO_LOG);
         GceManager.logAndDeleteFile(tempFile, "host_orchestrator", logger);
-        tempFile = hOUtil.getTunnelLog();
-        GceManager.logAndDeleteFile(tempFile, "host_orchestrator_tunnel_log", logger);
-        tempFile =
-                hOUtil.collectLogByCommand(
-                        "oxygen_container_log", HostOrchestratorUtil.URL_OXYGEN_CONTAINER_LOG);
-        GceManager.logAndDeleteFile(tempFile, "oxygen_container_log", logger);
+        // The following logs endpoints are only available using the Cuttlefish Host Image.
+        if (options != null && options.useOxygenationDevice()) {
+            tempFile =
+                    hOUtil.downloadLogFile("host_kernel", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+            GceManager.logAndDeleteFile(tempFile, "host_kernel", logger);
+            tempFile = hOUtil.getTunnelLog();
+            GceManager.logAndDeleteFile(tempFile, "host_orchestrator_tunnel_log", logger);
+            tempFile =
+                    hOUtil.downloadLogFile(
+                            "oxygen_container_log", HostOrchestratorUtil.URL_OXYGEN_CONTAINER_LOG);
+            GceManager.logAndDeleteFile(tempFile, "oxygen_container_log", logger);
+        }
     }
 
     /**
diff --git a/src/com/android/tradefed/device/cloud/GceManager.java b/src/com/android/tradefed/device/cloud/GceManager.java
index afb98053f..9df6449f7 100644
--- a/src/com/android/tradefed/device/cloud/GceManager.java
+++ b/src/com/android/tradefed/device/cloud/GceManager.java
@@ -31,6 +31,7 @@ import com.android.tradefed.result.ByteArrayInputStreamSource;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.error.ErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
@@ -41,8 +42,8 @@ import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.avd.AcloudUtil;
-import com.android.tradefed.util.avd.HostOrchestratorClient;
 import com.android.tradefed.util.avd.HostOrchestratorUtil;
+import com.android.tradefed.util.avd.InspectionUtil;
 import com.android.tradefed.util.avd.LogCollector;
 import com.android.tradefed.util.avd.OxygenClient;
 
@@ -95,7 +96,6 @@ public class GceManager {
                             InfraErrorIdentifier.OXYGEN_SERVER_CONNECTION_FAILURE,
                             InfraErrorIdentifier.OXYGEN_SERVER_LB_CONNECTION_ERROR,
                             InfraErrorIdentifier.OXYGEN_SERVER_SHUTTING_DOWN));
-
     private static final int MAX_LEASE_RETRIES = 3;
     private DeviceDescriptor mDeviceDescriptor;
     private TestDeviceOptions mDeviceOptions;
@@ -104,6 +104,7 @@ public class GceManager {
     private String mGceInstanceName = null;
     private String mGceHost = null;
     private GceAvdInfo mGceAvdInfo = null;
+    private HostOrchestratorUtil mHOUtil = null;
 
     private boolean mSkipSerialLogCollection = false;
 
@@ -316,7 +317,8 @@ public class GceManager {
                             getTestDeviceOptions().getOxygenLeaseLength(),
                             getTestDeviceOptions().getExtraOxygenArgs(),
                             attributes,
-                            getTestDeviceOptions().getGceCmdTimeout());
+                            getTestDeviceOptions().getGceCmdTimeout(),
+                            getTestDeviceOptions().useOxygenationDevice());
             gceAvdInfos = GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mDeviceOptions);
             mGceAvdInfo = gceAvdInfos.get(0);
             return gceAvdInfos;
@@ -411,9 +413,8 @@ public class GceManager {
                                 + getTestDeviceOptions().getGceCmdTimeout()
                                 - System.currentTimeMillis();
                 startTime = System.currentTimeMillis();
-                HostOrchestratorUtil hOUtil = null;
                 if (getTestDeviceOptions().useCvdCF()) {
-                    hOUtil =
+                    mHOUtil =
                             new HostOrchestratorUtil(
                                     getTestDeviceOptions().useOxygenationDevice(),
                                     getTestDeviceOptions().getExtraOxygenArgs(),
@@ -424,9 +425,8 @@ public class GceManager {
                                     mGceAvdInfo.getOxygenationDeviceId(),
                                     OxygenUtil.getTargetRegion(getTestDeviceOptions()),
                                     getTestDeviceOptions().getOxygenAccountingUser(),
-                                    oxygenClient,
-                                    new HostOrchestratorClient.HoHttpClient());
-                    bootSuccess = hOUtil.deviceBootCompleted(timeout);
+                                    oxygenClient);
+                    bootSuccess = mHOUtil.deviceBootCompleted(timeout);
                 } else {
                     final String remoteFile =
                             CommonLogRemoteFileUtil.OXYGEN_EMULATOR_LOG_DIR
@@ -457,13 +457,23 @@ public class GceManager {
                 if (!bootSuccess) {
                     if (logger != null) {
                         if (getTestDeviceOptions().useCvdCF()) {
-                            CommonLogRemoteFileUtil.pullCommonCvdLogs(mGceAvdInfo, hOUtil, logger);
+                            CommonLogRemoteFileUtil.pullCommonCvdLogs(
+                                    mGceAvdInfo, mHOUtil, logger, getTestDeviceOptions());
                         } else {
                             CommonLogRemoteFileUtil.fetchCommonFiles(
                                     logger, mGceAvdInfo, getTestDeviceOptions(), getRunUtil());
                         }
                     }
-                    mGceAvdInfo.setErrorType(InfraErrorIdentifier.OXYGEN_DEVICE_LAUNCHER_TIMEOUT);
+
+                    String errorSignatures =
+                            InvocationMetricLogger.getInvocationMetrics()
+                                    .get(InvocationMetricKey.DEVICE_ERROR_SIGNATURES.toString());
+                    ErrorIdentifier errorIdentifier =
+                            InspectionUtil.convertErrorSignatureToIdentifier(errorSignatures);
+                    if (errorIdentifier == null) {
+                        errorIdentifier = InfraErrorIdentifier.OXYGEN_DEVICE_LAUNCHER_TIMEOUT;
+                    }
+                    mGceAvdInfo.setErrorType(errorIdentifier);
                     mGceAvdInfo.setStatus(GceStatus.BOOT_FAIL);
                     // Align the error message raised when Oxygen lease timed out.
                     mGceAvdInfo.setErrors("Timed out waiting for virtual device to start.");
@@ -843,6 +853,10 @@ public class GceManager {
             if (res || notFromGceAvd) {
                 mBuildInfo.addBuildAttribute(GCE_INSTANCE_CLEANED_KEY, "true");
             }
+            if (!res && !notFromGceAvd) {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.ACLOUD_DEVICE_RELEASE_FAILURE_COUNT, 1);
+            }
             return res;
         } finally {
             mGceAvdInfo = null;
@@ -989,7 +1003,7 @@ public class GceManager {
         }
         String adbTool = "./bin/adb";
         String output;
-        if (options.useOxygen()) {
+        if (options.useOxygen() && !options.useOxygenationDevice()) {
             adbTool = "./tools/dynamic_adb_tool";
             // Make sure the Oxygen device is connected.
             output =
@@ -1002,7 +1016,7 @@ public class GceManager {
         }
 
         // TODO(b/280177749): Remove the special logic after Oxygen side is cleaned up.
-        if (options.useOxygen()) {
+        if (options.useOxygen() && options.useOxygenationDevice()) {
             output =
                     remoteSshCommandExec(
                             gceAvd,
@@ -1032,7 +1046,7 @@ public class GceManager {
         }
         String deviceFilePath = match.group(2);
         String pullOutput;
-        if (options.useOxygen()) {
+        if (options.useOxygen() && options.useOxygenationDevice()) {
             pullOutput =
                     remoteSshCommandExec(
                             gceAvd,
@@ -1114,17 +1128,11 @@ public class GceManager {
                 return false;
             }
             // Search log files for known failures for devices hosted by Oxygen and ARM server
-            if ((options.useOxygen() || InstanceType.GCE.equals(options.getInstanceType()))
+            if ((options.useOxygen()
+                            || InstanceType.GCE.equals(options.getInstanceType())
+                            || InstanceType.CUTTLEFISH.equals(options.getInstanceType()))
                     && remoteFile != null) {
-                try (CloseableTraceScope ignore =
-                        new CloseableTraceScope("avd:collectErrorSignature")) {
-                    List<String> signatures = LogCollector.collectErrorSignatures(remoteFile);
-                    if (signatures.size() > 0) {
-                        InvocationMetricLogger.addInvocationMetrics(
-                                InvocationMetricKey.DEVICE_ERROR_SIGNATURES,
-                                String.join(",", signatures));
-                    }
-                }
+                collectErrorSignatures(remoteFile);
             }
             if (options.useOxygen() && remoteFile != null) {
                 try (CloseableTraceScope ignore =
@@ -1159,6 +1167,10 @@ public class GceManager {
                     RemoteFileUtil.fetchRemoteFile(
                             gceAvd, options, runUtil, REMOTE_FILE_OP_TIMEOUT, remoteFilePath);
             if (remoteFile != null) {
+                if (InstanceType.GCE.equals(options.getInstanceType())
+                        || InstanceType.CUTTLEFISH.equals(options.getInstanceType())) {
+                    collectErrorSignatures(remoteFile);
+                }
                 logFile(remoteFile, baseName, logger, type);
                 return true;
             }
@@ -1166,15 +1178,26 @@ public class GceManager {
         return false;
     }
 
+    private static void collectErrorSignatures(File remoteFile) {
+        try (CloseableTraceScope ignore = new CloseableTraceScope("avd:collectErrorSignature")) {
+            List<String> signatures = LogCollector.collectErrorSignatures(remoteFile);
+            if (signatures.size() > 0) {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.DEVICE_ERROR_SIGNATURES, String.join(",", signatures));
+            }
+        }
+    }
+
     public static void logDirectory(
             File remoteDirectory, String baseName, ITestLogger logger, LogDataType type) {
         for (File f : remoteDirectory.listFiles()) {
             if (f.isFile()) {
                 LogDataType typeFromName = OxygenUtil.getDefaultLogType(f.getName());
-                if (!typeFromName.equals(LogDataType.UNKNOWN)) {
-                    type = typeFromName;
+                if (typeFromName.equals(LogDataType.UNKNOWN)) {
+                    // Use default LogDataType
+                    typeFromName = type;
                 }
-                logFile(f, baseName, logger, type);
+                logFile(f, baseName, logger, typeFromName);
             } else if (f.isDirectory()) {
                 logDirectory(f, baseName, logger, type);
             }
@@ -1294,6 +1317,11 @@ public class GceManager {
         return RunUtil.getDefault();
     }
 
+    /** Returns the instance of the {@link com.android.tradefed.util.avd.HostOrchestratorUtil}. */
+    public HostOrchestratorUtil getHostOrchestratorUtil() {
+        return mHOUtil;
+    }
+
     /**
      * Log the serial output of a device described by {@link GceAvdInfo}.
      *
diff --git a/src/com/android/tradefed/device/cloud/ManagedRemoteDevice.java b/src/com/android/tradefed/device/cloud/ManagedRemoteDevice.java
index 682f3aeff..3060d24d6 100644
--- a/src/com/android/tradefed/device/cloud/ManagedRemoteDevice.java
+++ b/src/com/android/tradefed/device/cloud/ManagedRemoteDevice.java
@@ -16,19 +16,11 @@
 package com.android.tradefed.device.cloud;
 
 import com.android.ddmlib.IDevice;
-import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.build.IBuildInfo;
-import com.android.tradefed.config.Configuration;
-import com.android.tradefed.config.ConfigurationException;
-import com.android.tradefed.config.DynamicRemoteFileResolver;
-import com.android.tradefed.config.IConfiguration;
-import com.android.tradefed.config.OptionCopier;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.IDeviceMonitor;
 import com.android.tradefed.device.IDeviceStateMonitor;
 import com.android.tradefed.device.TestDevice;
-import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.ITestLoggerReceiver;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.MultiMap;
@@ -40,9 +32,6 @@ import com.android.tradefed.util.MultiMap;
  */
 public class ManagedRemoteDevice extends TestDevice implements ITestLoggerReceiver {
 
-    private TestDeviceOptions mCopiedOptions;
-    private IConfiguration mValidationConfig;
-
     /**
      * Creates a {@link ManagedRemoteDevice}.
      *
@@ -58,42 +47,13 @@ public class ManagedRemoteDevice extends TestDevice implements ITestLoggerReceiv
     @Override
     public void preInvocationSetup(IBuildInfo info, MultiMap<String, String> attributes)
             throws TargetSetupError, DeviceNotAvailableException {
-        mCopiedOptions = null;
         super.preInvocationSetup(info, attributes);
     }
 
     /** {@inheritDoc} */
     @Override
     public void postInvocationTearDown(Throwable exception) {
-        // Reset the internal variable
-        mCopiedOptions = null;
-        if (mValidationConfig != null) {
-            mValidationConfig.cleanConfigurationData();
-            mValidationConfig = null;
-        }
         // Ensure parent postInvocationTearDown is always called.
         super.postInvocationTearDown(exception);
     }
-
-    /**
-     * Override the base getter to be able to resolve dynamic options before attempting to do the
-     * remote setup.
-     */
-    @Override
-    public TestDeviceOptions getOptions() {
-        if (mCopiedOptions == null) {
-            CLog.d("Copying TestDeviceOptions for dynamic configs.");
-            mCopiedOptions = new TestDeviceOptions();
-            TestDeviceOptions options = super.getOptions();
-            OptionCopier.copyOptionsNoThrow(options, mCopiedOptions);
-            mValidationConfig = new Configuration("validation", "validation");
-            mValidationConfig.setDeviceOptions(mCopiedOptions);
-            try {
-                mValidationConfig.resolveDynamicOptions(new DynamicRemoteFileResolver());
-            } catch (BuildRetrievalError | ConfigurationException e) {
-                throw new RuntimeException(e);
-            }
-        }
-        return mCopiedOptions;
-    }
 }
diff --git a/src/com/android/tradefed/device/cloud/RemoteAndroidVirtualDevice.java b/src/com/android/tradefed/device/cloud/RemoteAndroidVirtualDevice.java
index 8ecaef450..f55fcb2f1 100644
--- a/src/com/android/tradefed/device/cloud/RemoteAndroidVirtualDevice.java
+++ b/src/com/android/tradefed/device/cloud/RemoteAndroidVirtualDevice.java
@@ -27,6 +27,7 @@ import com.android.tradefed.device.connection.DefaultConnection;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.DeviceInspectionResult;
 
 import java.io.File;
 import java.util.List;
@@ -127,4 +128,16 @@ public class RemoteAndroidVirtualDevice extends RemoteAndroidDevice {
                 "RemoteAndroidVirtualDevice#powerwash should never be called. Only connection"
                         + " one should be invoked.");
     }
+
+    @Override
+    public DeviceInspectionResult debugDeviceNotAvailable() {
+        InstanceType type = getOptions().getInstanceType();
+        if (InstanceType.CUTTLEFISH.equals(type) || InstanceType.REMOTE_NESTED_AVD.equals(type)) {
+            if (getConnection() instanceof AdbSshConnection) {
+                return ((AdbSshConnection) getConnection()).debugDeviceNotAvailable();
+            }
+        }
+        CLog.d("Inspection for RemoteAndroidVirtualDevice of type %s is not implemented.", type);
+        return null;
+    }
 }
diff --git a/src/com/android/tradefed/device/cloud/RemoteSshUtil.java b/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
index 74c0da26e..edaf207ce 100644
--- a/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
+++ b/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
@@ -47,12 +47,16 @@ public class RemoteSshUtil {
             OutputStream stdout,
             OutputStream stderr,
             String... command) {
+        String hostName =
+                options.useOxygenationDevice()
+                        ? "localhost"
+                        : remoteInstance.hostAndPort().getHost();
         List<String> sshCmd =
                 GceRemoteCmdFormatter.getSshCommand(
                         options.getSshPrivateKeyPath(),
                         null,
                         options.getInstanceUser(),
-                        remoteInstance.hostAndPort().getHost(),
+                        hostName,
                         command);
         return runUtil.runTimedCmd(timeoutMs, stdout, stderr, sshCmd.toArray(new String[0]));
     }
diff --git a/src/com/android/tradefed/device/connection/AdbSshConnection.java b/src/com/android/tradefed/device/connection/AdbSshConnection.java
index 31dab99bf..4f6e2bec4 100644
--- a/src/com/android/tradefed/device/connection/AdbSshConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbSshConnection.java
@@ -43,28 +43,34 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ByteArrayInputStreamSource;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.ErrorIdentifier;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.DeviceInspectionResult;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.StreamUtil;
-import com.android.tradefed.util.avd.HostOrchestratorClient;
 import com.android.tradefed.util.avd.HostOrchestratorUtil;
+import com.android.tradefed.util.avd.InspectionUtil;
+import com.android.tradefed.util.avd.OxygenClient;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
 
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.TimeUnit;
 
 /** Adb connection over an ssh bridge. */
@@ -285,7 +291,8 @@ public class AdbSshConnection extends AdbTcpConnection {
                     CLog.d("Device log collection is skipped per SkipDeviceLogCollection setting.");
                 } else if (getDevice().getOptions().useCvdCF()) {
                     mHOUtil = createHostOrchestratorUtil(mGceAvd);
-                    CommonLogRemoteFileUtil.pullCommonCvdLogs(mGceAvd, mHOUtil, getLogger());
+                    CommonLogRemoteFileUtil.pullCommonCvdLogs(
+                            mGceAvd, mHOUtil, getLogger(), getDevice().getOptions());
                 } else if (mGceAvd.hostAndPort() != null) {
                     // Host and port can be null in case of acloud timeout
                     // attempt to get a bugreport if Gce Avd is a failure
@@ -361,6 +368,9 @@ public class AdbSshConnection extends AdbTcpConnection {
                 getGceHandler().cleanUp();
             }
         } finally {
+            if (mHOUtil != null && getDevice().getOptions().useCvdCF()) {
+                mHOUtil.closeTunnelConnection();
+            }
             super.tearDownConnection();
         }
     }
@@ -407,6 +417,17 @@ public class AdbSshConnection extends AdbTcpConnection {
             }
         }
         if (mGceAvd == null) {
+            // Override error identifier if error signature invocation metrics has more specific
+            // error.
+            String errorSignatures =
+                    InvocationMetricLogger.getInvocationMetrics()
+                            .get(InvocationMetricKey.DEVICE_ERROR_SIGNATURES.toString());
+            ErrorIdentifier errorIdentifier =
+                    InspectionUtil.convertErrorSignatureToIdentifier(errorSignatures);
+            if (errorIdentifier != null) {
+                exception =
+                        new TargetSetupError(exception.getMessage(), exception, errorIdentifier);
+            }
             throw exception;
         } else {
             CLog.i("GCE AVD has been started: %s", mGceAvd);
@@ -414,16 +435,35 @@ public class AdbSshConnection extends AdbTcpConnection {
                     (mGceAvd.getErrorType() != null)
                             ? mGceAvd.getErrorType()
                             : DeviceErrorIdentifier.FAILED_TO_LAUNCH_GCE;
+            // Inspect host to get more accurate error identifier
+            DeviceInspectionResult inspectionResult = null;
+            String errorMsg = null;
+            if (GceAvdInfo.GceStatus.BOOT_FAIL.equals(mGceAvd.getStatus())
+                    || GceAvdInfo.GceStatus.FAIL.equals(mGceAvd.getStatus())) {
+                inspectionResult = debugDeviceNotAvailable();
+                // Only override error identifier if it's not a generic one.
+                if ((errorIdentifier == InfraErrorIdentifier.OXYGEN_DEVICE_LAUNCHER_TIMEOUT
+                                || errorIdentifier == DeviceErrorIdentifier.FAILED_TO_LAUNCH_GCE)
+                        && inspectionResult != null
+                        && inspectionResult.getErrorIdentifier() != null) {
+                    errorMsg = inspectionResult.getDetails();
+                    errorIdentifier = inspectionResult.getErrorIdentifier();
+                }
+            }
             if (GceAvdInfo.GceStatus.BOOT_FAIL.equals(mGceAvd.getStatus())) {
-                String errorMsg =
-                        String.format(
-                                "Device failed to boot. Error from device leasing attempt: %s",
-                                mGceAvd.getErrors());
+                if (Strings.isNullOrEmpty(errorMsg)) {
+                    errorMsg =
+                            String.format(
+                                    "Device failed to boot. Error from device leasing attempt: %s",
+                                    mGceAvd.getErrors());
+                }
                 throw new TargetSetupError(
                         errorMsg, getDevice().getDeviceDescriptor(), errorIdentifier);
             } else if (GceAvdInfo.GceStatus.FAIL.equals(mGceAvd.getStatus())) {
                 throw new TargetSetupError(
-                        mGceAvd.getErrors(), getDevice().getDeviceDescriptor(), errorIdentifier);
+                        Strings.isNullOrEmpty(errorMsg) ? mGceAvd.getErrors() : errorMsg,
+                        getDevice().getDeviceDescriptor(),
+                        errorIdentifier);
             }
         }
         createGceTunnelMonitor(getDevice(), buildInfo, mGceAvd, getDevice().getOptions());
@@ -497,14 +537,6 @@ public class AdbSshConnection extends AdbTcpConnection {
         return mGceHandler;
     }
 
-    /**
-     * Returns the instance of the {@link com.android.tradefed.device.cloud.HostOrchestratorUtil}.
-     */
-    @VisibleForTesting
-    HostOrchestratorUtil getHostOrchestratorUtil() {
-        return mHOUtil;
-    }
-
     /** Capture a remote bugreport by ssh-ing into the device directly. */
     public void getSshBugreport() {
         if (mGceAvd == null) {
@@ -872,7 +904,7 @@ public class AdbSshConnection extends AdbTcpConnection {
         long startTime = System.currentTimeMillis();
         CommandResult stopRes = null;
         if (getDevice().getOptions().useCvdCF()) {
-            stopRes = mHOUtil.stopGce();
+            stopRes = mHOUtil.removeInstance();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
@@ -1001,10 +1033,10 @@ public class AdbSshConnection extends AdbTcpConnection {
     }
 
     /** Helper to create host orchestrator utility. */
-    HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
-        if (mHOUtil != null) {
+    public HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
+        if (getGceHandler().getHostOrchestratorUtil() != null) {
             CLog.i("Host Orchestrator Util has been initialized...");
-            return mHOUtil;
+            return getGceHandler().getHostOrchestratorUtil();
         }
         if (getDevice().getOptions().useCvdCF()) {
             CLog.i("Creating host orchestrator utility...");
@@ -1020,9 +1052,239 @@ public class AdbSshConnection extends AdbTcpConnection {
                             OxygenUtil.getTargetRegion(getDevice().getOptions()),
                             getDevice().getOptions().getOxygenAccountingUser(),
                             OxygenUtil.createOxygenClient(
-                                    getDevice().getOptions().getAvdDriverBinary()),
-                            new HostOrchestratorClient.HoHttpClient());
+                                    getDevice().getOptions().getAvdDriverBinary()));
         }
         return mHOUtil;
     }
+
+    /**
+     * Inspect host VM and retrieve more details in DeviceInspectionResult.
+     *
+     * @return {@link DeviceInspectionResult}
+     */
+    public DeviceInspectionResult debugDeviceNotAvailable() {
+
+        if (!getDevice().getOptions().useOxygen()
+                && !getDevice().getOptions().useOxygenationDevice()) {
+            // TODO(dshi): support acloud and ARM setup
+            CLog.d("Acloud setup is not supported yet, skipping device inspection.");
+            return null;
+        }
+
+        String sshPortNumber = null;
+        OxygenClient oxygenClient = null;
+        Process sshTunnel = null;
+        DeviceInspectionResult inspectionResult = null;
+        File sshTunnelLog = null;
+        try {
+            if (getDevice().getOptions().useOxygenationDevice()) {
+                oxygenClient = createOxygenClient();
+                sshPortNumber = Integer.toString(oxygenClient.createServerSocket());
+                FileOutputStream sshTunnelLogStream = null;
+                try {
+                    sshTunnelLog = FileUtil.createTempFile("ssh-connection", ".txt");
+                    sshTunnelLogStream = new FileOutputStream(sshTunnelLog, true);
+                } catch (IOException e) {
+                    FileUtil.deleteFile(sshTunnelLog);
+                    CLog.e(e);
+                }
+                sshTunnel =
+                        oxygenClient.createTunnelViaLHP(
+                                OxygenClient.LHPTunnelMode.SSH,
+                                sshPortNumber,
+                                mGceAvd.instanceName(),
+                                mGceAvd.hostAndPort() != null
+                                        ? mGceAvd.hostAndPort().getHost()
+                                        : null,
+                                OxygenUtil.getTargetRegion(getDevice().getOptions()),
+                                getDevice().getOptions().getOxygenAccountingUser(),
+                                mGceAvd.getOxygenationDeviceId(),
+                                getDevice().getOptions().getExtraOxygenArgs(),
+                                sshTunnelLogStream);
+                if (sshTunnel == null || !sshTunnel.isAlive()) {
+                    CLog.d("Ssh tunnel isn't ready, skipping device inspection.");
+                    return null;
+                }
+            }
+
+            String cmd = getSshCommand("", sshPortNumber);
+            boolean isGceReachable =
+                    CommonLogRemoteFileUtil.isRemoteGceReachableBySsh(
+                            mGceAvd, getDevice().getOptions(), getRunUtil(), cmd.split(" "));
+            if (!isGceReachable) {
+                CLog.e(
+                        "Failed to establish ssh connect to remote file host, skipping device "
+                                + "inspection.");
+                return null;
+            }
+
+            // Collect host status and running processes
+            cmd = getSshCommand("df -P /", sshPortNumber);
+            // Check if disk is full
+            CommandResult res =
+                    GceManager.remoteSshCommandExecution(
+                            mGceAvd,
+                            getDevice().getOptions(),
+                            getRunUtil(),
+                            10000L,
+                            cmd.split(" "));
+            if (!CommandStatus.SUCCESS.equals(res.getStatus())) {
+                CLog.e(
+                        "Failed to get disk space information: stdout: %s\nstderr: %s",
+                        res.getStdout(), res.getStderr());
+            } else {
+                String diskspaceInfo = res.getStdout().trim();
+                CLog.d("Disk space usage on the host:\n%s", diskspaceInfo);
+                Optional<Integer> usedPercentage = InspectionUtil.getDiskspaceUsage(diskspaceInfo);
+                if (usedPercentage.isPresent()
+                        && usedPercentage.get() > InspectionUtil.DISK_USAGE_MAX) {
+                    if (inspectionResult == null) {
+                        inspectionResult =
+                                new DeviceInspectionResult(
+                                        InfraErrorIdentifier.NO_DISK_SPACE,
+                                        String.format(
+                                                "Host disk space availability is low, current usage"
+                                                        + " is at %d%%",
+                                                usedPercentage.get()));
+                    }
+                }
+            }
+            String baseCmd = "top -bn1";
+            if (getDevice().getOptions().useOxygenationDevice()) {
+                baseCmd = "top -bcn1 -w 512";
+            }
+            // Collect host status and running processes
+            cmd = getSshCommand(baseCmd, sshPortNumber);
+            // toybox is only for Oxygen host vm.
+            if (getDevice().getOptions().useOxygen()
+                    && !getDevice().getOptions().useOxygenationDevice()) {
+                cmd = "toybox " + cmd;
+            }
+            res =
+                    GceManager.remoteSshCommandExecution(
+                            mGceAvd,
+                            getDevice().getOptions(),
+                            getRunUtil(),
+                            10000L,
+                            cmd.split(" "));
+            if (!CommandStatus.SUCCESS.equals(res.getStatus())) {
+                CLog.e(
+                        "Failed to get host running processes. stdout: %s\nstderr: %s",
+                        res.getStdout(), res.getStderr());
+            } else {
+                String processes = res.getStdout().trim();
+                try (final InputStreamSource source =
+                        new ByteArrayInputStreamSource(processes.getBytes())) {
+                    getLogger().testLog("host_vm_processes", LogDataType.TEXT, source);
+                }
+
+                // Check unexpected processes first. If any unexpected process presents, the process
+                // is likely hang or takes too long to finish, which indicate some infra issue.
+                for (String p : InspectionUtil.UNEXPECTED_PROCESSES.keySet()) {
+                    if (InspectionUtil.searchProcess(processes, p)) {
+                        CLog.e(
+                                "Found unexpected process %s. Review `host_vm_processes` log for"
+                                        + " the complete list of running processes.",
+                                p);
+                        if (inspectionResult == null) {
+                            inspectionResult =
+                                    new DeviceInspectionResult(
+                                            InspectionUtil.UNEXPECTED_PROCESSES.get(p),
+                                            String.format("Unexpected process %s found", p));
+                        }
+                    }
+                }
+
+                for (String p : InspectionUtil.EXPECTED_PROCESSES.keySet()) {
+                    if (!InspectionUtil.searchProcess(processes, p)) {
+                        CLog.e(
+                                "Failed to locate process %s. Review `host_vm_processes` log for"
+                                        + " the complete list of running processes.",
+                                p);
+                        if (inspectionResult == null) {
+                            inspectionResult =
+                                    new DeviceInspectionResult(
+                                            InspectionUtil.EXPECTED_PROCESSES.get(p),
+                                            String.format("Expected process %s not found", p));
+                        }
+                    }
+                }
+            }
+
+            if (getDevice().getOptions().useOxygenationDevice()) {
+                CLog.d("Collecting bugreportz in Oxygenation is not supported yet, skipping...");
+            } else {
+                // Check if device is available through adb
+                String adb = "adb";
+                if (getDevice().getOptions().useOxygen()
+                        && !getDevice().getOptions().useOxygenationDevice()) {
+                    adb = "/tools/dynamic_adb_tool";
+                }
+                cmd = String.format("%s start-server && sleep 5 && %s devices", adb, adb);
+                cmd = getSshCommand(cmd, sshPortNumber);
+                res =
+                        GceManager.remoteSshCommandExecution(
+                                mGceAvd,
+                                getDevice().getOptions(),
+                                getRunUtil(),
+                                10000L,
+                                cmd.split(" "));
+                if (!CommandStatus.SUCCESS.equals(res.getStatus())) {
+                    CLog.e(
+                            "Failed to run adb command to list devices: stdout: %s\nstderr: %s",
+                            res.getStdout(), res.getStderr());
+                } else {
+                    String devices = res.getStdout().trim();
+                    CLog.d("Available devices:\n%s", devices);
+                    if (devices.indexOf("127.0.0.1:") == -1
+                            && devices.indexOf("localhost:") == -1
+                            && devices.indexOf("0.0.0.0:") == -1) {
+                        CLog.e("No adb devices found on the host.");
+                        if (inspectionResult == null) {
+                            return new DeviceInspectionResult(
+                                    DeviceErrorIdentifier.DEVICE_UNAVAILABLE,
+                                    "No adb devices found on the host.");
+                        }
+                    } else {
+                        // Collect bugreport as the device is available with adb
+                        try {
+                            File bugreport =
+                                    GceManager.getNestedDeviceSshBugreportz(
+                                            mGceAvd, getDevice().getOptions(), getRunUtil());
+                            GceManager.logAndDeleteFile(
+                                    bugreport, "bugreport-ssh.zip", getLogger());
+                        } catch (IOException e) {
+                            CLog.e(e);
+                        }
+                    }
+                }
+            }
+
+            if (inspectionResult == null) {
+                CLog.d("Device inspection did not find the cause of device failure.");
+            }
+            return inspectionResult;
+        } finally {
+            if (getDevice().getOptions().useOxygenationDevice()
+                    && oxygenClient != null
+                    && sshTunnelLog != null) {
+                oxygenClient.closeLHPConnection(sshTunnel);
+                GceManager.logAndDeleteFile(sshTunnelLog, "ssh_tunnel_log", getLogger());
+            }
+        }
+    }
+
+    /** Helper to compile a ssh command. */
+    private String getSshCommand(String baseCmd, String sshPortNumber) {
+        if (getDevice().getOptions().useOxygenationDevice()) {
+            baseCmd = String.format("-p %s %s", sshPortNumber, baseCmd);
+        }
+        return baseCmd;
+    }
+
+    /** Helper to create an Oxygen Client. */
+    @VisibleForTesting
+    OxygenClient createOxygenClient() {
+        return OxygenUtil.createOxygenClient(getDevice().getOptions().getAvdDriverBinary());
+    }
 }
diff --git a/src/com/android/tradefed/device/connection/AdbTcpConnection.java b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
index b513d74e2..739b6579e 100644
--- a/src/com/android/tradefed/device/connection/AdbTcpConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
@@ -16,14 +16,17 @@
 package com.android.tradefed.device.connection;
 
 import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.IManagedTestDevice;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.RemoteAndroidDevice;
+import com.android.tradefed.device.RemoteAvdIDevice;
 import com.android.tradefed.device.internal.DeviceResetHandler;
 import com.android.tradefed.device.internal.DeviceSnapshotHandler;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
@@ -72,10 +75,36 @@ public class AdbTcpConnection extends DefaultConnection {
         return mInvocationSnapshots;
     }
 
+    @Override
+    public void initializeConnection() throws TargetSetupError, DeviceNotAvailableException {
+        super.initializeConnection();
+        if (wasPreExisting()) {
+            int port = 5555;
+            if (getInitialDeviceNumOffset() != null) {
+                port += getInitialDeviceNumOffset();
+            }
+            String serial = getInitialIp() + ":" + Integer.toString(port);
+            adbTcpDisconnect(getInitialIp(), Integer.toString(port));
+            ((IManagedTestDevice) getDevice())
+                    .setIDevice(new RemoteAvdIDevice(serial, getInitialIp()));
+            reconnect(serial);
+        }
+    }
+
     @Override
     public void tearDownConnection() {
         super.tearDownConnection();
         FileUtil.deleteFile(mAdbConnectLogs);
+        if (wasPreExisting()) {
+            // Resotre the placeholder
+            ((IManagedTestDevice) getDevice())
+                    .setIDevice(
+                            new RemoteAvdIDevice(
+                                    getInitialSerial(),
+                                    getInitialIp(),
+                                    getInitialUser(),
+                                    getInitialDeviceNumOffset()));
+        }
     }
 
     @Override
@@ -131,6 +160,12 @@ public class AdbTcpConnection extends DefaultConnection {
      */
     public boolean adbTcpConnect(String host, String port) {
         try (CloseableTraceScope ignored = new CloseableTraceScope("adbTcpConnect")) {
+            String adbConnectionLogMsg =
+                    mAdbConnectLogs == null
+                            ? ""
+                            : String.format(
+                                    " Found more details in adb connection log: %s",
+                                    mAdbConnectLogs);
             for (int i = 0; i < MAX_RETRIES; i++) {
                 CommandResult result = adbConnect(host, port);
                 CLog.d(
@@ -148,11 +183,17 @@ public class AdbTcpConnection extends DefaultConnection {
                         && result.getStdout().contains(ADB_CONN_REFUSED)) {
                     // If we find "Connection Refused", we bail out directly as more connect won't
                     // help
+                    CLog.e(
+                            "Adb connection to %s:%s was refused.%s",
+                            host, port, adbConnectionLogMsg);
                     return false;
                 }
                 CLog.d("adb connect retrying");
                 getRunUtil().sleep((i + 1) * RETRY_INTERVAL_MS);
             }
+            CLog.e(
+                    "All attempts to connect to %s:%s with adb failed.%s",
+                    host, port, adbConnectionLogMsg);
             return false;
         }
     }
diff --git a/src/com/android/tradefed/device/connection/DefaultConnection.java b/src/com/android/tradefed/device/connection/DefaultConnection.java
index d406431ca..a0f138b91 100644
--- a/src/com/android/tradefed/device/connection/DefaultConnection.java
+++ b/src/com/android/tradefed/device/connection/DefaultConnection.java
@@ -23,6 +23,7 @@ import com.android.tradefed.device.ManagedTestDeviceFactory;
 import com.android.tradefed.device.NativeDevice;
 import com.android.tradefed.device.NullDevice;
 import com.android.tradefed.device.RemoteAndroidDevice;
+import com.android.tradefed.device.RemoteAvdIDevice;
 import com.android.tradefed.device.TestDeviceOptions.InstanceType;
 import com.android.tradefed.device.cloud.GceAvdInfo;
 import com.android.tradefed.device.cloud.RemoteAndroidVirtualDevice;
@@ -46,6 +47,7 @@ public class DefaultConnection extends AbstractConnection {
     private final Integer mInitialDeviceNumOffset;
     private final String mInitialSerial;
     private final ITestLogger mTestLogger;
+    private final boolean mPreExisting;
 
     private final boolean mTemporaryHolder;
 
@@ -61,26 +63,31 @@ public class DefaultConnection extends AbstractConnection {
         }
 
         final InstanceType type = device.getOptions().getInstanceType();
-        CLog.d("Instance type for connection: %s", type);
-
-        final boolean isCuttlefish = type.equals(InstanceType.CUTTLEFISH)
-                || type.equals(InstanceType.REMOTE_NESTED_AVD);
-
-        if (device instanceof RemoteAndroidVirtualDevice) {
-            ((NativeDevice) device).setFastbootEnabled(isCuttlefish);
-            ((NativeDevice) device).setLogStartDelay(0);
-            return new AdbSshConnection(builder);
-        }
-        if (device instanceof RemoteAndroidDevice) {
-            return new AdbTcpConnection(builder);
+        final boolean isRemoteAvd =
+                type.equals(InstanceType.CUTTLEFISH) || type.equals(InstanceType.REMOTE_NESTED_AVD);
+        if (!device.getOptions().evaluateDeviceConnection()) {
+            CLog.d("Instance type for connection: %s", type);
+            if (device instanceof RemoteAndroidVirtualDevice) {
+                ((NativeDevice) device).setFastbootEnabled(isRemoteAvd);
+                ((NativeDevice) device).setLogStartDelay(0);
+                return new AdbSshConnection(builder);
+            }
+            if (device instanceof RemoteAndroidDevice) {
+                return new AdbTcpConnection(builder);
+            }
         }
 
-        CLog.d("Instance type for connection: %s", type);
-        if (isCuttlefish) {
+        CLog.d("Instance type for connection: %s. Evaluating for connection type.", type);
+        if (isRemoteAvd) {
             if (ManagedTestDeviceFactory.isTcpDeviceSerial(device.getSerialNumber())) {
                 // TODO: Add support for remote environment
                 // If the device is already started just go for TcpConnection
                 return new AdbTcpConnection(builder);
+            } else if (type.equals(InstanceType.REMOTE_NESTED_AVD)
+                    && device.getIDevice() instanceof RemoteAvdIDevice
+                    && ((RemoteAvdIDevice) device.getIDevice()).getKnownDeviceIp() != null) {
+                builder.markPreexisting();
+                return new AdbTcpConnection(builder);
             } else {
                 ((NativeDevice) device).setLogStartDelay(0);
                 return new AdbSshConnection(builder);
@@ -99,6 +106,7 @@ public class DefaultConnection extends AbstractConnection {
         IRunUtil runUtil;
         ITestLogger logger;
         GceAvdInfo existingAvdInfo;
+        boolean preExisting;
 
         public ConnectionBuilder(
                 IRunUtil runUtil, ITestDevice device, IBuildInfo buildInfo, ITestLogger logger) {
@@ -118,6 +126,11 @@ public class DefaultConnection extends AbstractConnection {
             existingAvdInfo = info;
             return this;
         }
+
+        public ConnectionBuilder markPreexisting() {
+            preExisting = true;
+            return this;
+        }
     }
 
     /** Constructor */
@@ -129,6 +142,7 @@ public class DefaultConnection extends AbstractConnection {
         IDevice idevice = mDevice.getIDevice();
         mInitialSerial = mDevice.getSerialNumber();
         mTestLogger = builder.logger;
+        mPreExisting = builder.preExisting;
         if (idevice instanceof IConfigurableVirtualDevice) {
             mInitialIpDevice = ((IConfigurableVirtualDevice) idevice).getKnownDeviceIp();
             mInitialUser = ((IConfigurableVirtualDevice) idevice).getKnownUser();
@@ -192,4 +206,8 @@ public class DefaultConnection extends AbstractConnection {
     public boolean wasTemporaryHolder() {
         return mTemporaryHolder;
     }
+
+    public boolean wasPreExisting() {
+        return mPreExisting;
+    }
 }
diff --git a/src/com/android/tradefed/device/metric/AutoLogCollector.java b/src/com/android/tradefed/device/metric/AutoLogCollector.java
index 264d424f0..053c50c71 100644
--- a/src/com/android/tradefed/device/metric/AutoLogCollector.java
+++ b/src/com/android/tradefed/device/metric/AutoLogCollector.java
@@ -22,6 +22,8 @@ public enum AutoLogCollector {
     BUGREPORTZ_ON_FAILURE(BugreportzOnFailureCollector.class),
     BUGREPORTZ_ON_TESTCASE_FAILURE(BugreportzOnTestCaseFailureCollector.class),
     CLANG_COVERAGE(ClangCodeCoverageCollector.class),
+    // TODO: Remove this temporary value after the new collector is verified to work as expected.
+    CODE_COVERAGE(CodeCoverageCollector.class),
     GCOV_COVERAGE(GcovCodeCoverageCollector.class),
     GCOV_KERNEL_COVERAGE(GcovKernelCodeCoverageCollector.class),
     HOSTLOG_ON_FAILURE(DebugHostLogOnFailureCollector.class),
diff --git a/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java b/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
index b2145f848..032cdafda 100644
--- a/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
+++ b/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
@@ -41,6 +41,7 @@ import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
 
 import java.io.File;
 import java.io.IOException;
@@ -690,6 +691,23 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
      *         if file not found.
      */
     private File resolveRelativeFilePath(String fileName) {
+        File src = null;
+        try {
+            src = SearchArtifactUtil.searchFile(fileName, true);
+        } catch (Exception e) {
+            // TODO: handle error when migration is complete.
+            CLog.e(e);
+        }
+        if (src != null && src.exists()) {
+            CLog.d("Found '%s' using SearchArtifactUtil", fileName);
+            return src;
+        } else {
+            CLog.d("Did not find '%s' using SearchArtifactUtil, fall back to old logic", fileName);
+            // Silently report not found and fall back to old logic.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, 1);
+        }
+
         IBuildInfo buildInfo = getBuildInfos().get(0);
         String mModuleName = null;
         // Retrieve the module name.
@@ -698,7 +716,6 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
                     .get(0);
         }
 
-        File src = null;
         if (buildInfo != null) {
             src = buildInfo.getFile(fileName);
             if (src != null && src.exists()) {
@@ -772,6 +789,13 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
                 }
             }
         }
+
+        if (src == null) {
+            // if old logic fails too, do not report search artifact failure
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, -1);
+        }
+
         return src;
     }
 
diff --git a/src/com/android/tradefed/device/metric/ClangCodeCoverageCollector.java b/src/com/android/tradefed/device/metric/ClangCodeCoverageCollector.java
index 1f784e95a..899de6729 100644
--- a/src/com/android/tradefed/device/metric/ClangCodeCoverageCollector.java
+++ b/src/com/android/tradefed/device/metric/ClangCodeCoverageCollector.java
@@ -20,7 +20,6 @@ import static com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain.C
 
 import static com.google.common.base.Verify.verifyNotNull;
 
-import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
@@ -270,21 +269,7 @@ public final class ClangCodeCoverageCollector extends BaseDeviceMetricCollector
                 return mLlvmProfileTool;
             }
         }
-        try {
-            // TODO: Delete this, we shouldn't have re-entry in the build
-            // provider this can cause quite a lot of overhead.
-            IBuildInfo buildInfo = mConfiguration.getBuildProvider().getBuild();
-            profileToolZip =
-                    verifyNotNull(
-                            buildInfo.getFile("llvm-profdata.zip"),
-                            "Could not get llvm-profdata.zip from the build.");
-            mLlvmProfileTool = ZipUtil.extractZipToTemp(profileToolZip, "llvm-profdata");
-            return mLlvmProfileTool;
-        } catch (BuildRetrievalError e) {
-            throw new RuntimeException(e);
-        } finally {
-            FileUtil.deleteFile(profileToolZip);
-        }
+        return mLlvmProfileTool;
     }
 
     private void setCoverageOptions(CoverageOptions coverageOptions) {
diff --git a/src/com/android/tradefed/device/metric/CodeCoverageCollector.java b/src/com/android/tradefed/device/metric/CodeCoverageCollector.java
new file mode 100644
index 000000000..45cb01c11
--- /dev/null
+++ b/src/com/android/tradefed/device/metric/CodeCoverageCollector.java
@@ -0,0 +1,500 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.metric;
+
+import static com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain.CLANG;
+
+import static com.google.common.base.Verify.verifyNotNull;
+import static com.google.common.io.Files.getNameWithoutExtension;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.testtype.coverage.CoverageOptions;
+import com.android.tradefed.util.AdbRootElevator;
+import com.android.tradefed.util.ClangProfileIndexer;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.JavaCodeCoverageFlusher;
+import com.android.tradefed.util.NativeCodeCoverageFlusher;
+import com.android.tradefed.util.ProcessInfo;
+import com.android.tradefed.util.PsParser;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.TarUtil;
+import com.android.tradefed.util.ZipUtil;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Splitter;
+import com.google.common.base.Strings;
+
+import org.jacoco.core.tools.ExecFileLoader;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A {@link com.android.tradefed.device.metric.BaseDeviceMetricCollector} that will pull Java and
+ * native coverage measurements off of the device and log them as test artifacts.
+ */
+public final class CodeCoverageCollector extends BaseDeviceMetricCollector
+        implements IConfigurationReceiver {
+
+    public static final String COVERAGE_MEASUREMENT_KEY = "coverageFilePath";
+    public static final String COVERAGE_DIRECTORY = "/data/misc/trace";
+    public static final String FIND_COVERAGE_FILES =
+            String.format("find %s -name '*.ec'", COVERAGE_DIRECTORY);
+    public static final String COMPRESS_COVERAGE_FILES =
+            String.format("%s | tar -czf - -T - 2>/dev/null", FIND_COVERAGE_FILES);
+
+    // Finds .profraw files and compresses those files only. Stores the full
+    // path of the file on the device.
+    private static final String ZIP_CLANG_FILES_COMMAND_FORMAT =
+            "find %s -name '*.profraw' | tar -czf - -T - 2>/dev/null";
+
+    // Deletes .profraw files in the directory.
+    private static final String DELETE_COVERAGE_FILES_COMMAND_FORMAT =
+            "find %s -name '*.profraw' -delete";
+
+    private ExecFileLoader mExecFileLoader;
+
+    private JavaCodeCoverageFlusher mJavaFlusher;
+
+    private IRunUtil mRunUtil = RunUtil.getDefault();
+    private NativeCodeCoverageFlusher mClangFlusher;
+    private File mLlvmProfileTool;
+
+    private IConfiguration mConfiguration;
+    // Timeout for pulling cross-process coverage files from the device, in milliseconds.
+    private long mTimeoutMilli = 20 * 60 * 1000;
+
+    @Override
+    public void extraInit(IInvocationContext context, ITestInvocationListener listener)
+            throws DeviceNotAvailableException {
+        super.extraInit(context, listener);
+
+        verifyNotNull(mConfiguration);
+        setCoverageOptions(mConfiguration.getCoverageOptions());
+
+        boolean initJavaCoverage = isJavaCoverageEnabled();
+        boolean initClangCoverage = isClangCoverageEnabled();
+
+        if (!initJavaCoverage && !initClangCoverage) {
+            return;
+        }
+
+        if (mConfiguration.getCoverageOptions().shouldResetCoverageBeforeTest()) {
+            for (ITestDevice device : getRealDevices()) {
+                try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
+                    if (initJavaCoverage) {
+                        getJavaCoverageFlusher(device).resetCoverage();
+                    }
+                    if (initClangCoverage) {
+                        getNativeCoverageFlusher(device).deleteCoverageMeasurements();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
+
+    @Override
+    public void rebootEnded(ITestDevice device) throws DeviceNotAvailableException {
+        if (isClangCoverageEnabled()
+                && mConfiguration.getCoverageOptions().shouldResetCoverageBeforeTest()) {
+            getNativeCoverageFlusher(device).deleteCoverageMeasurements();
+        }
+    }
+
+    @Override
+    public void onTestRunEnd(DeviceMetricData runData, final Map<String, Metric> runMetrics)
+            throws DeviceNotAvailableException {
+        if (!isJavaCoverageEnabled() && !isClangCoverageEnabled()) {
+            return;
+        }
+
+        String testCoveragePath = null;
+
+        if (isJavaCoverageEnabled()) {
+            // Get the path of the coverage measurement on the device.
+            Metric devicePathMetric = runMetrics.get(COVERAGE_MEASUREMENT_KEY);
+            if (devicePathMetric == null) {
+                CLog.d("No Java code coverage measurement.");
+            } else {
+                testCoveragePath = devicePathMetric.getMeasurements().getSingleString();
+                if (testCoveragePath == null) {
+                    CLog.d("No Java code coverage measurement.");
+                }
+            }
+        }
+
+        for (ITestDevice device : getRealDevices()) {
+            File testCoverage = null;
+            File coverageTarGz = null;
+            File untarDir = null;
+
+            try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
+                try {
+                    if (mConfiguration.getCoverageOptions().isCoverageFlushEnabled()) {
+                        if (isJavaCoverageEnabled()) {
+                            getJavaCoverageFlusher(device).forceCoverageFlush();
+                        }
+                        if (isClangCoverageEnabled()) {
+                            getNativeCoverageFlusher(device).forceCoverageFlush();
+                        }
+                    }
+
+                    if (isJavaCoverageEnabled()) {
+                        // Pull and log the test coverage file.
+                        if (testCoveragePath != null) {
+                            if (!new File(testCoveragePath).isAbsolute()) {
+                                testCoveragePath =
+                                        "/sdcard/googletest/internal_use/" + testCoveragePath;
+                            }
+                            testCoverage = device.pullFile(testCoveragePath);
+                            if (testCoverage == null) {
+                                // Log a warning only, since multi-device tests will not have this
+                                // file on all devices.
+                                CLog.w(
+                                        "Failed to pull test coverage file %s from the device.",
+                                        testCoveragePath);
+                            } else {
+                                saveJavaCoverageMeasurement(testCoverage);
+                            }
+                        }
+
+                        // Stream compressed coverage measurements from /data/misc/trace to the
+                        // host.
+                        coverageTarGz = FileUtil.createTempFile("java_coverage", ".tar.gz");
+                        try (OutputStream out =
+                                new BufferedOutputStream(new FileOutputStream(coverageTarGz))) {
+                            CommandResult result =
+                                    device.executeShellV2Command(
+                                            COMPRESS_COVERAGE_FILES,
+                                            null,
+                                            out,
+                                            mTimeoutMilli,
+                                            TimeUnit.MILLISECONDS,
+                                            1);
+                            if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
+                                CLog.e(
+                                        "Failed to stream coverage data from the device: %s",
+                                        result.toString());
+                            }
+                        }
+
+                        // Decompress the files and log the measurements.
+                        untarDir = TarUtil.extractTarGzipToTemp(coverageTarGz, "java_coverage");
+                        for (String coveragePath : FileUtil.findFiles(untarDir, ".*\\.ec")) {
+                            saveJavaCoverageMeasurement(new File(coveragePath));
+                        }
+                    }
+                    if (isClangCoverageEnabled()) {
+                        logNativeCoverageMeasurement(device, generateNativeMeasurementFileName());
+                    }
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                } finally {
+                    // Clean up local coverage files.
+                    FileUtil.deleteFile(testCoverage);
+                    FileUtil.deleteFile(coverageTarGz);
+                    FileUtil.recursiveDelete(untarDir);
+
+                    // Clean up device coverage files.
+                    cleanUpDeviceCoverageFiles(device);
+                }
+            }
+        }
+
+        // Log the merged coverage data file if the flag is set.
+        if (shouldMergeCoverage() && (mExecFileLoader != null)) {
+            File mergedCoverage = null;
+            try {
+                mergedCoverage = FileUtil.createTempFile("merged_java_coverage", ".ec");
+                mExecFileLoader.save(mergedCoverage, false);
+                logJavaCoverageMeasurement(mergedCoverage);
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            } finally {
+                mExecFileLoader = null;
+                FileUtil.deleteFile(mergedCoverage);
+            }
+        }
+    }
+
+    @VisibleForTesting
+    void setJavaCoverageFlusher(JavaCodeCoverageFlusher flusher) {
+        mJavaFlusher = flusher;
+    }
+
+    @VisibleForTesting
+    void setClangFlusherRunUtil(IRunUtil runUtil) {
+        mRunUtil = runUtil;
+        if (mClangFlusher != null) {
+            mClangFlusher.setRunUtil(runUtil);
+        }
+    }
+
+    private JavaCodeCoverageFlusher getJavaCoverageFlusher(ITestDevice device) {
+        if (mJavaFlusher == null) {
+            mJavaFlusher =
+                    new JavaCodeCoverageFlusher(
+                            device, mConfiguration.getCoverageOptions().getCoverageProcesses());
+        }
+        return mJavaFlusher;
+    }
+
+    /** Saves Java coverage file data. */
+    private void saveJavaCoverageMeasurement(File coverageFile) throws IOException {
+        if (shouldMergeCoverage()) {
+            if (mExecFileLoader == null) {
+                mExecFileLoader = new ExecFileLoader();
+            }
+            mExecFileLoader.load(coverageFile);
+        } else {
+            logJavaCoverageMeasurement(coverageFile);
+        }
+    }
+
+    /** Logs files as Java coverage measurements. */
+    private void logJavaCoverageMeasurement(File coverageFile) {
+        try (FileInputStreamSource source = new FileInputStreamSource(coverageFile, true)) {
+            testLog(generateJavaMeasurementFileName(coverageFile), LogDataType.COVERAGE, source);
+        }
+    }
+
+    /** Generate the .ec file prefix in format "$moduleName_MODULE_$runName". */
+    private String generateJavaMeasurementFileName(File coverageFile) {
+        String moduleName = Strings.nullToEmpty(getModuleName());
+        if (moduleName.length() > 0) {
+            moduleName += "_MODULE_";
+        }
+        return moduleName
+                + getRunName()
+                + "_"
+                + getNameWithoutExtension(coverageFile.getName())
+                + "_runtime_coverage";
+    }
+
+    /** Cleans up .ec files in /data/misc/trace. */
+    private void cleanUpDeviceCoverageFiles(ITestDevice device) throws DeviceNotAvailableException {
+        List<Integer> activePids = getRunningProcessIds(device);
+
+        String fileList = device.executeShellCommand(FIND_COVERAGE_FILES);
+        for (String devicePath : Splitter.on('\n').omitEmptyStrings().split(fileList)) {
+            if (devicePath.endsWith(".mm.ec")) {
+                // Check if the process was still running. The file will have the format
+                // /data/misc/trace/jacoco-XXXXX.mm.ec where XXXXX is the process id.
+                int start = devicePath.indexOf('-') + 1;
+                int end = devicePath.indexOf('.');
+                int pid = Integer.parseInt(devicePath.substring(start, end));
+                if (!activePids.contains(pid)) {
+                    device.deleteFile(devicePath);
+                }
+            } else {
+                device.deleteFile(devicePath);
+            }
+        }
+    }
+
+    /** Parses the output of `ps -e` to get a list of running process ids. */
+    private List<Integer> getRunningProcessIds(ITestDevice device)
+            throws DeviceNotAvailableException {
+        List<ProcessInfo> processes = PsParser.getProcesses(device.executeShellCommand("ps -e"));
+        List<Integer> pids = new ArrayList<>();
+
+        for (ProcessInfo process : processes) {
+            pids.add(process.getPid());
+        }
+        return pids;
+    }
+
+    private boolean isJavaCoverageEnabled() {
+        return mConfiguration != null
+                && mConfiguration.getCoverageOptions().isCoverageEnabled()
+                && mConfiguration
+                        .getCoverageOptions()
+                        .getCoverageToolchains()
+                        .contains(CoverageOptions.Toolchain.JACOCO);
+    }
+
+    private boolean isClangCoverageEnabled() {
+        return mConfiguration != null
+                && mConfiguration.getCoverageOptions().isCoverageEnabled()
+                && mConfiguration.getCoverageOptions().getCoverageToolchains().contains(CLANG);
+    }
+
+    /**
+     * Creates a {@link NativeCodeCoverageFlusher} if one does not already exist.
+     *
+     * @return a NativeCodeCoverageFlusher
+     */
+    private NativeCodeCoverageFlusher getNativeCoverageFlusher(ITestDevice device) {
+        if (mClangFlusher == null) {
+            verifyNotNull(mConfiguration);
+            mClangFlusher =
+                    new NativeCodeCoverageFlusher(device, mConfiguration.getCoverageOptions());
+            mClangFlusher.setRunUtil(mRunUtil);
+        }
+        return mClangFlusher;
+    }
+
+    /** Generate the .profdata file prefix in format "$moduleName_MODULE_$runName". */
+    private String generateNativeMeasurementFileName() {
+        String moduleName = Strings.nullToEmpty(getModuleName());
+        if (moduleName.length() > 0) {
+            moduleName += "_MODULE_";
+        }
+        return moduleName + getRunName().replace(' ', '_');
+    }
+
+    /**
+     * Logs Clang coverage measurements from the device.
+     *
+     * @param runName name used in the log file
+     * @throws DeviceNotAvailableException
+     * @throws IOException
+     */
+    private void logNativeCoverageMeasurement(ITestDevice device, String runName)
+            throws DeviceNotAvailableException, IOException {
+        Map<String, File> untarDirs = new HashMap<>();
+        File profileTool = null;
+        File indexedProfileFile = null;
+        try {
+            Set<String> rawProfileFiles = new HashSet<>();
+            for (String devicePath : mConfiguration.getCoverageOptions().getDeviceCoveragePaths()) {
+                File coverageTarGz = FileUtil.createTempFile("clang_coverage", ".tar.gz");
+
+                try {
+                    // Compress coverage measurements on the device before streaming to the host.
+                    try (OutputStream out =
+                            new BufferedOutputStream(new FileOutputStream(coverageTarGz))) {
+                        device.executeShellV2Command(
+                                String.format(
+                                        ZIP_CLANG_FILES_COMMAND_FORMAT, devicePath), // Command
+                                null, // File pipe as input
+                                out, // OutputStream to write to
+                                mTimeoutMilli, // Timeout in milliseconds
+                                TimeUnit.MILLISECONDS, // Timeout units
+                                1); // Retry count
+                    }
+
+                    File untarDir = TarUtil.extractTarGzipToTemp(coverageTarGz, "clang_coverage");
+                    untarDirs.put(devicePath, untarDir);
+                    rawProfileFiles.addAll(
+                            FileUtil.findFiles(
+                                    untarDir,
+                                    mConfiguration.getCoverageOptions().getProfrawFilter()));
+                } catch (IOException e) {
+                    CLog.e("Failed to pull Clang coverage data from %s", devicePath);
+                    CLog.e(e);
+                } finally {
+                    FileUtil.deleteFile(coverageTarGz);
+                }
+            }
+
+            if (rawProfileFiles.isEmpty()) {
+                CLog.i("No Clang code coverage measurements found.");
+                return;
+            }
+
+            CLog.i("Received %d Clang code coverage measurements.", rawProfileFiles.size());
+
+            ClangProfileIndexer indexer = new ClangProfileIndexer(getProfileTool(), mRunUtil);
+
+            // Create the output file.
+            indexedProfileFile =
+                    FileUtil.createTempFile(runName + "_clang_runtime_coverage", ".profdata");
+            indexer.index(rawProfileFiles, indexedProfileFile);
+
+            try (FileInputStreamSource source =
+                    new FileInputStreamSource(indexedProfileFile, true)) {
+                testLog(runName + "_clang_runtime_coverage", LogDataType.CLANG_COVERAGE, source);
+            }
+        } finally {
+            // Delete coverage files on the device.
+            for (String devicePath : mConfiguration.getCoverageOptions().getDeviceCoveragePaths()) {
+                device.executeShellCommand(
+                        String.format(DELETE_COVERAGE_FILES_COMMAND_FORMAT, devicePath));
+            }
+            for (File untarDir : untarDirs.values()) {
+                FileUtil.recursiveDelete(untarDir);
+            }
+            FileUtil.recursiveDelete(mLlvmProfileTool);
+            FileUtil.deleteFile(indexedProfileFile);
+        }
+    }
+
+    /**
+     * Retrieves the profile tool and dependencies from the build, and extracts them.
+     *
+     * @return the directory containing the profile tool and dependencies
+     */
+    private File getProfileTool() throws IOException {
+        // If llvm-profdata-path was set in the Configuration, pass it through. Don't save the path
+        // locally since the parent process is responsible for cleaning it up.
+        File configurationTool = mConfiguration.getCoverageOptions().getLlvmProfdataPath();
+        if (configurationTool != null) {
+            return configurationTool;
+        }
+        if (mLlvmProfileTool != null && mLlvmProfileTool.exists()) {
+            return mLlvmProfileTool;
+        }
+
+        // Otherwise, try to download llvm-profdata.zip from the build and cache it.
+        File profileToolZip = null;
+        for (IBuildInfo info : getBuildInfos()) {
+            if (info.getFile("llvm-profdata.zip") != null) {
+                profileToolZip = info.getFile("llvm-profdata.zip");
+                mLlvmProfileTool = ZipUtil.extractZipToTemp(profileToolZip, "llvm-profdata");
+                return mLlvmProfileTool;
+            }
+        }
+        return mLlvmProfileTool;
+    }
+
+    private boolean shouldMergeCoverage() {
+        return mConfiguration != null && mConfiguration.getCoverageOptions().shouldMergeCoverage();
+    }
+
+    private void setCoverageOptions(CoverageOptions coverageOptions) {
+        mTimeoutMilli = coverageOptions.getPullTimeout();
+    }
+}
diff --git a/src/com/android/tradefed/device/metric/FilePullerLogCollector.java b/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
index cebc45bf7..7996c7c0f 100644
--- a/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
+++ b/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
@@ -84,6 +84,9 @@ public class FilePullerLogCollector extends FilePullerDeviceMetricCollector {
             return LogDataType.BT_SNOOP_LOG;
         } else if (".json".equals(ext)) {
             return LogDataType.JSON;
+        } else if (FileUtil.getBaseName(metricFile.getName()).contains("winscope")
+                || FileUtil.getBaseName(metricFile.getName()).contains("uiTrace_")) {
+            return LogDataType.WINSCOPE;
         }
         return LogDataType.TEXT;
     }
diff --git a/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java b/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
index 7e4ac392d..820b87faf 100644
--- a/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
+++ b/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
@@ -140,62 +140,65 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
             File untarDir = null;
 
             try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
-                if (mConfiguration.getCoverageOptions().isCoverageFlushEnabled()) {
-                    getCoverageFlusher(device).forceCoverageFlush();
-                }
-
-                // Pull and log the test coverage file.
-                if (testCoveragePath != null) {
-                    if (!new File(testCoveragePath).isAbsolute()) {
-                        testCoveragePath =
-                                "/sdcard/googletest/internal_use/" + testCoveragePath;
+                try {
+                    if (mConfiguration.getCoverageOptions().isCoverageFlushEnabled()) {
+                        getCoverageFlusher(device).forceCoverageFlush();
                     }
-                    testCoverage = device.pullFile(testCoveragePath);
-                    if (testCoverage == null) {
-                        // Log a warning only, since multi-device tests will not have this file on
-                        // all devices.
-                        CLog.w(
-                                "Failed to pull test coverage file %s from the device.",
-                                testCoveragePath);
-                    } else {
-                        saveCoverageMeasurement(testCoverage);
+
+                    // Pull and log the test coverage file.
+                    if (testCoveragePath != null) {
+                        if (!new File(testCoveragePath).isAbsolute()) {
+                            testCoveragePath =
+                                    "/sdcard/googletest/internal_use/" + testCoveragePath;
+                        }
+                        testCoverage = device.pullFile(testCoveragePath);
+                        if (testCoverage == null) {
+                            // Log a warning only, since multi-device tests will not have this file
+                            // on
+                            // all devices.
+                            CLog.w(
+                                    "Failed to pull test coverage file %s from the device.",
+                                    testCoveragePath);
+                        } else {
+                            saveCoverageMeasurement(testCoverage);
+                        }
                     }
-                }
 
-                // Stream compressed coverage measurements from /data/misc/trace to the host.
-                coverageTarGz = FileUtil.createTempFile("java_coverage", ".tar.gz");
-                try (OutputStream out =
-                        new BufferedOutputStream(new FileOutputStream(coverageTarGz))) {
-                    CommandResult result =
-                            device.executeShellV2Command(
-                                    COMPRESS_COVERAGE_FILES,
-                                    null,
-                                    out,
-                                    mTimeoutMilli,
-                                    TimeUnit.MILLISECONDS,
-                                    1);
-                    if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
-                        CLog.e(
-                                "Failed to stream coverage data from the device: %s",
-                                result.toString());
+                    // Stream compressed coverage measurements from /data/misc/trace to the host.
+                    coverageTarGz = FileUtil.createTempFile("java_coverage", ".tar.gz");
+                    try (OutputStream out =
+                            new BufferedOutputStream(new FileOutputStream(coverageTarGz))) {
+                        CommandResult result =
+                                device.executeShellV2Command(
+                                        COMPRESS_COVERAGE_FILES,
+                                        null,
+                                        out,
+                                        mTimeoutMilli,
+                                        TimeUnit.MILLISECONDS,
+                                        1);
+                        if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
+                            CLog.e(
+                                    "Failed to stream coverage data from the device: %s",
+                                    result.toString());
+                        }
                     }
-                }
 
-                // Decompress the files and log the measurements.
-                untarDir = TarUtil.extractTarGzipToTemp(coverageTarGz, "java_coverage");
-                for (String coveragePath : FileUtil.findFiles(untarDir, ".*\\.ec")) {
-                    saveCoverageMeasurement(new File(coveragePath));
+                    // Decompress the files and log the measurements.
+                    untarDir = TarUtil.extractTarGzipToTemp(coverageTarGz, "java_coverage");
+                    for (String coveragePath : FileUtil.findFiles(untarDir, ".*\\.ec")) {
+                        saveCoverageMeasurement(new File(coveragePath));
+                    }
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                } finally {
+                    // Clean up local coverage files.
+                    FileUtil.deleteFile(testCoverage);
+                    FileUtil.deleteFile(coverageTarGz);
+                    FileUtil.recursiveDelete(untarDir);
+
+                    // Clean up device coverage files.
+                    cleanUpDeviceCoverageFiles(device);
                 }
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            } finally {
-                // Clean up local coverage files.
-                FileUtil.deleteFile(testCoverage);
-                FileUtil.deleteFile(coverageTarGz);
-                FileUtil.recursiveDelete(untarDir);
-
-                // Clean up device coverage files.
-                cleanUpDeviceCoverageFiles(device);
             }
         }
 
@@ -249,23 +252,21 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
 
     /** Cleans up .ec files in /data/misc/trace. */
     private void cleanUpDeviceCoverageFiles(ITestDevice device) throws DeviceNotAvailableException {
-        try (AdbRootElevator root = new AdbRootElevator(device)) {
-            List<Integer> activePids = getRunningProcessIds(device);
-
-            String fileList = device.executeShellCommand(FIND_COVERAGE_FILES);
-            for (String devicePath : Splitter.on('\n').omitEmptyStrings().split(fileList)) {
-                if (devicePath.endsWith(".mm.ec")) {
-                    // Check if the process was still running. The file will have the format
-                    // /data/misc/trace/jacoco-XXXXX.mm.ec where XXXXX is the process id.
-                    int start = devicePath.indexOf('-') + 1;
-                    int end = devicePath.indexOf('.');
-                    int pid = Integer.parseInt(devicePath.substring(start, end));
-                    if (!activePids.contains(pid)) {
-                        device.deleteFile(devicePath);
-                    }
-                } else {
+        List<Integer> activePids = getRunningProcessIds(device);
+
+        String fileList = device.executeShellCommand(FIND_COVERAGE_FILES);
+        for (String devicePath : Splitter.on('\n').omitEmptyStrings().split(fileList)) {
+            if (devicePath.endsWith(".mm.ec")) {
+                // Check if the process was still running. The file will have the format
+                // /data/misc/trace/jacoco-XXXXX.mm.ec where XXXXX is the process id.
+                int start = devicePath.indexOf('-') + 1;
+                int end = devicePath.indexOf('.');
+                int pid = Integer.parseInt(devicePath.substring(start, end));
+                if (!activePids.contains(pid)) {
                     device.deleteFile(devicePath);
                 }
+            } else {
+                device.deleteFile(devicePath);
             }
         }
     }
diff --git a/src/com/android/tradefed/invoker/InvocationCacheHelper.java b/src/com/android/tradefed/invoker/InvocationCacheHelper.java
new file mode 100644
index 000000000..357bff890
--- /dev/null
+++ b/src/com/android/tradefed/invoker/InvocationCacheHelper.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.invoker;
+
+import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
+import com.android.tradefed.cache.ExecutableAction;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.proxy.TradefedDelegator;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.proto.ModuleProtoResultReporter;
+import com.android.tradefed.util.CacheClientFactory;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.QuotationAwareTokenizer;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/** Utility to handle uploading and looking up invocation cache results. */
+public class InvocationCacheHelper {
+
+    /** Describes the cache results. */
+    public static class CacheInvocationResultDescriptor {
+        private final boolean cacheHit;
+        private final String cacheExplanation;
+
+        public CacheInvocationResultDescriptor(boolean cacheHit, String explanation) {
+            this.cacheHit = cacheHit;
+            this.cacheExplanation = explanation;
+        }
+
+        public boolean isCacheHit() {
+            return cacheHit;
+        }
+
+        public String getDetails() {
+            return cacheExplanation;
+        }
+    }
+
+    /**
+     * Upload invocation results
+     *
+     * @param mainConfig
+     * @param protoResults
+     * @param testInfo
+     */
+    public static void uploadInvocationResults(
+            IConfiguration mainConfig, File protoResults, TestInformation testInfo) {
+        if (testInfo.getDevices().size() > 1) {
+            return;
+        }
+        boolean emptyTestsDir = false;
+        File invocationTestsDir = null;
+        if (testInfo.getBuildInfo().getFile(BuildInfoFileKey.ROOT_DIRECTORY) == null
+                || testInfo.getBuildInfo().getFile(BuildInfoFileKey.TESTDIR_IMAGE) == null) {
+            emptyTestsDir = true;
+        }
+        if (!emptyTestsDir
+                && (mainConfig.getSkipManager().getTestArtifactsToDigest().isEmpty()
+                        || mainConfig
+                                .getSkipManager()
+                                .getTestArtifactsToDigest()
+                                .containsValue(null))) {
+            CLog.d("Cannot handle testsdir.");
+            return;
+        }
+        try (CloseableTraceScope ignored = new CloseableTraceScope("upload_invocation_results")) {
+            String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
+            ICacheClient cacheClient =
+                    CacheClientFactory.createCacheClient(
+                            CurrentInvocation.getWorkFolder(), cacheInstance);
+            invocationTestsDir =
+                    FileUtil.createNamedTempDir(CurrentInvocation.getWorkFolder(), "invoc-cache");
+            ExecutableAction action =
+                    ExecutableAction.create(
+                            invocationTestsDir,
+                            getCommonCommandLine(mainConfig.getCommandLine()),
+                            computeEnvironment(mainConfig),
+                            60000L);
+            ExecutableActionResult result = ExecutableActionResult.create(0, protoResults, null);
+            CLog.d("Uploading cache for %s and %s", action, protoResults);
+            cacheClient.uploadCache(action, result);
+        } catch (IOException | RuntimeException | InterruptedException e) {
+            CLog.e(e);
+        } finally {
+            FileUtil.recursiveDelete(invocationTestsDir);
+        }
+    }
+
+    public static CacheInvocationResultDescriptor lookupInvocationResults(
+            IConfiguration mainConfig, TestInformation testInfo) {
+        if (testInfo.getDevices().size() > 1) {
+            return null;
+        }
+        if (mainConfig.getSkipManager().getImageToDigest().containsValue(null)) {
+            CLog.d("No digest for device.");
+            return new CacheInvocationResultDescriptor(false, null);
+        }
+        boolean emptyTestsDir = false;
+        File invocationTestsDir = null;
+        if (testInfo.getBuildInfo().getFile(BuildInfoFileKey.ROOT_DIRECTORY) == null
+                && testInfo.getBuildInfo().getFile(BuildInfoFileKey.TESTDIR_IMAGE) == null) {
+            emptyTestsDir = true;
+        }
+        if (!emptyTestsDir
+                && (mainConfig.getSkipManager().getTestArtifactsToDigest().isEmpty()
+                        || mainConfig
+                                .getSkipManager()
+                                .getTestArtifactsToDigest()
+                                .containsValue(null))) {
+            CLog.d("Cannot handle testsdir.");
+            return new CacheInvocationResultDescriptor(false, null);
+        }
+        try (CloseableTraceScope ignored = new CloseableTraceScope("lookup_invocation_results")) {
+            String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
+            ICacheClient cacheClient =
+                    CacheClientFactory.createCacheClient(
+                            CurrentInvocation.getWorkFolder(), cacheInstance);
+            invocationTestsDir =
+                    FileUtil.createNamedTempDir(CurrentInvocation.getWorkFolder(), "invoc-cache");
+            ExecutableAction action =
+                    ExecutableAction.create(
+                            invocationTestsDir,
+                            getCommonCommandLine(mainConfig.getCommandLine()),
+                            computeEnvironment(mainConfig),
+                            60000L);
+            CLog.d("Looking up cache for %s", action);
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.INVOCATION_RESULTS_CHECKING_CACHE, 1);
+            ExecutableActionResult cachedResults = cacheClient.lookupCache(action);
+            if (cachedResults == null) {
+                CLog.d("No cached results for the invocation.");
+                return null;
+            } else {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.INVOCATION_CACHE_HIT, 1);
+                String details = "Cached results.";
+                Map<String, String> metadata =
+                        ModuleProtoResultReporter.parseResultsMetadata(cachedResults.stdOut());
+                if (metadata.containsKey(ModuleProtoResultReporter.INVOCATION_ID_KEY)) {
+                    details +=
+                            String.format(
+                                    " origin of results: http://ab/%s",
+                                    metadata.get(ModuleProtoResultReporter.INVOCATION_ID_KEY));
+                    CLog.d(details);
+                }
+                FileUtil.deleteFile(cachedResults.stdOut());
+                FileUtil.deleteFile(cachedResults.stdErr());
+                return new CacheInvocationResultDescriptor(true, details);
+            }
+        } catch (IOException | RuntimeException | InterruptedException e) {
+            CLog.e(e);
+        } finally {
+            FileUtil.recursiveDelete(invocationTestsDir);
+        }
+        return null;
+    }
+
+    private static Map<String, String> computeEnvironment(IConfiguration mainConfig) {
+        Map<String, String> environment = new HashMap<>();
+        for (Entry<String, Digest> entry :
+                mainConfig.getSkipManager().getImageToDigest().entrySet()) {
+            environment.put(entry.getKey(), entry.getValue().getHash());
+        }
+        for (Entry<String, Digest> entry :
+                mainConfig.getSkipManager().getTestArtifactsToDigest().entrySet()) {
+            environment.put(entry.getKey(), entry.getValue().getHash());
+        }
+        String atpTestName =
+                mainConfig
+                        .getCommandOptions()
+                        .getInvocationData()
+                        .getUniqueMap()
+                        .get("atp_test_name");
+        if (atpTestName != null) {
+            environment.put("atp_test_name", atpTestName);
+        }
+        // add tradefed.jar version
+        return environment;
+    }
+
+    private static List<String> getCommonCommandLine(String commandLine) {
+        String[] commandArray = QuotationAwareTokenizer.tokenizeLine(commandLine, false);
+        try {
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(commandArray, "invocation-data");
+            commandArray = TradefedDelegator.clearCommandlineFromOneArg(commandArray, "build-id");
+            commandArray = TradefedDelegator.clearCommandlineFromOneArg(commandArray, "serial");
+        } catch (ConfigurationException e) {
+            throw new RuntimeException(e);
+        }
+        return Arrays.asList(commandArray);
+    }
+}
diff --git a/src/com/android/tradefed/invoker/InvocationExecution.java b/src/com/android/tradefed/invoker/InvocationExecution.java
index 20357cfbf..1ebfa7f77 100644
--- a/src/com/android/tradefed/invoker/InvocationExecution.java
+++ b/src/com/android/tradefed/invoker/InvocationExecution.java
@@ -1286,7 +1286,7 @@ public class InvocationExecution implements IInvocationExecution {
                     try {
                         PrettyPrintDelimiter.printStageDelimiter("Starting auto-retry");
                         for (int attemptNumber = 1;
-                                attemptNumber < decision.getMaxRetryCount();
+                                attemptNumber < decision.getMaxTestRunAttempts();
                                 attemptNumber++) {
                             if (!firstCheck) {
                                 boolean retry =
@@ -1324,7 +1324,7 @@ public class InvocationExecution implements IInvocationExecution {
                         // Feed the last attempt if we reached here.
                         decision.addLastAttempt(
                                 mainGranularRunListener.getTestRunForAttempts(
-                                        decision.getMaxRetryCount() - 1));
+                                        decision.getMaxTestRunAttempts() - 1));
                     } finally {
                         RetryStatistics retryStats = decision.getRetryStatistics();
                         // Track how long we spend in retry
diff --git a/src/com/android/tradefed/invoker/TestInvocation.java b/src/com/android/tradefed/invoker/TestInvocation.java
index bdddf0865..82742bad6 100644
--- a/src/com/android/tradefed/invoker/TestInvocation.java
+++ b/src/com/android/tradefed/invoker/TestInvocation.java
@@ -58,6 +58,7 @@ import com.android.tradefed.device.internal.DeviceReleaseReporter;
 import com.android.tradefed.error.HarnessException;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.error.IHarnessException;
+import com.android.tradefed.invoker.InvocationCacheHelper.CacheInvocationResultDescriptor;
 import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.invoker.logger.CurrentInvocation.InvocationInfo;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
@@ -90,6 +91,7 @@ import com.android.tradefed.result.ResultAndLogForwarder;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.ErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.result.proto.InvocationProtoResultReporter;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.retry.IRetryDecision;
@@ -217,6 +219,7 @@ public class TestInvocation implements ITestInvocation {
     private List<IScheduledInvocationListener> mSchedulerListeners = new ArrayList<>();
     private DeviceUnavailableMonitor mUnavailableMonitor = new DeviceUnavailableMonitor();
     private ConditionFailureMonitor mConditionalFailureMonitor = new ConditionFailureMonitor();
+    private InvocationProtoResultReporter mInvocationProtoResultReporter = null;
     private ExitCode mExitCode = ExitCode.NO_ERROR;
     private Throwable mExitStack = null;
     private EventsLoggerListener mEventsLogger = null;
@@ -520,7 +523,8 @@ public class TestInvocation implements ITestInvocation {
                     new CloseableTraceScope(InvocationMetricKey.test_cleanup.name())) {
                 // Clean up host.
                 invocationPath.doCleanUp(context, config, exception);
-                waitForSnapuserd(testInfo, config, SnapuserdWaitPhase.BLOCK_BEFORE_RELEASING);
+                waitForSnapuserd(
+                        testInfo, config, SnapuserdWaitPhase.BLOCK_BEFORE_RELEASING, false);
                 if (mSoftStopRequestTime != null) { // soft stop occurred
                     long latency = System.currentTimeMillis() - mSoftStopRequestTime;
                     InvocationMetricLogger.addInvocationMetrics(
@@ -623,16 +627,23 @@ public class TestInvocation implements ITestInvocation {
             invocationPath.doSetup(testInfo, config, listener);
             // Don't run tests if notified of soft/forced shutdown
             if (mSoftStopRequestTime != null || mStopRequestTime != null) {
-                // Throw an exception so that it can be reported as an invocation failure
-                // and command can be un-leased
-                throw new RunInterruptedException(
-                        "Notified of shut down. Will not run tests",
-                        InfraErrorIdentifier.TRADEFED_SKIPPED_TESTS_DURING_SHUTDOWN);
+                if (System.getenv("IS_CLOUD_ATE") == null) {
+                    // Throw an exception so that it can be reported as an invocation failure
+                    // and command can be un-leased
+                    throw new RunInterruptedException(
+                            "Notified of shut down. Will not run tests",
+                            InfraErrorIdentifier.TRADEFED_SKIPPED_TESTS_DURING_SHUTDOWN);
+                } else {
+                    CLog.d(
+                            "Notified of shut down. Will still run tests and respect grace period"
+                                + " in CI for shutting down.");
+                }
             }
             logDeviceBatteryLevel(testInfo.getContext(), "setup -> test");
             mTestStarted = true;
             CurrentInvocation.setActionInProgress(ActionInProgress.TEST);
-            waitForSnapuserd(testInfo, config, SnapuserdWaitPhase.BLOCK_BEFORE_TEST);
+            waitForSnapuserd(
+                    testInfo, config, SnapuserdWaitPhase.BLOCK_BEFORE_TEST, isSubprocess(config));
             invocationPath.runTests(testInfo, config, listener);
         } finally {
             if (mClient != null) {
@@ -981,10 +992,6 @@ public class TestInvocation implements ITestInvocation {
         DynamicRemoteFileResolver resolver =
                 new DynamicRemoteFileResolver(true /* allow parallelization */);
         try {
-            // Don't resolve for remote invocation, wait until we are inside the remote.
-            if (RunMode.REMOTE_INVOCATION.equals(mode)) {
-                return true;
-            }
             CurrentInvocation.setActionInProgress(ActionInProgress.FETCHING_ARTIFACTS);
             resolver.setDevice(context.getDevices().get(0));
             resolver.addExtraArgs(config.getCommandOptions().getDynamicDownloadArgs());
@@ -1126,6 +1133,13 @@ public class TestInvocation implements ITestInvocation {
             allListeners.addAll(Arrays.asList(extraListeners));
             allListeners.add(mUnavailableMonitor);
             allListeners.add(mConditionalFailureMonitor);
+            if (config.getCommandOptions().shouldUploadInvocationCacheResults()) {
+                mInvocationProtoResultReporter =
+                        new InvocationProtoResultReporter(info.getContext(), false);
+                File outputFile = FileUtil.createTempFile("invocation-results-cache", ".pb");
+                mInvocationProtoResultReporter.setOutputFile(outputFile);
+                allListeners.add(mInvocationProtoResultReporter);
+            }
 
             // Auto retry feature
             IRetryDecision decision = config.getRetryDecision();
@@ -1142,7 +1156,7 @@ public class TestInvocation implements ITestInvocation {
                     .getInvocationData()
                     .containsKey(SubprocessTfLauncher.SUBPROCESS_TAG_NAME)) {
                 if (decision.isAutoRetryEnabled()
-                        && decision.getMaxRetryCount() > 1
+                        && decision.getMaxTestRunAttempts() > 1
                         && !RetryStrategy.NO_RETRY.equals(decision.getRetryStrategy())) {
                     CLog.d(
                             "Auto-retry enabled, using the ResultAggregator to handle multiple"
@@ -1259,7 +1273,23 @@ public class TestInvocation implements ITestInvocation {
                             .getInvocationData()
                             .containsKey(SubprocessTfLauncher.SUBPROCESS_TAG_NAME)
                     && !RunMode.DELEGATED_INVOCATION.equals(mode)) {
-                boolean skipInvocation = config.getSkipManager().shouldSkipInvocation(info);
+                boolean skipInvocation = config.getSkipManager().shouldSkipInvocation(info, config);
+                String skipReason = config.getSkipManager().getInvocationSkipReason();
+                if (!skipInvocation) {
+                    if (config.getCommandOptions().getRemoteCacheInstanceName() != null
+                            && config.getCommandOptions().shouldUploadInvocationCacheResults()) {
+                        CacheInvocationResultDescriptor descriptor =
+                                InvocationCacheHelper.lookupInvocationResults(config, info);
+                        if (descriptor != null && descriptor.isCacheHit()) {
+                            skipReason = descriptor.getDetails();
+                            if (InvocationContext.isPresubmit(context)
+                                    && config.getCommandOptions()
+                                            .reportInvocationCacheResultsInPresubmit()) {
+                                skipInvocation = true;
+                            }
+                        }
+                    }
+                }
                 if (skipInvocation) {
                     CLog.d("Skipping invocation early.");
                     startInvocation(config, info.getContext(), listener);
@@ -1280,11 +1310,16 @@ public class TestInvocation implements ITestInvocation {
                             InvocationMetricKey.TEARDOWN_PAIR, timestamp, timestamp);
                     InvocationMetricLogger.addInvocationPairMetrics(
                             InvocationMetricKey.TEST_TEARDOWN_PAIR, timestamp, timestamp);
-                    listener.invocationSkipped(
-                            new SkipReason(config.getSkipManager().getInvocationSkipReason(), ""));
+                    listener.invocationSkipped(new SkipReason(skipReason, ""));
                     reportModuleSkip(config, listener);
                     reportHostLog(listener, config);
                     reportInvocationEnded(config, info.getContext(), listener, 0L);
+                    // Still upload results for caching
+                    if (mInvocationProtoResultReporter != null
+                            && !mInvocationProtoResultReporter.stopCaching()) {
+                        InvocationCacheHelper.uploadInvocationResults(
+                                config, mInvocationProtoResultReporter.getOutputFile(), info);
+                    }
                     return;
                 }
             }
@@ -1428,9 +1463,17 @@ public class TestInvocation implements ITestInvocation {
 
             performInvocation(config, info, invocationPath, listener, deviceInit);
             setExitCode(ExitCode.NO_ERROR, null);
+            if (mInvocationProtoResultReporter != null
+                    && !mInvocationProtoResultReporter.stopCaching()) {
+                InvocationCacheHelper.uploadInvocationResults(
+                        config, mInvocationProtoResultReporter.getOutputFile(), info);
+            }
         } catch (IOException e) {
             CLog.e(e);
         } finally {
+            if (mInvocationProtoResultReporter != null) {
+                FileUtil.deleteFile(mInvocationProtoResultReporter.getOutputFile());
+            }
             TfObjectTracker.clearTracking();
             CurrentInvocation.clearInvocationInfos();
             config.getSkipManager().clearManager();
@@ -2058,12 +2101,20 @@ public class TestInvocation implements ITestInvocation {
 
     /** Always complete snapuserd before proceeding into test. */
     private void waitForSnapuserd(
-            TestInformation testInfo, IConfiguration config, SnapuserdWaitPhase currentPhase)
+            TestInformation testInfo,
+            IConfiguration config,
+            SnapuserdWaitPhase currentPhase,
+            boolean force)
             throws DeviceNotAvailableException {
         for (ITestDevice device : testInfo.getDevices()) {
             if (device instanceof StubDevice) {
                 continue;
             }
+            if (force) {
+                // Force a notify so we go through a round of detection.
+                // This ensures we will commit the snapshot before tests in subprocess
+                device.notifySnapuserd(currentPhase);
+            }
             device.waitForSnapuserd(currentPhase); // Should be inop if not waiting on any updates.
         }
     }
diff --git a/src/com/android/tradefed/invoker/shard/ShardHelper.java b/src/com/android/tradefed/invoker/shard/ShardHelper.java
index 111d638c5..c3330069c 100644
--- a/src/com/android/tradefed/invoker/shard/ShardHelper.java
+++ b/src/com/android/tradefed/invoker/shard/ShardHelper.java
@@ -389,7 +389,7 @@ public class ShardHelper implements IShardHelper {
 
     private static boolean isAutoRetryEnabled(IConfiguration config) {
         IRetryDecision decision = config.getRetryDecision();
-        if (decision.isAutoRetryEnabled() && decision.getMaxRetryCount() > 0) {
+        if (decision.isAutoRetryEnabled() && decision.getMaxTestRunAttempts() > 0) {
             return true;
         }
         return false;
diff --git a/src/com/android/tradefed/invoker/shard/StrictShardHelper.java b/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
index af726082a..83f626bb0 100644
--- a/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
+++ b/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
@@ -375,10 +375,6 @@ public class StrictShardHelper extends ShardHelper {
     }
 
     private void topBottom(List<List<IRemoteTest>> allShards, int shardCount) {
-        // We only attempt this when the number of shard is pretty high
-        if (shardCount < 4) {
-            return;
-        }
         // Generate approximate RuntimeHint for each shard
         int index = 0;
         List<SortShardObj> shardTimes = new ArrayList<>();
@@ -395,7 +391,10 @@ public class StrictShardHelper extends ShardHelper {
             index++;
             CLog.d("+++++++++++++++++++++++++++++++++++++++++++");
         }
-
+        // We only attempt this when the number of shard is pretty high
+        if (shardCount < 4) {
+            return;
+        }
         Collections.sort(shardTimes);
         if ((shardTimes.get(0).mAggTime - shardTimes.get(shardTimes.size() - 1).mAggTime)
                 < 60 * 60 * 1000L) {
diff --git a/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java b/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
index 78846fd28..64f8a96a3 100644
--- a/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
+++ b/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
@@ -225,7 +225,7 @@ public final class TestsPoolPoller
             RemoteDynamicPool remotePool = (RemoteDynamicPool) mTestsPool;
             ITestSuite testModule = (ITestSuite) test;
             int attemptNumber = remotePool.getAttemptNumber(testModule);
-            if (attemptNumber + 1 <= mConfig.getRetryDecision().getMaxRetryCount()) {
+            if (attemptNumber + 1 <= mConfig.getRetryDecision().getMaxTestRunAttempts()) {
                 // requeue the module for execution
                 remotePool.returnToRemotePool(testModule, attemptNumber + 1);
             } else {
diff --git a/src/com/android/tradefed/postprocessor/BasePostProcessor.java b/src/com/android/tradefed/postprocessor/BasePostProcessor.java
index 5379e33db..a6ac0ca65 100644
--- a/src/com/android/tradefed/postprocessor/BasePostProcessor.java
+++ b/src/com/android/tradefed/postprocessor/BasePostProcessor.java
@@ -170,6 +170,8 @@ public abstract class BasePostProcessor implements IPostProcessor {
                     }
                     testLogSaved(dataName, dataType, dataStream, log);
                     logAssociation(dataName, log);
+                    // do not forward if log saved
+                    return;
                 } catch (IOException e) {
                     CLog.e("Failed to save log file %s.", dataName);
                     CLog.e(e);
diff --git a/src/com/android/tradefed/result/CollectingTestListener.java b/src/com/android/tradefed/result/CollectingTestListener.java
index becb68f56..0603d4f63 100644
--- a/src/com/android/tradefed/result/CollectingTestListener.java
+++ b/src/com/android/tradefed/result/CollectingTestListener.java
@@ -614,6 +614,14 @@ public class CollectingTestListener
         mTestRunResultMap.remove(testRunName);
     }
 
+    /** Allows to clear all test run results so we avoid carrying them for too long. */
+    protected final synchronized void clearTestRunResults() {
+        setCountDirty();
+        mTestRunResultMap.clear();
+        mMergedTestRunResults.clear();
+        mCurrentTestRunResult = new TestRunResult();
+    }
+
     /** Allows cleaning the module file so we avoid carrying them for too long. */
     protected final synchronized void clearModuleLogFiles() {
         mModuleLogFiles = new MultiMap<>();
diff --git a/src/com/android/tradefed/result/LUCIResultReporter.java b/src/com/android/tradefed/result/LUCIResultReporter.java
index f6e813e1b..7df8177ea 100644
--- a/src/com/android/tradefed/result/LUCIResultReporter.java
+++ b/src/com/android/tradefed/result/LUCIResultReporter.java
@@ -83,6 +83,9 @@ public class LUCIResultReporter extends CollectingTestListener
     )
     private boolean mReportGranularResults = true;
 
+    @Option(name = "log-output-dir", description = "Path to save the JSON result file and other log files.")
+    private File mLogOutputDir = null;
+
     private boolean mHasInvocationFailures = false;
     private LinkedHashMap<String, LogFile> mLoggedFiles = new LinkedHashMap<>();
     private File mRootDir = null;
@@ -157,6 +160,17 @@ public class LUCIResultReporter extends CollectingTestListener
             String dataName = entry.getKey();
             LogFile logFile = entry.getValue();
             printLog(dataName, logFile);
+            if (mLogOutputDir != null) {
+              // If the output path is specified, copy all log artifacts there.
+              try {
+                  File logFullPathFile = new File(logFile.getPath());
+                  FileUtil.copyFile(logFullPathFile,
+                      new File(mLogOutputDir, logFullPathFile.getName()));
+              } catch (IOException e) {
+                  CLog.e("Failed to copy JSON result file to " + mLogOutputDir.toString());
+                  CLog.e(e);
+              }
+            }
         }
     }
 
@@ -253,14 +267,19 @@ public class LUCIResultReporter extends CollectingTestListener
     public void saveJsonFile(JSONObject jsonResults) {
         ByteArrayInputStream resultStream = new ByteArrayInputStream(
             jsonResults.toString().getBytes());
-        LogFileSaver saver = new LogFileSaver(mRootDir);
+        LogFileSaver saver;
+        if (mLogOutputDir != null) {
+            saver = new LogFileSaver(mLogOutputDir);
+        } else {
+            saver = new LogFileSaver(mRootDir);
+        }
         File generatedDir = saver.getFileDir();
         try {
-          File logFile = saver.saveLogData("LUCIResult", LogDataType.JSON, resultStream);
-          logResultFileLocation(logFile);
+            File logFile = saver.saveLogData("LUCIResult", LogDataType.JSON, resultStream);
+            logResultFileLocation(logFile);
         } catch(IOException e) {
-          CLog.e("Failed to save JSON results to " + generatedDir.toString());
-          CLog.e(e);
+            CLog.e("Failed to save JSON results to " + generatedDir.toString());
+            CLog.e(e);
         }
     }
 
@@ -319,7 +338,7 @@ public class LUCIResultReporter extends CollectingTestListener
 
     /** A helper method to format and print result file's name and location to console. */
     private void printLog(String dataName, LogFile logFile) {
-        String logDesc = logFile.getUrl() == null ? logFile.getPath() : logFile.getUrl();
-        CLog.logAndDisplay(LogLevel.DEBUG, "%s: %s\r\n", dataName, logDesc);
+        CLog.logAndDisplay(LogLevel.DEBUG, "%s: %s (size: %.2f KB)\r\n", dataName,
+                logFile.getPath(), logFile.getSize() / 1024.0);
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/android/tradefed/result/LogFileSaver.java b/src/com/android/tradefed/result/LogFileSaver.java
index d04cec539..11f47cc12 100644
--- a/src/com/android/tradefed/result/LogFileSaver.java
+++ b/src/com/android/tradefed/result/LogFileSaver.java
@@ -34,7 +34,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.zip.GZIPOutputStream;
 
-
 /**
  * A helper for {@link ITestInvocationListener}'s that will save log data to a file
  */
@@ -229,8 +228,9 @@ public class LogFileSaver {
         // Hardlink fallback to copy if needed
         FileUtil.hardlinkFile(fileToLog, logFile);
         CLog.i(
-                "Saved log file %s. [size=%s, elapsed=%sms]",
+                "Saved log file %s (type:%s). [size=%s, elapsed=%sms]",
                 logFile.getAbsolutePath(),
+                dataType,
                 logFile.length(),
                 System.currentTimeMillis() - startTime);
         return logFile;
diff --git a/src/com/android/tradefed/result/LogSaverResultForwarder.java b/src/com/android/tradefed/result/LogSaverResultForwarder.java
index cfdfb3528..97402eff2 100644
--- a/src/com/android/tradefed/result/LogSaverResultForwarder.java
+++ b/src/com/android/tradefed/result/LogSaverResultForwarder.java
@@ -40,12 +40,22 @@ public class LogSaverResultForwarder extends ResultForwarder implements ILogSave
 
     public LogSaverResultForwarder(
             ILogSaver logSaver, List<ITestInvocationListener> listeners, IConfiguration config) {
+        this(logSaver, listeners, config, true);
+    }
+
+    public LogSaverResultForwarder(
+            ILogSaver logSaver,
+            List<ITestInvocationListener> listeners,
+            IConfiguration config,
+            boolean setLogSaver) {
         super(listeners);
         mLogSaver = logSaver;
         mConfig = config;
-        for (ITestInvocationListener listener : listeners) {
-            if (listener instanceof ILogSaverListener) {
-                ((ILogSaverListener) listener).setLogSaver(mLogSaver);
+        if (setLogSaver) {
+            for (ITestInvocationListener listener : listeners) {
+                if (listener instanceof ILogSaverListener) {
+                    ((ILogSaverListener) listener).setLogSaver(mLogSaver);
+                }
             }
         }
     }
@@ -183,7 +193,7 @@ public class LogSaverResultForwarder extends ResultForwarder implements ILogSave
                 }
             }
         } catch (RuntimeException | IOException e) {
-            CLog.e("Failed to save log data");
+            CLog.e("Failed to save log data: %s", dataName);
             CLog.e(e);
         }
     }
@@ -211,7 +221,7 @@ public class LogSaverResultForwarder extends ResultForwarder implements ILogSave
                 }
             }
         } catch (RuntimeException e) {
-            CLog.e("Failed to save log data");
+            CLog.e("Failed to save log data for %s", dataName);
             CLog.e(e);
         }
     }
diff --git a/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java b/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java
new file mode 100644
index 000000000..cc9300235
--- /dev/null
+++ b/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.result;
+
+import com.android.tradefed.invoker.logger.CurrentInvocation.IsolationGrade;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.util.proto.TfMetricProtoUtil;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An Extension of {@link ResultAndLogForwarder} that adds extra module related metrics to the test
+ * results.
+ */
+public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
+    /** Track if we are within an isolated run or not */
+    private IsolationGrade mAttemptIsolation = IsolationGrade.NOT_ISOLATED;
+
+    private List<String> mTestMappingSources = new ArrayList<>();
+    private static final String TEST_MAPPING_SOURCE = "test_mapping_source";
+    private String mModuleId = null;
+
+    public ModuleResultsAndMetricsForwarder(ITestInvocationListener... listeners) {
+        super(listeners);
+    }
+
+    /** Sets whether or not the attempt should be reported as isolated. */
+    public void setAttemptIsolation(IsolationGrade isolation) {
+        mAttemptIsolation = isolation;
+    }
+
+    /** Sets test-mapping sources that will be inserted into metrics. */
+    public void setTestMappingSources(List<String> testMappingSources) {
+        mTestMappingSources = testMappingSources;
+    }
+
+    public void setModuleId(String moduleId) {
+        mModuleId = moduleId;
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        super.testRunStarted(mModuleId, testCount);
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber) {
+        testRunStarted(mModuleId, testCount, attemptNumber, System.currentTimeMillis());
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber, long startTime) {
+        super.testRunStarted(mModuleId, testCount, attemptNumber, startTime);
+    }
+
+    @Override
+    public void testStarted(TestDescription test) {
+        super.testStarted(test);
+    }
+
+    @Override
+    public void testStarted(TestDescription test, long startTime) {
+        super.testStarted(test, startTime);
+    }
+
+    @Override
+    public void testFailed(TestDescription test, String trace) {
+        super.testFailed(test, trace);
+    }
+
+    @Override
+    public void testFailed(TestDescription test, FailureDescription failure) {
+        super.testFailed(test, failure);
+    }
+
+    @Override
+    public void testEnded(
+            TestDescription test, HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        testEnded(test, System.currentTimeMillis(), testMetrics);
+    }
+
+    @Override
+    public void testEnded(
+            TestDescription test,
+            long endTime,
+            HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        if (!mTestMappingSources.isEmpty()) {
+            testMetrics.put(
+                    TEST_MAPPING_SOURCE,
+                    TfMetricProtoUtil.stringToMetric(mTestMappingSources.toString()));
+        }
+        super.testEnded(test, endTime, testMetrics);
+    }
+
+    @Override
+    public void testRunFailed(String errorMessage) {
+        super.testRunFailed(errorMessage);
+    }
+
+    @Override
+    public void testRunFailed(FailureDescription failure) {
+        super.testRunFailed(failure);
+    }
+
+    @Override
+    public void testRunEnded(
+            long elapsedTime, HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        if (!IsolationGrade.NOT_ISOLATED.equals(mAttemptIsolation)) {
+            runMetrics.put(
+                    "run-isolated", TfMetricProtoUtil.stringToMetric(mAttemptIsolation.toString()));
+            // In case something was off, reset isolation.
+            mAttemptIsolation = IsolationGrade.NOT_ISOLATED;
+        }
+        super.testRunEnded(elapsedTime, runMetrics);
+    }
+
+    @Override
+    public void testRunEnded(long elapsedTimeMillis, Map<String, String> runMetrics) {
+        super.testRunEnded(elapsedTimeMillis, runMetrics);
+    }
+}
diff --git a/src/com/android/tradefed/result/ResultForwarder.java b/src/com/android/tradefed/result/ResultForwarder.java
index ebdb5f088..6f5461705 100644
--- a/src/com/android/tradefed/result/ResultForwarder.java
+++ b/src/com/android/tradefed/result/ResultForwarder.java
@@ -77,11 +77,11 @@ public class ResultForwarder implements ITestInvocationListener {
     }
 
     /**
-     * Get the list of listeners.  Intended only for use by subclasses.
+     * Get the list of listeners.
      *
      * @return The list of {@link ITestInvocationListener}s.
      */
-    protected List<ITestInvocationListener> getListeners() {
+    public List<ITestInvocationListener> getListeners() {
         return mListeners;
     }
 
diff --git a/src/com/android/tradefed/result/TestResultListener.java b/src/com/android/tradefed/result/TestResultListener.java
index 8869f9b36..589f033dd 100644
--- a/src/com/android/tradefed/result/TestResultListener.java
+++ b/src/com/android/tradefed/result/TestResultListener.java
@@ -41,7 +41,12 @@ public abstract class TestResultListener implements ITestLifeCycleReceiver {
     public final void testStarted(TestDescription test, long startTime) {
         if (mCurrentTest != null) {
             // oh noes, previous test do not complete, forward an incomplete event
-            reportTestFinish(null);
+            mCurrentResult.setEndTime(System.currentTimeMillis());
+            mCurrentResult.setStatus(TestStatus.FAILURE);
+            mCurrentResult.setStackTrace("did not complete");
+            testResult(mCurrentTest, mCurrentResult);
+            mCurrentResult = null;
+            mCurrentTest = null;
         }
         mCurrentTest = test;
         mCurrentResult = new TestResult();
@@ -107,6 +112,8 @@ public abstract class TestResultListener implements ITestLifeCycleReceiver {
         if (mCurrentTest != null) {
             // last test did not finish! report incomplete
             mCurrentResult.setEndTime(System.currentTimeMillis());
+            mCurrentResult.setStatus(TestStatus.FAILURE);
+            mCurrentResult.setStackTrace("did not complete");
             testResult(mCurrentTest, mCurrentResult);
             mCurrentTest = null;
             mCurrentResult = null;
@@ -121,6 +128,8 @@ public abstract class TestResultListener implements ITestLifeCycleReceiver {
         if (mCurrentTest != null
                 && mCurrentTest.equals(test)
                 && TestStatus.INCOMPLETE.equals(mCurrentResult.getResultStatus())) {
+            // If we reach here with no status changed, that means passed otherwise the status
+            // would have been updated to an error
             mCurrentResult.setStatus(TestStatus.PASSED);
         }
         mCurrentResult.setEndTime(endTime);
diff --git a/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java b/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
index 138d5bb69..615ced136 100644
--- a/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
+++ b/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
@@ -18,7 +18,6 @@ package com.android.tradefed.result.ddmlib;
 import com.android.ddmlib.IShellEnabledDevice;
 import com.android.ddmlib.testrunner.IInstrumentationResultParser;
 import com.android.ddmlib.testrunner.ITestRunListener;
-import com.android.ddmlib.testrunner.InstrumentationResultParser;
 
 import java.util.Collection;
 
diff --git a/src/com/android/tradefed/result/ddmlib/InstrumentationProtoResultParser.java b/src/com/android/tradefed/result/ddmlib/InstrumentationProtoResultParser.java
new file mode 100644
index 000000000..fc8138bf1
--- /dev/null
+++ b/src/com/android/tradefed/result/ddmlib/InstrumentationProtoResultParser.java
@@ -0,0 +1,493 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.ddmlib;
+
+import static com.google.common.base.Strings.isNullOrEmpty;
+
+import com.android.commands.am.InstrumentationData;
+import com.android.ddmlib.testrunner.IInstrumentationResultParser;
+import com.android.ddmlib.testrunner.ITestRunListener;
+import com.android.ddmlib.testrunner.TestIdentifier;
+import com.android.tradefed.log.Log;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.protobuf.InvalidProtocolBufferException;
+
+import java.io.ByteArrayOutputStream;
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Parses the 'protoStd output mode' results of an instrumentation test run from shell and informs a
+ * ITestRunListener of the results.
+ *
+ * <p>Am instrument command with "-m" option outputs test execution status in binary protobuf format
+ * incrementally. The output protobuf message is {@link InstrumentationData.Session}, which has two
+ * fields: 1) a repeated field of {@link InstrumentationData.TestStatus}, 2) {@link
+ * InstrumentationData.SessionStatus}. The am instrument command outputs test status message
+ * before/after each test execution. {@link #addOutput} is invoked with a {@code data} argument
+ * which is a serialized bytes of {@code TestStatus}(es). When all tests are done, the command
+ * outputs {@code SessionStatus} at last.
+ *
+ * <p>See
+ * https://cs.android.com/android/platform/superproject/+/master:frameworks/base/cmds/am/proto/instrumentation_data.proto
+ * for a complete protobuf definition.
+ *
+ * <p>{@code InstrumentationProtoResultParser} is a state-machine and states are defined in {@link
+ * InstrumentationProtoResultParserState}. The state begins with {@link
+ * InstrumentationProtoResultParserState#NOT_STARTED}. When it sees a first test case status, it
+ * moves to {@link InstrumentationProtoResultParserState#RUNNING}. The state changes to {@link
+ * InstrumentationProtoResultParserState#FINISHED} if all tests are done or {@link
+ * InstrumentationProtoResultParserState#CANCELLED} if it is requested by calling {@link #cancel}.
+ *
+ * <p>Every time a new test status is available, it will be informed to the registered listeners.
+ */
+public class InstrumentationProtoResultParser implements IInstrumentationResultParser {
+
+    /** An internal state of {@link InstrumentationProtoResultParser}. */
+    private enum InstrumentationProtoResultParserState {
+        /** Test run is not started. */
+        NOT_STARTED(false),
+        /** Test is currently running. */
+        RUNNING(false),
+        /** All test executions are completed. */
+        FINISHED(true),
+        /** Test run has been cancelled. */
+        CANCELLED(true);
+
+        private final boolean mIsTerminalState;
+
+        InstrumentationProtoResultParserState(boolean isTerminalState) {
+            mIsTerminalState = isTerminalState;
+        }
+
+        public boolean isTerminalState() {
+            return mIsTerminalState;
+        }
+    }
+
+    /** Represents a status of a single test case execution. */
+    private static class TestStatus {
+        /**
+         * The result code of this test case.
+         *
+         * @see IInstrumentationResultParser.StatusCodes
+         */
+        private int mTestResultCode;
+
+        /** The logcat output emitted during this test case */
+        private StringBuilder mLogcat = new StringBuilder();
+
+        /**
+         * The test status metrics emitted during the execution of the test case by {@code
+         * android.app.Instrumentation#sendStatus}. The insertion order is preserved unless the test
+         * emits a same key multiple times. Note that standard keys defined in {@link
+         * IInstrumentationResultParser.StatusKeys} should be filtered out of this Map.
+         */
+        private final LinkedHashMap<String, String> mTestMetrics = new LinkedHashMap<>();
+
+        public TestStatus(int testResultCode) {
+            mTestResultCode = testResultCode;
+        }
+
+        public void setTestResultCode(int testResultCode) {
+            mTestResultCode = testResultCode;
+        }
+
+        public int getTestResultCode() {
+            return mTestResultCode;
+        }
+
+        public void appendLogcat(String logcat) {
+            mLogcat.append(logcat);
+        }
+
+        public void clearLogcat() {
+            mLogcat = new StringBuilder();
+        }
+
+        public String getLogcat() {
+            return mLogcat.toString();
+        }
+
+        public void putTestMetrics(String key, String value) {
+            mTestMetrics.put(key, value);
+        }
+
+        public void putAllTestMetrics(Map<String, String> testMetrics) {
+            mTestMetrics.putAll(testMetrics);
+        }
+
+        public Map<String, String> getTestMetrics() {
+            return ImmutableMap.copyOf(mTestMetrics);
+        }
+    }
+
+    /** The tag to be used for logging. */
+    private static final String LOG_TAG = "InstrumentationProtoResultParser";
+
+    private final String mRunName;
+    private final Collection<ITestRunListener> mListeners;
+
+    /** True if current test run has been canceled by user. */
+    private InstrumentationProtoResultParserState mState =
+            InstrumentationProtoResultParserState.NOT_STARTED;
+
+    /**
+     * A received byte array to be processed and translated into {@link InstrumentationData.Session}
+     * message.
+     */
+    private ByteArrayOutputStream mPendingData = new ByteArrayOutputStream();
+
+    /** The latest test statuses. Uses LinkedHashMap to preserve the insertion order. */
+    private final LinkedHashMap<TestIdentifier, TestStatus> mTestStatuses = new LinkedHashMap<>();
+
+    /**
+     * A regex patter to be used for finding test execution elapsed time from session output string.
+     */
+    private final Pattern mTimePattern = Pattern.compile("Time: \\s*([\\d\\,]*[\\d\\.]+)");
+
+    /**
+     * Constructs {@link InstrumentationProtoResultParser}.
+     *
+     * @param runName the test run name to provide to {@link ITestRunListener#testRunStarted}
+     * @param listeners informed of test results as the tests are executing
+     */
+    public InstrumentationProtoResultParser(
+            String runName, Collection<ITestRunListener> listeners) {
+        mRunName = runName;
+        mListeners = listeners;
+    }
+
+    /**
+     * This method is called every time some new data is available.
+     *
+     * @param data a serialized data of {@link InstrumentationData.Session} message. If {@code data}
+     *     is an incomplete chunk, they are added into an internal buffer and will be processed in
+     *     the next {@link #addOutput} call.
+     * @param offset an offset of the new data stored in {@code data}
+     * @param length bytes of a new data in {@code data} to be processed.
+     */
+    @Override
+    public void addOutput(byte[] data, int offset, int length) {
+        if (mState.isTerminalState()) {
+            return;
+        }
+
+        mPendingData.write(data, offset, length);
+        try {
+            InstrumentationData.Session session =
+                    InstrumentationData.Session.parseFrom(mPendingData.toByteArray());
+            mPendingData.reset();
+            updateState(session);
+        } catch (InvalidProtocolBufferException e) {
+            // InvalidProtocolBufferException may happen if a given new output data is incomplete.
+            // Let's just skip updating mSession and wait for incoming data.
+        }
+    }
+
+    private void updateState(InstrumentationData.Session session) {
+        for (InstrumentationData.TestStatus status : session.getTestStatusList()) {
+            // Notify test run started if this is the initial test state update.
+            if (mState == InstrumentationProtoResultParserState.NOT_STARTED) {
+                final int numTests =
+                        status.getResults().getEntriesList().stream()
+                                .filter(entry -> entry.getKey().equals(StatusKeys.NUMTESTS))
+                                .map(entry -> entry.getValueInt())
+                                .findFirst()
+                                .orElse(0);
+                if (numTests == 0) {
+                    return;
+                }
+
+                mState = InstrumentationProtoResultParserState.RUNNING;
+                for (ITestRunListener listener : mListeners) {
+                    listener.testRunStarted(mRunName, numTests);
+                }
+            }
+
+            String testClassName = "";
+            String testMethodName = "";
+            String stackTrace = "";
+            LinkedHashMap<String, String> testMetrics = new LinkedHashMap<>();
+            for (InstrumentationData.ResultsBundleEntry entry :
+                    status.getResults().getEntriesList()) {
+                switch (entry.getKey()) {
+                    case StatusKeys.CLASS:
+                        testClassName = entry.getValueString();
+                        break;
+                    case StatusKeys.TEST:
+                        testMethodName = entry.getValueString();
+                        break;
+                    case StatusKeys.STACK:
+                        stackTrace = entry.getValueString();
+                        break;
+                    default:
+                        if (!StatusKeys.KNOWN_KEYS.contains(entry.getKey())) {
+                            testMetrics.put(
+                                    entry.getKey(), getResultsEntryBundleValueInString(entry));
+                        }
+                }
+            }
+
+            // If both test class name and method name are missing, assume the previous test is
+            // the current one. This happens if your test sends custom test status by
+            // Instrumentation.sendStatus() method.
+            // Also, we should ignore reported test ResultCode from sendStatus() call because
+            // it is often misused and Activity.RESULT_OK (= -1) is set. -1 means ERROR here
+            // which causes ddmlib to fail.
+            Optional<Integer> resultCodeOverride = Optional.empty();
+            if (isNullOrEmpty(testClassName) && isNullOrEmpty(testMethodName)) {
+                Optional<Map.Entry<TestIdentifier, TestStatus>> previousTestStatus =
+                        mTestStatuses.entrySet().stream().reduce((first, second) -> second);
+                if (previousTestStatus.isPresent()) {
+                    testClassName = previousTestStatus.get().getKey().getClassName();
+                    testMethodName = previousTestStatus.get().getKey().getTestName();
+                    resultCodeOverride =
+                            Optional.of(previousTestStatus.get().getValue().mTestResultCode);
+                } else {
+                    testClassName = "";
+                    testMethodName = "";
+                }
+            }
+
+            if (!isNullOrEmpty(testClassName) && !isNullOrEmpty(testMethodName)) {
+                updateTestState(
+                        testClassName,
+                        testMethodName,
+                        resultCodeOverride.orElse(status.getResultCode()),
+                        status.getLogcat(),
+                        stackTrace,
+                        testMetrics);
+            }
+        }
+
+        if (session.hasSessionStatus()) {
+            mState = InstrumentationProtoResultParserState.FINISHED;
+
+            LinkedHashMap<String, String> testRunMetrics = new LinkedHashMap<>();
+            switch (session.getSessionStatus().getStatusCode()) {
+                    // System server is crashed during the test execution.
+                case SESSION_ABORTED:
+                    {
+                        String errorMessage = session.getSessionStatus().getErrorText();
+
+                        // Report the test case failure gracefully in case the system server is
+                        // crashed during the test case.
+                        Map.Entry<TestIdentifier, TestStatus> lastTestCase =
+                                mTestStatuses.entrySet().stream().findFirst().orElse(null);
+                        if (lastTestCase != null
+                                && !IInstrumentationResultParser.StatusCodes.isTerminalState(
+                                        lastTestCase.getValue().getTestResultCode())) {
+                            for (ITestRunListener listener : mListeners) {
+                                listener.testFailed(lastTestCase.getKey(), /* trace= */ "");
+                            }
+
+                            lastTestCase
+                                    .getValue()
+                                    .putTestMetrics(
+                                            StatusKeys.DDMLIB_LOGCAT,
+                                            lastTestCase.getValue().getLogcat());
+                            for (ITestRunListener listener : mListeners) {
+                                listener.testEnded(
+                                        lastTestCase.getKey(),
+                                        lastTestCase.getValue().getTestMetrics());
+                            }
+                        }
+
+                        for (ITestRunListener listener : mListeners) {
+                            listener.testRunFailed(errorMessage);
+                        }
+                    }
+                    break;
+
+                    // All tests run finishes.
+                case SESSION_FINISHED:
+                    if (session.getSessionStatus().getResultCode()
+                            == IInstrumentationResultParser.SessionResultCodes.ERROR) {
+                        String errorMessage =
+                                session.getSessionStatus().getResults().getEntriesList().stream()
+                                        .filter(entry -> entry.getKey().equals(StatusKeys.SHORTMSG))
+                                        .map(entry -> entry.getValueString())
+                                        .findFirst()
+                                        .orElse("");
+                        for (ITestRunListener listener : mListeners) {
+                            listener.testRunFailed(errorMessage);
+                        }
+                    }
+
+                    for (InstrumentationData.ResultsBundleEntry entry :
+                            session.getSessionStatus().getResults().getEntriesList()) {
+                        if (!StatusKeys.KNOWN_KEYS.contains(entry.getKey())) {
+                            testRunMetrics.put(
+                                    entry.getKey(), getResultsEntryBundleValueInString(entry));
+                        }
+                    }
+                    break;
+                default:
+                    /* Unknown status */
+                    break;
+            }
+
+            long elapsedTime = findElapsedTime(session.getSessionStatus()).orElse(0L);
+            ImmutableMap<String, String> immutableTestRunMetrics =
+                    ImmutableMap.copyOf(testRunMetrics);
+            for (ITestRunListener listener : mListeners) {
+                listener.testRunEnded(elapsedTime, immutableTestRunMetrics);
+            }
+        }
+    }
+
+    private static String getResultsEntryBundleValueInString(
+            InstrumentationData.ResultsBundleEntry entry) {
+        if (entry.hasValueString()) return entry.getValueString();
+        if (entry.hasValueInt()) return String.valueOf(entry.getValueInt());
+        if (entry.hasValueLong()) return String.valueOf(entry.getValueLong());
+        if (entry.hasValueFloat()) return String.valueOf(entry.getValueFloat());
+        if (entry.hasValueDouble()) return String.valueOf(entry.getValueDouble());
+        if (entry.hasValueBytes()) return entry.getValueBytes().toString();
+        if (entry.hasValueBundle()) return entry.getValueBundle().toString();
+        return "";
+    }
+
+    private void updateTestState(
+            String testClassName,
+            String testMethodName,
+            int testResultCode,
+            String logcat,
+            String stackTrace,
+            LinkedHashMap<String, String> testMetrics) {
+        TestIdentifier testId = new TestIdentifier(testClassName, testMethodName);
+        TestStatus status =
+                mTestStatuses.computeIfAbsent(
+                        testId,
+                        id -> {
+                            // Notify test case started.
+                            for (ITestRunListener listener : mListeners) {
+                                listener.testStarted(testId);
+                            }
+                            return new TestStatus(IInstrumentationResultParser.StatusCodes.START);
+                        });
+
+        status.appendLogcat(logcat);
+        status.putAllTestMetrics(testMetrics);
+
+        if (status.getTestResultCode() == testResultCode) {
+            return;
+        }
+
+        status.setTestResultCode(testResultCode);
+
+        switch (testResultCode) {
+            case IInstrumentationResultParser.StatusCodes.ASSUMPTION_FAILURE:
+                for (ITestRunListener listener : mListeners) {
+                    listener.testAssumptionFailure(testId, stackTrace);
+                }
+                break;
+
+            case IInstrumentationResultParser.StatusCodes.FAILURE:
+            case IInstrumentationResultParser.StatusCodes.ERROR:
+                for (ITestRunListener listener : mListeners) {
+                    listener.testFailed(testId, stackTrace);
+                }
+                break;
+
+            case IInstrumentationResultParser.StatusCodes.IGNORED:
+                for (ITestRunListener listener : mListeners) {
+                    listener.testIgnored(testId);
+                }
+                // If the test status code is IGNORED, don't report logcat message given by
+                // "am instrument" command because they are incorrect. (It seems it forgets
+                // to clear out logcat message from the previous tests and passes the same
+                // logcat message for the ignored tests).
+                status.clearLogcat();
+                break;
+        }
+
+        if (IInstrumentationResultParser.StatusCodes.isTerminalState(testResultCode)) {
+            // Add extra test metrics by ddmlib.
+            status.putTestMetrics(StatusKeys.DDMLIB_LOGCAT, status.getLogcat());
+
+            for (ITestRunListener listener : mListeners) {
+                listener.testEnded(testId, status.getTestMetrics());
+            }
+        }
+    }
+
+    /** Find an elapsed time string ("Time: 1,745.755") in a given session status. */
+    private Optional<Long> findElapsedTime(InstrumentationData.SessionStatus sessionStatus) {
+        String sessionOutput =
+                sessionStatus.getResults().getEntriesList().stream()
+                        .filter(entry -> entry.getKey().equals(StatusKeys.STREAM))
+                        .map(entry -> entry.getValueString())
+                        .findFirst()
+                        .orElse(null);
+
+        if (isNullOrEmpty(sessionOutput)) {
+            return Optional.empty();
+        }
+
+        Matcher timeMatcher = mTimePattern.matcher(sessionOutput);
+        if (timeMatcher.find()) {
+            String timeString = timeMatcher.group(1);
+            try {
+                float timeSeconds = NumberFormat.getInstance().parse(timeString).floatValue();
+                return Optional.of((long) (timeSeconds * 1000));
+            } catch (ParseException e) {
+                Log.w(LOG_TAG, String.format("Unexpected time format %1$s", timeString));
+            }
+        }
+
+        Log.w(LOG_TAG, String.format("Elapsed time is missing: %1$s", sessionOutput));
+        return Optional.empty();
+    }
+
+    @Override
+    public void handleTestRunFailed(String errorMsg) {
+        if (mState.isTerminalState()) {
+            return;
+        }
+        mState = InstrumentationProtoResultParserState.FINISHED;
+
+        for (ITestRunListener listener : mListeners) {
+            listener.testRunFailed(errorMsg);
+        }
+        for (ITestRunListener listener : mListeners) {
+            listener.testRunEnded(0, ImmutableMap.of());
+        }
+    }
+
+    @Override
+    public void flush() {
+        /** Noop. We process data immediately. Nothing to flush. */
+    }
+
+    @Override
+    public void cancel() {
+        mState = InstrumentationProtoResultParserState.CANCELLED;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return mState == InstrumentationProtoResultParserState.CANCELLED;
+    }
+}
diff --git a/src/com/android/tradefed/result/ddmlib/InstrumentationResultParser.java b/src/com/android/tradefed/result/ddmlib/InstrumentationResultParser.java
new file mode 100644
index 000000000..3dd77c6ec
--- /dev/null
+++ b/src/com/android/tradefed/result/ddmlib/InstrumentationResultParser.java
@@ -0,0 +1,674 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.ddmlib;
+
+import static com.android.ddmlib.testrunner.IInstrumentationResultParser.StatusKeys.KNOWN_KEYS;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.IShellOutputReceiver;
+import com.android.ddmlib.MultiLineReceiver;
+import com.android.ddmlib.testrunner.IInstrumentationResultParser;
+import com.android.ddmlib.testrunner.ITestRunListener;
+import com.android.ddmlib.testrunner.TestIdentifier;
+import com.android.tradefed.log.Log;
+
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Parses the 'raw output mode' results of an instrumentation test run from shell and informs a
+ * ITestRunListener of the results.
+ *
+ * <p>Expects the following output:
+ *
+ * <p>If fatal error occurred when attempted to run the tests:
+ *
+ * <pre>
+ * INSTRUMENTATION_STATUS: Error=error Message
+ * INSTRUMENTATION_FAILED:
+ * </pre>
+ *
+ * <p>or
+ *
+ * <pre>
+ * INSTRUMENTATION_RESULT: shortMsg=error Message
+ * </pre>
+ *
+ * <p>Otherwise, expect a series of test results, each one containing a set of status key/value
+ * pairs, delimited by a start(1)/pass(0)/fail(-2)/error(-1) status code result. At end of test run,
+ * expects that the elapsed test time in seconds will be displayed
+ *
+ * <p>For example:
+ *
+ * <pre>
+ * INSTRUMENTATION_STATUS_CODE: 1
+ * INSTRUMENTATION_STATUS: class=com.foo.FooTest
+ * INSTRUMENTATION_STATUS: test=testFoo
+ * INSTRUMENTATION_STATUS: numtests=2
+ * INSTRUMENTATION_STATUS: stack=com.foo.FooTest#testFoo:312
+ *    com.foo.X
+ * INSTRUMENTATION_STATUS_CODE: -2
+ * ...
+ *
+ * Time: X
+ * </pre>
+ *
+ * <p>Note that the "value" portion of the key-value pair may wrap over several text lines
+ *
+ * <p>Use {@link InstrumentationProtoResultParser} instead. The proto based parser has additional
+ * information such as logcat message.
+ */
+public class InstrumentationResultParser extends MultiLineReceiver
+        implements IInstrumentationResultParser {
+
+    /** Prefixes used to identify output. */
+    private static class Prefixes {
+        private static final String STATUS = "INSTRUMENTATION_STATUS: ";
+        private static final String STATUS_CODE = "INSTRUMENTATION_STATUS_CODE: ";
+        private static final String STATUS_FAILED = "INSTRUMENTATION_FAILED: ";
+        private static final String STATUS_ABORTED = "INSTRUMENTATION_ABORTED: ";
+        private static final String ON_ERROR = "onError:";
+        private static final String CODE = "INSTRUMENTATION_CODE: ";
+        private static final String RESULT = "INSTRUMENTATION_RESULT: ";
+        private static final String TIME_REPORT = "Time: ";
+    }
+
+    private final Collection<ITestRunListener> mTestListeners;
+
+    /** Test result data */
+    private static class TestResult {
+        private Integer mCode = null;
+        private String mTestName = null;
+        private String mTestClass = null;
+        private String mStackTrace = null;
+        private Integer mNumTests = null;
+        private String mCurrentTestNumber = null;
+
+        /** Returns true if all expected values have been parsed */
+        boolean isComplete() {
+            return mCode != null && mTestName != null && mTestClass != null;
+        }
+
+        /** Provides a more user readable string for TestResult, if possible */
+        @Override
+        public String toString() {
+            StringBuilder output = new StringBuilder();
+            if (mTestClass != null) {
+                output.append(mTestClass);
+                output.append('#');
+            }
+            if (mTestName != null) {
+                output.append(mTestName);
+            }
+            if (output.length() > 0) {
+                return output.toString();
+            }
+            return "unknown result";
+        }
+    }
+
+    /** the name to provide to {@link ITestRunListener#testRunStarted(String, int)} */
+    private final String mTestRunName;
+
+    /** Stores the status values for the test result currently being parsed */
+    private TestResult mCurrentTestResult = null;
+
+    /** Stores the status values for the test result last parsed */
+    private TestResult mLastTestResult = null;
+
+    /** Stores the current "key" portion of the status key-value being parsed. */
+    private String mCurrentKey = null;
+
+    /** Stores the current "value" portion of the status key-value being parsed. */
+    private StringBuilder mCurrentValue = null;
+
+    /** True if start of test has already been reported to listener. */
+    private boolean mTestStartReported = false;
+
+    /** True if the completion of the test run has been detected. */
+    private boolean mTestRunFinished = false;
+
+    /** True if test run failure has already been reported to listener. */
+    private boolean mTestRunFailReported = false;
+
+    /** The elapsed time of the test run, in milliseconds. */
+    private Long mTestTime = null;
+
+    /** True if current test run has been canceled by user. */
+    private boolean mIsCancelled = false;
+
+    /** The number of tests currently run */
+    private int mNumTestsRun = 0;
+
+    /** The number of tests expected to run */
+    private int mNumTestsExpected = 0;
+
+    /** True if the parser is parsing a line beginning with "INSTRUMENTATION_RESULT" */
+    private boolean mInInstrumentationResultKey = false;
+
+    /** Contains the full error available in 'stream=' in case of test runner fatal exception. */
+    private String mStreamError = null;
+
+    /** Contains the error message associated with the onError callback output. */
+    private String mOnError = null;
+
+    /**
+     * Stores key-value pairs under INSTRUMENTATION_RESULT header, keeping the order in which they
+     * were reported. The {@link ITestRunListener}s may choose to display some or all of them when
+     * the test run ends.
+     */
+    private Map<String, String> mInstrumentationResultBundle = new LinkedHashMap<>();
+
+    /**
+     * Stores key-value pairs of metrics emitted during the execution of each test case, keeping the
+     * order in which they were reported. Note that standard keys that are stored in the TestResults
+     * class are filtered out of this Map. The {@link ITestRunListener}s may choose to display some
+     * or all of them when the test case ends.
+     */
+    private Map<String, String> mTestMetrics = new LinkedHashMap<>();
+
+    private static final String LOG_TAG = "InstrumentationResultParser";
+
+    /** Error message supplied when no parseable test results are received from test run. */
+    static final String NO_TEST_RESULTS_MSG = "No test results";
+
+    /** Error message supplied when a test start bundle is parsed, but not the test end bundle. */
+    static final String INCOMPLETE_TEST_ERR_MSG_PREFIX = "Test failed to run to completion";
+
+    static final String INCOMPLETE_TEST_ERR_MSG_POSTFIX = "Check device logcat for details";
+
+    /** Error message supplied when the test run is incomplete. */
+    static final String INCOMPLETE_RUN_ERR_MSG_PREFIX = "Test run failed to complete";
+
+    /** Error message supplied from the test runner when some critical failure occurred */
+    static final String FATAL_EXCEPTION_MSG = "Fatal exception when running tests";
+
+    /**
+     * Pattern for the instrumentation reported errors (fatal & non-fatal) printed at the end of the
+     * instrumentation.
+     */
+    static final Pattern INSTRUMENTATION_FAILURES_PATTERN =
+            Pattern.compile("There (was|were) (\\d+) failure(.*)", Pattern.DOTALL);
+
+    /** Error message supplied when the test run output doesn't contain a valid time stamp. */
+    static final String INVALID_OUTPUT_ERR_MSG =
+            "Output from instrumentation is missing its time stamp";
+
+    /**
+     * Creates the InstrumentationResultParser.
+     *
+     * @param runName the test run name to provide to {@link ITestRunListener#testRunStarted(String,
+     *     int)}
+     * @param listeners informed of test results as the tests are executing
+     */
+    public InstrumentationResultParser(String runName, Collection<ITestRunListener> listeners) {
+        mTestRunName = runName;
+        mTestListeners = new ArrayList<ITestRunListener>(listeners);
+    }
+
+    /**
+     * Creates the InstrumentationResultParser for a single listener.
+     *
+     * @param runName the test run name to provide to {@link ITestRunListener#testRunStarted(String,
+     *     int)}
+     * @param listener informed of test results as the tests are executing
+     */
+    public InstrumentationResultParser(String runName, ITestRunListener listener) {
+        this(runName, Collections.singletonList(listener));
+    }
+
+    /**
+     * Processes the instrumentation test output from shell.
+     *
+     * @see MultiLineReceiver#processNewLines
+     */
+    @Override
+    public void processNewLines(@NonNull String[] lines) {
+        for (String line : lines) {
+            parse(line);
+            // in verbose mode, dump all adb output to log
+            Log.v(LOG_TAG, line);
+        }
+    }
+
+    /**
+     * Parse an individual output line. Expects a line that is one of:
+     *
+     * <ul>
+     *   <li>The start of a new status line (starts with Prefixes.STATUS or Prefixes.STATUS_CODE),
+     *       and thus there is a new key=value pair to parse, and the previous key-value pair is
+     *       finished.
+     *   <li>A continuation of the previous status (the "value" portion of the key has wrapped to
+     *       the next line).
+     *   <li>A line reporting a fatal error in the test run (Prefixes.STATUS_FAILED)
+     *   <li>A line reporting the total elapsed time of the test run. (Prefixes.TIME_REPORT)
+     * </ul>
+     *
+     * @param line Text output line
+     */
+    private void parse(String line) {
+        if (line.startsWith(Prefixes.STATUS_CODE)) {
+            // Previous status key-value has been collected. Store it.
+            submitCurrentKeyValue();
+            mInInstrumentationResultKey = false;
+            parseStatusCode(line);
+        } else if (line.startsWith(Prefixes.STATUS)) {
+            // Previous status key-value has been collected. Store it.
+            submitCurrentKeyValue();
+            mInInstrumentationResultKey = false;
+            parseKey(line, Prefixes.STATUS.length());
+        } else if (line.startsWith(Prefixes.RESULT)) {
+            // Previous status key-value has been collected. Store it.
+            submitCurrentKeyValue();
+            mInInstrumentationResultKey = true;
+            parseKey(line, Prefixes.RESULT.length());
+        } else if (line.startsWith(Prefixes.STATUS_FAILED) || line.startsWith(Prefixes.CODE)) {
+            // Previous status key-value has been collected. Store it.
+            submitCurrentKeyValue();
+            mInInstrumentationResultKey = false;
+            // these codes signal the end of the instrumentation run
+            mTestRunFinished = true;
+            // just ignore the remaining data on this line
+        } else if (line.startsWith(Prefixes.TIME_REPORT)) {
+            parseTime(line);
+        } else if (line.startsWith(Prefixes.ON_ERROR)) {
+            mOnError = line;
+        } else if (line.startsWith(Prefixes.STATUS_ABORTED)) {
+            if (mOnError == null) {
+                mOnError = line;
+            }
+        } else {
+            if (mCurrentValue != null) {
+                // this is a value that has wrapped to next line.
+                mCurrentValue.append("\r\n");
+                mCurrentValue.append(line);
+            } else if (!line.trim().isEmpty()) {
+                Log.d(LOG_TAG, "unrecognized line " + line);
+            }
+        }
+    }
+
+    /** Stores the currently parsed key-value pair in the appropriate place. */
+    private void submitCurrentKeyValue() {
+        if (mCurrentKey != null && mCurrentValue != null) {
+            String statusValue = mCurrentValue.toString();
+            if (mInInstrumentationResultKey) {
+                if (!KNOWN_KEYS.contains(mCurrentKey)) {
+                    mInstrumentationResultBundle.put(mCurrentKey, statusValue);
+                } else if (mCurrentKey.equals(StatusKeys.SHORTMSG)) {
+                    // test run must have failed
+                    handleTestRunFailed(
+                            String.format("Instrumentation run failed due to '%1$s'", statusValue));
+                } else if (StatusKeys.STREAM.equals(mCurrentKey)) {
+                    if (statusValue != null) {
+                        if (statusValue.contains(FATAL_EXCEPTION_MSG)) {
+                            mStreamError = statusValue.trim();
+                        } else if (INSTRUMENTATION_FAILURES_PATTERN
+                                .matcher(statusValue.trim())
+                                .matches()) {
+                            mStreamError = statusValue.trim();
+                        }
+                    }
+                }
+            } else {
+                TestResult testInfo = getCurrentTestInfo();
+
+                if (mCurrentKey.equals(StatusKeys.CLASS)) {
+                    testInfo.mTestClass = statusValue.trim();
+                } else if (mCurrentKey.equals(StatusKeys.TEST)) {
+                    testInfo.mTestName = statusValue.trim();
+                } else if (mCurrentKey.equals(StatusKeys.NUMTESTS)) {
+                    try {
+                        testInfo.mNumTests = Integer.parseInt(statusValue);
+                    } catch (NumberFormatException e) {
+                        Log.w(
+                                LOG_TAG,
+                                "Unexpected integer number of tests, received " + statusValue);
+                    }
+                } else if (mCurrentKey.equals(StatusKeys.ERROR)) {
+                    // test run must have failed
+                    handleTestRunFailed(statusValue);
+                } else if (mCurrentKey.equals(StatusKeys.STACK)) {
+                    testInfo.mStackTrace = statusValue;
+                } else if (StatusKeys.CURRENT.equals(mCurrentKey)) {
+                    testInfo.mCurrentTestNumber = statusValue;
+                } else if (!KNOWN_KEYS.contains(mCurrentKey)) {
+                    // Not one of the recognized key/value pairs, so dump it in mTestMetrics
+                    mTestMetrics.put(mCurrentKey, statusValue);
+                }
+            }
+
+            mCurrentKey = null;
+            mCurrentValue = null;
+        }
+    }
+
+    /**
+     * A utility method to return the test metrics from the current test case execution and get
+     * ready for the next one.
+     */
+    private Map<String, String> getAndResetTestMetrics() {
+        Map<String, String> retVal = mTestMetrics;
+        mTestMetrics = new HashMap<String, String>();
+        return retVal;
+    }
+
+    private TestResult getCurrentTestInfo() {
+        if (mCurrentTestResult == null) {
+            mCurrentTestResult = new TestResult();
+        }
+        return mCurrentTestResult;
+    }
+
+    private void clearCurrentTestInfo() {
+        mLastTestResult = mCurrentTestResult;
+        mCurrentTestResult = null;
+    }
+
+    /**
+     * Parses the key from the current line. Expects format of "key=value".
+     *
+     * @param line full line of text to parse
+     * @param keyStartPos the starting position of the key in the given line
+     */
+    private void parseKey(String line, int keyStartPos) {
+        int endKeyPos = line.indexOf('=', keyStartPos);
+        if (endKeyPos != -1) {
+            mCurrentKey = line.substring(keyStartPos, endKeyPos).trim();
+            parseValue(line, endKeyPos + 1);
+        }
+    }
+
+    /**
+     * Parses the start of a key=value pair.
+     *
+     * @param line - full line of text to parse
+     * @param valueStartPos - the starting position of the value in the given line
+     */
+    private void parseValue(String line, int valueStartPos) {
+        mCurrentValue = new StringBuilder();
+        mCurrentValue.append(line.substring(valueStartPos));
+    }
+
+    /** Parses out a status code result. */
+    private void parseStatusCode(String line) {
+        String value = line.substring(Prefixes.STATUS_CODE.length()).trim();
+        TestResult testInfo = getCurrentTestInfo();
+        testInfo.mCode = StatusCodes.ERROR;
+        try {
+            testInfo.mCode = Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            Log.w(LOG_TAG, "Expected integer status code, received: " + value);
+            testInfo.mCode = StatusCodes.ERROR;
+        }
+        if (testInfo.mCode != StatusCodes.IN_PROGRESS) {
+            // this means we're done with current test result bundle
+            reportResult(testInfo);
+            clearCurrentTestInfo();
+        }
+    }
+
+    /**
+     * Returns true if test run canceled.
+     *
+     * @see IShellOutputReceiver#isCancelled()
+     */
+    @Override
+    public boolean isCancelled() {
+        return mIsCancelled;
+    }
+
+    /** Requests cancellation of test run. */
+    @Override
+    public void cancel() {
+        mIsCancelled = true;
+    }
+
+    /**
+     * Reports a test result to the test run listener. Must be called when a individual test result
+     * has been fully parsed.
+     *
+     * @param testInfo The {@link TestResult} holding the current test infos.
+     */
+    private void reportResult(TestResult testInfo) {
+        if (!testInfo.isComplete()) {
+            Log.w(LOG_TAG, "invalid instrumentation status bundle " + testInfo.toString());
+            return;
+        }
+        reportTestRunStarted(testInfo);
+        TestIdentifier testId = new TestIdentifier(testInfo.mTestClass, testInfo.mTestName);
+        Map<String, String> metrics;
+
+        switch (testInfo.mCode) {
+            case StatusCodes.START:
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testStarted(testId);
+                }
+                break;
+            case StatusCodes.FAILURE:
+                // If a test failure was already reported for the same test number
+                // ('current' number), we avoid reporting a second repeated failure since it would
+                // cause inconsistent events.
+                if (mLastTestResult.mCurrentTestNumber != null
+                        && mLastTestResult.mCurrentTestNumber.equals(
+                                mCurrentTestResult.mCurrentTestNumber)
+                        && mLastTestResult.mStackTrace != null) {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "Ignoring repeated failed event for %s. Stack: %s",
+                                    mCurrentTestResult.toString(), mCurrentTestResult.mStackTrace));
+                    break;
+                }
+                metrics = getAndResetTestMetrics();
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testFailed(testId, getTrace(testInfo));
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+            case StatusCodes.ERROR:
+                // we're dealing with a legacy JUnit3 runner that still reports errors.
+                // just report this as a failure, since thats what upstream JUnit4 does
+                metrics = getAndResetTestMetrics();
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testFailed(testId, getTrace(testInfo));
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+            case StatusCodes.IGNORED:
+                metrics = getAndResetTestMetrics();
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testIgnored(testId);
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+            case StatusCodes.ASSUMPTION_FAILURE:
+                metrics = getAndResetTestMetrics();
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testAssumptionFailure(testId, getTrace(testInfo));
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+            case StatusCodes.OK:
+                metrics = getAndResetTestMetrics();
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+            default:
+                metrics = getAndResetTestMetrics();
+                Log.e(LOG_TAG, "Unknown status code received: " + testInfo.mCode);
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testEnded(testId, metrics);
+                }
+                mNumTestsRun++;
+                break;
+        }
+    }
+
+    /**
+     * Reports the start of a test run, and the total test count, if it has not been previously
+     * reported.
+     *
+     * @param testInfo current test status values
+     */
+    private void reportTestRunStarted(TestResult testInfo) {
+        // if start test run not reported yet
+        if (!mTestStartReported && testInfo.mNumTests != null) {
+            for (ITestRunListener listener : mTestListeners) {
+                listener.testRunStarted(mTestRunName, testInfo.mNumTests);
+            }
+            mNumTestsExpected = testInfo.mNumTests;
+            mTestStartReported = true;
+        }
+    }
+
+    /** Returns the stack trace of the current failed test, from the provided testInfo. */
+    private String getTrace(TestResult testInfo) {
+        if (testInfo.mStackTrace != null) {
+            return testInfo.mStackTrace;
+        } else {
+            Log.e(LOG_TAG, "Could not find stack trace for failed test ");
+            return new Throwable("Unknown failure").toString();
+        }
+    }
+
+    /**
+     * Parses out and store the elapsed time. Elapsed time format use comma separation above 1000.
+     * For example: "Time: 1,745.755" which should be handled.
+     */
+    private void parseTime(String line) {
+        final Pattern timePattern =
+                Pattern.compile(String.format("%s\\s*([\\d\\,]*[\\d\\.]+)", Prefixes.TIME_REPORT));
+        Matcher timeMatcher = timePattern.matcher(line);
+        if (timeMatcher.find()) {
+            String timeString = timeMatcher.group(1);
+            try {
+                Number n = NumberFormat.getInstance().parse(timeString);
+                float timeSeconds = n.floatValue();
+                mTestTime = (long) (timeSeconds * 1000);
+            } catch (ParseException e) {
+                Log.w(LOG_TAG, String.format("Unexpected time format %1$s", line));
+            }
+        } else {
+            Log.w(LOG_TAG, String.format("Unexpected time format %1$s", line));
+        }
+    }
+
+    @Override
+    public void handleTestRunFailed(@NonNull String errorMsg) {
+        Log.i(LOG_TAG, String.format("test run failed: '%1$s'", errorMsg));
+        if (mLastTestResult != null
+                && mLastTestResult.isComplete()
+                && StatusCodes.START == mLastTestResult.mCode) {
+
+            // received test start msg, but not test complete
+            // assume test caused this, report as test failure
+            TestIdentifier testId =
+                    new TestIdentifier(mLastTestResult.mTestClass, mLastTestResult.mTestName);
+            for (ITestRunListener listener : mTestListeners) {
+                listener.testFailed(
+                        testId,
+                        String.format(
+                                "%1$s. Reason: '%2$s'. %3$s",
+                                INCOMPLETE_TEST_ERR_MSG_PREFIX,
+                                errorMsg,
+                                INCOMPLETE_TEST_ERR_MSG_POSTFIX));
+                listener.testEnded(testId, getAndResetTestMetrics());
+            }
+        }
+        for (ITestRunListener listener : mTestListeners) {
+            if (!mTestStartReported) {
+                // test run wasn't started - must have crashed before it started
+                listener.testRunStarted(mTestRunName, 0);
+            }
+            String runErrorMsg = errorMsg;
+            if (mOnError != null) {
+                runErrorMsg = String.format("%s. %s", errorMsg, mOnError);
+            } else if (mStreamError != null) {
+                runErrorMsg = String.format("%s. %s", errorMsg, mStreamError);
+            }
+            listener.testRunFailed(runErrorMsg);
+
+            if (mTestTime == null) {
+                // We don't report an extra failure due to missing time stamp.
+                mTestTime = 0L;
+            }
+            listener.testRunEnded(mTestTime, mInstrumentationResultBundle);
+        }
+        mOnError = null;
+        mTestStartReported = true;
+        mTestRunFailReported = true;
+    }
+
+    /** Called by parent when adb session is complete. */
+    @Override
+    public void done() {
+        super.done();
+        if (!mTestRunFailReported) {
+            handleOutputDone();
+        }
+    }
+
+    /** Handles the end of the adb session when a test run failure has not been reported yet */
+    private void handleOutputDone() {
+        if (!mTestStartReported && !mTestRunFinished) {
+            // no results
+            handleTestRunFailed(NO_TEST_RESULTS_MSG);
+        } else if (mNumTestsExpected > mNumTestsRun) {
+            final String message =
+                    String.format(
+                            "%1$s. Expected %2$d tests, received %3$d",
+                            INCOMPLETE_RUN_ERR_MSG_PREFIX, mNumTestsExpected, mNumTestsRun);
+            handleTestRunFailed(message);
+        } else {
+            if (!mTestStartReported) {
+                // test run wasn't started, but it finished successfully. Must be a run with
+                // no tests
+                for (ITestRunListener listener : mTestListeners) {
+                    listener.testRunStarted(mTestRunName, 0);
+                }
+            }
+            if (mTestTime == null) {
+                mTestTime = 0L;
+            }
+            for (ITestRunListener listener : mTestListeners) {
+                // If we haven't reported a failure yet
+                if (!mTestRunFailReported
+                        && mStreamError != null
+                        && mStreamError.contains(FATAL_EXCEPTION_MSG)) {
+                    // If we reach here, this means the instrumentation fatally failed while being
+                    // in -e log true mode. Resulting in only the stream containing the exception.
+                    listener.testRunFailed(mStreamError.trim());
+                }
+                listener.testRunEnded(mTestTime, mInstrumentationResultBundle);
+            }
+        }
+    }
+}
diff --git a/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java b/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java
index 3c5cc8d22..24b3b77fe 100644
--- a/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java
+++ b/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java
@@ -24,8 +24,6 @@ import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IInstrumentationResultParser;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
 import com.android.ddmlib.testrunner.ITestRunListener;
-import com.android.ddmlib.testrunner.InstrumentationProtoResultParser;
-import com.android.ddmlib.testrunner.InstrumentationResultParser;
 import com.android.tradefed.log.Log;
 import com.android.tradefed.log.LogUtil.CLog;
 
diff --git a/src/com/android/tradefed/result/ddmlib/TestRunToTestInvocationForwarder.java b/src/com/android/tradefed/result/ddmlib/TestRunToTestInvocationForwarder.java
index 40bb1f714..6ee456873 100644
--- a/src/com/android/tradefed/result/ddmlib/TestRunToTestInvocationForwarder.java
+++ b/src/com/android/tradefed/result/ddmlib/TestRunToTestInvocationForwarder.java
@@ -54,6 +54,7 @@ public class TestRunToTestInvocationForwarder implements ITestRunListener {
     // so catch it, and avoid it at the root.
     private TestIdentifier mInvalidMethod = null;
     private boolean mNullMethodIsIgnored = false;
+    private String mNullMethodIsAssumptionFailure = null;
     private String mNullStack = null;
 
     public TestRunToTestInvocationForwarder(Collection<ITestLifeCycleReceiver> listeners) {
@@ -72,6 +73,7 @@ public class TestRunToTestInvocationForwarder implements ITestRunListener {
             return;
         }
         mNullMethodIsIgnored = false;
+        mNullMethodIsAssumptionFailure = null;
         mInvalidMethod = null;
         for (ITestLifeCycleReceiver listener : mListeners) {
             try {
@@ -88,6 +90,7 @@ public class TestRunToTestInvocationForwarder implements ITestRunListener {
     @Override
     public void testAssumptionFailure(TestIdentifier testId, String trace) {
         if (mInvalidMethod != null && mInvalidMethod.equals(testId)) {
+            mNullMethodIsAssumptionFailure = trace;
             return;
         }
         for (ITestLifeCycleReceiver listener : mListeners) {
@@ -151,6 +154,17 @@ public class TestRunToTestInvocationForwarder implements ITestRunListener {
                     listener.testIgnored(TestDescription.createFromTestIdentifier(testId));
                     // testEnded is reported below
                 }
+            } else if (mNullMethodIsAssumptionFailure != null) {
+                CLog.d(
+                        "assumptionFailure null method reported, most likely an Assume failure in"
+                                + " setup class");
+                for (ITestLifeCycleReceiver listener : mListeners) {
+                    listener.testAssumptionFailure(
+                            TestDescription.createFromTestIdentifier(testId),
+                            mNullMethodIsAssumptionFailure);
+                }
+                // Return directly after communicating the assumption failure
+                return;
             } else {
                 String message =
                         String.format(
diff --git a/src/com/android/tradefed/result/proto/FileProtoResultReporter.java b/src/com/android/tradefed/result/proto/FileProtoResultReporter.java
index 5424330e3..169fa6d45 100644
--- a/src/com/android/tradefed/result/proto/FileProtoResultReporter.java
+++ b/src/com/android/tradefed/result/proto/FileProtoResultReporter.java
@@ -92,11 +92,6 @@ public class FileProtoResultReporter extends ProtoResultReporter {
         return super.createModuleChildReference(record);
     }
 
-    /** Sets the file where to output the result. */
-    public void setFileOutput(File output) {
-        mOutputFile = output;
-    }
-
     /** Enable writing each module individualy to a file. */
     public void setPeriodicWriting(boolean enabled) {
         mPeriodicWriting = enabled;
diff --git a/src/com/android/tradefed/result/proto/InvocationProtoResultReporter.java b/src/com/android/tradefed/result/proto/InvocationProtoResultReporter.java
new file mode 100644
index 000000000..68ff6e1b2
--- /dev/null
+++ b/src/com/android/tradefed/result/proto/InvocationProtoResultReporter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.proto;
+
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.result.FailureDescription;
+
+/** Reporters to store invocation level caching information and its list of modules */
+public class InvocationProtoResultReporter extends ModuleProtoResultReporter {
+
+    public InvocationProtoResultReporter() {
+        super();
+    }
+
+    public InvocationProtoResultReporter(
+            IInvocationContext mainInvocationContext, boolean granularResults) {
+        super(mainInvocationContext, granularResults);
+    }
+
+    @Override
+    public void invocationStarted(IInvocationContext context) {
+        IInvocationContext stubContext = createCachedContext();
+        super.invocationStarted(stubContext);
+    }
+
+    @Override
+    public void invocationFailed(FailureDescription failure) {
+        reportStopCaching();
+    }
+
+    @Override
+    public void invocationFailed(Throwable cause) {
+        reportStopCaching();
+    }
+
+    @Override
+    protected void beforeModuleStart() {
+        // Override parent implementation
+    }
+}
diff --git a/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java b/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java
index 728565213..3f8b06870 100644
--- a/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java
+++ b/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java
@@ -56,11 +56,7 @@ public class ModuleProtoResultReporter extends FileProtoResultReporter {
 
     @Override
     protected void beforeModuleStart() {
-        IInvocationContext stubContext = new InvocationContext();
-        if (mInvocationId != null) {
-            CLog.d("Copying property into module results: %s", mInvocationId);
-            stubContext.addInvocationAttribute(INVOCATION_ID_KEY, mInvocationId);
-        }
+        IInvocationContext stubContext = createCachedContext();
         invocationStarted(stubContext);
     }
 
@@ -75,7 +71,7 @@ public class ModuleProtoResultReporter extends FileProtoResultReporter {
             super.processTestCaseEnded(testCaseRecord);
         }
         if (testCaseRecord.getStatus().equals(TestStatus.FAIL)) {
-            mStopCache = true;
+            reportStopCaching();
         }
     }
 
@@ -85,7 +81,7 @@ public class ModuleProtoResultReporter extends FileProtoResultReporter {
             super.processTestRunEnded(runRecord, moduleInProgress);
         }
         if (runRecord.hasDebugInfo()) {
-            mStopCache = true;
+            reportStopCaching();
         }
     }
 
@@ -93,7 +89,7 @@ public class ModuleProtoResultReporter extends FileProtoResultReporter {
     public void processTestModuleEnd(TestRecord moduleRecord) {
         super.processTestModuleEnd(moduleRecord);
         if (moduleRecord.hasSkipReason()) {
-            mStopCache = true;
+            reportStopCaching();
         }
     }
 
@@ -101,6 +97,23 @@ public class ModuleProtoResultReporter extends FileProtoResultReporter {
         return mStopCache;
     }
 
+    public void reportStopCaching() {
+        mStopCache = true;
+    }
+
+    public boolean reportGranularResults() {
+        return mGranularResults;
+    }
+
+    protected IInvocationContext createCachedContext() {
+        IInvocationContext stubContext = new InvocationContext();
+        if (mInvocationId != null) {
+            CLog.d("Copying property into module results: %s", mInvocationId);
+            stubContext.addInvocationAttribute(INVOCATION_ID_KEY, mInvocationId);
+        }
+        return stubContext;
+    }
+
     private void copyAttributes(IInvocationContext mainContext) {
         String invocationId = mainContext.getAttribute(INVOCATION_ID_KEY);
         if (!Strings.isNullOrEmpty(invocationId)) {
diff --git a/src/com/android/tradefed/result/proto/ProtoResultParser.java b/src/com/android/tradefed/result/proto/ProtoResultParser.java
index 437ab94b6..8ee5bad92 100644
--- a/src/com/android/tradefed/result/proto/ProtoResultParser.java
+++ b/src/com/android/tradefed/result/proto/ProtoResultParser.java
@@ -530,7 +530,7 @@ public class ProtoResultParser {
 
     /** Handles the test cases level of the invocation. */
     private void handleTestCase(TestRecord testcaseProto) {
-        String[] info = testcaseProto.getTestRecordId().split("#");
+        String[] info = testcaseProto.getTestRecordId().split("#", 2);
         TestDescription description = new TestDescription(info[0], info[1]);
         if (testcaseProto.hasEndTime()) {
             // Allow end event that also report start in one go. When using
diff --git a/src/com/android/tradefed/result/proto/ProtoResultReporter.java b/src/com/android/tradefed/result/proto/ProtoResultReporter.java
index e24c64db6..032f70388 100644
--- a/src/com/android/tradefed/result/proto/ProtoResultReporter.java
+++ b/src/com/android/tradefed/result/proto/ProtoResultReporter.java
@@ -168,7 +168,7 @@ public abstract class ProtoResultReporter
     // Invocation events
 
     @Override
-    public final void invocationStarted(IInvocationContext context) {
+    public void invocationStarted(IInvocationContext context) {
         mLatestChild = new Stack<>();
         mInvocationRecordBuilder = TestRecord.newBuilder();
         // Set invocation unique id
diff --git a/src/com/android/tradefed/result/proto/StreamProtoReceiver.java b/src/com/android/tradefed/result/proto/StreamProtoReceiver.java
index 4515eda61..80e38fc24 100644
--- a/src/com/android/tradefed/result/proto/StreamProtoReceiver.java
+++ b/src/com/android/tradefed/result/proto/StreamProtoReceiver.java
@@ -43,6 +43,7 @@ public class StreamProtoReceiver implements Closeable {
 
     private static final int DEFAULT_AVAILABLE_PORT = 0;
     private static final long PER_MODULE_EXTRA_WAIT_TIME_MS = 5000L;
+    private static final long PER_TESTRUN_EXTRA_WAIT_TIME_MS = 2000L;
 
     private EventReceiverThread mEventReceiver;
     private ITestInvocationListener mListener;
@@ -339,6 +340,11 @@ public class StreamProtoReceiver implements Closeable {
             TestLevel level = mParser.processNewProto(receivedRecord);
             if (TestLevel.MODULE.equals(level) && !mJoinStarted.get()) {
                 mExtraWaitTimeForEvents += PER_MODULE_EXTRA_WAIT_TIME_MS;
+            } else if (TestLevel.TEST_RUN.equals(level)
+                    && !receivedRecord.hasEndTime()
+                    && !mJoinStarted.get()) {
+                // increase wait time for each new test run
+                mExtraWaitTimeForEvents += PER_TESTRUN_EXTRA_WAIT_TIME_MS;
             }
         } catch (Throwable e) {
             CLog.e(e);
diff --git a/src/com/android/tradefed/result/resultdb/Client.java b/src/com/android/tradefed/result/resultdb/Client.java
new file mode 100644
index 000000000..6438fe0f5
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/Client.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.resultdb.proto.BatchCreateTestResultsRequest;
+import com.android.resultdb.proto.CreateInvocationRequest;
+import com.android.resultdb.proto.CreateTestResultRequest;
+import com.android.resultdb.proto.FinalizeInvocationRequest;
+import com.android.resultdb.proto.Invocation;
+import com.android.resultdb.proto.RecorderGrpc;
+import com.android.resultdb.proto.TestResult;
+import com.android.resultdb.proto.UpdateInvocationRequest;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.auth.Credentials;
+import com.google.auth.oauth2.GoogleCredentials;
+import com.google.common.base.Strings;
+
+import io.grpc.CallOptions;
+import io.grpc.Channel;
+import io.grpc.ClientCall;
+import io.grpc.ClientInterceptor;
+import io.grpc.ForwardingClientCall;
+import io.grpc.ForwardingClientCallListener.SimpleForwardingClientCallListener;
+import io.grpc.ManagedChannel;
+import io.grpc.ManagedChannelBuilder;
+import io.grpc.Metadata;
+import io.grpc.MethodDescriptor;
+import io.grpc.auth.MoreCallCredentials;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.Executors;
+
+/** ResultDB recorder client that uploads test results to ResultDB. */
+public class Client implements IRecorderClient {
+
+    // The key for the update token used to create/update resources undera ResultDB invocation.
+    private static final Metadata.Key<String> UPDATE_TOKEN_METADATA_KEY =
+            Metadata.Key.of("update-token", Metadata.ASCII_STRING_MARSHALLER);
+    private final Uploader mUploader;
+    private final Thread mUploadThread;
+    // The id of the ResultDB invocation used in upload results, update and finalize invocation
+    // request. Currently only one ResultDB invocation per TF invocation is supported.
+    private String mInvocationId;
+    private String mUpdateToken;
+
+    private final RecorderGrpc.RecorderBlockingStub mStub;
+    private final Credentials mCredentials;
+
+    // Both prod and staging Tradedfed instances should report to ResultDB prod server.
+    public static final String SERVER_ADDRESS = "results.api.cr.dev";
+    public static final int SERVER_PORT = 443;
+
+    private Client() {
+        try {
+            mCredentials = GoogleCredentials.getApplicationDefault();
+        } catch (IOException e) {
+            throw new RuntimeException("Failed to get application default credentials", e);
+        }
+        ManagedChannel channel =
+                ManagedChannelBuilder.forAddress(SERVER_ADDRESS, SERVER_PORT)
+                        .executor(Executors.newCachedThreadPool())
+                        .maxInboundMessageSize(32 * 1024)
+                        .build();
+        RecorderGrpc.RecorderBlockingStub stub =
+                RecorderGrpc.newBlockingStub(channel)
+                        .withCallCredentials(MoreCallCredentials.from(mCredentials))
+                        .withInterceptors(recorderInterceptor());
+        mStub = stub;
+        mUploader = new Uploader();
+        mUploadThread = new Thread(mUploader, "Recorder upload thread");
+        mUploadThread.setDaemon(true);
+        mUploadThread.start();
+    }
+
+    public static IRecorderClient create(String invocationId, String updateToken) {
+        Client client = new Client();
+        client.mInvocationId = invocationId;
+        client.mUpdateToken = updateToken;
+        return client;
+    }
+
+    public static IRecorderClient createWithNewInvocation(CreateInvocationRequest request) {
+        Client client = new Client();
+        Invocation invocation = client.createInvocation(request);
+        client.mInvocationId = invocation.getName().replace("invocations/", "");
+        return client;
+    }
+
+    // Interceptor that adds the update token to requests.
+    private ClientInterceptor recorderInterceptor() {
+        ClientInterceptor clientInterceptor =
+                new ClientInterceptor() {
+                    @Override
+                    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
+                            MethodDescriptor<ReqT, RespT> method,
+                            CallOptions callOptions,
+                            Channel next) {
+                        ClientCall<ReqT, RespT> delegate = next.newCall(method, callOptions);
+                        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(
+                                delegate) {
+                            @Override
+                            public void start(Listener<RespT> responseListener, Metadata headers) {
+                                if (!Strings.isNullOrEmpty(mUpdateToken)) {
+                                    // Add update token to request header.
+                                    headers.put(UPDATE_TOKEN_METADATA_KEY, mUpdateToken);
+                                }
+
+                                super.start(
+                                        new SimpleForwardingClientCallListener<RespT>(
+                                                responseListener) {
+                                            @Override
+                                            public void onHeaders(Metadata headers) {
+                                                String fullMethodName = method.getFullMethodName();
+                                                if (fullMethodName.equals(
+                                                        "luci.resultdb.v1.Recorder/CreateInvocation")) {
+                                                    String updateToken =
+                                                            headers.get(UPDATE_TOKEN_METADATA_KEY);
+
+                                                    if (!Strings.isNullOrEmpty(updateToken)) {
+                                                        // Retrieve the update token from the
+                                                        // response header.
+                                                        mUpdateToken = updateToken;
+                                                    }
+                                                }
+                                                super.onHeaders(headers);
+                                            }
+                                        },
+                                        headers);
+                            }
+                        };
+                    }
+                };
+        return clientInterceptor;
+    }
+
+    private Invocation createInvocation(CreateInvocationRequest request) {
+        Invocation invocation = mStub.createInvocation(request);
+        CLog.i("Created invocation: %s", invocation.getName());
+        return invocation;
+    }
+
+    @Override
+    public Invocation updateInvocation(UpdateInvocationRequest request) {
+        // TODO: Call recorder grpc client to update invocation.
+        CLog.i("Updating invocation: %s", request.toString());
+        return request.getInvocation();
+    }
+
+    @Override
+    public Invocation finalizeInvocation() {
+        CLog.i("Finalizing invocation: %s", mInvocationId);
+        return mStub.finalizeInvocation(
+                FinalizeInvocationRequest.newBuilder()
+                        .setName("invocations/" + mInvocationId)
+                        .build());
+    }
+
+    @Override
+    public void uploadTestResult(TestResult result) {
+        mUploader.enqueue(result);
+    }
+
+    @Override
+    public void finalizeTestResults() {
+        mUploader.cancel();
+        try {
+            mUploadThread.join();
+        } catch (InterruptedException e) {
+            CLog.e("Error joining upload thread: %s", e);
+        }
+    }
+
+    private class Uploader implements Runnable {
+        private static final int BATCH_SIZE = 500;
+
+        private final List<List<TestResult>> mPendingBatches = new ArrayList<>();
+        private List<TestResult> currentBatch = new ArrayList<>();
+        private volatile boolean mCanceled = false;
+
+        public void enqueue(TestResult result) {
+            if (mCanceled) {
+                throw new IllegalStateException(
+                        "Attempted to upload results after upload thread was cancelled");
+            }
+            synchronized (this) {
+                if (currentBatch.size() + 1 >= BATCH_SIZE) {
+                    mPendingBatches.add(currentBatch);
+                    currentBatch = new ArrayList<>();
+                    this.notifyAll();
+                }
+                currentBatch.add(result);
+            }
+        }
+
+        public synchronized void forceUpload() {
+            synchronized (this) {
+                if (!currentBatch.isEmpty()) {
+                    mPendingBatches.add(currentBatch);
+                }
+                while (!mPendingBatches.isEmpty()) {
+                    int lastIndex = mPendingBatches.size() - 1;
+                    upload(mPendingBatches.remove(lastIndex));
+                }
+            }
+        }
+
+        public synchronized void cancel() {
+            CLog.i("Canceling recorder uploader");
+            mCanceled = true;
+            this.notifyAll();
+        }
+
+        @Override
+        public void run() {
+            List<TestResult> uploadBatch = new ArrayList<TestResult>();
+            while (!mCanceled) {
+                synchronized (this) {
+                    // Wait with a timeout of 10 seconds when nothing to upload.
+                    if (mPendingBatches.isEmpty()) {
+                        try {
+                            this.wait(10000L);
+                        } catch (InterruptedException e) {
+                            // ignore
+                        }
+                    }
+                    if (!mPendingBatches.isEmpty()) {
+                        int lastIndex = mPendingBatches.size() - 1;
+                        CLog.i(
+                                "Starting batch upload of %d results",
+                                mPendingBatches.get(lastIndex).size());
+                        uploadBatch.addAll(mPendingBatches.remove(lastIndex));
+                    }
+                }
+                if (!uploadBatch.isEmpty()) {
+                    upload(uploadBatch);
+                    uploadBatch.clear();
+                }
+            }
+            // Upload any remaining results.
+            synchronized (this) {
+                if (!currentBatch.isEmpty()) {
+                    mPendingBatches.add(currentBatch);
+                }
+                while (!mPendingBatches.isEmpty()) {
+                    int lastIndex = mPendingBatches.size() - 1;
+                    upload(mPendingBatches.remove(lastIndex));
+                }
+            }
+            CLog.i("Uploader terminating");
+        }
+
+        private void upload(List<TestResult> allResults) {
+            BatchCreateTestResultsRequest.Builder request =
+                    BatchCreateTestResultsRequest.newBuilder()
+                            .setInvocation(String.format("invocations/%s", mInvocationId))
+                            .setRequestId(UUID.randomUUID().toString());
+            for (TestResult result : allResults) {
+                request.addRequests(
+                        CreateTestResultRequest.newBuilder().setTestResult(result).build());
+            }
+            mStub.batchCreateTestResults(request.build());
+            CLog.i("Uploaded %d results to invocation %s", allResults.size(), mInvocationId);
+        }
+    }
+}
diff --git a/src/com/android/tradefed/result/resultdb/IRecorderClient.java b/src/com/android/tradefed/result/resultdb/IRecorderClient.java
new file mode 100644
index 000000000..ca3ebcc10
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/IRecorderClient.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.resultdb.proto.Invocation;
+import com.android.resultdb.proto.TestResult;
+import com.android.resultdb.proto.UpdateInvocationRequest;
+
+/**
+ * Interface for communicating with ResultDB recorder backend. The interface contains methods to
+ * create and update invocations and upload test results.
+ */
+public interface IRecorderClient {
+
+    public Invocation updateInvocation(UpdateInvocationRequest request);
+
+    public Invocation finalizeInvocation();
+
+    public void uploadTestResult(TestResult result);
+
+    public void finalizeTestResults();
+}
diff --git a/src/com/android/tradefed/result/resultdb/ResultDBReporter.java b/src/com/android/tradefed/result/resultdb/ResultDBReporter.java
new file mode 100644
index 000000000..5f288e31c
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/ResultDBReporter.java
@@ -0,0 +1,556 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.resultdb.proto.CreateInvocationRequest;
+import com.android.resultdb.proto.FailureReason;
+import com.android.resultdb.proto.Invocation;
+import com.android.resultdb.proto.StringPair;
+import com.android.resultdb.proto.TestResult;
+import com.android.resultdb.proto.TestStatus;
+import com.android.resultdb.proto.Variant;
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.ILogSaver;
+import com.android.tradefed.result.ILogSaverListener;
+import com.android.tradefed.result.ITestSummaryListener;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.TestSummary;
+import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
+import com.android.tradefed.result.retry.ISupportGranularResults;
+import com.android.tradefed.result.skipped.SkipReason;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.util.MultiMap;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableSet;
+import com.google.protobuf.util.Durations;
+import com.google.protobuf.util.Timestamps;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
+
+@OptionClass(alias = "resultdb-reporter")
+/** Result reporter that uploads test results to ResultDB. */
+public class ResultDBReporter
+        implements ITestSummaryListener,
+                ILogSaverListener,
+                ISupportGranularResults,
+                IConfigurationReceiver {
+
+    public static final int MAX_SUMMARY_HTML_BYTES = 4096;
+
+    public static final int MAX_PRIMARY_ERROR_MESSAGE_BYTES = 1024;
+
+    // Set containing the allowed variant module parameter keys
+    private static final Set<String> ALLOWED_MODULE_PARAMETERS =
+            ImmutableSet.of(ModuleDefinition.MODULE_ABI, ModuleDefinition.MODULE_PARAMETERIZATION);
+    // Tag name for the test mapping source
+    private static final String TEST_MAPPING_TAG = "test_mapping_source";
+
+    @Option(name = "disable", description = "Set to true if reporter is disabled")
+    private boolean mDisable = false;
+
+    // Option used to test Tradefed ResultDB integration without invocation created by ATE.
+    @Option(
+            name = "create-local-invocation",
+            description = "Create a local invocation if invocation is not provided in the context")
+    private boolean mCreateLocalInvocation = false;
+
+    private Invocation mInvocation;
+    // Set to true if the reporter is responsible for updating and finalizing the invocation.
+    private boolean mManageInvocation = false;
+    private IRecorderClient mRecorder;
+
+    // Common variant values for all test in this TF invocation.
+    private Variant mBaseVariant;
+    // Module level variant for test in the same test module.
+    private Variant mModuleVariant;
+    private String mCurrentModule;
+    private TestResult mCurrentTestResult;
+    // Counter for generate test result ID.
+    private AtomicInteger mResultCounter = new AtomicInteger(0);
+    // Base for generate test result ID.
+    private String mResultIdBase;
+
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testLog(String dataName, LogDataType dataType, InputStreamSource dataStream) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void logAssociation(String dataName, LogFile logFile) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void setLogSaver(ILogSaver logSaver) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public TestSummary getSummary() {
+        // TODO: implement this method.
+        return null;
+    }
+
+    @VisibleForTesting
+    IRecorderClient createRecorderClient(String invocationId, String updateToken) {
+        return Client.create(invocationId, updateToken);
+    }
+
+    @VisibleForTesting
+    IRecorderClient createRecorderClient(CreateInvocationRequest request) {
+        return Client.createWithNewInvocation(request);
+    }
+
+    // Generate a random hexadecimal string of length 8.
+    @VisibleForTesting
+    String randomHexString() throws NoSuchAlgorithmException {
+        SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
+        byte[] bytes = new byte[4];
+        random.nextBytes(bytes);
+        return ResultDBUtil.bytesToHex(bytes);
+    }
+
+    @Override
+    public void invocationStarted(IInvocationContext context) {
+        if (mDisable) {
+            CLog.i("ResultDBReporter is disabled");
+            return;
+        }
+        try {
+            // Obtain invocation ID from context.
+            String invocationId = context.getAttribute("resultdb_invocation_id");
+            String updateToken = context.getAttribute("resultdb_invocation_update_token");
+            if (!invocationId.isEmpty() && !updateToken.isEmpty()) {
+                mRecorder = createRecorderClient(invocationId, updateToken);
+            } else if (mCreateLocalInvocation) {
+                mInvocation = Invocation.newBuilder().setRealm("android:ants-experiment").build();
+                invocationId = randomUUIDString().toString();
+                mRecorder =
+                        createRecorderClient(
+                                CreateInvocationRequest.newBuilder()
+                                        .setInvocation(mInvocation)
+                                        .setInvocationId("u-" + invocationId)
+                                        .build());
+                mManageInvocation = true;
+
+            } else {
+                mDisable = true;
+                CLog.i(
+                        "ResultDBReporter is disabled as invocation ID or update token is not"
+                                + " provided.");
+                return;
+            }
+        } catch (RuntimeException e) {
+            mDisable = true;
+            CLog.e("Failed to create ResultDB client.");
+            if (mRecorder != null) {
+                // Make sure we cancel the client, otherwise it will leak a thread since
+                // invocationEnded will be skipped.
+                mRecorder.finalizeTestResults();
+            }
+            throw new RuntimeException(e);
+        }
+        try {
+            mResultIdBase = this.randomHexString();
+        } catch (NoSuchAlgorithmException e) {
+            mDisable = true;
+            CLog.e("Failed to generate random result ID base.");
+            return;
+        }
+        // Variant contains properties in go/consistent-test-identifiers, excluding
+        // properties in ResultDB test identifier.
+        // TODO: Add Test definition properties eg. cluster_id.
+        Variant.Builder mBaseVariantBuilder =
+                Variant.newBuilder()
+                        .putDef("scheduler", "ATP") // ATP is the only scheduler supported for now.
+                        .putDef("name", Strings.nullToEmpty(context.getTestTag()));
+
+        if (!context.getBuildInfos().isEmpty()) {
+            IBuildInfo primaryBuild = context.getBuildInfos().get(0);
+            mBaseVariantBuilder =
+                    mBaseVariantBuilder
+                            .putDef("build_provider", "androidbuild")
+                            .putDef("branch", Strings.nullToEmpty(primaryBuild.getBuildBranch()))
+                            .putDef("target", Strings.nullToEmpty(primaryBuild.getBuildFlavor()));
+        }
+        mBaseVariant = mBaseVariantBuilder.build();
+    }
+
+    @Override
+    public void invocationFailed(Throwable cause) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void invocationFailed(FailureDescription failure) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void invocationSkipped(SkipReason reason) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void invocationEnded(long elapsedTime) {
+        if (mDisable) {
+            return;
+        }
+        mRecorder.finalizeTestResults();
+        if (mManageInvocation) {
+            mRecorder.finalizeInvocation();
+        }
+        // TODO: Update ResultDB invocation with information from TF invocation.
+    }
+
+    @Override
+    public void testModuleStarted(IInvocationContext moduleContext) {
+        if (mDisable) {
+            return;
+        }
+        // Extract module informations.
+        mCurrentModule = moduleContext.getConfigurationDescriptor().getModuleName();
+        mModuleVariant = getModuleVariant(moduleContext.getAttributes());
+    }
+
+    /*
+     * Only module-abi and module-param are used in the variant, so filter other values.
+     */
+    private Variant getModuleVariant(MultiMap<String, String> properties) {
+        Variant.Builder variantBuilder = Variant.newBuilder();
+        for (Map.Entry<String, String> property : properties.entries()) {
+            if (ALLOWED_MODULE_PARAMETERS.contains(property.getKey())) {
+                variantBuilder.putDef(
+                        ResultDBUtil.makeValidKey(property.getKey()), property.getValue());
+            }
+        }
+        return variantBuilder.build();
+    }
+
+    @Override
+    public void testModuleEnded() {
+        // Clear module variant.
+        mModuleVariant = null;
+    }
+
+    @Override
+    public void testRunEnded(
+            long elapsedTimeMillis, HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testRunFailed(String errorMessage) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testRunFailed(FailureDescription failure) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber, long startTime) {
+        // TODO: implement this method.
+    }
+
+    @VisibleForTesting
+    long currentTimestamp() {
+        return System.currentTimeMillis();
+    }
+
+    @VisibleForTesting
+    String randomUUIDString() {
+        return UUID.randomUUID().toString();
+    }
+
+    @Override
+    public void testRunStopped(long elapsedTime) {
+        // TODO: implement this method.
+    }
+
+    @Override
+    public void testStarted(TestDescription test) {
+        testStarted(test, currentTimestamp());
+    }
+
+    @Override
+    public void testStarted(TestDescription test, long startTime) {
+        if (mDisable) {
+            return;
+        }
+        Variant.Builder variantBuilder = Variant.newBuilder();
+        if (mModuleVariant != null) {
+            variantBuilder = variantBuilder.mergeFrom(mModuleVariant);
+        }
+        if (mBaseVariant != null) {
+            variantBuilder = variantBuilder.mergeFrom(mBaseVariant);
+        }
+        mCurrentTestResult =
+                TestResult.newBuilder()
+                        // TODO: Use test id format designed in go/resultdb-test-hierarchy-proposal
+                        .setTestId(
+                                String.format(
+                                        "ants://%s/%s/%s",
+                                        mCurrentModule, test.getClassName(), test.getTestName()))
+                        .setResultId(
+                                String.format(
+                                        "%s-%05d", mResultIdBase, mResultCounter.incrementAndGet()))
+                        .setStartTime(Timestamps.fromMillis(startTime))
+                        .setStatus(TestStatus.PASS)
+                        .setExpected(true)
+                        .setVariant(variantBuilder.build())
+                        .build();
+    }
+
+    @Override
+    public void testAssumptionFailure(TestDescription test, String trace) {
+        testAssumptionFailure(test, FailureDescription.create(trace));
+    }
+
+    @Override
+    public void testAssumptionFailure(TestDescription test, FailureDescription failure) {
+        if (mDisable) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testAssumptionFailure(%s) without a valid testStart before.", test);
+            return;
+        }
+
+        mCurrentTestResult =
+                mCurrentTestResult.toBuilder()
+                        .setStatus(TestStatus.SKIP)
+                        .setExpected(true)
+                        // This is not set in the test result failure reason field, because
+                        // test assumption failure is treated as a ResultDB skip status
+                        // (instead of fail). We will likely re-visit this once we have more
+                        // information on how this is used by downstream.
+                        .setSummaryHtml(
+                                extractFailureReason(
+                                        failure.getErrorMessage(), MAX_SUMMARY_HTML_BYTES))
+                        .build();
+        // TODO: Full error message is too long to fit in any test result field.
+        // Upload it as test artifact.
+    }
+
+    @Override
+    public void testSkipped(TestDescription test, SkipReason reason) {
+        if (mDisable) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testIgnored(%s) without a valid testStart before.", test);
+            return;
+        }
+
+        // ResultDB does not yet have a skip reason field, we put them in the
+        // summary HTML field and test artifact for now.
+        String summaryHtml = "";
+        if (!Strings.isNullOrEmpty(reason.getBugId())) {
+            summaryHtml += "bug_id: " + reason.getBugId() + "<br>";
+        }
+        if (!Strings.isNullOrEmpty(reason.getTrigger())) {
+            summaryHtml += "trigger: " + reason.getTrigger() + "<br>";
+        }
+        // TODO: Skip reason can be too long to fit in any test result field.
+        // Upload it as test artifact.
+
+        mCurrentTestResult =
+                mCurrentTestResult.toBuilder()
+                        .setStatus(TestStatus.SKIP)
+                        .setExpected(true)
+                        .setSummaryHtml(summaryHtml)
+                        .build();
+    }
+
+    @Override
+    public void testFailed(TestDescription test, String trace) {
+        if (mDisable) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testFailed(%s) without a valid testStart before.", test);
+            return;
+        }
+        String failureReason = extractFailureReason(trace, MAX_PRIMARY_ERROR_MESSAGE_BYTES);
+        mCurrentTestResult =
+                mCurrentTestResult.toBuilder()
+                        .setFailureReason(
+                                FailureReason.newBuilder().setPrimaryErrorMessage(failureReason))
+                        .setStatus(TestStatus.FAIL)
+                        .setExpected(false)
+                        .build();
+        // TODO: extract local instruction from test description and set in ResultDB test result.
+        // TODO: trace is too long to fit in any test result field. Upload it as test artifact.
+    }
+
+    @Override
+    public void testFailed(TestDescription test, FailureDescription failure) {
+        if (mDisable) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testFailed(%s) without a valid testStart before.", test);
+            return;
+        }
+        TestStatus status = TestStatus.FAIL;
+        Set<FailureStatus> crashStatus =
+                new HashSet<>(
+                        Arrays.asList(
+                                FailureStatus.TIMED_OUT,
+                                FailureStatus.CANCELLED,
+                                FailureStatus.INFRA_FAILURE,
+                                FailureStatus.SYSTEM_UNDER_TEST_CRASHED));
+        if (crashStatus.contains(failure.getFailureStatus())) {
+            status = TestStatus.CRASH;
+        }
+        String failureReason =
+                extractFailureReason(failure.getErrorMessage(), MAX_PRIMARY_ERROR_MESSAGE_BYTES);
+
+        mCurrentTestResult =
+                mCurrentTestResult.toBuilder()
+                        .setFailureReason(
+                                FailureReason.newBuilder().setPrimaryErrorMessage(failureReason))
+                        .setStatus(status)
+                        .setExpected(false)
+                        .build();
+
+        // Set the TF error type in the summary HTML.
+        if (failure.getFailureStatus() != null) {
+            mCurrentTestResult =
+                    mCurrentTestResult.toBuilder()
+                            .setSummaryHtml("TF error type: " + failure.getFailureStatus())
+                            .build();
+        }
+        // TODO: extract local instruction from test description and set in ResultDB test result.
+        // TODO: trace is too long to fit in any test result field. Upload it as test artifact.
+    }
+
+    @Override
+    public void testIgnored(TestDescription test) {
+        if (mDisable) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testIgnored(%s) without a valid testStart before.", test);
+            return;
+        }
+        mCurrentTestResult =
+                mCurrentTestResult.toBuilder().setStatus(TestStatus.SKIP).setExpected(true).build();
+    }
+
+    @Override
+    public void testEnded(
+            TestDescription test, HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        testEnded(test, currentTimestamp(), testMetrics);
+    }
+
+    @Override
+    public void testEnded(
+            TestDescription test,
+            long endTime,
+            HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        if (mDisable) {
+            return;
+        }
+        long startTimeMillis = Timestamps.toMillis(mCurrentTestResult.getStartTime());
+        TestResult.Builder testResultBuilder =
+                mCurrentTestResult.toBuilder()
+                        .setDuration(Durations.fromMillis(endTime - startTimeMillis));
+
+        // Add test mapping sources to test result as tags.
+        if (testMetrics.get(TEST_MAPPING_TAG) != null) {
+            // Get Test Mapping sources from string formatting with list such as "[path1, path2]".
+            // Note: Some test mapping sources may not be recorded. This is because a test module
+            // can be defined across multiple TEST_MAPPING files, and TF doesn't run it again if
+            // it's passed in the previous run.
+            String testMappingMeasurement =
+                    testMetrics
+                            .get(TEST_MAPPING_TAG)
+                            .getMeasurements()
+                            .getSingleString()
+                            .replaceAll("^\\[| |\\]$", "");
+            List<String> testMappingSources = Arrays.asList(testMappingMeasurement.split(","));
+
+            for (String testMappingSource : testMappingSources) {
+                testResultBuilder.addTags(
+                        StringPair.newBuilder()
+                                .setKey(ResultDBUtil.makeValidKey(TEST_MAPPING_TAG))
+                                .setValue(testMappingSource));
+            }
+        }
+        mCurrentTestResult = testResultBuilder.build();
+        mRecorder.uploadTestResult(mCurrentTestResult);
+        mCurrentTestResult = null;
+    }
+
+    @Override
+    public boolean supportGranularResults() {
+        return true;
+    }
+
+    /**
+     * Extract the first line of the stack trace as the error message, and truncate the string to
+     * the given max bytes.
+     *
+     * <p>In most cases, this ends up being the exception + error message.
+     */
+    String extractFailureReason(String trace, int maxBytes) {
+        String firstLine = trace.split("[\\r\\n]+", 2)[0];
+        if (!firstLine.trim().isEmpty()) {
+            return ResultDBUtil.truncateString(firstLine, maxBytes);
+        }
+        return "";
+    }
+}
diff --git a/src/com/android/tradefed/result/resultdb/ResultDBUtil.java b/src/com/android/tradefed/result/resultdb/ResultDBUtil.java
new file mode 100644
index 000000000..a01aec4d6
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/ResultDBUtil.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import java.nio.charset.StandardCharsets;
+
+/** Utility class for ResultDB reporter. */
+public final class ResultDBUtil {
+
+    /** Converts a byte array to a hexadecimal string. */
+    public static String bytesToHex(byte[] bytes) {
+        StringBuilder sb = new StringBuilder();
+        for (byte b : bytes) {
+            sb.append(String.format("%02x", b));
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Truncates the string to the given max bytes, avoiding breaking up a multi-byte character.
+     *
+     * @param input the string to truncate
+     * @param maxBytes the maximum number of bytes (in utf-8 encoding) to truncate to
+     * @return the truncated string
+     */
+    public static String truncateString(String input, int maxBytes) {
+        byte[] bytes = input.getBytes(StandardCharsets.UTF_8);
+        if (bytes.length <= maxBytes) {
+            return input;
+        }
+
+        int byteCount = 0;
+        StringBuilder result = new StringBuilder();
+
+        for (int i = 0; i < input.length(); ) {
+            int codePoint = input.codePointAt(i);
+            byte[] codePointBytes =
+                    new String(Character.toChars(codePoint)).getBytes(StandardCharsets.UTF_8);
+
+            if (byteCount + codePointBytes.length <= maxBytes) {
+                result.append(Character.toChars(codePoint));
+                byteCount += codePointBytes.length;
+                i += Character.charCount(codePoint); // Move to the next code point
+            } else {
+                break;
+            }
+        }
+        return result.toString();
+    }
+
+    /**
+     * Ensure the key is valid for ResultDB.
+     *
+     * <p>The key must match the regex: ^[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*$
+     */
+    public static String makeValidKey(String key) {
+        if (key == null || key.isEmpty()) {
+            return "empty_key";
+        }
+
+        StringBuilder validKeyBuilder = new StringBuilder();
+        for (char c : key.toCharArray()) {
+            if (c >= 'a' && c <= 'z') {
+                validKeyBuilder.append(c);
+            } else if (c >= '0' && c <= '9') {
+                validKeyBuilder.append(c);
+            } else if (c >= 'A' && c <= 'Z') {
+                validKeyBuilder.append((char) (c - 'A' + 'a'));
+            } else {
+                validKeyBuilder.append('_');
+            }
+        }
+        String validKey = validKeyBuilder.toString();
+        if (!validKey.isEmpty() && validKey.charAt(0) >= '0' && validKey.charAt(0) <= '9') {
+            validKey = "num_" + validKey;
+        }
+        return validKey;
+    }
+}
diff --git a/src/com/android/tradefed/result/resultdb/StubClient.java b/src/com/android/tradefed/result/resultdb/StubClient.java
new file mode 100644
index 000000000..7a50ea07c
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/StubClient.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.resultdb.proto.Invocation;
+import com.android.resultdb.proto.TestResult;
+import com.android.resultdb.proto.UpdateInvocationRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** Stub implementation of IRecorderClient for testing. */
+class StubClient implements IRecorderClient {
+    private List<TestResult> mTestResults = new ArrayList<>();
+    private Invocation mInvocation;
+
+    public static StubClient create() {
+        return new StubClient();
+    }
+
+    private StubClient() {}
+
+    @Override
+    public Invocation finalizeInvocation() {
+        return Invocation.getDefaultInstance();
+    }
+
+    @Override
+    public Invocation updateInvocation(UpdateInvocationRequest request) {
+        // TODO: implement this method.
+        return null;
+    }
+
+    @Override
+    public void uploadTestResult(TestResult result) {
+        mTestResults.add(result);
+    }
+
+    public List<TestResult> getTestResults() {
+        return mTestResults;
+    }
+
+    public Invocation getInvocation() {
+        return mInvocation;
+    }
+
+    @Override
+    public void finalizeTestResults() {
+        // Do nothing.
+    }
+}
diff --git a/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java b/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
index 04630425e..305eadaca 100644
--- a/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
+++ b/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 package com.android.tradefed.result.skipped;
+
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.content.ContentAnalysisContext;
@@ -21,6 +22,7 @@ import com.android.tradefed.build.content.ContentAnalysisContext.AnalysisMethod;
 import com.android.tradefed.build.content.ContentAnalysisResults;
 import com.android.tradefed.build.content.ImageContentAnalyzer;
 import com.android.tradefed.build.content.TestContentAnalyzer;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.NullDevice;
 import com.android.tradefed.invoker.InvocationContext;
@@ -36,6 +38,7 @@ import com.android.tradefed.util.SystemUtil;
 import build.bazel.remote.execution.v2.Digest;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -46,6 +49,7 @@ public class ArtifactsAnalyzer {
     // A build attribute describing that the device image didn't change from base build
     public static final String DEVICE_IMAGE_NOT_CHANGED = "DEVICE_IMAGE_NOT_CHANGED";
     private final TestInformation information;
+    private final IConfiguration configuration;
     private final MultiMap<ITestDevice, ContentAnalysisContext> mImageAnalysis;
     private final List<ContentAnalysisContext> mTestArtifactsAnalysisContent;
     private final List<String> mModulesDiscovered;
@@ -54,12 +58,14 @@ public class ArtifactsAnalyzer {
 
     public ArtifactsAnalyzer(
             TestInformation information,
+            IConfiguration configuration,
             MultiMap<ITestDevice, ContentAnalysisContext> imageAnalysis,
             List<ContentAnalysisContext> testAnalysisContexts,
             List<String> moduleDiscovered,
             List<String> dependencyFiles,
             AnalysisHeuristic analysisLevel) {
         this.information = information;
+        this.configuration = configuration;
         this.mImageAnalysis = imageAnalysis;
         this.mTestArtifactsAnalysisContent = testAnalysisContexts;
         this.mModulesDiscovered = moduleDiscovered;
@@ -72,11 +78,16 @@ public class ArtifactsAnalyzer {
             return null;
         }
         List<BuildAnalysis> reports = new ArrayList<>();
+        int i = 0;
         for (Entry<ITestDevice, IBuildInfo> deviceBuild :
                 information.getContext().getDeviceBuildMap().entrySet()) {
             BuildAnalysis report =
-                    analyzeArtifact(deviceBuild, mImageAnalysis.get(deviceBuild.getKey()));
+                    analyzeArtifact(
+                            deviceBuild,
+                            mImageAnalysis.get(deviceBuild.getKey()),
+                            configuration.getDeviceConfig().get(i).isFake());
             reports.add(report);
+            i++;
         }
         if (reports.size() > 1) {
             InvocationMetricLogger.addInvocationMetrics(
@@ -90,6 +101,9 @@ public class ArtifactsAnalyzer {
             if (mTestArtifactsAnalysisContent.isEmpty()) {
                 // Couldn't do analysis, assume changes
                 finalReport.setChangesInTests(true);
+                Map<String, Digest> errorMap = new HashMap<String, Digest>();
+                errorMap.put(TestContentAnalyzer.TESTS_DIR_KEY, null);
+                finalReport.addTestArtifactsDigestMapping(errorMap);
             } else {
                 try (CloseableTraceScope ignored =
                         new CloseableTraceScope(
@@ -104,6 +118,9 @@ public class ArtifactsAnalyzer {
                     ContentAnalysisResults analysisResults = analyzer.evaluate();
                     if (analysisResults == null) {
                         finalReport.setChangesInTests(true);
+                        Map<String, Digest> errorMap = new HashMap<String, Digest>();
+                        errorMap.put(TestContentAnalyzer.TESTS_DIR_KEY, null);
+                        finalReport.addTestArtifactsDigestMapping(errorMap);
                     } else {
                         CLog.d("%s", analysisResults.toString());
                         finalReport.setChangesInTests(analysisResults.hasAnyTestsChange());
@@ -111,6 +128,8 @@ public class ArtifactsAnalyzer {
                             finalReport.addUnchangedModules(analysisResults.getUnchangedModules());
                         }
                         finalReport.addImageDigestMapping(analysisResults.getImageToDigest());
+                        finalReport.addTestArtifactsDigestMapping(
+                                analysisResults.getArtifactToDigest());
                     }
                 } catch (RuntimeException e) {
                     CLog.e(e);
@@ -123,12 +142,15 @@ public class ArtifactsAnalyzer {
     }
 
     private BuildAnalysis analyzeArtifact(
-            Entry<ITestDevice, IBuildInfo> deviceBuild, List<ContentAnalysisContext> context) {
+            Entry<ITestDevice, IBuildInfo> deviceBuild,
+            List<ContentAnalysisContext> context,
+            boolean isFake) {
         ITestDevice device = deviceBuild.getKey();
         IBuildInfo build = deviceBuild.getValue();
         Map<String, Digest> imageToDigest = new LinkedHashMap<>();
         boolean deviceImageChanged = true; // anchor toward changing
-        if (device.getIDevice() != null
+        if (!isFake
+                && device.getIDevice() != null
                 && device.getIDevice().getClass().isAssignableFrom(NullDevice.class)) {
             deviceImageChanged = false; // No device image
             InvocationMetricLogger.addInvocationMetrics(
diff --git a/src/com/android/tradefed/result/skipped/BuildAnalysis.java b/src/com/android/tradefed/result/skipped/BuildAnalysis.java
index 266e99f01..d6ff4c924 100644
--- a/src/com/android/tradefed/result/skipped/BuildAnalysis.java
+++ b/src/com/android/tradefed/result/skipped/BuildAnalysis.java
@@ -30,23 +30,29 @@ public class BuildAnalysis {
     private boolean mHasChangesInTests = false;
     private Set<String> mUnchangedModules = new HashSet<>();
     private Map<String, Digest> mImageToDigest = new LinkedHashMap<>();
+    private Map<String, Digest> mTestArtifactsToDigest = new LinkedHashMap<>();
 
     public BuildAnalysis(boolean deviceImageChanged, boolean hasTestsArtifacts) {
         this.mDeviceImageChanged = deviceImageChanged;
         this.mHasTestsArtifacts = hasTestsArtifacts;
     }
+
     public boolean deviceImageChanged() {
         return mDeviceImageChanged;
     }
+
     public boolean hasTestsArtifacts() {
         return mHasTestsArtifacts;
     }
+
     public boolean hasChangesInTestsArtifacts() {
         return mHasChangesInTests;
     }
+
     public void setChangesInTests(boolean hasChanges) {
         mHasChangesInTests = hasChanges;
     }
+
     public void addUnchangedModules(Set<String> unchangedModules) {
         mUnchangedModules.addAll(unchangedModules);
     }
@@ -56,6 +62,11 @@ public class BuildAnalysis {
         return this;
     }
 
+    public BuildAnalysis addTestArtifactsDigestMapping(Map<String, Digest> artifactsToDigest) {
+        mTestArtifactsToDigest.putAll(artifactsToDigest);
+        return this;
+    }
+
     public Set<String> getUnchangedModules() {
         return mUnchangedModules;
     }
@@ -64,6 +75,10 @@ public class BuildAnalysis {
         return mImageToDigest;
     }
 
+    public Map<String, Digest> getArtifactsToDigest() {
+        return mTestArtifactsToDigest;
+    }
+
     @Override
     public String toString() {
         return "BuildAnalysis [mDeviceImageChanged="
@@ -74,19 +89,25 @@ public class BuildAnalysis {
                 + mHasChangesInTests
                 + ", imageDigests="
                 + mImageToDigest
+                + ", artifactDigests="
+                + mTestArtifactsToDigest
                 + "]";
     }
+
     public static BuildAnalysis mergeReports(List<BuildAnalysis> reports) {
         boolean deviceImageChanged = false;
         boolean hasTestsArtifacts = false;
         Map<String, Digest> mergedImageToDigest = new LinkedHashMap<>();
+        Map<String, Digest> mergedArtifactToDigest = new LinkedHashMap<>();
         // Anchor toward things changing
         for (BuildAnalysis rep : reports) {
             deviceImageChanged |= rep.deviceImageChanged();
             hasTestsArtifacts |= rep.hasTestsArtifacts();
             mergedImageToDigest.putAll(rep.getImageToDigest());
+            mergedArtifactToDigest.putAll(rep.getArtifactsToDigest());
         }
         return new BuildAnalysis(deviceImageChanged, hasTestsArtifacts)
-                .addImageDigestMapping(mergedImageToDigest);
+                .addImageDigestMapping(mergedImageToDigest)
+                .addTestArtifactsDigestMapping(mergedArtifactToDigest);
     }
 }
diff --git a/src/com/android/tradefed/result/skipped/SkipManager.java b/src/com/android/tradefed/result/skipped/SkipManager.java
index c1c190407..d4190fdf6 100644
--- a/src/com/android/tradefed/result/skipped/SkipManager.java
+++ b/src/com/android/tradefed/result/skipped/SkipManager.java
@@ -107,6 +107,7 @@ public class SkipManager implements IDisableable {
     private String mReasonForSkippingInvocation = "SkipManager decided to skip.";
     private Set<String> mUnchangedModules = new HashSet<>();
     private Map<String, Digest> mImageFileToDigest = new LinkedHashMap<>();
+    private Map<String, Digest> mTestArtifactsToDigest = new LinkedHashMap<>();
 
     /** Setup and initialize the skip manager. */
     public void setup(IConfiguration config, IInvocationContext context) {
@@ -139,6 +140,10 @@ public class SkipManager implements IDisableable {
         return mImageFileToDigest;
     }
 
+    public Map<String, Digest> getTestArtifactsToDigest() {
+        return mTestArtifactsToDigest;
+    }
+
     public void setImageAnalysis(ITestDevice device, ContentAnalysisContext analysisContext) {
         CLog.d(
                 "Received image artifact analysis '%s' for %s",
@@ -166,7 +171,11 @@ public class SkipManager implements IDisableable {
     }
 
     /** Reports whether we should skip the current invocation. */
-    public boolean shouldSkipInvocation(TestInformation information) {
+    public boolean shouldSkipInvocation(TestInformation information, IConfiguration configuration) {
+        if (InvocationContext.isOnDemand(information.getContext())) {
+            // Avoid skipping invocation for on-demand testing
+            return false;
+        }
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope("SkipManager#shouldSkipInvocation")) {
             // Build heuristic for skipping invocation
@@ -174,7 +183,14 @@ public class SkipManager implements IDisableable {
                 Set<String> possibleModules = new HashSet<>();
                 for (ContentAnalysisContext context : mTestArtifactsAnalysisContent) {
                     if (context.analysisMethod().equals(AnalysisMethod.SANDBOX_WORKDIR)) {
-                        possibleModules.addAll(ContentModuleLister.buildModuleList(context));
+                        Set<String> modules = ContentModuleLister.buildModuleList(context);
+                        if (modules == null) {
+                            // If some sort of error occurs, never skip invocation
+                            InvocationMetricLogger.addInvocationMetrics(
+                                    InvocationMetricKey.ERROR_INVOCATION_SKIP, 1);
+                            return false;
+                        }
+                        possibleModules.addAll(modules);
                     }
                 }
                 if (!possibleModules.isEmpty()) {
@@ -207,6 +223,7 @@ public class SkipManager implements IDisableable {
             ArtifactsAnalyzer analyzer =
                     new ArtifactsAnalyzer(
                             information,
+                            configuration,
                             mImageAnalysis,
                             mTestArtifactsAnalysisContent,
                             mModulesDiscovered,
@@ -253,6 +270,7 @@ public class SkipManager implements IDisableable {
             return false;
         }
         mImageFileToDigest.putAll(results.getImageToDigest());
+        mTestArtifactsToDigest.putAll(results.getArtifactsToDigest());
         boolean presubmit = InvocationContext.isPresubmit(information.getContext());
         if (results.deviceImageChanged()) {
             return false;
diff --git a/src/com/android/tradefed/result/suite/XmlFormattedGeneratorReporter.java b/src/com/android/tradefed/result/suite/XmlFormattedGeneratorReporter.java
index c8b1d2c76..4ec611e5f 100644
--- a/src/com/android/tradefed/result/suite/XmlFormattedGeneratorReporter.java
+++ b/src/com/android/tradefed/result/suite/XmlFormattedGeneratorReporter.java
@@ -51,9 +51,7 @@ public class XmlFormattedGeneratorReporter extends FormattedGeneratorReporter {
             CLog.e(e);
         } finally {
             // Once report and checksum files are created, release memory from base class.
-            for (String runName : getTestRunNames()) {
-                clearResultsForName(runName);
-            }
+            clearTestRunResults();
         }
     }
 
diff --git a/src/com/android/tradefed/retry/BaseRetryDecision.java b/src/com/android/tradefed/retry/BaseRetryDecision.java
index b609722f0..a612aa673 100644
--- a/src/com/android/tradefed/retry/BaseRetryDecision.java
+++ b/src/com/android/tradefed/retry/BaseRetryDecision.java
@@ -15,7 +15,6 @@
  */
 package com.android.tradefed.retry;
 
-import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
@@ -24,7 +23,6 @@ import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.device.internal.DeviceResetHandler;
 import com.android.tradefed.device.internal.DeviceSnapshotHandler;
-import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
@@ -34,12 +32,8 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
-import com.android.tradefed.result.TestDescription;
-import com.android.tradefed.result.TestResult;
 import com.android.tradefed.result.TestRunResult;
-import com.android.tradefed.result.TestStatus;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
-import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.ITestFileFilterReceiver;
 import com.android.tradefed.testtype.ITestFilterReceiver;
@@ -48,17 +42,12 @@ import com.android.tradefed.testtype.SubprocessTfLauncher;
 import com.android.tradefed.testtype.retry.IAutoRetriableTest;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
 import com.android.tradefed.testtype.suite.SuiteTestFilter;
-import com.android.tradefed.util.FileUtil;
 
-import java.io.File;
-import java.io.IOException;
+import com.google.common.annotations.VisibleForTesting;
+
 import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.stream.Collectors;
 
@@ -69,8 +58,6 @@ import java.util.stream.Collectors;
 public class BaseRetryDecision
         implements IRetryDecision, IConfigurationReceiver, ITestInformationReceiver {
 
-    private static final int ABORT_MAX_FAILURES = 75;
-
     @Option(
         name = "reboot-at-last-retry",
         description = "Reboot the device at the last retry attempt."
@@ -84,12 +71,29 @@ public class BaseRetryDecision
     private IsolationGrade mRetryIsolationGrade = IsolationGrade.NOT_ISOLATED;
 
     @Option(
-        name = "max-testcase-run-count",
-        description =
-                "If the IRemoteTest can have its testcases run multiple times, "
-                        + "the max number of runs for each testcase."
-    )
-    private int mMaxRetryAttempts = 1;
+            name = "max-testrun-run-count",
+            description =
+                    "If the IRemoteTest can have its modules run multiple times, "
+                            + "the max number of runs for each test run (module). "
+                            + "This is different from max-testcase-run-count which "
+                            + "is for each test case. For example, if the testcase "
+                            + "run count is 1 and the testrun run count is 3, we "
+                            + "will run the module up to 3 times so as to execute "
+                            + "each test case once. Format is "
+                            + "[<module id>:]<run count> . If module is "
+                            + "unspecified, it applies to all modules. Default is "
+                            + "to use the value of max-testcase-run-count.")
+    private Set<String> mTestRunAttempts = new LinkedHashSet<>();
+
+    @Option(
+            name = "max-testcase-run-count",
+            description =
+                    "If the IRemoteTest can have its testcases run multiple times, "
+                            + "the max number of runs for each testcase. Format is "
+                            + "[<module id>:]<run count> . If module is "
+                            + "unspecified, it applies to all modules. "
+                            + "Default is 1 attempt.")
+    private Set<String> mTestCaseAttempts = new LinkedHashSet<>();
 
     @Option(
         name = "retry-strategy",
@@ -118,17 +122,21 @@ public class BaseRetryDecision
                             + "SuiteTestFilter.")
     private Set<String> mSkipRetryingSet = new LinkedHashSet<>();
 
+    @Deprecated
     @Option(
             name = "updated-retry-reporting",
             description = "Feature flag to use the updated retry reporting strategy.")
     private boolean mUpdatedReporting = true;
 
+    @Deprecated
+    @SuppressWarnings("unused")
     @Option(
             name = "updated-filtering",
             description = "Feature flag to use the updated filtering logic.")
     private boolean mUpdatedFiltering = true;
 
     @Deprecated
+    @SuppressWarnings("unused")
     @Option(
             name = "module-preparation-retry",
             description = "Whether or not to retry any module-level target preparation errors." +
@@ -147,8 +155,10 @@ public class BaseRetryDecision
     private TestInformation mTestInformation;
 
     private IRemoteTest mCurrentlyConsideredTest;
-    private Set<TestDescription> mPreviouslyFailing;
     private RetryStatsHelper mStatistics;
+    private RetryTracker mRetryTracker;
+    private ExcludeFilterManager mExcludeManager;
+    private RetryCountParser mRetryCountParser;
 
     /** Constructor for the retry decision */
     public BaseRetryDecision() {}
@@ -168,9 +178,50 @@ public class BaseRetryDecision
         return mRebootAtLastRetry;
     }
 
+    private RetryCountParser getRetryCountParser() {
+        if (mRetryCountParser == null) {
+            mRetryCountParser = new RetryCountParser(mTestCaseAttempts, mTestRunAttempts);
+        }
+        return mRetryCountParser;
+    }
+
     @Override
-    public int getMaxRetryCount() {
-        return mMaxRetryAttempts;
+    public int getMaxTestRunAttempts() {
+        return getMaxTestRunAttempts(null);
+    }
+
+    @Override
+    public int getMaxTestRunAttempts(ModuleDefinition module) {
+        return getRetryCountParser().getMaxTestRunAttempts(module);
+    }
+
+    @Override
+    public int getMaxTestCaseAttempts() {
+        return getRetryCountParser().getMaxTestCaseAttempts(null);
+    }
+
+    @Override
+    public int getMaxTestCaseAttempts(ModuleDefinition module) {
+        return getRetryCountParser().getMaxTestCaseAttempts(module);
+    }
+
+    @Override
+    public List<String> getCommandLineArgs() {
+        List<String> args = new ArrayList<>();
+        args.addAll(getRetryCountParser().getCommandLineArgs());
+        args.addAll(List.of("--retry-strategy", mRetryStrategy.toString()));
+        if (mRebootAtLastRetry) {
+            args.add("--reboot-at-last-retry");
+        }
+        args.addAll(List.of("--retry-isolation-grade", mRetryIsolationGrade.toString()));
+        for (String filterEntry : mSkipRetryingSet) {
+            args.add("--skip-retrying-list");
+            args.add(filterEntry);
+        }
+        if (mSkipRetryInPresubmit) {
+            args.add("--skip-retry-in-presubmit");
+        }
+        return args;
     }
 
     @Override
@@ -262,7 +313,8 @@ public class BaseRetryDecision
         if (test != mCurrentlyConsideredTest) {
             mCurrentlyConsideredTest = test;
             mStatistics = new RetryStatsHelper();
-            mPreviouslyFailing = new HashSet<>();
+            mRetryTracker = new RetryTracker(getMaxTestCaseAttempts(module));
+            mExcludeManager = new ExcludeFilterManager(test);
         }
 
         if (mSkipRetryInPresubmit && InvocationContext.isPresubmit(mContext)) {
@@ -286,6 +338,7 @@ public class BaseRetryDecision
             }
         }
 
+        // Return early for strategies other than RETRY_ANY_FAILURE.
         switch (mRetryStrategy) {
             case NO_RETRY:
                 // Return directly if we are not considering retry at all.
@@ -325,11 +378,17 @@ public class BaseRetryDecision
 
         boolean shouldRetry = false;
         long retryStartTime = System.currentTimeMillis();
-        if (test instanceof ITestFilterReceiver) {
-            // TODO(b/77548917): Right now we only support ITestFilterReceiver. We should expect to
-            // support ITestFile*Filter*Receiver in the future.
-            ITestFilterReceiver filterableTest = (ITestFilterReceiver) test;
-            shouldRetry = handleRetryFailures(filterableTest, previousResults, moduleSkipList);
+        if (test instanceof ITestFilterReceiver || test instanceof ITestFileFilterReceiver) {
+            // Record the attempt for the previous failed tests.
+            mRetryTracker.recordTestRun(previousResults, attemptJustExecuted, moduleSkipList);
+
+            // Setup exclude filters.
+            mExcludeManager.resetDefaultFilters();
+            mExcludeManager.addExcludeFilters(mRetryTracker.getExcludedTests());
+
+            // Check if we should retry.
+            shouldRetry = mRetryTracker.shouldRetry();
+
             if (shouldRetry && !isAlreadyRecovered) {
                 // In case of retry, go through the recovery routine
                 recoverStateOfDevices(getDevices(), attemptJustExecuted, module);
@@ -344,8 +403,8 @@ public class BaseRetryDecision
             }
         } else {
             CLog.d(
-                    "%s does not implement ITestFilterReceiver or IAutoRetriableTest, thus "
-                            + "cannot work with auto-retry.",
+                    "%s does not implement ITestFilterReceiver or ITestFileFilterReceiver or "
+                            + "IAutoRetriableTest, thus cannot work with auto-retry.",
                     test);
             return false;
         }
@@ -370,25 +429,6 @@ public class BaseRetryDecision
         return mStatistics.calculateStatistics();
     }
 
-    /** Returns the map of failed test cases that should be retried. */
-    public static Map<TestDescription, TestResult> getFailedTestCases(
-            List<TestRunResult> previousResults) {
-        Map<TestDescription, TestResult> failedTestCases = new LinkedHashMap<>();
-        for (TestRunResult run : previousResults) {
-            if (run != null) {
-                for (Entry<TestDescription, TestResult> entry : run.getTestResults().entrySet()) {
-                    if (TestStatus.FAILURE.equals(entry.getValue().getResultStatus())) {
-                        failedTestCases.put(entry.getKey(), entry.getValue());
-                    } else if (TestStatus.SKIPPED.equals(entry.getValue().getResultStatus())) {
-                        // Retry skipped test as well
-                        failedTestCases.put(entry.getKey(), entry.getValue());
-                    }
-                }
-            }
-        }
-        return failedTestCases;
-    }
-
     /** Returns true if we should use the updated reporting. */
     @Override
     public boolean useUpdatedReporting() {
@@ -404,21 +444,6 @@ public class BaseRetryDecision
         return mSkipRetryingSet;
     }
 
-    private static Set<TestDescription> getPassedTestCases(List<TestRunResult> previousResults) {
-        Set<TestDescription> previousPassed = new LinkedHashSet<>();
-        for (TestRunResult run : previousResults) {
-            if (run != null) {
-                for (Entry<TestDescription, TestResult> entry : run.getTestResults().entrySet()) {
-                    if (!TestStatus.FAILURE.equals(entry.getValue().getResultStatus())
-                            && !TestStatus.SKIPPED.equals(entry.getValue().getResultStatus())) {
-                        previousPassed.add(entry.getKey());
-                    }
-                }
-            }
-        }
-        return previousPassed;
-    }
-
     /**
      * Skips retry if the module is fully skipped and populate module skip list if only some tests
      * need to stop retrying.
@@ -460,93 +485,6 @@ public class BaseRetryDecision
         return shouldSkip;
     }
 
-    /** Returns the list of failure from the previous results. */
-    private static List<TestRunResult> getRunFailures(List<TestRunResult> previousResults) {
-        List<TestRunResult> runFailed = new ArrayList<>();
-        for (TestRunResult run : previousResults) {
-            if (run != null && run.isRunFailure()) {
-                runFailed.add(run);
-            }
-        }
-        return runFailed;
-    }
-
-    private static List<TestRunResult> getNonRetriableFailures(List<TestRunResult> failedRun) {
-        List<TestRunResult> nonRetriableRuns = new ArrayList<>();
-        for (TestRunResult run : failedRun) {
-            if (!run.getRunFailureDescription().isRetriable()) {
-                nonRetriableRuns.add(run);
-            }
-        }
-        return nonRetriableRuns;
-    }
-
-    private boolean handleRetryFailures(
-            ITestFilterReceiver test,
-            List<TestRunResult> previousResults,
-            Set<String> moduleSkipList) {
-        List<TestRunResult> runFailures = getRunFailures(previousResults);
-        List<TestRunResult> nonRetriableRunFailures = getNonRetriableFailures(runFailures);
-        if (!nonRetriableRunFailures.isEmpty()) {
-            CLog.d("Skipping retry since there was a non-retriable failure.");
-            return false;
-        }
-        if (mUpdatedFiltering && mUpdatedReporting) {
-            CLog.d("Using updated filtering logic.");
-            Map<TestDescription, TestResult> previousFailedTests =
-                    getFailedTestCases(previousResults);
-            if (runFailures.isEmpty() && previousFailedTests.isEmpty()) {
-                CLog.d("No test run or test case failures. No need to retry.");
-                return false;
-            }
-            Set<TestDescription> previouslyPassedTests = getPassedTestCases(previousResults);
-            excludePassedTests(test, previouslyPassedTests);
-            boolean everythingFiltered =
-                    excludeNonRetriableFailure(test, previousFailedTests, moduleSkipList);
-            if (everythingFiltered && runFailures.isEmpty()) {
-                CLog.d("No failures are retriable, skipping retry.");
-                InvocationMetricLogger.addInvocationMetrics(
-                        InvocationMetricKey.RETRY_SKIPPED_ALL_FILTERED_COUNT, 1);
-            }
-            return !everythingFiltered || !runFailures.isEmpty();
-        } else if (!runFailures.isEmpty()) {
-            if (shouldFullRerun(runFailures)) {
-                List<String> names =
-                        runFailures.stream().map(e -> e.getName()).collect(Collectors.toList());
-                CLog.d("Retry the full run since [%s] runs have failures.", names);
-                return true;
-            }
-            // If we don't attempt full rerun add filters.
-            CLog.d("Full rerun not required, excluding previously passed tests.");
-            Set<TestDescription> previouslyPassedTests = getPassedTestCases(previousResults);
-            excludePassedTests(test, previouslyPassedTests);
-            return true;
-        }
-
-        // In case of test case failure, we retry with filters.
-        Map<TestDescription, TestResult> previousFailedTests = getFailedTestCases(previousResults);
-        if (!mPreviouslyFailing.isEmpty()) {
-            previousFailedTests.keySet().retainAll(mPreviouslyFailing);
-            mPreviouslyFailing.retainAll(previousFailedTests.keySet());
-        }
-        // Abort if number of failures is high for a given one test
-        if (previousFailedTests.size() > ABORT_MAX_FAILURES) {
-            CLog.d(
-                    "Found %s failures, skipping auto-retry to avoid large overhead.",
-                    previousFailedTests.size());
-            return false;
-        }
-
-        if (!previousFailedTests.isEmpty()) {
-            CLog.d("Retrying the test case failure.");
-            addRetriedTestsToFilters(test, previousFailedTests);
-            return true;
-        }
-
-        CLog.d("No test run or test case failures. No need to retry.");
-        return false;
-    }
-
     /** Returns true if there are any failures in the previous results. */
     private boolean hasAnyFailures(List<TestRunResult> previousResults) {
         for (TestRunResult run : previousResults) {
@@ -557,113 +495,6 @@ public class BaseRetryDecision
         return false;
     }
 
-    /** If none of the run failures require a full rerun, trigger the partial rerun logic. */
-    private boolean shouldFullRerun(List<TestRunResult> runFailures) {
-        for (TestRunResult run : runFailures) {
-            if (run.getRunFailureDescription().rerunFull()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /** Set the filters on the test runner for the retry. */
-    private void addRetriedTestsToFilters(
-            ITestFilterReceiver test, Map<TestDescription, TestResult> tests) {
-        // Limit the re-run to the failure we include, so clear filters then put our failures
-        test.clearIncludeFilters();
-        for (Entry<TestDescription, TestResult> testCaseEntry : tests.entrySet()) {
-            TestDescription testCase = testCaseEntry.getKey();
-            if (testCaseEntry.getValue().getFailure().isRetriable()) {
-                // We have to retry without the parameters since some runner don't support it.
-                String filter =
-                        String.format(
-                                "%s#%s",
-                                testCase.getClassName(), testCase.getTestNameWithoutParams());
-                test.addIncludeFilter(filter);
-            } else {
-                // If a test case failure is not retriable, track it, but don't retry it so we
-                // exclude it from the filters.
-                String filter =
-                        String.format("%s#%s", testCase.getClassName(), testCase.getTestName());
-                test.addExcludeFilter(filter);
-            }
-            mPreviouslyFailing.add(testCase);
-        }
-    }
-
-    private void excludePassedTests(ITestFilterReceiver test, Set<TestDescription> passedTests) {
-        // Exclude all passed tests for the retry.
-        for (TestDescription testCase : passedTests) {
-            String filter = String.format("%s#%s", testCase.getClassName(), testCase.getTestName());
-            if (test instanceof ITestFileFilterReceiver) {
-                addFilterToExcludeFilterFile((ITestFileFilterReceiver) test, filter);
-            } else {
-                test.addExcludeFilter(filter);
-            }
-        }
-    }
-
-    /** Returns true if all failure are filtered out */
-    private boolean excludeNonRetriableFailure(
-            ITestFilterReceiver test,
-            Map<TestDescription, TestResult> previousFailedTests,
-            Set<String> skipListForModule) {
-        Set<TestDescription> failedTests = new HashSet<>(previousFailedTests.keySet());
-        for (Entry<TestDescription, TestResult> testCaseEntry : previousFailedTests.entrySet()) {
-            TestDescription testCase = testCaseEntry.getKey();
-            if (!TestStatus.FAILURE.equals(testCaseEntry.getValue().getResultStatus())) {
-                // Only consider failures for retriable failures.
-                continue;
-            }
-            if (!testCaseEntry.getValue().getFailure().isRetriable()) {
-                // If a test case failure is not retriable, exclude it from the filters.
-                String filter =
-                        String.format("%s#%s", testCase.getClassName(), testCase.getTestName());
-                if (test instanceof ITestFileFilterReceiver) {
-                    addFilterToExcludeFilterFile((ITestFileFilterReceiver) test, filter);
-                } else {
-                    test.addExcludeFilter(filter);
-                }
-                failedTests.remove(testCase);
-            }
-            if (skipListForModule.contains(testCase.toString())) {
-                // If a test case failure is excluded from retry, exclude it
-                String filter =
-                        String.format("%s#%s", testCase.getClassName(), testCase.getTestName());
-                if (test instanceof ITestFileFilterReceiver) {
-                    addFilterToExcludeFilterFile((ITestFileFilterReceiver) test, filter);
-                } else {
-                    test.addExcludeFilter(filter);
-                }
-                InvocationMetricLogger.addInvocationMetrics(
-                        InvocationMetricKey.RETRY_TEST_SKIPPED_COUNT, 1);
-                failedTests.remove(testCase);
-                CLog.d("Skip retry of %s, it's in skip-retry-list.", filter);
-            }
-        }
-
-        return failedTests.isEmpty();
-    }
-
-    private void addFilterToExcludeFilterFile(ITestFileFilterReceiver test, String filter) {
-        File excludeFilterFile = test.getExcludeTestFile();
-        if (excludeFilterFile == null) {
-            try {
-                excludeFilterFile = FileUtil.createTempFile("exclude-filter", ".txt");
-            } catch (IOException e) {
-                throw new HarnessRuntimeException(
-                        e.getMessage(), e, InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
-            }
-            ((ITestFileFilterReceiver) test).setExcludeTestFile(excludeFilterFile);
-        }
-        try {
-            FileUtil.writeToFile(filter + "\n", excludeFilterFile, true);
-        } catch (IOException e) {
-            CLog.e(e);
-        }
-    }
-
     /** Returns all the non-stub device associated with the {@link IRemoteTest}. */
     private List<ITestDevice> getDevices() {
         List<ITestDevice> listDevices = new ArrayList<>(mContext.getDevices());
@@ -693,7 +524,7 @@ public class BaseRetryDecision
             }
         } else if (IsolationGrade.FULLY_ISOLATED.equals(mRetryIsolationGrade)) {
             resetIsolation(module, devices);
-        } else if (lastAttempt == (mMaxRetryAttempts - 2)) {
+        } else if (lastAttempt >= (getMaxTestCaseAttempts(module) - 2)) {
             // Reset only works for suite right now
             if (mRebootAtLastRetry) {
                 for (ITestDevice device : devices) {
@@ -773,4 +604,4 @@ public class BaseRetryDecision
                     DeviceErrorIdentifier.DEVICE_FAILED_TO_RESET);
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/com/android/tradefed/retry/ExcludeManager.java b/src/com/android/tradefed/retry/ExcludeManager.java
new file mode 100644
index 000000000..0c9bec01e
--- /dev/null
+++ b/src/com/android/tradefed/retry/ExcludeManager.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.retry;
+
+import com.android.tradefed.error.HarnessRuntimeException;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.testtype.ITestFileFilterReceiver;
+import com.android.tradefed.testtype.ITestFilterReceiver;
+import com.android.tradefed.util.FileUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Interface for providing exclude filter functionality.
+ */
+interface ExcludeFilterDelegate {
+    /**
+     * Initializes the exclude filters.
+     */
+    void initFilters();
+
+    /**
+     * Resets the exclude filters to their default state.
+     */
+    void resetDefaultFilters();
+
+    /**
+     * Adds the given filters to the exclude filters.
+     *
+     * @param filters The set of filters to add.
+     */
+    void addExcludeFilters(Set<String> filters);
+}
+
+/**
+ * Provides exclude filters for {@link ITestFileFilterReceiver} tests.
+ */
+class FileExcludeFilterDelegate implements ExcludeFilterDelegate {
+    private File mDefaultFilterFile;
+    private ITestFileFilterReceiver mTest;
+
+    /**
+     * Creates a new {@link FileExcludeFilterDelegate}.
+     *
+     * @param test The test to manage filters for.
+     */
+    public FileExcludeFilterDelegate(ITestFileFilterReceiver test) {
+        mTest = test;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void initFilters() {
+        mDefaultFilterFile = mTest.getExcludeTestFile();
+        try {
+            mTest.setExcludeTestFile(FileUtil.createTempFile("exclude-filter", ".txt"));
+        } catch (IOException e) {
+            throw new HarnessRuntimeException(
+                    e.getMessage(), e, InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void resetDefaultFilters() {
+        File excludeFilterFile = mTest.getExcludeTestFile();
+        if (mDefaultFilterFile != null) {
+            try {
+                FileUtil.copyFile(mDefaultFilterFile, excludeFilterFile);
+            } catch (IOException e) {
+                throw new HarnessRuntimeException(
+                        e.getMessage(), e, InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void addExcludeFilters(Set<String> filters) {
+        File excludeFilterFile = mTest.getExcludeTestFile();
+        String content = filters.stream().collect(Collectors.joining("\n", "", "\n"));
+        try {
+            FileUtil.writeToFile(content, excludeFilterFile, true);
+        } catch (IOException e) {
+            throw new HarnessRuntimeException(
+                    e.getMessage(), e, InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
+        }
+    }
+}
+
+/**
+ * Provides exclude filters for {@link ITestFilterReceiver} tests.
+ */
+class ListExcludeFilterDelegate implements ExcludeFilterDelegate {
+    private Set<String> mDefaultExcludeFilters;
+    private ITestFilterReceiver mTest;
+
+    /**
+     * Creates a new {@link ListExcludeFilterDelegate}.
+     *
+     * @param test The test to manage filters for.
+     */
+    public ListExcludeFilterDelegate(ITestFilterReceiver test) {
+        mTest = test;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void initFilters() {
+        mDefaultExcludeFilters = new HashSet<>();
+        if (mTest.getExcludeFilters() != null) {
+            mDefaultExcludeFilters.addAll(mTest.getExcludeFilters());
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void resetDefaultFilters() {
+        mTest.clearExcludeFilters();
+        mTest.addAllExcludeFilters(mDefaultExcludeFilters);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void addExcludeFilters(Set<String> filters) {
+        mTest.addAllExcludeFilters(filters);
+    }
+}
+
+/**
+ * A helper class to manage exclude filters for a given test.
+ *
+ * <p>This class is responsible for initializing, adding, and resetting exclude filters for a test.
+ * It supports both {@link ITestFilterReceiver} and {@link ITestFileFilterReceiver} tests.
+ *
+ * <p>This class is used by {@link BaseRetryDecision} to manage exclude filters for tests that are
+ * being retried. It initializes the exclude filters for a test, adds new exclude filters based on
+ * the failed tests from previous runs, and resets the filters to their original state after each
+ * retry attempt.
+ */
+class ExcludeFilterManager {
+    private ExcludeFilterDelegate mExcludeFilterDelegate;
+    private boolean mInitialized = false;
+
+    /**
+     * Creates a new {@link ExcludeFilterManager}.
+     *
+     * @param test The test to manage exclude filters for.
+     */
+    ExcludeFilterManager(IRemoteTest test) {
+        // ITestFileFilterReceiver is preferred due to bugs in parameterized exclusion (b/192510082)
+        if (test instanceof ITestFileFilterReceiver) {
+            mExcludeFilterDelegate = new FileExcludeFilterDelegate((ITestFileFilterReceiver) test);
+        } else if (test instanceof ITestFilterReceiver) {
+            mExcludeFilterDelegate = new ListExcludeFilterDelegate((ITestFilterReceiver) test);
+        }
+    }
+
+    /**
+     * Adds exclude filters for the given set of test descriptions.
+     *
+     * @param excludeFilters The set of test descriptions to exclude.
+     */
+    public void addExcludeFilters(Set<TestDescription> excludeFilters) {
+        if (!mInitialized) {
+            mExcludeFilterDelegate.initFilters();
+            mInitialized = true;
+        }
+        var filters = new HashSet<String>();
+        for (var testCase : excludeFilters) {
+            filters.add(String.format("%s#%s", testCase.getClassName(), testCase.getTestName()));
+        }
+        mExcludeFilterDelegate.addExcludeFilters(filters);
+    }
+
+    /**
+     * Resets the exclude filters to their default state.
+     */
+    public void resetDefaultFilters() {
+        if (!mInitialized) {
+            mExcludeFilterDelegate.initFilters();
+            mInitialized = true;
+        }
+        mExcludeFilterDelegate.resetDefaultFilters();
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/tradefed/retry/IRetryDecision.java b/src/com/android/tradefed/retry/IRetryDecision.java
index 22ab077c0..9ff79fbc7 100644
--- a/src/com/android/tradefed/retry/IRetryDecision.java
+++ b/src/com/android/tradefed/retry/IRetryDecision.java
@@ -38,8 +38,19 @@ public interface IRetryDecision {
     /** Whether or not to reboot the device before the last attempt. */
     public boolean rebootAtLastAttempt();
 
-    /** The maximum number of attempts during auto-retry. */
-    public int getMaxRetryCount();
+    /** The maximum number of attempts per test run during auto-retry. */
+    public int getMaxTestRunAttempts();
+
+    /** The maximum number of attempts per test run for a given module during
+     * auto-retry. */
+    public int getMaxTestRunAttempts(ModuleDefinition module);
+
+    /** The maximum number of attempts per test run during auto-retry. */
+    public int getMaxTestCaseAttempts();
+
+    /** The maximum number of attempts per test run for a given module during
+     * auto-retry. */
+    public int getMaxTestCaseAttempts(ModuleDefinition module);
 
     /** Returns true if we should use the updated reporting. */
     public boolean useUpdatedReporting();
@@ -101,4 +112,7 @@ public interface IRetryDecision {
     public default void addToSkipRetryList(String filterEntry) {
         // Empty by default on purpose
     }
+
+    /** Returns the command line args for the retry decision. */
+    public List<String> getCommandLineArgs();
 }
diff --git a/src/com/android/tradefed/retry/RetryCountParser.java b/src/com/android/tradefed/retry/RetryCountParser.java
new file mode 100644
index 000000000..2b72817e4
--- /dev/null
+++ b/src/com/android/tradefed/retry/RetryCountParser.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.retry;
+
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * A helper class to parse the max test run and test case attempts from the command line options.
+ * It parses the options and provides methods to get the max attempts for a given module or the
+ * default value.
+ *
+ * <p>The class is used by {@link BaseRetryDecision} to parse the retry attempts and provide the
+ * correct values for each module, as well as provide the command line.
+ */
+class RetryCountParser {
+
+    private int mDefaultTestRunAttempts;
+    private int mDefaultTestCaseAttempts;
+    private Map<String, Integer> mTestRunAttemptsMap = new HashMap<>();
+    private Map<String, Integer> mTestCaseAttemptsMap = new HashMap<>();
+
+    /**
+     * Constructor for RetryCountParser.
+     *
+     * @param testCaseAttempts A set of strings representing test case attempts,
+     *                         e.g., "module1:2", "3".
+     * @param testRunAttempts  A set of strings representing test run attempts,
+     *                         e.g., "module1:5", "2".
+     */
+    RetryCountParser(Set<String> testCaseAttempts, Set<String> testRunAttempts) {
+        mDefaultTestRunAttempts = parseAttempts(testRunAttempts, mTestRunAttemptsMap, -1);
+        mDefaultTestCaseAttempts = parseAttempts(testCaseAttempts, mTestCaseAttemptsMap, 1);
+    }
+
+    /**
+     * Returns the maximum test run attempts for the given module.
+     * If module-specific attempts are not defined, it returns the default test run attempts.
+     * If default test run attempts is -1, it returns the max test case attempts for the module.
+     *
+     * @param module The {@link ModuleDefinition} to get the max attempts for, or null to get the default.
+     * @return The maximum test run attempts for the module.
+     */
+    public int getMaxTestRunAttempts(ModuleDefinition module) {
+        int attempts = mDefaultTestRunAttempts;
+        if (module != null) {
+            attempts = mTestRunAttemptsMap.getOrDefault(module.getId(), attempts);
+        }
+        return attempts == -1 ? getMaxTestCaseAttempts(module) : attempts;
+    }
+
+    /**
+     * Returns the maximum test case attempts for the given module.
+     *
+     * @param module The {@link ModuleDefinition} to get the max attempts for, or null to get the default.
+     * @return The maximum test case attempts for the module.
+     */
+    public int getMaxTestCaseAttempts(ModuleDefinition module) {
+        if (module == null) {
+            return mDefaultTestCaseAttempts;
+        }
+        return mTestCaseAttemptsMap.getOrDefault(module.getId(), mDefaultTestCaseAttempts);
+    }
+
+    /**
+     * Returns a list of command line arguments representing the configured retry attempts.
+     *
+     * @return A list of strings representing the command line arguments.
+     */
+    public List<String> getCommandLineArgs() {
+        List<String> args = new ArrayList<>();
+        mTestCaseAttemptsMap.forEach((module, attempts) -> {
+            args.add("--max-testcase-run-count");
+            args.add(module + ":" + attempts);
+        });
+        if (mDefaultTestCaseAttempts > 1) {
+            args.add("--max-testcase-run-count");
+            args.add(Integer.toString(mDefaultTestCaseAttempts));
+        }
+        mTestRunAttemptsMap.forEach((module, attempts) -> {
+            args.add("--max-testrun-run-count");
+            args.add(module + ":" + attempts);
+        });
+        if (mDefaultTestRunAttempts > 0) {
+            args.add("--max-testrun-run-count");
+            args.add(Integer.toString(mDefaultTestRunAttempts));
+        }
+        return args;
+    }
+
+    /**
+     * Parses a set of strings representing how many retry attempts to use for each module.
+     *
+     * @param attempts A set of strings representing limits on retries, e.g., "module1:2", "3".
+     * @param attemptsMap A map to store module-specific attempts.
+     * @param defaultValue The default value to use if no default is specified in the attempts set.
+     * @return The default retry attempts.
+     */
+    private int parseAttempts(
+            Set<String> attempts, Map<String, Integer> attemptsMap, int defaultValue) {
+        int defaultAttempts = defaultValue;
+        for (String entry : attempts) {
+            try {
+                String[] parts = entry.split(":", 2); // Split into at most 2 parts
+                if (parts.length == 2) {
+                    attemptsMap.put(parts[0], Integer.parseInt(parts[1]));
+                } else if (parts.length == 1) {
+                    defaultAttempts = Integer.parseInt(parts[0]);
+                }
+            } catch (NumberFormatException e) {
+                CLog.e("Failed to parse module run count entry: %s", entry);
+            }
+        }
+        return defaultAttempts;
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/tradefed/retry/RetryStatsHelper.java b/src/com/android/tradefed/retry/RetryStatsHelper.java
index e4e17d30d..6bcf1a3f1 100644
--- a/src/com/android/tradefed/retry/RetryStatsHelper.java
+++ b/src/com/android/tradefed/retry/RetryStatsHelper.java
@@ -17,18 +17,19 @@ package com.android.tradefed.retry;
 
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestRunResult;
+import com.android.tradefed.result.TestStatus;
 
-import com.google.common.collect.Sets;
-
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
+import java.util.HashSet;
 import java.util.Set;
 
 /** Calculate the retry statistics and metrics based on attempts comparison. */
 final class RetryStatsHelper {
 
-    private List<List<TestRunResult>> mResults = new ArrayList<>();
     private RetryStatistics mStats = new RetryStatistics();
+    private Set<TestDescription> mPassedTestCases = new HashSet<>();
+    private Set<TestDescription> mFailedTestCases = new HashSet<>();
 
     /** Add the results from the latest run to be tracked for statistics purpose. */
     public void addResultsFromRun(List<TestRunResult> mLatestResults) {
@@ -36,14 +37,25 @@ final class RetryStatsHelper {
     }
 
     /** Add the results from the latest run to be tracked for statistics purpose. */
-    public void addResultsFromRun(List<TestRunResult> mLatestResults, long timeForIsolation, int attempt) {
-        if (!mResults.isEmpty()) {
-            updateSuccess(mResults.get(mResults.size() - 1), mLatestResults);
-        }
+    public void addResultsFromRun(
+            List<TestRunResult> mLatestResults, long timeForIsolation, int attempt) {
         if (timeForIsolation != 0L) {
             mStats.mAttemptIsolationCost.put(attempt, timeForIsolation);
         }
-        mResults.add(mLatestResults);
+        for (var runResult : mLatestResults) {
+            if (runResult != null) {
+                // Track all tests where we failed to clear the failure (so if the test either
+                // failed or didn't run in subsequent attempts, it's a failed retry.)
+                var failedStatuses = Arrays.asList(TestStatus.FAILURE, TestStatus.SKIPPED);
+                mFailedTestCases.addAll(runResult.getTestsInState(failedStatuses));
+                mFailedTestCases.removeAll(runResult.getPassedTests());
+
+                // Only track retries as retrySuccess.
+                if (attempt > 0) {
+                    mPassedTestCases.addAll(runResult.getPassedTests());
+                }
+            }
+        }
     }
 
     /**
@@ -51,21 +63,9 @@ final class RetryStatsHelper {
      * {@link RetryStatistics} to represent the results.
      */
     public RetryStatistics calculateStatistics() {
-        if (!mResults.isEmpty()) {
-            List<TestRunResult> attemptResults = mResults.get(mResults.size() - 1);
-            Set<TestDescription> attemptFailures =
-                    BaseRetryDecision.getFailedTestCases(attemptResults).keySet();
-            mStats.mRetryFailure = attemptFailures.size();
-        }
+        mStats.mRetryFailure = mFailedTestCases.size();
+        mStats.mRetrySuccess = mPassedTestCases.size();
         return mStats;
     }
 
-    private void updateSuccess(
-            List<TestRunResult> previousResults, List<TestRunResult> latestResults) {
-        Set<TestDescription> diff =
-                Sets.difference(
-                        BaseRetryDecision.getFailedTestCases(previousResults).keySet(),
-                        BaseRetryDecision.getFailedTestCases(latestResults).keySet());
-        mStats.mRetrySuccess += diff.size();
-    }
 }
diff --git a/src/com/android/tradefed/retry/RetryTracker.java b/src/com/android/tradefed/retry/RetryTracker.java
new file mode 100644
index 000000000..c87421f34
--- /dev/null
+++ b/src/com/android/tradefed/retry/RetryTracker.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.retry;
+
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.TestResult;
+import com.android.tradefed.result.TestRunResult;
+import com.android.tradefed.result.TestStatus;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A helper class to track the retry attempts for each test case and determine if a test run should
+ * be retried.
+ *
+ * <p>This class is used by {@link BaseRetryDecision} to determine which tests should be retried and
+ * which tests should be excluded from the next attempt.
+ *
+ * <p>When processing failed test runs, {@link BaseRetryDecision} calls {@link #recordTestRun}
+ * to record the results of the previous test run, and uses {@link #shouldRetry} to determine if
+ * the test run should be retried. If the test run should be retried, {@link BaseRetryDecision} will
+ * use the information from {@link #getExcludedTests} to exclude tests that have already passed or
+ * have reached the maximum number of attempts.
+ */
+class RetryTracker {
+    /** Track the number of attempts for each test case. */
+    private Map<TestDescription, Integer> mTestAttemptCounter = new LinkedHashMap<>();
+
+    /** Track the tests that have finished retrying. */
+    private Set<TestDescription> mFinishedRetries = new HashSet<>();
+
+    /** Track the tests to be excluded on the upcoming attempt. */
+    private Set<TestDescription> mExcludedTests = new HashSet<>();
+
+    /** Whether or not the test run failed (or encountered a fatal run failure). */
+    private boolean mHasRunFailure;
+    private boolean mHasFatalRunFailure;
+
+    /** Whether we've ever seen a passing test run (at the module level) */
+    private boolean mHasRunEverPassed;
+
+    /** The maximum number of empty retries. */
+    private static final int MAX_EMPTY_RETRIES = 1;
+
+    /** The number of test runs that finished with no tests to retry. */
+    private int mEmptyRetries = 0;
+
+    /** The number of the attempt that was just executed. */
+    private int mAttemptJustExecuted;
+
+    /** The maximum number of attempts for each test case. */
+    private int mMaxTestCaseAttempts;
+
+    final static private Set<TestStatus> RETRIABLE_STATUSES =
+        Set.of(TestStatus.FAILURE, TestStatus.SKIPPED);
+
+    /**
+     * Creates a new RetryTracker for the given module.
+     *
+     * @param testCaseAttempts The maximum number of attempts for the test cases.
+     */
+    public RetryTracker(int testCaseAttempts) {
+        mMaxTestCaseAttempts = testCaseAttempts;
+    }
+
+    /** Returns the set of tests that passed or have finished retrying. */
+    public Set<TestDescription> getExcludedTests() {
+        return mExcludedTests;
+    }
+
+    /**
+     * Record a test run that was just executed.
+     *
+     * @param runs The results of the latest attempt.
+     * @param attemptJustExecuted The number of the attempt that was just executed.
+     * @param skipList The list of tests that should not be retried.
+     */
+    public void recordTestRun(List<TestRunResult> runs, int attemptJustExecuted, Set<String> skipList) {
+        mAttemptJustExecuted = attemptJustExecuted;
+
+        // Only keep the tests that failed in the previous run.
+        mHasRunFailure = false;
+        mHasFatalRunFailure = false;
+        for (var run : runs) {
+            if (run.isRunFailure()) {
+                mHasRunFailure = true;
+                if (!run.getRunFailureDescription().isRetriable()) {
+                    mHasFatalRunFailure = true;
+                }
+            }
+
+            run.getTestResults().forEach((testCase, testResult) -> {
+                recordTestCase(testCase, testResult, skipList);
+            });
+
+        }
+
+        if (!mHasRunFailure) {
+            // Record whether we've ever seen a passing test run.
+            mHasRunEverPassed = true;
+        }
+
+        mExcludedTests.clear();
+        mExcludedTests.addAll(mFinishedRetries);
+
+        for (var run : runs) {
+            run.getTestResults().forEach((testCase, testResult) -> {
+                if (!isRetriable(testCase, testResult, skipList)) {
+                    mExcludedTests.add(testCase);
+                }
+            });
+        }
+
+        // Record an empty retry.
+        if (mTestAttemptCounter.isEmpty() && shouldRetry()) {
+            mEmptyRetries++;
+        }
+    }
+
+    /**
+     * Returns true if the test run should be retried.
+     */
+    public boolean shouldRetry() {
+        if (mHasFatalRunFailure) {
+            CLog.d("Not retrying due to fatal run failure.");
+            return false;
+        }
+        if (!mTestAttemptCounter.isEmpty()) {
+            CLog.d("Retrying because there are tests that have not finished retrying.");
+            return true;
+        }
+        if (!mHasRunFailure) {
+            CLog.d("Not retrying because there are no tests to retry and module passed.");
+            return false;
+        }
+        if (mHasRunEverPassed) {
+            // If the only problem is a module error and it's passed before, we can skip retries.
+            CLog.d("Not retrying because there are no tests to retry and module passed before.");
+            return false;
+        }
+        if (mEmptyRetries > MAX_EMPTY_RETRIES && mAttemptJustExecuted >= mMaxTestCaseAttempts) {
+            CLog.d("Not retrying because we hit empty retry limit: %d/%d", mEmptyRetries,
+                    MAX_EMPTY_RETRIES);
+            return false;
+        }
+        CLog.d("Retrying because the module failed.");
+        return true;
+    }
+
+    /**
+     * Returns true if the test case can ever be retried.
+     */
+    private boolean isRetriable(TestDescription test, TestResult result, Set<String> skipList) {
+        // Don't retry passed tests.
+        if (!RETRIABLE_STATUSES.contains(result.getResultStatus())) {
+            return false;
+        }
+
+        // Don't retry tests that failed with a non-retriable failure (e.g. timeouts).
+        var failureDescription = result.getFailure();
+        if (failureDescription != null && !failureDescription.isRetriable()) {
+            return false;
+        }
+
+        // Exclude tests that are finished retrying.
+        int attempts = mTestAttemptCounter.getOrDefault(test, 0);
+        if (attempts >= mMaxTestCaseAttempts || mFinishedRetries.contains(test)) {
+            return false;
+        }
+
+        // Exclude tests that are in the skip-retry-list.
+        if (skipList.contains(test.toString())) {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.RETRY_TEST_SKIPPED_COUNT, 1);
+            CLog.d("Skip retry of %s, it's in skip-retry-list.", test.toString());
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Record a test case that was just executed.
+     *
+     * @param test The test case that was just executed.
+     * @param result The result of the test case.
+     * @param skipList The list of tests that should not be retried.
+     */
+    private void recordTestCase(TestDescription test, TestResult result, Set<String> skipList) {
+        if (TestStatus.SKIPPED.equals(result.getResultStatus())) {
+            mTestAttemptCounter.putIfAbsent(test, 0);
+            return;
+        }
+
+        // Increment the attempt count for the test.
+        mTestAttemptCounter.put(test, mTestAttemptCounter.getOrDefault(test, 0) + 1);
+
+        // Record unretriable tests so we don't retry them again (or miscalculate
+        // mSmallestAttemptCount).
+        if (!isRetriable(test, result, skipList)) {
+            mTestAttemptCounter.remove(test);
+            mFinishedRetries.add(test);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/tradefed/service/management/TestInvocationManagementServer.java b/src/com/android/tradefed/service/management/TestInvocationManagementServer.java
index d0b62dcbe..330bf3387 100644
--- a/src/com/android/tradefed/service/management/TestInvocationManagementServer.java
+++ b/src/com/android/tradefed/service/management/TestInvocationManagementServer.java
@@ -129,8 +129,19 @@ public class TestInvocationManagementServer extends TestInvocationManagementImpl
     public void shutdown() throws InterruptedException {
         if (mServer != null) {
             CLog.d("Stopping invocation server.");
-            if (mTracker.size() > 0) {
+            // Mobile Harness has a 5s interval of checking test result status.
+            // Wait 30s to ensure Mobile Harness a chance to retrieve test status.
+            long shutdownTime = System.currentTimeMillis() + 30000;
+            while (mTracker.size() > 0 && System.currentTimeMillis() < shutdownTime) {
                 CLog.d("Remaining tracked test invocations: %s", mTracker.size());
+                RunUtil.getDefault().sleep(1000);
+            }
+            if (mTracker.size() > 0) {
+                CLog.w(
+                        "Shutdown invocation server when there's remaining tracked test"
+                            + " invocations: %s. Most likely Mobile Harness will fail to retrieve"
+                            + " the result of those test invocations.",
+                        mTracker.size());
             }
             mServer.shutdown();
             mServer.awaitTermination();
diff --git a/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java b/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
index 80b3b8910..d219f85ae 100644
--- a/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
+++ b/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
@@ -36,6 +36,7 @@ public class LockSettingsBaselineSetter extends DeviceBaselineSetter {
     private static final String CLEAR_PWD_COMMAND = "locksettings clear --old %s";
     private static final String KEYCODE_MENU_COMMAND = "input keyevent KEYCODE_MENU";
     private static final String KEYCODE_HOME_COMMAND = "input keyevent KEYCODE_HOME";
+    private static final String KEYCODE_WAKEUP_COMMAND = "input keyevent KEYCODE_WAKEUP";
 
     public LockSettingsBaselineSetter(JSONObject object, String name) throws JSONException {
         super(object, name);
@@ -60,9 +61,11 @@ public class LockSettingsBaselineSetter extends DeviceBaselineSetter {
         if (!isLockScreenDisabled(mDevice)) {
             return false;
         }
+        CommandResult wakeupResult = mDevice.executeShellV2Command(KEYCODE_WAKEUP_COMMAND);
         CommandResult menuResult = mDevice.executeShellV2Command(KEYCODE_MENU_COMMAND);
         CommandResult homeResult = mDevice.executeShellV2Command(KEYCODE_HOME_COMMAND);
-        return CommandStatus.SUCCESS.equals(menuResult.getStatus())
+        return CommandStatus.SUCCESS.equals(wakeupResult.getStatus())
+                && CommandStatus.SUCCESS.equals(menuResult.getStatus())
                 && CommandStatus.SUCCESS.equals(homeResult.getStatus());
     }
 
diff --git a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
index 668682ba1..c263a2b07 100644
--- a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
@@ -38,14 +38,15 @@ import com.android.tradefed.invoker.logger.CurrentInvocation.IsolationGrade;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ITestLoggerReceiver;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.retry.BaseRetryDecision;
 import com.android.tradefed.targetprep.IDeviceFlasher.UserDataFlashOption;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
-import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.image.DeviceImageTracker;
@@ -60,7 +61,7 @@ import java.util.concurrent.TimeUnit;
 
 /** A {@link ITargetPreparer} that flashes an image on physical Android hardware. */
 public abstract class DeviceFlashPreparer extends BaseTargetPreparer
-        implements IConfigurationReceiver {
+        implements IConfigurationReceiver, ITestLoggerReceiver {
 
     private static final int BOOT_POLL_TIME_MS = 5 * 1000;
     private static final long SNAPSHOT_CANCEL_TIMEOUT = 20000L;
@@ -165,7 +166,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     @Option(
             name = "allow-incremental-cross-release",
             description = "Allow doing incremental update across release build configs.")
-    private boolean mAllowIncrementalCrossRelease = false;
+    private boolean mAllowIncrementalCrossRelease = true;
+
+    @Option(
+            name = "allow-trackerless-update",
+            description = "Allow doing incremental update without a baseline known on the host.")
+    private boolean mAllowTrackerlessUpdate = true;
 
     @Option(
             name = "ignore-incremental-host-options",
@@ -184,12 +190,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     @Option(
             name = "wipe-after-apply-snapshot",
             description = "Whether to issue a wipe after applying snapshots.")
-    private boolean mWipeAfterApplySnapshot = false;
+    private boolean mWipeAfterApplySnapshot = true;
 
     @Option(
             name = "use-new-incremental-update-flow",
             description = "A new update flow possible with latest incremental features.")
-    private boolean mNewIncrementalFlow = false;
+    private boolean mNewIncrementalFlow = true;
 
     @Option(
             name = "update-bootloader-in-userspace",
@@ -205,16 +211,23 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     @Option(
             name = "allow-unzip-baseline",
             description = "Whether to allow tracking the baseline as unzipped or not.")
-    private boolean mAllowUnzippedBaseline = false;
+    private boolean mAllowUnzippedBaseline = true;
 
     @Option(
             name = "enforce-snapshot-completed",
             description = "Test mode was snapshot to ensure the logic was used and throw if not.")
     private boolean mEnforceSnapshotCompleted = false;
 
+    @Option(
+            name = "use-merkle-tree-comparison",
+            description = "Generate snapshot using the merkle tree on device instead of baseline.")
+    private boolean mUseMerkleTreeComparison = true;
+
     private IncrementalImageUtil mIncrementalImageUtil;
     private IConfiguration mConfig;
     private Set<String> mAllowedTransition = new HashSet<>();
+    private IDeviceFlasher mFlasher;
+    private ITestLogger mTestLogger;
 
     @Override
     public void setConfiguration(IConfiguration configuration) {
@@ -356,13 +369,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                                 deviceBuild,
                                 mCreateSnapshotBinary,
                                 isIsolated,
-                                mAllowIncrementalCrossRelease,
+                                mAllowTrackerlessUpdate,
                                 mAllowedTransition,
-                                mApplySnapshot,
-                                mWipeAfterApplySnapshot,
                                 mNewIncrementalFlow,
                                 mUpdateBootloaderFromUserspace,
-                                mWaitPhase);
+                                mWaitPhase,
+                                mUseMerkleTreeComparison);
                 if (mIncrementalImageUtil == null) {
                     useIncrementalFlashing = false;
                 } else {
@@ -380,7 +392,14 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         try {
             checkDeviceProductType(device, deviceBuild);
             device.setRecoveryMode(RecoveryMode.ONLINE);
-            IDeviceFlasher flasher = createFlasher(device);
+            IDeviceFlasher flasher = null;
+            if (mFlasher != null) {
+                flasher = mFlasher;
+                CLog.d("Reusing flasher object.");
+            } else {
+                flasher = createFlasher(device);
+                mFlasher = flasher;
+            }
             flasher.setWipeTimeout(mWipeTimeout);
             boolean tookPermit = false;
             // only surround fastboot related operations with flashing permit restriction
@@ -400,6 +419,7 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                         ((FastbootDeviceFlasher) flasher)
                                 .setIncrementalFlashing(mIncrementalImageUtil);
                     }
+                    ((FastbootDeviceFlasher) flasher).setTestLogger(mTestLogger);
                 }
                 start = System.currentTimeMillis();
                 flasher.preFlashOperations(device, deviceBuild);
@@ -440,6 +460,7 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                         FlashingMethod.FASTBOOT_UNCATEGORIZED.toString());
                 flasher.flash(device, deviceBuild);
             } catch (DeviceNotAvailableException | TargetSetupError | RuntimeException e) {
+                CLog.e(e);
                 // Clear tracking in case of error
                 DeviceImageTracker.getDefaultCache().invalidateTracking(device.getSerialNumber());
                 throw e;
@@ -541,32 +562,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
             moveBaseLine = true;
         }
         if (moveBaseLine) {
-            File deviceImage = deviceBuild.getDeviceImageFile();
-            File tmpReference = null;
-            try {
-                if (mAllowUnzippedBaseline
-                        && mIncrementalImageUtil != null
-                        && mIncrementalImageUtil.getExtractedTargetDirectory() != null
-                        && mIncrementalImageUtil.getExtractedTargetDirectory().isDirectory()) {
-                    CLog.d(
-                            "Using unzipped baseline: %s",
-                            mIncrementalImageUtil.getExtractedTargetDirectory());
-                    tmpReference = mIncrementalImageUtil.getExtractedTargetDirectory();
-                    deviceImage = tmpReference;
-                }
-
-                DeviceImageTracker.getDefaultCache()
-                        .trackUpdatedDeviceImage(
-                                serial,
-                                deviceImage,
-                                deviceBuild.getBootloaderImageFile(),
-                                deviceBuild.getBasebandImageFile(),
-                                deviceBuild.getBuildId(),
-                                deviceBuild.getBuildBranch(),
-                                deviceBuild.getBuildFlavor());
-            } finally {
-                FileUtil.recursiveDelete(tmpReference);
-            }
+            DeviceImageTracker.getDefaultCache()
+                    .trackUpdatedDeviceImage(
+                            serial,
+                            deviceBuild.getBuildId(),
+                            deviceBuild.getBuildBranch(),
+                            deviceBuild.getBuildFlavor());
         }
     }
 
@@ -645,6 +646,9 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                 testInfo.getDevice().setRecoveryMode(mode);
             }
         }
+        if (mFlasher != null) {
+            mFlasher.tearDownFlasher();
+        }
         if (mEnforceSnapshotCompleted && e == null) {
             if (mIncrementalImageUtil == null || !mIncrementalImageUtil.updateCompleted()) {
                 throw new RuntimeException(
@@ -653,6 +657,15 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         }
     }
 
+    @Override
+    public void setTestLogger(ITestLogger testLogger) {
+        mTestLogger = testLogger;
+    }
+
+    public ITestLogger getTestLogger() {
+        return mTestLogger;
+    }
+
     /**
      * Reports device flashing timing data to metrics backend
      * @param branch the branch where the device build originated from
@@ -731,4 +744,8 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     public void addAllowedBranchForTransitionInIncremental(String branch) {
         mAllowedTransition.add(branch);
     }
+
+    public void useMerkleTreeComparison(boolean enableMerkleTreeComparison) {
+        mUseMerkleTreeComparison = enableMerkleTreeComparison;
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
index 5a6a08c7b..f7acf5e94 100644
--- a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
@@ -16,6 +16,7 @@
 
 package com.android.tradefed.targetprep;
 
+import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.config.GlobalConfiguration;
@@ -29,7 +30,10 @@ import com.android.tradefed.host.IHostOptions.PermitLimitType;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.ErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
@@ -44,7 +48,6 @@ import com.android.tradefed.util.image.DeviceImageTracker;
 import com.android.tradefed.util.image.DeviceImageTracker.FileCacheTracker;
 import com.android.tradefed.util.image.IncrementalImageUtil;
 
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableSet;
 
 import org.apache.commons.compress.archivers.zip.ZipFile;
@@ -103,6 +106,7 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     private String mSystemBuildFlavor = null;
 
     private IncrementalImageUtil mIncrementalFlashing = null;
+    private ITestLogger mTestLogger = null;
 
     @VisibleForTesting
     protected FuseUtil getFuseUtil() {
@@ -121,6 +125,10 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         return mResourceRetriever;
     }
 
+    void setTestLogger(ITestLogger logger) {
+        mTestLogger = logger;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -212,6 +220,12 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
                 // fallback to full flashing.
                 CLog.e(e);
                 DeviceImageTracker.getDefaultCache().invalidateTracking(device.getSerialNumber());
+                if (mTestLogger != null) {
+                    try (InputStreamSource source = device.getLogcatDump()) {
+                        mTestLogger.testLog(
+                                "apply-update-logcat-failure", LogDataType.LOGCAT, source);
+                    }
+                }
                 if (TestDeviceState.ONLINE.equals(device.getDeviceState())) {
                     device.rebootIntoBootloader();
                 }
diff --git a/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
index 2f1534acd..6c634c54a 100644
--- a/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
@@ -196,7 +196,7 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
     @Option(
             name = "wipe-device-before-gki-flash",
             description = "Whether to wipe device before GKI boot image flash.")
-    private boolean mShouldWipeDeviceBeforeFlash = true;
+    private boolean mShouldWipeDeviceBeforeFlash = false;
 
     @Deprecated
     @Option(
@@ -347,6 +347,9 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
             device.reboot();
         }
         device.rebootIntoBootloader();
+        if (mShouldWipeDeviceBeforeFlash) {
+            executeFastbootCmd(device, "-w");
+        }
         if (mShouldDisableOemVerity) {
             executeFastbootCmd(device, "oem disable-verity");
         }
@@ -360,10 +363,6 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
         // Don't allow interruptions during flashing operations.
         getRunUtil().allowInterrupt(false);
         try {
-            if (mShouldWipeDeviceBeforeFlash) {
-                executeFastbootCmd(device, "-w");
-            }
-
             if (buildInfo.getFile(mVendorBootImageName) != null) {
                 File vendorBootImg =
                         getRequestedFile(
diff --git a/src/com/android/tradefed/targetprep/GsiDeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/GsiDeviceFlashPreparer.java
index c8e11818c..d374d0bec 100644
--- a/src/com/android/tradefed/targetprep/GsiDeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/GsiDeviceFlashPreparer.java
@@ -54,6 +54,7 @@ public class GsiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
     private static final int DYNAMIC_PARTITION_API_LEVEL = 29;
     // Wait time for device state to stablize in millisecond
     private static final int STATE_STABLIZATION_WAIT_TIME_MLLISECS = 60000;
+    private static final String PVMFW_IMG_FILE_NAME = "pvmfw.img";
 
     @Option(
             name = "device-boot-time",
@@ -73,6 +74,11 @@ public class GsiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
                             + "is in a zip file or directory.")
     private String mSystemImageFileName = "system.img";
 
+    @Option(
+            name = "flash-pvmfw",
+            description = "Fastboot flash pvmfw.img in the file system-image-zip-name.")
+    private boolean mFlashPvmfw = false;
+
     @Option(
             name = "vbmeta-image-zip-name",
             description = "The name of the zip file containing the system image in BuildInfo.")
@@ -109,6 +115,7 @@ public class GsiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
     private boolean mPostRebootDeviceIntoUserSpace = true;
 
     private File mSystemImg = null;
+    private File mPvmfwImg = null;
     private File mVbmetaImg = null;
     private File mBootImg = null;
 
@@ -228,10 +235,15 @@ public class GsiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
                 executeFastbootCmd(device, "erase", "system" + currSlot);
                 executeFastbootCmd(device, "flash", "system", mSystemImg.getAbsolutePath());
             }
-            if (mBootImg != null) {
+            if (mBootImg != null || mPvmfwImg != null) {
                 device.rebootIntoBootloader();
+            }
+            if (mBootImg != null) {
                 executeFastbootCmd(device, "flash", "boot", mBootImg.getAbsolutePath());
             }
+            if (mPvmfwImg != null) {
+                executeFastbootCmd(device, "flash", "pvmfw", mPvmfwImg.getAbsolutePath());
+            }
         } finally {
             getHostOptions().returnPermit(PermitLimitType.CONCURRENT_FLASHER);
             // Allow interruption at the end no matter what.
@@ -263,6 +275,14 @@ public class GsiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
                         mSystemImageFileName,
                         buildInfo.getFile(mSystemImageZipName),
                         tmpDir);
+        if (mFlashPvmfw) {
+            mPvmfwImg =
+                    getRequestedFile(
+                            device,
+                            PVMFW_IMG_FILE_NAME,
+                            buildInfo.getFile(mSystemImageZipName),
+                            tmpDir);
+        }
         if (buildInfo.getFile(mVbmetaImageZipName) != null) {
             mVbmetaImg =
                     getRequestedFile(
diff --git a/src/com/android/tradefed/targetprep/IDeviceFlasher.java b/src/com/android/tradefed/targetprep/IDeviceFlasher.java
index 719e0aa28..ce109fc04 100644
--- a/src/com/android/tradefed/targetprep/IDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/IDeviceFlasher.java
@@ -200,4 +200,9 @@ public interface IDeviceFlasher {
     public default Set<String> getAdditionalFileFilters() {
         return Collections.<String>emptySet();
     }
+
+    /** Last opportunity for the flasher implementation to clean up after itself */
+    public default void tearDownFlasher() {
+        // Empty on purpose
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java b/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java
index 3782d695b..0c08b0bfb 100644
--- a/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java
+++ b/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java
@@ -63,7 +63,8 @@ public class InstallKernelModulePreparer extends BaseTargetPreparer implements I
         mPreExistingAdbRootState = device.isAdbRoot();
 
         for (String modulePath : mModulePaths) {
-            KernelModuleUtils.removeModule(device, modulePath);
+            KernelModuleUtils.removeModuleWithDependency(
+                    device, KernelModuleUtils.getDisplayedModuleName(modulePath));
         }
 
         for (String modulePath : mModulePaths) {
@@ -79,7 +80,8 @@ public class InstallKernelModulePreparer extends BaseTargetPreparer implements I
         List<String> reversedModulePaths = new ArrayList<>(mModulePaths);
         Collections.reverse(reversedModulePaths);
         for (String modulePath : reversedModulePaths) {
-            KernelModuleUtils.removeModule(device, modulePath);
+            KernelModuleUtils.removeModuleWithDependency(
+                    device, KernelModuleUtils.getDisplayedModuleName(modulePath));
         }
         if (!mPreExistingAdbRootState) {
             device.disableAdbRoot();
diff --git a/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
index c1e3d7574..59679e1f7 100644
--- a/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
@@ -144,9 +144,12 @@ public class OtaUpdateDeviceFlasher implements IDeviceFlasher {
         device.enableAdbRoot();
         // TODO(guangzhu): Remove this once wipe via OTA script is properly supported
         if (UserDataFlashOption.WIPE.equals(mUserDataFlashOptions)) {
-            device.executeShellCommand("stop");
-            device.executeShellCommand("rm -rf /data/*");
-            device.reboot();
+            // starts the framework in case it was stopped (or no-op)
+            // this is still not the ideal solution as it needs a functioning framework
+            device.executeShellCommand("start");
+            device.waitForDeviceAvailable();
+            device.executeShellCommand("cmd recovery wipe");
+            // device will reboot from the above command
             device.waitForDeviceAvailable();
             device.enableAdbRoot();
             // ensure that the device won't enter suspend mode
diff --git a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
index 6a62f825a..6004b6746 100644
--- a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
+++ b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
@@ -128,10 +128,17 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             description = "Throw exception if the specified file is not found.")
     private boolean mThrowIfNoFile = true;
 
-    @Option(name = AbiFormatter.FORCE_ABI_STRING,
+    @Option(
+            name = "pin-abi",
+            description = "Pin ABI of the installed app",
+            importance = Importance.IF_UNSET)
+    private String mPinApi = null;
+
+    @Option(
+            name = AbiFormatter.FORCE_ABI_STRING,
             description = AbiFormatter.FORCE_ABI_DESCRIPTION,
             importance = Importance.IF_UNSET)
-    private String mForceAbi = null;
+    private String mForceAbiBitness = null;
 
     @Option(name = "install-arg",
             description = "Additional arguments to be passed to install command, "
@@ -359,7 +366,7 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             return;
         }
         // resolve abi flags
-        if (mAbi != null && mForceAbi != null) {
+        if (mAbi != null && mForceAbiBitness != null) {
             throw new IllegalStateException("cannot specify both abi flags: --abi and --force-abi");
         }
 
@@ -368,10 +375,15 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             ((NativeDevice) getDevice()).batchPrefetchStartupBuildProps();
         }
         String abiName = null;
-        if (mAbi != null) {
+        if (mPinApi != null) {
+            CLog.d("Using abi %s from pin-abi option.", mPinApi);
+            abiName = mPinApi;
+        } else if (mAbi != null) {
+            CLog.d("Using abi %s from abi option.", mAbi.getName());
             abiName = mAbi.getName();
-        } else if (mForceAbi != null) {
-            abiName = AbiFormatter.getDefaultAbi(getDevice(), mForceAbi);
+        } else if (mForceAbiBitness != null) {
+            CLog.d("Using abi %s from force-abi option.", AbiFormatter.getDefaultAbi(getDevice(), mForceAbiBitness));
+            abiName = AbiFormatter.getDefaultAbi(getDevice(), mForceAbiBitness);
         }
         // Set all the extra install args outside the loop to avoid adding them several times.
         if (abiName != null && testInfo.getDevice().getApiLevel() > 20) {
@@ -546,7 +558,8 @@ public class TestAppInstallSetup extends BaseTargetPreparer
 
         for (Map.Entry<String, List<File>> e : Multimaps.asMap(packageToFiles).entrySet()) {
             if (mApkChangeDetector != null
-                && mApkChangeDetector.handleTestAppsPreinstall(e.getKey(), e.getValue(), getDevice())) {
+                && mApkChangeDetector.handleTestAppsPreinstall(
+                    e.getKey(), e.getValue(), getDevice(), mUserId, mInstallForAllUsers)) {
                 continue;
             }
 
diff --git a/src/com/android/tradefed/targetprep/incremental/ApkChangeDetector.java b/src/com/android/tradefed/targetprep/incremental/ApkChangeDetector.java
index e74b51e8c..1498852c7 100644
--- a/src/com/android/tradefed/targetprep/incremental/ApkChangeDetector.java
+++ b/src/com/android/tradefed/targetprep/incremental/ApkChangeDetector.java
@@ -23,6 +23,7 @@ import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.google.common.base.Splitter;
+import com.google.common.collect.Sets;
 import com.google.common.hash.Hashing;
 import java.io.File;
 import java.io.FileInputStream;
@@ -43,6 +44,24 @@ public class ApkChangeDetector {
 
     private static final long MIN_FREE_DISK_SPACE_THRESHOLD_IN_BYTES = 10000000L;
     private static final double DISK_SPACE_TO_USE_ESTIMATE_FACTOR = 1.5;
+    @VisibleForTesting
+    static final String PACKAGE_INSTALLED_FILE_PATH =
+        "/sdcard/.tradefed_package_installation_cache";
+
+    @VisibleForTesting
+    final Set<String> mPackagesHandledInCurrentTestRun = new HashSet<>();
+
+    private Set<String> mPackagesHandledInPreviousTestRuns;
+    private Boolean incrementalSetupSupportEnsureResult;
+
+    public ApkChangeDetector() {
+        this(null);
+    }
+
+    @VisibleForTesting
+    ApkChangeDetector(Set<String> packagesHandledInPreviousTestRuns) {
+        mPackagesHandledInPreviousTestRuns = packagesHandledInPreviousTestRuns;
+    }
 
     /**
      * Handle app pre-install process.
@@ -50,42 +69,79 @@ public class ApkChangeDetector {
      * @param packageName The name of the package.
      * @param testApps Indicate all APK files in the package with the name {@link packageName}.
      * @param device Indicates the device on which the test is running.
+     * @param userId The current user ID.
+     * @param forAllUsers Indicates whether the cleanup should be done for all users.
      * @return Whether the APKs in {@link packageName} are fully handled under local incremental
      *     setup. Default to false, which does not oblige to re-install the package APKs.
      */
     public boolean handleTestAppsPreinstall(
-        String packageName, List<File> testApps, ITestDevice device)
+        String packageName, List<File> testApps, ITestDevice device, Integer userId,
+        boolean forAllUsers)
         throws DeviceNotAvailableException {
+        if (!forAllUsers && userId != null && userId != 0) {
+            CLog.d(
+                "Not skipping the installation of %s because user %s is not the owner.",
+                packageName, userId);
+            return false;
+        }
+        if (!ensureIncrementalSetupSupported(device)) {
+            CLog.d(
+                "Not skipping the installation of %s because incremental setup is not supported",
+                packageName);
+            return false;
+        }
+        loadPackagesHandledInPreviousTestRuns(device);
         if (!cleanupAppsIfNecessary(device, testApps)) {
+            CLog.d(
+                "Not skipping the installation of %s because app cleanup is not successful",
+                packageName);
             return false;
         }
+        updateInstalledPackageCache(device, packageName);
 
+        boolean couldSkipAppInstallation = true;
         List<String> apkInstallPaths = getApkInstallPaths(packageName, device);
         if (apkInstallPaths.size() != testApps.size()) {
             CLog.d(
                 "The file count of APKs to be installed is not equal to the number of APKs on "
                     + "the device for the package '%s'. Install the APKs.", packageName);
-            return false;
-        }
-
-        Set<String> sha256SetOnDevice = getSha256SumsOnDevice(apkInstallPaths, device);
-        CLog.d("The SHA256Sums on device contains: ");
-        sha256SetOnDevice.forEach(sha256 -> {
-            CLog.d("%s", sha256);
-        });
+            couldSkipAppInstallation = false;
+        } else {
+            Set<String> sha256SetOnDevice = getSha256SumsOnDevice(apkInstallPaths, device);
+            CLog.d("The SHA256Sums on device contains: ");
+            sha256SetOnDevice.forEach(sha256 -> {
+                CLog.d("%s", sha256);
+            });
 
-        try {
-            Set<String> sha256SumsOnHost = new HashSet<>();
-            for (File testApp : testApps) {
-                sha256SumsOnHost.add(calculateSHA256OnHost(testApp));
+            try {
+                Set<String> sha256SumsOnHost = new HashSet<>();
+                for (File testApp : testApps) {
+                    sha256SumsOnHost.add(calculateSHA256OnHost(testApp));
+                }
+                couldSkipAppInstallation = sha256SetOnDevice.equals(sha256SumsOnHost);
+            } catch (IOException ex) {
+                CLog.d(
+                    "Exception occurred when calculating the SHA256Sums of APKs to be installed. "
+                        + "Install the APKs. Error message: %s", ex);
+                couldSkipAppInstallation = false;
             }
-            return sha256SetOnDevice.equals(sha256SumsOnHost);
-        } catch (IOException ex) {
+        }
+
+        if (couldSkipAppInstallation) {
             CLog.d(
-                "Exception occurred when calculating the SHA256Sums of APKs to be installed. "
-                    + "Install the APKs. Error message: %s", ex);
-            return false;
+                "Skipping the installation of %s because incremental setup is turned on.",
+                packageName);
+        } else if (getPackagesHandledInPreviousTestRuns(device).contains(packageName)) {
+            // If the package needs installation and it is previously handled by this detector,
+            // uninstall the obsolete package.
+            // TODO(ihcinihsdk): Ideally, only uninstall the package if the user specifies APKs
+            // need cleanup.
+            CLog.d(
+                "Not skipping the installation of %s because the APKs are likely to have changed.",
+                packageName);
+            device.uninstallPackage(packageName);
         }
+        return couldSkipAppInstallation;
     }
 
     /**
@@ -101,10 +157,18 @@ public class ApkChangeDetector {
     public boolean handlePackageCleanup(
         String packageName, ITestDevice device, Integer userId, boolean forAllUsers)
         throws DeviceNotAvailableException {
+        if (!mPackagesHandledInCurrentTestRun.contains(packageName)) {
+            // In case incremental setup is not supported for the package, skip package cleanup of
+            // this detector.
+            return false;
+        }
         // For the current implementation, we stop the app process. If successful, skip the app
         // uninstallation.
         String commandToRun = String.format("am force-stop %s", packageName);
         device.executeShellCommand(commandToRun);
+        CLog.d(
+            "Skipping the uninstallation of %s because incremental setup is turned on.",
+            packageName);
         return true;
     }
 
@@ -199,7 +263,28 @@ public class ApkChangeDetector {
         long totalAppSize = testApps.stream().mapToLong(File::length).sum();
         if (freeDiskSpace - totalAppSize * DISK_SPACE_TO_USE_ESTIMATE_FACTOR
                 < MIN_FREE_DISK_SPACE_THRESHOLD_IN_BYTES) {
-            throw new UnsupportedOperationException("App cleanup is not yet supported.");
+            // First, get the list of packages to be uninstalled.
+            Set<String> packagesToBeUninstalled =
+                Sets.difference(
+                    getPackagesHandledInPreviousTestRuns(device),
+                    mPackagesHandledInCurrentTestRun);
+
+            // Then, uninstall the packages.
+            boolean anyUninstallationFailed = false;
+            for (String packageName : packagesToBeUninstalled) {
+                if (device.uninstallPackage(packageName) != null) {
+                    anyUninstallationFailed = true;
+                }
+            }
+
+            // Finally, remove the file indicating the packages to be uninstalled if there is no
+            // uninstallation failure; otherwise, return false to indicate the cleanup is not
+            // successful.
+            if (anyUninstallationFailed) {
+                return false;
+            }
+            device.deleteFile(PACKAGE_INSTALLED_FILE_PATH);
+            mPackagesHandledInPreviousTestRuns = new HashSet<>();
         }
         return true;
     }
@@ -234,4 +319,76 @@ public class ApkChangeDetector {
         }
         return Long.parseLong(tokens[3]) * bytesInKiloBytes;
     }
+
+    /**
+     * Load the packages installed on the device and handled by the APK change detector in previous
+     * test runs.
+     */
+    @VisibleForTesting
+    void loadPackagesHandledInPreviousTestRuns(ITestDevice device)
+        throws DeviceNotAvailableException {
+        if (mPackagesHandledInPreviousTestRuns != null) {
+            return;
+        }
+
+        String fileContents = device.pullFileContents(PACKAGE_INSTALLED_FILE_PATH);
+        if (fileContents != null) {
+            Splitter splitter = Splitter.on('\n').trimResults().omitEmptyStrings();
+            mPackagesHandledInPreviousTestRuns =
+                Sets.newHashSet(splitter.split(fileContents));
+        } else {
+            mPackagesHandledInPreviousTestRuns = new HashSet<>();
+        }
+    }
+
+    /**
+     * Get the set of packages installed on the device and handled by the APK change detector in
+     * previous test runs.
+     */
+    @VisibleForTesting
+    Set<String> getPackagesHandledInPreviousTestRuns(ITestDevice device) {
+        return mPackagesHandledInPreviousTestRuns;
+    }
+
+    /**
+     * Return the incremental setup is supported on {@code device}.
+     *
+     * Note that this method has the side effect of creating a cache file under "/sdcard/." if it
+     * does not exist.
+     */
+    @VisibleForTesting
+    boolean ensureIncrementalSetupSupported(ITestDevice device)
+        throws DeviceNotAvailableException {
+        if (incrementalSetupSupportEnsureResult != null) {
+            return incrementalSetupSupportEnsureResult;
+        }
+
+        // Check if the device has sha256sum command installed.
+        String sha256SumDryRunOutput = device.executeShellCommand("sha256sum --help");
+        if (sha256SumDryRunOutput.contains("sha256sum: inaccessible or not found")) {
+            incrementalSetupSupportEnsureResult = false;
+            return false;
+        }
+
+        // Check if we have access to "/sdcard/.".
+        if (device.doesFileExist(PACKAGE_INSTALLED_FILE_PATH)) {
+            incrementalSetupSupportEnsureResult = true;
+        } else {
+            incrementalSetupSupportEnsureResult =
+                device.pushString("", PACKAGE_INSTALLED_FILE_PATH);
+        }
+        return incrementalSetupSupportEnsureResult;
+    }
+
+    private void updateInstalledPackageCache(ITestDevice device, String packageName)
+        throws DeviceNotAvailableException {
+        mPackagesHandledInCurrentTestRun.add(packageName);
+        Set<String> packagesHandledByIncrementalSetup =
+            Sets.union(
+                getPackagesHandledInPreviousTestRuns(device),
+                mPackagesHandledInCurrentTestRun);
+        device.pushString(
+            String.join("\n", packagesHandledByIncrementalSetup),
+            PACKAGE_INSTALLED_FILE_PATH);
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/incremental/OWNERS b/src/com/android/tradefed/targetprep/incremental/OWNERS
new file mode 100644
index 000000000..49bbcde2f
--- /dev/null
+++ b/src/com/android/tradefed/targetprep/incremental/OWNERS
@@ -0,0 +1 @@
+include platform/tools/asuite:/OWNERS_ADTE_TEAM
diff --git a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
index bc69731dc..687f7c5af 100644
--- a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
+++ b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
@@ -468,7 +468,7 @@ public abstract class SubprocessTfLauncher
             StreamUtil.close(eventParser);
             StreamUtil.close(protoReceiver);
 
-            if (mGlobalConfig != null) {
+            if (mGlobalConfig != null && new File(mGlobalConfig).exists()) {
                 logAndCleanFile(new File(mGlobalConfig), listener);
             }
 
diff --git a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
index d0d85de65..080d01f75 100644
--- a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
+++ b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
@@ -36,6 +36,7 @@ import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.ModuleResultsAndMetricsForwarder;
 import com.android.tradefed.result.ResultAndLogForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestRunResult;
@@ -93,8 +94,8 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
     private IConfiguration mModuleConfiguration;
     private ModuleListener mMainGranularRunListener;
     private RetryLogSaverResultForwarder mRetryAttemptForwarder;
-    private List<ITestInvocationListener> mModuleLevelListeners;
     private ITestInvocationListener mRemoteTestTimeOutEnforcer;
+    private ModuleResultsAndMetricsForwarder listenerWithModuleMetricsForwarder;
     private ILogSaver mLogSaver;
     private String mModuleId;
     private int mMaxRunLimit;
@@ -105,28 +106,37 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
     private RetryStatistics mRetryStats = null;
     private int mCountRetryUsed = 0;
 
+    private boolean mUseModuleResultsForwarder = false;
+
     public GranularRetriableTestWrapper(
             IRemoteTest test,
             ITestInvocationListener mainListener,
-            List<ITestInvocationListener> moduleLevelListeners,
             int maxRunLimit) {
-        this(test, null, mainListener, moduleLevelListeners, maxRunLimit);
+        this(test, null, mainListener, maxRunLimit);
     }
 
     public GranularRetriableTestWrapper(
             IRemoteTest test,
             ModuleDefinition module,
             ITestInvocationListener mainListener,
-            List<ITestInvocationListener> moduleLevelListeners,
             int maxRunLimit) {
+        this(test, module, mainListener, maxRunLimit, false);
+    }
+
+    public GranularRetriableTestWrapper(
+            IRemoteTest test,
+            ModuleDefinition module,
+            ITestInvocationListener mainListener,
+            int maxRunLimit,
+            boolean useModuleResultsForwarder) {
         mTest = test;
         mModule = module;
+        mUseModuleResultsForwarder = useModuleResultsForwarder;
         IInvocationContext context = null;
         if (module != null) {
             context = module.getModuleInvocationContext();
         }
         initializeGranularRunListener(mainListener, context);
-        mModuleLevelListeners = moduleLevelListeners;
         mMaxRunLimit = maxRunLimit;
     }
 
@@ -202,7 +212,14 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
      */
     private void initializeGranularRunListener(
             ITestInvocationListener listener, IInvocationContext moduleContext) {
+        ModuleResultsAndMetricsForwarder mListenerWithModuleMetricsForwarder = null;
+        if (mUseModuleResultsForwarder) {
+            mListenerWithModuleMetricsForwarder = new ModuleResultsAndMetricsForwarder(listener);
+            mListenerWithModuleMetricsForwarder.setModuleId(mModuleId);
+            listener = mListenerWithModuleMetricsForwarder;
+        }
         mMainGranularRunListener = new ModuleListener(listener, moduleContext);
+        mMainGranularRunListener.setUseModuleResultsForwarder(mUseModuleResultsForwarder);
         if (mModule != null) {
             ConfigurationDescriptor configDesc =
                     mModule.getModuleInvocationContext().getConfigurationDescriptor();
@@ -218,6 +235,9 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
                     configDesc.getMetaData(Integer.toString(mTest.hashCode()));
             if (testMappingSources != null) {
                 mMainGranularRunListener.setTestMappingSources(testMappingSources);
+                if (mListenerWithModuleMetricsForwarder != null) {
+                    mListenerWithModuleMetricsForwarder.setTestMappingSources(testMappingSources);
+                }
             }
         }
     }
@@ -232,10 +252,6 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
      */
     private ITestInvocationListener initializeListeners() throws DeviceNotAvailableException {
         List<ITestInvocationListener> currentTestListener = new ArrayList<>();
-        // Add all the module level listeners, including TestFailureListener
-        if (mModuleLevelListeners != null) {
-            currentTestListener.addAll(mModuleLevelListeners);
-        }
         currentTestListener.add(mMainGranularRunListener);
 
         if (mRemoteTestTimeOutEnforcer != null) {
@@ -350,6 +366,10 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             TestInformation testInfo, ITestInvocationListener runListener, int attempt) {
         DeviceNotAvailableException exception = null;
         mMainGranularRunListener.setAttemptIsolation(CurrentInvocation.runCurrentIsolation());
+        if (listenerWithModuleMetricsForwarder != null) {
+            listenerWithModuleMetricsForwarder.setAttemptIsolation(
+                    CurrentInvocation.runCurrentIsolation());
+        }
         StartEndCollector startEndCollector = new StartEndCollector(runListener);
         runListener = startEndCollector;
         try (CloseableTraceScope ignored =
diff --git a/src/com/android/tradefed/testtype/suite/ITestSuite.java b/src/com/android/tradefed/testtype/suite/ITestSuite.java
index d1de192ed..73108fb9e 100644
--- a/src/com/android/tradefed/testtype/suite/ITestSuite.java
+++ b/src/com/android/tradefed/testtype/suite/ITestSuite.java
@@ -63,7 +63,8 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ITestLoggerReceiver;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
-import com.android.tradefed.result.ResultForwarder;
+import com.android.tradefed.result.LogSaverResultForwarder;
+import com.android.tradefed.result.ResultAndLogForwarder;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.result.error.TestErrorIdentifier;
@@ -407,6 +408,13 @@ public abstract class ITestSuite
                             + " test_suites rule")
     private String mRunTestSuite = null;
 
+    @Option(
+            name = "use-module-results-forwarder",
+            description =
+                    "Feature flag to enable whether metrics should be forwarded by ModuleListener"
+                            + " or the new forwarder.")
+    private boolean mUseModuleResultsForwarder = true;
+
     public enum IsolatedModuleGrade {
         REBOOT_ISOLATED, // Reboot was done before the test.
         FULLY_ISOLATED; // Test received a fresh device.
@@ -542,6 +550,12 @@ public abstract class ITestSuite
 
             filteredConfig.put(config.getKey(), config.getValue());
             moduleNames.add(config.getValue().getConfigurationDescription().getModuleName());
+            File configPath =
+                    SearchArtifactUtil.getModuleDirFromConfig(
+                            config.getValue().getConfigurationDescription());
+            if (configPath != null) {
+                moduleNames.add(configPath.getName());
+            }
         }
 
         if (stageAtInvocationLevel()) {
@@ -845,9 +859,6 @@ public abstract class ITestSuite
             }
         }
 
-        /** Create the list of listeners applicable at the module level. */
-        List<ITestInvocationListener> moduleListeners = createModuleListeners();
-
         if (mUseSnapshotForReset) {
             AbstractConnection connection = mDevice.getConnection();
             if (connection instanceof AdbTcpConnection) {
@@ -880,10 +891,13 @@ public abstract class ITestSuite
             mSkipContext = SkipFeature.getSkipContext();
         }
         /** Run all the module, make sure to reduce the list to release resources as we go. */
-        try {
-            while (!mRunModules.isEmpty()) {
-                ModuleDefinition module = mRunModules.remove(0);
-
+        while (!mRunModules.isEmpty()) {
+            ModuleDefinition module = mRunModules.remove(0);
+            mModuleInProgress = module;
+            boolean moduleStartReported = false;
+            boolean moduleEndReported = false;
+            ITestInvocationListener listenerWithCollectors = null;
+            try {
                 if (!shouldModuleRun(module)) {
                     continue;
                 }
@@ -893,14 +907,23 @@ public abstract class ITestSuite
                     continue;
                 }
 
+                /** Create the list of listeners applicable at the module level. */
+                List<ITestInvocationListener> moduleListeners = createModuleListeners();
+
                 try (CloseableTraceScope ignore = new CloseableTraceScope(module.getId())) {
                     if (!stageAtInvocationLevel() && stageModuleLevel()) {
-                        stageTestArtifacts(
-                                mDevice,
-                                ImmutableSet.of(
-                                        module.getModuleConfiguration()
-                                                .getConfigurationDescription()
-                                                .getModuleName()));
+                        Set<String> moduleNames = new LinkedHashSet<String>();
+                        moduleNames.add(
+                                module.getModuleConfiguration()
+                                        .getConfigurationDescription()
+                                        .getModuleName());
+                        File configPath =
+                                SearchArtifactUtil.getModuleDirFromConfig(
+                                        module.getModuleInvocationContext());
+                        if (configPath != null) {
+                            moduleNames.add(configPath.getName());
+                        }
+                        stageTestArtifacts(mDevice, moduleNames);
                     }
                     // Populate the module context with devices and builds
                     for (String deviceName : mContext.getDeviceConfigNames()) {
@@ -917,10 +940,19 @@ public abstract class ITestSuite
                                         ModuleDefinition.MODULE_ISOLATED,
                                         CurrentInvocation.moduleCurrentIsolation().toString());
                     }
-                    // Add module specific post processors.
-                    listener = listenerWithPostProcessorsForPerfModule(module, listener);
+                    // Unify invocation level listeners, module listeners and module post-processors
+                    ITestInvocationListener allListenersWithoutLogSaver =
+                            listenerWithPostProcessors(module, listener, moduleListeners);
+                    // NOTE: do not set log saver again, since the previous log saver should have
+                    // already set it to the correct listeners.
+                    ITestInvocationListener allListenersWithLogSaver =
+                            new LogSaverResultForwarder(
+                                    mMainConfiguration.getLogSaver(),
+                                    Arrays.asList(allListenersWithoutLogSaver),
+                                    module.getModuleConfiguration(),
+                                    false);
                     // Only the module callback will be called here.
-                    ITestInvocationListener listenerWithCollectors = listener;
+                    listenerWithCollectors = allListenersWithLogSaver;
                     if (mMetricCollectors != null) {
                         for (IMetricCollector collector :
                                 CollectorHelper.cloneCollectors(mMetricCollectors)) {
@@ -992,10 +1024,7 @@ public abstract class ITestSuite
                             .addInvocationAttribute(
                                     MODULE_START_TIME, Long.toString(System.currentTimeMillis()));
                     listenerWithCollectors.testModuleStarted(module.getModuleInvocationContext());
-                    mModuleInProgress = module;
-                    // Trigger module start on module level listener too
-                    new ResultForwarder(moduleListeners)
-                            .testModuleStarted(module.getModuleInvocationContext());
+                    moduleStartReported = true;
                     boolean applyCachedResults =
                             cacheDescriptor != null
                                     && cacheDescriptor.isCacheHit()
@@ -1005,11 +1034,13 @@ public abstract class ITestSuite
                                                             .getCommandOptions()
                                                             .reportCacheResultsInPresubmit()))
                                     && mSkipContext.shouldUseCache();
-                    // TODO(b/372243975): report logs even while applying caching
+                    // If we are not gonna use the config file, delete right away after logging.
+                    boolean deleteRightAway = (moduleReporter == null);
                     if (moduleConfig != null && !applyCachedResults && !shouldSkipModule) {
+                        // TODO(b/372243975): report logs even while applying caching
                         try (InputStreamSource source =
-                                new FileInputStreamSource(moduleConfig, false)) {
-                            listener.testLog(
+                                new FileInputStreamSource(moduleConfig, deleteRightAway)) {
+                            allListenersWithLogSaver.testLog(
                                     "module-configuration", LogDataType.HARNESS_CONFIG, source);
                         }
                     }
@@ -1041,14 +1072,12 @@ public abstract class ITestSuite
                             module.getModuleInvocationContext()
                                     .addInvocationAttribute(ModuleDefinition.SPARSE_MODULE, "true");
                         } else {
-                            runSingleModule(module, moduleInfo, listener, moduleListeners);
+                            runSingleModule(module, moduleInfo, allListenersWithoutLogSaver);
                         }
                     } finally {
                         module.getModuleInvocationContext()
                                 .addInvocationAttribute(
                                         MODULE_END_TIME, Long.toString(System.currentTimeMillis()));
-                        // Trigger module end on module level listener too
-                        new ResultForwarder(moduleListeners).testModuleEnded();
                         if (mMainConfiguration.getCommandOptions().shouldUploadCacheResults()
                                 && moduleReporter != null) {
                             File protoResults = moduleReporter.getOutputFile();
@@ -1066,10 +1095,6 @@ public abstract class ITestSuite
                             moduleListeners.remove(moduleReporter);
                         }
                         FileUtil.deleteFile(moduleConfig);
-                        // clear out module invocation context since we are now done with module
-                        // execution
-                        listenerWithCollectors.testModuleEnded();
-                        mModuleInProgress = null;
                         if (!applyCachedResults) {
                             // Following modules will not be isolated if no action is taken
                             CurrentInvocation.setModuleIsolation(IsolationGrade.NOT_ISOLATED);
@@ -1077,16 +1102,42 @@ public abstract class ITestSuite
                     }
                     if (moduleRan) {
                         // Module isolation routine
-                        moduleIsolation(mContext, listener);
+                        moduleIsolation(mContext, allListenersWithLogSaver);
                     }
                 }
+            } catch (DeviceNotAvailableException e) {
+                CLog.e(
+                        "A DeviceNotAvailableException occurred, following modules did not run: %s",
+                        mRunModules);
+                // allow current module to properly report module start/end
+                mModuleInProgress.setReportModuleStart(!moduleStartReported);
+                mModuleInProgress.setReportModuleEnd(true);
+                String inProgressMessage =
+                        String.format(
+                                "Module %s was interrupted after starting due to device not"
+                                        + " available. Results might not be accurate or complete.",
+                                mModuleInProgress.getId());
+                if (listenerWithCollectors != null) {
+                    mModuleInProgress.reportNotExecuted(listenerWithCollectors, inProgressMessage);
+                } else {
+                    mModuleInProgress.reportNotExecuted(listener, inProgressMessage);
+                }
+                moduleEndReported = true;
+                reportNotExecuted(listener, "Module did not run due to device not available.");
+                throw e;
+            } finally {
+                // if module end not reported(no DNAE happened), report it now
+                if (moduleStartReported && !moduleEndReported) {
+                    if (listenerWithCollectors != null) {
+                        listenerWithCollectors.testModuleEnded();
+                    } else {
+                        listener.testModuleEnded();
+                    }
+                }
+                // clear out module invocation context since we are now done with module
+                // execution
+                mModuleInProgress = null;
             }
-        } catch (DeviceNotAvailableException e) {
-            CLog.e(
-                    "A DeviceNotAvailableException occurred, following modules did not run: %s",
-                    mRunModules);
-            reportNotExecuted(listener, "Module did not run due to device not available.");
-            throw e;
         }
     }
 
@@ -1094,28 +1145,50 @@ public abstract class ITestSuite
      * Returns a listener with module-level post processors (for perf modules) instered to the
      * listener chain.
      */
-    private ITestInvocationListener listenerWithPostProcessorsForPerfModule(
-            ModuleDefinition module, ITestInvocationListener listener) {
+    private ITestInvocationListener listenerWithPostProcessors(
+            ModuleDefinition module,
+            ITestInvocationListener invocationListener,
+            List<ITestInvocationListener> moduleListeners) {
+        // Strip LogSaverResultForwarder from invocationListener as a RetryLogSaverResultForwarder
+        // will be added during module execution later.
+        if (invocationListener instanceof LogSaverResultForwarder) {
+            List<ITestInvocationListener> origListeners =
+                    ((LogSaverResultForwarder) invocationListener).getListeners();
+            invocationListener = new ResultAndLogForwarder(origListeners);
+        }
+
         IConfiguration config = module.getModuleConfiguration();
         List<String> testTypes = config.getConfigurationDescription().getMetaData(TEST_TYPE_KEY);
+        List<ITestInvocationListener> allListeners = new ArrayList<>();
+        allListeners.add(invocationListener);
+        // wrap module listeners with a forwarder in order to keep the array object intact.
+        allListeners.add(new ResultAndLogForwarder(moduleListeners));
+        ITestInvocationListener allListenerWithForwarder = new ResultAndLogForwarder(allListeners);
+
         if (testTypes == null || !testTypes.contains(TEST_TYPE_VALUE_PERFORMANCE)) {
-            return listener; // not a perf module
+            return allListenerWithForwarder; // not a perf module
         }
         List<IPostProcessor> topLevelPostProcessors = mMainConfiguration.getPostProcessors();
         List<IPostProcessor> modulePostProcessors = config.getPostProcessors();
         if (modulePostProcessors.size() > 0 && topLevelPostProcessors.size() > 0) {
             CLog.w("Post processors specified at both top level and module level (%s)", module);
         }
+        // set log saver for module level post postprocessor manually to allow chained log
+        // processing at module level. Do this before init() to avoid passing down the log saver
+        // to invocation level listeners/reporters.
+        for (IPostProcessor postProcessor : modulePostProcessors) {
+            postProcessor.setLogSaver(mMainConfiguration.getLogSaver());
+        }
         for (IPostProcessor postProcessor : modulePostProcessors) {
             try {
-                listener = postProcessor.init(listener);
+                allListenerWithForwarder = postProcessor.init(allListenerWithForwarder);
             } catch (Exception e) {
                 CLog.e(
                         "Post processor %s is ignored as it fails to init() with exception: %s",
                         postProcessor.getClass().getSimpleName(), e);
             }
         }
-        return listener;
+        return allListenerWithForwarder;
     }
 
     /** Log the module configuration. */
@@ -1214,18 +1287,22 @@ public abstract class ITestSuite
      *
      * @param module The {@link ModuleDefinition} to be ran.
      * @param moduleInfo The {@link TestInformation} for the module.
-     * @param listener The {@link ITestInvocationListener} where to report results
-     * @param moduleListeners The {@link ITestInvocationListener}s that runs at the module level.
+     * @param allListeners The {@link ITestInvocationListener} where to report results
      * @param failureListener special listener that we add to collect information on failures.
      * @throws DeviceNotAvailableException
      */
     private void runSingleModule(
             ModuleDefinition module,
             TestInformation moduleInfo,
-            ITestInvocationListener listener,
-            List<ITestInvocationListener> moduleListeners)
+            ITestInvocationListener allListeners)
             throws DeviceNotAvailableException {
         Map<String, String> properties = new LinkedHashMap<>();
+        ITestInvocationListener allListenersWithLogSaver =
+                new LogSaverResultForwarder(
+                        mMainConfiguration.getLogSaver(),
+                        Arrays.asList(allListeners),
+                        module.getModuleConfiguration(),
+                        false);
         try (CloseableTraceScope ignored = new CloseableTraceScope("module_pre_check")) {
             if (mRebootPerModule) {
                 if ("user".equals(mDevice.getProperty(DeviceProperties.BUILD_TYPE))) {
@@ -1241,7 +1318,10 @@ public abstract class ITestSuite
             if (!mSkipAllSystemStatusCheck && !mSystemStatusCheckers.isEmpty()) {
                 properties.putAll(
                         runPreModuleCheck(
-                                module.getId(), mSystemStatusCheckers, mDevice, listener));
+                                module.getId(),
+                                mSystemStatusCheckers,
+                                mDevice,
+                                allListenersWithLogSaver));
             }
             if (mCollectTestsOnly) {
                 module.setCollectTestsOnly(mCollectTestsOnly);
@@ -1249,6 +1329,9 @@ public abstract class ITestSuite
             if (mRecoverDeviceByCvd) {
                 module.setRecoverVirtualDevice(mRecoverDeviceByCvd);
             }
+            if (mUseModuleResultsForwarder) {
+                module.setUseModuleResultsForwarder(mUseModuleResultsForwarder);
+            }
             // Pass the run defined collectors to be used.
             module.setMetricCollectors(CollectorHelper.cloneCollectors(mMetricCollectors));
             // Pass the main invocation logSaver
@@ -1257,7 +1340,7 @@ public abstract class ITestSuite
             IRetryDecision decision = mMainConfiguration.getRetryDecision();
             // Pass whether we should merge the attempts of not
             if (mMergeAttempts
-                    && decision.getMaxRetryCount() > 1
+                    && decision.getMaxTestRunAttempts(module) > 1
                     && !RetryStrategy.NO_RETRY.equals(decision.getRetryStrategy())) {
                 CLog.d("Overriding '--merge-attempts' to false for auto-retry.");
                 mMergeAttempts = false;
@@ -1276,15 +1359,17 @@ public abstract class ITestSuite
         // Actually run the module
         module.run(
                 moduleInfo,
-                listener,
-                moduleListeners,
-                getConfiguration().getRetryDecision().getMaxRetryCount());
+                allListeners,
+                getConfiguration().getRetryDecision().getMaxTestRunAttempts(module));
 
         if (!mSkipAllSystemStatusCheck && !mSystemStatusCheckers.isEmpty()) {
             try (CloseableTraceScope ignored = new CloseableTraceScope("module_post_check")) {
                 properties.putAll(
                         runPostModuleCheck(
-                                module.getId(), mSystemStatusCheckers, mDevice, listener));
+                                module.getId(),
+                                mSystemStatusCheckers,
+                                mDevice,
+                                allListenersWithLogSaver));
             }
         }
         for (Map.Entry<String, String> entry : properties.entrySet()) {
@@ -1666,16 +1751,6 @@ public abstract class ITestSuite
             runModules = createExecutionList();
         }
 
-        if (mModuleInProgress != null) {
-            // TODO: Ensure in-progress data make sense
-            String inProgressMessage =
-                    String.format(
-                            "Module %s was interrupted after starting. Results might not be "
-                                    + "accurate or complete.",
-                            mModuleInProgress.getId());
-            mModuleInProgress.reportNotExecuted(listener, inProgressMessage);
-        }
-
         while (!runModules.isEmpty()) {
             ModuleDefinition module = runModules.remove(0);
             module.reportNotExecuted(listener, message);
diff --git a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
index b5d253d94..5d22909f1 100644
--- a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
+++ b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
@@ -59,8 +59,8 @@ import com.android.tradefed.result.ILogSaverListener;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ITestLoggerReceiver;
 import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.LogSaverResultForwarder;
 import com.android.tradefed.result.MultiFailureDescription;
-import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestResult;
 import com.android.tradefed.result.TestRunResult;
@@ -100,10 +100,12 @@ import com.google.common.annotations.VisibleForTesting;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.ListIterator;
@@ -188,7 +190,9 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     private long mElapsedTearDown = 0L;
 
     private long mStartTestTime = 0L;
-    private Long mStartModuleRunDate = null;
+    private boolean mReportModuleStart = true;
+    private boolean mReportModuleEnd = true;
+    private boolean mFinalResultsReported = false;
 
     // Tracking of retry performance
     private List<RetryStatistics> mRetryStats = new ArrayList<>();
@@ -210,6 +214,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
 
     private boolean mRecoverVirtualDevice = false;
 
+    private boolean mUseModuleResultsForwarder = false;
+
     @VisibleForTesting
     public ModuleDefinition() {
         mModuleInvocationContext = null;
@@ -255,6 +261,9 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         ConfigurationDescriptor configDescriptor = moduleConfig.getConfigurationDescription();
         mModuleInvocationContext = new InvocationContext();
         mModuleInvocationContext.setConfigurationDescriptor(configDescriptor.clone());
+        // Copy the command options invocation attributes to the invocation context
+        mModuleInvocationContext.addInvocationAttributes(
+                moduleConfig.getCommandOptions().getInvocationData());
 
         // If available in the suite, add the abi name
         if (configDescriptor.getAbi() != null) {
@@ -416,23 +425,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
      */
     public final void run(TestInformation moduleInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
-        run(moduleInfo, listener, null);
-    }
-
-    /**
-     * Run all the {@link IRemoteTest} contained in the module and use all the preparers before and
-     * after to setup and clean the device.
-     *
-     * @param listener the {@link ITestInvocationListener} where to report results.
-     * @param moduleLevelListeners The list of listeners at the module level.
-     * @throws DeviceNotAvailableException in case of device going offline.
-     */
-    public final void run(
-            TestInformation moduleInfo,
-            ITestInvocationListener listener,
-            List<ITestInvocationListener> moduleLevelListeners)
-            throws DeviceNotAvailableException {
-        run(moduleInfo, listener, moduleLevelListeners, 1);
+        run(moduleInfo, listener, 1);
     }
 
     /**
@@ -441,21 +434,25 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
      *
      * @param moduleInfo the {@link TestInformation} for the module.
      * @param listener the {@link ITestInvocationListener} where to report results.
-     * @param moduleLevelListeners The list of listeners at the module level.
      * @param maxRunLimit the max number of runs for each testcase.
      * @throws DeviceNotAvailableException in case of device going offline.
      */
     public final void run(
             TestInformation moduleInfo,
             ITestInvocationListener listener,
-            List<ITestInvocationListener> moduleLevelListeners,
             int maxRunLimit)
             throws DeviceNotAvailableException {
         mMaxRetry = maxRunLimit;
         mModuleInfo = moduleInfo;
-        mInvocationListener = listener;
+        // until RetryLogSaverResultForwarder is created, wrap a temp log saver if needed.
+        if (!(listener instanceof LogSaverResultForwarder)) {
+            mInvocationListener =
+                    new LogSaverResultForwarder(
+                            mLogSaver, Arrays.asList(listener), mModuleConfiguration, false);
+        } else {
+            mInvocationListener = listener;
+        }
 
-        mStartModuleRunDate = System.currentTimeMillis();
         // Load extra configuration for the module from module_controller
         // TODO: make module_controller a full TF object
         boolean skipTestCases = false;
@@ -525,8 +522,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             boolean shouldFailRun = retryDecision.shouldFailRun();
             reportSetupFailure(
                     preparationException,
-                    listener,
-                    moduleLevelListeners,
+                    mInvocationListener,
                     mTargetPreparerRetryCount,
                     shouldFailRun);
             if (shouldFailRun) {
@@ -606,7 +602,6 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                         prepareGranularRetriableWrapper(
                                 test,
                                 listener,
-                                moduleLevelListeners,
                                 skipTestCases,
                                 perModuleRetryQuota);
                 mCurrentTestWrapper.setCollectTestsOnly(mCollectTestsOnly);
@@ -616,8 +611,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 if (preparationException != null) {
                     reportSetupFailure(
                             preparationException,
-                            listener,
-                            moduleLevelListeners,
+                            mInvocationListener,
                             mTargetPreparerRetryCount,
                             true);
                     return;
@@ -676,7 +670,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 // failed, capture a bugreport.
                 if (mCurrentTestWrapper.getResultListener().hasLastAttemptFailed()) {
                     captureBugreport(
-                            listener,
+                            mInvocationListener,
                             getId(),
                             mCurrentTestWrapper
                                     .getResultListener()
@@ -732,7 +726,13 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                     mModuleConfiguration.cleanConfigurationData();
                     if (mMergeAttempts) {
                         reportFinalResults(
-                                listener, mExpectedTests, mTestsResults, null, tearDownException);
+                                mInvocationListener,
+                                mExpectedTests,
+                                mTestsResults,
+                                null,
+                                tearDownException);
+                        mTestsResults.clear();
+                        mExpectedTests = 0;
                     } else {
                         boolean reported = false;
                         // Push the attempts one by one
@@ -760,7 +760,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                                             "failed in the 1st run but passed after retrying.");
                                 }
                                 reportFinalResults(
-                                        listener,
+                                        mInvocationListener,
                                         expectedCount,
                                         runResultList,
                                         i,
@@ -791,12 +791,11 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     GranularRetriableTestWrapper prepareGranularRetriableWrapper(
             IRemoteTest test,
             ITestInvocationListener listener,
-            List<ITestInvocationListener> moduleLevelListeners,
             boolean skipTestCases,
             int maxRunLimit) {
         GranularRetriableTestWrapper retriableTest =
                 new GranularRetriableTestWrapper(
-                        test, this, listener, moduleLevelListeners, maxRunLimit);
+                        test, this, listener, maxRunLimit, mUseModuleResultsForwarder);
         retriableTest.setModuleId(getId());
         retriableTest.setMarkTestsSkipped(skipTestCases);
         retriableTest.setMetricCollectors(mRunMetricCollectors);
@@ -944,11 +943,15 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         } else {
             listener.testRunEnded(getCurrentTime() - mStartTestTime, metricsProto);
         }
+        mFinalResultsReported = true;
     }
 
     private void forwardTestResults(
             Map<TestDescription, TestResult> testResults, ITestInvocationListener listener) {
-        for (Map.Entry<TestDescription, TestResult> testEntry : testResults.entrySet()) {
+        Iterator<Map.Entry<TestDescription, TestResult>> iterator =
+                testResults.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<TestDescription, TestResult> testEntry = iterator.next();
             listener.testStarted(testEntry.getKey(), testEntry.getValue().getStartTime());
             switch (testEntry.getValue().getResultStatus()) {
                 case FAILURE:
@@ -986,6 +989,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                     testEntry.getKey(),
                     testEntry.getValue().getEndTime(),
                     testEntry.getValue().getProtoMetrics());
+            // Remove the test result from the map to release memory.
+            iterator.remove();
         }
     }
 
@@ -1265,16 +1270,6 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         mModuleConfiguration.setRetryDecision(decision);
     }
 
-    /** Returns a list of tests that ran in this module. */
-    List<TestRunResult> getTestsResults() {
-        return mTestsResults;
-    }
-
-    /** Returns the number of tests that was expected to be run */
-    int getNumExpectedTests() {
-        return mExpectedTests;
-    }
-
     /** Returns True if a testRunFailure has been called on the module * */
     public boolean hasModuleFailed() {
         return mIsFailedModule;
@@ -1364,40 +1359,46 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         return mModuleConfiguration;
     }
 
+    public void setReportModuleStart(boolean shouldReportModuleStart) {
+        mReportModuleStart = shouldReportModuleStart;
+    }
+
+    public void setReportModuleEnd(boolean shouldReportModuleEnd) {
+        mReportModuleEnd = shouldReportModuleEnd;
+    }
+
     /** Report completely not executed modules. */
     public final void reportNotExecuted(ITestInvocationListener listener, String message) {
-        if (mStartModuleRunDate == null) {
+        if (mReportModuleStart) {
             listener.testModuleStarted(getModuleInvocationContext());
         }
         if (mCurrentTestWrapper != null)  {
-            mRunListenersResults.add(mCurrentTestWrapper.getResultListener());
-            HarnessRuntimeException interruptedException =
-                    new HarnessRuntimeException(
-                        message, TestErrorIdentifier.MODULE_DID_NOT_EXECUTE);
-            for (int i = 0; i < mMaxRetry; i++) {
-                // Get all the results for the attempt
-                List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
-                int expectedCount = 0;
-                for (ModuleListener attemptListener : mRunListenersResults) {
-                    for (String runName : attemptListener.getTestRunNames()) {
-                        TestRunResult run =
-                                attemptListener.getTestRunAtAttempt(runName, i);
-                        if (run != null) {
-                            runResultList.add(run);
-                            expectedCount += run.getExpectedTestCount();
+            // do not report results if already reported once
+            if (!mFinalResultsReported) {
+                mRunListenersResults.add(mCurrentTestWrapper.getResultListener());
+                HarnessRuntimeException interruptedException =
+                        new HarnessRuntimeException(
+                                message, TestErrorIdentifier.MODULE_DID_NOT_EXECUTE);
+                for (int i = 0; i < mMaxRetry; i++) {
+                    // Get all the results for the attempt
+                    List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
+                    int expectedCount = 0;
+                    for (ModuleListener attemptListener : mRunListenersResults) {
+                        for (String runName : attemptListener.getTestRunNames()) {
+                            TestRunResult run = attemptListener.getTestRunAtAttempt(runName, i);
+                            if (run != null) {
+                                runResultList.add(run);
+                                expectedCount += run.getExpectedTestCount();
+                            }
                         }
                     }
-                }
 
-                if (!runResultList.isEmpty()) {
-                    reportFinalResults(
-                            listener,
-                            expectedCount,
-                            runResultList,
-                            i,
-                            interruptedException);
-                } else {
-                    CLog.d("No results to be forwarded for attempt %s.", i);
+                    if (!runResultList.isEmpty()) {
+                        reportFinalResults(
+                                listener, expectedCount, runResultList, i, interruptedException);
+                    } else {
+                        CLog.d("No results to be forwarded for attempt %s.", i);
+                    }
                 }
             }
         } else {
@@ -1410,7 +1411,9 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             listener.testRunFailed(description);
             listener.testRunEnded(0, new HashMap<String, Metric>());
         }
-        listener.testModuleEnded();
+        if (mReportModuleEnd) {
+            listener.testModuleEnded();
+        }
     }
 
     /** Whether or not to enable dynamic download at module level. */
@@ -1551,21 +1554,12 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     private void reportSetupFailure(
             Throwable setupException,
             ITestInvocationListener invocListener,
-            List<ITestInvocationListener> moduleListeners,
             int attemptNumber,
             boolean shouldFail)
         throws DeviceNotAvailableException {
-        List<ITestInvocationListener> allListeners = new ArrayList<>();
-        allListeners.add(invocListener);
-        if (moduleListeners != null) {
-            allListeners.addAll(moduleListeners);
-        }
-        // Report the early module failures to the moduleListeners too in order for them
-        // to know about it.
-        ITestInvocationListener forwarder = new ResultForwarder(allListeners);
         // For reporting purpose we create a failure placeholder with the error stack
         // similar to InitializationError of JUnit.
-        forwarder.testRunStarted(getId(), 1, attemptNumber, System.currentTimeMillis());
+        invocListener.testRunStarted(getId(), 1, attemptNumber, System.currentTimeMillis());
         FailureDescription failureDescription =
                 CurrentInvocation.createFailure(StreamUtil.getStackTrace(setupException), null);
         if (setupException instanceof IHarnessException
@@ -1583,10 +1577,10 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             failureDescription.setFailureStatus(FailureStatus.UNSET);
         }
         failureDescription.setCause(setupException);
-        forwarder.testRunFailed(failureDescription);
+        invocListener.testRunFailed(failureDescription);
         HashMap<String, Metric> metricsProto = new HashMap<>();
         metricsProto.put(TEST_TIME, TfMetricProtoUtil.createSingleValue(0L, "milliseconds"));
-        forwarder.testRunEnded(0, metricsProto);
+        invocListener.testRunEnded(0, metricsProto);
         // If it was a not available exception rethrow it to signal the new device state.
         if (setupException instanceof DeviceNotAvailableException) {
             if (!shouldFail) {
@@ -1620,4 +1614,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             ((ITestFilterReceiver) test).addAllExcludeFilters(filterNames);
         }
     }
+
+    public void setUseModuleResultsForwarder(boolean useModuleResultsForwarder) {
+        mUseModuleResultsForwarder = useModuleResultsForwarder;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/ModuleListener.java b/src/com/android/tradefed/testtype/suite/ModuleListener.java
index a62591e94..12daa4b1c 100644
--- a/src/com/android/tradefed/testtype/suite/ModuleListener.java
+++ b/src/com/android/tradefed/testtype/suite/ModuleListener.java
@@ -27,7 +27,6 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.LogFile;
-import com.android.tradefed.result.LogSaverResultForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestStatus;
 import com.android.tradefed.result.skipped.SkipReason;
@@ -61,6 +60,7 @@ public class ModuleListener extends CollectingTestListener {
 
     private List<String> mTestMappingSources = new ArrayList<String>();
     private static final String TEST_MAPPING_SOURCE = "test_mapping_source";
+    private boolean mUseModuleResultsForwarder = false;
 
     /** Constructor. */
     public ModuleListener(ITestInvocationListener listener, IInvocationContext moduleContext) {
@@ -137,13 +137,15 @@ public class ModuleListener extends CollectingTestListener {
     public void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
         CLog.d("ModuleListener.testRunEnded(%s) on %s", elapsedTime, getSerial());
 
-        if (!IsolationGrade.NOT_ISOLATED.equals(mAttemptIsolation)) {
-            runMetrics.put(
-                    "run-isolated", TfMetricProtoUtil.stringToMetric(mAttemptIsolation.toString()));
-            // In case something was off, reset isolation.
-            mAttemptIsolation = IsolationGrade.NOT_ISOLATED;
+        if (!mUseModuleResultsForwarder) {
+            if (!IsolationGrade.NOT_ISOLATED.equals(mAttemptIsolation)) {
+                runMetrics.put(
+                        "run-isolated",
+                        TfMetricProtoUtil.stringToMetric(mAttemptIsolation.toString()));
+                // In case something was off, reset isolation.
+                mAttemptIsolation = IsolationGrade.NOT_ISOLATED;
+            }
         }
-
         super.testRunEnded(elapsedTime, runMetrics);
         mRunInProgress = false;
     }
@@ -204,10 +206,12 @@ public class ModuleListener extends CollectingTestListener {
     @Override
     public void testEnded(TestDescription test, long endTime, HashMap<String, Metric> testMetrics) {
         logTestStatus(test, mTestStatus);
-        if (!mTestMappingSources.isEmpty()) {
-            testMetrics.put(
-                    TEST_MAPPING_SOURCE,
-                    TfMetricProtoUtil.stringToMetric(mTestMappingSources.toString()));
+        if (!mUseModuleResultsForwarder) {
+            if (!mTestMappingSources.isEmpty()) {
+                testMetrics.put(
+                        TEST_MAPPING_SOURCE,
+                        TfMetricProtoUtil.stringToMetric(mTestMappingSources.toString()));
+            }
         }
         super.testEnded(test, endTime, testMetrics);
     }
@@ -269,10 +273,9 @@ public class ModuleListener extends CollectingTestListener {
     /** {@inheritDoc} */
     @Override
     public void testLog(String dataName, LogDataType dataType, InputStreamSource dataStream) {
-        if (mMainListener instanceof LogSaverResultForwarder) {
-            // If the listener is a log saver, we should simply forward the testLog not save again.
-            ((LogSaverResultForwarder) mMainListener)
-                    .testLogForward(dataName, dataType, dataStream);
+        if (mMainListener != null) {
+            // let mainListener handle the testLog event.
+            mMainListener.testLog(dataName, dataType, dataStream);
         } else {
             super.testLog(dataName, dataType, dataStream);
         }
@@ -310,4 +313,8 @@ public class ModuleListener extends CollectingTestListener {
         }
         return mModuleContext.getDevices().get(0).getSerialNumber();
     }
+
+    public void setUseModuleResultsForwarder(boolean useModuleResultsForwarder) {
+        mUseModuleResultsForwarder = useModuleResultsForwarder;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/SuiteModuleLoader.java b/src/com/android/tradefed/testtype/suite/SuiteModuleLoader.java
index c33ad539f..827440fef 100644
--- a/src/com/android/tradefed/testtype/suite/SuiteModuleLoader.java
+++ b/src/com/android/tradefed/testtype/suite/SuiteModuleLoader.java
@@ -26,9 +26,11 @@ import com.android.tradefed.config.IDeviceConfiguration;
 import com.android.tradefed.config.OptionDef;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceFoldableState;
+import com.android.tradefed.device.metric.IMetricCollector;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.postprocessor.IPostProcessor;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.targetprep.ITargetPreparer;
 import com.android.tradefed.testtype.IAbi;
@@ -174,7 +176,6 @@ public class SuiteModuleLoader {
         for (File configFile : listConfigFiles) {
             Map<String, IConfiguration> loadedConfigs =
                     loadOneConfig(
-                            configFile.getParentFile(),
                             configFile.getName(),
                             configFile.getAbsolutePath(),
                             abis,
@@ -247,7 +248,7 @@ public class SuiteModuleLoader {
             List<String> configs, Set<IAbi> abis, String suiteTag) {
         LinkedHashMap<String, IConfiguration> toRun = new LinkedHashMap<>();
         for (String configName : configs) {
-            toRun.putAll(loadOneConfig(null, configName, configName, abis, suiteTag));
+            toRun.putAll(loadOneConfig(configName, configName, abis, suiteTag));
         }
         return toRun;
     }
@@ -257,7 +258,6 @@ public class SuiteModuleLoader {
      * does not implements {@link ITestFileFilterReceiver}. This can be overriden to create a more
      * restrictive behavior.
      *
-     * @param moduleDir The module directory
      * @param test The {@link IRemoteTest} that is being considered.
      * @param abi The Abi we are currently working on.
      * @param moduleId The id of the module (usually abi + module name).
@@ -265,7 +265,6 @@ public class SuiteModuleLoader {
      * @param excludeFilters The formatted and parsed exclude filters.
      */
     public void addFiltersToTest(
-            File moduleDir,
             IRemoteTest test,
             IAbi abi,
             String moduleId,
@@ -281,10 +280,10 @@ public class SuiteModuleLoader {
         LinkedHashSet<SuiteTestFilter> mdIncludes = getFilterList(includeFilters, moduleId);
         LinkedHashSet<SuiteTestFilter> mdExcludes = getFilterList(excludeFilters, moduleId);
         if (!mdIncludes.isEmpty()) {
-            addTestIncludes(moduleDir, (ITestFilterReceiver) test, mdIncludes, moduleId);
+            addTestIncludes((ITestFilterReceiver) test, mdIncludes, moduleId);
         }
         if (!mdExcludes.isEmpty()) {
-            addTestExcludes(moduleDir, (ITestFilterReceiver) test, mdExcludes, moduleId);
+            addTestExcludes((ITestFilterReceiver) test, mdExcludes, moduleId);
         }
     }
 
@@ -299,7 +298,6 @@ public class SuiteModuleLoader {
      * @return A map of loaded configuration.
      */
     private LinkedHashMap<String, IConfiguration> loadOneConfig(
-            File moduleDir,
             String configName,
             String configFullName,
             Set<IAbi> abis,
@@ -442,7 +440,6 @@ public class SuiteModuleLoader {
                                     baseId,
                                     fullId,
                                     paramConfig,
-                                    moduleDir,
                                     abi);
                             param.applySetup(paramConfig);
                             toRun.put(fullId, paramConfig);
@@ -477,8 +474,7 @@ public class SuiteModuleLoader {
                         paramConfig
                                 .getConfigurationDescription()
                                 .addMetadata(ITestSuite.ACTIVE_MAINLINE_PARAMETER_KEY, param);
-                        setUpConfig(
-                                name, nameWithParam, baseId, fullId, paramConfig, moduleDir, abi);
+                        setUpConfig(name, nameWithParam, baseId, fullId, paramConfig, abi);
                         handler.applySetup(paramConfig);
                         toRun.put(fullId, paramConfig);
                     }
@@ -494,7 +490,7 @@ public class SuiteModuleLoader {
                     // Always add the base regular configuration to the execution.
                     // Do not pass the nameWithParam in because it would cause the module args be
                     // injected into config twice if we pass nameWithParam using name.
-                    setUpConfig(name, null, baseId, baseId, config, moduleDir, abi);
+                    setUpConfig(name, null, baseId, baseId, config, abi);
                     toRun.put(baseId, config);
                 }
             }
@@ -632,13 +628,12 @@ public class SuiteModuleLoader {
     }
 
     private void addTestIncludes(
-            File moduleDir,
             ITestFilterReceiver test,
             Collection<SuiteTestFilter> includes,
             String moduleId) {
         if (test instanceof ITestFileFilterReceiver) {
             String escapedFileName = escapeFilterFileName(moduleId);
-            File includeFile = createFilterFile(escapedFileName, ".include", moduleDir, includes);
+            File includeFile = createFilterFile(escapedFileName, ".include", includes);
             if (includeFile != null) {
                 ((ITestFileFilterReceiver) test).setIncludeTestFile(includeFile);
             }
@@ -654,13 +649,12 @@ public class SuiteModuleLoader {
     }
 
     private void addTestExcludes(
-            File moduleDir,
             ITestFilterReceiver test,
             Collection<SuiteTestFilter> excludes,
             String moduleId) {
         if (test instanceof ITestFileFilterReceiver) {
             String escapedFileName = escapeFilterFileName(moduleId);
-            File excludeFile = createFilterFile(escapedFileName, ".exclude", moduleDir, excludes);
+            File excludeFile = createFilterFile(escapedFileName, ".exclude", excludes);
             if (excludeFile != null) {
                 ((ITestFileFilterReceiver) test).setExcludeTestFile(excludeFile);
             }
@@ -679,17 +673,13 @@ public class SuiteModuleLoader {
     }
 
     private File createFilterFile(
-            String prefix, String suffix, File moduleDir, Collection<SuiteTestFilter> filters) {
+            String prefix, String suffix, Collection<SuiteTestFilter> filters) {
         if (filters.isEmpty()) {
             return null;
         }
         File filterFile = null;
         try {
-            if (moduleDir == null) {
-                filterFile = FileUtil.createTempFile(prefix, suffix);
-            } else {
-                filterFile = new File(moduleDir, prefix + suffix);
-            }
+            filterFile = FileUtil.createTempFile(prefix, suffix);
             try (PrintWriter out = new PrintWriter(filterFile)) {
                 for (SuiteTestFilter filter : filters) {
                     String filterTest = filter.getTest();
@@ -939,7 +929,6 @@ public class SuiteModuleLoader {
             String id,
             String fullId,
             IConfiguration config,
-            File moduleDir,
             IAbi abi)
             throws ConfigurationException {
         List<OptionDef> optionsToInject = new ArrayList<>();
@@ -957,6 +946,26 @@ public class SuiteModuleLoader {
         }
         config.injectOptionValues(optionsToInject);
 
+        for (IMetricCollector collector : config.getMetricCollectors()) {
+            String className = collector.getClass().getName();
+            if (mTestOrPreparerOptions.containsKey(className)) {
+                OptionSetter collectorSetter = new OptionSetter(collector);
+                for (OptionDef def : mTestOrPreparerOptions.get(className)) {
+                    collectorSetter.setOptionValue(def.name, def.key, def.value);
+                }
+            }
+        }
+
+        for (IPostProcessor postProcessor : config.getPostProcessors()) {
+            String className = postProcessor.getClass().getName();
+            if (mTestOrPreparerOptions.containsKey(className)) {
+                OptionSetter processorSetter = new OptionSetter(postProcessor);
+                for (OptionDef def : mTestOrPreparerOptions.get(className)) {
+                    processorSetter.setOptionValue(def.name, def.key, def.value);
+                }
+            }
+        }
+
         // Set target preparers
         for (IDeviceConfiguration holder : config.getDeviceConfig()) {
             for (ITargetPreparer preparer : holder.getTargetPreparers()) {
@@ -983,7 +992,7 @@ public class SuiteModuleLoader {
                     preparerSetter.setOptionValue(def.name, def.key, def.value);
                 }
             }
-            addFiltersToTest(moduleDir, test, abi, fullId, mIncludeFilters, mExcludeFilters);
+            addFiltersToTest(test, abi, fullId, mIncludeFilters, mExcludeFilters);
             if (test instanceof IAbiReceiver) {
                 ((IAbiReceiver) test).setAbi(abi);
             }
diff --git a/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java b/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java
index 29b205e4e..20e934087 100644
--- a/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java
+++ b/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java
@@ -29,17 +29,31 @@ import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.proto.ModuleProtoResultReporter;
 import com.android.tradefed.result.skipped.SkipContext;
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.testtype.ITestFileFilterReceiver;
 import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.FileUtil;
 
 import build.bazel.remote.execution.v2.Digest;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.hash.HashCode;
+
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
+import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
 
 /** Utility to upload and download cache results for a test module. */
 public class SuiteResultCacheUtil {
@@ -48,6 +62,10 @@ public class SuiteResultCacheUtil {
     public static final String MODULE_CONFIG_KEY = "module_config";
     public static final String TRADEFED_JAR_VERSION_KEY = "tradefed.jar_version";
 
+    private static final Set<String> REMOVE_APKS =
+            ImmutableSet.of("TradefedContentProvider.apk", "TelephonyUtility.apk", "WifiUtil.apk");
+    private static final Map<String, Digest> COMPUTE_CACHE = new ConcurrentHashMap<String, Digest>();
+
     /** Describes the cache results. */
     public static class CacheResultDescriptor {
         private final boolean cacheHit;
@@ -120,6 +138,11 @@ public class SuiteResultCacheUtil {
             if (tradefedDigest != null) {
                 environment.put(TRADEFED_JAR_VERSION_KEY, tradefedDigest.getHash());
             }
+            int i = 0;
+            for (Digest d : filterFileDigest(module)) {
+                environment.put("filter_" + i, d.getHash());
+                i++;
+            }
             if (module.getIntraModuleShardCount() != null
                     && module.getIntraModuleShardIndex() != null) {
                 environment.put(
@@ -188,6 +211,11 @@ public class SuiteResultCacheUtil {
                     environment.put(TRADEFED_JAR_VERSION_KEY, tradefedDigest.getHash());
                 }
             }
+            int i = 0;
+            for (Digest d : filterFileDigest(module)) {
+                environment.put("filter_" + i, d.getHash());
+                i++;
+            }
             if (module.getIntraModuleShardCount() != null
                     && module.getIntraModuleShardIndex() != null) {
                 environment.put(
@@ -249,9 +277,66 @@ public class SuiteResultCacheUtil {
         for (String file : classpathStr.split(":")) {
             File currentJar = new File(file);
             if (currentJar.exists() && "tradefed.jar".equals(currentJar.getName())) {
-                return DigestCalculator.compute(currentJar);
+                return processJarFile(currentJar.getAbsolutePath());
             }
         }
         return null;
     }
+
+    private static Digest processJarFile(String jarFilePath) throws IOException {
+        if (COMPUTE_CACHE.containsKey(jarFilePath)) {
+            return COMPUTE_CACHE.get(jarFilePath);
+        }
+        try (JarFile jarFile = new JarFile(jarFilePath)) {
+            Enumeration<JarEntry> entries = jarFile.entries();
+            MessageDigest digest = MessageDigest.getInstance("SHA-256");
+
+            while (entries.hasMoreElements()) {
+                JarEntry entry = entries.nextElement();
+                if (REMOVE_APKS.contains(entry.getName())) {
+                    continue;
+                }
+                if (!entry.isDirectory()) {
+                    try (InputStream is = jarFile.getInputStream(entry)) {
+                        byte[] buffer = new byte[8192];
+                        int bytesRead;
+
+                        while ((bytesRead = is.read(buffer)) != -1) {
+                            digest.update(buffer, 0, bytesRead);
+                        }
+                    } catch (IOException e) {
+                        CLog.e(e);
+                    }
+                }
+            }
+            Digest tfDigest =
+                    Digest.newBuilder()
+                            .setHash(HashCode.fromBytes(digest.digest()).toString())
+                            .setSizeBytes(digest.getDigestLength())
+                            .build();
+            COMPUTE_CACHE.put(jarFilePath, tfDigest);
+            return tfDigest;
+        } catch (NoSuchAlgorithmException e) {
+            throw new IOException(e);
+        }
+    }
+
+    private static Set<Digest> filterFileDigest(ModuleDefinition m) throws IOException {
+        Set<Digest> filterDigest = new LinkedHashSet<Digest>();
+        for (IRemoteTest t : m.getTests()) {
+            if (t instanceof ITestFileFilterReceiver) {
+                ITestFileFilterReceiver fileFilterTest = ((ITestFileFilterReceiver) t);
+
+                File includeFilter = fileFilterTest.getIncludeTestFile();
+                if (includeFilter != null && includeFilter.exists()) {
+                    filterDigest.add(DigestCalculator.compute(includeFilter));
+                }
+                File excludeFilter = fileFilterTest.getExcludeTestFile();
+                if (excludeFilter != null && excludeFilter.exists()) {
+                    filterDigest.add(DigestCalculator.compute(excludeFilter));
+                }
+            }
+        }
+        return filterDigest;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java b/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
index a23fadac7..2f5cb5511 100644
--- a/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
+++ b/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
@@ -298,6 +298,14 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
         mTestGroup = null;
     }
 
+    public void clearTestMappingPaths() {
+        mTestMappingPaths.clear();
+    }
+
+    public void clearKeywords() {
+        mKeywords.clear();
+    }
+
     /**
      * Create individual tests with test infos for a module.
      *
diff --git a/src/com/android/tradefed/testtype/suite/module/Sdk36ModuleController.java b/src/com/android/tradefed/testtype/suite/module/Sdk36ModuleController.java
new file mode 100644
index 000000000..c6b696b7b
--- /dev/null
+++ b/src/com/android/tradefed/testtype/suite/module/Sdk36ModuleController.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.testtype.suite.module;
+
+/**
+ * Only run tests if the device under test is SDK version 36 or above.
+ *
+ * <p>Use by adding this line to your AndroidTest.xml:
+ *
+ * <pre><code>&lt;object type="module_controller"
+ * class="com.android.tradefed.testtype.suite.module.Sdk36ModuleController" /&gt;</code></pre>
+ */
+public class Sdk36ModuleController extends MinSdkModuleController {
+    public Sdk36ModuleController() {
+        super(36);
+    }
+}
diff --git a/src/com/android/tradefed/testtype/suite/module/ShippingApiLevelModuleController.java b/src/com/android/tradefed/testtype/suite/module/ShippingApiLevelModuleController.java
index d33def86f..7eaf061a6 100644
--- a/src/com/android/tradefed/testtype/suite/module/ShippingApiLevelModuleController.java
+++ b/src/com/android/tradefed/testtype/suite/module/ShippingApiLevelModuleController.java
@@ -16,10 +16,10 @@
 package com.android.tradefed.testtype.suite.module;
 
 import com.android.tradefed.config.Option;
-import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.StubDevice;
+import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.log.LogUtil.CLog;
 
 /**
@@ -35,6 +35,11 @@ import com.android.tradefed.log.LogUtil.CLog;
  *         <li>The device shipped with the {@code vsr-min-api-level} or later.
  *         <li>The vendor image implemented the features for the {@code vsr-min-api-level} or later.
  *       </ul>
+ *   <li>If {@code vendor-min-api-level} is defined:
+ *       <ul>
+ *         <li>The vendor image implemented the features for the {@code vendor-min-api-level} or
+ *             later.
+ *       </ul>
  * </ul>
  */
 public class ShippingApiLevelModuleController extends BaseModuleController {
@@ -53,6 +58,11 @@ public class ShippingApiLevelModuleController extends BaseModuleController {
 
     @Option(
             name = "vsr-min-api-level",
+            description = "The minimum VSR api-level of the device on which tests will run.")
+    private Integer mMinVsrApiLevel = 0;
+
+    @Option(
+            name = "vendor-min-api-level",
             description = "The minimum vendor api-level of the device on which tests will run.")
     private Integer mMinVendorApiLevel = 0;
 
@@ -117,19 +127,19 @@ public class ShippingApiLevelModuleController extends BaseModuleController {
                 }
             }
 
-            if (mMinVendorApiLevel > 0) {
-                if (mMinVendorApiLevel > 34 && mMinVendorApiLevel < 202404) {
+            if (mMinVsrApiLevel > 0) {
+                if (mMinVsrApiLevel > 34 && mMinVsrApiLevel < 202404) {
                     throw new RuntimeException(
                             "vsr-min-api-level must have YYYYMM format if it has a value greater"
                                     + " than 34, but has "
-                                    + mMinVendorApiLevel);
+                                    + mMinVsrApiLevel);
                 }
                 // All devices with Android T or newer defines "ro.vendor.api_level". Read this to
                 // compare the API level with vsr-min-api-level.
                 long vsrApiLevel =
                         device.getIntProperty(VSR_VENDOR_API_LEVEL_PROP, VALUE_NOT_FOUND);
                 if (vsrApiLevel != VALUE_NOT_FOUND) {
-                    if (vsrApiLevel < mMinVendorApiLevel) {
+                    if (vsrApiLevel < mMinVsrApiLevel) {
                         return RunStrategy.FULL_MODULE_BYPASS;
                     } else {
                         return RunStrategy.RUN;
@@ -142,7 +152,7 @@ public class ShippingApiLevelModuleController extends BaseModuleController {
                         new String[] {
                             SYSTEM_SHIPPING_API_LEVEL_PROP, SYSTEM_API_LEVEL_PROP,
                         },
-                        mMinVendorApiLevel)) {
+                        mMinVsrApiLevel)) {
                     return RunStrategy.FULL_MODULE_BYPASS;
                 }
                 // And then, read "ro.board.api_level" and "ro.board.first_api_level".
@@ -151,7 +161,21 @@ public class ShippingApiLevelModuleController extends BaseModuleController {
                         new String[] {
                             VENDOR_API_LEVEL_PROP, VENDOR_SHIPPING_API_LEVEL_PROP,
                         },
-                        mMinVendorApiLevel)) {
+                        mMinVsrApiLevel)) {
+                    return RunStrategy.FULL_MODULE_BYPASS;
+                }
+            }
+
+            if (mMinVendorApiLevel > 0) {
+                if (mMinVendorApiLevel < 202404) {
+                    throw new RuntimeException(
+                            "vendor-min-api-level must have YYYYMM format greater than or equal to"
+                                    + " 202404, but has "
+                                    + mMinVendorApiLevel);
+                }
+
+                long vendorApiLevel = device.getIntProperty(VENDOR_API_LEVEL_PROP, VALUE_NOT_FOUND);
+                if (vendorApiLevel == VALUE_NOT_FOUND || vendorApiLevel < mMinVendorApiLevel) {
                     return RunStrategy.FULL_MODULE_BYPASS;
                 }
             }
diff --git a/src/com/android/tradefed/testtype/suite/params/multiuser/ProfileParameterHandler.java b/src/com/android/tradefed/testtype/suite/params/multiuser/ProfileParameterHandler.java
index a23aa5cc1..ee4511ffa 100644
--- a/src/com/android/tradefed/testtype/suite/params/multiuser/ProfileParameterHandler.java
+++ b/src/com/android/tradefed/testtype/suite/params/multiuser/ProfileParameterHandler.java
@@ -35,20 +35,20 @@ import java.util.Set;
 /** Base parameter handler for any profile user. */
 public abstract class ProfileParameterHandler {
 
-    private final String mRequireRunOnProfileAnnotation;
+    private final List<String> mRequireRunOnProfileAnnotations;
     private final ProfileTargetPreparer mProfileTargetPreparer;
     private final List<IModuleController> mModuleControllers;
 
     ProfileParameterHandler(
-            String requireRunOnProfileAnnotation, ProfileTargetPreparer profileTargetPreparer) {
-        this(requireRunOnProfileAnnotation, profileTargetPreparer, new ArrayList<>());
+            List<String> requireRunOnProfileAnnotations, ProfileTargetPreparer profileTargetPreparer) {
+        this(requireRunOnProfileAnnotations, profileTargetPreparer, new ArrayList<>());
     }
 
     ProfileParameterHandler(
-            String requireRunOnProfileAnnotation,
+            List<String> requireRunOnProfileAnnotations,
             ProfileTargetPreparer profileTargetPreparer,
             List<IModuleController> moduleControllers) {
-        mRequireRunOnProfileAnnotation = requireRunOnProfileAnnotation;
+        mRequireRunOnProfileAnnotations = requireRunOnProfileAnnotations;
         mProfileTargetPreparer = profileTargetPreparer;
         mModuleControllers = moduleControllers;
     }
@@ -72,10 +72,11 @@ public abstract class ProfileParameterHandler {
             if (test instanceof ITestAnnotationFilterReceiver) {
                 ITestAnnotationFilterReceiver filterTest = (ITestAnnotationFilterReceiver) test;
                 filterTest.clearIncludeAnnotations();
-                filterTest.addIncludeAnnotation(mRequireRunOnProfileAnnotation);
-
                 Set<String> excludeAnnotations = new HashSet<>(filterTest.getExcludeAnnotations());
-                excludeAnnotations.remove(mRequireRunOnProfileAnnotation);
+                for (String requireRunOnProfileAnnotation : mRequireRunOnProfileAnnotations) {
+                    filterTest.addIncludeAnnotation(requireRunOnProfileAnnotation);
+                    excludeAnnotations.remove(requireRunOnProfileAnnotation);
+                }
                 filterTest.clearExcludeAnnotations();
                 filterTest.addAllExcludeAnnotation(excludeAnnotations);
             }
diff --git a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandler.java b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandler.java
index 3bf77bc9e..474222f53 100644
--- a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandler.java
+++ b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnCloneProfileParameterHandler.java
@@ -21,16 +21,19 @@ import com.android.tradefed.testtype.suite.module.Sdk34ModuleController;
 import com.android.tradefed.testtype.suite.params.IModuleParameterHandler;
 
 import java.util.Arrays;
+import java.util.List;
 
 public class RunOnCloneProfileParameterHandler extends ProfileParameterHandler
         implements IModuleParameterHandler {
 
-    private static final String REQUIRE_RUN_ON_CLONE_PROFILE_NAME =
-            "com.android.bedstead.multiuser.annotations.RequireRunOnCloneProfile";
+    private static final List<String> REQUIRE_RUN_ON_CLONE_PROFILE_NAMES = List.of(
+            "com.android.bedstead.multiuser.annotations.RequireRunOnCloneProfile",
+            "com.android.bedstead.harrier.annotations.RequireRunOnCloneProfile"
+    );
 
     public RunOnCloneProfileParameterHandler() {
         super(
-                REQUIRE_RUN_ON_CLONE_PROFILE_NAME,
+                REQUIRE_RUN_ON_CLONE_PROFILE_NAMES,
                 new RunOnCloneProfileTargetPreparer(),
                 Arrays.asList(new Sdk34ModuleController()));
     }
diff --git a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandler.java b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandler.java
index df43bed10..d8ce1a0c1 100644
--- a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandler.java
+++ b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnPrivateProfileParameterHandler.java
@@ -21,15 +21,18 @@ import com.android.tradefed.testtype.suite.module.Sdk35ModuleController;
 import com.android.tradefed.testtype.suite.params.IModuleParameterHandler;
 
 import java.util.Arrays;
+import java.util.List;
 
 public class RunOnPrivateProfileParameterHandler extends ProfileParameterHandler implements
         IModuleParameterHandler {
 
-    private static final String REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME =
-            "com.android.bedstead.multiuser.annotations.RequireRunOnPrivateProfile";
+    private static final List<String> REQUIRE_RUN_ON_PRIVATE_PROFILE_NAMES = List.of(
+            "com.android.bedstead.multiuser.annotations.RequireRunOnPrivateProfile",
+            "com.android.bedstead.harrier.annotations.RequireRunOnPrivateProfile"
+    );
 
     public RunOnPrivateProfileParameterHandler() {
-        super(REQUIRE_RUN_ON_PRIVATE_PROFILE_NAME, new RunOnPrivateProfileTargetPreparer(),
+        super(REQUIRE_RUN_ON_PRIVATE_PROFILE_NAMES, new RunOnPrivateProfileTargetPreparer(),
                 Arrays.asList(new Sdk35ModuleController()));
     }
 
diff --git a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandler.java b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandler.java
index 082ba2e8c..c96128991 100644
--- a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandler.java
+++ b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnSecondaryUserParameterHandler.java
@@ -31,8 +31,10 @@ import java.util.Set;
 
 public class RunOnSecondaryUserParameterHandler implements IModuleParameterHandler {
 
-    private static final String REQUIRE_RUN_ON_SECONDARY_USER_NAME =
-            "com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser";
+    private static final List<String> REQUIRE_RUN_ON_SECONDARY_USER_NAMES = List.of(
+            "com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser",
+            "com.android.bedstead.harrier.annotations.RequireRunOnSecondaryUser"
+    );
 
     @Override
     public String getParameterIdentifier() {
@@ -59,10 +61,11 @@ public class RunOnSecondaryUserParameterHandler implements IModuleParameterHandl
             if (test instanceof ITestAnnotationFilterReceiver) {
                 ITestAnnotationFilterReceiver filterTest = (ITestAnnotationFilterReceiver) test;
                 filterTest.clearIncludeAnnotations();
-                filterTest.addIncludeAnnotation(REQUIRE_RUN_ON_SECONDARY_USER_NAME);
-
                 Set<String> excludeAnnotations = new HashSet<>(filterTest.getExcludeAnnotations());
-                excludeAnnotations.remove(REQUIRE_RUN_ON_SECONDARY_USER_NAME);
+                for (String requireRunOnSecondaryUserName : REQUIRE_RUN_ON_SECONDARY_USER_NAMES) {
+                    filterTest.addIncludeAnnotation(requireRunOnSecondaryUserName);
+                    excludeAnnotations.remove(requireRunOnSecondaryUserName);
+                }
                 filterTest.clearExcludeAnnotations();
                 filterTest.addAllExcludeAnnotation(excludeAnnotations);
             }
diff --git a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandler.java b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandler.java
index ea3af0f02..495c4d960 100644
--- a/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandler.java
+++ b/src/com/android/tradefed/testtype/suite/params/multiuser/RunOnWorkProfileParameterHandler.java
@@ -19,14 +19,18 @@ package com.android.tradefed.testtype.suite.params.multiuser;
 import com.android.tradefed.targetprep.RunOnWorkProfileTargetPreparer;
 import com.android.tradefed.testtype.suite.params.IModuleParameterHandler;
 
+import java.util.List;
+
 public class RunOnWorkProfileParameterHandler extends ProfileParameterHandler
         implements IModuleParameterHandler {
 
-    private static final String REQUIRE_RUN_ON_WORK_PROFILE_NAME =
-            "com.android.bedstead.enterprise.annotations.RequireRunOnWorkProfile";
+    private static final List<String> REQUIRE_RUN_ON_WORK_PROFILE_NAMES = List.of(
+            "com.android.bedstead.enterprise.annotations.RequireRunOnWorkProfile",
+            "com.android.bedstead.harrier.annotations.RequireRunOnWorkProfile"
+    );
 
     public RunOnWorkProfileParameterHandler() {
-        super(REQUIRE_RUN_ON_WORK_PROFILE_NAME, new RunOnWorkProfileTargetPreparer());
+        super(REQUIRE_RUN_ON_WORK_PROFILE_NAMES, new RunOnWorkProfileTargetPreparer());
     }
 
     @Override
diff --git a/src/com/android/tradefed/testtype/suite/retry/RetryRescheduler.java b/src/com/android/tradefed/testtype/suite/retry/RetryRescheduler.java
index d7e2ae305..62e53362f 100644
--- a/src/com/android/tradefed/testtype/suite/retry/RetryRescheduler.java
+++ b/src/com/android/tradefed/testtype/suite/retry/RetryRescheduler.java
@@ -387,7 +387,7 @@ public final class RetryRescheduler implements IRemoteTest, IConfigurationReceiv
         // Since we always have 1 default reporter, avoid carrying it for no reason. Only carry
         // reporters if some actual ones were specified.
         if (retryConfig.getTestInvocationListeners().size() == 1
-                && (mConfiguration.getTestInvocationListeners().get(0)
+                && (retryConfig.getTestInvocationListeners().get(0)
                         instanceof TextResultReporter)) {
             return;
         }
diff --git a/src/com/android/tradefed/util/AbiFormatter.java b/src/com/android/tradefed/util/AbiFormatter.java
index a86ec9909..6ffc20439 100644
--- a/src/com/android/tradefed/util/AbiFormatter.java
+++ b/src/com/android/tradefed/util/AbiFormatter.java
@@ -30,7 +30,8 @@ public class AbiFormatter {
     private static final String PRODUCT_CPU_ABILIST_KEY = "ro.product.cpu.abilist";
     private static final String PRODUCT_CPU_ABI_KEY = "ro.product.cpu.abi";
     public static final String FORCE_ABI_STRING = "force-abi";
-    public static final String FORCE_ABI_DESCRIPTION = "The abi to use, can be either 32 or 64.";
+    public static final String FORCE_ABI_DESCRIPTION =
+            "The abi bitness to use, can be either 32 or 64.";
 
     /**
      * Special marker to be used as a placeholder in strings, that can be then
diff --git a/src/com/android/tradefed/util/GCSFileDownloader.java b/src/com/android/tradefed/util/GCSFileDownloader.java
index 218039a2f..0c3cab907 100644
--- a/src/com/android/tradefed/util/GCSFileDownloader.java
+++ b/src/com/android/tradefed/util/GCSFileDownloader.java
@@ -67,7 +67,11 @@ public class GCSFileDownloader extends GCSFileDownloaderBase implements IFileDow
     }
 
     public GCSFileDownloader(File jsonKeyFile) {
-        this(false);
+        this(jsonKeyFile, false);
+    }
+
+    public GCSFileDownloader(File jsonKeyFile, Boolean createEmptyFile) {
+        this(createEmptyFile);
         mJsonKeyFile = jsonKeyFile;
     }
 
diff --git a/src/com/android/tradefed/util/JUnitXmlParser.java b/src/com/android/tradefed/util/JUnitXmlParser.java
index 7576ef3eb..9f3a22481 100644
--- a/src/com/android/tradefed/util/JUnitXmlParser.java
+++ b/src/com/android/tradefed/util/JUnitXmlParser.java
@@ -71,6 +71,7 @@ public class JUnitXmlParser extends AbstractXmlParser {
         private static final String TESTCASE_TAG = "testcase";
         private TestDescription mCurrentTest = null;
         private StringBuffer mFailureContent = null;
+        private StringBuffer mSkippedTagContent = null;
         private String mCurrentMessage = null;
         private long mRunTimeMillis = 0L;
 
@@ -102,9 +103,8 @@ public class JUnitXmlParser extends AbstractXmlParser {
                 mTestListener.testStarted(mCurrentTest);
             }
             if (SKIPPED_TAG.equalsIgnoreCase(name)) {
-                if (mCurrentTest != null) {
-                    mTestListener.testIgnored(mCurrentTest);
-                }
+              // keeps track of the skipped tag content in case of assumption failure
+                mSkippedTagContent = new StringBuffer();
             }
             if (FAILURE_TAG.equalsIgnoreCase(name) || ERROR_TAG.equalsIgnoreCase(name)) {
                 // current testcase has a failure - will be extracted in characters() callback
@@ -123,6 +123,10 @@ public class JUnitXmlParser extends AbstractXmlParser {
             if (mFailureContent != null) {
                 mFailureContent.append(data, offset, len);
             }
+            // if currently parsing a skipped tag content, add stack data to content
+            if (mSkippedTagContent != null) {
+                mSkippedTagContent.append(data, offset, len);
+            }
         }
 
         /** {@inheritDoc} */
@@ -146,8 +150,17 @@ public class JUnitXmlParser extends AbstractXmlParser {
                                 mFailureContent.toString(), FailureStatus.TEST_FAILURE);
                 mTestListener.testFailed(mCurrentTest, failure);
             }
+            if (SKIPPED_TAG.equalsIgnoreCase(name) && mCurrentTest != null) {
+              if (mSkippedTagContent == null || mSkippedTagContent.length() == 0) {
+                // if there was no skipped tag content, the test was ignored
+                mTestListener.testIgnored(mCurrentTest);
+              } else {
+                mTestListener.testAssumptionFailure(mCurrentTest, mSkippedTagContent.toString());
+              }
+            }
             mFailureContent = null;
             mCurrentMessage = null;
+            mSkippedTagContent = null;
         }
 
         /**
diff --git a/src/com/android/tradefed/util/KernelModuleUtils.java b/src/com/android/tradefed/util/KernelModuleUtils.java
index eaf750fad..6ae8d9657 100644
--- a/src/com/android/tradefed/util/KernelModuleUtils.java
+++ b/src/com/android/tradefed/util/KernelModuleUtils.java
@@ -100,12 +100,10 @@ public class KernelModuleUtils {
      * @throws TargetSetupError if the module cannot be installed
      * @throws DeviceNotAvailableException if the device is not available
      */
-    public static void installModule(
+    public static CommandResult installModule(
             ITestDevice device, String modulePath, String arg, long timeoutMs)
             throws TargetSetupError, DeviceNotAvailableException {
 
-        String kernelModule = getDisplayedModuleName(modulePath);
-
         String command = String.format("insmod %s %s", modulePath, arg);
         CLog.i("Installing %s on %s", modulePath, device.getSerialNumber());
         CommandResult result =
@@ -118,18 +116,41 @@ public class KernelModuleUtils {
                     DeviceErrorIdentifier.KERNEL_MODULE_INSTALLATION_FAILED);
         }
         if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
+            String moduleName = getDisplayedModuleName(modulePath);
             String errorMessage =
                     String.format(
                             "shell command %s failed with exit code: %d, stderr: %s, stdout:"
                                     + " %s",
                             command, result.getExitCode(), result.getStderr(), result.getStdout());
-            CLog.e("Unable to install module '%s'. Error message: %s", kernelModule, errorMessage);
+            CLog.e("Unable to install module '%s'. Error message: %s", moduleName, errorMessage);
             throw new TargetSetupError(
                     String.format(
                             "Failed to install %s on %s. Error message: '%s'",
-                            kernelModule, device.getSerialNumber(), errorMessage),
+                            moduleName, device.getSerialNumber(), errorMessage),
                     DeviceErrorIdentifier.KERNEL_MODULE_INSTALLATION_FAILED);
         }
+        return result;
+    }
+
+    /**
+     * Remove a kernel module from the given device.
+     *
+     * <p>This method attempts to remove the target kernel module from the device. No dependent
+     * modules will be removed.
+     *
+     * @param device the device to remove the module from
+     * @param moduleName the name to the module to remove
+     * @throws DeviceNotAvailableException if the device is not available
+     */
+    public static CommandResult removeSingleModule(ITestDevice device, String moduleName)
+            throws DeviceNotAvailableException {
+
+        String command = String.format("rmmod %s", moduleName);
+        CommandResult result = device.executeShellV2Command(command);
+        if (result != null) {
+            CLog.i("'%s' returned %s.", command, result.getStdout());
+        }
+        return result;
     }
 
     /**
@@ -140,29 +161,20 @@ public class KernelModuleUtils {
      * effort.
      *
      * @param device the device to remove the module from
-     * @param module the name or the path to the module to remove
+     * @param moduleName the name to the module to remove
      * @throws DeviceNotAvailableException if the device is not available
      */
-    public static void removeModule(ITestDevice device, String module)
+    public static CommandResult removeModuleWithDependency(ITestDevice device, String moduleName)
             throws DeviceNotAvailableException {
 
-        String kernelModule = getDisplayedModuleName(module);
-        String command;
-
-        CLog.i("Remove kernel module %s from %s", kernelModule, device.getSerialNumber());
-
         String output = device.executeShellCommand("lsmod");
         CLog.d("lsmod output: %s from %s", output, device.getSerialNumber());
-        for (String modName : getDependentModules(kernelModule, output)) {
+        for (String modName : getDependentModules(moduleName, output)) {
             String trimmedName = modName.trim();
-            command = String.format("rmmod %s", trimmedName);
-            output = device.executeShellCommand(command);
-            CLog.i("'%s' returned %s.", command, output);
+            removeSingleModule(device, trimmedName);
         }
 
         // Clean up, unload module with best effort
-        command = String.format("rmmod %s", kernelModule);
-        output = device.executeShellCommand(command);
-        CLog.i("'%s' returned %s.", command, output);
+        return removeSingleModule(device, moduleName);
     }
 }
diff --git a/src/com/android/tradefed/util/ListInstrumentationParser.java b/src/com/android/tradefed/util/ListInstrumentationParser.java
index bcdb2c040..a85cb53be 100644
--- a/src/com/android/tradefed/util/ListInstrumentationParser.java
+++ b/src/com/android/tradefed/util/ListInstrumentationParser.java
@@ -49,7 +49,9 @@ public class ListInstrumentationParser extends MultiLineReceiver {
             new HashSet<>(
                     Arrays.asList(
                             "android.support.test.runner.AndroidJUnitRunner",
-                            "androidx.test.runner.AndroidJUnitRunner"));
+                            "androidx.test.runner.AndroidJUnitRunner",
+                            // Context b/383366431: This is an extension of AndroidJUnitRunner
+                            "android.testing.TestableInstrumentation"));
 
     private List<InstrumentationTarget> mInstrumentationTargets = new ArrayList<>();
 
diff --git a/src/com/android/tradefed/util/SystemUtil.java b/src/com/android/tradefed/util/SystemUtil.java
index 8ccbb0345..9b0ed3d48 100644
--- a/src/com/android/tradefed/util/SystemUtil.java
+++ b/src/com/android/tradefed/util/SystemUtil.java
@@ -33,7 +33,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-
 /** Utility class for making system calls. */
 public class SystemUtil {
 
@@ -53,6 +52,7 @@ public class SystemUtil {
 
     private static final String LOCAL_AUTH_VARIABLE = "LOCAL_AUTH";
     private static final String LOCAL_MODE = "LOCAL_MODE";
+    private static final String SKIP_JAVA_QUERY = "SKIP_JAVA_QUERY";
 
     /** Keep track of the mapping of the variables to the subpath it takes in the tests dir. */
     public static final Map<EnvVariable, String> ENV_VARIABLE_PATHS_IN_TESTS_DIR = new HashMap<>();
@@ -196,7 +196,7 @@ public class SystemUtil {
 
     /** Returns the path to the Java binary that current test harness is running in */
     public static File getRunningJavaBinaryPath() {
-        return getRunningJavaBinaryPath(false);
+        return getRunningJavaBinaryPath(System.getenv(SKIP_JAVA_QUERY) != null);
     }
 
     /**
diff --git a/src/com/android/tradefed/util/TestRunnerUtil.java b/src/com/android/tradefed/util/TestRunnerUtil.java
index 91610e164..6eda44004 100644
--- a/src/com/android/tradefed/util/TestRunnerUtil.java
+++ b/src/com/android/tradefed/util/TestRunnerUtil.java
@@ -63,6 +63,11 @@ public class TestRunnerUtil {
                 if (libFile.exists()) {
                     paths.add(libFile.getAbsolutePath());
                 }
+                // Handle special case of art
+                libFile = new File(new File(testcasesFolderPath, "art_common/out/host/linux-x86/"), lib);
+                if (libFile.exists()) {
+                    paths.add(libFile.getAbsolutePath());
+                }
             }
             // Include ANDROID_HOST_OUT/lib to support local case.
             if (androidHostOut != null) {
diff --git a/src/com/android/tradefed/util/TfInternalOptionsFetcher.java b/src/com/android/tradefed/util/TfInternalOptionsFetcher.java
new file mode 100644
index 000000000..284a09a25
--- /dev/null
+++ b/src/com/android/tradefed/util/TfInternalOptionsFetcher.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.config.OptionSetter.Handler;
+import com.android.tradefed.config.OptionSetter.MapHandler;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Properties;
+import java.util.regex.Pattern;
+
+/**
+ * A utility class that allows classes to load a variables value statically from a res file.
+ *
+ * <p>The resource file should be in a key=value format, where the key is associated with the
+ * variable that needs to be retrieved. A single resource file can contain multiple lines, where
+ * each line is associated with one variable.
+ *
+ * <p>To specify any primitive types, a single key=value pair should be used in a line. e.g.:
+ *
+ * <ol>
+ *   <li>my-integer-key=5
+ *   <li>my-string-key=myStringValue
+ * </ol>
+ *
+ * <p>To specify any collections, multiple values can be used, separated by a comma(,). e.g.:
+ *
+ * <ol>
+ *   <li>my-string-list-key=stringOne,stringTwo,stringThree
+ *   <li>my-int-list-key=1,2,3,4,5
+ * </ol>
+ *
+ * <p>To specify a map, multiple mapKey\=mapValue pair can be used, separated by a comma(,). e.g.:
+ *
+ * <ol>
+ *   <li>my-map-key=mapKey1\=mapVal1,mapKey2\=mapVal2
+ * </ol>
+ */
+public class TfInternalOptionsFetcher {
+    private static String resourcePath = "/util/TfInternalOptions.properties";
+
+    /**
+     * Fetches the values for all declared fields of the given {@link Class} from the specified
+     * resource file. If a resource file is not set, a default resource file will be used.
+     *
+     * @param classObj the class {@link Object} whose fields should be populated.
+     */
+    public static void fetchOption(Class<?> classObj) {
+        try (InputStream stream =
+                TfInternalOptionsFetcher.class.getResourceAsStream(resourcePath)) {
+            // load the properties from the resource file
+            Properties properties = new Properties();
+            properties.load(stream);
+            for (Field field : classObj.getDeclaredFields()) {
+                String propertyKey = field.getName();
+                String optionVal = (String) properties.get(propertyKey);
+                // if property exists, update the field
+                if (optionVal != null) {
+                    Handler handler = OptionSetter.getHandler(field.getGenericType());
+                    if (handler == null) {
+                        throw new ConfigurationException(
+                                String.format(
+                                        "Unable to get handler for option '%s'.", propertyKey),
+                                InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
+                    }
+                    boolean isOptionField = false;
+                    if (field.getAnnotation(Option.class) != null) {
+                        isOptionField = true;
+                    }
+                    if (Collection.class.isAssignableFrom(field.getType())) {
+                        // if field is a collection, allow multiple values to be specified.
+                        String[] optionValues = optionVal.split(",");
+                        for (String optionValue : optionValues) {
+                            // translate the value
+                            Object translatedValue = handler.translate(optionValue);
+                            OptionSetter.setFieldValue(
+                                    propertyKey,
+                                    classObj,
+                                    field,
+                                    null,
+                                    translatedValue,
+                                    isOptionField);
+                        }
+                    } else if (Map.class.isAssignableFrom(field.getType())) {
+                        // if field is a map, allow multiple key=value pairs for the option value.
+                        String[] optionValues = optionVal.split(",");
+                        for (String optionValue : optionValues) {
+                            String mapKey;
+                            String mapVal;
+                            // only match = to escape use "\="
+                            Pattern p = Pattern.compile("(?<!\\\\)=");
+                            String[] parts =
+                                    p.split(optionValue, /* allow empty-string values */ -1);
+                            // Note that we replace escaped = (\=) to =.
+                            if (parts.length == 2) {
+                                mapKey = parts[0].replaceAll("\\\\=", "=");
+                                mapVal = parts[1].replaceAll("\\\\=", "=");
+                            } else {
+                                throw new ConfigurationException(
+                                        String.format(
+                                                "option '%s' has an invalid format for value %s:w",
+                                                propertyKey, optionValue),
+                                        InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
+                            }
+                            // translate the key and value
+                            Object translatedKey = ((MapHandler) handler).translateKey(mapKey);
+                            Object translatedValue = handler.translate(mapVal);
+                            OptionSetter.setFieldValue(
+                                    propertyKey,
+                                    classObj,
+                                    field,
+                                    translatedKey,
+                                    translatedValue,
+                                    isOptionField);
+                        }
+                    } else {
+                        OptionSetter.setFieldValue(
+                                propertyKey,
+                                classObj,
+                                field,
+                                null,
+                                handler.translate(optionVal),
+                                isOptionField);
+                    }
+                }
+            }
+        } catch (IOException | ConfigurationException e) {
+            CLog.w("Unable to fetch option values for class '%s'.", classObj.getName());
+            CLog.e(e);
+        }
+    }
+
+    /** Set the path of the resource file where the value will be retrieved from. */
+    public static void setResourcePath(String path) {
+        resourcePath = path;
+    }
+}
diff --git a/src/com/android/tradefed/util/image/DeviceImageTracker.java b/src/com/android/tradefed/util/image/DeviceImageTracker.java
index e7425ebf0..27ebbd8f1 100644
--- a/src/com/android/tradefed/util/image/DeviceImageTracker.java
+++ b/src/com/android/tradefed/util/image/DeviceImageTracker.java
@@ -16,16 +16,11 @@
 package com.android.tradefed.util.image;
 
 import com.android.annotations.VisibleForTesting;
-import com.android.tradefed.log.LogUtil.CLog;
-import com.android.tradefed.util.FileUtil;
 
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
-import com.google.common.cache.RemovalListener;
-import com.google.common.cache.RemovalNotification;
 
-import java.io.File;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 
@@ -38,27 +33,17 @@ public class DeviceImageTracker {
     private static DeviceImageTracker sDefaultInstance;
 
     private final LoadingCache<String, FileCacheTracker> mImageCache;
-    private final File mCacheDir;
 
     /** Track information of the device image cached and its metadata */
     public class FileCacheTracker {
-        public File zippedDeviceImage;
-        public File zippedBootloaderImage;
-        public File zippedBasebandImage;
         public String buildId;
         public String branch;
         public String flavor;
 
         FileCacheTracker(
-                File zippedDeviceImage,
-                File zippedBootloaderImage,
-                File zippedBasebandImage,
                 String buildId,
                 String branch,
                 String flavor) {
-            this.zippedDeviceImage = zippedDeviceImage;
-            this.zippedBootloaderImage = zippedBootloaderImage;
-            this.zippedBasebandImage = zippedBasebandImage;
             this.buildId = buildId;
             this.branch = branch;
             this.flavor = flavor;
@@ -74,27 +59,10 @@ public class DeviceImageTracker {
 
     @VisibleForTesting
     protected DeviceImageTracker() {
-        try {
-            mCacheDir = FileUtil.createTempDir("image_file_cache_dir");
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-        RemovalListener<String, FileCacheTracker> listener =
-                new RemovalListener<String, FileCacheTracker>() {
-                    @Override
-                    public void onRemoval(RemovalNotification<String, FileCacheTracker> n) {
-                        if (n.wasEvicted()) {
-                            FileUtil.recursiveDelete(n.getValue().zippedDeviceImage);
-                            FileUtil.deleteFile(n.getValue().zippedBootloaderImage);
-                            FileUtil.deleteFile(n.getValue().zippedBasebandImage);
-                        }
-                    }
-                };
         mImageCache =
                 CacheBuilder.newBuilder()
                         .maximumSize(20)
                         .expireAfterAccess(1, TimeUnit.DAYS)
-                        .removalListener(listener)
                         .build(
                                 new CacheLoader<String, FileCacheTracker>() {
                                     @Override
@@ -118,61 +86,21 @@ public class DeviceImageTracker {
      * Tracks a given device image to the device serial that was flashed with it
      *
      * @param serial The device that was flashed with the image.
-     * @param deviceImage The image flashed onto the device.
      * @param buildId The build id associated with the device image.
      * @param branch The branch associated with the device image.
      * @param flavor The build flavor associated with the device image.
      */
     public void trackUpdatedDeviceImage(
             String serial,
-            File deviceImage,
-            File bootloader,
-            File baseband,
             String buildId,
             String branch,
             String flavor) {
-        if (bootloader == null) {
-            CLog.d("Skip tracking image, bootloader is null.");
-            return;
-        }
-        if (deviceImage == null) {
-            CLog.d("Skip tracking image, device image is null.");
-            return;
-        }
-        File copyInCacheDeviceImage = new File(mCacheDir, serial + "_device_image");
-        FileUtil.recursiveDelete(copyInCacheDeviceImage);
-        File copyInCacheBootloader = new File(mCacheDir, serial + "_bootloader");
-        FileUtil.deleteFile(copyInCacheBootloader);
-        File copyInCacheBaseband = null;
-        if (baseband != null) { // Baseband is optional on some devices
-            copyInCacheBaseband = new File(mCacheDir, serial + "_baseband");
-            FileUtil.deleteFile(copyInCacheBaseband);
-        }
-        try {
-            if (deviceImage.isDirectory()) {
-                CLog.d("Tracking device image as directory: %s", copyInCacheDeviceImage);
-                FileUtil.recursiveHardlink(deviceImage, copyInCacheDeviceImage);
-            } else {
-                CLog.d("Tracking device image: %s", copyInCacheDeviceImage);
-                FileUtil.hardlinkFile(deviceImage, copyInCacheDeviceImage);
-            }
-            FileUtil.hardlinkFile(bootloader, copyInCacheBootloader);
-            if (copyInCacheBaseband != null) {
-                FileUtil.hardlinkFile(baseband, copyInCacheBaseband);
-            }
-            mImageCache.put(
-                    serial,
-                    new FileCacheTracker(
-                            copyInCacheDeviceImage,
-                            copyInCacheBootloader,
-                            copyInCacheBaseband,
-                            buildId,
-                            branch,
-                            flavor));
-        } catch (IOException e) {
-            invalidateTracking(serial);
-            CLog.e(e);
-        }
+        mImageCache.put(
+                serial,
+                new FileCacheTracker(
+                        buildId,
+                        branch,
+                        flavor));
     }
 
     public void invalidateTracking(String serial) {
@@ -182,7 +110,6 @@ public class DeviceImageTracker {
     @VisibleForTesting
     protected void cleanUp() {
         mImageCache.invalidateAll();
-        FileUtil.recursiveDelete(mCacheDir);
     }
 
     /** Returns the device image that was tracked for the device. Null if none was tracked. */
diff --git a/src/com/android/tradefed/util/image/IncrementalImageUtil.java b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
index 92eed3757..1f33e2223 100644
--- a/src/com/android/tradefed/util/image/IncrementalImageUtil.java
+++ b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
@@ -17,13 +17,14 @@ package com.android.tradefed.util.image;
 
 import static org.junit.Assert.assertTrue;
 
+import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
-import com.android.tradefed.device.DeviceDisconnectedException;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.IManagedTestDevice;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.ITestDevice.RecoveryMode;
+import com.android.tradefed.device.NativeDevice;
 import com.android.tradefed.device.SnapuserdWaitPhase;
 import com.android.tradefed.device.TestDevice;
 import com.android.tradefed.device.TestDeviceState;
@@ -85,9 +86,6 @@ public class IncrementalImageUtil {
                     "vendor.img",
                     "vendor_dlkm.img");
 
-    private final File mSrcImage;
-    private final File mSrcBootloader;
-    private final File mSrcBaseband;
     private final File mTargetImage;
     private final ITestDevice mDevice;
     private final File mCreateSnapshotBinary;
@@ -113,131 +111,103 @@ public class IncrementalImageUtil {
             IDeviceBuildInfo build,
             File createSnapshot,
             boolean isIsolatedSetup,
-            boolean allowCrossRelease,
+            boolean allowTrackerlessUpdate,
             Set<String> allowedTransition,
-            boolean applySnapshot,
-            boolean wipeAfterApply,
             boolean newFlow,
             boolean updateBootloaderFromUserspace,
-            SnapuserdWaitPhase waitPhase)
+            SnapuserdWaitPhase waitPhase,
+            boolean useMerkleTree)
             throws DeviceNotAvailableException {
-        // With apply snapshot, device reset is supported
-        if (isIsolatedSetup && !applySnapshot) {
-            CLog.d("test is configured with isolation grade, doesn't support incremental yet.");
-            return null;
-        }
         String serialNumber = device.getSerialNumber();
         FileCacheTracker tracker =
                 DeviceImageTracker.getDefaultCache().getBaselineDeviceImage(serialNumber);
+        boolean crossRelease = false;
         if (tracker == null) {
             CLog.d("Not tracking current baseline image for %s", serialNumber);
-            return null;
-        }
-        String deviceBuildId = device.getBuildId();
-        if (!tracker.buildId.equals(deviceBuildId)) {
-            CLog.d(
-                    "On-device build (id = %s) isn't matching the cache (id = %s).",
-                    deviceBuildId, tracker.buildId);
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_IMAGE_CACHE_MISMATCH, 1);
-            return null;
-        }
-        if (!tracker.branch.equals(build.getBuildBranch())) {
-            if (applySnapshot
-                    && wipeAfterApply
-                    && allowedTransition.contains(tracker.branch)
-                    && allowedTransition.contains(build.getBuildBranch())) {
-                CLog.d("Allowing transition from %s => %s", tracker.branch, build.getBuildBranch());
-            } else {
-                CLog.d("Newer build is not on the same branch.");
+        } else {
+            if (tracker.branch.contains("release")) {
+                CLog.d("Skipping incremental flashing for release builds origin.");
                 return null;
             }
-        }
-        boolean crossRelease = false;
-        if (!tracker.flavor.equals(build.getBuildFlavor())) {
-            if (allowCrossRelease) {
+            if (!tracker.branch.equals(build.getBuildBranch())) {
+                if (allowedTransition.contains(tracker.branch)
+                        && allowedTransition.contains(build.getBuildBranch())) {
+                    CLog.d(
+                            "Allowing transition from %s => %s",
+                            tracker.branch, build.getBuildBranch());
+                } else {
+                    CLog.d("Newer build is not on the same branch.");
+                    return null;
+                }
+            }
+            if (!tracker.flavor.equals(build.getBuildFlavor())) {
                 CLog.d(
                         "Allowing cross-flavor update from '%s' to '%s'",
                         tracker.flavor, build.getBuildFlavor());
                 crossRelease = true;
-            } else {
-                CLog.d("Newer build is not on the build flavor.");
-                return null;
             }
         }
-
-        if (!isSnapshotSupported(device, applySnapshot)) {
+        if (!isSnapshotSupported(device, useMerkleTree)) {
             CLog.d("Incremental flashing not supported.");
             return null;
         }
-
-        String splTarget = getSplVersion(build);
-        String splBaseline = device.getProperty("ro.build.version.security_patch");
-        // When we wipe, do not consider security_patch
-        if (!wipeAfterApply) {
-            if (splTarget != null && !splBaseline.equals(splTarget)) {
-                CLog.d("Target SPL is '%s', while baseline is '%s", splTarget, splBaseline);
-                return null;
-            }
-        }
         if (crossRelease) {
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.INCREMENTAL_ACROSS_RELEASE_COUNT, 1);
         }
 
-        File deviceImage = null;
-        File bootloader = null;
-        File baseband = null;
-        try {
-            deviceImage = copyImage(tracker.zippedDeviceImage);
-            bootloader = copyImage(tracker.zippedBootloaderImage);
-            if (tracker.zippedBasebandImage != null) {
-                baseband = copyImage(tracker.zippedBasebandImage);
-            }
-        } catch (IOException e) {
+        if (tracker != null) {
             InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_IMAGE_CACHE_MISMATCH, 1);
-            CLog.e(e);
-            FileUtil.recursiveDelete(deviceImage);
-            FileUtil.deleteFile(bootloader);
-            FileUtil.deleteFile(baseband);
-            return null;
+                    InvocationMetricKey.DEVICE_IMAGE_CACHE_ORIGIN,
+                    String.format("%s:%s:%s", tracker.branch, tracker.buildId, tracker.flavor));
+        } else {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.DEVICE_IMAGE_CACHE_ORIGIN, "no baseline");
+        }
+        File merkleTreeDir = null;
+        if (useMerkleTree) {
+            device.executeShellV2Command("mkdir -p /data/verity-hash/");
+            CommandResult merkleDump =
+                    device.executeShellV2Command("snapshotctl dump-verity-hash /data/verity-hash/");
+            if (CommandStatus.SUCCESS.equals(merkleDump.getStatus())) {
+                try {
+                    merkleTreeDir =
+                            FileUtil.createTempDir(
+                                    "device-merkle-tree", CurrentInvocation.getWorkFolder());
+                    boolean res = device.pullDir("/data/verity-hash/", merkleTreeDir);
+                    if (!res) {
+                        CLog.w("Failed to pull merkle tree");
+                        FileUtil.recursiveDelete(merkleTreeDir);
+                        merkleTreeDir = null;
+                    }
+                } catch (IOException e) {
+                    CLog.e(e);
+                    FileUtil.recursiveDelete(merkleTreeDir);
+                    merkleTreeDir = null;
+                }
+            }
         }
-        InvocationMetricLogger.addInvocationMetrics(
-                InvocationMetricKey.DEVICE_IMAGE_CACHE_ORIGIN,
-                String.format("%s:%s:%s", tracker.branch, tracker.buildId, tracker.flavor));
         return new IncrementalImageUtil(
                 device,
-                deviceImage,
-                bootloader,
-                baseband,
                 build.getDeviceImageFile(),
                 createSnapshot,
-                applySnapshot,
-                wipeAfterApply,
                 newFlow,
                 updateBootloaderFromUserspace,
-                waitPhase);
+                waitPhase,
+                merkleTreeDir);
     }
 
     public IncrementalImageUtil(
             ITestDevice device,
-            File deviceImage,
-            File bootloader,
-            File baseband,
             File targetImage,
             File createSnapshot,
-            boolean applySnapshot,
-            boolean wipeAfterApply,
             boolean newFlow,
             boolean updateBootloaderFromUserspace,
-            SnapuserdWaitPhase waitPhase) {
+            SnapuserdWaitPhase waitPhase,
+            File deviceMerkleTree) {
         mDevice = device;
-        mSrcImage = deviceImage;
-        mSrcBootloader = bootloader;
-        mSrcBaseband = baseband;
-        mApplySnapshot = applySnapshot;
-        mWipeAfterApplySnapshot = wipeAfterApply;
+        mApplySnapshot = true;
+        mWipeAfterApplySnapshot = true;
         mNewFlow = newFlow;
         mUpdateBootloaderFromUserspace = updateBootloaderFromUserspace;
         mWaitPhase = waitPhase;
@@ -264,7 +234,9 @@ public class IncrementalImageUtil {
         }
         mParallelSetup =
                 new ParallelPreparation(
-                        Thread.currentThread().getThreadGroup(), mSrcImage, mTargetImage);
+                        Thread.currentThread().getThreadGroup(),
+                        mTargetImage,
+                        deviceMerkleTree);
         mParallelSetup.start();
     }
 
@@ -290,7 +262,7 @@ public class IncrementalImageUtil {
     }
 
     /** Returns whether or not we can use the snapshot logic to update the device */
-    public static boolean isSnapshotSupported(ITestDevice device, boolean applySnapshot)
+    public static boolean isSnapshotSupported(ITestDevice device, boolean useMerkle)
             throws DeviceNotAvailableException {
         // Ensure snapshotctl exists
         CommandResult whichOutput = device.executeShellV2Command("which snapshotctl");
@@ -300,17 +272,16 @@ public class IncrementalImageUtil {
         }
         CommandResult helpOutput = device.executeShellV2Command("snapshotctl");
         CLog.d("stdout: %s, stderr: %s", helpOutput.getStdout(), helpOutput.getStderr());
-        if (applySnapshot) {
-            if (helpOutput.getStdout().contains("apply-update")
-                    || helpOutput.getStderr().contains("apply-update")) {
-                return true;
-            }
-        } else {
-            if (helpOutput.getStdout().contains("map-snapshots")
-                    || helpOutput.getStderr().contains("map-snapshots")) {
-                return true;
+        if (useMerkle) {
+            if (!helpOutput.getStdout().contains("dump-verity-hash")
+                    && !helpOutput.getStderr().contains("dump-verity-hash")) {
+                return false;
             }
         }
+        if (helpOutput.getStdout().contains("apply-update")
+                || helpOutput.getStderr().contains("apply-update")) {
+            return true;
+        }
         return false;
     }
 
@@ -364,6 +335,7 @@ public class IncrementalImageUtil {
         if (mUpdateBootloaderFromUserspace) {
             updateBootloaderFromUserspace(currentBootloader);
         }
+        CLog.d("Updating with new incremental flow.");
         updateDevice(currentBootloader, currentRadio);
     }
 
@@ -570,40 +542,24 @@ public class IncrementalImageUtil {
 
             CommandResult listSnapshots = mDevice.executeShellV2Command("ls -l /data/ndb/");
             CLog.d("stdout: %s, stderr: %s", listSnapshots.getStdout(), listSnapshots.getStderr());
-
-            if (mApplySnapshot) {
-                String applyCommand = "snapshotctl apply-update /data/ndb/";
-                if (mWipeAfterApplySnapshot) {
-                    applyCommand += " -w";
-                }
-                CommandResult mapOutput = mDevice.executeShellV2Command(applyCommand);
-                CLog.d("stdout: %s, stderr: %s", mapOutput.getStdout(), mapOutput.getStderr());
-                if (!CommandStatus.SUCCESS.equals(mapOutput.getStatus())) {
-                    InvocationMetricLogger.addInvocationMetrics(
-                            InvocationMetricKey.INCREMENTAL_FALLBACK_REASON, "Failed apply-update");
-                    // Clean state if apply-update fails
-                    mDevice.executeShellV2Command("snapshotctl unmap-snapshots");
-                    mDevice.executeShellV2Command("snapshotctl delete-snapshots");
-                    throw new TargetSetupError(
-                            String.format(
-                                    "Failed to apply-update.\nstdout:%s\nstderr:%s",
-                                    mapOutput.getStdout(), mapOutput.getStderr()),
-                            InfraErrorIdentifier.INCREMENTAL_FLASHING_ERROR);
-                }
-            } else {
-                CommandResult mapOutput =
-                        mDevice.executeShellV2Command("snapshotctl map-snapshots /data/ndb/");
-                CLog.d("stdout: %s, stderr: %s", mapOutput.getStdout(), mapOutput.getStderr());
-                if (!CommandStatus.SUCCESS.equals(mapOutput.getStatus())) {
-                    InvocationMetricLogger.addInvocationMetrics(
-                            InvocationMetricKey.INCREMENTAL_FALLBACK_REASON,
-                            "Failed map-snapshots");
-                    throw new TargetSetupError(
-                            String.format(
-                                    "Failed to map the snapshots.\nstdout:%s\nstderr:%s",
-                                    mapOutput.getStdout(), mapOutput.getStderr()),
-                            InfraErrorIdentifier.INCREMENTAL_FLASHING_ERROR);
-                }
+            mDevice.logOnDevice("Tradefed", LogLevel.DEBUG, "Running snapshotctl apply-update");
+            String applyCommand = "snapshotctl apply-update /data/ndb/";
+            if (mWipeAfterApplySnapshot) {
+                applyCommand += " -w";
+            }
+            CommandResult mapOutput = mDevice.executeShellV2Command(applyCommand);
+            CLog.d("stdout: %s, stderr: %s", mapOutput.getStdout(), mapOutput.getStderr());
+            if (!CommandStatus.SUCCESS.equals(mapOutput.getStatus())) {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.INCREMENTAL_FALLBACK_REASON, "Failed apply-update");
+                // Clean state if apply-update fails
+                mDevice.executeShellV2Command("snapshotctl unmap-snapshots");
+                mDevice.executeShellV2Command("snapshotctl delete-snapshots");
+                throw new TargetSetupError(
+                        String.format(
+                                "Failed to apply-update.\nstdout:%s\nstderr:%s",
+                                mapOutput.getStdout(), mapOutput.getStderr()),
+                        InfraErrorIdentifier.INCREMENTAL_FLASHING_ERROR);
             }
             try {
                 if (mNewFlow && mDevice instanceof TestDevice) {
@@ -675,9 +631,6 @@ public class IncrementalImageUtil {
         // Delete the copy we made to use the incremental update
         FileUtil.recursiveDelete(mSourceDirectory);
         FileUtil.recursiveDelete(mTargetDirectory);
-        FileUtil.recursiveDelete(mSrcImage);
-        FileUtil.deleteFile(mSrcBootloader);
-        FileUtil.deleteFile(mSrcBaseband);
         // In case of same build flashing, we should clean the setup operation
         if (mParallelSetup != null) {
             try {
@@ -693,73 +646,17 @@ public class IncrementalImageUtil {
      * Returns the device to its original state.
      */
     public void teardownDevice(TestInformation testInfo) throws DeviceNotAvailableException {
-        try {
-            if (mApplySnapshot) {
-                return;
-            }
-            try (CloseableTraceScope ignored = new CloseableTraceScope("teardownDevice")) {
-                revertBootloaderAndBasebandifNeeded(mSrcBootloader, mSrcBaseband);
-                if (mDevice.isStateBootloaderOrFastbootd()) {
-                    mDevice.reboot();
-                }
-                mDevice.enableAdbRoot();
-                CommandResult revertOutput =
-                        mDevice.executeShellV2Command(
-                                "snapshotctl revert-snapshots", 60L, TimeUnit.SECONDS, 0);
-                if (!CommandStatus.SUCCESS.equals(revertOutput.getStatus())) {
-                    String failedMessage =
-                            String.format(
-                                    "Failed revert-snapshots. stdout: %s, stderr: %s",
-                                    revertOutput.getStdout(), revertOutput.getStderr());
-                    CLog.d(failedMessage);
-                    InvocationMetricLogger.addInvocationMetrics(
-                            InvocationMetricKey.INCREMENTAL_FLASHING_TEARDOWN_FAILURE, 1);
-                    // Invalidate the device since it failed the revert
-                    throw new DeviceDisconnectedException(failedMessage, mDevice.getSerialNumber());
-                }
-                if (mSourceDirectory != null) {
-                    // flash all static partition in bootloader
-                    mDevice.rebootIntoBootloader();
-                    try {
-                        flashStaticPartition(mSourceDirectory);
-                    } catch (TargetSetupError e) {
-                        CLog.e(e);
-                        throw new DeviceDisconnectedException(
-                                e.getMessage(), e, mDevice.getSerialNumber());
-                    }
-                }
-                if (mSourceDirectory != null && mAllowUnzipBaseline) {
-                    DeviceImageTracker.getDefaultCache()
-                            .trackUpdatedDeviceImage(
-                                    mDevice.getSerialNumber(),
-                                    mSourceDirectory,
-                                    mSrcBootloader,
-                                    mSrcBaseband,
-                                    testInfo.getBuildInfo().getBuildId(),
-                                    testInfo.getBuildInfo().getBuildBranch(),
-                                    testInfo.getBuildInfo().getBuildFlavor());
-                }
-            } catch (DeviceNotAvailableException e) {
-                InvocationMetricLogger.addInvocationMetrics(
-                        InvocationMetricKey.INCREMENTAL_FLASHING_TEARDOWN_FAILURE, 1);
-                throw e;
-            }
-        } finally {
-            // Delete the copy we made to use the incremental update
-            FileUtil.recursiveDelete(mSourceDirectory);
-            FileUtil.recursiveDelete(mTargetDirectory);
-            FileUtil.recursiveDelete(mSrcImage);
-            FileUtil.deleteFile(mSrcBootloader);
-            FileUtil.deleteFile(mSrcBaseband);
-            // In case of same build flashing, we should clean the setup operation
-            if (mParallelSetup != null) {
-                try {
-                    mParallelSetup.join();
-                } catch (InterruptedException e) {
-                    CLog.e(e);
-                }
-                mParallelSetup.cleanUpFiles();
+        // Delete the copy we made to use the incremental update
+        FileUtil.recursiveDelete(mSourceDirectory);
+        FileUtil.recursiveDelete(mTargetDirectory);
+        // In case of same build flashing, we should clean the setup operation
+        if (mParallelSetup != null) {
+            try {
+                mParallelSetup.join();
+            } catch (InterruptedException e) {
+                CLog.e(e);
             }
+            mParallelSetup.cleanUpFiles();
         }
     }
 
@@ -827,7 +724,7 @@ public class IncrementalImageUtil {
         }
     }
 
-    private void blockCompare(File srcImage, File targetImage, File workDir) {
+    private void blockCompare(File srcImage, File srcMerkleTree, File targetImage, File workDir) {
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope("block_compare:" + srcImage.getName())) {
             mRunUtil.setWorkingDir(workDir);
@@ -836,12 +733,25 @@ public class IncrementalImageUtil {
             if (mCreateSnapshotBinary != null && mCreateSnapshotBinary.exists()) {
                 createSnapshot = mCreateSnapshotBinary.getAbsolutePath();
             }
-            CommandResult result =
-                    mRunUtil.runTimedCmd(
-                            0L,
+            String[] command = null;
+            if (srcMerkleTree.exists()) {
+                command =
+                        new String[] {
+                            createSnapshot,
+                            "--source=" + srcMerkleTree.getAbsolutePath(),
+                            "--target=" + targetImage.getAbsolutePath(),
+                            "--merkel_tree"
+                        };
+            } else {
+                command =
+                        new String[] {
                             createSnapshot,
                             "--source=" + srcImage.getAbsolutePath(),
-                            "--target=" + targetImage.getAbsolutePath());
+                            "--target=" + targetImage.getAbsolutePath()
+                        };
+            }
+
+            CommandResult result = mRunUtil.runTimedCmd(0L, command);
             if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
                 throw new RuntimeException(
                         String.format("%s\n%s", result.getStdout(), result.getStderr()));
@@ -853,6 +763,11 @@ public class IncrementalImageUtil {
 
     private boolean flashStaticPartition(File imageDirectory)
             throws DeviceNotAvailableException, TargetSetupError {
+        // Invalidate properties to be updated after reboot into the new
+        // image.
+        if (mDevice instanceof NativeDevice) {
+            ((NativeDevice) mDevice).invalidatePropertyCache();
+        }
         Map<String, String> envMap = new HashMap<>();
         envMap.put("ANDROID_PRODUCT_OUT", imageDirectory.getAbsolutePath());
         CommandResult fastbootResult =
@@ -873,25 +788,18 @@ public class IncrementalImageUtil {
             ((IManagedTestDevice) mDevice).getMonitor().attachFinalState(TestDeviceState.RECOVERY);
             boolean available = mDevice.waitForDeviceAvailable(5 * 60 * 1000L);
             if (!available) {
-                if (mApplySnapshot) {
-                    if (TestDeviceState.RECOVERY.equals(mDevice.getDeviceState())) {
-                        InvocationMetricLogger.addInvocationMetrics(
-                                InvocationMetricKey.INCREMENTAL_RECOVERY_FALLBACK, 1);
-                        // Go back to bootloader for fallback flashing
-                        mDevice.rebootIntoBootloader();
-                        CommandResult result = mDevice.executeFastbootCommand("-w");
-                        CLog.d("wipe status: %s", result.getStatus());
-                        CLog.d("wipe stdout: %s", result.getStdout());
-                        CLog.d("wipe stderr: %s", result.getStderr());
-                        throw new TargetSetupError(
-                                "Device went to recovery unexpectedly",
-                                DeviceErrorIdentifier.DEVICE_UNEXPECTED_RESPONSE);
-                    }
-                } else {
-                    throw new DeviceNotAvailableException(
-                            "device did not become available after flashing.",
-                            mDevice.getSerialNumber(),
-                            DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
+                if (TestDeviceState.RECOVERY.equals(mDevice.getDeviceState())) {
+                    InvocationMetricLogger.addInvocationMetrics(
+                            InvocationMetricKey.INCREMENTAL_RECOVERY_FALLBACK, 1);
+                    // Go back to bootloader for fallback flashing
+                    mDevice.rebootIntoBootloader();
+                    CommandResult result = mDevice.executeFastbootCommand("-w");
+                    CLog.d("wipe status: %s", result.getStatus());
+                    CLog.d("wipe stdout: %s", result.getStdout());
+                    CLog.d("wipe stderr: %s", result.getStderr());
+                    throw new TargetSetupError(
+                            "Device went to recovery unexpectedly",
+                            DeviceErrorIdentifier.DEVICE_UNEXPECTED_RESPONSE);
                 }
             }
         } finally {
@@ -978,7 +886,7 @@ public class IncrementalImageUtil {
 
     private class ParallelPreparation extends Thread {
 
-        private final File mSetupSrcImage;
+        private final File mDeviceOriginMerkleTree;
         private final File mSetupTargetImage;
 
         private File mSrcDirectory;
@@ -986,10 +894,11 @@ public class IncrementalImageUtil {
         private File mWorkDir;
         private TargetSetupError mError;
 
-        public ParallelPreparation(ThreadGroup currentGroup, File srcImage, File targetImage) {
+        public ParallelPreparation(
+                ThreadGroup currentGroup, File targetImage, File deviceMerkleTree) {
             super(currentGroup, "incremental-flashing-preparation");
             setDaemon(true);
-            this.mSetupSrcImage = srcImage;
+            this.mDeviceOriginMerkleTree = deviceMerkleTree;
             this.mSetupTargetImage = targetImage;
         }
 
@@ -1010,37 +919,23 @@ public class IncrementalImageUtil {
                         }
                     };
             try (CloseableTraceScope ignored = new CloseableTraceScope("unzip_device_images")) {
-                mSrcDirectory = FileUtil.createTempDir("incremental_src");
+                mSrcDirectory = mDeviceOriginMerkleTree;
                 mTargetDirectory = FileUtil.createTempDir("incremental_target");
-                Future<Boolean> futureSrcDir =
+                Future<Boolean> futureTargetDir =
                         CompletableFuture.supplyAsync(
                                 () -> {
-                                    try (CloseableTraceScope unzipBaseline =
-                                            new CloseableTraceScope("unzip_baseline")) {
-                                        if (mSetupSrcImage.isDirectory()) {
+                                    if (mSetupTargetImage.isDirectory()) {
+                                        try (CloseableTraceScope unzipTarget =
+                                                new CloseableTraceScope("hardlink_target")) {
                                             FileUtil.recursiveHardlink(
-                                                    mSetupSrcImage, mSrcDirectory);
+                                                    mSetupTargetImage, mTargetDirectory);
                                             return true;
+                                        } catch (IOException ioe) {
+                                            throw new RuntimeException(ioe);
                                         }
-
-                                        ZipUtil2.extractZip(mSetupSrcImage, mSrcDirectory);
-                                        return true;
-                                    } catch (IOException ioe) {
-                                        throw new RuntimeException(ioe);
                                     }
-                                },
-                                TracePropagatingExecutorService.create(
-                                        Executors.newFixedThreadPool(1, factory)));
-                Future<Boolean> futureTargetDir =
-                        CompletableFuture.supplyAsync(
-                                () -> {
                                     try (CloseableTraceScope unzipTarget =
                                             new CloseableTraceScope("unzip_target")) {
-                                        if (mSetupTargetImage.isDirectory()) {
-                                            FileUtil.recursiveHardlink(
-                                                    mSetupTargetImage, mTargetDirectory);
-                                            return true;
-                                        }
                                         ZipUtil2.extractZip(mSetupTargetImage, mTargetDirectory);
                                         return true;
                                     } catch (IOException ioe) {
@@ -1050,7 +945,6 @@ public class IncrementalImageUtil {
                                 TracePropagatingExecutorService.create(
                                         Executors.newFixedThreadPool(1, factory)));
                 // Join the unzipping
-                futureSrcDir.get();
                 futureTargetDir.get();
             } catch (InterruptedException | IOException | ExecutionException e) {
                 FileUtil.recursiveDelete(mSrcDirectory);
@@ -1079,14 +973,23 @@ public class IncrementalImageUtil {
 
             List<Callable<Boolean>> callableTasks = new ArrayList<>();
             for (String partition : mSrcDirectory.list()) {
+                String merklePartition = partition.replaceAll(".img", ".pb");
+                partition = partition.replaceAll(".pb", ".img");
+
                 File possibleSrc = new File(mSrcDirectory, partition);
+                File sourceMerkleTree = new File(mDeviceOriginMerkleTree, merklePartition);
                 File possibleTarget = new File(mTargetDirectory, partition);
                 File workDirectory = mWorkDir;
-                if (possibleSrc.exists() && possibleTarget.exists()) {
+                if ((possibleSrc.exists() || sourceMerkleTree.exists())
+                        && possibleTarget.exists()) {
                     if (DYNAMIC_PARTITIONS_TO_DIFF.contains(partition)) {
                         callableTasks.add(
                                 () -> {
-                                    blockCompare(possibleSrc, possibleTarget, workDirectory);
+                                    blockCompare(
+                                            possibleSrc,
+                                            sourceMerkleTree,
+                                            possibleTarget,
+                                            workDirectory);
                                     return true;
                                 });
                     }
diff --git a/src/com/android/tradefed/util/testmapping/TestMapping.java b/src/com/android/tradefed/util/testmapping/TestMapping.java
index 818fa17af..88ef9b7cd 100644
--- a/src/com/android/tradefed/util/testmapping/TestMapping.java
+++ b/src/com/android/tradefed/util/testmapping/TestMapping.java
@@ -530,6 +530,12 @@ public class TestMapping {
                     String.format(
                             "IO exception (%s) when reading tests from TEST_MAPPING files (%s)",
                             e.getMessage(), testMappingsDir.getAbsolutePath()), e);
+        } catch (NoTestRuntimeException e) {
+            if (System.getenv("ALLOW_EMPTY_TEST_MAPPING") == null) {
+                throw e;
+            } else {
+                CLog.d("Allowing empty test info lists.");
+            }
         } finally {
             if (delete) {
                 FileUtil.recursiveDelete(testMappingsDir);
@@ -564,7 +570,7 @@ public class TestMapping {
             }
         }
         if (allTestMappingPaths.isEmpty()) {
-            throw new RuntimeException(
+            throw new NoTestRuntimeException(
                     String.format(
                             "Couldn't find TEST_MAPPING files from %s", mTestMappingRelativePaths));
         }
@@ -572,6 +578,13 @@ public class TestMapping {
         return allTestMappingPaths;
     }
 
+    public class NoTestRuntimeException extends RuntimeException {
+
+        public NoTestRuntimeException(String message) {
+            super(message);
+        }
+    }
+
     /**
      * Helper to find all tests in the TEST_MAPPING files from a given directory.
      *
diff --git a/test_framework/Android.bp b/test_framework/Android.bp
index 1aee02151..182f72b5b 100644
--- a/test_framework/Android.bp
+++ b/test_framework/Android.bp
@@ -28,6 +28,7 @@ tradefed_java_library_host {
     static_libs: [
         "diffutils-prebuilt-jar",
         "perfetto_metrics-full",
+        "trace_summary-full",
         "test-composers",
         "truth",
         "grpc-java-api",
diff --git a/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java b/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
index 68354225c..f12910d49 100644
--- a/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
+++ b/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
@@ -67,6 +67,8 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
     private static final String PROCESSOR_RUNTIME = "trace_processor_runtime";
     private static final String RAW_TRACE_FILE_SIZE = "perfetto_trace_file_size_bytes";
     private static final String NSS_CACHE_ERROR = "base/nsscache-inl.h failed to lookup";
+    private static final String METRIC_VERSION_V1 = "v1";
+    private static final String METRIC_VERSION_V2 = "v2";
 
     public enum METRIC_FILE_FORMAT {
         text,
@@ -165,10 +167,21 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
                     + " or module artifacts.")
     private String mTraceProcessorName = "trace_processor_shell";
 
+    @Option(
+            name = "perfetto-v1-metrics",
+            description = "This flag is to control the metric v1 computation.")
+    private boolean mMetricV1 = true;
+
+    @Option(
+            name = "perfetto-v2-metrics",
+            description = "This flag is to control the metric v2 computation.")
+    private boolean mMetricV2 = false;
+
     @Option(
             name = "trace-processor-run-metrics",
-            description = "Comma separated list of metrics to extract from raw trace file."
-                    + " For example android_mem.")
+            description =
+                    "Comma separated list of metrics to extract from raw trace file."
+                            + " For example android_mem.")
     private String mTraceProcessorMetrics = "android_mem";
 
     @Option(
@@ -182,6 +195,29 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
             isTimeVal = true)
     private long mTraceConversionTimeout = TimeUnit.MINUTES.toMillis(20);
 
+    @Option(
+            name = "perfetto-v2-metrics-ids",
+            description =
+                    "Specifies that the given v2 metrics (as defined by a comma separated set of"
+                        + " ids) should be computed and returned as part of the trace summary. The"
+                        + " spec for every metric must exist in one of the files passed to"
+                        + " --summary-spec.")
+    private String mComputeMetricsV2Ids = "memory_per_process-avg_rss_and_swap";
+
+    @Option(name = "summary-spec-files", description = "Summary spec files abusolutle paths.")
+    private List<File> mSummarySpecFiles = new ArrayList<File>();
+
+    @Option(
+            name = "summary-spec-file-name",
+            description =
+                    "Parses the spec at the specified path and makes it available to other"
+                        + " summarization operators (--summary-metrics-v2). Spec files must be"
+                        + " instances of the perfetto.protos.TraceSummarySpec proto. If the file"
+                        + " extension is `.textproto` then the spec file will be parsed as a"
+                        + " textproto. If the file extension is `.pb` then it will be parsed as a"
+                        + " binary protobuf. Otherwise, heureustics will be used to determine the"
+                        + " format.")
+    private String mSummarySpecFileName = "memory_per_process-avg_rss_and_swap.textproto";
 
     /**
      * Process the perfetto trace file for the additional metrics and add it to final metrics.
@@ -192,8 +228,7 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
      * @param data where metrics will be stored.
      */
     @Override
-    public void processMetricFile(String key, File metricFile,
-            DeviceMetricData data) {
+    public void processMetricFile(String key, File metricFile, DeviceMetricData data) {
         File processSrcFile = metricFile;
         if (mCompressPerfetto) {
             processSrcFile = decompressFile(metricFile);
@@ -210,28 +245,14 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
 
         // Convert to perfetto metric format.
         if (mConvertToMetricFile) {
-            TraceProcessorResult result = convertToMetricProto(processSrcFile);
-            File convertedMetricFile = result.file;
-            if (convertedMetricFile != null) {
-                try (InputStreamSource source = new FileInputStreamSource(convertedMetricFile,
-                        true)) {
-                    testLog(convertedMetricFile.getName(), getLogDataType(), source);
-                }
+            if (mMetricV1) {
+                wrapConvertedMetricFile(
+                        convertToMetricProto(processSrcFile, METRIC_VERSION_V1), data);
+            }
+            if (mMetricV2) {
+                wrapConvertedMetricFile(
+                        convertToMetricProto(processSrcFile, METRIC_VERSION_V2), data);
             }
-
-            Metric.Builder processorRuntimeBuilder = Metric.newBuilder();
-            processorRuntimeBuilder
-                    .getMeasurementsBuilder()
-                    .setSingleDouble((double) result.runtime);
-            data.addMetric(
-                    String.format("%s_%s", mMetricPrefix, PROCESSOR_RUNTIME),
-                    processorRuntimeBuilder.setType(DataType.RAW));
-
-            Metric.Builder processorStatusBuilder = Metric.newBuilder();
-            processorStatusBuilder.getMeasurementsBuilder().setSingleString(result.status);
-            data.addMetric(
-                    String.format("%s_%s", mMetricPrefix, PROCESSOR_STATUS),
-                    processorStatusBuilder.setType(DataType.RAW));
         }
 
         if (processSrcFile != null) {
@@ -348,9 +369,11 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
      * Converts the raw trace file into perfetto metric file.
      *
      * @param perfettoRawTraceFile Raw perfetto trace file that needs to be converted.
+     * @param metricVersion The version of the metric fileto be generated.
      * @return The result of the conversion.
      */
-    private TraceProcessorResult convertToMetricProto(File perfettoRawTraceFile) {
+    private TraceProcessorResult convertToMetricProto(
+            File perfettoRawTraceFile, String metricVersion) {
 
         // Use absolute path to the trace file if it is available otherwise
         // resolve the trace processor name from the test or module artifacts.
@@ -359,6 +382,7 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
         }
 
         File metricOutputFile = null;
+        String metricOutputFilePrefix = "";
         long runtime = -1L;
 
         if (mTraceProcessorBinary == null) {
@@ -370,18 +394,56 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
         List<String> commandArgsList = new ArrayList<String>();
         commandArgsList.add(mTraceProcessorBinary.getAbsolutePath());
 
-        // Comma separated list of metrics to extract.
-        if (!mTraceProcessorMetrics.isEmpty()) {
-            commandArgsList.add("--run-metrics");
-            commandArgsList.add(mTraceProcessorMetrics);
+        if (metricVersion.contains(METRIC_VERSION_V1)) {
+            metricOutputFilePrefix = "metric_";
+
+            // Comma separated list of metrics to extract.
+            if (!mTraceProcessorMetrics.isEmpty()) {
+                commandArgsList.add("--run-metrics");
+                commandArgsList.add(mTraceProcessorMetrics);
+            }
+        }
+
+        if (metricVersion.contains(METRIC_VERSION_V2)) {
+            metricOutputFilePrefix = "metric_v2_";
+            // Turn on the summary metrics v2 flag.
+            commandArgsList.add("--summary");
+
+            // Comma separated list of metrics ids to extract.
+            if (!mComputeMetricsV2Ids.isEmpty()) {
+                commandArgsList.add("--summary-metrics-v2");
+                commandArgsList.add(mComputeMetricsV2Ids);
+            }
+
+            // resolve the summary spec names from the test or module artifacts.
+            if (mSummarySpecFiles.isEmpty() && !mSummarySpecFileName.isEmpty()) {
+                String[] FileNames = mSummarySpecFileName.split(",");
+                for (String name : FileNames) {
+                    mSummarySpecFiles.add(getFileFromTestArtifacts(name));
+                }
+            }
+
+            if (mSummarySpecFiles.isEmpty()) {
+                CLog.e("Failed to locate the summary spec file.");
+                return new TraceProcessorResult(metricOutputFile, runtime, STATUS_FAILURE);
+            }
+
+            for (File summarySpecFile : mSummarySpecFiles) {
+                commandArgsList.add("--summary-spec");
+                commandArgsList.add(summarySpecFile.getAbsolutePath());
+            }
         }
+
         // Metric file output format.
         commandArgsList.add("--metrics-output=" + mTraceProcessorOutputFormat);
         commandArgsList.add(perfettoRawTraceFile.getAbsolutePath());
 
         try {
-            metricOutputFile = FileUtil.createTempFile(
-                    "metric_" + getRawTraceFileName(perfettoRawTraceFile.getName()), "");
+            metricOutputFile =
+                    FileUtil.createTempFile(
+                            metricOutputFilePrefix
+                                    + getRawTraceFileName(perfettoRawTraceFile.getName()),
+                            "");
         } catch (IOException e) {
             CLog.e("Not able to create metric perfetto output file.");
             CLog.e(e);
@@ -394,25 +456,29 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
         try (FileOutputStream outStream = new FileOutputStream(metricOutputFile);
                 ByteArrayOutputStream errStream = new ByteArrayOutputStream()) {
             long startTime = System.currentTimeMillis();
-            CommandResult conversionResult = runHostCommand(mTraceConversionTimeout,
-                    commandArgsList.toArray(new String[commandArgsList
-                            .size()]),
-                    outStream, errStream);
+            CommandResult conversionResult =
+                    runHostCommand(
+                            mTraceConversionTimeout,
+                            commandArgsList.toArray(new String[commandArgsList.size()]),
+                            outStream,
+                            errStream);
             runtime = System.currentTimeMillis() - startTime;
             if (!CommandStatus.SUCCESS.equals(conversionResult.getStatus())) {
-                CLog.e("Unable to convert the raw trace - %s to metric file due to"
-                        + " %s - Status - %s ", perfettoRawTraceFile.getName(),
-                        errStream.toString(), conversionResult.getStatus());
+                CLog.e(
+                        "Unable to convert the raw trace - %s to metric file due to"
+                                + " %s - Status - %s ",
+                        perfettoRawTraceFile.getName(),
+                        errStream.toString(),
+                        conversionResult.getStatus());
                 isConversionSuccess = false;
-            } else if (mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.text) ||
-                    mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.json)) {
+            } else if (mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.text)
+                    || mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.json)) {
                 File compressedFile = getCompressedFile(metricOutputFile);
                 metricOutputFile.delete();
                 return new TraceProcessorResult(compressedFile, runtime, STATUS_SUCCESS);
             }
         } catch (FileNotFoundException e) {
-            CLog.e("Not able to find the result metric file to write the "
-                    + "metric output.");
+            CLog.e("Not able to find the result metric file to write the " + "metric output.");
             CLog.e(e);
             isConversionSuccess = false;
         } catch (IOException e1) {
@@ -428,6 +494,33 @@ public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollect
         return new TraceProcessorResult(metricOutputFile, runtime, STATUS_SUCCESS);
     }
 
+    /**
+     * Wraps the converted metric file into test artifacts.
+     *
+     * @param result TraceProcessorResult
+     * @return void.
+     */
+    private void wrapConvertedMetricFile(TraceProcessorResult result, DeviceMetricData data) {
+        File convertedMetricFile = result.file;
+        if (convertedMetricFile != null) {
+            try (InputStreamSource source = new FileInputStreamSource(convertedMetricFile, true)) {
+                testLog(convertedMetricFile.getName(), getLogDataType(), source);
+            }
+        }
+
+        Metric.Builder processorRuntimeBuilder = Metric.newBuilder();
+        processorRuntimeBuilder.getMeasurementsBuilder().setSingleDouble((double) result.runtime);
+        data.addMetric(
+                String.format("%s_%s", mMetricPrefix, PROCESSOR_RUNTIME),
+                processorRuntimeBuilder.setType(DataType.RAW));
+
+        Metric.Builder processorStatusBuilder = Metric.newBuilder();
+        processorStatusBuilder.getMeasurementsBuilder().setSingleString(result.status);
+        data.addMetric(
+                String.format("%s_%s", mMetricPrefix, PROCESSOR_STATUS),
+                processorStatusBuilder.setType(DataType.RAW));
+    }
+
     /**
      * Pull the file from the specified path in the device. Pull the compressed content of the
      * perfetto file if the compress perfetto option is enabled.
diff --git a/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java b/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
index 41843a820..0ef0ec633 100644
--- a/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
+++ b/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
@@ -59,6 +59,10 @@ import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 import perfetto.protos.PerfettoMergedMetrics.TraceMetrics;
+import perfetto.protos.File.TraceSummary;
+import perfetto.protos.V2Metric.TraceMetricV2;
+import perfetto.protos.V2Metric.TraceMetricV2.MetricRow;
+import perfetto.protos.V2Metric.TraceMetricV2.MetricRow.Dimension;
 
 /**
  * A post processor that processes text/binary metric perfetto proto file into key-value pairs by
@@ -70,6 +74,7 @@ import perfetto.protos.PerfettoMergedMetrics.TraceMetrics;
  * keys. For example
  *
  * <p>"perfetto-indexed-list-field" - perfetto.protos.AndroidStartupMetric.Startup
+ *
  * <p>"perfetto-prefix-key-field" - perfetto.protos.ProcessRenderInfo.process_name
  *
  * <p>android_startup-startup#1-package_name-com.calculator-to_first_frame-dur_ns: 300620342
@@ -79,6 +84,8 @@ import perfetto.protos.PerfettoMergedMetrics.TraceMetrics;
 @OptionClass(alias = "perfetto-generic-processor")
 public class PerfettoGenericPostProcessor extends BasePostProcessor {
 
+    private static final TextFormat.Parser ALLOW_UNKNOWN_FIELD =
+            TextFormat.Parser.newBuilder().setAllowUnknownFields(true).build();
     private static final String METRIC_SEP = "-";
     @VisibleForTesting static final String RUNTIME_METRIC_KEY = "perfetto_post_processor_runtime";
 
@@ -105,14 +112,16 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
 
     @Option(
             name = "perfetto-prefix-key-field",
-            description = "String value field need to be prefixed with the all the other"
-                    + "numeric value field keys in the proto message.")
+            description =
+                    "String value field need to be prefixed with the all the other"
+                            + "numeric value field keys in the proto message.")
     private Set<String> mPerfettoPrefixKeyFields = new HashSet<>();
 
     @Option(
             name = "perfetto-prefix-inner-message-key-field",
-            description = "String value field need to be prefixed with the all the other"
-                    + "numeric value field keys outside of the current proto message.")
+            description =
+                    "String value field need to be prefixed with the all the other"
+                            + "numeric value field keys outside of the current proto message.")
     private Set<String> mPerfettoPrefixInnerMessagePrefixFields = new HashSet<>();
 
     @Option(
@@ -149,15 +158,19 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                             + " false if the metric can be handled by another post-processor.")
     private boolean mProcessedMetric = true;
 
-    @Option(name = "perfetto-metric-replace-prefix", description = "Replace the prefix in metrics"
-            + "from the metric proto file. Key is the prefix to look for in the metric"
-            + "keys parsed and value is be the replacement string.")
+    @Option(
+            name = "perfetto-metric-replace-prefix",
+            description =
+                    "Replace the prefix in metricsfrom the metric proto file. Key is the prefix to"
+                        + " look for in the metrickeys parsed and value is be the replacement"
+                        + " string.")
     private Map<String, String> mReplacePrefixMap = new LinkedHashMap<String, String>();
 
     @Option(
             name = "perfetto-all-metric-prefix",
-            description = "Prefix to be used with the metrics collected from perfetto."
-                    + "This will be applied before any other prefixes to metrics.")
+            description =
+                    "Prefix to be used with the metrics collected from perfetto."
+                            + "This will be applied before any other prefixes to metrics.")
     private String mAllMetricPrefix = "perfetto";
 
     @Option(
@@ -204,14 +217,14 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
         List<File> perfettoMetricFiles = new ArrayList<>();
         for (String key : logs.keySet()) {
             Optional<String> reportPrefix =
-                    mPerfettoProtoMetricFilePrefix
-                            .stream()
+                    mPerfettoProtoMetricFilePrefix.stream()
                             .filter(prefix -> key.startsWith(prefix))
                             .findAny();
 
             if (!reportPrefix.isPresent()) {
                 continue;
             }
+            CLog.i("Adding perfetto metric file: " + logs.get(key).getPath());
             perfettoMetricFiles.add(new File(logs.get(key).getPath()));
         }
         return perfettoMetricFiles;
@@ -231,8 +244,8 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
             // Text files by default are compressed before uploading. Decompress the text proto
             // file before post processing.
             try {
-                if (!(mTraceProcessorOutputFormat == METRIC_FILE_FORMAT.binary) &&
-                        ZipUtil.isZipFileValid(perfettoMetricFile, true)) {
+                if (!(mTraceProcessorOutputFormat == METRIC_FILE_FORMAT.binary)
+                        && ZipUtil.isZipFileValid(perfettoMetricFile, true)) {
                     ZipFile perfettoZippedFile = new ZipFile(perfettoMetricFile);
                     uncompressedDir = FileUtil.createTempDir("uncompressed_perfetto_metric");
                     ZipUtil2.extractZip(perfettoZippedFile, uncompressedDir);
@@ -251,19 +264,31 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                     new BufferedReader(new FileReader(perfettoMetricFile))) {
                 switch (mTraceProcessorOutputFormat) {
                     case text:
-                        TraceMetrics.Builder builder = TraceMetrics.newBuilder();
-                        TextFormat.merge(bufferedReader, builder);
-                        parsedMetrics.putAll(
-                                handlePrefixForProcessedMetrics(
-                                        convertPerfettoProtoMessage(builder.build())));
+                        if (perfettoMetricFile.getName().contains("v2")) {
+                            TraceSummary.Builder builderV2 = TraceSummary.newBuilder();
+                            ALLOW_UNKNOWN_FIELD.merge(bufferedReader, builderV2);
+                            parsedMetrics.putAll(convertPerfettoProtoMessageV2(builderV2.build()));
+                        } else {
+                            TraceMetrics.Builder builder = TraceMetrics.newBuilder();
+                            ALLOW_UNKNOWN_FIELD.merge(bufferedReader, builder);
+                            parsedMetrics.putAll(
+                                    handlePrefixForProcessedMetrics(
+                                            convertPerfettoProtoMessage(builder.build())));
+                        }
                         break;
                     case binary:
-                        TraceMetrics metricProto = null;
-                        metricProto =
-                                TraceMetrics.parseFrom(new FileInputStream(perfettoMetricFile));
-                        parsedMetrics.putAll(
-                                handlePrefixForProcessedMetrics(
-                                        convertPerfettoProtoMessage(metricProto)));
+                        if (perfettoMetricFile.getName().contains("v2")) {
+                            TraceSummary traceSummary =
+                                    TraceSummary.parseFrom(new FileInputStream(perfettoMetricFile));
+                            parsedMetrics.putAll(convertPerfettoProtoMessageV2(traceSummary));
+                        } else {
+                            TraceMetrics metricProto = null;
+                            metricProto =
+                                    TraceMetrics.parseFrom(new FileInputStream(perfettoMetricFile));
+                            parsedMetrics.putAll(
+                                    handlePrefixForProcessedMetrics(
+                                            convertPerfettoProtoMessage(metricProto)));
+                        }
                         break;
                     case json:
                         CLog.w("JSON perfetto metric file processing not supported.");
@@ -383,8 +408,9 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
             boolean isReplaced = false;
             for (Map.Entry<String, String> replaceEntry : mReplacePrefixMap.entrySet()) {
                 if (metric.getKey().startsWith(replaceEntry.getKey())) {
-                    String newKey = metric.getKey().replaceFirst(replaceEntry.getKey(),
-                            replaceEntry.getValue());
+                    String newKey =
+                            metric.getKey()
+                                    .replaceFirst(replaceEntry.getKey(), replaceEntry.getValue());
                     finalMetrics.put(newKey, metric.getValue());
                     isReplaced = true;
                     break;
@@ -438,7 +464,6 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
      *
      * <p>"perfetto-prefix-key-field" - perfetto.protos.ProcessRenderInfo.process_name
      * android_hwui_metric-process_info-process_name-system_server-cache_miss_avg
-     *
      */
     private Map<String, Metric.Builder> convertPerfettoProtoMessage(Message reportMessage) {
         Map<FieldDescriptor, Object> fields = reportMessage.getAllFields();
@@ -461,8 +486,12 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                         if (!keyPrefixOtherFields.isEmpty()) {
                             keyPrefixOtherFields = keyPrefixOtherFields.concat("-");
                         }
-                        keyPrefixOtherFields = keyPrefixOtherFields.concat(String.format("%s-%s",
-                                entry.getKey().getName().toString(), entry.getValue().toString()));
+                        keyPrefixOtherFields =
+                                keyPrefixOtherFields.concat(
+                                        String.format(
+                                                "%s-%s",
+                                                entry.getKey().getName().toString(),
+                                                entry.getValue().toString()));
                         continue;
                     }
 
@@ -471,9 +500,12 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                         if (!mPrefixFromInnerMessage.isEmpty()) {
                             mPrefixFromInnerMessage = mPrefixFromInnerMessage.concat("-");
                         }
-                        mPrefixFromInnerMessage = mPrefixFromInnerMessage.concat(String.format(
-                                "%s-%s", entry.getKey().getName().toString(),
-                                entry.getValue().toString()));
+                        mPrefixFromInnerMessage =
+                                mPrefixFromInnerMessage.concat(
+                                        String.format(
+                                                "%s-%s",
+                                                entry.getKey().getName().toString(),
+                                                entry.getValue().toString()));
                         prefixSetInCurrentMessage = true;
                         continue;
                     }
@@ -505,8 +537,12 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                         if (!keyPrefixOtherFields.isEmpty()) {
                             keyPrefixOtherFields = keyPrefixOtherFields.concat("-");
                         }
-                        keyPrefixOtherFields =  keyPrefixOtherFields.concat(String.format("%s-%s",
-                                entry.getKey().getName().toString(), entry.getValue().toString()));
+                        keyPrefixOtherFields =
+                                keyPrefixOtherFields.concat(
+                                        String.format(
+                                                "%s-%s",
+                                                entry.getKey().getName().toString(),
+                                                entry.getValue().toString()));
                     }
 
                     if (mPerfettoPrefixInnerMessagePrefixFields.contains(
@@ -514,9 +550,12 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                         if (!mPrefixFromInnerMessage.isEmpty()) {
                             mPrefixFromInnerMessage = mPrefixFromInnerMessage.concat("-");
                         }
-                        mPrefixFromInnerMessage = mPrefixFromInnerMessage.concat(String.format(
-                                "%s-%s", entry.getKey().getName().toString(),
-                                entry.getValue().toString()));
+                        mPrefixFromInnerMessage =
+                                mPrefixFromInnerMessage.concat(
+                                        String.format(
+                                                "%s-%s",
+                                                entry.getKey().getName().toString(),
+                                                entry.getValue().toString()));
                         prefixSetInCurrentMessage = true;
                         continue;
                     }
@@ -533,7 +572,7 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                 Map<String, Metric.Builder> messageMetrics =
                         convertPerfettoProtoMessage((Message) entry.getValue());
                 if (!mPrefixFromInnerMessage.isEmpty()) {
-                  innerMessagePrefix = mPrefixFromInnerMessage;
+                    innerMessagePrefix = mPrefixFromInnerMessage;
                 }
                 for (Entry<String, Metric.Builder> metricEntry : messageMetrics.entrySet()) {
                     // Add prefix to the metrics parsed from this message.
@@ -607,23 +646,26 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
                 new HashMap<String, Metric.Builder>();
         if (!keyPrefixOtherFields.isEmpty()) {
             for (Map.Entry<String, Metric.Builder> currentMetric : convertedMetrics.entrySet()) {
-                additionalConvertedMetrics.put(String.format("%s-%s", keyPrefixOtherFields,
-                        currentMetric.getKey()), currentMetric.getValue());
+                additionalConvertedMetrics.put(
+                        String.format("%s-%s", keyPrefixOtherFields, currentMetric.getKey()),
+                        currentMetric.getValue());
             }
         }
 
         if (!mPrefixFromInnerMessage.isEmpty() || !innerMessagePrefix.isEmpty()) {
-          String prefixToUse = !mPrefixFromInnerMessage.isEmpty()
-                  ? mPrefixFromInnerMessage : innerMessagePrefix;
-          for (Map.Entry<String, Metric.Builder> currentMetric : convertedMetrics.entrySet()) {
-            additionalConvertedMetrics.put(
-                String.format("%s-%s", prefixToUse, currentMetric.getKey()),
-                currentMetric.getValue());
-          }
+            String prefixToUse =
+                    !mPrefixFromInnerMessage.isEmpty()
+                            ? mPrefixFromInnerMessage
+                            : innerMessagePrefix;
+            for (Map.Entry<String, Metric.Builder> currentMetric : convertedMetrics.entrySet()) {
+                additionalConvertedMetrics.put(
+                        String.format("%s-%s", prefixToUse, currentMetric.getKey()),
+                        currentMetric.getValue());
+            }
         }
 
         if (!prefixSetInCurrentMessage) {
-          mPrefixFromInnerMessage = "";
+            mPrefixFromInnerMessage = "";
         }
 
         // Not cleaning up the other metrics without prefix fields.
@@ -632,6 +674,41 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
         return convertedMetrics;
     }
 
+    /**
+     * Expands the metric v2 proto file as tree structure and converts it into key, value pairs by
+     * recursively constructing the key using the id and dimensions string values, proto fields with
+     * string values until the numeric proto field is encountered.
+     *
+     * <p>memory_per_process-avg_rss_and_swap-.ShannonImsService: 121380864.000000
+     * memory_per_process-avg_rss_and_swap-/apex/com.android.adbd/bin/adbd: 10464441.000000
+     */
+    private Map<String, Metric.Builder> convertPerfettoProtoMessageV2(TraceSummary reportMessage) {
+        CLog.d("convertPerfettoProtoMessageV2 reportMessage : " + reportMessage);
+        Map<String, Metric.Builder> convertedMetrics = new HashMap<String, Metric.Builder>();
+        for (TraceMetricV2 metric : reportMessage.getMetricList()) {
+            for (MetricRow row : metric.getRowList()) {
+                String rowKey = metric.getSpec().getId();
+                double rowValue = row.getValue();
+                for (Dimension dimension : row.getDimensionList()) {
+                    Map<FieldDescriptor, Object> fields = dimension.getAllFields();
+                    for (Entry<FieldDescriptor, Object> entry : fields.entrySet()) {
+                        if (!(entry.getValue() instanceof Message)) {
+                            rowKey = rowKey.concat("-").concat(entry.getValue().toString());
+                        }
+                    }
+                }
+                convertedMetrics.put(
+                        rowKey,
+                        TfMetricProtoUtil.stringToMetric(String.format("%f", rowValue))
+                                .toBuilder());
+                CLog.d(
+                        "Perfetto trace v2 metric: key: %s value: %s",
+                        rowKey, Double.toString(rowValue));
+            }
+        }
+        return convertedMetrics;
+    }
+
     /**
      * Check if the given string is number. It matches the string with exponent notation as well.
      *
@@ -674,9 +751,7 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
         return filteredMetrics;
     }
 
-    /**
-     * Set the metric type to RAW metric.
-     */
+    /** Set the metric type to RAW metric. */
     @Override
     protected DataType getMetricType() {
         return DataType.RAW;
diff --git a/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java b/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
index 236481a8e..879ff0544 100644
--- a/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
@@ -108,6 +108,11 @@ public class DynamicSystemPreparer extends BaseTargetPreparer implements ILabPre
             description = "Whether to compress the images pushed to the device.")
     private boolean mCompressImages = false;
 
+    @Option(
+            name = "flash-pvmfw",
+            description = "Fastboot flash pvmfw.img in the file system-image-zip-name.")
+    private boolean mFlashPvmfw = false;
+
     private boolean isDSURunning(ITestDevice device) throws DeviceNotAvailableException {
         CollectingOutputReceiver receiver = new CollectingOutputReceiver();
         device.executeShellCommand("gsi_tool status", receiver);
@@ -195,6 +200,46 @@ public class DynamicSystemPreparer extends BaseTargetPreparer implements ILabPre
         }
     }
 
+    private void flashPvmfw(ITestDevice device, File systemImageZipFile)
+            throws DeviceNotAvailableException, TargetSetupError {
+        File pvmfwImg = null;
+        try {
+            // Unzip pvmfw.img and save to temp file
+            CLog.i("Unzip pvmfw.img from %s", systemImageZipFile.getAbsolutePath());
+            try (ZipFile zipFile = new ZipFile(systemImageZipFile)) {
+                ZipEntry pvmfwEntry = zipFile.getEntry("pvmfw.img");
+                if (pvmfwEntry == null) {
+                    throw new TargetSetupError(
+                            String.format("Cannot find pvmfw.img in %s", systemImageZipFile),
+                            device.getDeviceDescriptor(),
+                            InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
+                }
+                pvmfwImg = FileUtil.createTempFile("pvmfw", ".img");
+                try (InputStream in = zipFile.getInputStream(pvmfwEntry);
+                        OutputStream out = new FileOutputStream(pvmfwImg)) {
+                    StreamUtil.copyStreams(in, out);
+                }
+            } catch (IOException e) {
+                throw new TargetSetupError(
+                        String.format("Fail unzip pvmfw.img from %s", systemImageZipFile),
+                        device.getDeviceDescriptor(),
+                        InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
+            }
+
+            device.waitForDeviceOnline();
+
+            // Flash pvmfw.img and reboot back
+            CLog.i("Reboot into booloader and flash pvmfw.img");
+            device.rebootIntoBootloader();
+            device.executeFastbootCommand(
+                    String.format("flash pvmfw %s", pvmfwImg.getAbsolutePath()));
+            device.reboot();
+            device.waitForDeviceAvailable();
+        } finally {
+            FileUtil.deleteFile(pvmfwImg);
+        }
+    }
+
     @Override
     public void setUp(TestInformation testInfo)
             throws TargetSetupError, BuildError, DeviceNotAvailableException {
@@ -209,6 +254,10 @@ public class DynamicSystemPreparer extends BaseTargetPreparer implements ILabPre
                     InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
         }
 
+        if (mFlashPvmfw) {
+            flashPvmfw(device, systemImageZipFile);
+        }
+
         List<File> tempFiles = new ArrayList<File>();
         try {
             final long userdataSize = mUserDataSizeInGb << 30;
diff --git a/test_framework/com/android/tradefed/targetprep/PushFilePreparer.java b/test_framework/com/android/tradefed/targetprep/PushFilePreparer.java
index ce32b5181..8479e6b8e 100644
--- a/test_framework/com/android/tradefed/targetprep/PushFilePreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/PushFilePreparer.java
@@ -222,6 +222,19 @@ public class PushFilePreparer extends BaseTargetPreparer
      */
     public File resolveRelativeFilePath(IBuildInfo buildInfo, String fileName) {
         File src = null;
+        try {
+            src = SearchArtifactUtil.searchFile(fileName, true, mAbi, null, null, null, true);
+        } catch (Exception e) {
+            // TODO: handle error when migration is complete.
+            CLog.e(e);
+        }
+        if (src != null && src.exists()) {
+            return src;
+        } else {
+            // Silently report not found and fall back to old logic.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, 1);
+        }
         if (buildInfo != null) {
             src = buildInfo.getFile(fileName);
             if (src != null && src.exists()) {
@@ -353,6 +366,11 @@ public class PushFilePreparer extends BaseTargetPreparer
                 }
             }
         }
+        if (src == null) {
+            // if old logic fails too, do not report search artifact failure
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, -1);
+        }
         return src;
     }
 
diff --git a/test_framework/com/android/tradefed/targetprep/RootTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/RootTargetPreparer.java
index ed3fa31dc..971a3c613 100644
--- a/test_framework/com/android/tradefed/targetprep/RootTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/RootTargetPreparer.java
@@ -90,4 +90,12 @@ public final class RootTargetPreparer extends BaseTargetPreparer {
             CLog.w(message + " " + deviceDescriptor);
         }
     }
+
+    public boolean shouldThrowOnFailure() {
+        return mThrowOnError;
+    }
+
+    public boolean shouldForceRoot() {
+        return mForceRoot;
+    }
 }
diff --git a/test_framework/com/android/tradefed/targetprep/RunHostCommandTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/RunHostCommandTargetPreparer.java
index b324b95a2..e839f3410 100644
--- a/test_framework/com/android/tradefed/targetprep/RunHostCommandTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/RunHostCommandTargetPreparer.java
@@ -35,9 +35,9 @@ import com.android.tradefed.result.error.TestErrorIdentifier;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.PythonVirtualenvHelper;
 import com.android.tradefed.util.QuotationAwareTokenizer;
 import com.android.tradefed.util.RunUtil;
-import com.android.tradefed.util.PythonVirtualenvHelper;
 
 import com.google.common.annotations.VisibleForTesting;
 
@@ -330,7 +330,8 @@ public class RunHostCommandTargetPreparer extends BaseTargetPreparer
 
     /**
      * For each command in the list, replace placeholder (if any) with the file name indicated in
-     * the build information
+     * the build information. If the file has multiple path possible, split them around `:` and
+     * return the first file found
      *
      * @param commands list of host commands
      * @param buildInfo build artifact information
@@ -342,12 +343,14 @@ public class RunHostCommandTargetPreparer extends BaseTargetPreparer
             StringBuffer command = new StringBuffer();
 
             while (matcher.find()) {
-                String fileName = matcher.group(1);
-                File file = buildInfo.getFile(fileName);
-                if (file == null || !file.exists()) {
-                    continue;
+                for (String fileName : matcher.group(1).split(":")) {
+                    File file = buildInfo.getFile(fileName);
+                    if (file == null || !file.exists()) {
+                        continue;
+                    }
+                    matcher.appendReplacement(command, file.getPath());
+                    break;
                 }
-                matcher.appendReplacement(command, file.getPath());
             }
             matcher.appendTail(command);
 
diff --git a/test_framework/com/android/tradefed/targetprep/multi/MixImageZipPreparer.java b/test_framework/com/android/tradefed/targetprep/multi/MixImageZipPreparer.java
index 38d1544df..b7baeee55 100644
--- a/test_framework/com/android/tradefed/targetprep/multi/MixImageZipPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/multi/MixImageZipPreparer.java
@@ -208,24 +208,42 @@ public class MixImageZipPreparer extends BaseMultiTargetPreparer {
         File mixedSuperImage = null;
         File mixedImageZip = null;
         try {
-            deviceImageZip = new ZipFile(deviceBuildInfo.getDeviceImageFile());
-
             // Get all files from device build.
-            Map<String, InputStreamFactory> files =
-                    getInputStreamFactoriesFromImageZip(deviceImageZip, file -> true);
+            Map<String, InputStreamFactory> files = new HashMap<>();
+            File deviceImageFile = deviceBuildInfo.getDeviceImageFile();
+            if (deviceImageFile.isDirectory()) {
+                files = getInputStreamFactoriesFromUncompressedImageZip(deviceImageFile,
+                        file -> true);
+            } else {
+                files = getInputStreamFactoriesFromImageZip(new ZipFile(deviceImageFile),
+                        file -> true);
+            }
+
             Map<String, InputStreamFactory> filesNotInDeviceBuild =
                     new HashMap<String, InputStreamFactory>();
 
             // Map system build file names to contents by file name.
-            systemImageZip = new ZipFile(systemBuildInfo.getDeviceImageFile());
-            Map<String, InputStreamFactory> systemFiles =
-                    getInputStreamFactoriesFromImageZip(
-                            systemImageZip, file -> mSystemFileNames.contains(file));
-
+            Map<String, InputStreamFactory> systemFiles = new HashMap<>();
             // Map system build file names to contents by file name map values
-            Map<String, InputStreamFactory> extraSystemFiles =
-                    getInputStreamFactoriesFromImageZip(
-                            systemImageZip, file -> mSystemFileNameMaps.containsValue(file));
+            Map<String, InputStreamFactory> extraSystemFiles = new HashMap<>();
+            File systemImageFile = systemBuildInfo.getDeviceImageFile();
+            if (systemImageFile.isDirectory()) {
+                systemFiles =
+                        getInputStreamFactoriesFromUncompressedImageZip(
+                                systemImageFile, file -> mSystemFileNames.contains(file));
+                extraSystemFiles =
+                        getInputStreamFactoriesFromUncompressedImageZip(
+                                systemImageFile, file -> mSystemFileNameMaps.containsValue(file));
+            } else {
+                systemImageZip = new ZipFile(systemImageFile);
+                systemFiles =
+                        getInputStreamFactoriesFromImageZip(
+                                systemImageZip, file -> mSystemFileNames.contains(file));
+                extraSystemFiles =
+                        getInputStreamFactoriesFromImageZip(
+                                systemImageZip, file -> mSystemFileNameMaps.containsValue(file));
+            }
+
             // Map device build file names to contents.
             for (Entry<String, String> entry : mSystemFileNameMaps.entrySet()) {
                 InputStreamFactory value = extraSystemFiles.get(entry.getValue());
@@ -400,6 +418,52 @@ public class MixImageZipPreparer extends BaseMultiTargetPreparer {
         return factories;
     }
 
+    /**
+     * Get {@link InputStreamFactory} from entries in an image dir (uncompressed image zip).
+     *
+     * @param imageDir image directory.
+     * @param predicate function that takes a file name as the argument and determines whether the
+     *     file name and the content should be added to the output map.
+     * @return map from file name to {@link InputStreamFactory}.
+     * @throws IOException if fails to create the temporary directory.
+     */
+    private static Map<String, InputStreamFactory> getInputStreamFactoriesFromUncompressedImageZip(
+            final File imageDir, Predicate<String> predicate) throws IOException {
+        Map<String, InputStreamFactory> factories = new HashMap<String, InputStreamFactory>();
+        for (File file : imageDir.listFiles()) {
+            if (file.isDirectory()) {
+                CLog.w("Image zip contains subdirectory %s.", file.getName());
+                continue;
+            }
+            String name = file.getName();
+            if (!predicate.test(name)) {
+                continue;
+            }
+
+            factories.put(
+                    name,
+                    new InputStreamFactory() {
+                        @Override
+                        public InputStream createInputStream() throws IOException {
+                            return new FileInputStream(file);
+                        }
+
+                        @Override
+                        public long getSize() {
+                            return file.length();
+                        }
+
+                        @Override
+                        public long getCrc32() throws IOException {
+                            try (InputStream in = createInputStream()) {
+                                return StreamUtil.calculateCrc32(in);
+                            }
+                        }
+                    });
+        }
+        return factories;
+    }
+
     private static Map<String, InputStreamFactory> createStubInputStreamFactories(
             Collection<String> stubFileNames) {
         // The image size must be larger than zero. Otherwise fastboot cannot flash it.
diff --git a/test_framework/com/android/tradefed/testtype/DeviceJUnit4ClassRunner.java b/test_framework/com/android/tradefed/testtype/DeviceJUnit4ClassRunner.java
index 113d7e749..daa58b531 100644
--- a/test_framework/com/android/tradefed/testtype/DeviceJUnit4ClassRunner.java
+++ b/test_framework/com/android/tradefed/testtype/DeviceJUnit4ClassRunner.java
@@ -125,20 +125,24 @@ public class DeviceJUnit4ClassRunner extends BlockJUnit4ClassRunner
 
         List<FrameworkMethod> beforesWithDevice =
                 getTestClass().getAnnotatedMethods(BeforeClassWithInfo.class);
-        return beforesWithDevice.isEmpty()
-                ? s
-                : new RunBeforesWithInfo(statement, beforesWithDevice, mTestInformation);
+        // If present, run BeforeClassWithInfo then BeforeClass
+        if (!beforesWithDevice.isEmpty()) {
+            s = new RunBeforesWithInfo(s, beforesWithDevice, mTestInformation);
+        }
+        return s;
     }
 
     @Override
     protected Statement withAfterClasses(Statement statement) {
-        Statement s = super.withAfterClasses(statement);
+        Statement s = statement;
 
         List<FrameworkMethod> aftersWithDevice =
                 getTestClass().getAnnotatedMethods(AfterClassWithInfo.class);
-        return aftersWithDevice.isEmpty()
-                ? s
-                : new RunAftersWithInfo(statement, aftersWithDevice, mTestInformation);
+        // If present, run AfterClass, then AfterClassWithInfo
+        if (!aftersWithDevice.isEmpty()) {
+            s = new RunAftersWithInfo(s, aftersWithDevice, mTestInformation);
+        }
+        return super.withAfterClasses(s);
     }
 
     @Override
diff --git a/test_framework/com/android/tradefed/testtype/GTest.java b/test_framework/com/android/tradefed/testtype/GTest.java
index 894e29849..3a85c84ca 100644
--- a/test_framework/com/android/tradefed/testtype/GTest.java
+++ b/test_framework/com/android/tradefed/testtype/GTest.java
@@ -404,7 +404,7 @@ public class GTest extends GTestBase implements IDeviceTest {
             String testRunName = fullPath.substring(fullPath.lastIndexOf("/") + 1);
             tmpOutput = FileUtil.createTempFile(testRunName, ".xml");
             String tmpResName = fullPath + "_res.xml";
-            String extraFlag = String.format(GTEST_XML_OUTPUT, tmpResName);
+            String extraFlag = String.format(convertName(GTEST_XML_OUTPUT), tmpResName);
             String fullFlagCmd =  String.format("%s %s", flags, extraFlag);
 
             // Run the tests with modified flags
diff --git a/test_framework/com/android/tradefed/testtype/GTestBase.java b/test_framework/com/android/tradefed/testtype/GTestBase.java
index cc2b0e55e..fa21a1bbc 100644
--- a/test_framework/com/android/tradefed/testtype/GTestBase.java
+++ b/test_framework/com/android/tradefed/testtype/GTestBase.java
@@ -224,6 +224,11 @@ public abstract class GTestBase
                             + "resolved.")
     private boolean mChangeToWorkingDirectory = false;
 
+    @Option(
+            name = "use-gunit-namings",
+            description = "Use the internal gunit version name of flags.")
+    private boolean mSwitchToGunitNamings = false;
+
     // GTest flags...
     protected static final String GTEST_FLAG_PRINT_TIME = "--gtest_print_time";
     protected static final String GTEST_FLAG_FILTER = "--gtest_filter";
@@ -567,7 +572,7 @@ public abstract class GTestBase
         if (filterFlag.length() > 500) {
             String tmpFlag = createFlagFile(filterFlag);
             if (tmpFlag != null) {
-                return String.format("%s=%s", GTEST_FLAG_FILE, tmpFlag);
+                return String.format("%s=%s", convertName(GTEST_FLAG_FILE), tmpFlag);
             }
         }
 
@@ -602,14 +607,15 @@ public abstract class GTestBase
      * @return the {@link String} of all the GTest flags that should be passed to the GTest
      */
     protected String getAllGTestFlags(String path) throws DeviceNotAvailableException {
-        String flags = String.format("%s %s", GTEST_FLAG_PRINT_TIME, getGTestFilters(path));
+        String flags =
+                String.format("%s %s", convertName(GTEST_FLAG_PRINT_TIME), getGTestFilters(path));
 
         if (getRunDisabledTests()) {
-            flags = String.format("%s %s", flags, GTEST_FLAG_RUN_DISABLED_TESTS);
+            flags = String.format("%s %s", flags, convertName(GTEST_FLAG_RUN_DISABLED_TESTS));
         }
 
         if (isCollectTestsOnly()) {
-            flags = String.format("%s %s", flags, GTEST_FLAG_LIST_TESTS);
+            flags = String.format("%s %s", flags, convertName(GTEST_FLAG_LIST_TESTS));
         }
 
         for (String gTestFlag : getGTestFlags()) {
@@ -857,4 +863,11 @@ public abstract class GTestBase
                 && mPrevFailedTests != null
                 && !mPrevFailedTests.isEmpty();
     }
+
+    protected String convertName(String gtestFlagName) {
+        if (mSwitchToGunitNamings) {
+            return gtestFlagName.replaceAll("--gtest", "--gunit");
+        }
+        return gtestFlagName;
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/HostTest.java b/test_framework/com/android/tradefed/testtype/HostTest.java
index 7af69fe74..c387975cf 100644
--- a/test_framework/com/android/tradefed/testtype/HostTest.java
+++ b/test_framework/com/android/tradefed/testtype/HostTest.java
@@ -37,6 +37,7 @@ import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.observatory.IDiscoverTestClasses;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ResultForwarder;
@@ -112,7 +113,8 @@ public class HostTest
                 IAbiReceiver,
                 IShardableTest,
                 IRuntimeHintProvider,
-                IConfigurationReceiver {
+                IConfigurationReceiver,
+                IDiscoverTestClasses {
 
     @Option(name = "class", description = "The JUnit test classes to run, in the format "
             + "<package>.<class>. eg. \"com.android.foo.Bar\". This field can be repeated.",
@@ -432,7 +434,7 @@ public class HostTest
         mClasses.add(className);
     }
 
-    @VisibleForTesting
+    @Override
     public Set<String> getClassNames() {
         return mClasses;
     }
diff --git a/test_framework/com/android/tradefed/testtype/InstrumentationListener.java b/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
index 693db9080..defcf9363 100644
--- a/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
+++ b/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
@@ -38,6 +38,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -57,6 +58,7 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
     private static final String DDMLIB_UNEXPECTED_COUNT = "Instrumentation reported numtests=";
 
     private Set<TestDescription> mTests = new HashSet<>();
+    private Map<String, String> mClassAssumptionFailure = new HashMap<>();
     private Set<TestDescription> mDuplicateTests = new HashSet<>();
     private final Collection<TestDescription> mExpectedTests;
     private boolean mDisableDuplicateCheck = false;
@@ -131,6 +133,15 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
         super.testFailed(test, failure);
     }
 
+    @Override
+    public void testAssumptionFailure(TestDescription test, String trace) {
+        if (test.getTestName().equals("null")) {
+            mClassAssumptionFailure.put(test.getClassName(), trace);
+        } else {
+            super.testAssumptionFailure(test, trace);
+        }
+    }
+
     @Override
     public void testEnded(TestDescription test, long endTime, HashMap<String, Metric> testMetrics) {
         mLastTest = test;
@@ -213,7 +224,7 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
             super.testRunFailed(error);
         } else if (mReportUnexecutedTests
                 && mExpectedTests != null
-                && mExpectedTests.size() > mTests.size()) {
+                && (mExpectedTests.size() > mTests.size() || !mExpectedTests.isEmpty())) {
             Set<TestDescription> missingTests = new LinkedHashSet<>(mExpectedTests);
             missingTests.removeAll(mTests);
 
@@ -230,17 +241,23 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
             }
             for (TestDescription miss : missingTests) {
                 super.testStarted(miss);
-                SkipReason reason =
-                        new SkipReason(
-                                String.format(
-                                        "Test did not run due to instrumentation issue. %s %s",
-                                        lastExecutedLog, runLevelError),
-                                "INSTRUMENTATION_ERROR");
-                super.testSkipped(miss, reason);
+                if (mClassAssumptionFailure.containsKey(miss.getClassName())) {
+                    super.testAssumptionFailure(
+                            miss, mClassAssumptionFailure.get(miss.getClassName()));
+                } else {
+                    SkipReason reason =
+                            new SkipReason(
+                                    String.format(
+                                            "Test did not run due to instrumentation issue. %s %s",
+                                            lastExecutedLog, runLevelError),
+                                    "INSTRUMENTATION_ERROR");
+                    super.testSkipped(miss, reason);
+                }
                 super.testEnded(miss, new HashMap<String, Metric>());
             }
         }
         runLevelError = null;
+        mClassAssumptionFailure = new HashMap<String, String>();
         super.testRunEnded(elapsedTime, runMetrics);
     }
 }
diff --git a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
index e4c7aa83b..4d4f1fbce 100644
--- a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
+++ b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
@@ -1086,7 +1086,7 @@ public class InstrumentationTest
                 expectedTests.removeAll(excludeNonExecuted(testTracker.getCurrentRunResults()));
                 IRetryDecision decision = mConfiguration.getRetryDecision();
                 if (!RetryStrategy.NO_RETRY.equals(decision.getRetryStrategy())
-                        && decision.getMaxRetryCount() > 1) {
+                        && decision.getMaxTestRunAttempts() > 1) {
                     // Delegate retry to the module/invocation level.
                     // This prevents the InstrumentationTest retry from re-running by itself and
                     // creating overhead.
diff --git a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
index e1474fbb5..5f87d4249 100644
--- a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
@@ -29,6 +29,8 @@ import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.invoker.logger.CurrentInvocation;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.isolation.FilterSpec;
 import com.android.tradefed.isolation.JUnitEvent;
@@ -50,6 +52,7 @@ import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.ResourceUtil;
 import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
 import com.android.tradefed.util.StreamUtil;
 import com.android.tradefed.util.SystemUtil;
 
@@ -199,6 +202,11 @@ public class IsolatedHostTest
                             + " test problems to silently fail.")
     private boolean mDoNotSwallowRunnerErrors = false;
 
+    @Option(
+            name = "ravenwood-locale",
+            description = "Set the locale for Ravenwood tests. Default is \"en_US.UTF-8\"")
+    private String mRavenwoodLocale = "en_US.UTF-8";
+
     private static final String QUALIFIED_PATH = "/com/android/tradefed/isolation";
     private static final String ISOLATED_JAVA_LOG = "isolated-java-logs";
     private IBuildInfo mBuildInfo;
@@ -270,6 +278,11 @@ public class IsolatedHostTest
                                           .getAbsolutePath()));
             }
 
+            if (mRavenwoodResources) {
+                runner.setEnvVariable("LANG", mRavenwoodLocale);
+                runner.setEnvVariable("LC_ALL", mRavenwoodLocale);
+            }
+
             runner.setWorkingDir(mWorkDir);
             CLog.v("Using PWD: %s", mWorkDir.getAbsolutePath());
 
@@ -907,9 +920,23 @@ public class IsolatedHostTest
      * find our jar.
      */
     private File getJarFile(String jarName, IBuildInfo buildInfo) throws FileNotFoundException {
+        File jarFile = null;
+        try {
+            jarFile = SearchArtifactUtil.searchFile(jarName, false);
+        } catch (Exception e) {
+            // TODO: handle error when migration is complete.
+            CLog.e(e);
+        }
+        if (jarFile != null && jarFile.exists()) {
+            return jarFile;
+        } else {
+            // Silently report not found and fall back to old logic.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, 1);
+        }
         // Check tests dir
         File testDir = buildInfo.getFile(BuildInfoFileKey.TESTDIR_IMAGE);
-        File jarFile = searchJarFile(testDir, jarName);
+        jarFile = searchJarFile(testDir, jarName);
         if (jarFile != null) {
             return jarFile;
         }
@@ -922,6 +949,9 @@ public class IsolatedHostTest
         if (jarFile != null) {
             return jarFile;
         }
+        // if old logic fails too, do not report search artifact failure
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, -1);
         throw new FileNotFoundException(String.format("Could not find jar: %s", jarName));
     }
 
diff --git a/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java b/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
index 2c41531f6..1937fe94f 100644
--- a/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
@@ -27,6 +27,7 @@ import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.GTestResultParser;
 import com.android.tradefed.testtype.IDeviceTest;
+import com.android.tradefed.testtype.PythonUnitTestResultParser;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 
@@ -54,12 +55,17 @@ public class ExecutableTargetTest extends ExecutableBaseTest implements IDeviceT
     @Option(name = "skip-binary-check", description = "Skip the binary check in findBinary().")
     private boolean mSkipBinaryCheck = false;
 
-    @Option(name = "parse-gtest", description = "Parse test outputs in GTest format")
+    @Option(name = "parse-gtest", description = "Parse test outputs in GTest format.")
     private boolean mParseGTest = false;
 
+    @Option(
+            name = "parse-python-unit-test",
+            description = "Parse test outputs in Python unit test format.")
+    private boolean mParsePythonUnitTest = false;
+
     @Override
     protected boolean doesRunBinaryGenerateTestResults() {
-        return mParseGTest;
+        return mParseGTest || mParsePythonUnitTest;
     }
 
     @Override
@@ -67,7 +73,11 @@ public class ExecutableTargetTest extends ExecutableBaseTest implements IDeviceT
         // when using the GTestParser testRun events are triggered
         // by the TEST_RUN_MARKER in stdout
         // so we should not generate testRuns on the RunBinary event
-        return !mParseGTest;
+
+        // when using the PythonUnitTestResultParser, testRun events are triggered in the parser
+        // with the given run names
+        // so we should not generate testRuns on the RunBinary event
+        return !mParseGTest && !mParsePythonUnitTest;
     }
 
     @Override
@@ -96,6 +106,11 @@ public class ExecutableTargetTest extends ExecutableBaseTest implements IDeviceT
 
     @Override
     public FailureDescription shouldAbortRun(TestDescription description) {
+        if (mParseGTest && mParsePythonUnitTest) {
+            return FailureDescription.create(
+                    "Only one of parse-gtest and parse-python-unit-test can be set.",
+                    FailureStatus.CUSTOMER_ISSUE);
+        }
         if (mAbortIfDeviceLost) {
             if (!TestDeviceState.ONLINE.equals(getDevice().getDeviceState())) {
                 return FailureDescription.create(
@@ -165,6 +180,13 @@ public class ExecutableTargetTest extends ExecutableBaseTest implements IDeviceT
                             );
             parser.processNewLines(result.getStdout().split("\n"));
             parser.done();
+        } else if (mParsePythonUnitTest) {
+            // the parser automatically reports the test result back to the infra through the
+            // listener.
+            MultiLineReceiver parser =
+                    new PythonUnitTestResultParser(listener, description.getTestName());
+            parser.processNewLines(result.getStderr().split("\n"));
+            parser.done();
         } else if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
             String error_message;
             error_message =
diff --git a/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java b/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
index c8edad261..4e49ccf72 100644
--- a/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
@@ -27,8 +27,10 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.result.skipped.SkipReason;
+import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.KernelModuleUtils;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -37,7 +39,6 @@ import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 
 /** Test runner for running KUnit test modules on device. */
 @OptionClass(alias = "kunit-module-test")
@@ -49,45 +50,11 @@ public class KUnitModuleTest extends ExecutableTargetTest {
     private KTapResultParser.ParseResolution mKTapResultParserResolution =
             KTapResultParser.ParseResolution.AGGREGATED_MODULE;
 
-    public static final String RMMOD_COMMAND_FMT = "rmmod %s";
-    public static final String INSMOD_COMMAND_FMT = "insmod %s";
     public static final String KUNIT_DEBUGFS_PATH =
             String.format("%s/kunit", NativeDevice.DEBUGFS_PATH);
     public static final String KUNIT_RESULTS_FMT =
             String.format("%s/%%s/results", KUNIT_DEBUGFS_PATH);
 
-    /** Remove `.ko` extension if present */
-    private static String removeKoExtension(String s) {
-        return s.endsWith(".ko") ? s.substring(0, s.length() - 3) : s;
-    }
-
-    /**
-     * Return module name as it's displayed after loading.
-     *
-     * <p>For example, see the difference between the file name and that returned by `lsmod`:
-     *
-     * <pre>{@code
-     * $ insmod kunit-example-test.ko
-     * $ lsmod | grep kunit
-     * kunit_example_test 20480 0
-     * }</pre>
-     */
-    private String getDisplayedModuleName(String fullPath) {
-
-        // Extract filename from full path
-        int sepPos = fullPath.lastIndexOf('/');
-        String moduleName = sepPos == -1 ? fullPath : fullPath.substring(sepPos + 1);
-        if (moduleName.isEmpty()) {
-            throw new IllegalArgumentException("input should not end with \"/\"");
-        }
-
-        // Remove `.ko` extension if present
-        moduleName = removeKoExtension(moduleName);
-
-        // Replace all '-' with '_'
-        return moduleName.replace('-', '_');
-    }
-
     @Override
     protected boolean doesRunBinaryGenerateTestResults() {
         return true;
@@ -107,7 +74,8 @@ public class KUnitModuleTest extends ExecutableTargetTest {
         Map<String, String> originalTestCommands = super.getAllTestCommands();
         Map<String, String> modifiedTestCommands = new LinkedHashMap<>();
         for (Map.Entry<String, String> entry : originalTestCommands.entrySet()) {
-            modifiedTestCommands.put(removeKoExtension(entry.getKey()), entry.getValue());
+            modifiedTestCommands.put(
+                    KernelModuleUtils.removeKoExtension(entry.getKey()), entry.getValue());
         }
         return modifiedTestCommands;
     }
@@ -125,11 +93,10 @@ public class KUnitModuleTest extends ExecutableTargetTest {
         if (getDevice() == null) {
             throw new IllegalArgumentException("Device has not been set");
         }
-        String kunitModule = getDisplayedModuleName(modulePath);
+        String kunitModule = KernelModuleUtils.getDisplayedModuleName(modulePath);
 
         // Unload module before hand in case it's already loaded for some reason
-        CommandResult result =
-                getDevice().executeShellV2Command(String.format(RMMOD_COMMAND_FMT, kunitModule));
+        CommandResult result = KernelModuleUtils.removeSingleModule(getDevice(), kunitModule);
 
         if (CommandStatus.SUCCESS.equals(result.getStatus())) {
             CLog.w("Module '%s' unexpectedly still loaded, it has been unloaded.", kunitModule);
@@ -151,17 +118,12 @@ public class KUnitModuleTest extends ExecutableTargetTest {
                         String.join(",", kunitTestSuitesBefore));
             }
 
-            result =
-                    getDevice()
-                            .executeShellV2Command(
-                                    String.format(INSMOD_COMMAND_FMT, modulePath),
-                                    getTimeoutPerBinaryMs(),
-                                    TimeUnit.MILLISECONDS);
-            if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
-                String errorMessage =
-                        String.format(
-                                "binary returned non-zero. Exit code: %d, stderr: %s, stdout: %s",
-                                result.getExitCode(), result.getStderr(), result.getStdout());
+            try {
+                result =
+                        KernelModuleUtils.installModule(
+                                getDevice(), modulePath, "", getTimeoutPerBinaryMs());
+            } catch (TargetSetupError e) {
+                String errorMessage = e.toString();
                 listener.testStarted(description);
                 listener.testFailed(
                         description,
@@ -219,9 +181,7 @@ public class KUnitModuleTest extends ExecutableTargetTest {
             }
 
             // Clean up, unload module.
-            result =
-                    getDevice()
-                            .executeShellV2Command(String.format(RMMOD_COMMAND_FMT, kunitModule));
+            result = KernelModuleUtils.removeSingleModule(getDevice(), kunitModule);
 
             if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
                 String errorMessage =
diff --git a/test_framework/com/android/tradefed/testtype/junit4/DeviceParameterizedRunner.java b/test_framework/com/android/tradefed/testtype/junit4/DeviceParameterizedRunner.java
index bef11be51..160a6e56b 100644
--- a/test_framework/com/android/tradefed/testtype/junit4/DeviceParameterizedRunner.java
+++ b/test_framework/com/android/tradefed/testtype/junit4/DeviceParameterizedRunner.java
@@ -103,5 +103,31 @@ public class DeviceParameterizedRunner extends JUnitParamsRunner
     @Override
     public TestInformation getTestInformation() {
         return mTestInformation;
+  }
+
+    @Override
+    protected Statement withBeforeClasses(Statement statement) {
+        Statement s = super.withBeforeClasses(statement);
+
+        List<FrameworkMethod> beforesWithDevice =
+                getTestClass().getAnnotatedMethods(BeforeClassWithInfo.class);
+        // If present, run BeforeClassWithInfo then BeforeClass
+        if (!beforesWithDevice.isEmpty()) {
+            s = new RunBeforesWithInfo(s, beforesWithDevice, mTestInformation);
+        }
+        return s;
     }
+
+    @Override
+    protected Statement withAfterClasses(Statement statement) {
+        Statement s = statement;
+
+        List<FrameworkMethod> aftersWithDevice =
+                getTestClass().getAnnotatedMethods(AfterClassWithInfo.class);
+        // If present, run AfterClass, then AfterClassWithInfo
+        if (!aftersWithDevice.isEmpty()) {
+            s = new RunAftersWithInfo(s, aftersWithDevice, mTestInformation);
+        }
+        return super.withAfterClasses(s);
+  }
 }
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
index 4a0525885..ae1ecd69d 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
@@ -136,6 +136,13 @@ public class MoblyBinaryHostTest
     @Option(name = "mobly-std-log", description = "Print mobly logs to standard outputs")
     private boolean mStdLog = false;
 
+    @Option(
+            name = "use-list-tests",
+            description =
+                    "Use the list-tests feature to obtain the expected tests. This is necessary for"
+                            + " sharding.")
+    private boolean mListTests = true;
+
     private ITestDevice mDevice;
     private IBuildInfo mBuildInfo;
     private File mLogDir;
@@ -375,6 +382,8 @@ public class MoblyBinaryHostTest
             getRunUtil().setEnvVariable(ANDROID_SERIAL_VAR, getDevice().getSerialNumber());
         }
         AdbUtils.updateAdb(mTestInfo, getRunUtil(), getAdbPath());
+        // Set cwd to the binary directory
+        getRunUtil().setWorkingDir(new File(parFilePath).getParentFile());
         String configPath = null;
         if (mConfigFileName != null || mWildcardConfig) {
             try {
@@ -390,65 +399,70 @@ public class MoblyBinaryHostTest
                 return;
             }
         }
-        CommandResult list_result =
-                getRunUtil().runTimedCmd(60000, parFilePath, "--", "--list_tests");
-        if (!CommandStatus.SUCCESS.equals(list_result.getStatus())) {
-            String message;
-            if (CommandStatus.TIMED_OUT.equals(list_result.getStatus())) {
-                message = "Unable to list tests from the python binary: Timed out";
-            } else {
-                message =
-                        "Unable to list tests from the python binary\nstdout: "
-                                + list_result.getStdout()
-                                + "\nstderr: "
-                                + list_result.getStderr();
+        List<String> includedTests = Collections.emptyList();
+        long startTime = System.currentTimeMillis();
+        if (mListTests) {
+            CommandResult list_result =
+                    getRunUtil().runTimedCmd(60000, parFilePath, "--", "--list_tests");
+            if (!CommandStatus.SUCCESS.equals(list_result.getStatus())) {
+                String message;
+                if (CommandStatus.TIMED_OUT.equals(list_result.getStatus())) {
+                    message = "Unable to list tests from the python binary: Timed out";
+                } else {
+                    message =
+                            "Unable to list tests from the python binary\nstdout: "
+                                    + list_result.getStdout()
+                                    + "\nstderr: "
+                                    + list_result.getStderr();
+                }
+                reportFailure(listener, runName, message);
+                return;
             }
-            reportFailure(listener, runName, message);
-            return;
-        }
-        // Compute filtered tests.
-        Optional<Pair<List<String>, List<String>>> filteredTests =
-                filterTests(
-                        list_result.getStdout().split(System.lineSeparator()), runName, listener);
-        if (filteredTests.isEmpty()) {
-            // An empty option here mean a failure has already been reported in `filterTests`,
-            // just return.
-            return;
-        }
-        List<String> allTests = filteredTests.get().first;
-        List<String> includedTests = filteredTests.get().second;
-        CLog.d("All tests: %s", allTests);
-        CLog.d("Included tests: %s", includedTests);
-
-        // Split test across shards.
-        int totalTests = includedTests.size();
-        int chunkSize = totalTests / totalShards;
-        if (totalTests % totalShards > 0) chunkSize++;
-        // Ensure shards beyond the number of available tests get no tests
-        if (shardIndex >= totalTests) {
-            includedTests = Collections.emptyList();
-        } else {
-            int startIndex = shardIndex * chunkSize;
-            int endIndex = Math.min((shardIndex + 1) * chunkSize, totalTests);
-            if (startIndex >= totalTests) {
-                startIndex = Math.max(0, totalTests - 1);
-                endIndex = totalTests;
+            // Compute filtered tests.
+            Optional<Pair<List<String>, List<String>>> filteredTests =
+                    filterTests(
+                            list_result.getStdout().split(System.lineSeparator()),
+                            runName,
+                            listener);
+            if (filteredTests.isEmpty()) {
+                // An empty option here mean a failure has already been reported in `filterTests`,
+                // just return.
+                return;
             }
-            includedTests = includedTests.subList(startIndex, endIndex);
-        }
-        int testCount = includedTests.size();
+            List<String> allTests = filteredTests.get().first;
+            includedTests = filteredTests.get().second;
+            CLog.d("All tests: %s", allTests);
+            CLog.d("Included tests: %s", includedTests);
+
+            // Split test across shards.
+            int totalTests = includedTests.size();
+            int chunkSize = totalTests / totalShards;
+            if (totalTests % totalShards > 0) chunkSize++;
+            // Ensure shards beyond the number of available tests get no tests
+            if (shardIndex >= totalTests) {
+                includedTests = Collections.emptyList();
+            } else {
+                int startIndex = shardIndex * chunkSize;
+                int endIndex = Math.min((shardIndex + 1) * chunkSize, totalTests);
+                if (startIndex >= totalTests) {
+                    startIndex = Math.max(0, totalTests - 1);
+                    endIndex = totalTests;
+                }
+                includedTests = includedTests.subList(startIndex, endIndex);
+            }
+            int testCount = includedTests.size();
 
-        // Start run.
-        long startTime = System.currentTimeMillis();
-        listener.testRunStarted(runName, testCount);
-        // No test to run, abort early.
-        if (testCount == 0) {
-            listener.testRunEnded(0, new HashMap<String, String>());
-            return;
-        }
-        // Do not pass tests to command line if all included.
-        if (includedTests.size() == allTests.size()) {
-            includedTests.clear();
+            // Start run.
+            listener.testRunStarted(runName, testCount);
+            // No test to run, abort early.
+            if (testCount == 0) {
+                listener.testRunEnded(0, new HashMap<String, String>());
+                return;
+            }
+            // Do not pass tests to command line if all included.
+            if (includedTests.size() == allTests.size()) {
+                includedTests.clear();
+            }
         }
         String[] command = buildCommandLineArray(parFilePath, configPath, includedTests);
         ExecutorService executor = Executors.newSingleThreadExecutor();
@@ -463,7 +477,7 @@ public class MoblyBinaryHostTest
                             return getRunUtil().runTimedCmd(getTestTimeout(), command);
                         },
                         executor);
-        MoblyYamlResultParser parser = new MoblyYamlResultParser(listener);
+        MoblyYamlResultParser parser = new MoblyYamlResultParser(listener, runName, !mListTests);
         File yamlSummaryFile = null;
         InputStream inputStream = null;
         boolean reportRunFailed = true;
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
index 58ae60dfa..2d45efe79 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
@@ -45,15 +45,19 @@ public class MoblyYamlResultParser {
     private static final String TYPE = "Type";
     private ImmutableList.Builder<ITestInvocationListener> mListenersBuilder =
             new ImmutableList.Builder<>();
-    private ImmutableList.Builder<ITestResult> mResultCacheBuilder = new ImmutableList.Builder<>();
+    private String mRunName;
+    private boolean mReportRunStart = false;
     private long mRunStartTime;
     private long mRunEndTime;
     private boolean mEnded;
     private boolean mRunFailed;
     private StringBuilder mYamlString = new StringBuilder();
 
-    public MoblyYamlResultParser(ITestInvocationListener listener) {
+    public MoblyYamlResultParser(
+            ITestInvocationListener listener, String runName, boolean reportRunStart) {
         mListenersBuilder.add(listener);
+        mRunName = runName;
+        mReportRunStart = reportRunStart;
     }
 
     public boolean parse(InputStream inputStream)
@@ -107,6 +111,15 @@ public class MoblyYamlResultParser {
             List<IMoblyYamlResultHandler.ITestResult> resultCache) {
         for (IMoblyYamlResultHandler.ITestResult result : resultCache) {
             switch (result.getType()) {
+                case TEST_NAME_LIST:
+                    if (mReportRunStart) {
+                        MoblyYamlResultTestNameListHandler.TestNameList testList =
+                                (MoblyYamlResultTestNameListHandler.TestNameList) result;
+                        for (ITestInvocationListener listener : listeners) {
+                            listener.testRunStarted(mRunName, testList.getTestList().size());
+                        }
+                    }
+                    break;
                 case RECORD:
                     MoblyYamlResultRecordHandler.Record record =
                             (MoblyYamlResultRecordHandler.Record) result;
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultTestNameListHandler.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultTestNameListHandler.java
index 063c8c87d..3fd7acb0d 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultTestNameListHandler.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultTestNameListHandler.java
@@ -16,20 +16,29 @@
 
 package com.android.tradefed.testtype.mobly;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
 
 /** Mobly yaml result 'Test Name List' element handler. */
 public class MoblyYamlResultTestNameListHandler implements IMoblyYamlResultHandler {
 
+    private static final String REQUESTED_TESTS = "Requested Tests";
+
     @Override
     public TestNameList handle(Map<String, Object> docMap) {
         TestNameList.Builder builder = TestNameList.builder();
+        builder.addTests((List<String>) docMap.get(REQUESTED_TESTS));
         return builder.build();
     }
 
     public static class TestNameList implements ITestResult {
 
-        private TestNameList() {}
+        private List<String> testList = new ArrayList<>();
+
+        private TestNameList(List<String> testList) {
+            this.testList.addAll(testList);
+        }
 
         @Override
         public MoblyYamlResultHandlerFactory.Type getType() {
@@ -40,10 +49,22 @@ public class MoblyYamlResultTestNameListHandler implements IMoblyYamlResultHandl
             return new Builder();
         }
 
+        public List<String> getTestList() {
+            return testList;
+        }
+
         public static class Builder {
 
+            private List<String> testList = new ArrayList<>();
+
             public TestNameList build() {
-                return new TestNameList();
+                return new TestNameList(testList);
+            }
+
+            public void addTests(List<String> tests) {
+                if (tests != null) {
+                    testList.addAll(tests);
+                }
             }
         }
     }
diff --git a/test_framework/com/android/tradefed/testtype/pandora/OWNERS b/test_framework/com/android/tradefed/testtype/pandora/OWNERS
index d4db0303e..157e3d8ff 100644
--- a/test_framework/com/android/tradefed/testtype/pandora/OWNERS
+++ b/test_framework/com/android/tradefed/testtype/pandora/OWNERS
@@ -1,3 +1,4 @@
 girardier@google.com
-licorne@google.com
 charliebout@google.com
+wescande@google.com
+henrichataing@google.com
diff --git a/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java b/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
index ac97529ee..85b7a314c 100644
--- a/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
+++ b/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
@@ -32,6 +32,7 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.IShardableTest;
 import com.android.tradefed.testtype.ITestFilterReceiver;
@@ -76,7 +77,6 @@ import java.util.stream.Collectors;
  * https://www.bluetooth.com/develop-with-bluetooth/qualification-listing/qualification-test-tools/profile-tuning-suite/).
  */
 public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableTest, ITestLogger {
-
     private static final String TAG = "PandoraPtsBot";
 
     // This is the fixed port of the Pandora gRPC server running on the DUT.
@@ -115,11 +115,6 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
     // does not explicitly close the underlying BLE ACL link.
     private static final int PTS_INACTIVITY_TIMEOUT = 90;
 
-    private static final String A2DP_SNK_PROPERTY = "bluetooth.profile.a2dp.sink.enabled";
-    private static final String A2DP_SRC_PROPERTY = "bluetooth.profile.a2dp.source.enabled";
-    private static final String HFP_HF_PROPERTY = "bluetooth.profile.hfp.hf.enabled";
-    private static final String HFP_AG_PROPERTY = "bluetooth.profile.hfp.ag.enabled";
-
     private static final String NATIVE_BLUETOOTH_FLAG =
             "setprop persist.device_config.aconfig_flags.bluetooth.com.android.bluetooth.flags";
 
@@ -132,7 +127,17 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         }
     }
 
-    private TestFlagConfiguration testFlagConfiguration;
+    public class TestSyspropConfiguration {
+        List<SyspropConfig> system_properties; // snake_case naming to match the json
+
+        public class SyspropConfig {
+            Map<String, String> system_properties;
+            List<String> tests;
+        }
+    }
+
+    private TestFlagConfiguration mTestFlagConfiguration;
+    private TestSyspropConfiguration mTestSyspropConfiguration;
 
     private IRunUtil mRunUtil = new RunUtil();
 
@@ -228,7 +233,11 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
     }
 
     public TestFlagConfiguration getTestFlagConfiguration() {
-        return testFlagConfiguration;
+        return mTestFlagConfiguration;
+    }
+
+    public TestSyspropConfiguration getSyspropConfiguration() {
+        return mTestSyspropConfiguration;
     }
 
     private int shardIndex = 0;
@@ -317,6 +326,10 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         // flags value.
         initFlagsConfig(testDevice, testsConfigFile);
 
+        // Parse the properties config file and initialize the default
+        // sysprops' values.
+        initSystemPropertiesConfig(testsConfigFile);
+
         // Forward allocated host Pandora Server port to actual DUT Pandora
         // Server ports.
         hostPandoraServerPort = adbForwardPort(testDevice, 0, PANDORA_SERVER_PORT);
@@ -483,6 +496,36 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         throw new RuntimeException(String.format("Cannot list tests for %s", profile));
     }
 
+    private Map<String, String> setPropertiesBeforeTest(String testName, ITestDevice testDevice) {
+        Map<String, String> restoreSyspropConfiguration = new HashMap<>();
+
+        for (TestSyspropConfiguration.SyspropConfig syspropConfig :
+                mTestSyspropConfiguration.system_properties) {
+            if (syspropConfig.tests.stream().anyMatch(testName::startsWith)
+                    || syspropConfig.tests.stream().anyMatch("all"::equals)) {
+                for (Map.Entry<String, String> entry : syspropConfig.system_properties.entrySet()) {
+                    String currentValue = getProperty(testDevice, entry.getKey());
+                    // Save current value to restore it after the test
+                    restoreSyspropConfiguration.put(entry.getKey(), currentValue);
+                    // Set the value from the config
+                    setProperty(testDevice, entry.getKey(), entry.getValue());
+                }
+            }
+        }
+        return restoreSyspropConfiguration;
+    }
+
+    private void restorePropertiesAfterTest(
+            ITestDevice testDevice, Map<String, String> restoreSyspropConfiguration) {
+        if (restoreSyspropConfiguration == null) {
+            CLog.e("Unable to restore sysprops - configuration is null");
+            return;
+        }
+        for (Map.Entry<String, String> entry : restoreSyspropConfiguration.entrySet()) {
+            setProperty(testDevice, entry.getKey(), entry.getValue());
+        }
+    }
+
     private void runPtsBotTests(
             String[] tests, TestInformation testInfo, ITestInvocationListener listener) {
 
@@ -498,57 +541,74 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
                             .filter(testName -> testName.startsWith(profile))
                             .toArray(String[]::new);
 
-            if (profileTests.length > 0) {
-                Map<String, String> runMetrics = new HashMap<>();
-
-                listener.testRunStarted(profile, profileTests.length);
-                ITestDevice testDevice = testInfo.getDevice();
-                long startTimestamp = System.currentTimeMillis();
-                for (String testName : profileTests) {
-                    toggleA2dpSinkIfNeeded(testDevice, testName);
-                    toggleHfpHfIfNeeded(testDevice, testName);
-                    boolean matchingFlagConfig = false;
-                    boolean unflagged = false;
-                    for (TestFlagConfiguration.FlagConfig flagConfig :
-                            testFlagConfiguration.flags) {
-                        if (flagConfig.tests.stream().anyMatch(testName::startsWith)) {
-                            matchingFlagConfig = true;
-                            flagConfig.flags.forEach(flag -> enableBluetoothFlag(testDevice, flag));
-                            runPtsBotTest(profile, testName, testInfo, listener);
-                            flagConfig.flags.forEach(
-                                    flag -> restoreBluetoothFlag(testDevice, flag));
-
-                            if (flagConfig.flags.stream().anyMatch("unflagged"::equals)) {
-                                unflagged = true;
-                            }
-                        }
-                    }
-                    if (!matchingFlagConfig || unflagged) {
-                        runPtsBotTest(profile, testName, testInfo, listener);
-                    }
-                    try {
-                        File snoopFile = FileUtil.createTempFile("android_snoop_log", ".log");
-                        testDevice.pullFile("/data/misc/bluetooth/logs/btsnoop_hci.log", snoopFile);
-                        try (InputStreamSource source =
-                                new FileInputStreamSource(snoopFile, true)) {
-                            listener.testLog(
-                                    String.format("android_btsnoop_%s", testName),
-                                    LogDataType.BT_SNOOP_LOG,
-                                    source);
-                        }
-                    } catch (DeviceNotAvailableException | IOException e) {
-                        CLog.e("Cannot fetch Android snoop logs: " + e.toString());
+            if (profileTests.length == 0) {
+                CLog.i("No tests applicable for %s", profile);
+                continue;
+            }
+            Map<String, String> runMetrics = new HashMap<>();
+
+            listener.testRunStarted(profile, profileTests.length);
+            ITestDevice testDevice = testInfo.getDevice();
+            long startTimestamp = System.currentTimeMillis();
+            for (String testName : profileTests) {
+                Map<String, String> restoreSyspropConfiguration =
+                        setPropertiesBeforeTest(testName, testDevice);
+                runPtsBotTestWithFlag(profile, testName, testInfo, listener);
+                restorePropertiesAfterTest(testDevice, restoreSyspropConfiguration);
+                try {
+                    File snoopFile = FileUtil.createTempFile("android_snoop_log", ".log");
+                    testDevice.pullFile("/data/misc/bluetooth/logs/btsnoop_hci.log", snoopFile);
+                    try (InputStreamSource source = new FileInputStreamSource(snoopFile, true)) {
+                        listener.testLog(
+                                String.format("android_btsnoop_%s", testName),
+                                LogDataType.BT_SNOOP_LOG,
+                                source);
                     }
+                } catch (DeviceNotAvailableException | IOException e) {
+                    CLog.e("Cannot fetch Android snoop logs: " + e.toString());
                 }
-                long endTimestamp = System.currentTimeMillis();
-                listener.testRunEnded(endTimestamp - startTimestamp, runMetrics);
-            } else {
-                CLog.i("No tests applicable for %s", profile);
             }
+            long endTimestamp = System.currentTimeMillis();
+            listener.testRunEnded(endTimestamp - startTimestamp, runMetrics);
+        }
+    }
+
+    private void runPtsBotTestWithFlag(
+            String profile,
+            String testName,
+            TestInformation testInfo,
+            ITestInvocationListener listener) {
+        ITestDevice testDevice = testInfo.getDevice();
+        boolean matchingFlagConfig = false;
+        // If specified in the config, will run the test both with and without flags.
+        // This allow to test "no-op" flag before releasing them
+        boolean unflagged = false;
+        for (TestFlagConfiguration.FlagConfig flagConfig : mTestFlagConfiguration.flags) {
+            if (!flagConfig.tests.stream().anyMatch(testName::startsWith)) {
+                continue;
+            }
+            if (flagConfig.flags.stream().anyMatch("unflagged"::equals)) {
+                unflagged = true;
+            }
+            matchingFlagConfig = true;
+            if (flagConfig.flags.stream().anyMatch(f -> isFlagDisabledAndReadOnly(testDevice, f))) {
+                TestDescription testDescription = new TestDescription(profile, testName);
+                SkipReason reason =
+                        new SkipReason("The test device doesn't support flag override", "");
+                Log.w(testDevice, "Test Ended [Skipped]: " + testName + " " + reason);
+                listener.testSkipped(testDescription, reason);
+                continue;
+            }
+            flagConfig.flags.forEach(flag -> enableBluetoothFlag(testDevice, flag));
+            runPtsBotTest(profile, testName, testInfo, listener);
+            flagConfig.flags.forEach(flag -> restoreBluetoothFlag(testDevice, flag));
+        }
+        if (!matchingFlagConfig || unflagged) {
+            runPtsBotTest(profile, testName, testInfo, listener);
         }
     }
 
-    private void shell(ITestDevice testDevice, String cmd) {
+    private static void shell(ITestDevice testDevice, String cmd) {
         try {
             CommandResult cmdResult = testDevice.executeShellV2Command(cmd);
             if (cmdResult.getExitCode() != 0) {
@@ -559,7 +619,60 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         }
     }
 
+    private boolean isFlagEnabledAndReadOnly(ITestDevice testDevice, String flag) {
+        try {
+            String cmd = "aflags list -c com.android.bt | grep 'flags." + flag + " '";
+            CommandResult cmdResult = testDevice.executeShellV2Command(cmd);
+            if (cmdResult.getExitCode() != 0) {
+                CLog.e("Failed to run" + cmd + ": " + cmdResult.getStderr());
+                return false;
+            }
+            String[] out = cmdResult.getStdout().trim().toLowerCase().split("\\R");
+            if (out.length != 1) {
+                CLog.e(
+                        "Check the config or the target for flag=%s. out=[%s]",
+                        flag, Arrays.toString(out));
+                return false;
+            }
+            CLog.v("Flag is: [[" + out[0] + "]]");
+            return out[0].matches(
+                    "com.android.bluetooth.flags." + flag + " .*enabled.*read-only.*");
+        } catch (DeviceNotAvailableException e) {
+            CLog.e("Device not available: " + e);
+            return false;
+        }
+    }
+
+    private boolean isFlagDisabledAndReadOnly(ITestDevice testDevice, String flag) {
+        try {
+            String cmd = "aflags list -c com.android.bt | grep 'flags." + flag + " '";
+            CommandResult cmdResult = testDevice.executeShellV2Command(cmd);
+            if (cmdResult.getExitCode() != 0) {
+                CLog.e("Failed to run" + cmd + ": " + cmdResult.getStderr());
+                return true;
+            }
+            String[] out = cmdResult.getStdout().trim().split("\\R");
+            if (out.length != 1) {
+                CLog.e(
+                        "Check the config or the target for flag=%s. out=[%s]",
+                        flag, Arrays.toString(out));
+                return true;
+            }
+            CLog.v("Flag is: [[" + out[0] + "]]");
+            return !out[0].matches(
+                    "com.android.bluetooth.flags." + flag + " .*(enabled.*read-only|read-write).*");
+        } catch (DeviceNotAvailableException e) {
+            CLog.e("Device not available: " + e);
+            return true;
+        }
+    }
+
     private void enableBluetoothFlag(ITestDevice testDevice, String flag) {
+        if (isFlagEnabledAndReadOnly(testDevice, flag)) {
+            Log.i(testDevice, "enableBluetoothFlag: skip %s: already ENABLED + READ_ONLY", flag);
+            return;
+        }
+        Log.i(testDevice, "enableBluetoothFlag: %s", flag);
         String setNativeFlagCmd = String.format("%s.%s true", NATIVE_BLUETOOTH_FLAG, flag);
         shell(testDevice, setNativeFlagCmd);
 
@@ -571,6 +684,11 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
     }
 
     private void restoreBluetoothFlag(ITestDevice testDevice, String flag) {
+        if (isFlagEnabledAndReadOnly(testDevice, flag)) {
+            Log.i(testDevice, "enableBluetoothFlag: skip %s: already ENABLED + READ_ONLY", flag);
+            return;
+        }
+        Log.i(testDevice, "restoreBluetoothFlag: %s", flag);
         String clearOverrideCmd =
                 String.format(
                         "device_config clear_override bluetooth com.android.bluetooth.flags.%s",
@@ -586,46 +704,27 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         try {
             Gson gson = new Gson();
             FileReader reader = new FileReader(testConfigFile);
-            testFlagConfiguration = gson.fromJson(reader, TestFlagConfiguration.class);
-            List<TestFlagConfiguration.FlagConfig> flags = testFlagConfiguration.flags;
-            if (flags.isEmpty()) {
-                return;
-            }
+            mTestFlagConfiguration = gson.fromJson(reader, TestFlagConfiguration.class);
         } catch (IOException | JsonSyntaxException e) {
             CLog.e("Error initFlagsConfig: " + e);
         }
     }
 
-    private void toggleA2dpSinkIfNeeded(ITestDevice testDevice, String testName) {
-        CLog.i("toggleA2dpSinkIfNeeded: " + testName);
-        if (testName.startsWith("A2DP/SNK")
-                || testName.startsWith("AVCTP/CT")
-                || testName.startsWith("AVDTP/SNK")
-                || (testName.startsWith("AVRCP/CT") && !testName.startsWith("AVRCP/CT/VLH"))
-                || testName.startsWith("AVRCP/TG/VLH")) {
-            setProperty(testDevice, A2DP_SNK_PROPERTY, true);
-            setProperty(testDevice, A2DP_SRC_PROPERTY, false);
-        } else if (!getProperty(testDevice, A2DP_SRC_PROPERTY).equals("true")) {
-            setProperty(testDevice, A2DP_SNK_PROPERTY, false);
-            setProperty(testDevice, A2DP_SRC_PROPERTY, true);
-        }
-    }
-
-    private void toggleHfpHfIfNeeded(ITestDevice testDevice, String testName) {
-        CLog.i("toggleHfpHfIfNeeded: " + testName);
-        if (testName.startsWith("HFP/HF")) {
-            setProperty(testDevice, HFP_HF_PROPERTY, true);
-            setProperty(testDevice, HFP_AG_PROPERTY, false);
-        } else if (!getProperty(testDevice, HFP_HF_PROPERTY).equals("true")) {
-            setProperty(testDevice, HFP_HF_PROPERTY, false);
-            setProperty(testDevice, HFP_AG_PROPERTY, true);
+    public void initSystemPropertiesConfig(File testConfigFile) {
+        CLog.i("initSystemPropertiesConfig");
+        try {
+            Gson gson = new Gson();
+            FileReader reader = new FileReader(testConfigFile);
+            mTestSyspropConfiguration = gson.fromJson(reader, TestSyspropConfiguration.class);
+        } catch (IOException | JsonSyntaxException e) {
+            CLog.e("Error initSystemPropertiesConfig: " + e);
         }
     }
 
-    private void setProperty(ITestDevice testDevice, String property, boolean enable) {
-        CLog.i("setProperty: " + property);
+    private void setProperty(ITestDevice testDevice, String property, String value) {
+        Log.i(testDevice, "setProperty: " + property + " value: " + value);
         try {
-            String cmd = String.format("setprop %s %s", property, enable);
+            String cmd = String.format("setprop %s %s", property, (value != null ? value : ""));
             CommandResult result = testDevice.executeShellV2Command(cmd);
             if (result.getExitCode() != 0) {
                 CLog.e("Failed to set property: " + property + ": " + result.getStderr());
@@ -636,7 +735,7 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
     }
 
     private String getProperty(ITestDevice testDevice, String property) {
-        CLog.i("getProperty: " + property);
+        Log.i(testDevice, "getProperty: " + property);
         try {
             String cmd = String.format("getprop %s", property);
             CommandResult result = testDevice.executeShellV2Command(cmd);
@@ -659,8 +758,7 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         TestDescription testDescription = new TestDescription(profile, testName);
 
         listener.testStarted(testDescription);
-        CLog.i(testName);
-        androidLogInfo(testInfo.getDevice(), "Test Started: " + testName);
+        Log.i(testInfo.getDevice(), "Test Started: " + testName);
 
         boolean success = false;
         boolean inconclusive = false;
@@ -734,7 +832,7 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
             // At the first retry, increment flaky tests count.
             if (retryCount == 1) flakyCount++;
             if (flakyCount <= maxFlakyTests && retryCount <= maxRetriesPerTest) {
-                androidLogWarning(
+                Log.w(
                         testInfo.getDevice(),
                         String.format(
                                 "Test %s: %s, retrying [count=%s]",
@@ -745,9 +843,9 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         }
 
         if (success) {
-            androidLogInfo(testInfo.getDevice(), "Test Ended [Success]: " + testName);
+            Log.i(testInfo.getDevice(), "Test Ended [Success]: " + testName);
         } else {
-            androidLogError(testInfo.getDevice(), "Test Ended [Failed]: " + testName);
+            Log.e(testInfo.getDevice(), "Test Ended [Failed]: " + testName);
             listener.testFailed(
                     testDescription,
                     String.format(
@@ -801,7 +899,7 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         return builder;
     }
 
-    private int adbForwardPort(ITestDevice testDevice, int hostPort, int dutPort)
+    private static int adbForwardPort(ITestDevice testDevice, int hostPort, int dutPort)
             throws DeviceNotAvailableException {
         return Integer.parseInt(
                 testDevice
@@ -812,7 +910,8 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
                         .trim());
     }
 
-    private int adbForwardVsockPort(ITestDevice testDevice, int hostPort, int dutCid, int dutPort)
+    private static int adbForwardVsockPort(
+            ITestDevice testDevice, int hostPort, int dutCid, int dutPort)
             throws DeviceNotAvailableException {
         return Integer.parseInt(
                 testDevice
@@ -823,12 +922,12 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
                         .trim());
     }
 
-    private void adbForwardRemovePort(ITestDevice testDevice, int hostPort)
+    private static void adbForwardRemovePort(ITestDevice testDevice, int hostPort)
             throws DeviceNotAvailableException {
         testDevice.executeAdbCommand("forward", "--remove", String.format("tcp:%s", hostPort));
     }
 
-    private void androidLog(ITestDevice testDevice, String priority, String content) {
+    private static void androidLog(ITestDevice testDevice, String priority, String content) {
         try {
             String timeStamp = new SimpleDateFormat("HH:mm:ss.SSS").format(new Date());
             String command =
@@ -847,15 +946,24 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         }
     }
 
-    private void androidLogInfo(ITestDevice testDevice, String content) {
-        androidLog(testDevice, "i", content);
-    }
+    // Log simultaneously in host and in android
+    static class Log {
+        public static void i(ITestDevice testDevice, String format, Object... args) {
+            String content = String.format(format, args);
+            androidLog(testDevice, "i", content);
+            CLog.i(content);
+        }
 
-    private void androidLogWarning(ITestDevice testDevice, String content) {
-        androidLog(testDevice, "w", content);
-    }
+        public static void w(ITestDevice testDevice, String format, Object... args) {
+            String content = String.format(format, args);
+            androidLog(testDevice, "w", content);
+            CLog.w(content);
+        }
 
-    private void androidLogError(ITestDevice testDevice, String content) {
-        androidLog(testDevice, "e", content);
+        public static void e(ITestDevice testDevice, String format, Object... args) {
+            String content = String.format(format, args);
+            androidLog(testDevice, "e", content);
+            CLog.e(content);
+        }
     }
 }
diff --git a/test_framework/com/android/tradefed/testtype/rust/RustBinaryTest.java b/test_framework/com/android/tradefed/testtype/rust/RustBinaryTest.java
index 85d5f38ff..fd6f3cc54 100644
--- a/test_framework/com/android/tradefed/testtype/rust/RustBinaryTest.java
+++ b/test_framework/com/android/tradefed/testtype/rust/RustBinaryTest.java
@@ -16,11 +16,10 @@
 
 package com.android.tradefed.testtype.rust;
 
-import static com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain.GCOV;
+import static com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain.CLANG;
 
 import com.android.ddmlib.FileListingService;
 import com.android.ddmlib.IShellOutputReceiver;
-import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
@@ -54,16 +53,8 @@ public class RustBinaryTest extends RustTestBase implements IDeviceTest, IConfig
     @Option(name = "module-name", description = "The name of the test module to run.")
     private String mTestModule = null;
 
-    private IConfiguration mConfiguration = null;
-
     private ITestDevice mDevice = null;
 
-    /** {@inheritDoc} */
-    @Override
-    public void setConfiguration(IConfiguration configuration) {
-        mConfiguration = configuration;
-    }
-
     /** {@inheritDoc} */
     @Override
     public void setDevice(ITestDevice device) {
@@ -202,9 +193,7 @@ public class RustBinaryTest extends RustTestBase implements IDeviceTest, IConfig
      * @param fullPath absolute file system path to rust binary on device
      * @throws DeviceNotAvailableException
      */
-    private void runTest(
-            final ITestInvocationListener listener,
-            final String fullPath)
+    private void runTest(final ITestInvocationListener listener, final String fullPath)
             throws DeviceNotAvailableException {
         CLog.d("RustBinaryTest runTest: " + fullPath);
         File file = new File(fullPath);
@@ -229,9 +218,11 @@ public class RustBinaryTest extends RustTestBase implements IDeviceTest, IConfig
         String name = new File(fullPath).getName();
         listener.testRunStarted(name, testCount, 0, startTimeMs);
         for (Invocation invocation : invocations) {
-            if (mConfiguration != null
-                    && mConfiguration.getCoverageOptions().getCoverageToolchains().contains(GCOV)) {
-                invocation.env.add(new EnvPair("GCOV_PREFIX", "/data/misc/trace"));
+            if (isClangCoverageEnabled()) {
+                invocation.env.add(
+                        new EnvPair(
+                                "LLVM_PROFILE_FILE",
+                                "/data/local/tmp/clang-%m.profraw "));
             }
 
             IShellOutputReceiver resultParser = createParser(listener, name);
@@ -276,4 +267,9 @@ public class RustBinaryTest extends RustTestBase implements IDeviceTest, IConfig
             wrongTestPath("No test found under ", testPath, listener);
         }
     }
+
+    private boolean isClangCoverageEnabled() {
+        return getConfiguration().getCoverageOptions().isCoverageEnabled()
+                && getConfiguration().getCoverageOptions().getCoverageToolchains().contains(CLANG);
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/suite/AtestRunner.java b/test_framework/com/android/tradefed/testtype/suite/AtestRunner.java
index 832e0d3c3..492848d9e 100644
--- a/test_framework/com/android/tradefed/testtype/suite/AtestRunner.java
+++ b/test_framework/com/android/tradefed/testtype/suite/AtestRunner.java
@@ -18,6 +18,7 @@ package com.android.tradefed.testtype.suite;
 import com.android.tradefed.config.ConfigurationFactory;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationFactory;
+import com.android.tradefed.config.IDeviceConfiguration;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.Option.Importance;
 import com.android.tradefed.config.OptionCopier;
@@ -280,9 +281,11 @@ public class AtestRunner extends BaseTestSuite {
      */
     private static void setIncrementalSetupEnabledForTargetPreparers(
         IConfiguration testConfig, boolean shouldEnable) {
-        for (ITargetPreparer targetPreparer : testConfig.getTargetPreparers()) {
-            if (targetPreparer instanceof IIncrementalSetup) {
-                ((IIncrementalSetup) targetPreparer).setIncrementalSetupEnabled(shouldEnable);
+        for (IDeviceConfiguration deviceConfig : testConfig.getDeviceConfig()) {
+            for (ITargetPreparer targetPreparer : deviceConfig.getTargetPreparers()) {
+                if (targetPreparer instanceof IIncrementalSetup) {
+                    ((IIncrementalSetup) targetPreparer).setIncrementalSetupEnabled(shouldEnable);
+                }
             }
         }
     }
diff --git a/test_observatory/com/android/tradefed/observatory/ConfigurationCtsParserSettings.java b/test_observatory/com/android/tradefed/observatory/ConfigurationCtsParserSettings.java
index 73b8737ff..6b3d45bb0 100644
--- a/test_observatory/com/android/tradefed/observatory/ConfigurationCtsParserSettings.java
+++ b/test_observatory/com/android/tradefed/observatory/ConfigurationCtsParserSettings.java
@@ -18,9 +18,12 @@ package com.android.tradefed.observatory;
 
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.config.filter.GlobalTestFilter;
 
 import java.util.ArrayList;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 
 /**
  * A simple class to accept settings for the ConfigurationCtsParserSettings
@@ -35,6 +38,16 @@ public class ConfigurationCtsParserSettings {
             description = "This option is for the purpose of filtering in all of its values.")
     public List<String> mCtsParams = new ArrayList<>();
 
+    @Option(
+            name = GlobalTestFilter.STRICT_INCLUDE_FILTER_OPTION,
+            description =
+                    "Filters applied to the invocation. Format: [abi] [module-name]"
+                            + " [test-class][#method-name]. All other filters "
+                            + "will be ignored to strictly run this set."
+                            + "This is still best-effort as not all runners "
+                            + "support filtering equally.")
+    public Set<String> mStrictIncludeFilters = new LinkedHashSet<>();
+
     @Option(
             name = "config-name",
             description = "This option is for the purpose of filtering in all of its values.")
diff --git a/test_observatory/com/android/tradefed/observatory/DiscoveryExitCode.java b/test_observatory/com/android/tradefed/observatory/DiscoveryExitCode.java
index 07fe9d9bb..d08fbc0d5 100644
--- a/test_observatory/com/android/tradefed/observatory/DiscoveryExitCode.java
+++ b/test_observatory/com/android/tradefed/observatory/DiscoveryExitCode.java
@@ -22,8 +22,8 @@ public enum DiscoveryExitCode {
     NO_DISCOVERY_POSSIBLE(6), // When the command doesn't have any properties useful for discovery.
     CONFIGURATION_EXCEPTION(7), // When the command itself doesn't parse
     DISCOVERY_RESULTS_CORREPUTED(8), // When the discovery results are corrupted.
-    ERROR(1);
-
+    ERROR(1),
+    HAS_NON_SUITE_BASED_TEST_RUNNER_ERROR(11);
     private final int code;
 
     private DiscoveryExitCode(int code) {
diff --git a/test_observatory/com/android/tradefed/observatory/IDiscoverTestClasses.java b/test_observatory/com/android/tradefed/observatory/IDiscoverTestClasses.java
new file mode 100644
index 000000000..2167d4064
--- /dev/null
+++ b/test_observatory/com/android/tradefed/observatory/IDiscoverTestClasses.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.observatory;
+
+import java.util.Set;
+
+/** Interface for discovering test classes. */
+public interface IDiscoverTestClasses {
+    /** Returns a set of test class names. */
+    Set<String> getClassNames();
+}
diff --git a/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java b/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
index ae73cfa7e..5253c793f 100644
--- a/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
+++ b/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
@@ -20,6 +20,7 @@ import com.android.ddmlib.DdmPreferences;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.filter.GlobalTestFilter;
 import com.android.tradefed.invoker.tracing.ActiveTrace;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.invoker.tracing.TracingLogger;
@@ -163,6 +164,15 @@ public class TestDiscoveryExecutor {
                         null,
                         DiscoveryExitCode.ERROR);
             }
+            if (!config.getGlobalFilters().getStrictIncludeFilters().isEmpty()) {
+                for (IRemoteTest test : tests) {
+                    if (test instanceof BaseTestSuite) {
+                        GlobalTestFilter.applyGlobalStrictFilters(
+                                (BaseTestSuite) test,
+                                config.getGlobalFilters().getStrictIncludeFilters());
+                    }
+                }
+            }
 
             List<String> testModules = new ArrayList<>(discoverTestModulesFromTests(tests));
             List<String> testDependencies = new ArrayList<>(discoverDependencies(config));
@@ -211,7 +221,7 @@ public class TestDiscoveryExecutor {
                             "Tradefed Observatory can't do test discovery on non suite-based test"
                                     + " runner.",
                             null,
-                            DiscoveryExitCode.ERROR);
+                            DiscoveryExitCode.HAS_NON_SUITE_BASED_TEST_RUNNER_ERROR);
                 }
                 if (test instanceof TestMappingSuiteRunner) {
                     ((TestMappingSuiteRunner) test).loadTestInfos();
diff --git a/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java b/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
index 5383b36b7..263d07e12 100644
--- a/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
+++ b/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
@@ -20,6 +20,7 @@ import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.config.ArgsOptionParser;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.filter.GlobalTestFilter;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
@@ -40,8 +41,8 @@ import com.android.tradefed.util.testmapping.TestMapping;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
-
 import com.google.common.base.Strings;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -78,11 +79,15 @@ public class TestDiscoveryInvoker {
     private IBuildInfo mBuildInfo;
     private ITestLogger mLogger;
 
+    private static final TestDiscoveryUtil mTestDiscoveryUtil = new TestDiscoveryUtil();
+
     public static final String TRADEFED_OBSERVATORY_ENTRY_PATH =
             TestDiscoveryExecutor.class.getName();
     public static final String TEST_DEPENDENCIES_LIST_KEY = "TestDependencies";
     public static final String TEST_MODULES_LIST_KEY = "TestModules";
     public static final String TEST_ZIP_REGEXES_LIST_KEY = "TestZipRegexes";
+
+    public static final String TEST_DISCOVERY_COMMENT_KEY = "TestDiscoveryComment";
     public static final String PARTIAL_FALLBACK_KEY = "PartialFallback";
     public static final String NO_POSSIBLE_TEST_DISCOVERY_KEY = "NoPossibleTestDiscovery";
     public static final String TEST_MAPPING_ZIP_FILE = "TF_TEST_MAPPING_ZIP_FILE";
@@ -107,6 +112,10 @@ public class TestDiscoveryInvoker {
 
     @VisibleForTesting
     File createOutputFile() throws IOException {
+        if (mTestDiscoveryUtil.hasOutputResultFile()) {
+            File presetOutputFile = new File(System.getenv(TestDiscoveryInvoker.OUTPUT_FILE));
+            return presetOutputFile;
+        }
         return FileUtil.createTempFile("discovery-output", ".txt");
     }
 
@@ -270,7 +279,11 @@ public class TestDiscoveryInvoker {
                 return dependencies;
             }
         } finally {
-            FileUtil.deleteFile(outputFile);
+            // Have output file set means other source is anticipating to read the output file.
+            // Therefore avoid deleting the output file if its set. (e.g. BWYN script)
+            if (!mTestDiscoveryUtil.hasOutputResultFile()) {
+                FileUtil.deleteFile(outputFile);
+            }
             try (FileInputStreamSource source = new FileInputStreamSource(traceFile, true)) {
                 if (mLogger != null) {
                     mLogger.testLog("discovery-trace", LogDataType.PERFETTO, source);
@@ -404,7 +417,11 @@ public class TestDiscoveryInvoker {
                 return dependencies;
             }
         } finally {
-            FileUtil.deleteFile(outputFile);
+            // Have output file set means other source is anticipating to read the output file.
+            // Therefore avoid deleting the output file if its set. (e.g. BWYN script)
+            if (!mTestDiscoveryUtil.hasOutputResultFile()) {
+                FileUtil.deleteFile(outputFile);
+            }
             try (FileInputStreamSource source = new FileInputStreamSource(traceFile, true)) {
                 if (mLogger != null) {
                     mLogger.testLog("discovery-trace", LogDataType.PERFETTO, source);
@@ -471,6 +488,10 @@ public class TestDiscoveryInvoker {
         ctsOptionParser.parseBestEffort(fullCommandLineArgs, true);
 
         List<String> ctsParams = ctsParserSettings.mCtsParams;
+        for (String globalFilter : ctsParserSettings.mStrictIncludeFilters) {
+            ctsParams.add("--" + GlobalTestFilter.STRICT_INCLUDE_FILTER_OPTION);
+            ctsParams.add(globalFilter);
+        }
         String configName = ctsParserSettings.mConfigName;
 
         if (configName == null) {
diff --git a/test_observatory/com/android/tradefed/observatory/TestDiscoveryUtil.java b/test_observatory/com/android/tradefed/observatory/TestDiscoveryUtil.java
index ed1713780..e98c6872b 100644
--- a/test_observatory/com/android/tradefed/observatory/TestDiscoveryUtil.java
+++ b/test_observatory/com/android/tradefed/observatory/TestDiscoveryUtil.java
@@ -36,6 +36,10 @@ public class TestDiscoveryUtil {
         return System.getenv(TestDiscoveryInvoker.OUTPUT_FILE) != null;
     }
 
+    public String getTestMappingFilePath() {
+        return System.getenv(TestDiscoveryInvoker.TEST_MAPPING_ZIP_FILE);
+    }
+
     protected String getEnvironment(String var) {
         return System.getenv(var);
     }
@@ -55,8 +59,20 @@ public class TestDiscoveryUtil {
                     Set.of(
                             Configuration.BUILD_PROVIDER_TYPE_NAME,
                             Configuration.TEST_TYPE_NAME,
-                            Configuration.TARGET_PREPARER_TYPE_NAME),
+                            Configuration.TARGET_PREPARER_TYPE_NAME,
+                            Configuration.GLOBAL_FILTERS_TYPE_NAME),
                     null);
         }
     }
+
+    /** Returns true if the command is a Tradefed command */
+    public boolean isTradefedConfiguration(String[] args) {
+        if (args[0].equals("testing/mobileharness/gateway")) {
+            return false;
+        }
+        if (args[0].equals("unused")) {
+            return false;
+        }
+        return true;
+    }
 }
diff --git a/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java b/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java
new file mode 100644
index 000000000..4e3a9b2aa
--- /dev/null
+++ b/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.observatory;
+
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.invoker.tracing.ActiveTrace;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.invoker.tracing.TracingLogger;
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.util.FileUtil;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A class serves as entry point for BWYN script to call by java command to do setup works for
+ * TestDiscoveryInvoker.
+ *
+ * <p>TestMappingDiscoveryAgent will consume the command line args, set the path to
+ * test_mapping.zip, pass down output file info and use TestDiscoveryInvoker to do test mapping test
+ * discovery.
+ *
+ * <p>
+ */
+public class TestMappingDiscoveryAgent {
+
+    private TestDiscoveryInvoker mTestDiscoveryInvoker;
+
+    private static final Set<String> VALIDATION_TEST_CLASS_NAMES =
+            new HashSet<String>(
+                    Arrays.asList(
+                            "com.android.tradefed.presubmit.DeviceTestsConfigValidation",
+                            "com.android.tradefed.presubmit.GeneralTestsConfigValidation"));
+
+    private static final Set<String> TEST_MAPPING_VALIDATION_TEST_CLASS_NAMES =
+            new HashSet<String>(
+                    Arrays.asList("com.android.tradefed.presubmit.TestMappingsValidation"));
+
+    private static final String VALIDATION_TEST_DISCOVERED_CASE_COMMENT =
+            "Discovered Validation Test";
+
+    private boolean isValidationTestDiscovered = false;
+
+    private TestMappingDiscoveryAgent() {
+        // Private constructor - prevents external instantiation.
+        // This class should only serve as an entry point, and should not be used anywhere inside
+        // TradeFed code.
+        mTestDiscoveryUtil = new TestDiscoveryUtil();
+    }
+
+    @VisibleForTesting
+    public TestMappingDiscoveryAgent(
+            TestDiscoveryInvoker testDiscoveryInvoker, TestDiscoveryUtil testDiscoveryUtil) {
+        mTestDiscoveryInvoker = testDiscoveryInvoker;
+        mTestDiscoveryUtil = testDiscoveryUtil;
+    }
+
+    public static Set<String> getTestMappingValidationTestClassNames() {
+        return TEST_MAPPING_VALIDATION_TEST_CLASS_NAMES;
+    }
+
+    public static Set<String> getValidationTestClassNames() {
+        return VALIDATION_TEST_CLASS_NAMES;
+    }
+
+    private static TestDiscoveryUtil mTestDiscoveryUtil;
+
+    /**
+     * Entry point from test suite build script, discover test modules from test mapping test.
+     *
+     * @param args the command line args of the test.
+     */
+    public static void main(String[] args) {
+        long pid = ProcessHandle.current().pid();
+        long tid = Thread.currentThread().getId();
+        ActiveTrace trace = TracingLogger.createActiveTrace(pid, tid);
+        trace.startTracing(false);
+        DiscoveryExitCode exitCode = DiscoveryExitCode.SUCCESS;
+        try (CloseableTraceScope ignored = new CloseableTraceScope("main_discovery")) {
+            TestMappingDiscoveryAgent testMappingDiscoveryAgent = new TestMappingDiscoveryAgent();
+            testMappingDiscoveryAgent.discoverTestMapping(args);
+        } catch (TestDiscoveryException e) {
+            System.err.print(e.getMessage());
+            if (e.exitCode() != null) {
+                exitCode = e.exitCode();
+            } else {
+                exitCode = DiscoveryExitCode.ERROR;
+            }
+        } catch (ConfigurationException e) {
+            System.err.print(e.getMessage());
+            exitCode = DiscoveryExitCode.CONFIGURATION_EXCEPTION;
+        } catch (Exception e) {
+            System.err.print(e.getMessage());
+            exitCode = DiscoveryExitCode.ERROR;
+        }
+        File traceFile = trace.finalizeTracing();
+        if (traceFile != null) {
+            if (System.getenv(TestDiscoveryInvoker.DISCOVERY_TRACE_FILE) != null) {
+                try {
+                    FileUtil.copyFile(
+                            traceFile,
+                            new File(System.getenv(TestDiscoveryInvoker.DISCOVERY_TRACE_FILE)));
+                } catch (IOException | RuntimeException e) {
+                    System.err.print(e.getMessage());
+                }
+            }
+            FileUtil.deleteFile(traceFile);
+        }
+        System.exit(exitCode.exitCode());
+    }
+
+    /**
+     * Do test discovery from a test mapping test config. Write discovery results to the output
+     * file. Will write a empty test module list to the output file if the test itself is validation
+     * test.
+     *
+     * @param args the command line args of the test.
+     * @throws IOException
+     * @throws JSONException
+     * @throws ConfigurationException
+     * @throws TestDiscoveryException
+     */
+    public void discoverTestMapping(String[] args)
+            throws ConfigurationException, TestDiscoveryException, JSONException, IOException {
+        IConfiguration config = mTestDiscoveryUtil.getConfiguration(args);
+
+        if (isValidationTestConfig(config)) {
+            System.out.print("Discovered that test config is a validation test.");
+            isValidationTestDiscovered = true;
+            // For validation tests, output an empty discovery result.
+            JSONObject j = new JSONObject();
+            j.put(TestDiscoveryInvoker.TEST_MODULES_LIST_KEY, new JSONArray());
+            j.put(TestDiscoveryInvoker.TEST_DEPENDENCIES_LIST_KEY, new JSONArray());
+            j.put(
+                    TestDiscoveryInvoker.TEST_DISCOVERY_COMMENT_KEY,
+                    VALIDATION_TEST_DISCOVERED_CASE_COMMENT);
+            if (mTestDiscoveryUtil.hasOutputResultFile()) {
+                FileUtil.writeToFile(
+                        j.toString(), new File(System.getenv(TestDiscoveryInvoker.OUTPUT_FILE)));
+            }
+        } else {
+            String currentDirectoryPath =
+                    TestMappingDiscoveryAgent.class
+                            .getProtectionDomain()
+                            .getCodeSource()
+                            .getLocation()
+                            .getPath();
+            if (mTestDiscoveryInvoker == null) {
+                mTestDiscoveryInvoker =
+                        new TestDiscoveryInvoker(
+                                config,
+                                null,
+                                new File(currentDirectoryPath).getParentFile(),
+                                false,
+                                true);
+            }
+            if (mTestDiscoveryUtil.getTestMappingFilePath() != null) {
+                mTestDiscoveryInvoker.setTestMappingZip(
+                        new File(mTestDiscoveryUtil.getTestMappingFilePath()));
+            }
+
+            // The result reporting happens in the side effect of the discovery method.
+            // TestDiscoveryInvoker will create an output file that follows its caller
+            // And by deleting the output file it allows the caller (e.g. BWYN script)
+            // to read the discovery result.
+            mTestDiscoveryInvoker.discoverTestMappingDependencies();
+        }
+    }
+
+    /**
+     * Determine if a test config is validation test.
+     *
+     * @param configuration the {@link IConfiguration} that the test args generated.
+     * @return True if is validation test config. False if not.
+     */
+    private static boolean isValidationTestConfig(IConfiguration configuration) {
+        List<IRemoteTest> testList = configuration.getTests();
+        // Validation test will be the only IRemoteTest in the config
+        if (testList.size() != 1) {
+            return false;
+        }
+        if (testList.get(0) instanceof IDiscoverTestClasses) {
+            IDiscoverTestClasses test = (IDiscoverTestClasses) testList.get(0);
+            return test.getClassNames().equals(VALIDATION_TEST_CLASS_NAMES)
+                    || test.getClassNames().equals(TEST_MAPPING_VALIDATION_TEST_CLASS_NAMES);
+        }
+        return false;
+    }
+
+    @VisibleForTesting
+    public boolean isValidationTestDiscovered() {
+        return isValidationTestDiscovered;
+    }
+}
diff --git a/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java b/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
index cc1081bca..43c14ed26 100644
--- a/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
+++ b/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
@@ -53,8 +53,6 @@ import java.util.Set;
  */
 public class TestZipDiscoveryExecutor {
 
-    private boolean mReportNoPossibleDiscovery = false;
-
     private static TestDiscoveryUtil mTestDiscoveryUtil;
 
     public TestZipDiscoveryExecutor() {
@@ -73,9 +71,9 @@ public class TestZipDiscoveryExecutor {
      */
     public String discoverTestZips(String[] args)
             throws TestDiscoveryException, ConfigurationException, JSONException {
-        // Create IConfiguration base on command line args.
-        IConfiguration config = mTestDiscoveryUtil.getConfiguration(args);
-
+        if (!mTestDiscoveryUtil.isTradefedConfiguration(args)) {
+            return nonTradefedDiscovery(args);
+        }
         if (mTestDiscoveryUtil.hasOutputResultFile()) {
             DdmPreferences.setLogLevel(Log.LogLevel.VERBOSE.getStringValue());
             Log.setLogOutput(LogRegistry.getLogRegistry());
@@ -83,7 +81,9 @@ public class TestZipDiscoveryExecutor {
             logger.setLogLevel(Log.LogLevel.VERBOSE);
             LogRegistry.getLogRegistry().registerLogger(logger);
         }
-
+        boolean reportNoPossibleDiscovery = true;
+        // Create IConfiguration base on command line args.
+        IConfiguration config = mTestDiscoveryUtil.getConfiguration(args);
         try {
             // Get tests from the configuration.
             List<IRemoteTest> tests = config.getTests();
@@ -108,6 +108,7 @@ public class TestZipDiscoveryExecutor {
                 testZipRegexSet.add("tradefed-all.zip");
                 testZipRegexSet.add("google-tradefed.zip");
                 testZipRegexSet.add("google-tradefed-all.zip");
+                reportNoPossibleDiscovery = false;
             }
 
             if (config.getConfigurationObject(Configuration.SANBOX_OPTIONS_TYPE_NAME) != null) {
@@ -118,6 +119,7 @@ public class TestZipDiscoveryExecutor {
             // Retrieve the value of option --sandbox-tests-zips
             if (sandboxOptions != null) {
                 testZipRegexSet.addAll(sandboxOptions.getTestsZips());
+                reportNoPossibleDiscovery = false;
             }
 
             List<IDeviceConfiguration> list = config.getDeviceConfig();
@@ -132,6 +134,7 @@ public class TestZipDiscoveryExecutor {
                         if (testZipFileFilters != null) {
                             testZipRegexSet.addAll(testZipFileFilters);
                         }
+                        reportNoPossibleDiscovery = false;
                     }
                 }
             }
@@ -145,32 +148,22 @@ public class TestZipDiscoveryExecutor {
                     testZipRegexSet.addAll(
                             TradefedSandbox.matchSandboxExtraBuildTargetByConfigName(
                                     config.getName()));
+                    reportNoPossibleDiscovery = false;
                 }
             }
 
-            // If no test zip related info discovered, report a no possible discovery.
-            if (testZipRegexSet.isEmpty()) {
-                mReportNoPossibleDiscovery = true;
-            }
-
             if (testZipRegexSet.contains(null)) {
                 throw new TestDiscoveryException(
-                        "Tradefed Observatory discovered null test zip regex. This is likely due to a corrupted discovery result. Test config: %s"
-                                .format(config.getName()),
+                        String.format(
+                                "Tradefed Observatory discovered null test zip regex. This is"
+                                    + " likely due to a corrupted discovery result. Test config:"
+                                    + " %s",
+                                config.getName()),
                         null,
                         DiscoveryExitCode.DISCOVERY_RESULTS_CORREPUTED);
             }
 
-            try (CloseableTraceScope ignored = new CloseableTraceScope("format_results")) {
-                JSONObject j = new JSONObject();
-                j.put(
-                        TestDiscoveryInvoker.TEST_ZIP_REGEXES_LIST_KEY,
-                        new JSONArray(testZipRegexSet));
-                if (mReportNoPossibleDiscovery) {
-                    j.put(TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY, "true");
-                }
-                return j.toString();
-            }
+            return formatResults(reportNoPossibleDiscovery, testZipRegexSet);
         } finally {
             if (mTestDiscoveryUtil.hasOutputResultFile()) {
                 LogRegistry.getLogRegistry().unregisterLogger();
@@ -178,6 +171,42 @@ public class TestZipDiscoveryExecutor {
         }
     }
 
+    private String formatResults(boolean reportNoPossibleDiscovery, Set<String> zipRegex)
+            throws JSONException {
+        try (CloseableTraceScope ignored = new CloseableTraceScope("format_results")) {
+            JSONObject j = new JSONObject();
+            j.put(TestDiscoveryInvoker.TEST_ZIP_REGEXES_LIST_KEY, new JSONArray(zipRegex));
+            if (reportNoPossibleDiscovery) {
+                j.put(TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY, "true");
+            }
+            return j.toString();
+        }
+    }
+
+    /** Centralize all the logic to handle non-Tradefed command discovery and assumptions. */
+    private String nonTradefedDiscovery(String[] args) throws JSONException {
+        Set<String> testsZipRegex = new LinkedHashSet<String>();
+        // special setup by camera team
+        if ("unused".equals(args[0])) {
+            for (String arg : args) {
+                if (arg.contains("liblyric")) {
+                    testsZipRegex.add("camera-hal-tests.zip");
+                }
+            }
+            return formatResults(false, testsZipRegex);
+        }
+        for (String arg : args) {
+            if (arg.contains("haiku")) {
+                testsZipRegex.add("haiku-presubmit");
+            }
+            // TODO(b/382159415): Update to the dedicated mobly zip
+            if (arg.contains("mobly")) {
+                testsZipRegex.add("general-tests.zip");
+            }
+        }
+        return formatResults(false, testsZipRegex);
+    }
+
     /**
      * A TradeFederation entry point that will use command args to discover test zip information.
      *
diff --git a/tools/content_uploader.py b/tools/content_uploader.py
index ab37b5f6c..2f605e7c0 100644
--- a/tools/content_uploader.py
+++ b/tools/content_uploader.py
@@ -41,9 +41,18 @@ def _get_env_var(key: str, default=None, check=False):
         raise ValueError(f'Error: the environment variable {key} is not set')
     return value
 
+def _truncate_file(file_path: str):
+    try:
+        with open(file_path, 'w'):
+            pass
+    except Exception as e:
+        print(f"Failed to trunacte file: {e}")
+
+
 def _setup_logging() -> str:
     dist_dir = _get_env_var('DIST_DIR', check=True)
     log_file = os.path.join(dist_dir, LOG_PATH)
+    _truncate_file(log_file)
     logging.basicConfig(
         level=logging.DEBUG,
         format='%(asctime)s %(levelname)s %(message)s',
@@ -65,6 +74,13 @@ def main():
     except FileNotFoundError:
         print(f'content_uploader.py will export logs to: {log_file}')
         logging.error('Uploader not found: %s', log_file)
+    except subprocess.CalledProcessError as e:
+        print(f'content_uploader.py will export logs to: {log_file}')
+        logging.error(f"Error: Command failed with exit code {e.returncode}\nCommand: {e.cmd}\nStdout:\n{e.stdout}\nStderr:\n{e.stderr}")
+    except ValueError as e:
+        # Capture and log all errors - not to fail the build.
+        print(f'content_uploader.py will export logs to: {log_file}')
+        logging.exception("Unexpected error: %s", e)
 
 if __name__ == '__main__':
     main()
diff --git a/tools/content_uploader/Android.bp b/tools/content_uploader/Android.bp
index 82f1b7dd9..99617f374 100644
--- a/tools/content_uploader/Android.bp
+++ b/tools/content_uploader/Android.bp
@@ -24,6 +24,7 @@ python_binary_host {
     ],
     libs: [
         "cas_metrics_proto",
+        "content_uploader_lib",
     ],
     version: {
         py3: {
@@ -32,6 +33,18 @@ python_binary_host {
     },
 }
 
+python_library_host {
+    name: "content_uploader_lib",
+    srcs: [
+        "artifact_manager.py",
+        "artifacts.py",
+        "uploader.py",
+    ],
+    libs: [
+        "cas_metrics_proto",
+    ],
+}
+
 python_library_host {
     name: "cas_metrics_proto",
     srcs: [
@@ -41,3 +54,21 @@ python_library_host {
         canonical_path_from_root: false,
     },
 }
+
+python_test_host {
+    name: "content_uploader_unittests",
+    main: "test.py",
+    srcs: [
+        "test.py",
+        "test_artifact_manager.py",
+        "test_artifacts.py",
+        "test_uploader.py",
+    ],
+    libs: [
+        "cas_metrics_proto",
+        "content_uploader_lib",
+    ],
+    test_options: {
+        unit_test: true,
+    },
+}
diff --git a/tools/content_uploader/artifact_manager.py b/tools/content_uploader/artifact_manager.py
new file mode 100644
index 000000000..a4025e300
--- /dev/null
+++ b/tools/content_uploader/artifact_manager.py
@@ -0,0 +1,151 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Artifact manager that supports artifact overriding."""
+
+import logging
+from typing import Dict, List, Self, Any
+from uploader import ArtifactConfig
+
+class ArtifactManager:
+    """Manager for artifact overriding."""
+
+    def __init__(self, artifacts: Dict[str, ArtifactConfig]):
+        """
+        Initialize the ArtifactManager with a preset dictionary of artifacts.
+
+        Args:
+            artifacts: Dictionary of artifact configurations.
+        """
+        self._artifacts = artifacts.copy()
+
+    def artifacts(self) -> Dict[str, ArtifactConfig]:
+        """
+        Returns a copy of the stored artifacts.
+
+        Returns:
+            A dictionary containing artifact configurations.
+        """
+        return self._artifacts.copy()
+
+    def override_artifacts(self, args: Any) -> Self:
+        """
+        Override the preset artifacts based on the given arguments.
+
+        Args:
+            args: An object containing artifact override arguments.
+        Returns:
+            self
+        """
+        if not hasattr(args, 'artifacts') or not args.artifacts:
+            return self
+
+        for override in args.artifacts:
+            self._process_artifact_override(override)
+        return self
+
+    def _process_artifact_override(self, override: str):
+        """
+        Processes a single artifact override string.
+
+        Args:
+            override: The override string in the format 'name=source_path attributes'.
+        """
+        tokens = override.split('=', maxsplit=1)
+        if len(tokens) != 2:
+            logging.warning('Artifact override - ignored (invalid format): %s', override)
+            return
+
+        name, source_path_str = tokens
+        if not source_path_str:
+            self._delete_artifact(name, override)
+            return
+
+        self._update_or_create_artifact(name, source_path_str)
+
+    def _delete_artifact(self, name: str, override: str):
+        """
+        Deletes an artifact if it exists.
+
+        Args:
+            name: The name of the artifact to delete.
+            override: The original override string for logging purposes.
+        """
+        if name in self._artifacts:
+            logging.info('Artifact delete: %s', override)
+            del self._artifacts[name]
+        else:
+            logging.warning('Artifact delete - ignored (name not found): %s', override)
+
+    def _update_or_create_artifact(self, name: str, source_path_str: str):
+        """
+        Updates an existing artifact or creates a new one.
+
+        Args:
+            name: The name of the artifact.
+            source_path_str: The source path and optional attributes string.
+        """
+        tokens = source_path_str.split()
+        source_path = tokens[0]
+        action = "update" if name in self._artifacts else "add"
+        artifact = self._artifacts.get(name, ArtifactConfig(source_path, unzip=False))
+        artifact.source_path = source_path
+
+        if len(tokens) > 1:
+            artifact.unzip = self._get_artifact_attribute(
+                tokens[1:], 'unzip', artifact.unzip
+            )
+            artifact.standard = self._get_artifact_attribute(
+                tokens[1:], 'standard', artifact.standard
+            )
+            artifact.chunk = self._get_artifact_attribute(
+                tokens[1:], 'chunk', artifact.chunk
+            )
+            artifact.chunk_dir = self._get_artifact_attribute(
+                tokens[1:], 'chunk_dir', artifact.chunk_dir
+            )
+
+        logging.info('Artifact %s: %s', action, artifact)
+        self._artifacts[name] = artifact
+
+    def _get_artifact_attribute(
+        self, tokens: List[str], attribute_name: str, default: bool
+    ) -> bool:
+        """
+        Retrieves a boolean attribute from the given tokens. Treat 'ATTRIBUTE_NAME'
+        same as 'ATTRIBUTE_NAME=True'.
+
+        Args:
+            tokens: A list of tokens containing attribute assignments.
+            attribute_name: The name of the attribute to retrieve.
+            default: The default value if the attribute is not found.
+
+        Returns:
+            The boolean value of the attribute.
+        """
+        for token in tokens:
+            if token.startswith(attribute_name + '='):
+                attr_token = token.split('=', 1)[1].lower()
+                if attr_token in {'true', 't', '1'}:
+                    return True
+                elif attr_token in {'false', 'f', '0'}:
+                    return False
+                else:
+                    logging.warning(
+                        'Invalid boolean value for %s: %s' % (attribute_name, attr_token)
+                    )
+                    return default
+            if token == attribute_name:
+                return True
+        return default
diff --git a/tools/content_uploader/artifacts.py b/tools/content_uploader/artifacts.py
new file mode 100644
index 000000000..5951075ea
--- /dev/null
+++ b/tools/content_uploader/artifacts.py
@@ -0,0 +1,135 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""A preset dictionary of artifacts for all branches."""
+
+import uploader
+
+ARTIFACTS = {
+    # test_suite targets
+    'android-catbox': uploader.ArtifactConfig(
+        'android-catbox.zip', True, exclude_filters=['android-catbox/jdk/.*']
+    ),
+    'android-csuite': uploader.ArtifactConfig(
+        'android-csuite.zip', True, exclude_filters=['android-csuite/jdk/.*']
+    ),
+    'android-cts': uploader.ArtifactConfig(
+        'android-cts.zip', True, exclude_filters=['android-cts/jdk/.*']
+    ),
+    'android-gcatbox': uploader.ArtifactConfig(
+        'android-gcatbox.zip', True, exclude_filters=['android-gcatbox/jdk/.*']
+    ),
+    'android-gts': uploader.ArtifactConfig(
+        'android-gts.zip', True, exclude_filters=['android-gts/jdk/.*']
+    ),
+    'android-mcts': uploader.ArtifactConfig('android-mcts.zip', True),
+    'android-mts': uploader.ArtifactConfig(
+        'android-mts.zip', True, exclude_filters=['android-mts/jdk/.*']
+    ),
+    'android-pts': uploader.ArtifactConfig(
+        'android-pts.zip', True, exclude_filters=['android-pts/jdk/.*']
+    ),
+    'android-sts': uploader.ArtifactConfig('android-sts.zip', True),
+    'android-tvts': uploader.ArtifactConfig(
+        'android-tvts.zip', True, exclude_filters=['android-tvts/jdk/.*']
+    ),
+    'android-vts': uploader.ArtifactConfig('android-vts.zip', True),
+    'android-wts': uploader.ArtifactConfig(
+        'android-wts.zip', True, exclude_filters=['android-wts/jdk/.*']
+    ),
+    'art-host-tests': uploader.ArtifactConfig('art-host-tests.zip', True),
+    'bazel-test-suite': uploader.ArtifactConfig('bazel-test-suite.zip', True),
+    'host-unit-tests': uploader.ArtifactConfig('host-unit-tests.zip', True),
+    'general-tests': uploader.ArtifactConfig('general-tests.zip', True),
+    'general-tests_configs': uploader.ArtifactConfig(
+        'general-tests_configs.zip', True
+    ),
+    'general-tests_host-shared-libs': uploader.ArtifactConfig(
+        'general-tests_host-shared-libs.zip', True
+    ),
+    'tradefed': uploader.ArtifactConfig('tradefed.zip', True),
+    'google-tradefed': uploader.ArtifactConfig('google-tradefed.zip', True),
+    'robolectric-tests': uploader.ArtifactConfig('robolectric-tests.zip', True),
+    'ravenwood-tests': uploader.ArtifactConfig('ravenwood-tests.zip', True),
+    'test_mappings': uploader.ArtifactConfig('test_mappings.zip', True),
+
+    # Mainline artifacts
+    'apex': uploader.ArtifactConfig('*.apex', False),
+    'apk': uploader.ArtifactConfig('*.apk', False),
+
+    # Device target artifacts
+    'androidTest': uploader.ArtifactConfig('androidTest.zip', True),
+    'device-tests': uploader.ArtifactConfig('device-tests.zip', True),
+    'device-tests_configs': uploader.ArtifactConfig(
+        'device-tests_configs.zip', True
+    ),
+    'device-tests_host-shared-libs': uploader.ArtifactConfig(
+        'device-tests_host-shared-libs.zip', True
+    ),
+    'performance-tests': uploader.ArtifactConfig('performance-tests.zip', True),
+    'device-platinum-tests': uploader.ArtifactConfig(
+        'device-platinum-tests.zip', True
+    ),
+    'device-platinum-tests_configs': uploader.ArtifactConfig(
+        'device-platinum-tests_configs.zip', True
+    ),
+    'device-platinum-tests_host-shared-libs': uploader.ArtifactConfig(
+        'device-platinum-tests_host-shared-libs.zip', True
+    ),
+    'camera-hal-tests': uploader.ArtifactConfig('camera-hal-tests.zip', True),
+    'camera-hal-tests_configs': uploader.ArtifactConfig(
+        'camera-hal-tests_configs.zip', True
+    ),
+    'camera-hal-tests_host-shared-libs': uploader.ArtifactConfig(
+        'camera-hal-tests_host-shared-libs.zip', True
+    ),
+    'device-pixel-tests': uploader.ArtifactConfig(
+        'device-pixel-tests.zip', True
+    ),
+    'device-pixel-tests_configs': uploader.ArtifactConfig(
+        'device-pixel-tests_configs.zip', True
+    ),
+    'device-pixel-tests_host-shared-libs': uploader.ArtifactConfig(
+        'device-pixel-tests_host-shared-libs.zip', True
+    ),
+    'automotive-tests': uploader.ArtifactConfig('automotive-tests.zip', True),
+    'automotive-general-tests': uploader.ArtifactConfig(
+        'automotive-general-tests.zip', True
+    ),
+    'automotive-sdv-tests': uploader.ArtifactConfig(
+        'automotive-sdv-tests.zip', True
+    ),
+    'automotive-sdv-tests_configs': uploader.ArtifactConfig(
+        'automotive-sdv-tests_configs.zip', True
+    ),
+    'tests': uploader.ArtifactConfig('*-tests-*zip', True),
+    'continuous_instrumentation_tests': uploader.ArtifactConfig(
+        '*-continuous_instrumentation_tests-*zip', True
+    ),
+    'continuous_instrumentation_metric_tests': uploader.ArtifactConfig(
+        '*-continuous_instrumentation_metric_tests-*zip', True
+    ),
+    'continuous_native_tests': uploader.ArtifactConfig(
+        '*-continuous_native_tests-*zip', True
+    ),
+    'cvd-host_package': uploader.ArtifactConfig(
+        'cvd-host_package.tar.gz', False
+    ),
+    'bootloader': uploader.ArtifactConfig('bootloader.img', False),
+    'radio': uploader.ArtifactConfig('radio.img', False),
+    'target_files': uploader.ArtifactConfig('*-target_files-*.zip', True),
+    'img': uploader.ArtifactConfig(
+        '*-img-*zip', False, chunk=True, chunk_dir=True
+    ),
+}
diff --git a/tools/content_uploader/cas_metrics.proto b/tools/content_uploader/cas_metrics.proto
index 90cea9fa2..d87e46989 100644
--- a/tools/content_uploader/cas_metrics.proto
+++ b/tools/content_uploader/cas_metrics.proto
@@ -33,4 +33,6 @@ message CasMetrics {
   int64 time_ms = 1;            // End to end time for the upload session.
   repeated ArtifactMetrics artifacts = 2;
   string client_version = 3;    // CAS uploader client version.
+  string uploader_version = 4;  // Content uploader (this script) version.
+  int32 max_workers = 5;        // Max workers used for uploading.
 }
\ No newline at end of file
diff --git a/tools/content_uploader/content_uploader_script.py b/tools/content_uploader/content_uploader_script.py
index 78063c973..8929ddd69 100644
--- a/tools/content_uploader/content_uploader_script.py
+++ b/tools/content_uploader/content_uploader_script.py
@@ -15,149 +15,36 @@
 #  limitations under the License.
 
 """The script to upload generated artifacts from build server to CAS."""
+
 import argparse
-import copy
-import dataclasses
 import glob
-import json
 import logging
 import os
+import random
 import re
-import shutil
 import subprocess
-import tempfile
 import time
-import cas_metrics_pb2  # type: ignore
-from google.protobuf import json_format
-
-
-@dataclasses.dataclass
-class ArtifactConfig:
-    """Configuration of an artifact to be uploaded to CAS.
-
-    Attributes:
-        source_path: path to the artifact that relative to the root of source code.
-        unzip: true if the artifact should be unzipped and uploaded as a directory.
-        chunk: true if the artifact should be uploaded with chunking.
-        chunk_fallback: true if a regular version (no chunking) of the artifact should be uploaded.
-        exclude_filters: a list of regular expressions for files that are excluded from uploading.
-    """
-    source_path: str
-    unzip: bool
-    chunk: bool = False
-    chunk_fallback: bool = False
-    exclude_filters: list[str] = dataclasses.field(default_factory=list)
-
-
-@dataclasses.dataclass
-class CasInfo:
-    """Basic information of CAS server and client.
-
-    Attributes:
-        cas_instance: the instance name of CAS service.
-        cas_service: the address of CAS service.
-        client_path: path to the CAS uploader client.
-        version: version of the CAS uploader client, in turple format.
-    """
-    cas_instance: str
-    cas_service: str
-    client_path: str
-    client_version: tuple
-
 
-@dataclasses.dataclass
-class UploadResult:
-    """Result of uploading a single artifact with CAS client.
+from artifact_manager import ArtifactManager
+from artifacts import ARTIFACTS
+import cas_metrics_pb2  # type: ignore
+from uploader import CasInfo
+from uploader import Uploader
 
-    Attributes:
-        digest: root digest of the artifact.
-        content_details: detail information of all uploaded files inside the uploaded artifact.
-    """
-    digest: str
-    content_details: list[dict[str,any]]
 
+VERSION = '1.8'
 
 CAS_UPLOADER_PREBUILT_PATH = 'tools/tradefederation/prebuilts/'
 CAS_UPLOADER_PATH = 'tools/content_addressed_storage/prebuilts/'
 CAS_UPLOADER_BIN = 'casuploader'
 
-UPLOADER_TIMEOUT_SECS = 600 # 10 minutes
-AVG_CHUNK_SIZE_IN_KB = 128
-
-DIGESTS_PATH = 'cas_digests.json'
 LOG_PATH = 'logs/cas_uploader.log'
 CAS_METRICS_PATH = 'logs/cas_metrics.pb'
 METRICS_PATH = 'logs/artifact_metrics.json'
-CONTENT_DETAILS_PATH = 'logs/cas_content_details.json'
-CHUNKED_ARTIFACT_NAME_PREFIX = "_chunked_"
-CHUNKED_DIR_ARTIFACT_NAME_PREFIX = "_chunked_dir_"
-
-# Configurations of artifacts will be uploaded to CAS.
-# TODO(b/298890453) Add artifacts after this script is attached to build process.
-# If configs share files, chunking enabled artifacts should come first.
-ARTIFACTS = [
-    # test_suite targets
-    ArtifactConfig('android-catbox.zip', True),
-    ArtifactConfig('android-csuite.zip', True),
-    ArtifactConfig('android-cts.zip', True, exclude_filters=['android-cts/jdk/.*']),
-    ArtifactConfig('android-gcatbox.zip', True),
-    ArtifactConfig('android-gts.zip', True, exclude_filters=['android-gts/jdk/.*']),
-    ArtifactConfig('android-mcts.zip', True),
-    ArtifactConfig('android-mts.zip', True, exclude_filters=['android-mts/jdk/.*']),
-    ArtifactConfig('android-pts.zip', True, exclude_filters=['android-pts/jdk/.*']),
-    ArtifactConfig('android-sts.zip', True),
-    ArtifactConfig('android-vts.zip', True),
-    ArtifactConfig('android-wts.zip', True, exclude_filters=['android-wts/jdk/.*']),
-    ArtifactConfig('art-host-tests.zip', True),
-    ArtifactConfig('bazel-test-suite.zip', True),
-    ArtifactConfig('host-unit-tests.zip', True),
-    ArtifactConfig('general-tests.zip', True),
-    ArtifactConfig('general-tests_configs.zip', True),
-    ArtifactConfig('general-tests_host-shared-libs.zip', True),
-    ArtifactConfig('tradefed.zip', True),
-    ArtifactConfig('google-tradefed.zip', True),
-    ArtifactConfig('robolectric-tests.zip', True),
-    ArtifactConfig('ravenwood-tests.zip', True),
-    ArtifactConfig('test_mappings.zip', True),
-
-    # Mainline artifacts
-    ArtifactConfig('*.apex', False),
-    ArtifactConfig('*.apk', False),
+MAX_WORKERS_LOWER_BOUND = 5
+MAX_WORKERS_UPPER_BOUND = 7
+MAX_WORKERS = random.randint(MAX_WORKERS_LOWER_BOUND, MAX_WORKERS_UPPER_BOUND)
 
-    # Device target artifacts
-    ArtifactConfig('androidTest.zip', True),
-    ArtifactConfig('device-tests.zip', True),
-    ArtifactConfig('device-tests_configs.zip', True),
-    ArtifactConfig('device-tests_host-shared-libs.zip', True),
-    ArtifactConfig('performance-tests.zip', True),
-    ArtifactConfig('device-platinum-tests.zip', True),
-    ArtifactConfig('device-platinum-tests_configs.zip', True),
-    ArtifactConfig('device-platinum-tests_host-shared-libs.zip', True),
-    ArtifactConfig('camera-hal-tests.zip', True),
-    ArtifactConfig('camera-hal-tests_configs.zip', True),
-    ArtifactConfig('camera-hal-tests_host-shared-libs.zip', True),
-    ArtifactConfig('device-pixel-tests.zip', True),
-    ArtifactConfig('device-pixel-tests_configs.zip', True),
-    ArtifactConfig('device-pixel-tests_host-shared-libs.zip', True),
-    ArtifactConfig('*-tests-*zip', True),
-    ArtifactConfig('*-continuous_instrumentation_tests-*zip', True),
-    ArtifactConfig('*-continuous_instrumentation_metric_tests-*zip', True),
-    ArtifactConfig('*-continuous_native_tests-*zip', True),
-    ArtifactConfig('cvd-host_package.tar.gz', False),
-    ArtifactConfig('bootloader.img', False),
-    ArtifactConfig('radio.img', False),
-    ArtifactConfig('*-target_files-*.zip', True),
-    ArtifactConfig('*-img-*zip', True, True, True)
-]
-
-# Artifacts will be uploaded if the config name is set in arguments `--experiment_artifacts`.
-# These configs are usually used to upload artifacts in partial branches/targets for experiment
-# purpose.
-# A sample entry:
-#   "device_image_target_files": ArtifactConfig('*-target_files-*.zip', True)
-EXPERIMENT_ARTIFACT_CONFIGS = {
-    "device_image_proguard_dict": ArtifactConfig('*-proguard-dict-*.zip', False, True, True),
-}
 
 def _init_cas_info() -> CasInfo:
     client_path = _get_client()
@@ -213,265 +100,26 @@ def _get_env_var(key: str, default=None, check=False):
     return value
 
 
-def _parse_additional_artifacts(args) -> list[ArtifactConfig]:
-    additional_artifacts = []
-    for config in args.experiment_artifacts:
-        if config not in EXPERIMENT_ARTIFACT_CONFIGS:
-            logging.warning('Ignore invalid experiment_artifacts: %s', config)
-        else:
-            additional_artifacts.append(EXPERIMENT_ARTIFACT_CONFIGS[config])
-            logging.info(
-                'Added experiment artifact from arguments %s',
-                EXPERIMENT_ARTIFACT_CONFIGS[config].source_path,
-            )
-    return additional_artifacts
-
-
-def _upload(
-        cas_info: CasInfo,
-        artifact: ArtifactConfig,
-        working_dir: str,
-        log_file: str,
-        metrics_file: str,
-) -> str:
-    """Upload the artifact to CAS by casuploader binary.
-
-    Args:
-      cas_info: the basic CAS server information.
-      artifact: the artifact to be uploaded to CAS.
-      working_dir: the directory for intermediate files.
-      log_file: the file where to add the upload logs.
-      metrics_file: the metrics_file for the artifact.
-
-    Returns: the digest of the uploaded artifact, formatted as "<hash>/<size>".
-      returns None if artifact upload fails.
-    """
-    # `-dump-file-details` only supports on cas uploader V1.0 or later.
-    dump_file_details = cas_info.client_version >= (1, 0)
-    if not dump_file_details:
-        logging.warning('-dump-file-details is not enabled')
-
-    # `-dump-metrics` only supports on cas uploader V1.3 or later.
-    dump_metrics = cas_info.client_version >= (1, 3)
-    if not dump_metrics:
-        logging.warning('-dump-metrics is not enabled')
-
-    with tempfile.NamedTemporaryFile(mode='w+') as digest_file, tempfile.NamedTemporaryFile(
-      mode='w+') as content_details_file:
-        logging.info(
-            'Uploading %s to CAS instance %s', artifact.source_path, cas_info.cas_instance
-        )
-
-        cmd = [
-            cas_info.client_path,
-            '-cas-instance',
-            cas_info.cas_instance,
-            '-cas-addr',
-            cas_info.cas_service,
-            '-dump-digest',
-            digest_file.name,
-            '-use-adc',
-        ]
-
-        cmd = cmd + _path_for_artifact(artifact, working_dir)
-
-        if artifact.chunk:
-            cmd = cmd + ['-chunk', '-avg-chunk-size', str(AVG_CHUNK_SIZE_IN_KB)]
-
-        for exclude_filter in artifact.exclude_filters:
-            cmd = cmd + ['-exclude-filters', exclude_filter]
-
-        if dump_file_details:
-            cmd = cmd + ['-dump-file-details', content_details_file.name]
-
-        if dump_metrics:
-            cmd = cmd + ['-dump-metrics', metrics_file]
-
-        try:
-            logging.info('Running command: %s', cmd)
-            with open(log_file, 'a', encoding='utf8') as outfile:
-                subprocess.run(
-                    cmd,
-                    check=True,
-                    text=True,
-                    stdout=outfile,
-                    stderr=subprocess.STDOUT,
-                    encoding='utf-8',
-                    timeout=UPLOADER_TIMEOUT_SECS
-                )
-        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
-            logging.warning(
-                'Failed to upload %s to CAS instance %s. Skip.\nError message: %s\nLog: %s',
-                artifact.source_path, cas_info.cas_instance, e, e.stdout,
-            )
-            return None
-        except subprocess.SubprocessError as e:
-            logging.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error %s',
-                artifact.source_path, cas_info.cas_instance, e)
-            return None
-
-        # Read digest of the root directory or file from dumped digest file.
-        digest = digest_file.read()
-        if digest:
-            logging.info('Uploaded %s to CAS. Digest: %s', artifact.source_path, digest)
-        else:
-            logging.warning(
-                'No digest is dumped for file %s, the uploading may fail.', artifact.source_path)
-            return None
-
-        content_details = None
-        if dump_file_details:
-            try:
-                content_details = json.loads(content_details_file.read())
-            except json.JSONDecodeError as e:
-                logging.warning('Failed to parse uploaded content details: %s', e)
-
-        return UploadResult(digest, content_details)
-
-
-def _path_for_artifact(artifact: ArtifactConfig, working_dir: str) -> [str]:
-    if artifact.unzip:
-        return ['-zip-path', artifact.source_path]
-    if artifact.chunk:
-        return ['-file-path', artifact.source_path]
-    # TODO(b/250643926) This is a workaround to handle non-directory files.
-    tmp_dir = tempfile.mkdtemp(dir=working_dir)
-    target_path = os.path.join(tmp_dir, os.path.basename(artifact.source_path))
-    shutil.copy(artifact.source_path, target_path)
-    return ['-dir-path', tmp_dir]
-
-
-def _output_results(
-        cas_info: CasInfo,
-        output_dir: str,
-        digests: dict[str, str],
-        content_details: list[dict[str, any]],
-):
-    digests_output = {
-        'cas_instance': cas_info.cas_instance,
-        'cas_service': cas_info.cas_service,
-        'client_version': '.'.join(map(str, cas_info.client_version)),
-        'files': digests,
-    }
-    output_path = os.path.join(output_dir, DIGESTS_PATH)
-    with open(output_path, 'w', encoding='utf8') as writer:
-        writer.write(json.dumps(digests_output, sort_keys=True, indent=2))
-    logging.info('Output digests to %s', output_path)
-
-    output_path = os.path.join(output_dir, CONTENT_DETAILS_PATH)
-    with open(output_path, 'w', encoding='utf8') as writer:
-        writer.write(json.dumps(content_details, sort_keys=True, indent=2))
-    logging.info('Output uploaded content details to %s', output_path)
-
-
-def _upload_all_artifacts(cas_info: CasInfo, all_artifacts: ArtifactConfig,
-    dist_dir: str, working_dir: str, log_file:str, cas_metrics: cas_metrics_pb2.CasMetrics):
-    file_digests = {}
-    content_details = []
-    skip_files = []
-    _add_fallback_artifacts(all_artifacts)
-    for artifact in all_artifacts:
-        for f in glob.glob(dist_dir + '/**/' + artifact.source_path, recursive=True):
-            start = time.time()
-            rel_path = _get_relative_path(dist_dir, f)
-            path = _artifact_path(rel_path, artifact.chunk, artifact.unzip)
-
-            # Avoid redundant upload if multiple ArtifactConfigs share files.
-            if path in file_digests or path in skip_files:
-                continue
-
-            artifact.source_path = f
-            metrics_file = os.path.join(dist_dir, METRICS_PATH)
-            result = _upload(cas_info, artifact, working_dir, log_file, metrics_file)
-
-            if result and result.digest:
-                file_digests[path] = result.digest
-                if artifact.chunk and (not artifact.chunk_fallback or artifact.unzip):
-                    # Skip the regular version even it matches other configs.
-                    skip_files.append(rel_path)
-            else:
-                logging.warning(
-                    'Skip to save the digest of file %s, the uploading may fail', path
-                )
-            if result and result.content_details:
-                content_details.append({"artifact": path, "details": result.content_details})
-            else:
-                logging.warning('Skip to save the content details of file %s', path)
-
-            if os.path.exists(metrics_file):
-                _add_artifact_metrics(metrics_file, cas_metrics)
-                os.remove(metrics_file)
-
-            logging.info(
-                'Elapsed time of uploading %s: %d seconds\n\n',
-                artifact.source_path,
-                time.time() - start,
-            )
-    _output_results(
-        cas_info,
-        dist_dir,
-        file_digests,
-        content_details,
-    )
-
-
-def _add_artifact_metrics(metrics_file: str, cas_metrics: cas_metrics_pb2.CasMetrics):
-    try:
-        with open(metrics_file, "r", encoding='utf8') as file:
-            json_metrics = json.load(file)
-            cas_metrics.artifacts.append(
-                json_format.ParseDict(json_metrics, cas_metrics_pb2.ArtifactMetrics())
-            )
-
-    except FileNotFoundError:
-        logging.exception("File not found: %s", metrics_file)
-    except json_format.ParseError as e:  # Catch any other unexpected errors
-        logging.exception("Error converting Json to protobuf: %s", e)
-
-
-def _add_fallback_artifacts(artifacts: list[ArtifactConfig]):
-    """Add a fallback artifact if chunking is enabled for an artifact.
-
-    For unzip artifacts, the fallback is the zipped chunked version.
-    For the rest, the fallback is the standard version (not chunked).
-    """
-    for artifact in artifacts:
-        if artifact.chunk and artifact.chunk_fallback:
-            fallback_artifact = copy.copy(artifact)
-            if artifact.unzip:
-                fallback_artifact.unzip = False
-            else:
-                fallback_artifact.chunk = False
-            artifacts.append(fallback_artifact)
-
-
-def _get_relative_path(dir: str, file: str) -> str:
-    try:
-        return os.path.relpath(file, dir)
-    except ValueError as e:
-        print(f"Error calculating relative path: {e}")  # should never happen
-        return os.path.basename(file)
-
-
-def _artifact_path(path: str, chunk: bool, unzip: bool) -> str:
-    if not chunk:
-        return path
-    if unzip:
-        return CHUNKED_DIR_ARTIFACT_NAME_PREFIX + path
-    return CHUNKED_ARTIFACT_NAME_PREFIX + path
-
-
 def main():
     """Uploads the specified artifacts to CAS."""
     parser = argparse.ArgumentParser()
     parser.add_argument(
-        '--experiment_artifacts',
+        '--artifacts',
         required=False,
         action='append',
         default=[],
-        help='Name of configuration which artifact to upload',
+        help='Override preset artifacts, e.g. "--artifacts \'img=./*-img-*zip unzip chunk=False\'"',
+    )
+    parser.add_argument(
+        '--list',
+        action='store_true',
+        help='List preset artifacts and exit',
+    )
+    parser.add_argument(
+        '--dryrun',
+        action='store_true',
+        help='List files to upload and exit',
     )
-    args = parser.parse_args()
 
     dist_dir = _get_env_var('DIST_DIR', check=True)
     log_file = os.path.join(dist_dir, LOG_PATH)
@@ -481,28 +129,37 @@ def main():
         format='%(asctime)s %(levelname)s %(message)s',
         filename=log_file,
     )
+    logging.info('Content uploader version: %s', VERSION)
     logging.info('Environment variables of running server: %s', os.environ)
 
-    additional_artifacts = _parse_additional_artifacts(args)
-    cas_info = _init_cas_info()
-
-    with tempfile.TemporaryDirectory() as working_dir:
-        logging.info('The working dir is %s', working_dir)
+    try:
         start = time.time()
-        cas_metrics = cas_metrics_pb2.CasMetrics()
-        _upload_all_artifacts(cas_info, ARTIFACTS + additional_artifacts,
-            dist_dir, working_dir, log_file, cas_metrics)
+
+        args = parser.parse_args()
+        artifacts = ArtifactManager(ARTIFACTS).override_artifacts(args).artifacts()
+        if args.list:
+            for name, artifact in artifacts.items():
+                print(f"{name:<30}={artifact}")
+
+        cas_info = _init_cas_info()
+        cas_metrics = Uploader(cas_info).upload(list(artifacts.values()),
+                dist_dir, MAX_WORKERS, args.dryrun)
+
         elapsed = time.time() - start
         logging.info('Total time of uploading build artifacts to CAS: %d seconds',
-                     elapsed)
+                    elapsed)
         cas_metrics.time_ms = int(elapsed * 1000)
         cas_metrics.client_version = '.'.join([str(num) for num in cas_info.client_version])
+        cas_metrics.uploader_version = VERSION
+        cas_metrics.max_workers = MAX_WORKERS
         serialized_metrics = cas_metrics.SerializeToString()
         if serialized_metrics:
             cas_metrics_file = os.path.join(dist_dir, CAS_METRICS_PATH)
             with open(cas_metrics_file, "wb") as file:
                 file.write(serialized_metrics)
             logging.info('Output cas metrics to: %s', cas_metrics_file)
+    except ValueError as e:
+        logging.exception("Unexpected error: %s", e)
 
 
 if __name__ == '__main__':
diff --git a/tools/content_uploader/test.py b/tools/content_uploader/test.py
new file mode 100644
index 000000000..05435c383
--- /dev/null
+++ b/tools/content_uploader/test.py
@@ -0,0 +1,33 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Run unit tests for specified modules."""
+
+import unittest
+import sys
+
+
+def run():
+    """Run unit tests for specified modules."""
+    test_modules = ['test_uploader', 'test_artifact_manager', 'test_artifacts']
+
+    suite = unittest.defaultTestLoader.loadTestsFromNames(test_modules)
+
+    runner = unittest.TextTestRunner(verbosity=2)
+    result = runner.run(suite)
+    sys.exit(not result.wasSuccessful())
+
+
+if __name__ == '__main__':
+    run()
diff --git a/tools/content_uploader/test_artifact_manager.py b/tools/content_uploader/test_artifact_manager.py
new file mode 100644
index 000000000..020d56e13
--- /dev/null
+++ b/tools/content_uploader/test_artifact_manager.py
@@ -0,0 +1,130 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Unit tests for artifact_manager."""
+
+import argparse
+import sys
+import tempfile
+import unittest
+import logging
+from unittest.mock import patch
+
+from artifact_manager import ArtifactManager
+from uploader import ArtifactConfig
+
+
+class ArtifactManagerTest(unittest.TestCase):
+    """A unit test class for artifact_manager."""
+
+    def setUp(self):
+        self.temp_dir = tempfile.TemporaryDirectory()
+        self.test_dir = self.temp_dir.name
+        self.artifacts = {
+            'apex': ArtifactConfig('*.apex', False),
+            'img': ArtifactConfig('*-img-*zip', False, chunk=True, chunk_dir=True)
+        }
+        self.artifact_manager = ArtifactManager(self.artifacts)
+        self.parser = argparse.ArgumentParser()
+        self.parser.add_argument(
+            '--artifacts',
+            required=False,
+            action='append',
+            default=[],
+            help='Override artifacts',
+        )
+
+    def tearDown(self):
+        self.temp_dir.cleanup()
+        return super().tearDown()
+
+    def test_override_artifacts_delete_artifact(self):
+        """Flag --artifact 'ARTIFACT_NAME=' deletes the artifact."""
+        test_args = ['content_uploader', '--artifacts', 'img=']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            expected = {k: v for k, v in self.artifacts.items() if k != 'img'}
+            self.assertDictEqual(artifacts, expected)
+
+    def test_override_artifacts_update_artifact(self):
+        """Flag --artifact 'ARTIFACT_NAME=NEW_PATH' updates artifact path."""
+        test_args = ['content_uploader', '--artifacts', 'apex=new_path']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            expected = self.artifacts.copy()
+            self.artifacts['apex'].source_path = 'new_path'
+            self.assertDictEqual(artifacts, expected)
+
+    def test_override_artifacts_add_artifact(self):
+        """Flag --artifact 'NEW_ARTIFACT=PATH' adds a new artifact."""
+        test_args = ['content_uploader', '--artifacts', 'new_artifact=path/to/new']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            expected = self.artifacts.copy()
+            expected['new_artifact'] = ArtifactConfig('path/to/new', False)
+            self.assertDictEqual(artifacts, expected)
+
+    def test_override_artifacts_update_attributes(self):
+        """Flag --artifact 'ARTIFACT_NAME=PATH standard chunk=True' updates attributes."""
+        test_args = ['content_uploader', '--artifacts', 'apex=new_path standard chunk=True']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            self.assertEqual(artifacts['apex'].source_path, 'new_path')
+            self.assertFalse(artifacts['apex'].unzip)   # Default
+            self.assertTrue(artifacts['apex'].standard) # 'standard'
+            self.assertTrue(artifacts['apex'].chunk)    # 'chunk=True'
+            self.assertFalse(artifacts['apex'].chunk_dir)
+
+    def test_override_artifacts_update_attributes_to_false(self):
+        """Flag --artifact 'ARTIFACT_NAME=PATH unzip standard=False chunk=F' updates attributes."""
+        test_args = ['content_uploader', '--artifacts', 'img=new_path standard=False chunk=F']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            self.assertEqual(artifacts['img'].source_path, 'new_path')
+            self.assertFalse(artifacts['img'].unzip)    # Default
+            self.assertFalse(artifacts['img'].standard) # 'standard=False'
+            self.assertFalse(artifacts['img'].chunk)    # 'chunk=F'
+            self.assertTrue(artifacts['img'].chunk_dir)
+
+    def test_override_artifacts_invalid_format(self):
+        """Flag --artifact 'INVALID_FORMAT' logs a warning."""
+        test_args = ['content_uploader', '--artifacts', 'invalid_format']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            with self.assertLogs(level=logging.WARNING) as cm:
+                self.artifact_manager.override_artifacts(args)
+            self.assertIn("Artifact override - ignored (invalid format):", cm.output[0])
+
+    def test_override_artifacts_invalid_boolean_attribute(self):
+        """Flag --artifact logs a warning for invalid boolean value."""
+        test_args = ['content_uploader', '--artifacts', 'apex=new_path unzip=invalid']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            with self.assertLogs(level=logging.WARNING) as cm:
+                self.artifact_manager.override_artifacts(args)
+            self.assertIn("Invalid boolean value for unzip: invalid", cm.output[0])
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tools/content_uploader/test_artifacts.py b/tools/content_uploader/test_artifacts.py
new file mode 100644
index 000000000..ca1952d3f
--- /dev/null
+++ b/tools/content_uploader/test_artifacts.py
@@ -0,0 +1,56 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Unit tests for artifacts."""
+
+import unittest
+
+from artifacts import ARTIFACTS
+from uploader import ArtifactConfig
+
+
+class ArtifactsTest(unittest.TestCase):
+    """A unit test class for preset artifacts."""
+
+    def test_img_has_expected_attributes(self):
+        """Tests the attributes of the 'img' artifact."""
+        self.assertTrue('img' in ARTIFACTS, "The 'img' artifact should exist.")
+        expected = ArtifactConfig('*-img-*zip', False, chunk=True, chunk_dir=True)
+        self.assertEqual(
+            ARTIFACTS['img'], expected, "The 'img' artifact attributes do not match."
+        )
+
+    def test_unzip_artifacts_have_path_end_with_zip(self):
+        """Tests that artifacts with unzip=True have source paths ending with 'zip'."""
+        for name, artifact in ARTIFACTS.items():
+            if artifact.unzip:
+                self.assertTrue(
+                    artifact.source_path.endswith('zip'),
+                    f"Artifact '{name}' (unzip=True) should have a source path ending with 'zip'.",
+                )
+
+    def test_all_preset_artifacts_are_valid(self):
+        """Tests that no artrifact has all standard, chunk, and chunk_dir false."""
+        for name, artifact in ARTIFACTS.items():
+            self.assertTrue(
+                artifact.standard or artifact.chunk or artifact.chunk_dir,
+                (
+                    f"Artifact '{name}' is invalid. "
+                    "One or more of 'standard', 'chunk' or 'chunk_dir' must be true."
+                )
+            )
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tools/content_uploader/test_uploader.py b/tools/content_uploader/test_uploader.py
new file mode 100644
index 000000000..6f7452fbe
--- /dev/null
+++ b/tools/content_uploader/test_uploader.py
@@ -0,0 +1,193 @@
+# Copyright 2025 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Unit tests for content_uploader."""
+
+import logging
+import os
+import tempfile
+import unittest
+
+from uploader import Uploader
+from uploader import CasInfo
+from uploader import ArtifactConfig
+import cas_metrics_pb2  # type: ignore
+
+class ContentUploaderTest(unittest.TestCase):
+    """A unit test class for content uploader."""
+
+    def setUp(self):
+        self.temp_dir = tempfile.TemporaryDirectory()
+        self.test_dir = self.temp_dir.name
+        self.command_file=os.path.join(self.test_dir, 'command')
+
+    def tearDown(self):
+        self.temp_dir.cleanup()
+        return super().tearDown()
+
+
+    def _create_fake_uploader(self, test_dir: str, text: str) -> str:
+        try:
+            path = os.path.join(test_dir, 'casuploader')
+            with open(path, "w", encoding="utf-8") as f:
+                f.write(text)
+            os.chmod(path, 0o777)
+            return path
+        except Exception as e:
+            self.fail(f"Error creating casuploader: {e}")
+            return None
+
+    def _create_fake_imagefile(self, parent_dir: str, name: str):
+        try:
+            if not os.path.exists(parent_dir):
+                os.makedirs(parent_dir)
+            path = os.path.join(parent_dir, name)
+            with open(path, "w", encoding="utf-8") as f:
+                f.write('fake image')
+        except Exception as e:
+            self.fail(f"Error creating image file: {e}")
+
+    def _upload(self, artifacts, test_dir: str, dist_dir: str) -> str:
+        log_dir = os.path.join(dist_dir, 'logs')
+        os.makedirs(log_dir, 0o777)
+        max_workers = 1
+        dryrun = False
+        client_path = self._create_fake_uploader(test_dir, f"""#!/bin/bash
+echo $@ >> {self.command_file}
+while (("$#" > 0)); do
+    case "$1" in
+    -dump-digest)
+        echo 'DIGEST' > $2
+        shift 2 ;;
+    -dump-file-details)
+        echo '[ {{ "digest": "DIGEST", "path": "PATH", "size": 3680794449 }} ]' > $2
+        shift 2 ;;
+    -dump-metrics)
+        echo '{{ "digest": "DIGEST", "time_ms": "100" }}' > $2
+        shift 2 ;;
+    *)
+        shift ;;
+    esac
+done
+
+""")
+        cas_info = CasInfo('INSTANCE', 'SERVICE', client_path, (1, 4))
+        uploader = Uploader(cas_info)
+        uploader.upload(artifacts, dist_dir, max_workers, dryrun)
+        return Uploader.read_file(self.command_file)
+
+    def _verify(self, command: str, has_flags: list[str], no_flags: list[str]):
+        for flag in has_flags:
+            if not flag in command:
+                self.fail(f'flag "{flag}" is absent from command "{command}"')
+        for flag in no_flags:
+            if flag in command:
+                self.fail(f'flag "{flag}" is should not be present in command "{command}"')
+
+    def test_standard_version_flags(self):
+        """standard version has '-file-path', no '-chunk'."""
+
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = False,
+            standard = True,
+            chunk = False,
+            chunk_dir = False,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            command = self._upload(artifacts, self.test_dir, dist_dir)
+            self._verify(command, ['-file-path'], ['-zip-path', '-chunk'])
+
+    def test_standard_unzip_version_flags(self):
+        """standard_unzip version has '-zip-path', no '-chunk'."""
+
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = True,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            command = self._upload(artifacts, self.test_dir, dist_dir)
+            self._verify(command, ['-zip-path'], ['-file-path', '-chunk'])
+
+    def test_chunk_version_flags(self):
+        """chunk version has '-file-path' and '-chunk'."""
+
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = False,
+            standard = False,
+            chunk = True,
+            chunk_dir = False,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            command = self._upload(artifacts, self.test_dir, dist_dir)
+            self._verify(command, ['-file-path', '-chunk'], ['-zip-path'])
+
+    def test_chunk_dir_version_flags(self):
+        """chunk_dir version has '-zip-path' and '-chunk'."""
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = False,
+            standard = False,
+            chunk = False,
+            chunk_dir = True,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            command = self._upload(artifacts, self.test_dir, dist_dir)
+            self._verify(command, ['-zip-path', '-chunk'], ['-file-path'])
+
+    def test_glob_pattern_regular(self):
+        """Regular glob patterns find all matches."""
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = False,
+            standard = True,
+            chunk = False,
+            chunk_dir = False,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            self._create_fake_imagefile(dist_dir + '/sub', 'oriole-img-123.zip')
+            commands = self._upload(artifacts, self.test_dir, dist_dir)
+            self.assertEqual(len(commands.split('\n')) - 1, 2)
+            self.assertIn('/sub/', commands)
+
+    def test_glob_pattern_relative(self):
+        """Relative glob patterns find the exact matches."""
+        standard_image = ArtifactConfig(
+            './*-img-*zip',
+            unzip = False,
+            standard = True,
+            chunk = False,
+            chunk_dir = False,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            self._create_fake_imagefile(dist_dir + '/sub', 'oriole-img-123.zip')
+            commands = self._upload(artifacts, self.test_dir, dist_dir)
+            self.assertEqual(len(commands.split('\n')) - 1, 1)
+            self.assertNotIn('/sub/', commands)
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tools/content_uploader/uploader.py b/tools/content_uploader/uploader.py
new file mode 100644
index 000000000..324ba3d6c
--- /dev/null
+++ b/tools/content_uploader/uploader.py
@@ -0,0 +1,446 @@
+#!/usr/bin/env python3
+#
+#  Copyright (C) 2022 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+"""The script to upload generated artifacts from build server to CAS."""
+
+import concurrent.futures
+import dataclasses
+import glob
+import json
+import logging
+import os
+import subprocess
+import tempfile
+import uuid
+import time
+from typing import Tuple
+
+import cas_metrics_pb2  # type: ignore
+from google.protobuf import json_format
+
+@dataclasses.dataclass
+class ArtifactConfig:
+    """Configuration of an artifact to be uploaded to CAS.
+
+    Attributes:
+        source_path: path to the artifact that relative to the root of source code.
+        unzip: true if the artifact should be unzipped and uploaded as a directory.
+        chunk: true if the artifact should be uploaded with chunking as a single file.
+        chunk_dir: true if the artifact should be uploaded with chunking as a directory.
+        exclude_filters: a list of regular expressions for files that are excluded from uploading.
+    """
+    source_path: str
+    unzip: bool
+    standard: bool = True
+    chunk: bool = False
+    chunk_dir: bool = False
+    exclude_filters: list[str] = dataclasses.field(default_factory=list)
+
+
+@dataclasses.dataclass
+class CasInfo:
+    """Basic information of CAS server and client.
+
+    Attributes:
+        cas_instance: the instance name of CAS service.
+        cas_service: the address of CAS service.
+        client_path: path to the CAS uploader client.
+        version: version of the CAS uploader client, in turple format.
+    """
+    cas_instance: str
+    cas_service: str
+    client_path: str
+    client_version: tuple
+
+
+@dataclasses.dataclass
+class UploadResult:
+    """Result of uploading a single artifact with CAS client.
+
+    Attributes:
+        digest: root digest of the artifact.
+        content_details: detail information of all uploaded files inside the uploaded artifact.
+    """
+    digest: str
+    content_details: list[dict[str, any]]
+    log_file: str
+
+
+@dataclasses.dataclass
+class UploadTask:
+    """Task of uploading a single artifact with CAS client."""
+    artifact: ArtifactConfig
+    path: str
+    working_dir: str
+    metrics_file: str
+
+
+UPLOADER_TIMEOUT_SECS = 600  # 10 minutes
+AVG_CHUNK_SIZE_IN_KB = 128
+DIGESTS_PATH = 'cas_digests.json'
+CONTENT_DETAILS_PATH = 'logs/cas_content_details.json'
+CHUNKED_ARTIFACT_NAME_PREFIX = "_chunked_"
+CHUNKED_DIR_ARTIFACT_NAME_PREFIX = "_chunked_dir_"
+
+
+class Uploader:
+    """Uploader for uploading artifacts to CAS remote."""
+    def __init__(self, cas_info: CasInfo):
+        """Initialize the Uploader with CAS info."""
+        self._cas_info = cas_info
+
+    @staticmethod
+    def setup_task_logger(working_dir: str) -> Tuple[logging.Logger, str]:
+        """Creates a logger for an individual uploader task."""
+        task_id = uuid.uuid4()
+        logger = logging.getLogger(f"Uploader-{task_id}")
+        logger.setLevel(logging.DEBUG)
+        logger.propagate = False
+
+        log_file = os.path.join(working_dir, f"_uploader_{task_id}.log")
+        file_handler = logging.FileHandler(log_file)
+        formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
+        file_handler.setFormatter(formatter)
+        logger.addHandler(file_handler)
+
+        return logger, log_file
+
+    @staticmethod
+    def read_file(file_path: str) -> str:
+        """Returns contents of file."""
+        try:
+            with open(file_path, "r", encoding="utf-8") as file:
+                return file.read()
+        except FileNotFoundError:
+            return f"Error: File '{file_path}' not found."
+        except Exception as e:
+            return f"Error: {e}"
+
+    @staticmethod
+    def _run_uploader_command(cmd: str, working_dir: str) -> str:
+        """"Run the uploader command using working_dir and returns the output."""
+        log_file = os.path.join(working_dir, f'_casuploader_{uuid.uuid4()}.log')
+        with open(log_file, 'w', encoding='utf8') as outfile:
+            subprocess.run(
+                cmd,
+                check=True,
+                text=True,
+                stdout=outfile,
+                stderr=subprocess.STDOUT,
+                encoding='utf-8',
+                timeout=UPLOADER_TIMEOUT_SECS
+            )
+        return Uploader.read_file(log_file)
+
+    def _upload_artifact(self,
+            artifact: ArtifactConfig,
+            working_dir: str,
+            metrics_file: str,
+    ) -> UploadResult:
+        """Upload the artifact to CAS using casuploader binary.
+
+        Args:
+        artifact: the artifact to be uploaded to CAS.
+        working_dir: the directory for intermediate files.
+        metrics_file: the metrics_file for the artifact.
+
+        Returns: the digest of the uploaded artifact, formatted as "<hash>/<size>".
+        returns None if artifact upload fails.
+        """
+        logger, log_file = Uploader.setup_task_logger(working_dir)
+
+        # `-dump-file-details` only supports on cas uploader V1.0 or later.
+        dump_file_details = self._cas_info.client_version >= (1, 0)
+        if not dump_file_details:
+            logger.warning('-dump-file-details is not enabled')
+
+        # `-dump-metrics` only supports on cas uploader V1.3 or later.
+        dump_metrics = self._cas_info.client_version >= (1, 3)
+        if not dump_metrics:
+            logger.warning('-dump-metrics is not enabled')
+
+        with tempfile.NamedTemporaryFile(mode='w+') as digest_file, tempfile.NamedTemporaryFile(
+        mode='w+') as content_details_file:
+            logger.info(
+                'Uploading %s to CAS instance %s', artifact.source_path, self._cas_info.cas_instance
+            )
+
+            cmd = [
+                self._cas_info.client_path,
+                '-cas-instance',
+                self._cas_info.cas_instance,
+                '-cas-addr',
+                self._cas_info.cas_service,
+                '-dump-digest',
+                digest_file.name,
+                '-use-adc',
+            ]
+
+            cmd = cmd + Uploader._path_flag_for_artifact(artifact)
+
+            if artifact.chunk or artifact.chunk_dir:
+                cmd = cmd + ['-chunk', '-avg-chunk-size', str(AVG_CHUNK_SIZE_IN_KB)]
+
+            for exclude_filter in artifact.exclude_filters:
+                cmd = cmd + ['-exclude-filters', exclude_filter]
+
+            if dump_file_details:
+                cmd = cmd + ['-dump-file-details', content_details_file.name]
+
+            if dump_metrics:
+                cmd = cmd + ['-dump-metrics', metrics_file]
+
+            try:
+                logger.info('Running command: %s', cmd)
+                output = Uploader._run_uploader_command(cmd, working_dir)
+                logger.info('Command output:\n %s', output)
+            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
+                logger.warning(
+                    'Failed to upload %s to CAS instance %s. Skip.\nError message: %s\nLog: %s',
+                    artifact.source_path, self._cas_info.cas_instance, e, e.stdout,
+                )
+                return None
+            except subprocess.SubprocessError as e:
+                logger.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error %s',
+                    artifact.source_path, self._cas_info.cas_instance, e)
+                return None
+
+            # Read digest of the root directory or file from dumped digest file.
+            digest = digest_file.read()
+            if digest:
+                logger.info('Uploaded %s to CAS. Digest: %s', artifact.source_path, digest)
+            else:
+                logger.warning(
+                    'No digest is dumped for file %s, the uploading may fail.',
+                    artifact.source_path,
+                )
+                return None
+
+            content_details = None
+            if dump_file_details:
+                try:
+                    content_details = json.loads(content_details_file.read())
+                except json.JSONDecodeError as e:
+                    logger.warning('Failed to parse uploaded content details: %s', e)
+
+            return UploadResult(digest, content_details, log_file)
+
+    @staticmethod
+    def _path_flag_for_artifact(artifact: ArtifactConfig) -> list[str]:
+        """Returns the path flag for the artifact."""
+        if artifact.standard:
+            return ['-zip-path' if artifact.unzip else '-file-path', artifact.source_path]
+        if artifact.chunk:
+            return ['-file-path', artifact.source_path]
+        if artifact.chunk_dir:
+            return ['-zip-path', artifact.source_path]
+        # Should neve reach here.
+        return ['-file-path', artifact.source_path]
+
+    def _output_results(
+            self,
+            output_dir: str,
+            digests: dict[str, str],
+            content_details: list[dict[str, any]],
+    ):
+        """Outputs digests and content details."""
+        digests_output = {
+            'cas_instance': self._cas_info.cas_instance,
+            'cas_service': self._cas_info.cas_service,
+            'client_version': '.'.join(map(str, self._cas_info.client_version)),
+            'files': digests,
+        }
+        output_path = os.path.join(output_dir, DIGESTS_PATH)
+        with open(output_path, 'w', encoding='utf8') as writer:
+            writer.write(json.dumps(digests_output, sort_keys=True, indent=2))
+        logging.info('Output digests to %s', output_path)
+
+        output_path = os.path.join(output_dir, CONTENT_DETAILS_PATH)
+        with open(output_path, 'w', encoding='utf8') as writer:
+            writer.write(json.dumps(content_details, sort_keys=True, indent=2))
+        logging.info('Output uploaded content details to %s', output_path)
+
+    def _upload_wrapper(self, task: UploadTask) -> Tuple[UploadResult, UploadTask]:
+        """Returns a wrapper for _upload_artifact that associates the result with the task."""
+        return self._upload_artifact(
+            task.artifact,
+            task.working_dir,
+            task.metrics_file,
+        ), task
+
+    @staticmethod
+    def _glob_wrapper(args):
+        """Wrapper function for multiprocessing"""
+        dist_dir, artifact = args
+
+        files = []
+        if artifact.source_path.startswith("./"):
+            files = glob.glob(dist_dir + artifact.source_path[1:])
+        else:
+            files = glob.glob(dist_dir + '/**/' + artifact.source_path, recursive=True)
+        return (files, artifact)
+
+    def create_upload_tasks(
+            self, artifacts: list[ArtifactConfig], working_dir: str, dist_dir: str
+    ) -> list[UploadTask]:
+        """Creates upload tasks for the artifacts."""
+        start = time.time()
+
+        tasks = []
+        skip_files = []
+        # Glob in parallel. Note that ThreadPoolExecutor doesn't help, likely due to GIL.
+        with concurrent.futures.ProcessPoolExecutor() as executor:
+            results = executor.map(
+                    Uploader._glob_wrapper,
+                    [(dist_dir, artifact) for artifact in artifacts],
+            )
+            for files, artifact in results:
+                for file in files:
+                    if os.path.isdir(file):
+                        logging.warning('Ignore artifact match (dir): %s', file)
+                        continue
+                    rel_path = Uploader._get_relative_path(dist_dir, file)
+                    for task_artifact in Uploader._artifact_variations(rel_path, artifact):
+                        path = Uploader._artifact_path(rel_path, task_artifact)
+                        if path in skip_files:
+                            continue
+                        skip_files.append(path)
+                        task_artifact.source_path = file
+                        _, task_metrics_file = tempfile.mkstemp(dir=working_dir)
+                        task = UploadTask(task_artifact, path, working_dir, task_metrics_file)
+                        tasks.append(task)
+
+        logging.info(
+                'Time of file globbing for all artifact configs: %d seconds',
+                time.time() - start,
+        )
+        return tasks
+
+    @staticmethod
+    def _print_tasks(tasks: list[UploadTask]):
+        """Outputs info for upload tasks."""
+        for task in tasks:
+            unzip = '+' if task.artifact.unzip else '-'
+            print(f"{task.path:<40} {unzip} {task.artifact.source_path}")
+        print(f"Total: {len(tasks)} files.")
+
+    def upload(self, artifacts: list[ArtifactConfig], dist_dir: str,
+               max_works: int, dryrun: bool = False) -> cas_metrics_pb2.CasMetrics:
+        """Uploads artifacts to CAS remote"""
+        file_digests = {}
+        content_details = []
+
+        cas_metrics = cas_metrics_pb2.CasMetrics()
+        with tempfile.TemporaryDirectory() as working_dir:
+            logging.info('The working dir is %s', working_dir)
+
+            tasks = self.create_upload_tasks(artifacts, working_dir, dist_dir)
+            logging.info('Uploading %d files, max workers = %d', len(tasks), max_works)
+            if dryrun:
+                Uploader._print_tasks(tasks)
+                return cas_metrics
+
+            # Upload artifacts in parallel
+            logging.info('==== Start uploading %d artifact(s) in parallel ====\n', len(tasks))
+            with concurrent.futures.ThreadPoolExecutor(max_workers=max_works) as executor:
+                futures = [executor.submit(self._upload_wrapper, task) for task in tasks]
+
+                index = 1
+                for future in concurrent.futures.as_completed(futures):
+                    result, task = future.result()
+                    if result:
+                        output = Uploader.read_file(result.log_file) if result else ''
+                        logging.info('---- %s: %s ----\n\n%s', index, task.path, output)
+                    else:
+                        logging.info('---- %s: %s ----\n\n', index, task.path)
+                    index += 1
+                    if result and result.digest:
+                        file_digests[task.path] = result.digest
+                    else:
+                        logging.warning(
+                            'Skip to save the digest of file %s, the uploading may fail',
+                            task.path,
+                        )
+                    if result and result.content_details:
+                        content_details.append({"artifact": task.path,
+                                                "details": result.content_details})
+                    else:
+                        logging.warning('Skip to save the content details of file %s', task.path)
+
+                    if os.path.exists(task.metrics_file):
+                        Uploader._add_artifact_metrics(task.metrics_file, cas_metrics)
+                        os.remove(task.metrics_file)
+            logging.info('==== Uploading of artifacts completed ====')
+
+        self._output_results(
+            dist_dir,
+            file_digests,
+            content_details,
+        )
+        return cas_metrics
+
+    @staticmethod
+    def _add_artifact_metrics(metrics_file: str, cas_metrics: cas_metrics_pb2.CasMetrics):
+        """Adds artifact metrics from metrics_file to cas_metrics."""
+        try:
+            with open(metrics_file, "r", encoding='utf8') as file:
+                json_str = file.read()  # Read the file contents here
+                if json_str:
+                    json_metrics = json.loads(json_str)
+                    cas_metrics.artifacts.append(
+                        json_format.ParseDict(json_metrics, cas_metrics_pb2.ArtifactMetrics())
+                    )
+                else:
+                    logging.exception("Empty file: %s", metrics_file)
+        except FileNotFoundError:
+            logging.exception("File not found: %s", metrics_file)
+        except json.JSONDecodeError as e:
+            logging.exception("Jason decode error: %s for json contents:\n%s", e, json_str)
+        except json_format.ParseError as e:  # Catch any other unexpected errors
+            logging.exception("Error converting Json to protobuf: %s", e)
+
+    @staticmethod
+    def _get_relative_path(dir: str, path: str) -> str:
+        """Returns the relative path from dir, falls back to basename on error."""
+        try:
+            return os.path.relpath(path, dir)
+        except ValueError as e:
+            logging.exception("Error calculating relative path: %s", e)
+            return os.path.basename(path)
+
+    @staticmethod
+    def _artifact_path(path: str, artifact: ArtifactConfig) -> str:
+        """Returns unique artifact path for saving in cas_digest.json."""
+        if artifact.chunk:
+            return CHUNKED_ARTIFACT_NAME_PREFIX + path
+        if artifact.chunk_dir:
+            return CHUNKED_DIR_ARTIFACT_NAME_PREFIX + path
+        return path
+
+    @staticmethod
+    def _artifact_variations(path: str, artifact: ArtifactConfig) -> list[ArtifactConfig]:
+        """Returns variations of the artifact for upload based on artifact attributes."""
+        variations = []
+        if artifact.standard:
+            variations.append(ArtifactConfig(path, artifact.unzip, True, False, False,
+                                            exclude_filters=artifact.exclude_filters))
+        if artifact.chunk:
+            variations.append(ArtifactConfig(path, False, False, True, False,
+                                            exclude_filters=artifact.exclude_filters))
+        if artifact.chunk_dir:
+            variations.append(ArtifactConfig(path, True, False, False, True,
+                                            exclude_filters=artifact.exclude_filters))
+        return variations
```

